{"sha": "328b47d83720f011cb1c95685c3e7df8195efbd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOGI0N2Q4MzcyMGYwMTFjYjFjOTU2ODVjM2U3ZGY4MTk1ZWZiZDM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-25T18:10:33Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@palantir.com", "date": "2014-01-16T23:01:48Z"}, "message": "Load macros from external modules", "tree": {"sha": "b370ba6b6fa4ef5d88ca4b1f1e7739be81381f10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b370ba6b6fa4ef5d88ca4b1f1e7739be81381f10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/328b47d83720f011cb1c95685c3e7df8195efbd3", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/328b47d83720f011cb1c95685c3e7df8195efbd3", "html_url": "https://github.com/rust-lang/rust/commit/328b47d83720f011cb1c95685c3e7df8195efbd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/328b47d83720f011cb1c95685c3e7df8195efbd3/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "html_url": "https://github.com/rust-lang/rust/commit/a5ed0c58cb9f38af940403c34e283b68c89f5aa2"}], "stats": {"total": 1078, "additions": 873, "deletions": 205}, "files": [{"sha": "fa99b89c252be59248333797f315df4f7b9c0380", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -90,10 +90,14 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     fn xfail_target(config: &config) -> ~str {\n         ~\"xfail-\" + util::get_os(config.target)\n     }\n+    fn xfail_stage(config: &config) -> ~str {\n+        ~\"xfail-\" + config.stage_id.split('-').next().unwrap()\n+    }\n \n     let val = iter_header(testfile, |ln| {\n         if parse_name_directive(ln, \"xfail-test\") { false }\n         else if parse_name_directive(ln, xfail_target(config)) { false }\n+        else if parse_name_directive(ln, xfail_stage(config)) { false }\n         else if config.mode == common::mode_pretty &&\n             parse_name_directive(ln, \"xfail-pretty\") { false }\n         else { true }"}, {"sha": "7e13bd2fcf10f188b674e8bf9c2f03ec37879c58", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -20,6 +20,7 @@ use lib::llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::{creader, filesearch};\n use metadata::cstore::CStore;\n+use metadata::creader::Loader;\n use metadata;\n use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n@@ -41,6 +42,7 @@ use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::codemap;\n use syntax::diagnostic;\n+use syntax::ext::base::CrateLoader;\n use syntax::parse;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n@@ -163,6 +165,7 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n /// standard library and prelude.\n pub fn phase_2_configure_and_expand(sess: Session,\n                                     cfg: ast::CrateConfig,\n+                                    loader: &mut CrateLoader,\n                                     mut crate: ast::Crate)\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n@@ -188,9 +191,14 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     crate = time(time_passes, \"configuration 1\", crate, |crate|\n                  front::config::strip_unconfigured_items(crate));\n \n-    crate = time(time_passes, \"expansion\", crate, |crate|\n-                 syntax::ext::expand::expand_crate(sess.parse_sess, cfg.clone(),\n-                                                   crate));\n+    crate = time(time_passes, \"expansion\", crate, |crate| {\n+        syntax::ext::expand::expand_crate(sess.parse_sess,\n+                                          loader,\n+                                          cfg.clone(),\n+                                          crate)\n+    });\n+    // dump the syntax-time crates\n+    sess.cstore.reset();\n \n     // strip again, in case expansion added anything with a #[cfg].\n     crate = time(time_passes, \"configuration 2\", crate, |crate|\n@@ -248,6 +256,11 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, \"looking for entry point\", (),\n          |_| middle::entry::find_entry_point(sess, crate, ast_map));\n \n+    sess.macro_registrar_fn.with_mut(|r| *r =\n+        time(time_passes, \"looking for macro registrar\", (), |_|\n+            syntax::ext::registrar::find_macro_registrar(\n+                sess.span_diagnostic, crate)));\n+\n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n                         freevars::annotate_freevars(def_map, crate));\n \n@@ -491,7 +504,8 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n         let (expanded_crate, ast_map) = {\n             let crate = phase_1_parse_input(sess, cfg.clone(), input);\n             if stop_after_phase_1(sess) { return; }\n-            phase_2_configure_and_expand(sess, cfg, crate)\n+            let loader = &mut Loader::new(sess);\n+            phase_2_configure_and_expand(sess, cfg, loader, crate)\n         };\n         let outputs = build_output_filenames(input, outdir, output,\n                                              expanded_crate.attrs, sess);\n@@ -579,7 +593,8 @@ pub fn pretty_print_input(sess: Session,\n \n     let (crate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n-            let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, crate);\n+            let loader = &mut Loader::new(sess);\n+            let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, loader, crate);\n             (crate, Some(ast_map), true)\n         }\n         _ => (crate, None, false)\n@@ -912,6 +927,7 @@ pub fn build_session_(sopts: @session::options,\n         // For a library crate, this is always none\n         entry_fn: RefCell::new(None),\n         entry_type: Cell::new(None),\n+        macro_registrar_fn: RefCell::new(None),\n         span_diagnostic: span_diagnostic_handler,\n         filesearch: filesearch,\n         building_library: Cell::new(false),"}, {"sha": "abebfc614a8fbc7ad18b688430fd07ab73475d76", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -210,6 +210,7 @@ pub struct Session_ {\n     entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     entry_type: Cell<Option<EntryFnType>>,\n     span_diagnostic: @diagnostic::SpanHandler,\n+    macro_registrar_fn: RefCell<Option<ast::DefId>>,\n     filesearch: @filesearch::FileSearch,\n     building_library: Cell<bool>,\n     working_dir: Path,"}, {"sha": "d51f3e3f037c1414cf9b69b79f2555d1e3315103", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -43,6 +43,8 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"non_ascii_idents\", Active),\n     (\"thread_local\", Active),\n     (\"link_args\", Active),\n+    (\"phase\", Active),\n+    (\"macro_registrar\", Active),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n@@ -114,7 +116,15 @@ impl Visitor<()> for Context {\n                     }\n                 }\n             }\n-            _ => {}\n+            ast::ViewItemExternMod(..) => {\n+                for attr in i.attrs.iter() {\n+                    if \"phase\" == attr.name() {\n+                        self.gate_feature(\"phase\", attr.span,\n+                                          \"compile time crate loading is \\\n+                                           experimental and possibly buggy\");\n+                    }\n+                }\n+            }\n         }\n         visit::walk_view_item(self, i, ())\n     }\n@@ -151,6 +161,14 @@ impl Visitor<()> for Context {\n                 }\n             }\n \n+            ast::ItemFn(..) => {\n+                if attr::contains_name(i.attrs, \"macro_registrar\") {\n+                    self.gate_feature(\"macro_registrar\", i.span,\n+                                      \"cross-crate macro exports are \\\n+                                       experimental and possibly buggy\");\n+                }\n+            }\n+\n             _ => {}\n         }\n "}, {"sha": "95bf171562d2fc5c112ed64d0ddb24efcaaf8331", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -14,6 +14,7 @@\n use driver::session;\n use front::config;\n use front::std_inject::with_version;\n+use metadata::creader::Loader;\n \n use std::cell::RefCell;\n use std::vec;\n@@ -38,10 +39,10 @@ struct Test {\n     should_fail: bool\n }\n \n-struct TestCtxt {\n+struct TestCtxt<'a> {\n     sess: session::Session,\n     path: RefCell<~[ast::Ident]>,\n-    ext_cx: ExtCtxt,\n+    ext_cx: ExtCtxt<'a>,\n     testfns: RefCell<~[Test]>,\n     is_extra: bool,\n     config: ast::CrateConfig,\n@@ -63,11 +64,11 @@ pub fn modify_for_testing(sess: session::Session,\n     }\n }\n \n-struct TestHarnessGenerator {\n-    cx: TestCtxt,\n+struct TestHarnessGenerator<'a> {\n+    cx: TestCtxt<'a>,\n }\n \n-impl fold::Folder for TestHarnessGenerator {\n+impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n         let folded = fold::noop_fold_crate(c, self);\n \n@@ -155,9 +156,10 @@ impl fold::Folder for TestHarnessGenerator {\n \n fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n                          -> ast::Crate {\n+    let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(), loader),\n         path: RefCell::new(~[]),\n         testfns: RefCell::new(~[]),\n         is_extra: is_extra(&crate),"}, {"sha": "09531e80ae59cf1d038f609195102ce8aa1c2800", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -204,6 +204,10 @@ pub static tag_native_libraries_lib: uint = 0x104;\n pub static tag_native_libraries_name: uint = 0x105;\n pub static tag_native_libraries_kind: uint = 0x106;\n \n+pub static tag_macro_registrar_fn: uint = 0x110;\n+pub static tag_exported_macros: uint = 0x111;\n+pub static tag_macro_def: uint = 0x112;\n+\n #[deriving(Clone)]\n pub struct LinkMeta {\n     crateid: CrateId,"}, {"sha": "1d992833112063ac9be5b0dfc74e102a6f2965d6", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 105, "deletions": 30, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -10,10 +10,13 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n+use driver::{driver, session};\n use driver::session::Session;\n+use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::loader;\n+use metadata::loader::Os;\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n@@ -23,6 +26,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::diagnostic::SpanHandler;\n+use syntax::ext::base::{CrateLoader, MacroCrate};\n use syntax::parse::token;\n use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n@@ -131,37 +135,65 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n }\n \n fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n+    let should_load = i.attrs.iter().all(|attr| {\n+        \"phase\" != attr.name() ||\n+            attr.meta_item_list().map_or(false, |phases| {\n+                attr::contains_name(phases, \"link\")\n+            })\n+    });\n+\n+    if !should_load {\n+        return;\n+    }\n+\n+    match extract_crate_info(i) {\n+        Some(info) => {\n+            let cnum = resolve_crate(e, info.ident, info.name, info.version,\n+                                     @\"\", i.span);\n+            e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+        }\n+        None => ()\n+    }\n+}\n+\n+struct CrateInfo {\n+    ident: @str,\n+    name: @str,\n+    version: @str,\n+    id: ast::NodeId,\n+}\n+\n+fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n-      ast::ViewItemExternMod(ident, path_opt, id) => {\n-          let ident = token::ident_to_str(&ident);\n-          debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n-                 ident, path_opt);\n-          let (name, version) = match path_opt {\n-              Some((path_str, _)) => {\n-                  let crateid: Option<CrateId> = from_str(path_str);\n-                  match crateid {\n-                      None => (@\"\", @\"\"),\n-                      Some(crateid) => {\n-                          let version = match crateid.version {\n-                              None => @\"\",\n-                              Some(ref ver) => ver.to_managed(),\n-                          };\n-                          (crateid.name.to_managed(), version)\n-                      }\n-                  }\n-              }\n-              None => (ident, @\"\"),\n-          };\n-          let cnum = resolve_crate(e,\n-                                   ident,\n-                                   name,\n-                                   version,\n-                                   @\"\",\n-                                   i.span);\n-          e.sess.cstore.add_extern_mod_stmt_cnum(id, cnum);\n-      }\n-      _ => ()\n-  }\n+        ast::ViewItemExternMod(ident, path_opt, id) => {\n+            let ident = token::ident_to_str(&ident);\n+            debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n+                   ident, path_opt);\n+            let (name, version) = match path_opt {\n+                Some((path_str, _)) => {\n+                    let crateid: Option<CrateId> = from_str(path_str);\n+                    match crateid {\n+                        None => (@\"\", @\"\"),\n+                        Some(crateid) => {\n+                            let version = match crateid.version {\n+                                None => @\"\",\n+                                Some(ref ver) => ver.to_managed(),\n+                            };\n+                            (crateid.name.to_managed(), version)\n+                        }\n+                    }\n+                }\n+                None => (ident, @\"\"),\n+            };\n+            Some(CrateInfo {\n+                  ident: ident,\n+                  name: name,\n+                  version: version,\n+                  id: id,\n+            })\n+        }\n+        _ => None\n+    }\n }\n \n fn visit_item(e: &Env, i: &ast::Item) {\n@@ -355,3 +387,46 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n     }\n     return @RefCell::new(cnum_map);\n }\n+\n+pub struct Loader {\n+    priv env: Env,\n+}\n+\n+impl Loader {\n+    pub fn new(sess: Session) -> Loader {\n+        let os = driver::get_os(driver::host_triple()).unwrap();\n+        let os = session::sess_os_to_meta_os(os);\n+        Loader {\n+            env: Env {\n+                sess: sess,\n+                os: os,\n+                crate_cache: @RefCell::new(~[]),\n+                next_crate_num: 1,\n+                intr: token::get_ident_interner(),\n+            }\n+        }\n+    }\n+}\n+\n+impl CrateLoader for Loader {\n+    fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate {\n+        let info = extract_crate_info(crate).unwrap();\n+        let cnum = resolve_crate(&mut self.env, info.ident, info.name,\n+                                 info.version, @\"\", crate.span);\n+        let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n+        MacroCrate {\n+            lib: library.dylib,\n+            cnum: cnum\n+        }\n+    }\n+\n+    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> ~[@ast::Item] {\n+        csearch::get_exported_macros(self.env.sess.cstore, cnum)\n+    }\n+\n+    fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n+        let cstore = self.env.sess.cstore;\n+        csearch::get_macro_registrar_fn(cstore, cnum)\n+            .map(|did| csearch::get_symbol(cstore, did))\n+    }\n+}"}, {"sha": "9955186da462faaef9b1e75c409f504183539830", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -301,3 +301,16 @@ pub fn get_trait_of_method(cstore: @cstore::CStore,\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)\n }\n \n+pub fn get_macro_registrar_fn(cstore: @cstore::CStore,\n+                              crate_num: ast::CrateNum)\n+                              -> Option<ast::DefId> {\n+    let cdata = cstore.get_crate_data(crate_num);\n+    decoder::get_macro_registrar_fn(cdata)\n+}\n+\n+pub fn get_exported_macros(cstore: @cstore::CStore,\n+                           crate_num: ast::CrateNum)\n+                           -> ~[@ast::Item] {\n+    let cdata = cstore.get_crate_data(crate_num);\n+    decoder::get_exported_macros(cdata)\n+}"}, {"sha": "024e214a2fe716d453e34ab4b99170669c349e32", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -53,7 +53,7 @@ pub enum NativeLibaryKind {\n \n // Where a crate came from on the local filesystem. One of these two options\n // must be non-None.\n-#[deriving(Eq)]\n+#[deriving(Eq, Clone)]\n pub struct CrateSource {\n     dylib: Option<Path>,\n     rlib: Option<Path>,\n@@ -123,6 +123,21 @@ impl CStore {\n         }\n     }\n \n+    pub fn get_used_crate_source(&self, cnum: ast::CrateNum)\n+                                     -> Option<CrateSource> {\n+        let mut used_crate_sources = self.used_crate_sources.borrow_mut();\n+        used_crate_sources.get().iter().find(|source| source.cnum == cnum)\n+            .map(|source| source.clone())\n+    }\n+\n+    pub fn reset(&self) {\n+        self.metas.with_mut(|s| s.clear());\n+        self.extern_mod_crate_map.with_mut(|s| s.clear());\n+        self.used_crate_sources.with_mut(|s| s.clear());\n+        self.used_libraries.with_mut(|s| s.clear());\n+        self.used_link_args.with_mut(|s| s.clear());\n+    }\n+\n     pub fn get_used_crates(&self, prefer: LinkagePreference)\n                            -> ~[(ast::CrateNum, Option<Path>)] {\n         let used_crate_sources = self.used_crate_sources.borrow();"}, {"sha": "abf5b051c7de7342d7cffabb554f1550d29e415f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -23,6 +23,7 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n+use middle::astencode;\n use middle::astencode::vtable_decoder_helpers;\n \n use std::at_vec;\n@@ -1275,3 +1276,19 @@ pub fn get_native_libraries(cdata: Cmd) -> ~[(cstore::NativeLibaryKind, ~str)] {\n     });\n     return result;\n }\n+\n+pub fn get_macro_registrar_fn(cdata: Cmd) -> Option<ast::DefId> {\n+    reader::maybe_get_doc(reader::Doc(cdata.data()), tag_macro_registrar_fn)\n+        .map(|doc| item_def_id(doc, cdata))\n+}\n+\n+pub fn get_exported_macros(cdata: Cmd) -> ~[@ast::Item] {\n+    let macros = reader::get_doc(reader::Doc(cdata.data()),\n+                                 tag_exported_macros);\n+    let mut result = ~[];\n+    reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n+        result.push(astencode::decode_exported_macro(macro_doc));\n+        true\n+    });\n+    result\n+}"}, {"sha": "c55318f9e5ac270e66a1d1d8e0a6ba0673fcfa3a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 74, "deletions": 12, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -79,6 +79,8 @@ struct Stats {\n     dep_bytes: Cell<u64>,\n     lang_item_bytes: Cell<u64>,\n     native_lib_bytes: Cell<u64>,\n+    macro_registrar_fn_bytes: Cell<u64>,\n+    macro_defs_bytes: Cell<u64>,\n     impl_bytes: Cell<u64>,\n     misc_bytes: Cell<u64>,\n     item_bytes: Cell<u64>,\n@@ -1287,7 +1289,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n-      ItemMac(..) => fail!(\"item macros unimplemented\")\n+      ItemMac(..) => {\n+        // macros are encoded separately\n+      }\n     }\n }\n \n@@ -1691,6 +1695,50 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n+fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n+    let ptr = ecx.tcx.sess.macro_registrar_fn.borrow();\n+    match *ptr.get() {\n+        Some(did) => {\n+            ebml_w.start_tag(tag_macro_registrar_fn);\n+            encode_def_id(ebml_w, did);\n+            ebml_w.end_tag();\n+        }\n+        None => {}\n+    }\n+}\n+\n+struct MacroDefVisitor<'a, 'b> {\n+    ecx: &'a EncodeContext<'a>,\n+    ebml_w: &'a mut writer::Encoder<'b>\n+}\n+\n+impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n+    fn visit_item(&mut self, item: &Item, _: ()) {\n+        match item.node {\n+            ItemMac(..) => {\n+                self.ebml_w.start_tag(tag_macro_def);\n+                astencode::encode_exported_macro(self.ebml_w, item);\n+                self.ebml_w.end_tag();\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn encode_macro_defs(ecx: &EncodeContext,\n+                     crate: &Crate,\n+                     ebml_w: &mut writer::Encoder) {\n+    ebml_w.start_tag(tag_exported_macros);\n+    {\n+        let mut visitor = MacroDefVisitor {\n+            ecx: ecx,\n+            ebml_w: ebml_w,\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n+    ebml_w.end_tag();\n+}\n+\n struct ImplVisitor<'a,'b> {\n     ecx: &'a EncodeContext<'a>,\n     ebml_w: &'a mut writer::Encoder<'b>,\n@@ -1815,6 +1863,8 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n         dep_bytes: Cell::new(0),\n         lang_item_bytes: Cell::new(0),\n         native_lib_bytes: Cell::new(0),\n+        macro_registrar_fn_bytes: Cell::new(0),\n+        macro_defs_bytes: Cell::new(0),\n         impl_bytes: Cell::new(0),\n         misc_bytes: Cell::new(0),\n         item_bytes: Cell::new(0),\n@@ -1873,6 +1923,16 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n     encode_native_libraries(&ecx, &mut ebml_w);\n     ecx.stats.native_lib_bytes.set(ebml_w.writer.tell() - i);\n \n+    // Encode the macro registrar function\n+    i = ebml_w.writer.tell();\n+    encode_macro_registrar_fn(&ecx, &mut ebml_w);\n+    ecx.stats.macro_registrar_fn_bytes.set(ebml_w.writer.tell() - i);\n+\n+    // Encode macro definitions\n+    i = ebml_w.writer.tell();\n+    encode_macro_defs(&ecx, crate, &mut ebml_w);\n+    ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell() - i);\n+\n     // Encode the def IDs of impls, for coherence checking.\n     i = ebml_w.writer.tell();\n     encode_impls(&ecx, crate, &mut ebml_w);\n@@ -1905,17 +1965,19 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n         }\n \n         println!(\"metadata stats:\");\n-        println!(\"    inline bytes: {}\", ecx.stats.inline_bytes.get());\n-        println!(\" attribute bytes: {}\", ecx.stats.attr_bytes.get());\n-        println!(\"       dep bytes: {}\", ecx.stats.dep_bytes.get());\n-        println!(\" lang item bytes: {}\", ecx.stats.lang_item_bytes.get());\n-        println!(\"    native bytes: {}\", ecx.stats.native_lib_bytes.get());\n-        println!(\"      impl bytes: {}\", ecx.stats.impl_bytes.get());\n-        println!(\"      misc bytes: {}\", ecx.stats.misc_bytes.get());\n-        println!(\"      item bytes: {}\", ecx.stats.item_bytes.get());\n-        println!(\"     index bytes: {}\", ecx.stats.index_bytes.get());\n-        println!(\"      zero bytes: {}\", ecx.stats.zero_bytes.get());\n-        println!(\"     total bytes: {}\", ecx.stats.total_bytes.get());\n+        println!(\"         inline bytes: {}\", ecx.stats.inline_bytes.get());\n+        println!(\"      attribute bytes: {}\", ecx.stats.attr_bytes.get());\n+        println!(\"            dep bytes: {}\", ecx.stats.dep_bytes.get());\n+        println!(\"      lang item bytes: {}\", ecx.stats.lang_item_bytes.get());\n+        println!(\"         native bytes: {}\", ecx.stats.native_lib_bytes.get());\n+        println!(\"macro registrar bytes: {}\", ecx.stats.macro_registrar_fn_bytes.get());\n+        println!(\"      macro def bytes: {}\", ecx.stats.macro_defs_bytes.get());\n+        println!(\"           impl bytes: {}\", ecx.stats.impl_bytes.get());\n+        println!(\"           misc bytes: {}\", ecx.stats.misc_bytes.get());\n+        println!(\"           item bytes: {}\", ecx.stats.item_bytes.get());\n+        println!(\"          index bytes: {}\", ecx.stats.index_bytes.get());\n+        println!(\"           zero bytes: {}\", ecx.stats.zero_bytes.get());\n+        println!(\"          total bytes: {}\", ecx.stats.total_bytes.get());\n     }\n }\n "}, {"sha": "3e0436a8ec2ff2550a7c459f9aa73a8930b00aee", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -107,6 +107,13 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n+pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n+    match i.node {\n+        ast::ItemMac(..) => encode_ast(ebml_w, ast::IIItem(@i.clone())),\n+        _ => fail!(\"expected a macro\")\n+    }\n+}\n+\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n@@ -159,6 +166,13 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n     }\n }\n \n+pub fn decode_exported_macro(par_doc: ebml::Doc) -> @ast::Item {\n+    match decode_ast(par_doc) {\n+        ast::IIItem(item) => item,\n+        _ => fail!(\"expected item\")\n+    }\n+}\n+\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n "}, {"sha": "098e4154e17485861fe8344a2bde7ef1d829e295", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -924,15 +924,16 @@ static other_attrs: &'static [&'static str] = &[\n     \"allow\", \"deny\", \"forbid\", \"warn\", // lint options\n     \"deprecated\", \"experimental\", \"unstable\", \"stable\", \"locked\", \"frozen\", //item stability\n     \"crate_map\", \"cfg\", \"doc\", \"export_name\", \"link_section\", \"no_freeze\",\n-    \"no_mangle\", \"no_send\", \"static_assert\", \"unsafe_no_drop_flag\",\n-    \"packed\", \"simd\", \"repr\", \"deriving\", \"unsafe_destructor\", \"link\",\n+    \"no_mangle\", \"no_send\", \"static_assert\", \"unsafe_no_drop_flag\", \"packed\",\n+    \"simd\", \"repr\", \"deriving\", \"unsafe_destructor\", \"link\", \"phase\",\n+    \"macro_export\",\n \n     //mod-level\n     \"path\", \"link_name\", \"link_args\", \"nolink\", \"macro_escape\", \"no_implicit_prelude\",\n \n     // fn-level\n     \"test\", \"bench\", \"should_fail\", \"ignore\", \"inline\", \"lang\", \"main\", \"start\",\n-    \"no_split_stack\", \"cold\",\n+    \"no_split_stack\", \"cold\", \"macro_registrar\",\n \n     // internal attribute: bypass privacy inside items\n     \"!resolve_unexported\","}, {"sha": "2d1c5b1b4e7030a554d1aadcefd22e8c8389615e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -1400,10 +1400,7 @@ impl Resolver {\n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n                 new_parent\n             }\n-\n-            ItemMac(..) => {\n-                fail!(\"item macros unimplemented\")\n-            }\n+            ItemMac(..) => parent\n         }\n     }\n \n@@ -3804,9 +3801,9 @@ impl Resolver {\n                 });\n             }\n \n-            ItemMac(..) => {\n-                fail!(\"item macros unimplemented\")\n-            }\n+           ItemMac(..) => {\n+                // do nothing, these are just around to be encoded\n+           }\n         }\n     }\n "}, {"sha": "f9193c4f73c2a2bed937da44a2f4947945489d19", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -560,7 +560,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"convert: item {} with id {}\", tcx.sess.str_of(it.ident), it.id);\n     match it.node {\n       // These don't define types.\n-      ast::ItemForeignMod(_) | ast::ItemMod(_) => {}\n+      ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n       ast::ItemEnum(ref enum_definition, ref generics) => {\n           ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n           let tpt = ty_of_item(ccx, it);\n@@ -913,8 +913,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return tpt;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n-        ast::ItemForeignMod(_) => fail!(),\n-        ast::ItemMac(..) => fail!(\"item macros unimplemented\")\n+        ast::ItemForeignMod(_) | ast::ItemMac(_) => fail!(),\n     }\n }\n "}, {"sha": "e2205e12986b90b4c3e42ac7a3cf09ffb37fdca2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -10,6 +10,7 @@\n \n use rustc;\n use rustc::{driver, middle};\n+use rustc::metadata::creader::Loader;\n use rustc::middle::privacy;\n \n use syntax::ast;\n@@ -74,7 +75,8 @@ fn get_ast_and_resolve(cpath: &Path,\n     }\n \n     let crate = phase_1_parse_input(sess, cfg.clone(), &input);\n-    let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, crate);\n+    let loader = &mut Loader::new(sess);\n+    let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, loader, crate);\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &crate, ast_map);"}, {"sha": "ffc8388ee90778c3d6035063fe7b3c547a7d73e3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -20,6 +20,7 @@ use extra::getopts;\n use extra::test;\n use rustc::driver::driver;\n use rustc::driver::session;\n+use rustc::metadata::creader::Loader;\n use syntax::diagnostic;\n use syntax::parse;\n \n@@ -58,7 +59,8 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n \n     let cfg = driver::build_configuration(sess);\n     let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    let (crate, _) = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+    let loader = &mut Loader::new(sess);\n+    let (crate, _) = driver::phase_2_configure_and_expand(sess, cfg, loader, crate);\n \n     let ctx = @core::DocContext {\n         crate: crate,"}, {"sha": "ab6f87c5a9d62a0bd88d9129d7916fbc2f92b4a7", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -28,6 +28,7 @@ pub use std::path::Path;\n \n use extra::workcache;\n use rustc::driver::{driver, session};\n+use rustc::metadata::creader::Loader;\n use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use rustc::util::sha2;\n@@ -118,7 +119,11 @@ impl<'a> PkgScript<'a> {\n                                             @diagnostic::Emitter);\n         let cfg = driver::build_configuration(sess);\n         let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-        let crate_and_map = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n+        let loader = &mut Loader::new(sess);\n+        let crate_and_map = driver::phase_2_configure_and_expand(sess,\n+                                                         cfg.clone(),\n+                                                         loader,\n+                                                         crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id {}\", id.to_str());"}, {"sha": "e530853725067dfc08cc232f711a37487dbbb363", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 75, "deletions": 45, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -16,11 +16,13 @@ use std::os;\n use std::io;\n use std::io::fs;\n use extra::workcache;\n+use rustc::metadata::creader::Loader;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n use syntax;\n use syntax::codemap::{DUMMY_SP, Spanned};\n-use syntax::ext::base::ExtCtxt;\n+use syntax::ext::base;\n+use syntax::ext::base::{ExtCtxt, MacroCrate};\n use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::Folder;\n@@ -63,9 +65,9 @@ struct ListenerFn {\n     path: ~[ast::Ident]\n }\n \n-struct ReadyCtx {\n+struct ReadyCtx<'a> {\n     sess: session::Session,\n-    ext_cx: ExtCtxt,\n+    ext_cx: ExtCtxt<'a>,\n     path: ~[ast::Ident],\n     fns: ~[ListenerFn]\n }\n@@ -130,7 +132,7 @@ fn fold_item(item: @ast::Item, fold: &mut CrateSetup)\n }\n \n struct CrateSetup<'a> {\n-    ctx: &'a mut ReadyCtx,\n+    ctx: &'a mut ReadyCtx<'a>,\n }\n \n impl<'a> fold::Folder for CrateSetup<'a> {\n@@ -145,9 +147,10 @@ impl<'a> fold::Folder for CrateSetup<'a> {\n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n                    crate: ast::Crate) -> ast::Crate {\n+    let loader = &mut Loader::new(sess);\n     let mut ctx = ReadyCtx {\n         sess: sess,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(), loader),\n         path: ~[],\n         fns: ~[]\n     };\n@@ -269,23 +272,41 @@ pub fn compile_input(context: &BuildContext,\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess);\n     let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    let (mut crate, ast_map) = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n-\n-    debug!(\"About to call find_and_install_dependencies...\");\n-\n-    find_and_install_dependencies(context, pkg_id, in_file, sess, exec, &crate, deps,\n-                                  |p| {\n-                                      debug!(\"a dependency: {}\", p.display());\n-                                      let mut addl_lib_search_paths =\n-                                        addl_lib_search_paths.borrow_mut();\n-                                      let addl_lib_search_paths =\n-                                        addl_lib_search_paths.get();\n-                                      let mut addl_lib_search_paths =\n-                                        addl_lib_search_paths.borrow_mut();\n-                                      // Pass the directory containing a dependency\n-                                      // as an additional lib search path\n-                                      addl_lib_search_paths.get().insert(p);\n-                                  });\n+\n+    let (mut crate, ast_map) = {\n+        let installer = CrateInstaller {\n+            context: context,\n+            parent: pkg_id,\n+            parent_crate: in_file,\n+            sess: sess,\n+            exec: exec,\n+            deps: deps,\n+            save: |p| {\n+                debug!(\"a dependency: {}\", p.display());\n+                let mut addl_lib_search_paths =\n+                    addl_lib_search_paths.borrow_mut();\n+                let addl_lib_search_paths =\n+                    addl_lib_search_paths.get();\n+                let mut addl_lib_search_paths =\n+                    addl_lib_search_paths.borrow_mut();\n+                // Pass the directory containing a dependency\n+                // as an additional lib search path\n+                addl_lib_search_paths.get().insert(p);\n+            },\n+        };\n+        let mut loader = CrateLoader {\n+            installer: installer,\n+            loader: Loader::new(sess),\n+        };\n+        let (crate, ast_map) = driver::phase_2_configure_and_expand(sess,\n+                                                     cfg.clone(),\n+                                                     &mut loader,\n+                                                     crate);\n+        let CrateLoader { mut installer, .. } = loader;\n+        debug!(\"About to call find_and_install_dependencies...\");\n+        find_and_install_dependencies(&mut installer, &crate);\n+        (crate, ast_map)\n+    };\n \n     // Inject the crate_id attribute so we get the right package name and version\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n@@ -430,19 +451,18 @@ pub fn compile_crate(ctxt: &BuildContext,\n     compile_input(ctxt, exec, pkg_id, crate, workspace, deps, flags, cfgs, opt, what)\n }\n \n-struct ViewItemVisitor<'a> {\n+struct CrateInstaller<'a> {\n     context: &'a BuildContext,\n     parent: &'a CrateId,\n     parent_crate: &'a Path,\n     sess: session::Session,\n     exec: &'a mut workcache::Exec,\n-    c: &'a ast::Crate,\n     save: 'a |Path|,\n     deps: &'a mut DepMap\n }\n \n-impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::ViewItem, env: ()) {\n+impl<'a> CrateInstaller<'a> {\n+    fn install_crate(&mut self, vi: &ast::ViewItem) {\n         use conditions::nonexistent_package::cond;\n \n         match vi.node {\n@@ -585,33 +605,43 @@ impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n             // Ignore `use`s\n             _ => ()\n         }\n+    }\n+}\n+\n+impl<'a> Visitor<()> for CrateInstaller<'a> {\n+    fn visit_view_item(&mut self, vi: &ast::ViewItem, env: ()) {\n+        self.install_crate(vi);\n         visit::walk_view_item(self, vi, env)\n     }\n }\n \n+struct CrateLoader<'a> {\n+    installer: CrateInstaller<'a>,\n+    loader: Loader,\n+}\n+\n+impl<'a> base::CrateLoader for CrateLoader<'a> {\n+    fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate {\n+        self.installer.install_crate(crate);\n+        self.loader.load_crate(crate)\n+    }\n+\n+    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> ~[@ast::Item] {\n+        self.loader.get_exported_macros(cnum)\n+    }\n+\n+    fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n+        self.loader.get_registrar_symbol(cnum)\n+    }\n+}\n+\n /// Collect all `extern mod` directives in `c`, then\n /// try to install their targets, failing if any target\n /// can't be found.\n-pub fn find_and_install_dependencies(context: &BuildContext,\n-                                     parent: &CrateId,\n-                                     parent_crate: &Path,\n-                                     sess: session::Session,\n-                                     exec: &mut workcache::Exec,\n-                                     c: &ast::Crate,\n-                                     deps: &mut DepMap,\n-                                     save: |Path|) {\n+pub fn find_and_install_dependencies(installer: &mut CrateInstaller,\n+                                     c: &ast::Crate) {\n     debug!(\"In find_and_install_dependencies...\");\n-    let mut visitor = ViewItemVisitor {\n-        context: context,\n-        parent: parent,\n-        parent_crate: parent_crate,\n-        sess: sess,\n-        exec: exec,\n-        c: c,\n-        save: save,\n-        deps: deps\n-    };\n-    visit::walk_crate(&mut visitor, c, ())\n+    visit::walk_crate(installer, c, ())\n }\n \n pub fn mk_string_lit(s: @str) -> ast::Lit {"}, {"sha": "ef6d154c651a3655d8eb06de161dc59046fd73c4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 49, "deletions": 62, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -20,6 +20,7 @@ use parse::token::{ident_to_str, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n+use std::unstable::dynamic_lib::DynamicLibrary;\n \n // new-style macro! tt code:\n //\n@@ -120,6 +121,9 @@ pub type SyntaxExpanderTTItemFun =\n pub type SyntaxExpanderTTItemFunNoCtxt =\n     fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::TokenTree]) -> MacResult;\n \n+pub type MacroCrateRegistrationFun =\n+    extern \"Rust\" fn(|ast::Name, SyntaxExtension|);\n+\n pub trait AnyMacro {\n     fn make_expr(&self) -> @ast::Expr;\n     fn make_items(&self) -> SmallVector<@ast::Item>;\n@@ -151,24 +155,21 @@ pub enum SyntaxExtension {\n     IdentTT(~SyntaxExpanderTTItemTrait:'static, Option<Span>),\n }\n \n-\n-// The SyntaxEnv is the environment that's threaded through the expansion\n-// of macros. It contains bindings for macros, and also a special binding\n-// for \" block\" (not a legal identifier) that maps to a BlockInfo\n-pub type SyntaxEnv = MapChain<Name, SyntaxExtension>;\n-\n pub struct BlockInfo {\n     // should macros escape from this scope?\n     macros_escape : bool,\n     // what are the pending renames?\n-    pending_renames : RenameList\n+    pending_renames : RenameList,\n+    // references for crates loaded in this scope\n+    macro_crates: ~[DynamicLibrary],\n }\n \n impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n-            pending_renames: ~[]\n+            pending_renames: ~[],\n+            macro_crates: ~[],\n         }\n     }\n }\n@@ -189,7 +190,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n         None)\n     }\n \n-    let mut syntax_expanders = MapChain::new();\n+    let mut syntax_expanders = SyntaxEnv::new();\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n                             IdentTT(~SyntaxExpanderTTItem {\n                                 expander: SyntaxExpanderTTItemExpanderWithContext(\n@@ -280,25 +281,38 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders\n }\n \n+pub struct MacroCrate {\n+    lib: Option<Path>,\n+    cnum: ast::CrateNum,\n+}\n+\n+pub trait CrateLoader {\n+    fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate;\n+    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> ~[@ast::Item];\n+    fn get_registrar_symbol(&mut self, crate_num: ast::CrateNum) -> Option<~str>;\n+}\n+\n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n-pub struct ExtCtxt {\n+pub struct ExtCtxt<'a> {\n     parse_sess: @parse::ParseSess,\n     cfg: ast::CrateConfig,\n     backtrace: Option<@ExpnInfo>,\n+    loader: &'a mut CrateLoader,\n \n     mod_path: ~[ast::Ident],\n     trace_mac: bool\n }\n \n-impl ExtCtxt {\n-    pub fn new(parse_sess: @parse::ParseSess, cfg: ast::CrateConfig)\n-               -> ExtCtxt {\n+impl<'a> ExtCtxt<'a> {\n+    pub fn new<'a>(parse_sess: @parse::ParseSess, cfg: ast::CrateConfig,\n+               loader: &'a mut CrateLoader) -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n             backtrace: None,\n+            loader: loader,\n             mod_path: ~[],\n             trace_mac: false\n         }\n@@ -456,20 +470,27 @@ pub fn get_exprs_from_tts(cx: &ExtCtxt,\n // able to refer to a macro that was added to an enclosing\n // scope lexically later than the deeper scope.\n \n-// Only generic to make it easy to test\n-struct MapChainFrame<K, V> {\n+struct MapChainFrame {\n     info: BlockInfo,\n-    map: HashMap<K, V>,\n+    map: HashMap<Name, SyntaxExtension>,\n+}\n+\n+#[unsafe_destructor]\n+impl Drop for MapChainFrame {\n+    fn drop(&mut self) {\n+        // make sure that syntax extension dtors run before we drop the libs\n+        self.map.clear();\n+    }\n }\n \n // Only generic to make it easy to test\n-pub struct MapChain<K, V> {\n-    priv chain: ~[MapChainFrame<K, V>],\n+pub struct SyntaxEnv {\n+    priv chain: ~[MapChainFrame],\n }\n \n-impl<K: Hash+Eq, V> MapChain<K, V> {\n-    pub fn new() -> MapChain<K, V> {\n-        let mut map = MapChain { chain: ~[] };\n+impl SyntaxEnv {\n+    pub fn new() -> SyntaxEnv {\n+        let mut map = SyntaxEnv { chain: ~[] };\n         map.push_frame();\n         map\n     }\n@@ -486,7 +507,7 @@ impl<K: Hash+Eq, V> MapChain<K, V> {\n         self.chain.pop();\n     }\n \n-    fn find_escape_frame<'a>(&'a mut self) -> &'a mut MapChainFrame<K, V> {\n+    fn find_escape_frame<'a>(&'a mut self) -> &'a mut MapChainFrame {\n         for (i, frame) in self.chain.mut_iter().enumerate().invert() {\n             if !frame.info.macros_escape || i == 0 {\n                 return frame\n@@ -495,7 +516,7 @@ impl<K: Hash+Eq, V> MapChain<K, V> {\n         unreachable!()\n     }\n \n-    pub fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+    pub fn find<'a>(&'a self, k: &Name) -> Option<&'a SyntaxExtension> {\n         for frame in self.chain.iter().invert() {\n             match frame.map.find(k) {\n                 Some(v) => return Some(v),\n@@ -505,49 +526,15 @@ impl<K: Hash+Eq, V> MapChain<K, V> {\n         None\n     }\n \n-    pub fn insert(&mut self, k: K, v: V) {\n+    pub fn insert(&mut self, k: Name, v: SyntaxExtension) {\n         self.find_escape_frame().map.insert(k, v);\n     }\n \n-    pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n-        &mut self.chain[self.chain.len()-1].info\n+    pub fn insert_macro_crate(&mut self, lib: DynamicLibrary) {\n+        self.find_escape_frame().info.macro_crates.push(lib);\n     }\n-}\n \n-#[cfg(test)]\n-mod test {\n-    use super::MapChain;\n-\n-    #[test]\n-    fn testenv() {\n-        let mut m = MapChain::new();\n-        let (a,b,c,d) = (\"a\", \"b\", \"c\", \"d\");\n-        m.insert(1, a);\n-        assert_eq!(Some(&a), m.find(&1));\n-\n-        m.push_frame();\n-        m.info().macros_escape = true;\n-        m.insert(2, b);\n-        assert_eq!(Some(&a), m.find(&1));\n-        assert_eq!(Some(&b), m.find(&2));\n-        m.pop_frame();\n-\n-        assert_eq!(Some(&a), m.find(&1));\n-        assert_eq!(Some(&b), m.find(&2));\n-\n-        m.push_frame();\n-        m.push_frame();\n-        m.info().macros_escape = true;\n-        m.insert(3, c);\n-        assert_eq!(Some(&c), m.find(&3));\n-        m.pop_frame();\n-        assert_eq!(Some(&c), m.find(&3));\n-        m.pop_frame();\n-        assert_eq!(None, m.find(&3));\n-\n-        m.push_frame();\n-        m.insert(4, d);\n-        m.pop_frame();\n-        assert_eq!(None, m.find(&4));\n+    pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n+        &mut self.chain[self.chain.len()-1].info\n     }\n }"}, {"sha": "d702ee3ead4f6553a165114c7453b3bba6e92fe6", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -236,7 +236,7 @@ pub trait AstBuilder {\n                      vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem;\n }\n \n-impl AstBuilder for ExtCtxt {\n+impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n         self.path_all(span, false, strs, opt_vec::Empty, ~[])\n     }\n@@ -896,7 +896,7 @@ impl AstBuilder for ExtCtxt {\n }\n \n struct Duplicator<'a> {\n-    cx: &'a ExtCtxt,\n+    cx: &'a ExtCtxt<'a>,\n }\n \n impl<'a> Folder for Duplicator<'a> {"}, {"sha": "202746acddce1a01b604ed2a03835f1a2e1b3502", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -190,7 +190,7 @@ mod ty;\n \n pub struct TraitDef<'a> {\n     /// The extension context\n-    cx: &'a ExtCtxt,\n+    cx: &'a ExtCtxt<'a>,\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n "}, {"sha": "b1b38d6dc90f24528da78373c3e93a441382daec", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 102, "deletions": 8, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -30,6 +30,7 @@ use visit::Visitor;\n use util::small_vector::SmallVector;\n \n use std::vec;\n+use std::unstable::dynamic_lib::DynamicLibrary;\n \n pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     match e.node {\n@@ -365,13 +366,79 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n             fld.extsbox.insert(intern(name), ext);\n-            SmallVector::zero()\n+            if attr::contains_name(it.attrs, \"macro_export\") {\n+                SmallVector::one(it)\n+            } else {\n+                SmallVector::zero()\n+            }\n         }\n     };\n     fld.cx.bt_pop();\n     return items;\n }\n \n+// load macros from syntax-phase crates\n+pub fn expand_view_item(vi: &ast::ViewItem,\n+                        fld: &mut MacroExpander)\n+                        -> ast::ViewItem {\n+    let should_load = vi.attrs.iter().any(|attr| {\n+        \"phase\" == attr.name() &&\n+            attr.meta_item_list().map_or(false, |phases| {\n+                attr::contains_name(phases, \"syntax\")\n+            })\n+    });\n+\n+    if should_load {\n+        load_extern_macros(vi, fld);\n+    }\n+\n+    noop_fold_view_item(vi, fld)\n+}\n+\n+fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n+    let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(crate);\n+\n+    let exported_macros = fld.cx.loader.get_exported_macros(cnum);\n+    for &it in exported_macros.iter() {\n+        expand_item_mac(it, fld);\n+    }\n+\n+    let path = match lib {\n+        Some(path) => path,\n+        None => return\n+    };\n+    // Make sure the path contains a / or the linker will search for it.\n+    // If path is already absolute this is a no-op.\n+    let path = Path::new(\".\").join(path);\n+\n+    let registrar = match fld.cx.loader.get_registrar_symbol(cnum) {\n+        Some(registrar) => registrar,\n+        None => return\n+    };\n+\n+    let lib = match DynamicLibrary::open(Some(&path)) {\n+        Ok(lib) => lib,\n+        Err(err) => fld.cx.span_fatal(crate.span, err)\n+    };\n+\n+    unsafe {\n+        let registrar: MacroCrateRegistrationFun = match lib.symbol(registrar) {\n+            Ok(registrar) => registrar,\n+            Err(err) => fld.cx.span_fatal(crate.span, err)\n+        };\n+        registrar(|name, extension| {\n+            let extension = match extension {\n+                NormalTT(ext, _) => NormalTT(ext, Some(crate.span)),\n+                IdentTT(ext, _) => IdentTT(ext, Some(crate.span)),\n+                ItemDecorator(ext) => ItemDecorator(ext),\n+            };\n+            fld.extsbox.insert(name, extension);\n+        });\n+    }\n+\n+    fld.extsbox.insert_macro_crate(lib);\n+}\n+\n // expand a stmt\n pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n@@ -878,7 +945,7 @@ pub fn inject_std_macros(parse_sess: @parse::ParseSess,\n \n pub struct MacroExpander<'a> {\n     extsbox: SyntaxEnv,\n-    cx: &'a mut ExtCtxt,\n+    cx: &'a mut ExtCtxt<'a>,\n }\n \n impl<'a> Folder for MacroExpander<'a> {\n@@ -894,6 +961,10 @@ impl<'a> Folder for MacroExpander<'a> {\n         expand_item(item, self)\n     }\n \n+    fn fold_view_item(&mut self, vi: &ast::ViewItem) -> ast::ViewItem {\n+        expand_view_item(vi, self)\n+    }\n+\n     fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n@@ -908,9 +979,10 @@ impl<'a> Folder for MacroExpander<'a> {\n }\n \n pub fn expand_crate(parse_sess: @parse::ParseSess,\n+                    loader: &mut CrateLoader,\n                     cfg: ast::CrateConfig,\n                     c: Crate) -> Crate {\n-    let mut cx = ExtCtxt::new(parse_sess, cfg.clone());\n+    let mut cx = ExtCtxt::new(parse_sess, cfg.clone(), loader);\n     let mut expander = MacroExpander {\n         extsbox: syntax_expander_table(),\n         cx: &mut cx,\n@@ -1076,6 +1148,7 @@ mod test {\n     use codemap::Spanned;\n     use fold;\n     use fold::*;\n+    use ext::base::{CrateLoader, MacroCrate};\n     use parse;\n     use parse::token::{fresh_mark, gensym, intern, ident_to_str};\n     use parse::token;\n@@ -1119,6 +1192,22 @@ mod test {\n         }\n     }\n \n+    struct ErrLoader;\n+\n+    impl CrateLoader for ErrLoader {\n+        fn load_crate(&mut self, _: &ast::ViewItem) -> MacroCrate {\n+            fail!(\"lolwut\")\n+        }\n+\n+        fn get_exported_macros(&mut self, _: ast::CrateNum) -> ~[@ast::Item] {\n+            fail!(\"lolwut\")\n+        }\n+\n+        fn get_registrar_symbol(&mut self, _: ast::CrateNum) -> Option<~str> {\n+            fail!(\"lolwut\")\n+        }\n+    }\n+\n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n         let src = @\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n@@ -1129,7 +1218,8 @@ mod test {\n             ~[],sess);\n         let crate_ast = inject_std_macros(sess, ~[], crate_ast);\n         // don't bother with striping, doesn't affect fail!.\n-        expand_crate(sess,~[],crate_ast);\n+        let mut loader = ErrLoader;\n+        expand_crate(sess,&mut loader,~[],crate_ast);\n     }\n \n     // these following tests are quite fragile, in that they don't test what\n@@ -1146,7 +1236,8 @@ mod test {\n             src,\n             ~[],sess);\n         // should fail:\n-        expand_crate(sess,~[],crate_ast);\n+        let mut loader = ErrLoader;\n+        expand_crate(sess,&mut loader,~[],crate_ast);\n     }\n \n     // make sure that macros can leave scope for modules\n@@ -1160,7 +1251,8 @@ mod test {\n             src,\n             ~[],sess);\n         // should fail:\n-        expand_crate(sess,~[],crate_ast);\n+        let mut loader = ErrLoader;\n+        expand_crate(sess,&mut loader,~[],crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n@@ -1173,7 +1265,8 @@ mod test {\n             src,\n             ~[], sess);\n         // should fail:\n-        expand_crate(sess,~[],crate_ast);\n+        let mut loader = ErrLoader;\n+        expand_crate(sess,&mut loader,~[],crate_ast);\n     }\n \n     #[test] fn std_macros_must_parse () {\n@@ -1281,7 +1374,8 @@ mod test {\n     fn expand_crate_str(crate_str: @str) -> ast::Crate {\n         let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n         // the cfg argument actually does matter, here...\n-        expand_crate(ps,~[],crate_ast)\n+        let mut loader = ErrLoader;\n+        expand_crate(ps,&mut loader,~[],crate_ast)\n     }\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {"}, {"sha": "9ae13ddeb0266f04c76ab1926c88eabefecfb8de", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -34,7 +34,7 @@ enum Position {\n }\n \n struct Context<'a> {\n-    ecx: &'a mut ExtCtxt,\n+    ecx: &'a mut ExtCtxt<'a>,\n     fmtsp: Span,\n \n     // Parsed argument expressions and the types that we've found so far for"}, {"sha": "27f41356a4bb39d0ac046d1b5e4f3020f71ca7d8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -243,7 +243,7 @@ pub mod rt {\n         fn parse_tts(&self, s: @str) -> ~[ast::TokenTree];\n     }\n \n-    impl ExtParseUtils for ExtCtxt {\n+    impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n         fn parse_item(&self, s: @str) -> @ast::Item {\n             let res = parse::parse_item_from_source_str("}, {"sha": "265dd91d7f41b89163073b8940bb73f03409fee0", "filename": "src/libsyntax/ext/registrar.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use attr;\n+use codemap::Span;\n+use diagnostic;\n+use visit;\n+use visit::Visitor;\n+\n+struct MacroRegistrarContext {\n+    registrars: ~[(ast::NodeId, Span)],\n+}\n+\n+impl Visitor<()> for MacroRegistrarContext {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+        match item.node {\n+            ast::ItemFn(..) => {\n+                if attr::contains_name(item.attrs, \"macro_registrar\") {\n+                    self.registrars.push((item.id, item.span));\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, item, ());\n+    }\n+}\n+\n+pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n+                            crate: &ast::Crate) -> Option<ast::DefId> {\n+    let mut ctx = MacroRegistrarContext { registrars: ~[] };\n+    visit::walk_crate(&mut ctx, crate, ());\n+\n+    match ctx.registrars.len() {\n+        0 => None,\n+        1 => {\n+            let (node_id, _) = ctx.registrars.pop();\n+            Some(ast::DefId {\n+                crate: ast::LOCAL_CRATE,\n+                node: node_id\n+            })\n+        },\n+        _ => {\n+            diagnostic.handler().err(\"Multiple macro registration functions found\");\n+            for &(_, span) in ctx.registrars.iter() {\n+                diagnostic.span_note(span, \"one is here\");\n+            }\n+            diagnostic.handler().abort_if_errors();\n+            unreachable!();\n+        }\n+    }\n+}"}, {"sha": "7a86dd6e4ce72d70548f2e940c6afcd261307ac4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -63,20 +63,7 @@ pub trait Folder {\n     }\n \n     fn fold_view_item(&mut self, vi: &ViewItem) -> ViewItem {\n-        let inner_view_item = match vi.node {\n-            ViewItemExternMod(ref ident, string, node_id) => {\n-                ViewItemExternMod(ident.clone(), string, self.new_id(node_id))\n-            }\n-            ViewItemUse(ref view_paths) => {\n-                ViewItemUse(self.fold_view_paths(*view_paths))\n-            }\n-        };\n-        ViewItem {\n-            node: inner_view_item,\n-            attrs: vi.attrs.map(|a| fold_attribute_(*a, self)),\n-            vis: vi.vis,\n-            span: self.new_span(vi.span),\n-        }\n+        noop_fold_view_item(vi, self)\n     }\n \n     fn fold_foreign_item(&mut self, ni: @ForeignItem) -> @ForeignItem {\n@@ -509,6 +496,28 @@ fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n     }\n }\n \n+pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n+                                       -> ViewItem{\n+    let inner_view_item = match vi.node {\n+        ViewItemExternMod(ref ident,\n+                             string,\n+                             node_id) => {\n+            ViewItemExternMod(ident.clone(),\n+                                 string,\n+                                 folder.new_id(node_id))\n+        }\n+        ViewItemUse(ref view_paths) => {\n+            ViewItemUse(folder.fold_view_paths(*view_paths))\n+        }\n+    };\n+    ViewItem {\n+        node: inner_view_item,\n+        attrs: vi.attrs.map(|a| fold_attribute_(*a, folder)),\n+        vis: vi.vis,\n+        span: folder.new_span(vi.span),\n+    }\n+}\n+\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();"}, {"sha": "532a2a9a314935a148ad552c085b64226de8fa3c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -68,6 +68,7 @@ pub mod ext {\n     pub mod asm;\n     pub mod base;\n     pub mod expand;\n+    pub mod registrar;\n \n     pub mod quote;\n "}, {"sha": "145212bcc8c1bf99e313af122afd5af7a0d72f5c", "filename": "src/test/auxiliary/macro_crate_def_only.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(macro_rules)];\n+\n+#[macro_export]\n+macro_rules! make_a_5(\n+    () => (5)\n+)"}, {"sha": "403bbac8eb2fa9a55a232945a2af82be85e0604b", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(globs, macro_registrar, macro_rules)];\n+\n+extern mod syntax;\n+\n+use syntax::ast::{Name, TokenTree};\n+use syntax::codemap::Span;\n+use syntax::ext::base::*;\n+use syntax::parse::token;\n+\n+#[macro_export]\n+macro_rules! exported_macro (() => (2))\n+\n+macro_rules! unexported_macro (() => (3))\n+\n+#[macro_registrar]\n+pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n+    register(token::intern(\"make_a_1\"),\n+        NormalTT(~SyntaxExpanderTT {\n+            expander: SyntaxExpanderTTExpanderWithoutContext(expand_make_a_1),\n+            span: None,\n+        },\n+        None));\n+}\n+\n+pub fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> MacResult {\n+    if !tts.is_empty() {\n+        cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n+    }\n+    MRExpr(quote_expr!(cx, 1i))\n+}\n+\n+pub fn foo() {}"}, {"sha": "54274ccb847a67fb8363a91544eca14edc9bb294", "filename": "src/test/compile-fail/gated-macro_registrar.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fgated-macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fgated-macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-macro_registrar.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// the registration function isn't typechecked yet\n+#[macro_registrar]\n+pub fn registrar() {} //~ ERROR cross-crate macro exports are experimental\n+\n+fn main() {}"}, {"sha": "3a801e1351ac96a4e34023c591e316b5c1b1ccf9", "filename": "src/test/compile-fail/gated-phase.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fgated-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fgated-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-phase.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+\n+#[phase(syntax)]\n+//~^ ERROR compile time crate loading is experimental and possibly buggy\n+extern mod macro_crate_test;\n+\n+fn main() {}"}, {"sha": "d6867e780efbc6f03d55a811f7b89bde7f535e15", "filename": "src/test/compile-fail/macro-crate-unexported-macro.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-crate-unexported-macro.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// xfail-stage1\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern mod macro_crate_test;\n+\n+fn main() {\n+    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: 'unexported_macro'\n+}"}, {"sha": "83538fcf454e875ebef94e292775ac34f5c9175b", "filename": "src/test/compile-fail/macro-crate-unknown-crate.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fmacro-crate-unknown-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fmacro-crate-unknown-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-crate-unknown-crate.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern mod doesnt_exist; //~ ERROR can't find crate\n+\n+fn main() {}"}, {"sha": "7802c13bd3a27cfedbd5a684b37f09217e4f8bc3", "filename": "src/test/compile-fail/multiple-macro-registrars.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fmultiple-macro-registrars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fmultiple-macro-registrars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultiple-macro-registrars.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: Multiple macro registration functions found\n+\n+#[feature(macro_registrar)];\n+\n+// the registration function isn't typechecked yet\n+#[macro_registrar]\n+pub fn one() {}\n+\n+#[macro_registrar]\n+pub fn two() {}\n+\n+fn main() {}"}, {"sha": "c7e49d2dd607f0afb2d9532e620c6984e6e25c87", "filename": "src/test/compile-fail/phase-syntax-doesnt-resolve.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fphase-syntax-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Fcompile-fail%2Fphase-syntax-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fphase-syntax-doesnt-resolve.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// xfail-stage1\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern mod macro_crate_test;\n+\n+fn main() {\n+    macro_crate_test::foo();\n+    //~^ ERROR unresolved name\n+    //~^^ ERROR use of undeclared module `macro_crate_test`\n+    //~^^^ ERROR unresolved name `macro_crate_test::foo`.\n+}"}, {"sha": "b5ae00e1d7bd7fcbedac2c8ba5e9ad8ec8ec0253", "filename": "src/test/run-pass/macro-crate-def-only.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_def_only.rs\n+// xfail-fast\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern mod macro_crate_def_only;\n+\n+pub fn main() {\n+    assert_eq!(5, make_a_5!());\n+}"}, {"sha": "0073c1c33fba54884cdc703760412f5c38d198d3", "filename": "src/test/run-pass/macro-crate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Frun-pass%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Frun-pass%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// xfail-stage1\n+// xfail-fast\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern mod macro_crate_test;\n+\n+pub fn main() {\n+    assert_eq!(1, make_a_1!());\n+    assert_eq!(2, exported_macro!());\n+}"}, {"sha": "20c6fa5efaa35f2f342c94e9fef202ebea9e65ce", "filename": "src/test/run-pass/phase-syntax-link-does-resolve.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Frun-pass%2Fphase-syntax-link-does-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328b47d83720f011cb1c95685c3e7df8195efbd3/src%2Ftest%2Frun-pass%2Fphase-syntax-link-does-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fphase-syntax-link-does-resolve.rs?ref=328b47d83720f011cb1c95685c3e7df8195efbd3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// xfail-stage1\n+// xfail-fast\n+\n+#[feature(phase)];\n+\n+#[phase(syntax, link)]\n+extern mod macro_crate_test;\n+\n+fn main() {\n+    assert_eq!(1, make_a_1!());\n+    macro_crate_test::foo();\n+}"}]}