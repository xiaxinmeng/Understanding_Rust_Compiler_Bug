{"sha": "621047b2b0820f9f9962ae278b0093da398fff20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMTA0N2IyYjA4MjBmOWY5OTYyYWUyNzhiMDA5M2RhMzk4ZmZmMjA=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-23T10:00:02Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-23T10:00:02Z"}, "message": "Reindent check/mod.rs", "tree": {"sha": "59a8fb45c4e4433ab0d5dfaae3657afab625ad71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59a8fb45c4e4433ab0d5dfaae3657afab625ad71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/621047b2b0820f9f9962ae278b0093da398fff20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/621047b2b0820f9f9962ae278b0093da398fff20", "html_url": "https://github.com/rust-lang/rust/commit/621047b2b0820f9f9962ae278b0093da398fff20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/621047b2b0820f9f9962ae278b0093da398fff20/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ba2952af63ea1eb0bb8096f7e51c339ab3ab66f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ba2952af63ea1eb0bb8096f7e51c339ab3ab66f", "html_url": "https://github.com/rust-lang/rust/commit/7ba2952af63ea1eb0bb8096f7e51c339ab3ab66f"}], "stats": {"total": 1048, "additions": 524, "deletions": 524}, "files": [{"sha": "4a8b61d230efe1e8f9a6b4eb90573316b17adc50", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 524, "deletions": 524, "changes": 1048, "blob_url": "https://github.com/rust-lang/rust/blob/621047b2b0820f9f9962ae278b0093da398fff20/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621047b2b0820f9f9962ae278b0093da398fff20/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=621047b2b0820f9f9962ae278b0093da398fff20", "patch": "@@ -3611,579 +3611,579 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n-          hir::ExprBox(ref subexpr) => {\n-            let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n-                match ty.sty {\n-                    ty::TyAdt(def, _) if def.is_box()\n-                        => Expectation::rvalue_hint(self, ty.boxed_ty()),\n-                    _ => NoExpectation\n-                }\n-            });\n-            let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n-            tcx.mk_box(referent_ty)\n-          }\n-\n-          hir::ExprLit(ref lit) => {\n-            self.check_lit(&lit, expected)\n-          }\n-          hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            self.check_binop(expr, op, lhs, rhs)\n-          }\n-          hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            self.check_binop_assign(expr, op, lhs, rhs)\n-          }\n-          hir::ExprUnary(unop, ref oprnd) => {\n-            let expected_inner = match unop {\n-                hir::UnNot | hir::UnNeg => {\n-                    expected\n-                }\n-                hir::UnDeref => {\n-                    NoExpectation\n-                }\n-            };\n-            let needs = match unop {\n-                hir::UnDeref => needs,\n-                _ => Needs::None\n-            };\n-            let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                               expected_inner,\n-                                                                               needs);\n+            hir::ExprBox(ref subexpr) => {\n+                let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n+                    match ty.sty {\n+                        ty::TyAdt(def, _) if def.is_box()\n+                            => Expectation::rvalue_hint(self, ty.boxed_ty()),\n+                        _ => NoExpectation\n+                    }\n+                });\n+                let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n+                tcx.mk_box(referent_ty)\n+            }\n \n-            if !oprnd_t.references_error() {\n-                oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-                match unop {\n+            hir::ExprLit(ref lit) => {\n+                self.check_lit(&lit, expected)\n+            }\n+            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+                self.check_binop(expr, op, lhs, rhs)\n+            }\n+            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                self.check_binop_assign(expr, op, lhs, rhs)\n+            }\n+            hir::ExprUnary(unop, ref oprnd) => {\n+                let expected_inner = match unop {\n+                    hir::UnNot | hir::UnNeg => {\n+                        expected\n+                    }\n                     hir::UnDeref => {\n-                        if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                            oprnd_t = mt.ty;\n-                        } else if let Some(ok) = self.try_overloaded_deref(\n-                                expr.span, oprnd_t, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                                let mutbl = match mutbl {\n-                                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                    hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                        // (It shouldn't actually matter for unary ops whether\n-                                        // we enable two-phase borrows or not, since a unary\n-                                        // op has no additional operands.)\n-                                        allow_two_phase_borrow: AllowTwoPhase::No,\n-                                    }\n-                                };\n-                                self.apply_adjustments(oprnd, vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                    target: method.sig.inputs()[0]\n-                                }]);\n+                        NoExpectation\n+                    }\n+                };\n+                let needs = match unop {\n+                    hir::UnDeref => needs,\n+                    _ => Needs::None\n+                };\n+                let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n+                                                                                    expected_inner,\n+                                                                                    needs);\n+\n+                if !oprnd_t.references_error() {\n+                    oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n+                    match unop {\n+                        hir::UnDeref => {\n+                            if let Some(mt) = oprnd_t.builtin_deref(true) {\n+                                oprnd_t = mt.ty;\n+                            } else if let Some(ok) = self.try_overloaded_deref(\n+                                    expr.span, oprnd_t, needs) {\n+                                let method = self.register_infer_ok_obligations(ok);\n+                                if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                    let mutbl = match mutbl {\n+                                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                            // (It shouldn't actually matter for unary ops whether\n+                                            // we enable two-phase borrows or not, since a unary\n+                                            // op has no additional operands.)\n+                                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                                        }\n+                                    };\n+                                    self.apply_adjustments(oprnd, vec![Adjustment {\n+                                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                                        target: method.sig.inputs()[0]\n+                                    }]);\n+                                }\n+                                oprnd_t = self.make_overloaded_place_return_type(method).ty;\n+                                self.write_method_call(expr.hir_id, method);\n+                            } else {\n+                                type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n+                                                    \"type `{}` cannot be dereferenced\",\n+                                                    oprnd_t).emit();\n+                                oprnd_t = tcx.types.err;\n                             }\n-                            oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                            self.write_method_call(expr.hir_id, method);\n-                        } else {\n-                            type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n-                                               \"type `{}` cannot be dereferenced\",\n-                                               oprnd_t).emit();\n-                            oprnd_t = tcx.types.err;\n                         }\n-                    }\n-                    hir::UnNot => {\n-                        let result = self.check_user_unop(expr, oprnd_t, unop);\n-                        // If it's builtin, we can reuse the type, this helps inference.\n-                        if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n-                            oprnd_t = result;\n+                        hir::UnNot => {\n+                            let result = self.check_user_unop(expr, oprnd_t, unop);\n+                            // If it's builtin, we can reuse the type, this helps inference.\n+                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n+                                oprnd_t = result;\n+                            }\n+                        }\n+                        hir::UnNeg => {\n+                            let result = self.check_user_unop(expr, oprnd_t, unop);\n+                            // If it's builtin, we can reuse the type, this helps inference.\n+                            if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n+                                oprnd_t = result;\n+                            }\n                         }\n                     }\n-                    hir::UnNeg => {\n-                        let result = self.check_user_unop(expr, oprnd_t, unop);\n-                        // If it's builtin, we can reuse the type, this helps inference.\n-                        if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n-                            oprnd_t = result;\n+                }\n+                oprnd_t\n+            }\n+            hir::ExprAddrOf(mutbl, ref oprnd) => {\n+                let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n+                    match ty.sty {\n+                        ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                            if self.is_place_expr(&oprnd) {\n+                                // Places may legitimately have unsized types.\n+                                // For example, dereferences of a fat pointer and\n+                                // the last field of a struct can be unsized.\n+                                ExpectHasType(ty)\n+                            } else {\n+                                Expectation::rvalue_hint(self, ty)\n+                            }\n                         }\n+                        _ => NoExpectation\n                     }\n+                });\n+                let needs = Needs::maybe_mut_place(mutbl);\n+                let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+\n+                let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+                if tm.ty.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    // Note: at this point, we cannot say what the best lifetime\n+                    // is to use for resulting pointer.  We want to use the\n+                    // shortest lifetime possible so as to avoid spurious borrowck\n+                    // errors.  Moreover, the longest lifetime will depend on the\n+                    // precise details of the value whose address is being taken\n+                    // (and how long it is valid), which we don't know yet until type\n+                    // inference is complete.\n+                    //\n+                    // Therefore, here we simply generate a region variable.  The\n+                    // region inferencer will then select the ultimate value.\n+                    // Finally, borrowck is charged with guaranteeing that the\n+                    // value whose address was taken can actually be made to live\n+                    // as long as it needs to live.\n+                    let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+                    tcx.mk_ref(region, tm)\n                 }\n             }\n-            oprnd_t\n-          }\n-          hir::ExprAddrOf(mutbl, ref oprnd) => {\n-            let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-                match ty.sty {\n-                    ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        if self.is_place_expr(&oprnd) {\n-                            // Places may legitimately have unsized types.\n-                            // For example, dereferences of a fat pointer and\n-                            // the last field of a struct can be unsized.\n-                            ExpectHasType(ty)\n+            hir::ExprPath(ref qpath) => {\n+                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n+                let ty = if def != Def::Err {\n+                    self.instantiate_value_path(segs, opt_ty, def, expr.span, id)\n+                } else {\n+                    self.set_tainted_by_errors();\n+                    tcx.types.err\n+                };\n+\n+                // We always require that the type provided as the value for\n+                // a type parameter outlives the moment of instantiation.\n+                let substs = self.tables.borrow().node_substs(expr.hir_id);\n+                self.add_wf_bounds(substs, expr);\n+\n+                ty\n+            }\n+            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+                for output in outputs {\n+                    self.check_expr(output);\n+                }\n+                for input in inputs {\n+                    self.check_expr(input);\n+                }\n+                tcx.mk_nil()\n+            }\n+            hir::ExprBreak(destination, ref expr_opt) => {\n+                if let Ok(target_id) = destination.target_id {\n+                    let (e_ty, cause);\n+                    if let Some(ref e) = *expr_opt {\n+                        // If this is a break with a value, we need to type-check\n+                        // the expression. Get an expected type from the loop context.\n+                        let opt_coerce_to = {\n+                            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                            enclosing_breakables.find_breakable(target_id)\n+                                                .coerce\n+                                                .as_ref()\n+                                                .map(|coerce| coerce.expected_ty())\n+                        };\n+\n+                        // If the loop context is not a `loop { }`, then break with\n+                        // a value is illegal, and `opt_coerce_to` will be `None`.\n+                        // Just set expectation to error in that case.\n+                        let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                        // Recurse without `enclosing_breakables` borrowed.\n+                        e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        cause = self.misc(e.span);\n+                    } else {\n+                        // Otherwise, this is a break *without* a value. That's\n+                        // always legal, and is equivalent to `break ()`.\n+                        e_ty = tcx.mk_nil();\n+                        cause = self.misc(expr.span);\n+                    }\n+\n+                    // Now that we have type-checked `expr_opt`, borrow\n+                    // the `enclosing_loops` field and let's coerce the\n+                    // type of `expr_opt` into what is expected.\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    let ctxt = enclosing_breakables.find_breakable(target_id);\n+                    if let Some(ref mut coerce) = ctxt.coerce {\n+                        if let Some(ref e) = *expr_opt {\n+                            coerce.coerce(self, &cause, e, e_ty);\n                         } else {\n-                            Expectation::rvalue_hint(self, ty)\n+                            assert!(e_ty.is_nil());\n+                            coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                        }\n+                    } else {\n+                        // If `ctxt.coerce` is `None`, we can just ignore\n+                        // the type of the expresison.  This is because\n+                        // either this was a break *without* a value, in\n+                        // which case it is always a legal type (`()`), or\n+                        // else an error would have been flagged by the\n+                        // `loops` pass for using break with an expression\n+                        // where you are not supposed to.\n+                        assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+                    }\n+\n+                    ctxt.may_break = true;\n+\n+                    // the type of a `break` is always `!`, since it diverges\n+                    tcx.types.never\n+                } else {\n+                    // Otherwise, we failed to find the enclosing loop;\n+                    // this can only happen if the `break` was not\n+                    // inside a loop at all, which is caught by the\n+                    // loop-checking pass.\n+                    assert!(self.tcx.sess.err_count() > 0);\n+\n+                    // We still need to assign a type to the inner expression to\n+                    // prevent the ICE in #43162.\n+                    if let Some(ref e) = *expr_opt {\n+                        self.check_expr_with_hint(e, tcx.types.err);\n+\n+                        // ... except when we try to 'break rust;'.\n+                        // ICE this expression in particular (see #43162).\n+                        if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n+                            if path.segments.len() == 1 && path.segments[0].name == \"rust\" {\n+                                fatally_break_rust(self.tcx.sess);\n+                            }\n                         }\n                     }\n-                    _ => NoExpectation\n+                    // There was an error, make typecheck fail\n+                    tcx.types.err\n                 }\n-            });\n-            let needs = Needs::maybe_mut_place(mutbl);\n-            let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n-            let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-            if tm.ty.references_error() {\n-                tcx.types.err\n-            } else {\n-                // Note: at this point, we cannot say what the best lifetime\n-                // is to use for resulting pointer.  We want to use the\n-                // shortest lifetime possible so as to avoid spurious borrowck\n-                // errors.  Moreover, the longest lifetime will depend on the\n-                // precise details of the value whose address is being taken\n-                // (and how long it is valid), which we don't know yet until type\n-                // inference is complete.\n-                //\n-                // Therefore, here we simply generate a region variable.  The\n-                // region inferencer will then select the ultimate value.\n-                // Finally, borrowck is charged with guaranteeing that the\n-                // value whose address was taken can actually be made to live\n-                // as long as it needs to live.\n-                let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                tcx.mk_ref(region, tm)\n             }\n-          }\n-          hir::ExprPath(ref qpath) => {\n-              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath,\n-                                                                         expr.id, expr.span);\n-              let ty = if def != Def::Err {\n-                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n-              } else {\n-                  self.set_tainted_by_errors();\n-                  tcx.types.err\n-              };\n-\n-              // We always require that the type provided as the value for\n-              // a type parameter outlives the moment of instantiation.\n-              let substs = self.tables.borrow().node_substs(expr.hir_id);\n-              self.add_wf_bounds(substs, expr);\n-\n-              ty\n-          }\n-          hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n-              for output in outputs {\n-                  self.check_expr(output);\n-              }\n-              for input in inputs {\n-                  self.check_expr(input);\n-              }\n-              tcx.mk_nil()\n-          }\n-          hir::ExprBreak(destination, ref expr_opt) => {\n-              if let Ok(target_id) = destination.target_id {\n-                  let (e_ty, cause);\n-                  if let Some(ref e) = *expr_opt {\n-                      // If this is a break with a value, we need to type-check\n-                      // the expression. Get an expected type from the loop context.\n-                      let opt_coerce_to = {\n-                          let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                          enclosing_breakables.find_breakable(target_id)\n-                                              .coerce\n-                                              .as_ref()\n-                                              .map(|coerce| coerce.expected_ty())\n-                      };\n-\n-                      // If the loop context is not a `loop { }`, then break with\n-                      // a value is illegal, and `opt_coerce_to` will be `None`.\n-                      // Just set expectation to error in that case.\n-                      let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n-\n-                      // Recurse without `enclosing_breakables` borrowed.\n-                      e_ty = self.check_expr_with_hint(e, coerce_to);\n-                      cause = self.misc(e.span);\n-                  } else {\n-                      // Otherwise, this is a break *without* a value. That's\n-                      // always legal, and is equivalent to `break ()`.\n-                      e_ty = tcx.mk_nil();\n-                      cause = self.misc(expr.span);\n-                  }\n-\n-                  // Now that we have type-checked `expr_opt`, borrow\n-                  // the `enclosing_loops` field and let's coerce the\n-                  // type of `expr_opt` into what is expected.\n-                  let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                  let ctxt = enclosing_breakables.find_breakable(target_id);\n-                  if let Some(ref mut coerce) = ctxt.coerce {\n-                      if let Some(ref e) = *expr_opt {\n-                          coerce.coerce(self, &cause, e, e_ty);\n-                      } else {\n-                          assert!(e_ty.is_nil());\n-                          coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                      }\n-                  } else {\n-                      // If `ctxt.coerce` is `None`, we can just ignore\n-                      // the type of the expresison.  This is because\n-                      // either this was a break *without* a value, in\n-                      // which case it is always a legal type (`()`), or\n-                      // else an error would have been flagged by the\n-                      // `loops` pass for using break with an expression\n-                      // where you are not supposed to.\n-                      assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n-                  }\n-\n-                  ctxt.may_break = true;\n-\n-                  // the type of a `break` is always `!`, since it diverges\n-                  tcx.types.never\n-              } else {\n-                  // Otherwise, we failed to find the enclosing loop;\n-                  // this can only happen if the `break` was not\n-                  // inside a loop at all, which is caught by the\n-                  // loop-checking pass.\n-                  assert!(self.tcx.sess.err_count() > 0);\n-\n-                  // We still need to assign a type to the inner expression to\n-                  // prevent the ICE in #43162.\n-                  if let Some(ref e) = *expr_opt {\n-                      self.check_expr_with_hint(e, tcx.types.err);\n-\n-                      // ... except when we try to 'break rust;'.\n-                      // ICE this expression in particular (see #43162).\n-                      if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n-                          if path.segments.len() == 1 && path.segments[0].name == \"rust\" {\n-                              fatally_break_rust(self.tcx.sess);\n-                          }\n-                      }\n-                  }\n-                  // There was an error, make typecheck fail\n-                  tcx.types.err\n-              }\n-\n-          }\n-          hir::ExprContinue(_) => { tcx.types.never }\n-          hir::ExprRet(ref expr_opt) => {\n-            if self.ret_coercion.is_none() {\n-                struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                 \"return statement outside of function body\").emit();\n-            } else if let Some(ref e) = *expr_opt {\n-                self.check_return_expr(e);\n-            } else {\n-                let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-                let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+            hir::ExprContinue(_) => { tcx.types.never }\n+            hir::ExprRet(ref expr_opt) => {\n+                if self.ret_coercion.is_none() {\n+                    struct_span_err!(self.tcx.sess, expr.span, E0572,\n+                                        \"return statement outside of function body\").emit();\n+                } else if let Some(ref e) = *expr_opt {\n+                    self.check_return_expr(e);\n+                } else {\n+                    let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n+                    let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n+                    coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                }\n+                tcx.types.never\n             }\n-            tcx.types.never\n-          }\n-          hir::ExprAssign(ref lhs, ref rhs) => {\n-            let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n+            hir::ExprAssign(ref lhs, ref rhs) => {\n+                let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n-            let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+                let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n-            match expected {\n-                ExpectIfCondition => {\n-                    self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n-                                                            expected error elsehwere\");\n-                }\n-                _ => {\n-                    // Only check this if not in an `if` condition, as the\n-                    // mistyped comparison help is more appropriate.\n-                    if !self.is_place_expr(&lhs) {\n-                        struct_span_err!(self.tcx.sess, expr.span, E0070,\n-                                         \"invalid left-hand side expression\")\n-                            .span_label(expr.span, \"left-hand of expression not valid\")\n-                            .emit();\n+                match expected {\n+                    ExpectIfCondition => {\n+                        self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n+                                                                expected error elsehwere\");\n+                    }\n+                    _ => {\n+                        // Only check this if not in an `if` condition, as the\n+                        // mistyped comparison help is more appropriate.\n+                        if !self.is_place_expr(&lhs) {\n+                            struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                                \"invalid left-hand side expression\")\n+                                .span_label(expr.span, \"left-hand of expression not valid\")\n+                                .emit();\n+                        }\n                     }\n                 }\n+\n+                self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+\n+                if lhs_ty.references_error() || rhs_ty.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    tcx.mk_nil()\n+                }\n+            }\n+            hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n+                self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n+                                    expr.span, expected)\n             }\n+            hir::ExprWhile(ref cond, ref body, _) => {\n+                let ctxt = BreakableCtxt {\n+                    // cannot use break with a value from a while loop\n+                    coerce: None,\n+                    may_break: false,  // Will get updated if/when we find a `break`.\n+                };\n \n-            self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                    self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n+                    let cond_diverging = self.diverges.get();\n+                    self.check_block_no_value(&body);\n \n-            if lhs_ty.references_error() || rhs_ty.references_error() {\n-                tcx.types.err\n-            } else {\n-                tcx.mk_nil()\n+                    // We may never reach the body so it diverging means nothing.\n+                    self.diverges.set(cond_diverging);\n+                });\n+\n+                if ctxt.may_break {\n+                    // No way to know whether it's diverging because\n+                    // of a `break` or an outer `break` or `return`.\n+                    self.diverges.set(Diverges::Maybe);\n+                }\n+\n+                self.tcx.mk_nil()\n             }\n-          }\n-          hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n-              self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n-                                   expr.span, expected)\n-          }\n-          hir::ExprWhile(ref cond, ref body, _) => {\n-              let ctxt = BreakableCtxt {\n-                  // cannot use break with a value from a while loop\n-                  coerce: None,\n-                  may_break: false,  // Will get updated if/when we find a `break`.\n-              };\n-\n-              let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n-                  self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n-                  let cond_diverging = self.diverges.get();\n-                  self.check_block_no_value(&body);\n-\n-                  // We may never reach the body so it diverging means nothing.\n-                  self.diverges.set(cond_diverging);\n-              });\n-\n-              if ctxt.may_break {\n-                  // No way to know whether it's diverging because\n-                  // of a `break` or an outer `break` or `return`.\n-                  self.diverges.set(Diverges::Maybe);\n-              }\n-\n-              self.tcx.mk_nil()\n-          }\n-          hir::ExprLoop(ref body, _, source) => {\n-              let coerce = match source {\n-                  // you can only use break with a value from a normal `loop { }`\n-                  hir::LoopSource::Loop => {\n-                      let coerce_to = expected.coercion_target_type(self, body.span);\n-                      Some(CoerceMany::new(coerce_to))\n-                  }\n-\n-                  hir::LoopSource::WhileLet |\n-                  hir::LoopSource::ForLoop => {\n-                      None\n-                  }\n-              };\n-\n-              let ctxt = BreakableCtxt {\n-                  coerce,\n-                  may_break: false, // Will get updated if/when we find a `break`.\n-              };\n-\n-              let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n-                  self.check_block_no_value(&body);\n-              });\n-\n-              if ctxt.may_break {\n-                  // No way to know whether it's diverging because\n-                  // of a `break` or an outer `break` or `return`.\n-                  self.diverges.set(Diverges::Maybe);\n-              }\n-\n-              // If we permit break with a value, then result type is\n-              // the LUB of the breaks (possibly ! if none); else, it\n-              // is nil. This makes sense because infinite loops\n-              // (which would have type !) are only possible iff we\n-              // permit break with a value [1].\n-              assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n-              ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n-          }\n-          hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-            self.check_match(expr, &discrim, arms, expected, match_src)\n-          }\n-          hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n-              self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n-          }\n-          hir::ExprBlock(ref body, _) => {\n-            self.check_block_with_expected(&body, expected)\n-          }\n-          hir::ExprCall(ref callee, ref args) => {\n-              self.check_call(expr, &callee, args, expected)\n-          }\n-          hir::ExprMethodCall(ref segment, span, ref args) => {\n-              self.check_method_call(expr, segment, span, args, expected, needs)\n-          }\n-          hir::ExprCast(ref e, ref t) => {\n-            // Find the type of `e`. Supply hints based on the type we are casting to,\n-            // if appropriate.\n-            let t_cast = self.to_ty(t);\n-            let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n-            let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-            let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n-\n-            // Eagerly check for some obvious errors.\n-            if t_expr.references_error() || t_cast.references_error() {\n-                tcx.types.err\n-            } else {\n-                // Defer other checks until we're done type checking.\n-                let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-                match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n-                    Ok(cast_check) => {\n-                        deferred_cast_checks.push(cast_check);\n-                        t_cast\n+            hir::ExprLoop(ref body, _, source) => {\n+                let coerce = match source {\n+                    // you can only use break with a value from a normal `loop { }`\n+                    hir::LoopSource::Loop => {\n+                        let coerce_to = expected.coercion_target_type(self, body.span);\n+                        Some(CoerceMany::new(coerce_to))\n                     }\n-                    Err(ErrorReported) => {\n-                        tcx.types.err\n+\n+                    hir::LoopSource::WhileLet |\n+                    hir::LoopSource::ForLoop => {\n+                        None\n                     }\n+                };\n+\n+                let ctxt = BreakableCtxt {\n+                    coerce,\n+                    may_break: false, // Will get updated if/when we find a `break`.\n+                };\n+\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                    self.check_block_no_value(&body);\n+                });\n+\n+                if ctxt.may_break {\n+                    // No way to know whether it's diverging because\n+                    // of a `break` or an outer `break` or `return`.\n+                    self.diverges.set(Diverges::Maybe);\n                 }\n-            }\n-          }\n-          hir::ExprType(ref e, ref t) => {\n-            let typ = self.to_ty(&t);\n-            self.check_expr_eq_type(&e, typ);\n-            typ\n-          }\n-          hir::ExprArray(ref args) => {\n-              let uty = expected.to_option(self).and_then(|uty| {\n-                  match uty.sty {\n-                      ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n-                      _ => None\n-                  }\n-              });\n-\n-              let element_ty = if !args.is_empty() {\n-                  let coerce_to = uty.unwrap_or_else(\n-                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n-                  let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n-                  assert_eq!(self.diverges.get(), Diverges::Maybe);\n-                  for e in args {\n-                      let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                      let cause = self.misc(e.span);\n-                      coerce.coerce(self, &cause, e, e_ty);\n-                  }\n-                  coerce.complete(self)\n-              } else {\n-                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n-              };\n-              tcx.mk_array(element_ty, args.len() as u64)\n-          }\n-          hir::ExprRepeat(ref element, ref count) => {\n-            let count_def_id = tcx.hir.local_def_id(count.id);\n-            let param_env = ty::ParamEnv::empty();\n-            let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n-            let instance = ty::Instance::resolve(\n-                tcx.global_tcx(),\n-                param_env,\n-                count_def_id,\n-                substs,\n-            ).unwrap();\n-            let global_id = GlobalId {\n-                instance,\n-                promoted: None\n-            };\n-            let count = tcx.const_eval(param_env.and(global_id));\n \n-            if let Err(ref err) = count {\n-                err.report_as_error(\n-                    tcx.at(tcx.def_span(count_def_id)),\n-                    \"could not evaluate repeat length\",\n-                );\n+                // If we permit break with a value, then result type is\n+                // the LUB of the breaks (possibly ! if none); else, it\n+                // is nil. This makes sense because infinite loops\n+                // (which would have type !) are only possible iff we\n+                // permit break with a value [1].\n+                assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n+                ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n             }\n-\n-            let uty = match expected {\n-                ExpectHasType(uty) => {\n+            hir::ExprMatch(ref discrim, ref arms, match_src) => {\n+                self.check_match(expr, &discrim, arms, expected, match_src)\n+            }\n+            hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n+                self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n+            }\n+            hir::ExprBlock(ref body, _) => {\n+                self.check_block_with_expected(&body, expected)\n+            }\n+            hir::ExprCall(ref callee, ref args) => {\n+                self.check_call(expr, &callee, args, expected)\n+            }\n+            hir::ExprMethodCall(ref segment, span, ref args) => {\n+                self.check_method_call(expr, segment, span, args, expected, needs)\n+            }\n+            hir::ExprCast(ref e, ref t) => {\n+                // Find the type of `e`. Supply hints based on the type we are casting to,\n+                // if appropriate.\n+                let t_cast = self.to_ty(t);\n+                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n+                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+\n+                // Eagerly check for some obvious errors.\n+                if t_expr.references_error() || t_cast.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    // Defer other checks until we're done type checking.\n+                    let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+                    match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                        Ok(cast_check) => {\n+                            deferred_cast_checks.push(cast_check);\n+                            t_cast\n+                        }\n+                        Err(ErrorReported) => {\n+                            tcx.types.err\n+                        }\n+                    }\n+                }\n+            }\n+            hir::ExprType(ref e, ref t) => {\n+                let ty = self.to_ty(&t);\n+                self.check_expr_eq_type(&e, ty);\n+                ty\n+            }\n+            hir::ExprArray(ref args) => {\n+                let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n                         ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n                         _ => None\n                     }\n-                }\n-                _ => None\n-            };\n+                });\n \n-            let (element_ty, t) = match uty {\n-                Some(uty) => {\n-                    self.check_expr_coercable_to_type(&element, uty);\n-                    (uty, uty)\n-                }\n-                None => {\n-                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n-                    let element_ty = self.check_expr_has_type_or_error(&element, t);\n-                    (element_ty, t)\n-                }\n-            };\n+                let element_ty = if !args.is_empty() {\n+                    let coerce_to = uty.unwrap_or_else(\n+                        || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n+                    let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n+                    assert_eq!(self.diverges.get(), Diverges::Maybe);\n+                    for e in args {\n+                        let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        let cause = self.misc(e.span);\n+                        coerce.coerce(self, &cause, e, e_ty);\n+                    }\n+                    coerce.complete(self)\n+                } else {\n+                    self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n+                };\n+                tcx.mk_array(element_ty, args.len() as u64)\n+            }\n+            hir::ExprRepeat(ref element, ref count) => {\n+                let count_def_id = tcx.hir.local_def_id(count.id);\n+                let param_env = ty::ParamEnv::empty();\n+                let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n+                let instance = ty::Instance::resolve(\n+                    tcx.global_tcx(),\n+                    param_env,\n+                    count_def_id,\n+                    substs,\n+                ).unwrap();\n+                let global_id = GlobalId {\n+                    instance,\n+                    promoted: None\n+                };\n+                let count = tcx.const_eval(param_env.and(global_id));\n \n-            if let Ok(count) = count {\n-                let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-                if !zero_or_one {\n-                    // For [foo, ..n] where n > 1, `foo` must have\n-                    // Copy type:\n-                    let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                    self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                if let Err(ref err) = count {\n+                    err.report_as_error(\n+                        tcx.at(tcx.def_span(count_def_id)),\n+                        \"could not evaluate repeat length\",\n+                    );\n                 }\n-            }\n \n-            if element_ty.references_error() {\n-                tcx.types.err\n-            } else if let Ok(count) = count {\n-                tcx.mk_ty(ty::TyArray(t, count))\n-            } else {\n-                tcx.types.err\n-            }\n-          }\n-          hir::ExprTup(ref elts) => {\n-            let flds = expected.only_has_type(self).and_then(|ty| {\n-                let ty = self.resolve_type_vars_with_obligations(ty);\n-                match ty.sty {\n-                    ty::TyTuple(ref flds) => Some(&flds[..]),\n+                let uty = match expected {\n+                    ExpectHasType(uty) => {\n+                        match uty.sty {\n+                            ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                            _ => None\n+                        }\n+                    }\n                     _ => None\n-                }\n-            });\n+                };\n \n-            let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n-                let t = match flds {\n-                    Some(ref fs) if i < fs.len() => {\n-                        let ety = fs[i];\n-                        self.check_expr_coercable_to_type(&e, ety);\n-                        ety\n+                let (element_ty, t) = match uty {\n+                    Some(uty) => {\n+                        self.check_expr_coercable_to_type(&element, uty);\n+                        (uty, uty)\n                     }\n-                    _ => {\n-                        self.check_expr_with_expectation(&e, NoExpectation)\n+                    None => {\n+                        let ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n+                        let element_ty = self.check_expr_has_type_or_error(&element, ty);\n+                        (element_ty, ty)\n                     }\n                 };\n-                t\n-            });\n-            let tuple = tcx.mk_tup(elt_ts_iter);\n-            if tuple.references_error() {\n-                tcx.types.err\n-            } else {\n-                self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n-                tuple\n+\n+                if let Ok(count) = count {\n+                    let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n+                    if !zero_or_one {\n+                        // For [foo, ..n] where n > 1, `foo` must have\n+                        // Copy type:\n+                        let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                        self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                    }\n+                }\n+\n+                if element_ty.references_error() {\n+                    tcx.types.err\n+                } else if let Ok(count) = count {\n+                    tcx.mk_ty(ty::TyArray(t, count))\n+                } else {\n+                    tcx.types.err\n+                }\n             }\n-          }\n-          hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n-          }\n-          hir::ExprField(ref base, field) => {\n-            self.check_field(expr, needs, &base, field)\n-          }\n-          hir::ExprIndex(ref base, ref idx) => {\n-              let base_t = self.check_expr_with_needs(&base, needs);\n-              let idx_t = self.check_expr(&idx);\n-\n-              if base_t.references_error() {\n-                  base_t\n-              } else if idx_t.references_error() {\n-                  idx_t\n-              } else {\n-                  let base_t = self.structurally_resolved_type(base.span, base_t);\n-                  match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n-                      Some((index_ty, element_ty)) => {\n-                          // two-phase not needed because index_ty is never mutable\n-                          self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n-                          element_ty\n-                      }\n-                      None => {\n-                          let mut err = type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n-                                                           \"cannot index into a value of type `{}`\",\n-                                                           base_t);\n-                          // Try to give some advice about indexing tuples.\n-                          if let ty::TyTuple(..) = base_t.sty {\n-                              let mut needs_note = true;\n-                              // If the index is an integer, we can show the actual\n-                              // fixed expression:\n-                              if let hir::ExprLit(ref lit) = idx.node {\n-                                  if let ast::LitKind::Int(i,\n+            hir::ExprTup(ref elts) => {\n+                let flds = expected.only_has_type(self).and_then(|ty| {\n+                    let ty = self.resolve_type_vars_with_obligations(ty);\n+                    match ty.sty {\n+                        ty::TyTuple(ref flds) => Some(&flds[..]),\n+                        _ => None\n+                    }\n+                });\n+\n+                let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n+                    let t = match flds {\n+                        Some(ref fs) if i < fs.len() => {\n+                            let ety = fs[i];\n+                            self.check_expr_coercable_to_type(&e, ety);\n+                            ety\n+                        }\n+                        _ => {\n+                            self.check_expr_with_expectation(&e, NoExpectation)\n+                        }\n+                    };\n+                    t\n+                });\n+                let tuple = tcx.mk_tup(elt_ts_iter);\n+                if tuple.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n+                    tuple\n+                }\n+            }\n+            hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n+                self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n+            }\n+            hir::ExprField(ref base, field) => {\n+                self.check_field(expr, needs, &base, field)\n+            }\n+            hir::ExprIndex(ref base, ref idx) => {\n+                let base_t = self.check_expr_with_needs(&base, needs);\n+                let idx_t = self.check_expr(&idx);\n+\n+                if base_t.references_error() {\n+                    base_t\n+                } else if idx_t.references_error() {\n+                    idx_t\n+                } else {\n+                    let base_t = self.structurally_resolved_type(base.span, base_t);\n+                    match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+                        Some((index_ty, element_ty)) => {\n+                            // two-phase not needed because index_ty is never mutable\n+                            self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                            element_ty\n+                        }\n+                        None => {\n+                            let mut err =\n+                                type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n+                                                   \"cannot index into a value of type `{}`\",\n+                                                   base_t);\n+                            // Try to give some advice about indexing tuples.\n+                            if let ty::TyTuple(..) = base_t.sty {\n+                                let mut needs_note = true;\n+                                // If the index is an integer, we can show the actual\n+                                // fixed expression:\n+                                if let hir::ExprLit(ref lit) = idx.node {\n+                                    if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n-                                      let snip = tcx.sess.codemap().span_to_snippet(base.span);\n-                                      if let Ok(snip) = snip {\n-                                          err.span_suggestion(expr.span,\n-                                                              \"to access tuple elements, use\",\n-                                                              format!(\"{}.{}\", snip, i));\n-                                          needs_note = false;\n-                                      }\n-                                  }\n-                              }\n-                              if needs_note {\n-                                  err.help(\"to access tuple elements, use tuple indexing \\\n+                                        let snip = tcx.sess.codemap().span_to_snippet(base.span);\n+                                        if let Ok(snip) = snip {\n+                                            err.span_suggestion(expr.span,\n+                                                                \"to access tuple elements, use\",\n+                                                                format!(\"{}.{}\", snip, i));\n+                                            needs_note = false;\n+                                        }\n+                                    }\n+                                }\n+                                if needs_note {\n+                                    err.help(\"to access tuple elements, use tuple indexing \\\n                                             syntax (e.g. `tuple.0`)\");\n-                              }\n-                          }\n-                          err.emit();\n-                          self.tcx.types.err\n-                      }\n-                  }\n-              }\n-           }\n-          hir::ExprYield(ref value) => {\n-            match self.yield_ty {\n-                Some(ty) => {\n-                    self.check_expr_coercable_to_type(&value, ty);\n+                                }\n+                            }\n+                            err.emit();\n+                            self.tcx.types.err\n+                        }\n+                    }\n                 }\n-                None => {\n-                    struct_span_err!(self.tcx.sess, expr.span, E0627,\n-                                 \"yield statement outside of generator literal\").emit();\n+            }\n+            hir::ExprYield(ref value) => {\n+                match self.yield_ty {\n+                    Some(ty) => {\n+                        self.check_expr_coercable_to_type(&value, ty);\n+                    }\n+                    None => {\n+                        struct_span_err!(self.tcx.sess, expr.span, E0627,\n+                                        \"yield statement outside of generator literal\").emit();\n+                    }\n                 }\n+                tcx.mk_nil()\n             }\n-            tcx.mk_nil()\n-          }\n         }\n     }\n "}]}