{"sha": "e85ddeb474665f3af7c447445c273da6117e266d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NWRkZWI0NzQ2NjVmM2FmN2M0NDc0NDVjMjczZGE2MTE3ZTI2NmQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-04-18T12:27:28Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-10T18:18:11Z"}, "message": "Encode spans relative to their parent.", "tree": {"sha": "6f2e80f6c78c506df6effcd202c1196284356fd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f2e80f6c78c506df6effcd202c1196284356fd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e85ddeb474665f3af7c447445c273da6117e266d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e85ddeb474665f3af7c447445c273da6117e266d", "html_url": "https://github.com/rust-lang/rust/commit/e85ddeb474665f3af7c447445c273da6117e266d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e85ddeb474665f3af7c447445c273da6117e266d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00485e0c0e8dcd64c57a86d706beb62054921253", "url": "https://api.github.com/repos/rust-lang/rust/commits/00485e0c0e8dcd64c57a86d706beb62054921253", "html_url": "https://github.com/rust-lang/rust/commit/00485e0c0e8dcd64c57a86d706beb62054921253"}], "stats": {"total": 92, "additions": 76, "deletions": 16}, "files": [{"sha": "9232be8ea2b5bd80809a837909eb4d1a30b35e6c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=e85ddeb474665f3af7c447445c273da6117e266d", "patch": "@@ -165,6 +165,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n pub trait ResolverAstLowering {\n     fn def_key(&mut self, id: DefId) -> DefKey;\n \n+    fn def_span(&self, id: LocalDefId) -> Span;\n+\n     fn item_generics_num_lifetimes(&self, def: DefId) -> usize;\n \n     fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>>;\n@@ -215,6 +217,11 @@ impl<'a> rustc_span::HashStableContext for LoweringHasher<'a> {\n         true\n     }\n \n+    #[inline]\n+    fn def_span(&self, id: LocalDefId) -> Span {\n+        self.resolver.def_span(id)\n+    }\n+\n     #[inline]\n     fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n         self.resolver.def_path_hash(def_id)"}, {"sha": "efb1fc68ce133fba23f83be885cc638a3570eaa4", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=e85ddeb474665f3af7c447445c273da6117e266d", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::definitions::{DefPathHash, Definitions};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{BytePos, CachingSourceMapView, SourceFile, SpanData};\n+use rustc_span::{BytePos, CachingSourceMapView, SourceFile, Span, SpanData};\n \n use smallvec::SmallVec;\n use std::cmp::Ord;\n@@ -229,6 +229,11 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n         self.def_path_hash(def_id)\n     }\n \n+    #[inline]\n+    fn def_span(&self, def_id: LocalDefId) -> Span {\n+        self.definitions.def_span(def_id)\n+    }\n+\n     fn span_data_to_lines_and_cols(\n         &mut self,\n         span: &SpanData,"}, {"sha": "63000a295f6fb05f19c00836e4a20532027a06e8", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=e85ddeb474665f3af7c447445c273da6117e266d", "patch": "@@ -23,7 +23,7 @@ use rustc_span::hygiene::{\n };\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n-use rustc_span::{BytePos, ExpnData, ExpnHash, SourceFile, Span, DUMMY_SP};\n+use rustc_span::{BytePos, ExpnData, ExpnHash, Pos, SourceFile, Span};\n use std::collections::hash_map::Entry;\n use std::mem;\n \n@@ -33,6 +33,7 @@ const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n const TAG_FULL_SPAN: u8 = 0;\n // A partial span with no location information, encoded only with a `SyntaxContext`\n const TAG_PARTIAL_SPAN: u8 = 1;\n+const TAG_RELATIVE_SPAN: u8 = 2;\n \n const TAG_SYNTAX_CONTEXT: u8 = 0;\n const TAG_EXPN_DATA: u8 = 1;\n@@ -829,11 +830,25 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n     fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let ctxt = SyntaxContext::decode(decoder)?;\n+        let parent = Option::<LocalDefId>::decode(decoder)?;\n         let tag: u8 = Decodable::decode(decoder)?;\n \n         if tag == TAG_PARTIAL_SPAN {\n-            let ctxt = SyntaxContext::decode(decoder)?;\n-            return Ok(DUMMY_SP.with_ctxt(ctxt));\n+            return Ok(Span::new(BytePos(0), BytePos(0), ctxt, parent));\n+        } else if tag == TAG_RELATIVE_SPAN {\n+            let dlo = u32::decode(decoder)?;\n+            let dto = u32::decode(decoder)?;\n+\n+            let enclosing = decoder.tcx.definitions_untracked().def_span(parent.unwrap()).data();\n+            let span = Span::new(\n+                enclosing.lo + BytePos::from_u32(dlo),\n+                enclosing.lo + BytePos::from_u32(dto),\n+                ctxt,\n+                parent,\n+            );\n+\n+            return Ok(span);\n         } else {\n             debug_assert_eq!(tag, TAG_FULL_SPAN);\n         }\n@@ -842,13 +857,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n         let line_lo = usize::decode(decoder)?;\n         let col_lo = BytePos::decode(decoder)?;\n         let len = BytePos::decode(decoder)?;\n-        let ctxt = SyntaxContext::decode(decoder)?;\n \n         let file_lo = decoder.file_index_to_file(file_lo_index);\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n-        Ok(Span::new(lo, hi, ctxt, None))\n+        Ok(Span::new(lo, hi, ctxt, parent))\n     }\n }\n \n@@ -1009,9 +1023,21 @@ where\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         let span_data = self.data();\n-        if self.is_dummy() {\n-            TAG_PARTIAL_SPAN.encode(s)?;\n-            return span_data.ctxt.encode(s);\n+        span_data.ctxt.encode(s)?;\n+        span_data.parent.encode(s)?;\n+\n+        if span_data.is_dummy() {\n+            return TAG_PARTIAL_SPAN.encode(s);\n+        }\n+\n+        if let Some(parent) = span_data.parent {\n+            let enclosing = s.tcx.definitions_untracked().def_span(parent).data();\n+            if enclosing.contains(span_data) {\n+                TAG_RELATIVE_SPAN.encode(s)?;\n+                (span_data.lo - enclosing.lo).to_u32().encode(s)?;\n+                (span_data.hi - enclosing.lo).to_u32().encode(s)?;\n+                return Ok(());\n+            }\n         }\n \n         let pos = s.source_map.byte_pos_to_line_and_col(span_data.lo);\n@@ -1021,8 +1047,7 @@ where\n         };\n \n         if partial_span {\n-            TAG_PARTIAL_SPAN.encode(s)?;\n-            return span_data.ctxt.encode(s);\n+            return TAG_PARTIAL_SPAN.encode(s);\n         }\n \n         let (file_lo, line_lo, col_lo) = pos.unwrap();\n@@ -1035,8 +1060,7 @@ where\n         source_file_index.encode(s)?;\n         line_lo.encode(s)?;\n         col_lo.encode(s)?;\n-        len.encode(s)?;\n-        span_data.ctxt.encode(s)\n+        len.encode(s)\n     }\n }\n "}, {"sha": "787c7a625d5165e9647816924695a0e79952b527", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e85ddeb474665f3af7c447445c273da6117e266d", "patch": "@@ -1114,6 +1114,11 @@ impl ResolverAstLowering for Resolver<'_> {\n         }\n     }\n \n+    #[inline]\n+    fn def_span(&self, id: LocalDefId) -> Span {\n+        self.definitions.def_span(id)\n+    }\n+\n     fn item_generics_num_lifetimes(&self, def_id: DefId) -> usize {\n         if let Some(def_id) = def_id.as_local() {\n             self.item_generics_num_lifetimes[&def_id]\n@@ -1221,6 +1226,11 @@ impl<'a, 'b> rustc_span::HashStableContext for ExpandHasher<'a, 'b> {\n         true\n     }\n \n+    #[inline]\n+    fn def_span(&self, id: LocalDefId) -> Span {\n+        self.resolver.def_span(id)\n+    }\n+\n     #[inline]\n     fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n         self.resolver.def_path_hash(def_id)"}, {"sha": "de08c5d8a55431e5c41474acaddfeb9ba71f853d", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ddeb474665f3af7c447445c273da6117e266d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=e85ddeb474665f3af7c447445c273da6117e266d", "patch": "@@ -2001,6 +2001,7 @@ impl InnerSpan {\n pub trait HashStableContext {\n     fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n     fn hash_spans(&self) -> bool;\n+    fn def_span(&self, def_id: LocalDefId) -> Span;\n     fn span_data_to_lines_and_cols(\n         &mut self,\n         span: &SpanData,\n@@ -2024,22 +2025,35 @@ where\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n+        const TAG_RELATIVE_SPAN: u8 = 2;\n \n         if !ctx.hash_spans() {\n             return;\n         }\n \n-        self.ctxt().hash_stable(ctx, hasher);\n+        let span = self.data();\n+        span.ctxt.hash_stable(ctx, hasher);\n+        span.parent.hash_stable(ctx, hasher);\n \n-        if self.is_dummy() {\n+        if span.is_dummy() {\n             Hash::hash(&TAG_INVALID_SPAN, hasher);\n             return;\n         }\n \n+        if let Some(parent) = span.parent {\n+            let def_span = ctx.def_span(parent).data();\n+            if def_span.contains(span) {\n+                // This span is enclosed in a definition: only hash the relative position.\n+                Hash::hash(&TAG_RELATIVE_SPAN, hasher);\n+                (span.lo - def_span.lo).to_u32().hash_stable(ctx, hasher);\n+                (span.hi - def_span.lo).to_u32().hash_stable(ctx, hasher);\n+                return;\n+            }\n+        }\n+\n         // If this is not an empty or invalid span, we want to hash the last\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n-        let span = self.data();\n         let (file, line_lo, col_lo, line_hi, col_hi) = match ctx.span_data_to_lines_and_cols(&span)\n         {\n             Some(pos) => pos,"}]}