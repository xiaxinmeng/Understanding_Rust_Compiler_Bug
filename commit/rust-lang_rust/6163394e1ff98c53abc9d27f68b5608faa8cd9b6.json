{"sha": "6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNjMzOTRlMWZmOThjNTNhYmM5ZDI3ZjY4YjU2MDhmYWE4Y2Q5YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T14:15:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T14:15:18Z"}, "message": "Auto merge of #72262 - Dylan-DPC:rollup-x56q1jj, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #71625 (Improve the documentation for ManuallyDrop to resolve conflicting usage of terminology)\n - #71919 (Update transitive dependency to work towards removing syn <1.0 dep)\n - #72166 (Simpler slice `Iterator` methods)\n - #72216 (Remove `lang_items\\(\\).*\\.unwrap\\(\\)`)\n - #72230 (Updated documentation of Prefix::VerbatimDisk)\n - #72234 (Implement Default for proc_macro::TokenStream)\n - #72258 (Fix typo Arbintrary to Arbitrary)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2bf91dbd14be1303f249ff73fe3ff2bd7c3fdea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bf91dbd14be1303f249ff73fe3ff2bd7c3fdea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "html_url": "https://github.com/rust-lang/rust/commit/6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31add7e60709445617ab54a69f6f21cfcb2e3122", "url": "https://api.github.com/repos/rust-lang/rust/commits/31add7e60709445617ab54a69f6f21cfcb2e3122", "html_url": "https://github.com/rust-lang/rust/commit/31add7e60709445617ab54a69f6f21cfcb2e3122"}, {"sha": "e43dd47db2192a492f1f2124752b4039d655880b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e43dd47db2192a492f1f2124752b4039d655880b", "html_url": "https://github.com/rust-lang/rust/commit/e43dd47db2192a492f1f2124752b4039d655880b"}], "stats": {"total": 333, "additions": 218, "deletions": 115}, "files": [{"sha": "d6357823a37f2fcbb76f306499fcd61dee07704f", "filename": "Cargo.lock", "status": "modified", "additions": 31, "deletions": 55, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -438,7 +438,7 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -937,13 +937,13 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"derive-new\"\n-version = \"0.5.6\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n+checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -1144,14 +1144,14 @@ dependencies = [\n \n [[package]]\n name = \"failure_derive\"\n-version = \"0.1.5\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n+checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"synstructure 0.10.2\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -1404,30 +1404,18 @@ dependencies = [\n \n [[package]]\n name = \"handlebars\"\n-version = \"2.0.1\"\n+version = \"3.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n+checksum = \"ba758d094d31274eb49d15da6f326b96bf3185239a6359bf684f3d5321148900\"\n dependencies = [\n- \"hashbrown 0.5.0\",\n- \"lazy_static 1.4.0\",\n  \"log\",\n  \"pest\",\n  \"pest_derive\",\n  \"quick-error\",\n- \"regex\",\n  \"serde\",\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"hashbrown\"\n version = \"0.6.2\"\n@@ -2054,9 +2042,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.3.5\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"031bdd9d4893c983e2f69ebc4b59070feee8276a584c4aabdcb351235ea28016\"\n+checksum = \"e7ec525f7ebccc2dd935c263717250cd37f9a4b264a77c5dbc950ea2734d8159\"\n dependencies = [\n  \"ammonia\",\n  \"chrono\",\n@@ -2556,15 +2544,15 @@ dependencies = [\n \n [[package]]\n name = \"pest_generator\"\n-version = \"2.1.0\"\n+version = \"2.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n+checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -2784,9 +2772,9 @@ checksum = \"6ddd112cca70a4d30883b2d21568a1d376ff8be4758649f64f973c6845128ad3\"\n \n [[package]]\n name = \"quick-error\"\n-version = \"1.2.2\"\n+version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n+checksum = \"a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0\"\n \n [[package]]\n name = \"quine-mc_cluskey\"\n@@ -3448,7 +3436,7 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -4058,7 +4046,7 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -4629,13 +4617,13 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.81\"\n+version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n+checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -4799,7 +4787,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.6.2\",\n+ \"hashbrown\",\n  \"hermit-abi\",\n  \"libc\",\n  \"panic_abort\",\n@@ -4931,18 +4919,6 @@ dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n-[[package]]\n-name = \"synstructure\"\n-version = \"0.10.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"unicode-xid 0.1.0\",\n-]\n-\n [[package]]\n name = \"synstructure\"\n version = \"0.12.1\""}, {"sha": "447db405c02805d040ff8ade6918e3e1e883f9ec", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -333,7 +333,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in self {\n+        while let Some(x) = self.next() {\n             if n == 0 {\n                 return Some(x);\n             }"}, {"sha": "17863dd38afeeceb086d859d3a7896c829d62b17", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -7,14 +7,14 @@ use crate::ptr;\n ///\n /// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n /// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about all values being initialized at their type.  In particular, initializing\n-/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// about its contents. For example, initializing a `ManuallyDrop<&mut T>`\n+/// with [`mem::zeroed`] is undefined behavior.\n /// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n ///\n /// # Examples\n ///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n+/// This wrapper can be used to enforce a particular drop order on fields, regardless\n+/// of how they are defined in the struct:\n ///\n /// ```rust\n /// use std::mem::ManuallyDrop;\n@@ -43,8 +43,18 @@ use crate::ptr;\n /// }\n /// ```\n ///\n+/// However, care should be taken when using this pattern as it can lead to *leak amplification*.\n+/// In this example, if the `Drop` implementation for `Peach` were to panic, the `banana` field\n+/// would also be leaked.\n+///\n+/// In contrast, the automatically-generated compiler drop implementation would have ensured\n+/// that all fields are dropped even in the presence of panics. This is especially important when\n+/// working with [pinned] data, where reusing the memory without calling the destructor could lead\n+/// to Undefined Behaviour.\n+///\n /// [`mem::zeroed`]: fn.zeroed.html\n /// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [pinned]: ../pin/index.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -113,19 +123,28 @@ impl<T> ManuallyDrop<T> {\n }\n \n impl<T: ?Sized> ManuallyDrop<T> {\n-    /// Manually drops the contained value.\n+    /// Manually drops the contained value. This is exactly equivalent to calling\n+    /// [`ptr::drop_in_place`] with a pointer to the contained value. As such, unless\n+    /// the contained value is a packed struct, the destructor will be called in-place\n+    /// without moving the value, and thus can be used to safely drop [pinned] data.\n     ///\n     /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n     ///\n     /// # Safety\n     ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    /// In particular, this function can only be called at most once\n-    /// for a given instance of `ManuallyDrop<T>`.\n+    /// This function runs the destructor of the contained value. Other than changes made by\n+    /// the destructor itself, the memory is left unchanged, and so as far as the compiler is\n+    /// concerned still holds a bit-pattern which is valid for the type `T`.\n+    ///\n+    /// However, this \"zombie\" value should not be exposed to safe code, and this function\n+    /// should not be called more than once. To use a value after it's been dropped, or drop\n+    /// a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n+    /// This is normally prevented by the type system, but users of `ManuallyDrop` must\n+    /// uphold those guarantees without assistance from the compiler.\n     ///\n     /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    /// [`ptr::drop_in_place`]: ../ptr/fn.drop_in_place.html\n+    /// [pinned]: ../pin/index.html\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {"}, {"sha": "ecc70adda4111c764bb084f1bcab5bc907a772b2", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -110,11 +110,17 @@ mod mut_ptr;\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n+///   (pinned data must not be moved before it is dropped).\n+///\n /// Unaligned values cannot be dropped in place, they must be copied to an aligned\n-/// location first using [`ptr::read_unaligned`].\n+/// location first using [`ptr::read_unaligned`]. For packed structs, this move is\n+/// done automatically by the compiler. This means the fields of packed structs\n+/// are not dropped in-place.\n ///\n /// [`ptr::read`]: ../ptr/fn.read.html\n /// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n+/// [pinned]: ../pin/index.html\n ///\n /// # Safety\n ///"}, {"sha": "3386f83ec810fb36035efcbe4b9ab4915c433c1f", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 105, "deletions": 17, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -3179,6 +3179,7 @@ macro_rules! is_empty {\n         $self.ptr.as_ptr() as *const T == $self.end\n     };\n }\n+\n // To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n // unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n macro_rules! len {\n@@ -3347,40 +3348,127 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn for_each<F>(mut self, mut f: F)\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item),\n+            {\n+                while let Some(x) = self.next() {\n+                    f(x);\n+                }\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn all<F>(&mut self, mut f: F) -> bool\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if !f(x) {\n+                        return false;\n+                    }\n+                }\n+                true\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn any<F>(&mut self, mut f: F) -> bool\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if f(x) {\n+                        return true;\n+                    }\n+                }\n+                false\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+            where\n+                Self: Sized,\n+                P: FnMut(&Self::Item) -> bool,\n+            {\n+                while let Some(x) = self.next() {\n+                    if predicate(&x) {\n+                        return Some(x);\n+                    }\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile.\n+            #[inline]\n+            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n+            where\n+                Self: Sized,\n+                F: FnMut(Self::Item) -> Option<B>,\n+            {\n+                while let Some(x) = self.next() {\n+                    if let Some(y) = f(x) {\n+                        return Some(y);\n+                    }\n+                }\n+                None\n+            }\n+\n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile. Also, the `assume` avoids a bounds check.\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                 Self: Sized,\n                 P: FnMut(Self::Item) -> bool,\n             {\n-                // The addition might panic on overflow.\n                 let n = len!(self);\n-                self.try_fold(0, move |i, x| {\n-                    if predicate(x) { Err(i) }\n-                    else { Ok(i + 1) }\n-                }).err()\n-                    .map(|i| {\n+                let mut i = 0;\n+                while let Some(x) = self.next() {\n+                    if predicate(x) {\n                         unsafe { assume(i < n) };\n-                        i\n-                    })\n+                        return Some(i);\n+                    }\n+                    i += 1;\n+                }\n+                None\n             }\n \n+            // We override the default implementation, which uses `try_fold`,\n+            // because this simple implementation generates less LLVM IR and is\n+            // faster to compile. Also, the `assume` avoids a bounds check.\n             #[inline]\n             fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                 P: FnMut(Self::Item) -> bool,\n                 Self: Sized + ExactSizeIterator + DoubleEndedIterator\n             {\n-                // No need for an overflow check here, because `ExactSizeIterator`\n                 let n = len!(self);\n-                self.try_rfold(n, move |i, x| {\n-                    let i = i - 1;\n-                    if predicate(x) { Err(i) }\n-                    else { Ok(i) }\n-                }).err()\n-                    .map(|i| {\n+                let mut i = n;\n+                while let Some(x) = self.next_back() {\n+                    i -= 1;\n+                    if predicate(x) {\n                         unsafe { assume(i < n) };\n-                        i\n-                    })\n+                        return Some(i);\n+                    }\n+                }\n+                None\n             }\n \n             $($extra)*"}, {"sha": "b6544341fa95bb66d6b624c1b292e1ecbbf80017", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -158,6 +158,13 @@ impl fmt::Debug for TokenStream {\n     }\n }\n \n+#[stable(feature = \"proc_macro_token_stream_default\", since = \"1.45.0\")]\n+impl Default for TokenStream {\n+    fn default() -> Self {\n+        TokenStream::new()\n+    }\n+}\n+\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub use quote::{quote, quote_span};\n "}, {"sha": "0d29d56ea1a75c2cccbc00eba0b5f1714fb7ec58", "filename": "src/librustc_error_codes/error_codes/E0307.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -64,7 +64,7 @@ impl Trait for Foo {\n }\n ```\n \n-The nightly feature [Arbintrary self types][AST] extends the accepted\n+The nightly feature [Arbitrary self types][AST] extends the accepted\n set of receiver types to also include any type that can dereference to\n `Self`:\n "}, {"sha": "28edd87a3add5e055ebbeac083bb8f87ae559e2f", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -2,6 +2,8 @@ use rustc_middle::traits;\n use rustc_middle::ty::adjustment::CustomCoerceUnsized;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n+use rustc_hir::lang_items::CoerceUnsizedTraitLangItem;\n+\n pub mod collector;\n pub mod partitioning;\n \n@@ -10,7 +12,7 @@ pub fn custom_coerce_unsize_info<'tcx>(\n     source_ty: Ty<'tcx>,\n     target_ty: Ty<'tcx>,\n ) -> CustomCoerceUnsized {\n-    let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n+    let def_id = tcx.require_lang_item(CoerceUnsizedTraitLangItem, None);\n \n     let trait_ref = ty::Binder::bind(ty::TraitRef {\n         def_id,"}, {"sha": "28ec2ca13d5af7f83e740ffe671f8b35942134f7", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -141,7 +141,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // code at the moment, because types like `for <'a> fn(&'a ())` do\n                 // not *yet* implement `PartialEq`. So for now we leave this here.\n                 let ty_is_partial_eq: bool = {\n-                    let partial_eq_trait_id = self.tcx().require_lang_item(EqTraitLangItem, None);\n+                    let partial_eq_trait_id =\n+                        self.tcx().require_lang_item(EqTraitLangItem, Some(self.span));\n                     let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n                         self.tcx(),\n                         self.param_env,"}, {"sha": "eb63505b69b413a73a8d0f8783a88c57a727012c", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -4,6 +4,7 @@ use crate::traits::{self, ConstPatternStructural, TraitEngine};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_hir::lang_items::{StructuralPeqTraitLangItem, StructuralTeqTraitLangItem};\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -69,7 +70,7 @@ pub fn type_marked_structural(\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n     let cause = ObligationCause::new(span, id, ConstPatternStructural);\n     // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id = infcx.tcx.lang_items().structural_peq_trait().unwrap();\n+    let structural_peq_def_id = infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n@@ -80,7 +81,7 @@ pub fn type_marked_structural(\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n     let cause = ObligationCause::new(span, id, ConstPatternStructural);\n-    let structural_teq_def_id = infcx.tcx.lang_items().structural_teq_trait().unwrap();\n+    let structural_teq_def_id = infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),"}, {"sha": "87a6f119acb09a6b34a26b774ce9b29d189a8e04", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::AstConv;\n use crate::middle::region;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::{FutureTraitLangItem, GeneratorTraitLangItem};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n@@ -245,7 +245,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n         let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n-        let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n+        let gen_trait = tcx.require_lang_item(GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Check that this is a projection from the `Future` trait.\n         let trait_ref = predicate.projection_ty.trait_ref(self.tcx);\n-        let future_trait = self.tcx.lang_items().future_trait().unwrap();\n+        let future_trait = self.tcx.require_lang_item(FutureTraitLangItem, Some(cause_span));\n         if trait_ref.def_id != future_trait {\n             debug!(\"deduce_future_output_from_projection: not a future\");\n             return None;"}, {"sha": "9694ce9450c27ec3565e9686ba3e3b35c4e3e404", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -7,7 +7,7 @@ use rustc_trait_selection::traits::{self, ObligationCause};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::lang_items::DerefTraitLangItem;\n+use rustc_hir::lang_items::{CloneTraitLangItem, DerefTraitLangItem};\n use rustc_hir::{is_range_literal, Node};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n@@ -456,8 +456,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.kind {\n-                        let clone_trait = self.tcx.lang_items().clone_trait().unwrap();\n+                    if let hir::ExprKind::MethodCall(ref segment, sp, ref args) = expr.kind {\n+                        let clone_trait = self.tcx.require_lang_item(CloneTraitLangItem, Some(sp));\n                         if let ([arg], Some(true), sym::clone) = (\n                             &args[..],\n                             self.tables.borrow().type_dependent_def_id(expr.hir_id).map(|did| {\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ if sp == expr.span && !is_macro => {\n                 // Check for `Deref` implementations by constructing a predicate to\n                 // prove: `<T as Deref>::Output == U`\n-                let deref_trait = self.tcx.require_lang_item(DerefTraitLangItem, Some(expr.span));\n+                let deref_trait = self.tcx.require_lang_item(DerefTraitLangItem, Some(sp));\n                 let item_def_id = self\n                     .tcx\n                     .associated_items(deref_trait)"}, {"sha": "6bf836015d226b6596885d95304c96388b544958", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -100,7 +100,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::lang_items;\n+use rustc_hir::lang_items::{\n+    FutureTraitLangItem, PinTypeLangItem, SizedTraitLangItem, VaListTypeLangItem,\n+};\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n@@ -1335,10 +1337,8 @@ fn check_fn<'a, 'tcx>(\n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did = tcx.require_lang_item(\n-            lang_items::VaListTypeLangItem,\n-            Some(body.params.last().unwrap().span),\n-        );\n+        let va_list_did =\n+            tcx.require_lang_item(VaListTypeLangItem, Some(body.params.last().unwrap().span));\n         let region = tcx.mk_region(ty::ReScope(region::Scope {\n             id: body.value.hir_id.local_id,\n             data: region::ScopeData::CallSite,\n@@ -3296,7 +3296,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         code: traits::ObligationCauseCode<'tcx>,\n     ) {\n         if !ty.references_error() {\n-            let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n+            let lang_item = self.tcx.require_lang_item(SizedTraitLangItem, None);\n             self.require_type_meets(ty, span, code, lang_item);\n         }\n     }\n@@ -5135,7 +5135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => {}\n         }\n         let boxed_found = self.tcx.mk_box(found);\n-        let new_found = self.tcx.mk_lang_item(boxed_found, lang_items::PinTypeLangItem).unwrap();\n+        let new_found = self.tcx.mk_lang_item(boxed_found, PinTypeLangItem).unwrap();\n         if let (true, Ok(snippet)) = (\n             self.can_coerce(new_found, expected),\n             self.sess().source_map().span_to_snippet(expr.span),\n@@ -5292,7 +5292,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let sp = expr.span;\n                 // Check for `Future` implementations by constructing a predicate to\n                 // prove: `<T as Future>::Output == U`\n-                let future_trait = self.tcx.lang_items().future_trait().unwrap();\n+                let future_trait = self.tcx.require_lang_item(FutureTraitLangItem, Some(sp));\n                 let item_def_id = self\n                     .tcx\n                     .associated_items(future_trait)"}, {"sha": "efa3cd9955b49610ad1537568bb145f130dbf4e5", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -4,7 +4,9 @@\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::lang_items::UnsizeTraitLangItem;\n+use rustc_hir::lang_items::{\n+    CoerceUnsizedTraitLangItem, DispatchFromDynTraitLangItem, UnsizeTraitLangItem,\n+};\n use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n@@ -145,11 +147,11 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: LocalDefI\n fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n-    let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n-\n     let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n     let span = tcx.hir().span(impl_hir_id);\n \n+    let dispatch_from_dyn_trait = tcx.require_lang_item(DispatchFromDynTraitLangItem, Some(span));\n+\n     let source = tcx.type_of(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n     let target = {\n@@ -314,22 +316,23 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n+\n+    // this provider should only get invoked for local def-ids\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n+    let span = tcx.hir().span(impl_hir_id);\n+\n+    let coerce_unsized_trait = tcx.require_lang_item(CoerceUnsizedTraitLangItem, Some(span));\n \n     let unsize_trait = tcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n         tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n     });\n \n-    // this provider should only get invoked for local def-ids\n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n-\n     let source = tcx.type_of(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\", source, target);\n \n-    let span = tcx.hir().span(impl_hir_id);\n     let param_env = tcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n "}, {"sha": "8516e80f3b876630489ba7a2f39c8d6654f7ddee", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -157,10 +157,10 @@ pub enum Prefix<'a> {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n     ),\n \n-    /// Verbatim disk prefix, e.g., `\\\\?\\C:\\`.\n+    /// Verbatim disk prefix, e.g., `\\\\?\\C:`.\n     ///\n     /// Verbatim disk prefixes consist of `\\\\?\\` immediately followed by the\n-    /// drive letter and `:\\`.\n+    /// drive letter and `:`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     VerbatimDisk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n "}, {"sha": "ff41197faa1a6d187316febf75d518ceca3043f2", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6163394e1ff98c53abc9d27f68b5608faa8cd9b6/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=6163394e1ff98c53abc9d27f68b5608faa8cd9b6", "patch": "@@ -23,6 +23,6 @@ codespan-reporting = { version = \"0.5\", optional = true }\n rustc-workspace-hack = \"1.0.0\"\n \n [dependencies.mdbook]\n-version = \"0.3.0\"\n+version = \"0.3.7\"\n default-features = false\n features = [\"search\"]"}]}