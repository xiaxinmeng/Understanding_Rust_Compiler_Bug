{"sha": "3ce97000e1a4909dc106ac0a50d936c604f96725", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZTk3MDAwZTFhNDkwOWRjMTA2YWMwYTUwZDkzNmM2MDRmOTY3MjU=", "commit": {"author": {"name": "Daniel Conley", "email": "danielc030417@gmail.com", "date": "2021-01-09T22:55:41Z"}, "committer": {"name": "Daniel Conley", "email": "danielc030417@gmail.com", "date": "2021-01-22T00:36:32Z"}, "message": "library/core/test/iter.rs split attempt 2", "tree": {"sha": "753944adfbd1d053de4dc129de04387c326bed3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/753944adfbd1d053de4dc129de04387c326bed3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ce97000e1a4909dc106ac0a50d936c604f96725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce97000e1a4909dc106ac0a50d936c604f96725", "html_url": "https://github.com/rust-lang/rust/commit/3ce97000e1a4909dc106ac0a50d936c604f96725", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ce97000e1a4909dc106ac0a50d936c604f96725/comments", "author": {"login": "danii", "id": 39541871, "node_id": "MDQ6VXNlcjM5NTQxODcx", "avatar_url": "https://avatars.githubusercontent.com/u/39541871?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danii", "html_url": "https://github.com/danii", "followers_url": "https://api.github.com/users/danii/followers", "following_url": "https://api.github.com/users/danii/following{/other_user}", "gists_url": "https://api.github.com/users/danii/gists{/gist_id}", "starred_url": "https://api.github.com/users/danii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danii/subscriptions", "organizations_url": "https://api.github.com/users/danii/orgs", "repos_url": "https://api.github.com/users/danii/repos", "events_url": "https://api.github.com/users/danii/events{/privacy}", "received_events_url": "https://api.github.com/users/danii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danii", "id": 39541871, "node_id": "MDQ6VXNlcjM5NTQxODcx", "avatar_url": "https://avatars.githubusercontent.com/u/39541871?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danii", "html_url": "https://github.com/danii", "followers_url": "https://api.github.com/users/danii/followers", "following_url": "https://api.github.com/users/danii/following{/other_user}", "gists_url": "https://api.github.com/users/danii/gists{/gist_id}", "starred_url": "https://api.github.com/users/danii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danii/subscriptions", "organizations_url": "https://api.github.com/users/danii/orgs", "repos_url": "https://api.github.com/users/danii/repos", "events_url": "https://api.github.com/users/danii/events{/privacy}", "received_events_url": "https://api.github.com/users/danii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "202720bf483088dbdb343f78c0aa77067fdd8156", "url": "https://api.github.com/repos/rust-lang/rust/commits/202720bf483088dbdb343f78c0aa77067fdd8156", "html_url": "https://github.com/rust-lang/rust/commit/202720bf483088dbdb343f78c0aa77067fdd8156"}], "stats": {"total": 7255, "additions": 3574, "deletions": 3681}, "files": [{"sha": "78b4d1acaf5cd3119d619b79dab7a2bbdf749136", "filename": "library/core/tests/iter.rs", "status": "removed", "additions": 0, "deletions": 3681, "changes": 3681, "blob_url": "https://github.com/rust-lang/rust/blob/202720bf483088dbdb343f78c0aa77067fdd8156/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202720bf483088dbdb343f78c0aa77067fdd8156/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=202720bf483088dbdb343f78c0aa77067fdd8156"}, {"sha": "df2596322dea3b4d50b8103e4ce92f20e45b08da", "filename": "library/core/tests/iter/adapters/chain.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fchain.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,217 @@\n+use super::*;\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_chain() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    let it = xs.iter().chain(&ys);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    let ys = (30..).step_by(10).take(4);\n+    let it = xs.iter().cloned().chain(ys);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+#[test]\n+fn test_iterator_chain_advance_by() {\n+    fn test_chain(xs: &[i32], ys: &[i32]) {\n+        let len = xs.len() + ys.len();\n+\n+        for i in 0..xs.len() {\n+            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n+            iter.advance_by(i).unwrap();\n+            assert_eq!(iter.next(), Some(&xs[i]));\n+            assert_eq!(iter.advance_by(100), Err(len - i - 1));\n+        }\n+\n+        for i in 0..ys.len() {\n+            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n+            iter.advance_by(xs.len() + i).unwrap();\n+            assert_eq!(iter.next(), Some(&ys[i]));\n+            assert_eq!(iter.advance_by(100), Err(ys.len() - i - 1));\n+        }\n+\n+        let mut iter = xs.iter().chain(ys);\n+        iter.advance_by(len).unwrap();\n+        assert_eq!(iter.next(), None);\n+\n+        let mut iter = xs.iter().chain(ys);\n+        assert_eq!(iter.advance_by(len + 1), Err(len));\n+    }\n+\n+    test_chain(&[], &[]);\n+    test_chain(&[], &[0, 1, 2, 3, 4, 5]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[30, 40, 50, 60]);\n+}\n+#[test]\n+fn test_iterator_chain_advance_back_by() {\n+    fn test_chain(xs: &[i32], ys: &[i32]) {\n+        let len = xs.len() + ys.len();\n+\n+        for i in 0..ys.len() {\n+            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n+            iter.advance_back_by(i).unwrap();\n+            assert_eq!(iter.next_back(), Some(&ys[ys.len() - i - 1]));\n+            assert_eq!(iter.advance_back_by(100), Err(len - i - 1));\n+        }\n+\n+        for i in 0..xs.len() {\n+            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n+            iter.advance_back_by(ys.len() + i).unwrap();\n+            assert_eq!(iter.next_back(), Some(&xs[xs.len() - i - 1]));\n+            assert_eq!(iter.advance_back_by(100), Err(xs.len() - i - 1));\n+        }\n+\n+        let mut iter = xs.iter().chain(ys);\n+        iter.advance_back_by(len).unwrap();\n+        assert_eq!(iter.next_back(), None);\n+\n+        let mut iter = xs.iter().chain(ys);\n+        assert_eq!(iter.advance_back_by(len + 1), Err(len));\n+    }\n+\n+    test_chain(&[], &[]);\n+    test_chain(&[], &[0, 1, 2, 3, 4, 5]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[30, 40, 50, 60]);\n+}\n+#[test]\n+fn test_iterator_chain_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    for (i, x) in expected.iter().enumerate() {\n+        assert_eq!(Some(x), xs.iter().chain(&ys).nth(i));\n+    }\n+    assert_eq!(zs.iter().chain(&xs).nth(0), Some(&0));\n+\n+    let mut it = xs.iter().chain(&zs);\n+    assert_eq!(it.nth(5), Some(&5));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_iterator_chain_nth_back() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    for (i, x) in expected.iter().rev().enumerate() {\n+        assert_eq!(Some(x), xs.iter().chain(&ys).nth_back(i));\n+    }\n+    assert_eq!(zs.iter().chain(&xs).nth_back(0), Some(&5));\n+\n+    let mut it = xs.iter().chain(&zs);\n+    assert_eq!(it.nth_back(5), Some(&0));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_iterator_chain_last() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    assert_eq!(xs.iter().chain(&ys).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(&ys).last(), Some(&60));\n+    assert_eq!(ys.iter().chain(&zs).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(&zs).last(), None);\n+}\n+#[test]\n+fn test_iterator_chain_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    assert_eq!(xs.iter().chain(&ys).count(), 10);\n+    assert_eq!(zs.iter().chain(&ys).count(), 4);\n+}\n+#[test]\n+fn test_iterator_chain_find() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let mut iter = xs.iter().chain(&ys);\n+    assert_eq!(iter.find(|&&i| i == 4), Some(&4));\n+    assert_eq!(iter.next(), Some(&5));\n+    assert_eq!(iter.find(|&&i| i == 40), Some(&40));\n+    assert_eq!(iter.next(), Some(&50));\n+    assert_eq!(iter.find(|&&i| i == 100), None);\n+    assert_eq!(iter.next(), None);\n+}\n+#[test]\n+fn test_iterator_chain_size_hint() {\n+    // this chains an iterator of length 0 with an iterator of length 1,\n+    // so after calling `.next()` once, the iterator is empty and the\n+    // state is `ChainState::Back`. `.size_hint()` should now disregard\n+    // the size hint of the left iterator\n+    let mut iter = Toggle { is_empty: true }.chain(once(()));\n+    assert_eq!(iter.next(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n+    let mut iter = once(()).chain(Toggle { is_empty: true });\n+    assert_eq!(iter.next_back(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+}\n+#[test]\n+fn test_iterator_chain_unfused() {\n+    // Chain shouldn't be fused in its second iterator, depending on direction\n+    let mut iter = NonFused::new(empty()).chain(Toggle { is_empty: true });\n+    iter.next().unwrap_none();\n+    iter.next().unwrap();\n+    iter.next().unwrap_none();\n+\n+    let mut iter = Toggle { is_empty: true }.chain(NonFused::new(empty()));\n+    iter.next_back().unwrap_none();\n+    iter.next_back().unwrap();\n+    iter.next_back().unwrap_none();\n+}\n+#[test]\n+fn test_chain_fold() {\n+    let xs = [1, 2, 3];\n+    let ys = [1, 2, 0];\n+\n+    let mut iter = xs.iter().chain(&ys);\n+    iter.next();\n+    let mut result = Vec::new();\n+    iter.fold((), |(), &elt| result.push(elt));\n+    assert_eq!(&[2, 3, 1, 2, 0], &result[..]);\n+}\n+#[test]\n+fn test_chain_try_folds() {\n+    let c = || (0..10).chain(10..20);\n+\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!(c().try_fold(7, f), (0..20).try_fold(7, f));\n+    assert_eq!(c().try_rfold(7, f), (0..20).rev().try_fold(7, f));\n+\n+    let mut iter = c();\n+    assert_eq!(iter.position(|x| x == 5), Some(5));\n+    assert_eq!(iter.next(), Some(6), \"stopped in front, state Both\");\n+    assert_eq!(iter.position(|x| x == 13), Some(6));\n+    assert_eq!(iter.next(), Some(14), \"stopped in back, state Back\");\n+    assert_eq!(iter.try_fold(0, |acc, x| Some(acc + x)), Some((15..20).sum()));\n+\n+    let mut iter = c().rev(); // use rev to access try_rfold\n+    assert_eq!(iter.position(|x| x == 15), Some(4));\n+    assert_eq!(iter.next(), Some(14), \"stopped in back, state Both\");\n+    assert_eq!(iter.position(|x| x == 5), Some(8));\n+    assert_eq!(iter.next(), Some(4), \"stopped in front, state Front\");\n+    assert_eq!(iter.try_fold(0, |acc, x| Some(acc + x)), Some((0..4).sum()));\n+\n+    let mut iter = c();\n+    iter.by_ref().rev().nth(14); // skip the last 15, ending in state Front\n+    assert_eq!(iter.try_fold(7, f), (0..5).try_fold(7, f));\n+\n+    let mut iter = c();\n+    iter.nth(14); // skip the first 15, ending in state Back\n+    assert_eq!(iter.try_rfold(7, f), (15..20).try_rfold(7, f));\n+}"}, {"sha": "f1b3a4b7933a7ed0eceb31dc5afd8c7f3291258b", "filename": "library/core/tests/iter/adapters/cloned.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcloned.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,50 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_cloned() {\n+    let xs = [2, 4, 6, 8];\n+\n+    let mut it = xs.iter().cloned();\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next(), Some(4));\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back(), Some(8));\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next_back(), None);\n+}\n+#[test]\n+fn test_cloned_side_effects() {\n+    let mut count = 0;\n+    {\n+        let iter = [1, 2, 3]\n+            .iter()\n+            .map(|x| {\n+                count += 1;\n+                x\n+            })\n+            .cloned()\n+            .zip(&[1]);\n+        for _ in iter {}\n+    }\n+    assert_eq!(count, 2);\n+}\n+#[test]\n+fn test_cloned_try_folds() {\n+    let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    let f_ref = &|acc, &x| i32::checked_add(2 * acc, x);\n+    assert_eq!(a.iter().cloned().try_fold(7, f), a.iter().try_fold(7, f_ref));\n+    assert_eq!(a.iter().cloned().try_rfold(7, f), a.iter().try_rfold(7, f_ref));\n+\n+    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n+    let mut iter = a.iter().cloned();\n+    assert_eq!(iter.try_fold(0_i8, |acc, x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(60));\n+    let mut iter = a.iter().cloned();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(70));\n+}"}, {"sha": "b12f2035dc133378a6629f10790f7fd1bb372472", "filename": "library/core/tests/iter/adapters/copied.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcopied.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,18 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_copied() {\n+    let xs = [2, 4, 6, 8];\n+\n+    let mut it = xs.iter().copied();\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next(), Some(4));\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back(), Some(8));\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next_back(), None);\n+}"}, {"sha": "8831c09b48b3f6674c11cb253cb9409e529bc08b", "filename": "library/core/tests/iter/adapters/cycle.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fcycle.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,31 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_cycle() {\n+    let cycle_len = 3;\n+    let it = (0..).step_by(1).take(cycle_len).cycle();\n+    assert_eq!(it.size_hint(), (usize::MAX, None));\n+    for (i, x) in it.take(100).enumerate() {\n+        assert_eq!(i % cycle_len, x);\n+    }\n+\n+    let mut it = (0..).step_by(1).take(0).cycle();\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+\n+    assert_eq!(empty::<i32>().cycle().fold(0, |acc, x| acc + x), 0);\n+\n+    assert_eq!(once(1).cycle().skip(1).take(4).fold(0, |acc, x| acc + x), 4);\n+\n+    assert_eq!((0..10).cycle().take(5).sum::<i32>(), 10);\n+    assert_eq!((0..10).cycle().take(15).sum::<i32>(), 55);\n+    assert_eq!((0..10).cycle().take(25).sum::<i32>(), 100);\n+\n+    let mut iter = (0..10).cycle();\n+    iter.nth(14);\n+    assert_eq!(iter.take(8).sum::<i32>(), 38);\n+\n+    let mut iter = (0..10).cycle();\n+    iter.nth(9);\n+    assert_eq!(iter.take(3).sum::<i32>(), 3);\n+}"}, {"sha": "dfdf37dbedbeba7a1a845fa739e8ea656f16d6b5", "filename": "library/core/tests/iter/adapters/enumerate.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fenumerate.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,89 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_enumerate() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let it = xs.iter().enumerate();\n+    for (i, &x) in it {\n+        assert_eq!(i, x);\n+    }\n+}\n+#[test]\n+fn test_iterator_enumerate_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    for (i, &x) in xs.iter().enumerate() {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth(0) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth(1) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let (i, &x) = xs.iter().enumerate().nth(3).unwrap();\n+    assert_eq!(i, x);\n+    assert_eq!(i, 3);\n+}\n+#[test]\n+fn test_iterator_enumerate_nth_back() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth_back(0) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth_back(1) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let (i, &x) = xs.iter().enumerate().nth_back(3).unwrap();\n+    assert_eq!(i, x);\n+    assert_eq!(i, 2);\n+}\n+#[test]\n+fn test_iterator_enumerate_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    assert_eq!(xs.iter().enumerate().count(), 6);\n+}\n+#[test]\n+fn test_iterator_enumerate_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    // steal a couple to get an interesting offset\n+    assert_eq!(it.next(), Some((0, &0)));\n+    assert_eq!(it.next(), Some((1, &1)));\n+    let i = it.fold(2, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let mut it = xs.iter().enumerate();\n+    assert_eq!(it.next(), Some((0, &0)));\n+    let i = it.rfold(xs.len() - 1, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+#[test]\n+fn test_enumerate_try_folds() {\n+    let f = &|acc, (i, x)| usize::checked_add(2 * acc, x / (i + 1) + i);\n+    assert_eq!((9..18).enumerate().try_fold(7, f), (0..9).map(|i| (i, i + 9)).try_fold(7, f));\n+    assert_eq!((9..18).enumerate().try_rfold(7, f), (0..9).map(|i| (i, i + 9)).try_rfold(7, f));\n+\n+    let mut iter = (100..200).enumerate();\n+    let f = &|acc, (i, x)| u8::checked_add(acc, u8::checked_div(x, i as u8 + 1)?);\n+    assert_eq!(iter.try_fold(0, f), None);\n+    assert_eq!(iter.next(), Some((7, 107)));\n+    assert_eq!(iter.try_rfold(0, f), None);\n+    assert_eq!(iter.next_back(), Some((11, 111)));\n+}"}, {"sha": "fd1519ce532d652d942ac74cb42ca48df1fe11bc", "filename": "library/core/tests/iter/adapters/filter.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffilter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffilter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffilter.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,40 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_filter_count() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    assert_eq!(xs.iter().filter(|&&x| x % 2 == 0).count(), 5);\n+}\n+#[test]\n+fn test_iterator_filter_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0, 2, 4, 6, 8];\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+#[test]\n+fn test_filter_try_folds() {\n+    fn p(&x: &i32) -> bool {\n+        0 <= x && x < 10\n+    }\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((-10..20).filter(p).try_fold(7, f), (0..10).try_fold(7, f));\n+    assert_eq!((-10..20).filter(p).try_rfold(7, f), (0..10).try_rfold(7, f));\n+\n+    let mut iter = (0..40).filter(|&x| x % 2 == 1);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(25));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(31));\n+}"}, {"sha": "807a35eb0b90a6629023bb88d45a4de51af19208", "filename": "library/core/tests/iter/adapters/filter_map.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffilter_map.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,25 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_filter_map() {\n+    let it = (0..).step_by(1).take(10).filter_map(|x| if x % 2 == 0 { Some(x * x) } else { None });\n+    assert_eq!(it.collect::<Vec<usize>>(), [0 * 0, 2 * 2, 4 * 4, 6 * 6, 8 * 8]);\n+}\n+#[test]\n+fn test_filter_map_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0 * 0, 2 * 2, 4 * 4, 6 * 6, 8 * 8];\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x * x) } else { None });\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x * x) } else { None });\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}"}, {"sha": "fdd5d799e7299fe92bcddf36bc6b54a5087fc70c", "filename": "library/core/tests/iter/adapters/flat_map.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflat_map.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,53 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_flat_map() {\n+    let xs = [0, 3, 6];\n+    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let it = xs.iter().flat_map(|&x| (x..).step_by(1).take(3));\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+#[test]\n+fn test_iterator_flat_map_fold() {\n+    let xs = [0, 3, 6];\n+    let ys = [1, 2, 3, 4, 5, 6, 7];\n+    let mut it = xs.iter().flat_map(|&x| x..x + 3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().flat_map(|&x| x..x + 3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+#[test]\n+fn test_flat_map_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc * 2 / 3, x);\n+    let mr = &|x| (5 * x)..(5 * x + 5);\n+    assert_eq!((0..10).flat_map(mr).try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).flat_map(mr).try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).flat_map(mr);\n+    iter.next();\n+    iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).flat_map(|x| (4 * x)..(4 * x + 4));\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}"}, {"sha": "5b74026c32ce70fb77ad440cdc0c4e382b11c851", "filename": "library/core/tests/iter/adapters/flatten.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,71 @@\n+use super::*;\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_flatten() {\n+    let xs = [0, 3, 6];\n+    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let it = xs.iter().map(|&x| (x..).step_by(1).take(3)).flatten();\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+#[test]\n+fn test_iterator_flatten_fold() {\n+    let xs = [0, 3, 6];\n+    let ys = [1, 2, 3, 4, 5, 6, 7];\n+    let mut it = xs.iter().map(|&x| x..x + 3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().map(|&x| x..x + 3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+#[test]\n+fn test_flatten_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc * 2 / 3, x);\n+    let mr = &|x| (5 * x)..(5 * x + 5);\n+    assert_eq!((0..10).map(mr).flatten().try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).map(mr).flatten().try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).map(mr).flatten();\n+    iter.next();\n+    iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).map(|x| (4 * x)..(4 * x + 4)).flatten();\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}\n+#[test]\n+fn test_flatten_non_fused_outer() {\n+    let mut iter = NonFused::new(once(0..2)).flatten();\n+\n+    assert_eq!(iter.next_back(), Some(1));\n+    assert_eq!(iter.next(), Some(0));\n+    assert_eq!(iter.next(), None);\n+}\n+#[test]\n+fn test_flatten_non_fused_inner() {\n+    let mut iter = once(0..1).chain(once(1..3)).flat_map(NonFused::new);\n+\n+    assert_eq!(iter.next_back(), Some(2));\n+    assert_eq!(iter.next(), Some(0));\n+    assert_eq!(iter.next(), Some(1));\n+    assert_eq!(iter.next(), None);\n+}"}, {"sha": "181cee719d932cd0b3dc2d417e07a89ad2e9add1", "filename": "library/core/tests/iter/adapters/fuse.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ffuse.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,54 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_fuse_nth() {\n+    let xs = [0, 1, 2];\n+    let mut it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.nth(2), Some(&2));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.nth(2), None);\n+    assert_eq!(it.len(), 0);\n+}\n+#[test]\n+fn test_fuse_last() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.last(), Some(&2));\n+}\n+#[test]\n+fn test_fuse_count() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.count(), 3);\n+    // Can't check len now because count consumes.\n+}\n+#[test]\n+fn test_fuse_fold() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().rfold(xs.len(), |i, &x| {\n+        assert_eq!(x, xs[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+\n+    let it = xs.iter().scan((), |_, &x| Some(x)); // `!FusedIterator`\n+    let i = it.fuse().fold(0, |i, x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}"}, {"sha": "c411848e6f72e17fbd06a91a5037063b758cea07", "filename": "library/core/tests/iter/adapters/inspect.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Finspect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Finspect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Finspect.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,37 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_inspect() {\n+    let xs = [1, 2, 3, 4];\n+    let mut n = 0;\n+\n+    let ys = xs.iter().cloned().inspect(|_| n += 1).collect::<Vec<usize>>();\n+\n+    assert_eq!(n, xs.len());\n+    assert_eq!(&xs[..], &ys[..]);\n+}\n+#[test]\n+fn test_inspect_fold() {\n+    let xs = [1, 2, 3, 4];\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.fold(0, |i, &x| {\n+            assert_eq!(x, xs[i]);\n+            i + 1\n+        });\n+        assert_eq!(i, xs.len());\n+    }\n+    assert_eq!(n, xs.len());\n+\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.rfold(xs.len(), |i, &x| {\n+            assert_eq!(x, xs[i - 1]);\n+            i - 1\n+        });\n+        assert_eq!(i, 0);\n+    }\n+    assert_eq!(n, xs.len());\n+}"}, {"sha": "31af70171f1dd5a0477569146b962f4ed5381a5a", "filename": "library/core/tests/iter/adapters/intersperse.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,125 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_intersperse() {\n+    let v = std::iter::empty().intersperse(0u32).collect::<Vec<_>>();\n+    assert_eq!(v, vec![]);\n+\n+    let v = std::iter::once(1).intersperse(0).collect::<Vec<_>>();\n+    assert_eq!(v, vec![1]);\n+\n+    let xs = [\"a\", \"\", \"b\", \"c\"];\n+    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n+    let text: String = v.concat();\n+    assert_eq!(text, \"a, , b, c\".to_string());\n+\n+    let ys = [0, 1, 2, 3];\n+    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n+    assert!(it.next() == None);\n+}\n+#[test]\n+fn test_intersperse_size_hint() {\n+    let iter = std::iter::empty::<i32>().intersperse(0);\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n+    let xs = [\"a\", \"\", \"b\", \"c\"];\n+    let mut iter = xs.iter().map(|x| x.clone()).intersperse(\", \");\n+    assert_eq!(iter.size_hint(), (7, Some(7)));\n+\n+    assert_eq!(iter.next(), Some(\"a\"));\n+    assert_eq!(iter.size_hint(), (6, Some(6)));\n+    assert_eq!(iter.next(), Some(\", \"));\n+    assert_eq!(iter.size_hint(), (5, Some(5)));\n+\n+    assert_eq!([].iter().intersperse(&()).size_hint(), (0, Some(0)));\n+}\n+#[test]\n+fn test_fold_specialization_intersperse() {\n+    let mut iter = (1..2).intersperse(0);\n+    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n+\n+    let mut iter = (1..3).intersperse(0);\n+    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n+\n+    let mut iter = (1..4).intersperse(0);\n+    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n+}\n+#[test]\n+fn test_try_fold_specialization_intersperse_ok() {\n+    let mut iter = (1..2).intersperse(0);\n+    iter.clone().try_for_each(|x| {\n+        assert_eq!(Some(x), iter.next());\n+        Some(())\n+    });\n+\n+    let mut iter = (1..3).intersperse(0);\n+    iter.clone().try_for_each(|x| {\n+        assert_eq!(Some(x), iter.next());\n+        Some(())\n+    });\n+\n+    let mut iter = (1..4).intersperse(0);\n+    iter.clone().try_for_each(|x| {\n+        assert_eq!(Some(x), iter.next());\n+        Some(())\n+    });\n+}\n+#[test]\n+fn test_intersperse_with() {\n+    #[derive(PartialEq, Debug)]\n+    struct NotClone {\n+        u: u32,\n+    }\n+    let r = vec![NotClone { u: 0 }, NotClone { u: 1 }]\n+        .into_iter()\n+        .intersperse_with(|| NotClone { u: 2 })\n+        .collect::<Vec<_>>();\n+    assert_eq!(r, vec![NotClone { u: 0 }, NotClone { u: 2 }, NotClone { u: 1 }]);\n+\n+    let mut ctr = 100;\n+    let separator = || {\n+        ctr *= 2;\n+        ctr\n+    };\n+    let r = (0..3).intersperse_with(separator).collect::<Vec<_>>();\n+    assert_eq!(r, vec![0, 200, 1, 400, 2]);\n+}\n+#[test]\n+fn test_intersperse_fold() {\n+    let v = (1..4).intersperse(9).fold(Vec::new(), |mut acc, x| {\n+        acc.push(x);\n+        acc\n+    });\n+    assert_eq!(v.as_slice(), [1, 9, 2, 9, 3]);\n+\n+    let mut iter = (1..4).intersperse(9);\n+    assert_eq!(iter.next(), Some(1));\n+    let v = iter.fold(Vec::new(), |mut acc, x| {\n+        acc.push(x);\n+        acc\n+    });\n+    assert_eq!(v.as_slice(), [9, 2, 9, 3]);\n+\n+    struct NoneAtStart(i32); // Produces: None, Some(2), Some(3), None, ...\n+    impl Iterator for NoneAtStart {\n+        type Item = i32;\n+        fn next(&mut self) -> Option<i32> {\n+            self.0 += 1;\n+            Some(self.0).filter(|i| i % 3 != 1)\n+        }\n+    }\n+\n+    let v = NoneAtStart(0).intersperse(1000).fold(0, |a, b| a + b);\n+    assert_eq!(v, 0);\n+}\n+#[test]\n+fn test_intersperse_collect_string() {\n+    let contents = vec![1, 2, 3];\n+\n+    let contents_string = contents\n+        .into_iter()\n+        .map(|id| id.to_string())\n+        .intersperse(\", \".to_owned())\n+        .collect::<String>();\n+    assert_eq!(contents_string, \"1, 2, 3\");\n+}"}, {"sha": "69866af472ecd1470ae5a9179c90ddf797d95350", "filename": "library/core/tests/iter/adapters/map.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmap.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,49 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_find_map() {\n+    let xs: &[isize] = &[];\n+    assert_eq!(xs.iter().find_map(half_if_even), None);\n+    let xs: &[isize] = &[3, 5];\n+    assert_eq!(xs.iter().find_map(half_if_even), None);\n+    let xs: &[isize] = &[4, 5];\n+    assert_eq!(xs.iter().find_map(half_if_even), Some(2));\n+    let xs: &[isize] = &[3, 6];\n+    assert_eq!(xs.iter().find_map(half_if_even), Some(3));\n+\n+    let xs: &[isize] = &[1, 2, 3, 4, 5, 6, 7];\n+    let mut iter = xs.iter();\n+    assert_eq!(iter.find_map(half_if_even), Some(1));\n+    assert_eq!(iter.find_map(half_if_even), Some(2));\n+    assert_eq!(iter.find_map(half_if_even), Some(3));\n+    assert_eq!(iter.next(), Some(&7));\n+\n+    fn half_if_even(x: &isize) -> Option<isize> {\n+        if x % 2 == 0 { Some(x / 2) } else { None }\n+    }\n+}\n+#[test]\n+fn test_map_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((0..10).map(|x| x + 3).try_fold(7, f), (3..13).try_fold(7, f));\n+    assert_eq!((0..10).map(|x| x + 3).try_rfold(7, f), (3..13).try_rfold(7, f));\n+\n+    let mut iter = (0..40).map(|x| x + 10);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(46));\n+}\n+#[test]\n+fn test_filter_map_try_folds() {\n+    let mp = &|x| if 0 <= x && x < 10 { Some(x * 2) } else { None };\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((-9..20).filter_map(mp).try_fold(7, f), (0..10).map(|x| 2 * x).try_fold(7, f));\n+    assert_eq!((-9..20).filter_map(mp).try_rfold(7, f), (0..10).map(|x| 2 * x).try_rfold(7, f));\n+\n+    let mut iter = (0..40).filter_map(|x| if x % 2 == 1 { None } else { Some(x * 2 + 10) });\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(38));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(78));\n+}"}, {"sha": "de4b6c01a6ddb6c9fdd0cebe3c25797b9dc8229b", "filename": "library/core/tests/iter/adapters/mod.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,186 @@\n+mod chain;\n+mod cloned;\n+mod copied;\n+mod cycle;\n+mod enumerate;\n+mod filter;\n+mod filter_map;\n+mod flat_map;\n+mod flatten;\n+mod fuse;\n+mod inspect;\n+mod intersperse;\n+mod map;\n+mod peekable;\n+mod scan;\n+mod skip;\n+mod skip_while;\n+mod step;\n+mod step_by;\n+mod take;\n+mod take_while;\n+mod zip;\n+\n+use core::cell::Cell;\n+\n+/// An iterator that panics whenever `next` or next_back` is called\n+/// after `None` has already been returned. This does not violate\n+/// `Iterator`'s contract. Used to test that iterator adaptors don't\n+/// poll their inner iterators after exhausting them.\n+pub struct NonFused<I> {\n+    iter: I,\n+    done: bool,\n+}\n+\n+impl<I> NonFused<I> {\n+    pub fn new(iter: I) -> Self {\n+        Self { iter, done: false }\n+    }\n+}\n+\n+impl<I> Iterator for NonFused<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        assert!(!self.done, \"this iterator has already returned None\");\n+        self.iter.next().or_else(|| {\n+            self.done = true;\n+            None\n+        })\n+    }\n+}\n+\n+impl<I> DoubleEndedIterator for NonFused<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        assert!(!self.done, \"this iterator has already returned None\");\n+        self.iter.next_back().or_else(|| {\n+            self.done = true;\n+            None\n+        })\n+    }\n+}\n+\n+/// An iterator wrapper that panics whenever `next` or `next_back` is called\n+/// after `None` has been returned.\n+pub struct Unfuse<I> {\n+    iter: I,\n+    exhausted: bool,\n+}\n+\n+impl<I> Unfuse<I> {\n+    pub fn new<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<IntoIter = I>,\n+    {\n+        Self { iter: iter.into_iter(), exhausted: false }\n+    }\n+}\n+\n+impl<I> Iterator for Unfuse<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        assert!(!self.exhausted);\n+        let next = self.iter.next();\n+        self.exhausted = next.is_none();\n+        next\n+    }\n+}\n+\n+impl<I> DoubleEndedIterator for Unfuse<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        assert!(!self.exhausted);\n+        let next = self.iter.next_back();\n+        self.exhausted = next.is_none();\n+        next\n+    }\n+}\n+\n+pub struct Toggle {\n+    is_empty: bool,\n+}\n+\n+impl Iterator for Toggle {\n+    type Item = ();\n+\n+    // alternates between `None` and `Some(())`\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.is_empty {\n+            self.is_empty = false;\n+            None\n+        } else {\n+            self.is_empty = true;\n+            Some(())\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.is_empty { (0, Some(0)) } else { (1, Some(1)) }\n+    }\n+}\n+\n+impl DoubleEndedIterator for Toggle {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.next()\n+    }\n+}\n+\n+/// This is an iterator that follows the Iterator contract,\n+/// but it is not fused. After having returned None once, it will start\n+/// producing elements if .next() is called again.\n+pub struct CycleIter<'a, T> {\n+    index: usize,\n+    data: &'a [T],\n+}\n+\n+impl<'a, T> CycleIter<'a, T> {\n+    pub fn new(data: &'a [T]) -> Self {\n+        Self { index: 0, data }\n+    }\n+}\n+\n+impl<'a, T> Iterator for CycleIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let elt = self.data.get(self.index);\n+        self.index += 1;\n+        self.index %= 1 + self.data.len();\n+        elt\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct CountClone(Cell<i32>);\n+\n+impl CountClone {\n+    pub fn new() -> Self {\n+        Self(Cell::new(0))\n+    }\n+}\n+\n+impl PartialEq<i32> for CountClone {\n+    fn eq(&self, rhs: &i32) -> bool {\n+        self.0.get() == *rhs\n+    }\n+}\n+\n+impl Clone for CountClone {\n+    fn clone(&self) -> Self {\n+        let ret = CountClone(self.0.clone());\n+        let n = self.0.get();\n+        self.0.set(n + 1);\n+        ret\n+    }\n+}"}, {"sha": "ee36ff41b032529054bac328df223c177336eb13", "filename": "library/core/tests/iter/adapters/peekable.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fpeekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fpeekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fpeekable.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,260 @@\n+use super::*;\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_peekable() {\n+    let xs = vec![0, 1, 2, 3, 4, 5];\n+\n+    let mut it = xs.iter().cloned().peekable();\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.next().unwrap(), 0);\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.next().unwrap(), 1);\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next().unwrap(), 2);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next().unwrap(), 3);\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.peek().unwrap(), &5);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next().unwrap(), 5);\n+    assert_eq!(it.len(), 0);\n+    assert!(it.peek().is_none());\n+    assert_eq!(it.len(), 0);\n+    assert!(it.next().is_none());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().cloned().peekable();\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.next_back().unwrap(), 5);\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.next_back().unwrap(), 4);\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next_back().unwrap(), 3);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next_back().unwrap(), 2);\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back().unwrap(), 1);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back().unwrap(), 0);\n+    assert_eq!(it.len(), 0);\n+    assert!(it.peek().is_none());\n+    assert_eq!(it.len(), 0);\n+    assert!(it.next_back().is_none());\n+    assert_eq!(it.len(), 0);\n+}\n+#[test]\n+fn test_iterator_peekable_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [10];\n+    let zs: [i32; 0] = [];\n+\n+    assert_eq!(xs.iter().peekable().count(), 6);\n+\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.count(), 6);\n+\n+    assert_eq!(ys.iter().peekable().count(), 1);\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&10));\n+    assert_eq!(it.count(), 1);\n+\n+    assert_eq!(zs.iter().peekable().count(), 0);\n+\n+    let mut it = zs.iter().peekable();\n+    assert_eq!(it.peek(), None);\n+}\n+#[test]\n+fn test_iterator_peekable_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.nth(0), Some(&0));\n+    assert_eq!(it.peek(), Some(&&1));\n+    assert_eq!(it.nth(1), Some(&2));\n+    assert_eq!(it.peek(), Some(&&3));\n+    assert_eq!(it.nth(2), Some(&5));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_iterator_peekable_last() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [0];\n+\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.last(), Some(&5));\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.last(), Some(&0));\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.next(), Some(&0));\n+    assert_eq!(it.peek(), None);\n+    assert_eq!(it.last(), None);\n+}\n+#[test]\n+fn test_iterator_peekable_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+#[test]\n+fn test_iterator_peekable_rfold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.rfold(0, |i, &x| {\n+        assert_eq!(x, xs[xs.len() - 1 - i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+#[test]\n+fn test_iterator_peekable_next_if_eq() {\n+    // first, try on references\n+    let xs = vec![\"Heart\", \"of\", \"Gold\"];\n+    let mut it = xs.into_iter().peekable();\n+    // try before `peek()`\n+    assert_eq!(it.next_if_eq(&\"trillian\"), None);\n+    assert_eq!(it.next_if_eq(&\"Heart\"), Some(\"Heart\"));\n+    // try after peek()\n+    assert_eq!(it.peek(), Some(&\"of\"));\n+    assert_eq!(it.next_if_eq(&\"of\"), Some(\"of\"));\n+    assert_eq!(it.next_if_eq(&\"zaphod\"), None);\n+    // make sure `next()` still behaves\n+    assert_eq!(it.next(), Some(\"Gold\"));\n+\n+    // make sure comparison works for owned values\n+    let xs = vec![String::from(\"Ludicrous\"), \"speed\".into()];\n+    let mut it = xs.into_iter().peekable();\n+    // make sure basic functionality works\n+    assert_eq!(it.next_if_eq(\"Ludicrous\"), Some(\"Ludicrous\".into()));\n+    assert_eq!(it.next_if_eq(\"speed\"), Some(\"speed\".into()));\n+    assert_eq!(it.next_if_eq(\"\"), None);\n+}\n+#[test]\n+fn test_iterator_peekable_mut() {\n+    let mut it = vec![1, 2, 3].into_iter().peekable();\n+    if let Some(p) = it.peek_mut() {\n+        if *p == 1 {\n+            *p = 5;\n+        }\n+    }\n+    assert_eq!(it.collect::<Vec<_>>(), vec![5, 2, 3]);\n+}\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_1() {\n+    // Check that the loop using .peek() terminates\n+    let data = [1, 2, 3];\n+    let mut iter = CycleIter::new(&data).peekable();\n+\n+    let mut n = 0;\n+    while let Some(_) = iter.next() {\n+        let is_the_last = iter.peek().is_none();\n+        assert_eq!(is_the_last, n == data.len() - 1);\n+        n += 1;\n+        if n > data.len() {\n+            break;\n+        }\n+    }\n+    assert_eq!(n, data.len());\n+}\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_2() {\n+    let data = [0];\n+    let mut iter = CycleIter::new(&data).peekable();\n+    iter.next();\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.last(), None);\n+}\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_3() {\n+    let data = [0];\n+    let mut iter = CycleIter::new(&data).peekable();\n+    iter.peek();\n+    assert_eq!(iter.nth(0), Some(&0));\n+\n+    let mut iter = CycleIter::new(&data).peekable();\n+    iter.next();\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.nth(0), None);\n+}\n+#[test]\n+fn test_peek_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+\n+    assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n+    assert_eq!((1..20).peekable().try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n+\n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&40));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.next_back(), Some(50));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.peek(), Some(&3));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.peek(), Some(&4));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(4));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(3));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(2));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Ok(()));\n+}\n+#[test]\n+fn test_peekable_non_fused() {\n+    let mut iter = NonFused::new(empty::<i32>()).peekable();\n+\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.next_back(), None);\n+}"}, {"sha": "1d28ca6b7fdc59d9be8e81638d1f1f365f3d9206", "filename": "library/core/tests/iter/adapters/scan.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fscan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fscan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fscan.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,20 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_scan() {\n+    // test the type inference\n+    fn add(old: &mut isize, new: &usize) -> Option<f64> {\n+        *old += *new as isize;\n+        Some(*old as f64)\n+    }\n+    let xs = [0, 1, 2, 3, 4];\n+    let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n+\n+    let it = xs.iter().scan(0, add);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}"}, {"sha": "76be892c33716e775105295b93064366bb347099", "filename": "library/core/tests/iter/adapters/skip.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,174 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_skip() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+    let mut it = xs.iter().skip(5);\n+    let mut i = 0;\n+    while let Some(&x) = it.next() {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+        assert_eq!(it.len(), xs.len() - 5 - i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+}\n+#[test]\n+fn test_iterator_skip_doubleended() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let mut it = xs.iter().rev().skip(5);\n+    assert_eq!(it.next(), Some(&15));\n+    assert_eq!(it.by_ref().rev().next(), Some(&0));\n+    assert_eq!(it.next(), Some(&13));\n+    assert_eq!(it.by_ref().rev().next(), Some(&1));\n+    assert_eq!(it.next(), Some(&5));\n+    assert_eq!(it.by_ref().rev().next(), Some(&2));\n+    assert_eq!(it.next(), Some(&3));\n+    assert_eq!(it.next(), None);\n+    let mut it = xs.iter().rev().skip(5).rev();\n+    assert_eq!(it.next(), Some(&0));\n+    assert_eq!(it.rev().next(), Some(&15));\n+    let mut it_base = xs.iter();\n+    {\n+        let mut it = it_base.by_ref().skip(5).rev();\n+        assert_eq!(it.next(), Some(&30));\n+        assert_eq!(it.next(), Some(&20));\n+        assert_eq!(it.next(), Some(&19));\n+        assert_eq!(it.next(), Some(&17));\n+        assert_eq!(it.next(), Some(&16));\n+        assert_eq!(it.next(), Some(&15));\n+        assert_eq!(it.next(), Some(&13));\n+        assert_eq!(it.next(), None);\n+    }\n+    // make sure the skipped parts have not been consumed\n+    assert_eq!(it_base.next(), Some(&0));\n+    assert_eq!(it_base.next(), Some(&1));\n+    assert_eq!(it_base.next(), Some(&2));\n+    assert_eq!(it_base.next(), Some(&3));\n+    assert_eq!(it_base.next(), Some(&5));\n+    assert_eq!(it_base.next(), None);\n+    let it = xs.iter().skip(5).rev();\n+    assert_eq!(it.last(), Some(&13));\n+}\n+#[test]\n+fn test_iterator_skip_nth() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    let mut it = xs.iter().skip(0);\n+    assert_eq!(it.nth(0), Some(&0));\n+    assert_eq!(it.nth(1), Some(&2));\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.nth(0), Some(&13));\n+    assert_eq!(it.nth(1), Some(&16));\n+\n+    let mut it = xs.iter().skip(12);\n+    assert_eq!(it.nth(0), None);\n+}\n+#[test]\n+fn test_iterator_skip_count() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    assert_eq!(xs.iter().skip(0).count(), 12);\n+    assert_eq!(xs.iter().skip(1).count(), 11);\n+    assert_eq!(xs.iter().skip(11).count(), 1);\n+    assert_eq!(xs.iter().skip(12).count(), 0);\n+    assert_eq!(xs.iter().skip(13).count(), 0);\n+}\n+#[test]\n+fn test_iterator_skip_last() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    assert_eq!(xs.iter().skip(0).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(1).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(11).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(12).last(), None);\n+    assert_eq!(xs.iter().skip(13).last(), None);\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&13));\n+    assert_eq!(it.last(), Some(&30));\n+}\n+#[test]\n+fn test_iterator_skip_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+\n+    let it = xs.iter().skip(5);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().skip(5);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        let i = i - 1;\n+        assert_eq!(x, ys[i]);\n+        i\n+    });\n+    assert_eq!(i, 0);\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        let i = i - 1;\n+        assert_eq!(x, ys[i]);\n+        i\n+    });\n+    assert_eq!(i, 1);\n+}\n+#[test]\n+fn test_skip_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((1..20).skip(9).try_fold(7, f), (10..20).try_fold(7, f));\n+    assert_eq!((1..20).skip(9).try_rfold(7, f), (10..20).try_rfold(7, f));\n+\n+    let mut iter = (0..30).skip(10);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+}\n+#[test]\n+fn test_skip_nth_back() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().skip(2);\n+    assert_eq!(it.nth_back(0), Some(&5));\n+    assert_eq!(it.nth_back(1), Some(&3));\n+    assert_eq!(it.nth_back(0), Some(&2));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let ys = [2, 3, 4, 5];\n+    let mut ity = ys.iter();\n+    let mut it = xs.iter().skip(2);\n+    assert_eq!(it.nth_back(1), ity.nth_back(1));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+    assert_eq!(it.nth_back(0), ity.nth_back(0));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+    assert_eq!(it.nth_back(0), ity.nth_back(0));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+    assert_eq!(it.nth_back(0), ity.nth_back(0));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+\n+    let mut it = xs.iter().skip(2);\n+    assert_eq!(it.nth_back(4), None);\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let mut it = xs.iter();\n+    it.by_ref().skip(2).nth_back(3);\n+    assert_eq!(it.next_back(), Some(&1));\n+\n+    let mut it = xs.iter();\n+    it.by_ref().skip(2).nth_back(10);\n+    assert_eq!(it.next_back(), Some(&1));\n+}"}, {"sha": "73890d231acc3fb097b824ba17f36f5ff67adeca", "filename": "library/core/tests/iter/adapters/skip_while.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fskip_while.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,48 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_skip_while() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let it = xs.iter().skip_while(|&x| *x < 15);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(*x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+#[test]\n+fn test_iterator_skip_while_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let it = xs.iter().skip_while(|&x| *x < 15);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip_while(|&x| *x < 15);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+}\n+#[test]\n+fn test_skip_while_try_fold() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    fn p(&x: &i32) -> bool {\n+        (x % 10) <= 5\n+    }\n+    assert_eq!((1..20).skip_while(p).try_fold(7, f), (6..20).try_fold(7, f));\n+    let mut iter = (1..20).skip_while(p);\n+    assert_eq!(iter.nth(5), Some(11));\n+    assert_eq!(iter.try_fold(7, f), (12..20).try_fold(7, f));\n+\n+    let mut iter = (0..50).skip_while(|&x| (x % 20) < 15);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(23));\n+}"}, {"sha": "195b4c85639dbeafb89f9d99aa281e4952ed1720", "filename": "library/core/tests/iter/adapters/step.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fstep.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,87 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_steps_between() {\n+    assert_eq!(Step::steps_between(&20_u8, &200_u8), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i8, &80_i8), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-120_i8, &80_i8), Some(200_usize));\n+    assert_eq!(Step::steps_between(&20_u32, &4_000_100_u32), Some(4_000_080_usize));\n+    assert_eq!(Step::steps_between(&-20_i32, &80_i32), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-2_000_030_i32, &2_000_050_i32), Some(4_000_080_usize));\n+\n+    // Skip u64/i64 to avoid differences with 32-bit vs 64-bit platforms\n+\n+    assert_eq!(Step::steps_between(&20_u128, &200_u128), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i128, &80_i128), Some(100_usize));\n+    if cfg!(target_pointer_width = \"64\") {\n+        assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_0009_u128), Some(usize::MAX));\n+    }\n+    assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_000a_u128), None);\n+    assert_eq!(Step::steps_between(&10_i128, &0x1_0000_0000_0000_000a_i128), None);\n+    assert_eq!(\n+        Step::steps_between(&-0x1_0000_0000_0000_0000_i128, &0x1_0000_0000_0000_0000_i128,),\n+        None,\n+    );\n+}\n+#[test]\n+fn test_step_forward() {\n+    assert_eq!(Step::forward_checked(55_u8, 200_usize), Some(255_u8));\n+    assert_eq!(Step::forward_checked(252_u8, 200_usize), None);\n+    assert_eq!(Step::forward_checked(0_u8, 256_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i8, 200_usize), Some(90_i8));\n+    assert_eq!(Step::forward_checked(-110_i8, 248_usize), None);\n+    assert_eq!(Step::forward_checked(-126_i8, 256_usize), None);\n+\n+    assert_eq!(Step::forward_checked(35_u16, 100_usize), Some(135_u16));\n+    assert_eq!(Step::forward_checked(35_u16, 65500_usize), Some(u16::MAX));\n+    assert_eq!(Step::forward_checked(36_u16, 65500_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i16, 200_usize), Some(90_i16));\n+    assert_eq!(Step::forward_checked(-20_030_i16, 50_050_usize), Some(30_020_i16));\n+    assert_eq!(Step::forward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::forward_checked(-10_i16, 70_000_usize), None);\n+\n+    assert_eq!(Step::forward_checked(10_u128, 70_000_usize), Some(70_010_u128));\n+    assert_eq!(Step::forward_checked(10_i128, 70_030_usize), Some(70_040_i128));\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0xff_usize),\n+        Some(u128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0x100_usize),\n+        None\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0xff_usize),\n+        Some(i128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        None\n+    );\n+}\n+#[test]\n+fn test_step_backward() {\n+    assert_eq!(Step::backward_checked(255_u8, 200_usize), Some(55_u8));\n+    assert_eq!(Step::backward_checked(100_u8, 200_usize), None);\n+    assert_eq!(Step::backward_checked(255_u8, 256_usize), None);\n+    assert_eq!(Step::backward_checked(90_i8, 200_usize), Some(-110_i8));\n+    assert_eq!(Step::backward_checked(110_i8, 248_usize), None);\n+    assert_eq!(Step::backward_checked(127_i8, 256_usize), None);\n+\n+    assert_eq!(Step::backward_checked(135_u16, 100_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(u16::MAX, 65500_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(10_u16, 11_usize), None);\n+    assert_eq!(Step::backward_checked(90_i16, 200_usize), Some(-110_i16));\n+    assert_eq!(Step::backward_checked(30_020_i16, 50_050_usize), Some(-20_030_i16));\n+    assert_eq!(Step::backward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::backward_checked(-10_i16, 70_000_usize), None);\n+\n+    assert_eq!(Step::backward_checked(70_010_u128, 70_000_usize), Some(10_u128));\n+    assert_eq!(Step::backward_checked(70_020_i128, 70_030_usize), Some(-10_i128));\n+    assert_eq!(Step::backward_checked(10_u128, 7_usize), Some(3_u128));\n+    assert_eq!(Step::backward_checked(10_u128, 11_usize), None);\n+    assert_eq!(\n+        Step::backward_checked(-0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        Some(i128::MIN)\n+    );\n+}"}, {"sha": "a1c2c64bb5dfb1f47fb5af8871dcc693f8e802cc", "filename": "library/core/tests/iter/adapters/step_by.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fstep_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fstep_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fstep_by.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,240 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_step_by() {\n+    // Identity\n+    let mut it = (0..).step_by(1).take(3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(1));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.next(), None);\n+\n+    let mut it = (0..).step_by(3).take(4);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(3));\n+    assert_eq!(it.next(), Some(6));\n+    assert_eq!(it.next(), Some(9));\n+    assert_eq!(it.next(), None);\n+\n+    let mut it = (0..3).step_by(1);\n+    assert_eq!(it.next_back(), Some(2));\n+    assert_eq!(it.next_back(), Some(1));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n+\n+    let mut it = (0..11).step_by(3);\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(3));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n+}\n+#[test]\n+fn test_iterator_step_by_nth() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth(0), Some(0));\n+    assert_eq!(it.nth(0), Some(5));\n+    assert_eq!(it.nth(0), Some(10));\n+    assert_eq!(it.nth(0), Some(15));\n+    assert_eq!(it.nth(0), None);\n+\n+    let it = (0..18).step_by(5);\n+    assert_eq!(it.clone().nth(0), Some(0));\n+    assert_eq!(it.clone().nth(1), Some(5));\n+    assert_eq!(it.clone().nth(2), Some(10));\n+    assert_eq!(it.clone().nth(3), Some(15));\n+    assert_eq!(it.clone().nth(4), None);\n+    assert_eq!(it.clone().nth(42), None);\n+}\n+#[test]\n+fn test_iterator_step_by_nth_overflow() {\n+    #[cfg(target_pointer_width = \"8\")]\n+    type Bigger = u16;\n+    #[cfg(target_pointer_width = \"16\")]\n+    type Bigger = u32;\n+    #[cfg(target_pointer_width = \"32\")]\n+    type Bigger = u64;\n+    #[cfg(target_pointer_width = \"64\")]\n+    type Bigger = u128;\n+\n+    #[derive(Clone)]\n+    struct Test(Bigger);\n+    impl Iterator for &mut Test {\n+        type Item = i32;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            Some(21)\n+        }\n+        fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+            self.0 += n as Bigger + 1;\n+            Some(42)\n+        }\n+    }\n+\n+    let mut it = Test(0);\n+    let root = usize::MAX >> (usize::BITS / 2);\n+    let n = root + 20;\n+    (&mut it).step_by(n).nth(n);\n+    assert_eq!(it.0, n as Bigger * n as Bigger);\n+\n+    // large step\n+    let mut it = Test(0);\n+    (&mut it).step_by(usize::MAX).nth(5);\n+    assert_eq!(it.0, (usize::MAX as Bigger) * 5);\n+\n+    // n + 1 overflows\n+    let mut it = Test(0);\n+    (&mut it).step_by(2).nth(usize::MAX);\n+    assert_eq!(it.0, (usize::MAX as Bigger) * 2);\n+\n+    // n + 1 overflows\n+    let mut it = Test(0);\n+    (&mut it).step_by(1).nth(usize::MAX);\n+    assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n+}\n+#[test]\n+fn test_iterator_step_by_nth_try_fold() {\n+    let mut it = (0..).step_by(10);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(60));\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(90));\n+\n+    let mut it = (100..).step_by(10);\n+    assert_eq!(it.try_fold(50, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(110));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+#[test]\n+fn test_iterator_step_by_nth_back() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), Some(0));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.next(), Some(0)); // to set `first_take` to `false`\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let it = || (0..18).step_by(5);\n+    assert_eq!(it().nth_back(0), Some(15));\n+    assert_eq!(it().nth_back(1), Some(10));\n+    assert_eq!(it().nth_back(2), Some(5));\n+    assert_eq!(it().nth_back(3), Some(0));\n+    assert_eq!(it().nth_back(4), None);\n+    assert_eq!(it().nth_back(42), None);\n+}\n+#[test]\n+fn test_iterator_step_by_nth_try_rfold() {\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(70));\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(30));\n+\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(50, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(80));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next_back(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+#[test]\n+#[should_panic]\n+fn test_iterator_step_by_zero() {\n+    let mut it = (0..).step_by(0);\n+    it.next();\n+}\n+#[test]\n+fn test_iterator_step_by_size_hint() {\n+    struct StubSizeHint(usize, Option<usize>);\n+    impl Iterator for StubSizeHint {\n+        type Item = ();\n+        fn next(&mut self) -> Option<()> {\n+            self.0 -= 1;\n+            if let Some(ref mut upper) = self.1 {\n+                *upper -= 1;\n+            }\n+            Some(())\n+        }\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            (self.0, self.1)\n+        }\n+    }\n+\n+    // The two checks in each case are needed because the logic\n+    // is different before the first call to `next()`.\n+\n+    let mut it = StubSizeHint(10, Some(10)).step_by(1);\n+    assert_eq!(it.size_hint(), (10, Some(10)));\n+    it.next();\n+    assert_eq!(it.size_hint(), (9, Some(9)));\n+\n+    // exact multiple\n+    let mut it = StubSizeHint(10, Some(10)).step_by(3);\n+    assert_eq!(it.size_hint(), (4, Some(4)));\n+    it.next();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+\n+    // larger base range, but not enough to get another element\n+    let mut it = StubSizeHint(12, Some(12)).step_by(3);\n+    assert_eq!(it.size_hint(), (4, Some(4)));\n+    it.next();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+\n+    // smaller base range, so fewer resulting elements\n+    let mut it = StubSizeHint(9, Some(9)).step_by(3);\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    it.next();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+\n+    // infinite upper bound\n+    let mut it = StubSizeHint(usize::MAX, None).step_by(1);\n+    assert_eq!(it.size_hint(), (usize::MAX, None));\n+    it.next();\n+    assert_eq!(it.size_hint(), (usize::MAX - 1, None));\n+\n+    // still infinite with larger step\n+    let mut it = StubSizeHint(7, None).step_by(3);\n+    assert_eq!(it.size_hint(), (3, None));\n+    it.next();\n+    assert_eq!(it.size_hint(), (2, None));\n+\n+    // propagates ExactSizeIterator\n+    let a = [1, 2, 3, 4, 5];\n+    let it = a.iter().step_by(2);\n+    assert_eq!(it.len(), 3);\n+\n+    // Cannot be TrustedLen as a step greater than one makes an iterator\n+    // with (usize::MAX, None) no longer meet the safety requirements\n+    trait TrustedLenCheck {\n+        fn test(self) -> bool;\n+    }\n+    impl<T: Iterator> TrustedLenCheck for T {\n+        default fn test(self) -> bool {\n+            false\n+        }\n+    }\n+    impl<T: TrustedLen> TrustedLenCheck for T {\n+        fn test(self) -> bool {\n+            true\n+        }\n+    }\n+    assert!(TrustedLenCheck::test(a.iter()));\n+    assert!(!TrustedLenCheck::test(a.iter().step_by(1)));\n+}\n+#[test]\n+fn test_step_by_skip() {\n+    assert_eq!((0..640).step_by(128).skip(1).collect::<Vec<_>>(), [128, 256, 384, 512]);\n+    assert_eq!((0..=50).step_by(10).nth(3), Some(30));\n+    assert_eq!((200..=255u8).step_by(10).nth(3), Some(230));\n+}"}, {"sha": "6739855c8ad53b7b0f56c846e6cafe0e571cd0f8", "filename": "library/core/tests/iter/adapters/take.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,122 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_take() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0, 1, 2, 3, 5];\n+\n+    let mut it = xs.iter().take(ys.len());\n+    let mut i = 0;\n+    assert_eq!(it.len(), ys.len());\n+    while let Some(&x) = it.next() {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+        assert_eq!(it.len(), ys.len() - i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(ys.len());\n+    let mut i = 0;\n+    assert_eq!(it.len(), ys.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, ys[ys.len() - i]);\n+        assert_eq!(it.len(), ys.len() - i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+}\n+#[test]\n+fn test_iterator_take_nth() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth(0) {\n+            assert_eq!(x, i);\n+            i += 1;\n+        }\n+    }\n+    assert_eq!(it.nth(1), Some(&5));\n+    assert_eq!(it.nth(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    let mut i = 1;\n+    while let Some(&x) = it.nth(1) {\n+        assert_eq!(x, i);\n+        i += 2;\n+    }\n+}\n+#[test]\n+fn test_iterator_take_nth_back() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth_back(0) {\n+            i += 1;\n+            assert_eq!(x, 3 - i);\n+        }\n+    }\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    assert_eq!(it.nth_back(1), Some(&3));\n+    assert_eq!(it.nth_back(1), Some(&1));\n+    assert_eq!(it.nth_back(1), None);\n+}\n+#[test]\n+fn test_iterator_take_short() {\n+    let xs = [0, 1, 2, 3];\n+\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    assert_eq!(it.len(), xs.len());\n+    while let Some(&x) = it.next() {\n+        assert_eq!(x, xs[i]);\n+        i += 1;\n+        assert_eq!(it.len(), xs.len() - i);\n+    }\n+    assert_eq!(i, xs.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    assert_eq!(it.len(), xs.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, xs[xs.len() - i]);\n+        assert_eq!(it.len(), xs.len() - i);\n+    }\n+    assert_eq!(i, xs.len());\n+    assert_eq!(it.len(), 0);\n+}\n+#[test]\n+fn test_take_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n+    assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n+\n+    let mut iter = (10..30).take(20);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+\n+    let mut iter = (2..20).take(3);\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..20).take(3).rev();\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+}"}, {"sha": "58856ac44bd1954ec2a14c7c93c3310f6b213c1b", "filename": "library/core/tests/iter/adapters/take_while.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Ftake_while.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,28 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_take_while() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0, 1, 2, 3, 5, 13];\n+    let it = xs.iter().take_while(|&x| *x < 15);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(*x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+#[test]\n+fn test_take_while_folds() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((1..20).take_while(|&x| x != 10).try_fold(7, f), (1..10).try_fold(7, f));\n+    let mut iter = (1..20).take_while(|&x| x != 10);\n+    assert_eq!(iter.try_fold(0, |x, y| Some(x + y)), Some((1..10).sum()));\n+    assert_eq!(iter.next(), None, \"flag should be set\");\n+    let iter = (1..20).take_while(|&x| x != 10);\n+    assert_eq!(iter.fold(0, |x, y| x + y), (1..10).sum());\n+\n+    let mut iter = (10..50).take_while(|&x| x != 40);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+}"}, {"sha": "a8d524ccec923016316eed0a1ceff9eb0ce328e9", "filename": "library/core/tests/iter/adapters/zip.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,223 @@\n+use super::*;\n+use core::iter::*;\n+\n+#[test]\n+fn test_zip_nth() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let ys = [10, 11, 12];\n+\n+    let mut it = xs.iter().zip(&ys);\n+    assert_eq!(it.nth(0), Some((&0, &10)));\n+    assert_eq!(it.nth(1), Some((&2, &12)));\n+    assert_eq!(it.nth(0), None);\n+\n+    let mut it = xs.iter().zip(&ys);\n+    assert_eq!(it.nth(3), None);\n+\n+    let mut it = ys.iter().zip(&xs);\n+    assert_eq!(it.nth(3), None);\n+}\n+#[test]\n+fn test_zip_nth_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let value = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }))\n+        .skip(1)\n+        .nth(3);\n+    assert_eq!(value, Some((50, 6000)));\n+    assert_eq!(a, vec![1, 2, 3, 4, 5]);\n+    assert_eq!(b, vec![200, 300, 400, 500, 600]);\n+}\n+#[test]\n+fn test_zip_next_back_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let mut iter = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }));\n+\n+    // The second iterator is one item longer, so `next_back` is called on it\n+    // one more time.\n+    assert_eq!(iter.next_back(), Some((60, 7000)));\n+    assert_eq!(iter.next_back(), Some((50, 6000)));\n+    assert_eq!(iter.next_back(), Some((40, 5000)));\n+    assert_eq!(iter.next_back(), Some((30, 4000)));\n+    assert_eq!(a, vec![6, 5, 4, 3]);\n+    assert_eq!(b, vec![800, 700, 600, 500, 400]);\n+}\n+#[test]\n+fn test_zip_nth_back_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let value = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }))\n+        .nth_back(3);\n+    assert_eq!(value, Some((30, 4000)));\n+    assert_eq!(a, vec![6, 5, 4, 3]);\n+    assert_eq!(b, vec![800, 700, 600, 500, 400]);\n+}\n+#[test]\n+fn test_zip_next_back_side_effects_exhausted() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let mut iter = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }));\n+\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    assert_eq!(iter.next_back(), None);\n+    assert_eq!(a, vec![1, 2, 3, 4, 6, 5]);\n+    assert_eq!(b, vec![200, 300, 400]);\n+}\n+#[test]\n+fn test_zip_cloned_sideffectful() {\n+    let xs = [CountClone::new(), CountClone::new(), CountClone::new(), CountClone::new()];\n+    let ys = [CountClone::new(), CountClone::new()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) {}\n+\n+    assert_eq!(&xs, &[1, 1, 1, 0][..]);\n+    assert_eq!(&ys, &[1, 1][..]);\n+\n+    let xs = [CountClone::new(), CountClone::new()];\n+    let ys = [CountClone::new(), CountClone::new(), CountClone::new(), CountClone::new()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) {}\n+\n+    assert_eq!(&xs, &[1, 1][..]);\n+    assert_eq!(&ys, &[1, 1, 0, 0][..]);\n+}\n+#[test]\n+fn test_zip_map_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) {}\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+\n+    let mut xs = [0; 4];\n+    let mut ys = [0; 6];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) {}\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1, 0, 0]);\n+}\n+#[test]\n+fn test_zip_map_rev_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[0, 0, 0, 1, 1, 1]);\n+    assert_eq!(&ys, &[0, 0, 0, 1]);\n+\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        (&mut it).take(5).count();\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+}\n+#[test]\n+fn test_zip_nested_sideffectful() {\n+    let mut xs = [0; 6];\n+    let ys = [0; 4];\n+\n+    {\n+        // test that it has the side effect nested inside enumerate\n+        let it = xs.iter_mut().map(|x| *x = 1).enumerate().zip(&ys);\n+        it.count();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+}\n+#[test]\n+fn test_zip_nth_back_side_effects_exhausted() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let mut iter = [1, 2, 3, 4, 5, 6]\n+        .iter()\n+        .cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }));\n+\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    iter.next();\n+    assert_eq!(iter.nth_back(0), None);\n+    assert_eq!(a, vec![1, 2, 3, 4, 6, 5]);\n+    assert_eq!(b, vec![200, 300, 400]);\n+}\n+#[test]\n+fn test_zip_trusted_random_access_composition() {\n+    let a = [0, 1, 2, 3, 4];\n+    let b = a;\n+    let c = a;\n+\n+    let a = a.iter().copied();\n+    let b = b.iter().copied();\n+    let mut c = c.iter().copied();\n+    c.next();\n+\n+    let mut z1 = a.zip(b);\n+    assert_eq!(z1.next().unwrap(), (0, 0));\n+\n+    let mut z2 = z1.zip(c);\n+    fn assert_trusted_random_access<T: TrustedRandomAccess>(_a: &T) {}\n+    assert_trusted_random_access(&z2);\n+    assert_eq!(z2.next().unwrap(), ((1, 1), 1));\n+}"}, {"sha": "6216d0a3288895487f3fa71f21e80d2d35d9201e", "filename": "library/core/tests/iter/mod.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fmod.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,101 @@\n+mod adapters;\n+mod range;\n+mod sources;\n+mod traits;\n+\n+use core::cell::Cell;\n+use core::convert::TryFrom;\n+use core::iter::*;\n+#[test]\n+fn test_multi_iter() {\n+    let xs = [1, 2, 3, 4];\n+    let ys = [4, 3, 2, 1];\n+    assert!(xs.iter().eq(ys.iter().rev()));\n+    assert!(xs.iter().lt(xs.iter().skip(2)));\n+}\n+#[test]\n+fn test_counter_from_iter() {\n+    let it = (0..).step_by(5).take(10);\n+    let xs: Vec<isize> = FromIterator::from_iter(it);\n+    assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+}\n+\n+pub fn is_trusted_len<I: TrustedLen>(_: I) {}\n+#[test]\n+fn test_functor_laws() {\n+    // identity:\n+    fn identity<T>(x: T) -> T {\n+        x\n+    }\n+    assert_eq!((0..10).map(identity).sum::<usize>(), (0..10).sum());\n+\n+    // composition:\n+    fn f(x: usize) -> usize {\n+        x + 3\n+    }\n+    fn g(x: usize) -> usize {\n+        x * 2\n+    }\n+    fn h(x: usize) -> usize {\n+        g(f(x))\n+    }\n+    assert_eq!((0..10).map(f).map(g).sum::<usize>(), (0..10).map(h).sum());\n+}\n+#[test]\n+fn test_monad_laws_left_identity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> {\n+        (0..10).map(move |y| x * y)\n+    }\n+    assert_eq!(once(42).flat_map(f.clone()).sum::<usize>(), f(42).sum());\n+}\n+#[test]\n+fn test_monad_laws_right_identity() {\n+    assert_eq!((0..10).flat_map(|x| once(x)).sum::<usize>(), (0..10).sum());\n+}\n+#[test]\n+fn test_monad_laws_associativity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> {\n+        0..x\n+    }\n+    fn g(x: usize) -> impl Iterator<Item = usize> {\n+        (0..x).rev()\n+    }\n+    assert_eq!(\n+        (0..10).flat_map(f).flat_map(g).sum::<usize>(),\n+        (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>()\n+    );\n+}\n+\n+#[test]\n+pub fn extend_for_unit() {\n+    let mut x = 0;\n+    {\n+        let iter = (0..5).map(|_| {\n+            x += 1;\n+        });\n+        ().extend(iter);\n+    }\n+    assert_eq!(x, 5);\n+}\n+#[test]\n+fn test_try_fold_specialization_intersperse_err() {\n+    let orig_iter = [\"a\", \"b\"].iter().copied().intersperse(\"-\");\n+\n+    // Abort after the first item.\n+    let mut iter = orig_iter.clone();\n+    iter.try_for_each(|_| None::<()>);\n+    assert_eq!(iter.next(), Some(\"-\"));\n+    assert_eq!(iter.next(), Some(\"b\"));\n+    assert_eq!(iter.next(), None);\n+\n+    // Abort after the second item.\n+    let mut iter = orig_iter.clone();\n+    iter.try_for_each(|item| if item == \"-\" { None } else { Some(()) });\n+    assert_eq!(iter.next(), Some(\"b\"));\n+    assert_eq!(iter.next(), None);\n+\n+    // Abort after the third item.\n+    let mut iter = orig_iter.clone();\n+    iter.try_for_each(|item| if item == \"b\" { None } else { Some(()) });\n+    assert_eq!(iter.next(), None);\n+}"}, {"sha": "2ba787325ad270c9689287d6260bad85f8a898ea", "filename": "library/core/tests/iter/range.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Frange.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,412 @@\n+use super::*;\n+\n+#[test]\n+fn test_range() {\n+    assert_eq!((0..5).collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n+    assert_eq!((-10..-1).collect::<Vec<_>>(), [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+    assert_eq!((0..5).rev().collect::<Vec<_>>(), [4, 3, 2, 1, 0]);\n+    assert_eq!((200..-5).count(), 0);\n+    assert_eq!((200..-5).rev().count(), 0);\n+    assert_eq!((200..200).count(), 0);\n+    assert_eq!((200..200).rev().count(), 0);\n+\n+    assert_eq!((0..100).size_hint(), (100, Some(100)));\n+    // this test is only meaningful when sizeof usize < sizeof u64\n+    assert_eq!((usize::MAX - 1..usize::MAX).size_hint(), (1, Some(1)));\n+    assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n+    assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n+\n+    assert_eq!((-70..58).size_hint(), (128, Some(128)));\n+    assert_eq!((-128..127).size_hint(), (255, Some(255)));\n+    assert_eq!(\n+        (-2..isize::MAX).size_hint(),\n+        (isize::MAX as usize + 2, Some(isize::MAX as usize + 2))\n+    );\n+}\n+#[test]\n+fn test_char_range() {\n+    use std::char;\n+    // Miri is too slow\n+    let from = if cfg!(miri) { char::from_u32(0xD800 - 10).unwrap() } else { '\\0' };\n+    let to = if cfg!(miri) { char::from_u32(0xDFFF + 10).unwrap() } else { char::MAX };\n+    assert!((from..=to).eq((from as u32..=to as u32).filter_map(char::from_u32)));\n+    assert!((from..=to).rev().eq((from as u32..=to as u32).filter_map(char::from_u32).rev()));\n+\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').count(), 2);\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').size_hint(), (2, Some(2)));\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').count(), 1);\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').size_hint(), (1, Some(1)));\n+}\n+#[test]\n+fn test_range_exhaustion() {\n+    let mut r = 10..10;\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 10..10);\n+\n+    let mut r = 10..12;\n+    assert_eq!(r.next(), Some(10));\n+    assert_eq!(r.next(), Some(11));\n+    assert!(r.is_empty());\n+    assert_eq!(r, 12..12);\n+    assert_eq!(r.next(), None);\n+\n+    let mut r = 10..12;\n+    assert_eq!(r.next_back(), Some(11));\n+    assert_eq!(r.next_back(), Some(10));\n+    assert!(r.is_empty());\n+    assert_eq!(r, 10..10);\n+    assert_eq!(r.next_back(), None);\n+\n+    let mut r = 100..10;\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 100..10);\n+}\n+#[test]\n+fn test_range_inclusive_exhaustion() {\n+    let mut r = 10..=10;\n+    assert_eq!(r.next(), Some(10));\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next(), None);\n+\n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n+    let mut r = 10..=10;\n+    assert_eq!(r.next_back(), Some(10));\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n+\n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n+    let mut r = 10..=12;\n+    assert_eq!(r.next(), Some(10));\n+    assert_eq!(r.next(), Some(11));\n+    assert_eq!(r.next(), Some(12));\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+\n+    let mut r = 10..=12;\n+    assert_eq!(r.next_back(), Some(12));\n+    assert_eq!(r.next_back(), Some(11));\n+    assert_eq!(r.next_back(), Some(10));\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n+\n+    let mut r = 10..=12;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+\n+    let mut r = 10..=12;\n+    assert_eq!(r.nth(5), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+\n+    let mut r = 100..=10;\n+    assert_eq!(r.next(), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r, 100..=10);\n+\n+    let mut r = 100..=10;\n+    assert_eq!(r.next_back(), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 100..=10);\n+}\n+#[test]\n+fn test_range_nth() {\n+    assert_eq!((10..15).nth(0), Some(10));\n+    assert_eq!((10..15).nth(1), Some(11));\n+    assert_eq!((10..15).nth(4), Some(14));\n+    assert_eq!((10..15).nth(5), None);\n+\n+    let mut r = 10..20;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 13..20);\n+    assert_eq!(r.nth(2), Some(15));\n+    assert_eq!(r, 16..20);\n+    assert_eq!(r.nth(10), None);\n+    assert_eq!(r, 20..20);\n+}\n+#[test]\n+fn test_range_nth_back() {\n+    assert_eq!((10..15).nth_back(0), Some(14));\n+    assert_eq!((10..15).nth_back(1), Some(13));\n+    assert_eq!((10..15).nth_back(4), Some(10));\n+    assert_eq!((10..15).nth_back(5), None);\n+    assert_eq!((-120..80_i8).nth_back(199), Some(-120));\n+\n+    let mut r = 10..20;\n+    assert_eq!(r.nth_back(2), Some(17));\n+    assert_eq!(r, 10..17);\n+    assert_eq!(r.nth_back(2), Some(14));\n+    assert_eq!(r, 10..14);\n+    assert_eq!(r.nth_back(10), None);\n+    assert_eq!(r, 10..10);\n+}\n+#[test]\n+fn test_range_from_nth() {\n+    assert_eq!((10..).nth(0), Some(10));\n+    assert_eq!((10..).nth(1), Some(11));\n+    assert_eq!((10..).nth(4), Some(14));\n+\n+    let mut r = 10..;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 13..);\n+    assert_eq!(r.nth(2), Some(15));\n+    assert_eq!(r, 16..);\n+    assert_eq!(r.nth(10), Some(26));\n+    assert_eq!(r, 27..);\n+\n+    assert_eq!((0..).size_hint(), (usize::MAX, None));\n+}\n+#[test]\n+fn test_range_from_take() {\n+    let mut it = (0..).take(3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(1));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.next(), None);\n+    is_trusted_len((0..).take(3));\n+    assert_eq!((0..).take(3).size_hint(), (3, Some(3)));\n+    assert_eq!((0..).take(0).size_hint(), (0, Some(0)));\n+    assert_eq!((0..).take(usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n+}\n+#[test]\n+fn test_range_from_take_collect() {\n+    let v: Vec<_> = (0..).take(3).collect();\n+    assert_eq!(v, vec![0, 1, 2]);\n+}\n+#[test]\n+fn test_range_inclusive_nth() {\n+    assert_eq!((10..=15).nth(0), Some(10));\n+    assert_eq!((10..=15).nth(1), Some(11));\n+    assert_eq!((10..=15).nth(5), Some(15));\n+    assert_eq!((10..=15).nth(6), None);\n+\n+    let mut exhausted_via_next = 10_u8..=20;\n+    while exhausted_via_next.next().is_some() {}\n+\n+    let mut r = 10_u8..=20;\n+    assert_eq!(r.nth(2), Some(12));\n+    assert_eq!(r, 13..=20);\n+    assert_eq!(r.nth(2), Some(15));\n+    assert_eq!(r, 16..=20);\n+    assert_eq!(r.is_empty(), false);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n+    assert_eq!(r.nth(10), None);\n+    assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n+}\n+#[test]\n+fn test_range_inclusive_nth_back() {\n+    assert_eq!((10..=15).nth_back(0), Some(15));\n+    assert_eq!((10..=15).nth_back(1), Some(14));\n+    assert_eq!((10..=15).nth_back(5), Some(10));\n+    assert_eq!((10..=15).nth_back(6), None);\n+    assert_eq!((-120..=80_i8).nth_back(200), Some(-120));\n+\n+    let mut exhausted_via_next_back = 10_u8..=20;\n+    while exhausted_via_next_back.next_back().is_some() {}\n+\n+    let mut r = 10_u8..=20;\n+    assert_eq!(r.nth_back(2), Some(18));\n+    assert_eq!(r, 10..=17);\n+    assert_eq!(r.nth_back(2), Some(15));\n+    assert_eq!(r, 10..=14);\n+    assert_eq!(r.is_empty(), false);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n+    assert_eq!(r.nth_back(10), None);\n+    assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next_back);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n+}\n+#[test]\n+fn test_range_len() {\n+    assert_eq!((0..10_u8).len(), 10);\n+    assert_eq!((9..10_u8).len(), 1);\n+    assert_eq!((10..10_u8).len(), 0);\n+    assert_eq!((11..10_u8).len(), 0);\n+    assert_eq!((100..10_u8).len(), 0);\n+}\n+#[test]\n+fn test_range_inclusive_len() {\n+    assert_eq!((0..=10_u8).len(), 11);\n+    assert_eq!((9..=10_u8).len(), 2);\n+    assert_eq!((10..=10_u8).len(), 1);\n+    assert_eq!((11..=10_u8).len(), 0);\n+    assert_eq!((100..=10_u8).len(), 0);\n+}\n+#[test]\n+fn test_range_step() {\n+    #![allow(deprecated)]\n+\n+    assert_eq!((0..20).step_by(5).collect::<Vec<isize>>(), [0, 5, 10, 15]);\n+    assert_eq!((1..21).rev().step_by(5).collect::<Vec<isize>>(), [20, 15, 10, 5]);\n+    assert_eq!((1..21).rev().step_by(6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n+    assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n+    assert_eq!((200..-5).step_by(1).collect::<Vec<isize>>(), []);\n+    assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n+\n+    assert_eq!((0..20).step_by(1).size_hint(), (20, Some(20)));\n+    assert_eq!((0..20).step_by(21).size_hint(), (1, Some(1)));\n+    assert_eq!((0..20).step_by(5).size_hint(), (4, Some(4)));\n+    assert_eq!((1..21).rev().step_by(5).size_hint(), (4, Some(4)));\n+    assert_eq!((1..21).rev().step_by(6).size_hint(), (4, Some(4)));\n+    assert_eq!((20..-5).step_by(1).size_hint(), (0, Some(0)));\n+    assert_eq!((20..20).step_by(1).size_hint(), (0, Some(0)));\n+    assert_eq!((i8::MIN..i8::MAX).step_by(-(i8::MIN as i32) as usize).size_hint(), (2, Some(2)));\n+    assert_eq!((i16::MIN..i16::MAX).step_by(i16::MAX as usize).size_hint(), (3, Some(3)));\n+    assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n+}\n+#[test]\n+fn test_range_inclusive_step() {\n+    assert_eq!((0..=50).step_by(10).collect::<Vec<_>>(), [0, 10, 20, 30, 40, 50]);\n+    assert_eq!((0..=5).step_by(1).collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5]);\n+    assert_eq!((200..=255u8).step_by(10).collect::<Vec<_>>(), [200, 210, 220, 230, 240, 250]);\n+    assert_eq!((250..=255u8).step_by(1).collect::<Vec<_>>(), [250, 251, 252, 253, 254, 255]);\n+}\n+#[test]\n+fn test_range_last_max() {\n+    assert_eq!((0..20).last(), Some(19));\n+    assert_eq!((-20..0).last(), Some(-1));\n+    assert_eq!((5..5).last(), None);\n+\n+    assert_eq!((0..20).max(), Some(19));\n+    assert_eq!((-20..0).max(), Some(-1));\n+    assert_eq!((5..5).max(), None);\n+}\n+#[test]\n+fn test_range_inclusive_last_max() {\n+    assert_eq!((0..=20).last(), Some(20));\n+    assert_eq!((-20..=0).last(), Some(0));\n+    assert_eq!((5..=5).last(), Some(5));\n+    let mut r = 10..=10;\n+    r.next();\n+    assert_eq!(r.last(), None);\n+\n+    assert_eq!((0..=20).max(), Some(20));\n+    assert_eq!((-20..=0).max(), Some(0));\n+    assert_eq!((5..=5).max(), Some(5));\n+    let mut r = 10..=10;\n+    r.next();\n+    assert_eq!(r.max(), None);\n+}\n+#[test]\n+fn test_range_min() {\n+    assert_eq!((0..20).min(), Some(0));\n+    assert_eq!((-20..0).min(), Some(-20));\n+    assert_eq!((5..5).min(), None);\n+}\n+#[test]\n+fn test_range_inclusive_min() {\n+    assert_eq!((0..=20).min(), Some(0));\n+    assert_eq!((-20..=0).min(), Some(-20));\n+    assert_eq!((5..=5).min(), Some(5));\n+    let mut r = 10..=10;\n+    r.next();\n+    assert_eq!(r.min(), None);\n+}\n+#[test]\n+fn test_range_inclusive_folds() {\n+    assert_eq!((1..=10).sum::<i32>(), 55);\n+    assert_eq!((1..=10).rev().sum::<i32>(), 55);\n+\n+    let mut it = 44..=50;\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it, 47..=50);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it, 50..=50);\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(50));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+    assert!(it.is_empty());\n+\n+    let mut it = 40..=47;\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it, 40..=44);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it, 40..=41);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), Some(81));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_rfold(0, i8::checked_add), Some(0));\n+    assert!(it.is_empty());\n+\n+    let mut it = 10..=20;\n+    assert_eq!(it.try_fold(0, |a, b| Some(a + b)), Some(165));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_fold(0, |a, b| Some(a + b)), Some(0));\n+    assert!(it.is_empty());\n+\n+    let mut it = 10..=20;\n+    assert_eq!(it.try_rfold(0, |a, b| Some(a + b)), Some(165));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_rfold(0, |a, b| Some(a + b)), Some(0));\n+    assert!(it.is_empty());\n+}\n+#[test]\n+fn test_range_size_hint() {\n+    assert_eq!((0..0usize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..100usize).size_hint(), (100, Some(100)));\n+    assert_eq!((0..usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n+\n+    let umax = u128::try_from(usize::MAX).unwrap();\n+    assert_eq!((0..0u128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..100u128).size_hint(), (100, Some(100)));\n+    assert_eq!((0..umax).size_hint(), (usize::MAX, Some(usize::MAX)));\n+    assert_eq!((0..umax + 1).size_hint(), (usize::MAX, None));\n+\n+    assert_eq!((0..0isize).size_hint(), (0, Some(0)));\n+    assert_eq!((-100..100isize).size_hint(), (200, Some(200)));\n+    assert_eq!((isize::MIN..isize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n+\n+    let imin = i128::try_from(isize::MIN).unwrap();\n+    let imax = i128::try_from(isize::MAX).unwrap();\n+    assert_eq!((0..0i128).size_hint(), (0, Some(0)));\n+    assert_eq!((-100..100i128).size_hint(), (200, Some(200)));\n+    assert_eq!((imin..imax).size_hint(), (usize::MAX, Some(usize::MAX)));\n+    assert_eq!((imin..imax + 1).size_hint(), (usize::MAX, None));\n+}\n+#[test]\n+fn test_range_inclusive_size_hint() {\n+    assert_eq!((1..=0usize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0usize).size_hint(), (1, Some(1)));\n+    assert_eq!((0..=100usize).size_hint(), (101, Some(101)));\n+    assert_eq!((0..=usize::MAX - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n+    assert_eq!((0..=usize::MAX).size_hint(), (usize::MAX, None));\n+\n+    let umax = u128::try_from(usize::MAX).unwrap();\n+    assert_eq!((1..=0u128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0u128).size_hint(), (1, Some(1)));\n+    assert_eq!((0..=100u128).size_hint(), (101, Some(101)));\n+    assert_eq!((0..=umax - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n+    assert_eq!((0..=umax).size_hint(), (usize::MAX, None));\n+    assert_eq!((0..=umax + 1).size_hint(), (usize::MAX, None));\n+\n+    assert_eq!((0..=-1isize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0isize).size_hint(), (1, Some(1)));\n+    assert_eq!((-100..=100isize).size_hint(), (201, Some(201)));\n+    assert_eq!((isize::MIN..=isize::MAX - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n+    assert_eq!((isize::MIN..=isize::MAX).size_hint(), (usize::MAX, None));\n+\n+    let imin = i128::try_from(isize::MIN).unwrap();\n+    let imax = i128::try_from(isize::MAX).unwrap();\n+    assert_eq!((0..=-1i128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0i128).size_hint(), (1, Some(1)));\n+    assert_eq!((-100..=100i128).size_hint(), (201, Some(201)));\n+    assert_eq!((imin..=imax - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n+    assert_eq!((imin..=imax).size_hint(), (usize::MAX, None));\n+    assert_eq!((imin..=imax + 1).size_hint(), (usize::MAX, None));\n+}"}, {"sha": "38152e3711febe4ac608348a729cbd1903d70e60", "filename": "library/core/tests/iter/sources.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fsources.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,99 @@\n+use super::*;\n+use core::iter::*;\n+\n+#[test]\n+fn test_repeat() {\n+    let mut it = repeat(42);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(repeat(42).size_hint(), (usize::MAX, None));\n+}\n+#[test]\n+fn test_repeat_take() {\n+    let mut it = repeat(42).take(3);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), None);\n+    is_trusted_len(repeat(42).take(3));\n+    assert_eq!(repeat(42).take(3).size_hint(), (3, Some(3)));\n+    assert_eq!(repeat(42).take(0).size_hint(), (0, Some(0)));\n+    assert_eq!(repeat(42).take(usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n+}\n+#[test]\n+fn test_repeat_take_collect() {\n+    let v: Vec<_> = repeat(42).take(3).collect();\n+    assert_eq!(v, vec![42, 42, 42]);\n+}\n+#[test]\n+fn test_repeat_with() {\n+    #[derive(PartialEq, Debug)]\n+    struct NotClone(usize);\n+    let mut it = repeat_with(|| NotClone(42));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(repeat_with(|| NotClone(42)).size_hint(), (usize::MAX, None));\n+}\n+#[test]\n+fn test_repeat_with_take() {\n+    let mut it = repeat_with(|| 42).take(3);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), None);\n+    is_trusted_len(repeat_with(|| 42).take(3));\n+    assert_eq!(repeat_with(|| 42).take(3).size_hint(), (3, Some(3)));\n+    assert_eq!(repeat_with(|| 42).take(0).size_hint(), (0, Some(0)));\n+    assert_eq!(repeat_with(|| 42).take(usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n+}\n+#[test]\n+fn test_repeat_with_take_collect() {\n+    let mut curr = 1;\n+    let v: Vec<_> = repeat_with(|| {\n+        let tmp = curr;\n+        curr *= 2;\n+        tmp\n+    })\n+    .take(5)\n+    .collect();\n+    assert_eq!(v, vec![1, 2, 4, 8, 16]);\n+}\n+#[test]\n+fn test_successors() {\n+    let mut powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+    assert_eq!(powers_of_10.by_ref().collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+    assert_eq!(powers_of_10.next(), None);\n+\n+    let mut empty = successors(None::<u32>, |_| unimplemented!());\n+    assert_eq!(empty.next(), None);\n+    assert_eq!(empty.next(), None);\n+}\n+#[test]\n+fn test_once() {\n+    let mut it = once(42);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_once_with() {\n+    let count = Cell::new(0);\n+    let mut it = once_with(|| {\n+        count.set(count.get() + 1);\n+        42\n+    });\n+\n+    assert_eq!(count.get(), 0);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(count.get(), 1);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(count.get(), 1);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(count.get(), 1);\n+}\n+#[test]\n+fn test_empty() {\n+    let mut it = empty::<i32>();\n+    assert_eq!(it.next(), None);\n+}"}, {"sha": "9d7425449f79d9d925d005ae7101e32c10bf7a18", "filename": "library/core/tests/iter/traits/accum.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Faccum.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,61 @@\n+use core::iter::*;\n+\n+#[test]\n+fn test_iterator_sum() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[..4].iter().cloned().sum::<i32>(), 6);\n+    assert_eq!(v.iter().cloned().sum::<i32>(), 55);\n+    assert_eq!(v[..0].iter().cloned().sum::<i32>(), 0);\n+}\n+#[test]\n+fn test_iterator_sum_result() {\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Ok(10));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n+\n+    #[derive(PartialEq, Debug)]\n+    struct S(Result<i32, ()>);\n+\n+    impl Sum<Result<i32, ()>> for S {\n+        fn sum<I: Iterator<Item = Result<i32, ()>>>(mut iter: I) -> Self {\n+            // takes the sum by repeatedly calling `next` on `iter`,\n+            // thus testing that repeated calls to `ResultShunt::try_fold`\n+            // produce the expected results\n+            Self(iter.by_ref().sum())\n+        }\n+    }\n+\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Ok(10)));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Err(())));\n+}\n+#[test]\n+fn test_iterator_sum_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), Some(10));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), None);\n+}\n+#[test]\n+fn test_iterator_product() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[..4].iter().cloned().product::<i32>(), 0);\n+    assert_eq!(v[1..5].iter().cloned().product::<i32>(), 24);\n+    assert_eq!(v[..0].iter().cloned().product::<i32>(), 1);\n+}\n+#[test]\n+fn test_iterator_product_result() {\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Ok(24));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n+}\n+#[test]\n+fn test_iterator_product_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), Some(24));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), None);\n+}"}, {"sha": "c90ad8baeb98aadecab9aa0b355b0a832058f95d", "filename": "library/core/tests/iter/traits/collect.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fcollect.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,6 @@\n+#[test]\n+fn test_collect() {\n+    let a = vec![1, 2, 3, 4, 5];\n+    let b: Vec<isize> = a.iter().cloned().collect();\n+    assert!(a == b);\n+}"}, {"sha": "24059f8a3e40be1539d9f45f99f5155ac4bf61db", "filename": "library/core/tests/iter/traits/double_ended.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,187 @@\n+#[test]\n+fn test_iterator_rev_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().rev().nth_back(i).unwrap(), &v[i]);\n+    }\n+    assert_eq!(v.iter().rev().nth_back(v.len()), None);\n+}\n+#[test]\n+fn test_iterator_rev_nth() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().rev().nth(i).unwrap(), &v[v.len() - 1 - i]);\n+    }\n+    assert_eq!(v.iter().rev().nth(v.len()), None);\n+}\n+#[test]\n+fn test_iterator_len() {\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[..4].iter().count(), 4);\n+    assert_eq!(v[..10].iter().count(), 10);\n+    assert_eq!(v[..0].iter().count(), 0);\n+}\n+#[test]\n+fn test_rev() {\n+    let xs = [2, 4, 6, 8, 10, 12, 14, 16];\n+    let mut it = xs.iter();\n+    it.next();\n+    it.next();\n+    assert!(it.rev().cloned().collect::<Vec<isize>>() == vec![16, 14, 12, 10, 8, 6]);\n+}\n+#[test]\n+fn test_double_ended_map() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().map(|&x| x * -1);\n+    assert_eq!(it.next(), Some(-1));\n+    assert_eq!(it.next(), Some(-2));\n+    assert_eq!(it.next_back(), Some(-6));\n+    assert_eq!(it.next_back(), Some(-5));\n+    assert_eq!(it.next(), Some(-3));\n+    assert_eq!(it.next_back(), Some(-4));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_double_ended_enumerate() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().cloned().enumerate();\n+    assert_eq!(it.next(), Some((0, 1)));\n+    assert_eq!(it.next(), Some((1, 2)));\n+    assert_eq!(it.next_back(), Some((5, 6)));\n+    assert_eq!(it.next_back(), Some((4, 5)));\n+    assert_eq!(it.next_back(), Some((3, 4)));\n+    assert_eq!(it.next_back(), Some((2, 3)));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_double_ended_zip() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let ys = [1, 2, 3, 7];\n+    let a = xs.iter().cloned();\n+    let b = ys.iter().cloned();\n+    let mut it = a.zip(b);\n+    assert_eq!(it.next(), Some((1, 1)));\n+    assert_eq!(it.next(), Some((2, 2)));\n+    assert_eq!(it.next_back(), Some((4, 7)));\n+    assert_eq!(it.next_back(), Some((3, 3)));\n+    assert_eq!(it.next(), None);\n+}\n+#[test]\n+fn test_double_ended_filter() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.next().unwrap(), &2);\n+    assert_eq!(it.next_back(), None);\n+}\n+#[test]\n+fn test_double_ended_filter_map() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n+    assert_eq!(it.next_back().unwrap(), 12);\n+    assert_eq!(it.next_back().unwrap(), 8);\n+    assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.next_back(), None);\n+}\n+#[test]\n+fn test_double_ended_chain() {\n+    let xs = [1, 2, 3, 4, 5];\n+    let ys = [7, 9, 11];\n+    let mut it = xs.iter().chain(&ys).rev();\n+    assert_eq!(it.next().unwrap(), &11);\n+    assert_eq!(it.next().unwrap(), &9);\n+    assert_eq!(it.next_back().unwrap(), &1);\n+    assert_eq!(it.next_back().unwrap(), &2);\n+    assert_eq!(it.next_back().unwrap(), &3);\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.next_back().unwrap(), &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+\n+    // test that .chain() is well behaved with an unfused iterator\n+    struct CrazyIterator(bool);\n+    impl CrazyIterator {\n+        fn new() -> CrazyIterator {\n+            CrazyIterator(false)\n+        }\n+    }\n+    impl Iterator for CrazyIterator {\n+        type Item = i32;\n+        fn next(&mut self) -> Option<i32> {\n+            if self.0 {\n+                Some(99)\n+            } else {\n+                self.0 = true;\n+                None\n+            }\n+        }\n+    }\n+\n+    impl DoubleEndedIterator for CrazyIterator {\n+        fn next_back(&mut self) -> Option<i32> {\n+            self.next()\n+        }\n+    }\n+\n+    assert_eq!(CrazyIterator::new().chain(0..10).rev().last(), Some(0));\n+    assert!((0..10).chain(CrazyIterator::new()).rev().any(|i| i == 0));\n+}\n+#[test]\n+fn test_double_ended_flat_map() {\n+    let u = [0, 1];\n+    let v = [5, 6, 7, 8];\n+    let mut it = u.iter().flat_map(|x| &v[*x..v.len()]);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(), &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n+}\n+#[test]\n+fn test_double_ended_flatten() {\n+    let u = [0, 1];\n+    let v = [5, 6, 7, 8];\n+    let mut it = u.iter().map(|x| &v[*x..v.len()]).flatten();\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(), &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n+}\n+#[test]\n+fn test_double_ended_range() {\n+    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n+    for _ in (10..0).rev() {\n+        panic!(\"unreachable\");\n+    }\n+\n+    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n+    for _ in (10..0).rev() {\n+        panic!(\"unreachable\");\n+    }\n+}\n+#[test]\n+fn test_rev_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2 * acc, x);\n+    assert_eq!((1..10).rev().try_fold(7, f), (1..10).try_rfold(7, f));\n+    assert_eq!((1..10).rev().try_rfold(7, f), (1..10).try_fold(7, f));\n+\n+    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n+    let mut iter = a.iter().rev();\n+    assert_eq!(iter.try_fold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(&70));\n+    let mut iter = a.iter().rev();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(&60));\n+}"}, {"sha": "a2b418fbf8038be80bfe09cf0c3e0a6eff2dcefe", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,405 @@\n+/// A wrapper struct that implements `Eq` and `Ord` based on the wrapped\n+/// integer modulo 3. Used to test that `Iterator::max` and `Iterator::min`\n+/// return the correct element if some of them are equal.\n+#[derive(Debug)]\n+struct Mod3(i32);\n+\n+impl PartialEq for Mod3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 % 3 == other.0 % 3\n+    }\n+}\n+\n+impl Eq for Mod3 {}\n+\n+impl PartialOrd for Mod3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Mod3 {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        (self.0 % 3).cmp(&(other.0 % 3))\n+    }\n+}\n+\n+#[test]\n+fn test_lt() {\n+    let empty: [isize; 0] = [];\n+    let xs = [1, 2, 3];\n+    let ys = [1, 2, 0];\n+\n+    assert!(!xs.iter().lt(ys.iter()));\n+    assert!(!xs.iter().le(ys.iter()));\n+    assert!(xs.iter().gt(ys.iter()));\n+    assert!(xs.iter().ge(ys.iter()));\n+\n+    assert!(ys.iter().lt(xs.iter()));\n+    assert!(ys.iter().le(xs.iter()));\n+    assert!(!ys.iter().gt(xs.iter()));\n+    assert!(!ys.iter().ge(xs.iter()));\n+\n+    assert!(empty.iter().lt(xs.iter()));\n+    assert!(empty.iter().le(xs.iter()));\n+    assert!(!empty.iter().gt(xs.iter()));\n+    assert!(!empty.iter().ge(xs.iter()));\n+\n+    // Sequence with NaN\n+    let u = [1.0f64, 2.0];\n+    let v = [0.0f64 / 0.0, 3.0];\n+\n+    assert!(!u.iter().lt(v.iter()));\n+    assert!(!u.iter().le(v.iter()));\n+    assert!(!u.iter().gt(v.iter()));\n+    assert!(!u.iter().ge(v.iter()));\n+\n+    let a = [0.0f64 / 0.0];\n+    let b = [1.0f64];\n+    let c = [2.0f64];\n+\n+    assert!(a.iter().lt(b.iter()) == (a[0] < b[0]));\n+    assert!(a.iter().le(b.iter()) == (a[0] <= b[0]));\n+    assert!(a.iter().gt(b.iter()) == (a[0] > b[0]));\n+    assert!(a.iter().ge(b.iter()) == (a[0] >= b[0]));\n+\n+    assert!(c.iter().lt(b.iter()) == (c[0] < b[0]));\n+    assert!(c.iter().le(b.iter()) == (c[0] <= b[0]));\n+    assert!(c.iter().gt(b.iter()) == (c[0] > b[0]));\n+    assert!(c.iter().ge(b.iter()) == (c[0] >= b[0]));\n+}\n+#[test]\n+fn test_cmp_by() {\n+    use core::cmp::Ordering;\n+\n+    let f = |x: i32, y: i32| (x * x).cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().cmp_by(ys(), f), Ordering::Less);\n+    assert_eq!(ys().cmp_by(xs(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(xs().map(|x| x * x), f), Ordering::Equal);\n+    assert_eq!(xs().rev().cmp_by(ys().rev(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(ys().rev(), f), Ordering::Less);\n+    assert_eq!(xs().cmp_by(ys().take(2), f), Ordering::Greater);\n+}\n+#[test]\n+fn test_partial_cmp_by() {\n+    use core::cmp::Ordering;\n+\n+    let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), Some(Ordering::Less));\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().map(|x| x * x), f), Some(Ordering::Equal));\n+    assert_eq!(xs().rev().partial_cmp_by(ys().rev(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().rev(), f), Some(Ordering::Less));\n+    assert_eq!(xs().partial_cmp_by(ys().take(2), f), Some(Ordering::Greater));\n+\n+    let f = |x: f64, y: f64| (x * x).partial_cmp(&y);\n+    let xs = || [1.0, 2.0, 3.0, 4.0].iter().copied();\n+    let ys = || [1.0, 4.0, f64::NAN, 16.0].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), None);\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+}\n+#[test]\n+fn test_eq_by() {\n+    let f = |x: i32, y: i32| x * x == y;\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 9, 16].iter().copied();\n+\n+    assert!(xs().eq_by(ys(), f));\n+    assert!(!ys().eq_by(xs(), f));\n+    assert!(!xs().eq_by(xs(), f));\n+    assert!(!ys().eq_by(ys(), f));\n+\n+    assert!(!xs().take(3).eq_by(ys(), f));\n+    assert!(!xs().eq_by(ys().take(3), f));\n+    assert!(xs().take(3).eq_by(ys().take(3), f));\n+}\n+#[test]\n+fn test_iterator_nth() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n+    }\n+    assert_eq!(v.iter().nth(v.len()), None);\n+}\n+#[test]\n+fn test_iterator_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - 1 - i]);\n+    }\n+    assert_eq!(v.iter().nth_back(v.len()), None);\n+}\n+#[test]\n+fn test_iterator_advance_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter();\n+        assert_eq!(iter.advance_by(i), Ok(()));\n+        assert_eq!(iter.next().unwrap(), &v[i]);\n+        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().advance_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().advance_by(100), Err(v.len()));\n+}\n+#[test]\n+fn test_iterator_advance_back_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter();\n+        assert_eq!(iter.advance_back_by(i), Ok(()));\n+        assert_eq!(iter.next_back().unwrap(), &v[v.len() - 1 - i]);\n+        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().advance_back_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().advance_back_by(100), Err(v.len()));\n+}\n+#[test]\n+fn test_iterator_rev_advance_back_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter().rev();\n+        assert_eq!(iter.advance_back_by(i), Ok(()));\n+        assert_eq!(iter.next_back().unwrap(), &v[i]);\n+        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().rev().advance_back_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().rev().advance_back_by(100), Err(v.len()));\n+}\n+#[test]\n+fn test_iterator_last() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    assert_eq!(v.iter().last().unwrap(), &4);\n+    assert_eq!(v[..1].iter().last().unwrap(), &0);\n+}\n+#[test]\n+fn test_iterator_max() {\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[..4].iter().cloned().max(), Some(3));\n+    assert_eq!(v.iter().cloned().max(), Some(10));\n+    assert_eq!(v[..0].iter().cloned().max(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).max().map(|x| x.0), Some(8));\n+}\n+#[test]\n+fn test_iterator_min() {\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[..4].iter().cloned().min(), Some(0));\n+    assert_eq!(v.iter().cloned().min(), Some(0));\n+    assert_eq!(v[..0].iter().cloned().min(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).min().map(|x| x.0), Some(0));\n+}\n+#[test]\n+fn test_iterator_size_hint() {\n+    let c = (0..).step_by(1);\n+    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v2 = &[10, 11, 12];\n+    let vi = v.iter();\n+\n+    assert_eq!((0..).size_hint(), (usize::MAX, None));\n+    assert_eq!(c.size_hint(), (usize::MAX, None));\n+    assert_eq!(vi.clone().size_hint(), (10, Some(10)));\n+\n+    assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(c.clone().skip(5).size_hint().1, None);\n+    assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map_while(|_| None::<()>).size_hint(), (0, None));\n+    assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().enumerate().size_hint(), (usize::MAX, None));\n+    assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (usize::MAX, None));\n+    assert_eq!(c.clone().zip(vi.clone()).size_hint(), (10, Some(10)));\n+    assert_eq!(c.clone().scan(0, |_, _| Some(0)).size_hint(), (0, None));\n+    assert_eq!(c.clone().filter(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map(|_| 0).size_hint(), (usize::MAX, None));\n+    assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n+\n+    assert_eq!(vi.clone().take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(vi.clone().take(12).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n+    assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n+    assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map_while(|_| None::<()>).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().chain(v2).size_hint(), (13, Some(13)));\n+    assert_eq!(vi.clone().zip(v2).size_hint(), (3, Some(3)));\n+    assert_eq!(vi.clone().scan(0, |_, _| Some(0)).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().filter(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map(|&i| i + 1).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n+}\n+#[test]\n+fn test_all() {\n+    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n+    assert!(v.iter().all(|&x| x < 10));\n+    assert!(!v.iter().all(|&x| x % 2 == 0));\n+    assert!(!v.iter().all(|&x| x > 100));\n+    assert!(v[..0].iter().all(|_| panic!()));\n+}\n+#[test]\n+fn test_any() {\n+    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n+    assert!(v.iter().any(|&x| x < 10));\n+    assert!(v.iter().any(|&x| x % 2 == 0));\n+    assert!(!v.iter().any(|&x| x > 100));\n+    assert!(!v[..0].iter().any(|_| panic!()));\n+}\n+#[test]\n+fn test_find() {\n+    let v: &[isize] = &[1, 3, 9, 27, 103, 14, 11];\n+    assert_eq!(*v.iter().find(|&&x| x & 1 == 0).unwrap(), 14);\n+    assert_eq!(*v.iter().find(|&&x| x % 3 == 0).unwrap(), 3);\n+    assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n+}\n+#[test]\n+fn test_try_find() {\n+    let xs: &[isize] = &[];\n+    assert_eq!(xs.iter().try_find(testfn), Ok(None));\n+    let xs: &[isize] = &[1, 2, 3, 4];\n+    assert_eq!(xs.iter().try_find(testfn), Ok(Some(&2)));\n+    let xs: &[isize] = &[1, 3, 4];\n+    assert_eq!(xs.iter().try_find(testfn), Err(()));\n+\n+    let xs: &[isize] = &[1, 2, 3, 4, 5, 6, 7];\n+    let mut iter = xs.iter();\n+    assert_eq!(iter.try_find(testfn), Ok(Some(&2)));\n+    assert_eq!(iter.try_find(testfn), Err(()));\n+    assert_eq!(iter.next(), Some(&5));\n+\n+    fn testfn(x: &&isize) -> Result<bool, ()> {\n+        if **x == 2 {\n+            return Ok(true);\n+        }\n+        if **x == 4 {\n+            return Err(());\n+        }\n+        Ok(false)\n+    }\n+}\n+#[test]\n+fn test_try_find_api_usability() -> Result<(), Box<dyn std::error::Error>> {\n+    let a = [\"1\", \"2\"];\n+\n+    let is_my_num = |s: &str, search: i32| -> Result<bool, std::num::ParseIntError> {\n+        Ok(s.parse::<i32>()? == search)\n+    };\n+\n+    let val = a.iter().try_find(|&&s| is_my_num(s, 2))?;\n+    assert_eq!(val, Some(&\"2\"));\n+\n+    Ok(())\n+}\n+#[test]\n+fn test_position() {\n+    let v = &[1, 3, 9, 27, 103, 14, 11];\n+    assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n+    assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n+    assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n+}\n+#[test]\n+fn test_count() {\n+    let xs = &[1, 2, 2, 1, 5, 9, 0, 2];\n+    assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n+    assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n+    assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n+}\n+#[test]\n+fn test_max_by_key() {\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n+}\n+#[test]\n+fn test_max_by() {\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().max_by(|x, y| x.abs().cmp(&y.abs())).unwrap(), -10);\n+}\n+#[test]\n+fn test_min_by_key() {\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n+}\n+#[test]\n+fn test_min_by() {\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().min_by(|x, y| x.abs().cmp(&y.abs())).unwrap(), 0);\n+}\n+#[test]\n+fn test_by_ref() {\n+    let mut xs = 0..10;\n+    // sum the first five values\n+    let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n+    assert_eq!(partial_sum, 10);\n+    assert_eq!(xs.next(), Some(5));\n+}\n+#[test]\n+fn test_is_sorted() {\n+    assert!([1, 2, 2, 9].iter().is_sorted());\n+    assert!(![1, 3, 2].iter().is_sorted());\n+    assert!([0].iter().is_sorted());\n+    assert!(std::iter::empty::<i32>().is_sorted());\n+    assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n+    assert!([-2, -1, 0, 3].iter().is_sorted());\n+    assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n+    assert!(![\"c\", \"bb\", \"aaa\"].iter().is_sorted());\n+    assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\n+}\n+#[test]\n+fn test_partition() {\n+    fn check(xs: &mut [i32], ref p: impl Fn(&i32) -> bool, expected: usize) {\n+        let i = xs.iter_mut().partition_in_place(p);\n+        assert_eq!(expected, i);\n+        assert!(xs[..i].iter().all(p));\n+        assert!(!xs[i..].iter().any(p));\n+        assert!(xs.iter().is_partitioned(p));\n+        if i == 0 || i == xs.len() {\n+            assert!(xs.iter().rev().is_partitioned(p));\n+        } else {\n+            assert!(!xs.iter().rev().is_partitioned(p));\n+        }\n+    }\n+\n+    check(&mut [], |_| true, 0);\n+    check(&mut [], |_| false, 0);\n+\n+    check(&mut [0], |_| true, 1);\n+    check(&mut [0], |_| false, 0);\n+\n+    check(&mut [-1, 1], |&x| x > 0, 1);\n+    check(&mut [-1, 1], |&x| x < 0, 1);\n+\n+    let ref mut xs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    check(xs, |_| true, 10);\n+    check(xs, |_| false, 0);\n+    check(xs, |&x| x % 2 == 0, 5); // evens\n+    check(xs, |&x| x % 2 == 1, 5); // odds\n+    check(xs, |&x| x % 3 == 0, 4); // multiple of 3\n+    check(xs, |&x| x % 4 == 0, 3); // multiple of 4\n+    check(xs, |&x| x % 5 == 0, 2); // multiple of 5\n+    check(xs, |&x| x < 3, 3); // small\n+    check(xs, |&x| x > 6, 3); // large\n+}\n+#[test]\n+fn test_iterator_rev_advance_by() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+\n+    for i in 0..v.len() {\n+        let mut iter = v.iter().rev();\n+        assert_eq!(iter.advance_by(i), Ok(()));\n+        assert_eq!(iter.next().unwrap(), &v[v.len() - 1 - i]);\n+        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n+    }\n+\n+    assert_eq!(v.iter().rev().advance_by(v.len()), Ok(()));\n+    assert_eq!(v.iter().rev().advance_by(100), Err(v.len()));\n+}"}, {"sha": "d3510703a2d467eaebdb4f423c1228295ca591ea", "filename": "library/core/tests/iter/traits/marker.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fmarker.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,17 @@\n+#[test]\n+fn test_fuse() {\n+    let mut it = 0..3;\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next(), Some(1));\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.len(), 0);\n+}"}, {"sha": "edacebc4b5143e655a174cbca0a62d9c12275e22", "filename": "library/core/tests/iter/traits/mod.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce97000e1a4909dc106ac0a50d936c604f96725/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fmod.rs?ref=3ce97000e1a4909dc106ac0a50d936c604f96725", "patch": "@@ -0,0 +1,39 @@\n+mod accum;\n+mod collect;\n+mod double_ended;\n+mod iterator;\n+mod marker;\n+\n+#[test]\n+fn test_rposition() {\n+    fn f(xy: &(isize, char)) -> bool {\n+        let (_x, y) = *xy;\n+        y == 'b'\n+    }\n+    fn g(xy: &(isize, char)) -> bool {\n+        let (_x, y) = *xy;\n+        y == 'd'\n+    }\n+    let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+    assert_eq!(v.iter().rposition(f), Some(3));\n+    assert!(v.iter().rposition(g).is_none());\n+}\n+#[test]\n+fn test_rev_rposition() {\n+    let v = [0, 0, 1, 1];\n+    assert_eq!(v.iter().rev().rposition(|&x| x == 1), Some(1));\n+}\n+#[test]\n+#[should_panic]\n+fn test_rposition_panic() {\n+    let v: [(Box<_>, Box<_>); 4] = [(box 0, box 0), (box 0, box 0), (box 0, box 0), (box 0, box 0)];\n+    let mut i = 0;\n+    v.iter().rposition(|_elt| {\n+        if i == 2 {\n+            panic!()\n+        }\n+        i += 1;\n+        false\n+    });\n+}"}]}