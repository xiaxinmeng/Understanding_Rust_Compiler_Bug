{"sha": "c229a836e8397afba3fddfb062aa764a620a8098", "node_id": "C_kwDOAAsO6NoAKGMyMjlhODM2ZTgzOTdhZmJhM2ZkZGZiMDYyYWE3NjRhNjIwYTgwOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T10:33:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T10:33:54Z"}, "message": "Auto merge of #14222 - Veykril:pat-mismatch-diags, r=Veykril\n\nShow pattern mismatch diagnostics", "tree": {"sha": "978dcce7f042577b0134f22c3318ec68fbce83a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/978dcce7f042577b0134f22c3318ec68fbce83a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c229a836e8397afba3fddfb062aa764a620a8098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c229a836e8397afba3fddfb062aa764a620a8098", "html_url": "https://github.com/rust-lang/rust/commit/c229a836e8397afba3fddfb062aa764a620a8098", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c229a836e8397afba3fddfb062aa764a620a8098/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b857e1c38bc04384da4a0df9e519a601c60265e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b857e1c38bc04384da4a0df9e519a601c60265e", "html_url": "https://github.com/rust-lang/rust/commit/3b857e1c38bc04384da4a0df9e519a601c60265e"}, {"sha": "522823f610391932e2f4162a8c929af2dacaefc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/522823f610391932e2f4162a8c929af2dacaefc4", "html_url": "https://github.com/rust-lang/rust/commit/522823f610391932e2f4162a8c929af2dacaefc4"}], "stats": {"total": 596, "additions": 354, "deletions": 242}, "files": [{"sha": "fdb236c11146f86df94570efa4f8f650933270c4", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -85,7 +85,7 @@ pub enum ResolveValueResult {\n     Partial(TypeNs, usize),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n     ImplSelf(ImplId),\n     LocalBinding(PatId),"}, {"sha": "e4719237a2aa5a78c23e0a76d3bb866655dae7d6", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -771,6 +771,15 @@ impl<T> InFile<Option<T>> {\n     }\n }\n \n+impl<L, R> InFile<Either<L, R>> {\n+    pub fn transpose(self) -> Either<InFile<L>, InFile<R>> {\n+        match self.value {\n+            Either::Left(l) => Either::Left(InFile::new(self.file_id, l)),\n+            Either::Right(r) => Either::Right(InFile::new(self.file_id, r)),\n+        }\n+    }\n+}\n+\n impl<'a> InFile<&'a SyntaxNode> {\n     pub fn ancestors_with_macros(\n         self,"}, {"sha": "f229bf2f644d3e54b34204f37014f403dad196c2", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -144,44 +144,6 @@ impl Default for BindingMode {\n     }\n }\n \n-/// Used to generalize patterns and assignee expressions.\n-trait PatLike: Into<ExprOrPatId> + Copy {\n-    type BindingMode: Copy;\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        default_bm: Self::BindingMode,\n-    ) -> Ty;\n-}\n-\n-impl PatLike for ExprId {\n-    type BindingMode = ();\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        _: Self::BindingMode,\n-    ) -> Ty {\n-        this.infer_assignee_expr(id, expected_ty)\n-    }\n-}\n-\n-impl PatLike for PatId {\n-    type BindingMode = BindingMode;\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        default_bm: Self::BindingMode,\n-    ) -> Ty {\n-        this.infer_pat(id, expected_ty, default_bm)\n-    }\n-}\n-\n #[derive(Debug)]\n pub(crate) struct InferOk<T> {\n     value: T,\n@@ -389,18 +351,15 @@ impl InferenceResult {\n     pub fn type_mismatch_for_pat(&self, pat: PatId) -> Option<&TypeMismatch> {\n         self.type_mismatches.get(&pat.into())\n     }\n+    pub fn type_mismatches(&self) -> impl Iterator<Item = (ExprOrPatId, &TypeMismatch)> {\n+        self.type_mismatches.iter().map(|(expr_or_pat, mismatch)| (*expr_or_pat, mismatch))\n+    }\n     pub fn expr_type_mismatches(&self) -> impl Iterator<Item = (ExprId, &TypeMismatch)> {\n         self.type_mismatches.iter().filter_map(|(expr_or_pat, mismatch)| match *expr_or_pat {\n             ExprOrPatId::ExprId(expr) => Some((expr, mismatch)),\n             _ => None,\n         })\n     }\n-    pub fn pat_type_mismatches(&self) -> impl Iterator<Item = (PatId, &TypeMismatch)> {\n-        self.type_mismatches.iter().filter_map(|(expr_or_pat, mismatch)| match *expr_or_pat {\n-            ExprOrPatId::PatId(pat) => Some((pat, mismatch)),\n-            _ => None,\n-        })\n-    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -584,7 +543,7 @@ impl<'a> InferenceContext<'a> {\n             let ty = self.insert_type_vars(ty);\n             let ty = self.normalize_associated_types_in(ty);\n \n-            self.infer_pat(*pat, &ty, BindingMode::default());\n+            self.infer_top_pat(*pat, &ty);\n         }\n         let error_ty = &TypeRef::Error;\n         let return_ty = if data.has_async_kw() {"}, {"sha": "6f20f0dc893ec4dbda4826ff24216b5a54743b0d", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -25,7 +25,9 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n+    infer::{\n+        coerce::CoerceMany, find_continuable, pat::contains_explicit_ref_binding, BreakableKind,\n+    },\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n@@ -39,8 +41,8 @@ use crate::{\n };\n \n use super::{\n-    coerce::auto_deref_adjust_steps, find_breakable, BindingMode, BreakableContext, Diverges,\n-    Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,\n+    coerce::auto_deref_adjust_steps, find_breakable, BreakableContext, Diverges, Expectation,\n+    InferenceContext, InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -111,7 +113,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n-                self.infer_pat(pat, &input_ty, BindingMode::default());\n+                self.infer_top_pat(pat, &input_ty);\n                 self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n@@ -223,7 +225,7 @@ impl<'a> InferenceContext<'a> {\n                 let pat_ty =\n                     self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n \n-                self.infer_pat(pat, &pat_ty, BindingMode::default());\n+                self.infer_top_pat(pat, &pat_ty);\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n@@ -298,7 +300,7 @@ impl<'a> InferenceContext<'a> {\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n-                    self.infer_pat(*arg_pat, &arg_ty, BindingMode::default());\n+                    self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n@@ -395,7 +397,8 @@ impl<'a> InferenceContext<'a> {\n \n                 for arm in arms.iter() {\n                     self.diverges = Diverges::Maybe;\n-                    let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n+                    let input_ty = self.resolve_ty_shallow(&input_ty);\n+                    self.infer_top_pat(arm.pat, &input_ty);\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n@@ -1142,27 +1145,33 @@ impl<'a> InferenceContext<'a> {\n                     let decl_ty = type_ref\n                         .as_ref()\n                         .map(|tr| self.make_ty(tr))\n-                        .unwrap_or_else(|| self.err_ty());\n-\n-                    // Always use the declared type when specified\n-                    let mut ty = decl_ty.clone();\n+                        .unwrap_or_else(|| self.table.new_type_var());\n \n-                    if let Some(expr) = initializer {\n-                        let actual_ty =\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n-                        if decl_ty.is_unknown() {\n-                            ty = actual_ty;\n+                    let ty = if let Some(expr) = initializer {\n+                        let ty = if contains_explicit_ref_binding(&self.body, *pat) {\n+                            self.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n+                        } else {\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()))\n+                        };\n+                        if type_ref.is_some() {\n+                            decl_ty\n+                        } else {\n+                            ty\n                         }\n-                    }\n+                    } else {\n+                        decl_ty\n+                    };\n+\n+                    self.infer_top_pat(*pat, &ty);\n \n                     if let Some(expr) = else_branch {\n+                        let previous_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                         self.infer_expr_coerce(\n                             *expr,\n                             &Expectation::HasType(self.result.standard_types.never.clone()),\n                         );\n+                        self.diverges = previous_diverges;\n                     }\n-\n-                    self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr { expr, .. } => {\n                     self.infer_expr(*expr, &Expectation::none());"}, {"sha": "3d03c2a527cbd7606d8de9957a8ba7ca4256033c", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 203, "deletions": 106, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -4,7 +4,8 @@ use std::iter::repeat_with;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{BindingAnnotation, Expr, Literal, Pat, PatId},\n+    body::Body,\n+    expr::{BindingAnnotation, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId, RecordFieldPat},\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -17,7 +18,43 @@ use crate::{\n     static_lifetime, Interner, Scalar, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n-use super::PatLike;\n+/// Used to generalize patterns and assignee expressions.\n+pub(super) trait PatLike: Into<ExprOrPatId> + Copy {\n+    type BindingMode: Copy;\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty;\n+}\n+\n+impl PatLike for ExprId {\n+    type BindingMode = ();\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        (): Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_assignee_expr(id, expected_ty)\n+    }\n+}\n+\n+impl PatLike for PatId {\n+    type BindingMode = BindingMode;\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_pat(id, expected_ty, default_bm)\n+    }\n+}\n \n impl<'a> InferenceContext<'a> {\n     /// Infers type for tuple struct pattern or its corresponding assignee expression.\n@@ -110,6 +147,7 @@ impl<'a> InferenceContext<'a> {\n         ellipsis: Option<usize>,\n         subs: &[T],\n     ) -> Ty {\n+        let expected = self.resolve_ty_shallow(expected);\n         let expectations = match expected.as_tuple() {\n             Some(parameters) => &*parameters.as_slice(Interner),\n             _ => &[],\n@@ -143,12 +181,11 @@ impl<'a> InferenceContext<'a> {\n             .intern(Interner)\n     }\n \n-    pub(super) fn infer_pat(\n-        &mut self,\n-        pat: PatId,\n-        expected: &Ty,\n-        mut default_bm: BindingMode,\n-    ) -> Ty {\n+    pub(super) fn infer_top_pat(&mut self, pat: PatId, expected: &Ty) {\n+        self.infer_pat(pat, expected, BindingMode::default());\n+    }\n+\n+    fn infer_pat(&mut self, pat: PatId, expected: &Ty, mut default_bm: BindingMode) -> Ty {\n         let mut expected = self.resolve_ty_shallow(expected);\n \n         if is_non_ref_pat(self.body, pat) {\n@@ -183,30 +220,17 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_tuple_pat_like(&expected, default_bm, *ellipsis, args)\n             }\n             Pat::Or(pats) => {\n-                if let Some((first_pat, rest)) = pats.split_first() {\n-                    let ty = self.infer_pat(*first_pat, &expected, default_bm);\n-                    for pat in rest {\n-                        self.infer_pat(*pat, &expected, default_bm);\n-                    }\n-                    ty\n-                } else {\n-                    self.err_ty()\n+                for pat in pats.iter() {\n+                    self.infer_pat(*pat, &expected, default_bm);\n                 }\n+                expected.clone()\n             }\n-            Pat::Ref { pat, mutability } => {\n-                let mutability = lower_to_chalk_mutability(*mutability);\n-                let expectation = match expected.as_reference() {\n-                    Some((inner_ty, _lifetime, exp_mut)) => {\n-                        if mutability != exp_mut {\n-                            // FIXME: emit type error?\n-                        }\n-                        inner_ty.clone()\n-                    }\n-                    _ => self.result.standard_types.unknown.clone(),\n-                };\n-                let subty = self.infer_pat(*pat, &expectation, default_bm);\n-                TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n-            }\n+            &Pat::Ref { pat, mutability } => self.infer_ref_pat(\n+                pat,\n+                lower_to_chalk_mutability(mutability),\n+                &expected,\n+                default_bm,\n+            ),\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self\n                 .infer_tuple_struct_pat_like(\n                     p.as_deref(),\n@@ -226,90 +250,21 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_path(&resolver, path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n             Pat::Bind { mode, name: _, subpat } => {\n-                let mode = if mode == &BindingAnnotation::Unannotated {\n-                    default_bm\n-                } else {\n-                    BindingMode::convert(*mode)\n-                };\n-                self.result.pat_binding_modes.insert(pat, mode);\n-\n-                let inner_ty = match subpat {\n-                    Some(subpat) => self.infer_pat(*subpat, &expected, default_bm),\n-                    None => expected,\n-                };\n-                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n-\n-                let bound_ty = match mode {\n-                    BindingMode::Ref(mutability) => {\n-                        TyKind::Ref(mutability, static_lifetime(), inner_ty.clone())\n-                            .intern(Interner)\n-                    }\n-                    BindingMode::Move => inner_ty.clone(),\n-                };\n-                self.write_pat_ty(pat, bound_ty);\n-                return inner_ty;\n+                return self.infer_bind_pat(pat, *mode, default_bm, *subpat, &expected);\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let elem_ty = match expected.kind(Interner) {\n-                    TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n-                    _ => self.err_ty(),\n-                };\n-\n-                for &pat_id in prefix.iter().chain(suffix.iter()) {\n-                    self.infer_pat(pat_id, &elem_ty, default_bm);\n-                }\n-\n-                if let &Some(slice_pat_id) = slice {\n-                    let rest_pat_ty = match expected.kind(Interner) {\n-                        TyKind::Array(_, length) => {\n-                            let len = try_const_usize(length);\n-                            let len = len.and_then(|len| {\n-                                len.checked_sub((prefix.len() + suffix.len()) as u128)\n-                            });\n-                            TyKind::Array(\n-                                elem_ty.clone(),\n-                                usize_const(self.db, len, self.resolver.krate()),\n-                            )\n-                        }\n-                        _ => TyKind::Slice(elem_ty.clone()),\n-                    }\n-                    .intern(Interner);\n-                    self.infer_pat(slice_pat_id, &rest_pat_ty, default_bm);\n-                }\n-\n-                match expected.kind(Interner) {\n-                    TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n-                    _ => TyKind::Slice(elem_ty),\n-                }\n-                .intern(Interner)\n+                self.infer_slice_pat(&expected, prefix, slice, suffix, default_bm)\n             }\n             Pat::Wild => expected.clone(),\n             Pat::Range { start, end } => {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n                 self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n             &Pat::Lit(expr) => {\n-                // FIXME: using `Option` here is a workaround until we can use if-let chains in stable.\n-                let mut pat_ty = None;\n-\n-                // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n-                if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n-                    if let Some((inner, ..)) = expected.as_reference() {\n-                        let inner = self.resolve_ty_shallow(inner);\n-                        if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n-                            let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n-                            let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n-                            let ty = TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty)\n-                                .intern(Interner);\n-                            self.write_expr_ty(expr, ty.clone());\n-                            pat_ty = Some(ty);\n-                        }\n-                    }\n-                }\n-\n-                pat_ty.unwrap_or_else(|| {\n-                    self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n-                })\n+                // Don't emit type mismatches again, the expression lowering already did that.\n+                let ty = self.infer_lit_pat(expr, &expected);\n+                self.write_pat_ty(pat, ty.clone());\n+                return ty;\n             }\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n@@ -338,14 +293,118 @@ impl<'a> InferenceContext<'a> {\n         };\n         // use a new type variable if we got error type here\n         let ty = self.insert_type_vars_shallow(ty);\n-        if !self.unify(&ty, &expected) {\n+        // FIXME: This never check is odd, but required with out we do inference right now\n+        if !expected.is_never() && !self.unify(&ty, &expected) {\n             self.result\n                 .type_mismatches\n                 .insert(pat.into(), TypeMismatch { expected, actual: ty.clone() });\n         }\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }\n+\n+    fn infer_ref_pat(\n+        &mut self,\n+        pat: PatId,\n+        mutability: Mutability,\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let expectation = match expected.as_reference() {\n+            Some((inner_ty, _lifetime, _exp_mut)) => inner_ty.clone(),\n+            _ => self.result.standard_types.unknown.clone(),\n+        };\n+        let subty = self.infer_pat(pat, &expectation, default_bm);\n+        TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n+    }\n+\n+    fn infer_bind_pat(\n+        &mut self,\n+        pat: PatId,\n+        mode: BindingAnnotation,\n+        default_bm: BindingMode,\n+        subpat: Option<PatId>,\n+        expected: &Ty,\n+    ) -> Ty {\n+        let mode = if mode == BindingAnnotation::Unannotated {\n+            default_bm\n+        } else {\n+            BindingMode::convert(mode)\n+        };\n+        self.result.pat_binding_modes.insert(pat, mode);\n+\n+        let inner_ty = match subpat {\n+            Some(subpat) => self.infer_pat(subpat, &expected, default_bm),\n+            None => expected.clone(),\n+        };\n+        let inner_ty = self.insert_type_vars_shallow(inner_ty);\n+\n+        let bound_ty = match mode {\n+            BindingMode::Ref(mutability) => {\n+                TyKind::Ref(mutability, static_lifetime(), inner_ty.clone()).intern(Interner)\n+            }\n+            BindingMode::Move => inner_ty.clone(),\n+        };\n+        self.write_pat_ty(pat, bound_ty);\n+        return inner_ty;\n+    }\n+\n+    fn infer_slice_pat(\n+        &mut self,\n+        expected: &Ty,\n+        prefix: &[PatId],\n+        slice: &Option<PatId>,\n+        suffix: &[PatId],\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let elem_ty = match expected.kind(Interner) {\n+            TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n+            _ => self.err_ty(),\n+        };\n+\n+        for &pat_id in prefix.iter().chain(suffix.iter()) {\n+            self.infer_pat(pat_id, &elem_ty, default_bm);\n+        }\n+\n+        if let &Some(slice_pat_id) = slice {\n+            let rest_pat_ty = match expected.kind(Interner) {\n+                TyKind::Array(_, length) => {\n+                    let len = try_const_usize(length);\n+                    let len =\n+                        len.and_then(|len| len.checked_sub((prefix.len() + suffix.len()) as u128));\n+                    TyKind::Array(elem_ty.clone(), usize_const(self.db, len, self.resolver.krate()))\n+                }\n+                _ => TyKind::Slice(elem_ty.clone()),\n+            }\n+            .intern(Interner);\n+            self.infer_pat(slice_pat_id, &rest_pat_ty, default_bm);\n+        }\n+\n+        match expected.kind(Interner) {\n+            TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n+            _ => TyKind::Slice(elem_ty),\n+        }\n+        .intern(Interner)\n+    }\n+\n+    fn infer_lit_pat(&mut self, expr: ExprId, expected: &Ty) -> Ty {\n+        // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n+        if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n+            if let Some((inner, ..)) = expected.as_reference() {\n+                let inner = self.resolve_ty_shallow(inner);\n+                if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n+                    let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n+                    let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n+                    let ty =\n+                        TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty).intern(Interner);\n+                    self.write_expr_ty(expr, ty.clone());\n+                    return ty;\n+                }\n+            }\n+        }\n+\n+        self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n+    }\n }\n \n fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n@@ -370,3 +429,41 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Box { .. } | Pat::Missing => false,\n     }\n }\n+\n+pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n+    let mut res = false;\n+    walk_pats(body, pat_id, &mut |pat| {\n+        res |= matches!(pat, Pat::Bind { mode: BindingAnnotation::Ref, .. })\n+    });\n+    res\n+}\n+\n+fn walk_pats(body: &Body, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+    let pat = &body[pat_id];\n+    f(pat);\n+    match pat {\n+        Pat::Range { .. }\n+        | Pat::Lit(..)\n+        | Pat::Path(..)\n+        | Pat::ConstBlock(..)\n+        | Pat::Wild\n+        | Pat::Missing => {}\n+        &Pat::Bind { subpat, .. } => {\n+            if let Some(subpat) = subpat {\n+                walk_pats(body, subpat, f);\n+            }\n+        }\n+        Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+            args.iter().copied().for_each(|p| walk_pats(body, p, f));\n+        }\n+        Pat::Ref { pat, .. } => walk_pats(body, *pat, f),\n+        Pat::Slice { prefix, slice, suffix } => {\n+            let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+            total_iter.copied().for_each(|p| walk_pats(body, p, f));\n+        }\n+        Pat::Record { args, .. } => {\n+            args.iter().for_each(|RecordFieldPat { pat, .. }| walk_pats(body, *pat, f));\n+        }\n+        Pat::Box { inner } => walk_pats(body, *inner, f),\n+    }\n+}"}, {"sha": "ab848a18eb38285b98a7b99e963d2dd3e8292791", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -191,30 +191,11 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n             }\n         }\n \n-        for (pat, mismatch) in inference_result.pat_type_mismatches() {\n-            let node = match pat_node(&body_source_map, pat, &db) {\n-                Some(value) => value,\n-                None => continue,\n-            };\n-            let range = node.as_ref().original_file_range(&db);\n-            let actual = format!(\n-                \"expected {}, got {}\",\n-                mismatch.expected.display_test(&db),\n-                mismatch.actual.display_test(&db)\n-            );\n-            match mismatches.remove(&range) {\n-                Some(annotation) => assert_eq!(actual, annotation),\n-                None => format_to!(unexpected_type_mismatches, \"{:?}: {}\\n\", range.range, actual),\n-            }\n-        }\n-        for (expr, mismatch) in inference_result.expr_type_mismatches() {\n-            let node = match body_source_map.expr_syntax(expr) {\n-                Ok(sp) => {\n-                    let root = db.parse_or_expand(sp.file_id).unwrap();\n-                    sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n-                }\n-                Err(SyntheticSyntax) => continue,\n-            };\n+        for (expr_or_pat, mismatch) in inference_result.type_mismatches() {\n+            let Some(node) = (match expr_or_pat {\n+                hir_def::expr::ExprOrPatId::ExprId(expr) => expr_node(&body_source_map, expr, &db),\n+                hir_def::expr::ExprOrPatId::PatId(pat) => pat_node(&body_source_map, pat, &db),\n+            }) else { continue; };\n             let range = node.as_ref().original_file_range(&db);\n             let actual = format!(\n                 \"expected {}, got {}\","}, {"sha": "be67329fee4417189c42474436427f0151723c74", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -953,9 +953,9 @@ fn main() {\n             42..51 'true | ()': bool\n             49..51 '()': ()\n             57..59 '{}': ()\n-            68..80 '(() | true,)': ((),)\n+            68..80 '(() | true,)': (bool,)\n             69..71 '()': ()\n-            69..78 '() | true': ()\n+            69..78 '() | true': bool\n             74..78 'true': bool\n             74..78 'true': bool\n             84..86 '{}': ()\n@@ -964,19 +964,15 @@ fn main() {\n             96..102 '_ | ()': bool\n             100..102 '()': ()\n             108..110 '{}': ()\n-            119..128 '(() | _,)': ((),)\n+            119..128 '(() | _,)': (bool,)\n             120..122 '()': ()\n-            120..126 '() | _': ()\n+            120..126 '() | _': bool\n             125..126 '_': bool\n             132..134 '{}': ()\n             49..51: expected bool, got ()\n-            68..80: expected (bool,), got ((),)\n             69..71: expected bool, got ()\n-            69..78: expected bool, got ()\n             100..102: expected bool, got ()\n-            119..128: expected (bool,), got ((),)\n             120..122: expected bool, got ()\n-            120..126: expected bool, got ()\n         \"#]],\n     );\n }\n@@ -1092,3 +1088,19 @@ fn my_fn(foo: ...) {}\n \"#,\n     );\n }\n+\n+#[test]\n+fn ref_pat_mutability() {\n+    check(\n+        r#\"\n+fn foo() {\n+    let &() = &();\n+    let &mut () = &mut ();\n+    let &mut () = &();\n+      //^^^^^^^ expected &(), got &mut ()\n+    let &() = &mut ();\n+      //^^^ expected &mut (), got &()\n+}\n+\"#,\n+    );\n+}"}, {"sha": "3b2591e8a106d4f8be9df275dc8809e596295d7d", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -178,8 +178,7 @@ pub struct MissingMatchArms {\n \n #[derive(Debug)]\n pub struct TypeMismatch {\n-    // FIXME: add mismatches in patterns as well\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub expr_or_pat: Either<InFile<AstPtr<ast::Expr>>, InFile<AstPtr<ast::Pat>>>,\n     pub expected: Type,\n     pub actual: Type,\n }"}, {"sha": "846ad4007ce26882d7e4219b06d0779c94e1b760", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -1413,14 +1413,22 @@ impl DefWithBody {\n                 }\n             }\n         }\n-        for (expr, mismatch) in infer.expr_type_mismatches() {\n-            let expr = match source_map.expr_syntax(expr) {\n-                Ok(expr) => expr,\n-                Err(SyntheticSyntax) => continue,\n+        for (pat_or_expr, mismatch) in infer.type_mismatches() {\n+            let expr_or_pat = match pat_or_expr {\n+                ExprOrPatId::ExprId(expr) => source_map.expr_syntax(expr).map(Either::Left),\n+                ExprOrPatId::PatId(pat) => source_map.pat_syntax(pat).map(Either::Right),\n             };\n+            let expr_or_pat = match expr_or_pat {\n+                Ok(Either::Left(expr)) => Either::Left(expr),\n+                Ok(Either::Right(InFile { file_id, value: Either::Left(pat) })) => {\n+                    Either::Right(InFile { file_id, value: pat })\n+                }\n+                Ok(Either::Right(_)) | Err(SyntheticSyntax) => continue,\n+            };\n+\n             acc.push(\n                 TypeMismatch {\n-                    expr,\n+                    expr_or_pat,\n                     expected: Type::new(db, DefWithBodyId::from(self), mismatch.expected.clone()),\n                     actual: Type::new(db, DefWithBodyId::from(self), mismatch.actual.clone()),\n                 }"}, {"sha": "6594eed26d1712bce003245b2795120836406512", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -273,15 +273,20 @@ enum Either2 { C, D }\n fn main() {\n     match Either::A {\n         Either2::C => (),\n+     // ^^^^^^^^^^  error: expected Either, found Either2\n         Either2::D => (),\n+     // ^^^^^^^^^^  error: expected Either, found Either2\n     }\n     match (true, false) {\n         (true, false, true) => (),\n+     // ^^^^^^^^^^^^^^^^^^^  error: expected (bool, bool), found (bool, bool, bool)\n         (true) => (),\n       // ^^^^  error: expected (bool, bool), found bool\n     }\n     match (true, false) { (true,) => {} }\n+                       // ^^^^^^^  error: expected (bool, bool), found (bool,)\n     match (0) { () => () }\n+             // ^^  error: expected i32, found ()\n     match Unresolved::Bar { Unresolved::Baz => () }\n }\n         \"#,\n@@ -295,7 +300,9 @@ fn main() {\n             r#\"\n fn main() {\n     match false { true | () => {} }\n+                      // ^^  error: expected bool, found ()\n     match (false,) { (true | (),) => {} }\n+                          // ^^  error: expected bool, found ()\n }\n \"#,\n         );\n@@ -1038,12 +1045,12 @@ fn main() {\n         #[test]\n         fn reference_patterns_in_fields() {\n             cov_mark::check_count!(validate_match_bailed_out, 2);\n-\n             check_diagnostics(\n                 r#\"\n fn main() {\n     match (&false,) {\n         (true,) => {}\n+     // ^^^^^^^  error: expected (&bool,), found (bool,)\n     }\n     match (&false,) {\n         (&true,) => {}"}, {"sha": "2026a2d4b8a0ced962a92dd7d755033fef6b8a58", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 60, "deletions": 28, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -1,28 +1,33 @@\n-use hir::{db::AstDatabase, HirDisplay, Type};\n+use either::Either;\n+use hir::{db::AstDatabase, HirDisplay, InFile, Type};\n use ide_db::{famous_defs::FamousDefs, source_change::SourceChange};\n use syntax::{\n     ast::{self, BlockExpr, ExprStmt},\n-    AstNode,\n+    AstNode, AstPtr,\n };\n use text_edit::TextEdit;\n \n use crate::{adjusted_display_range, fix, Assist, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: type-mismatch\n //\n-// This diagnostic is triggered when the type of an expression does not match\n+// This diagnostic is triggered when the type of an expression or pattern does not match\n // the expected type.\n pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Diagnostic {\n-    let display_range = adjusted_display_range::<ast::BlockExpr>(\n-        ctx,\n-        d.expr.clone().map(|it| it.into()),\n-        &|block| {\n-            let r_curly_range = block.stmt_list()?.r_curly_token()?.text_range();\n-            cov_mark::hit!(type_mismatch_on_block);\n-            Some(r_curly_range)\n-        },\n-    );\n-\n+    let display_range = match &d.expr_or_pat {\n+        Either::Left(expr) => adjusted_display_range::<ast::BlockExpr>(\n+            ctx,\n+            expr.clone().map(|it| it.into()),\n+            &|block| {\n+                let r_curly_range = block.stmt_list()?.r_curly_token()?.text_range();\n+                cov_mark::hit!(type_mismatch_on_block);\n+                Some(r_curly_range)\n+            },\n+        ),\n+        Either::Right(pat) => {\n+            ctx.sema.diagnostics_display_range(pat.clone().map(|it| it.into())).range\n+        }\n+    };\n     let mut diag = Diagnostic::new(\n         \"type-mismatch\",\n         format!(\n@@ -42,10 +47,15 @@ pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch)\n fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assist>> {\n     let mut fixes = Vec::new();\n \n-    add_reference(ctx, d, &mut fixes);\n-    add_missing_ok_or_some(ctx, d, &mut fixes);\n-    remove_semicolon(ctx, d, &mut fixes);\n-    str_ref_to_owned(ctx, d, &mut fixes);\n+    match &d.expr_or_pat {\n+        Either::Left(expr_ptr) => {\n+            add_reference(ctx, d, expr_ptr, &mut fixes);\n+            add_missing_ok_or_some(ctx, d, expr_ptr, &mut fixes);\n+            remove_semicolon(ctx, d, expr_ptr, &mut fixes);\n+            str_ref_to_owned(ctx, d, expr_ptr, &mut fixes);\n+        }\n+        Either::Right(_pat_ptr) => {}\n+    }\n \n     if fixes.is_empty() {\n         None\n@@ -57,9 +67,10 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assi\n fn add_reference(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range;\n+    let range = ctx.sema.diagnostics_display_range(expr_ptr.clone().map(|it| it.into())).range;\n \n     let (_, mutability) = d.expected.as_reference()?;\n     let actual_with_ref = Type::reference(&d.actual, mutability);\n@@ -71,18 +82,19 @@ fn add_reference(\n \n     let edit = TextEdit::insert(range.start(), ampersands);\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), edit);\n     acc.push(fix(\"add_reference_here\", \"Add reference here\", source_change, range));\n     Some(())\n }\n \n fn add_missing_ok_or_some(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr = d.expr.value.to_node(&root);\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n     let expr_range = expr.syntax().text_range();\n     let scope = ctx.sema.scope(expr.syntax())?;\n \n@@ -109,7 +121,7 @@ fn add_missing_ok_or_some(\n     builder.insert(expr.syntax().text_range().start(), format!(\"{variant_name}(\"));\n     builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), builder.finish());\n     let name = format!(\"Wrap in {variant_name}\");\n     acc.push(fix(\"wrap_in_constructor\", &name, source_change, expr_range));\n     Some(())\n@@ -118,10 +130,11 @@ fn add_missing_ok_or_some(\n fn remove_semicolon(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr = d.expr.value.to_node(&root);\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n     if !d.actual.is_unit() {\n         return None;\n     }\n@@ -136,7 +149,7 @@ fn remove_semicolon(\n \n     let edit = TextEdit::delete(semicolon_range);\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), edit);\n \n     acc.push(fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon_range));\n     Some(())\n@@ -145,24 +158,26 @@ fn remove_semicolon(\n fn str_ref_to_owned(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n     let expected = d.expected.display(ctx.sema.db);\n     let actual = d.actual.display(ctx.sema.db);\n \n+    // FIXME do this properly\n     if expected.to_string() != \"String\" || actual.to_string() != \"&str\" {\n         return None;\n     }\n \n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr = d.expr.value.to_node(&root);\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n     let expr_range = expr.syntax().text_range();\n \n     let to_owned = format!(\".to_owned()\");\n \n     let edit = TextEdit::insert(expr.syntax().text_range().end(), to_owned);\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), edit);\n     acc.push(fix(\"str_ref_to_owned\", \"Add .to_owned() here\", source_change, expr_range));\n \n     Some(())\n@@ -592,6 +607,23 @@ fn f() -> i32 {\n     let _ = x + y;\n   }\n //^ error: expected i32, found ()\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn type_mismatch_pat_smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn f() {\n+    let &() = &mut ();\n+      //^^^ error: expected &mut (), found &()\n+    match &() {\n+        &9 => ()\n+      //^^ error: expected &(), found &i32\n+       //^ error: expected (), found i32\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "729780fa0c919903a1be2102cc02a70bc6920c78", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c229a836e8397afba3fddfb062aa764a620a8098/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=c229a836e8397afba3fddfb062aa764a620a8098", "patch": "@@ -606,14 +606,13 @@ fn a() {\n     }\n \n     #[test]\n-    fn bug() {\n+    fn let_stmt_explicit_ty() {\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\"\n fn main() {\n-    // These should be identical, but they are not...\n-\n     let () = return;\n+           //^^^^^^<never-to-any>\n     let (): () = return;\n                //^^^^^^<never-to-any>\n }"}]}