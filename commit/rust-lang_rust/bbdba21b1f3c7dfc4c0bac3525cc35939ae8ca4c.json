{"sha": "bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZGJhMjFiMWYzYzdkZmM0YzBiYWMzNTI1Y2MzNTkzOWFlOGNhNGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:26:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:26:26Z"}, "message": "rustc: Revert the conversion to interior vectors due to heap corruption", "tree": {"sha": "d9cb0046b2a608b4b44c54eacce7951326c65df2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9cb0046b2a608b4b44c54eacce7951326c65df2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "html_url": "https://github.com/rust-lang/rust/commit/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec890fff23d80da97086e89f29ef7f8d14dbaab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec890fff23d80da97086e89f29ef7f8d14dbaab8", "html_url": "https://github.com/rust-lang/rust/commit/ec890fff23d80da97086e89f29ef7f8d14dbaab8"}], "stats": {"total": 1411, "additions": 633, "deletions": 778}, "files": [{"sha": "37bcd0bb8b821223c5cc41cd6557bd6c90317f6f", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,6 +1,5 @@\n // Functions dealing with attributes and meta_items\n \n-import std::ivec;\n import std::vec;\n import std::str;\n import std::map;\n@@ -29,11 +28,13 @@ export mk_attr;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n-fn find_linkage_metas(&ast::attribute[] attrs) -> (@ast::meta_item)[] {\n-    let (@ast::meta_item)[] metas = ~[];\n+fn find_linkage_metas(vec[ast::attribute] attrs) -> vec[@ast::meta_item] {\n+    let vec[@ast::meta_item] metas = [];\n     for (ast::attribute attr in find_attrs_by_name(attrs, \"link\")) {\n         alt (attr.node.value.node) {\n-            case (ast::meta_list(_, ?items)) { metas += items; }\n+            case (ast::meta_list(_, ?items)) {\n+                metas += items;\n+            }\n             case (_) {\n                 log \"ignoring link attribute that has incorrect type\";\n             }\n@@ -43,8 +44,8 @@ fn find_linkage_metas(&ast::attribute[] attrs) -> (@ast::meta_item)[] {\n }\n \n // Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(&ast::attribute[] attrs,\n-                      ast::ident name) -> ast::attribute[] {\n+fn find_attrs_by_name(vec[ast::attribute] attrs,\n+                      ast::ident name) -> vec[ast::attribute] {\n     auto filter = bind fn(&ast::attribute a,\n                           ast::ident name) -> option::t[ast::attribute] {\n         if (get_attr_name(a) == name) {\n@@ -53,7 +54,7 @@ fn find_attrs_by_name(&ast::attribute[] attrs,\n             option::none\n         }\n     } (_, name);\n-    ret ivec::filter_map(filter, attrs);\n+    ret vec::filter_map(filter, attrs);\n }\n \n fn get_attr_name(&ast::attribute attr) -> ast::ident {\n@@ -100,10 +101,8 @@ fn get_meta_item_value_str(&@ast::meta_item meta) -> option::t[str] {\n fn attr_meta(&ast::attribute attr) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(&ast::attribute[] attrs) -> vec[@ast::meta_item] {\n-    auto mitems = [];\n-    for (ast::attribute a in attrs) { mitems += [attr_meta(a)]; }\n-    ret mitems;\n+fn attr_metas(&vec[ast::attribute] attrs) -> vec[@ast::meta_item] {\n+    ret vec::map(attr_meta, attrs);\n }\n \n fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {\n@@ -131,7 +130,7 @@ fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {\n     }\n }\n \n-fn contains(&(@ast::meta_item)[] haystack, @ast::meta_item needle) -> bool {\n+fn contains(&vec[@ast::meta_item] haystack, @ast::meta_item needle) -> bool {\n     log #fmt(\"looking for %s\",\n              syntax::print::pprust::meta_item_to_str(*needle));\n     for (@ast::meta_item item in haystack) {\n@@ -220,8 +219,8 @@ fn mk_name_value_item(ast::ident name, ast::lit value) -> @ast::meta_item {\n     ret @span(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(ast::ident name, &(@ast::meta_item)[] items)\n-        -> @ast::meta_item {\n+fn mk_list_item(ast::ident name,\n+                &vec[@ast::meta_item] items) -> @ast::meta_item {\n     ret @span(ast::meta_list(name, items));\n }\n "}, {"sha": "4e6bb485cd23a55add7980609624c005087f5bb2", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,4 +1,3 @@\n-import std::ivec;\n import std::option;\n import std::vec;\n import syntax::ast;\n@@ -98,20 +97,20 @@ fn native_item_in_cfg(&ast::crate_cfg cfg, &@ast::native_item item) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(&ast::crate_cfg cfg, &ast::attribute[] attrs) -> bool {\n+fn in_cfg(&ast::crate_cfg cfg, &vec[ast::attribute] attrs) -> bool {\n \n     // The \"cfg\" attributes on the item\n     auto item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n-    auto item_has_cfg_attrs = ivec::len(item_cfg_attrs) > 0u;\n+    auto item_has_cfg_attrs = vec::len(item_cfg_attrs) > 0u;\n     if (!item_has_cfg_attrs) { ret true; }\n \n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n     auto item_cfg_metas = {\n-        fn extract_metas(&(@ast::meta_item)[] inner_items,\n+        fn extract_metas(&vec[@ast::meta_item] inner_items,\n                          &@ast::meta_item cfg_item)\n-        -> (@ast::meta_item)[] {\n+        -> vec[@ast::meta_item] {\n \n             alt (cfg_item.node) {\n                 case (ast::meta_list(?name, ?items)) {\n@@ -122,11 +121,13 @@ fn in_cfg(&ast::crate_cfg cfg, &ast::attribute[] attrs) -> bool {\n             }\n         }\n         auto cfg_metas = attr::attr_metas(item_cfg_attrs);\n-        ivec::foldl(extract_metas, ~[], cfg_metas)\n+        vec::foldl(extract_metas, [], cfg_metas)\n     };\n \n     for (@ast::meta_item cfg_mi in item_cfg_metas) {\n-        if (attr::contains(cfg, cfg_mi)) { ret true; }\n+        if (attr::contains(cfg, cfg_mi)) {\n+            ret true;\n+        }\n     }\n \n     ret false;"}, {"sha": "7bcb9e48bf8633e6733d21c6c4effb6eb2a59857", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -194,27 +194,27 @@ fn get_symbol(session::session sess, ast::def_id def) -> str {\n     ret item_symbol(lookup_item(def._1, data));\n }\n \n-fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> ty::variant_info[] {\n+fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> vec[ty::variant_info] {\n     auto external_crate_id = def._0;\n     auto data = tcx.sess.get_external_crate(external_crate_id).data;\n     auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     auto item = find_item(def._1, items);\n-    let ty::variant_info[] infos = ~[];\n+    let vec[ty::variant_info] infos = [];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tcx);\n-        let ty::t[] arg_tys = ~[];\n+        let vec[ty::t] arg_tys = [];\n         alt (ty::struct(tcx, ctor_ty)) {\n             case (ty::ty_fn(_, ?args, _, _, _)) {\n-                for (ty::arg a in args) { arg_tys += ~[a.ty]; }\n+                for (ty::arg a in args) { arg_tys += [a.ty]; }\n             }\n             case (_) {\n                 // Nullary tag variant.\n \n             }\n         }\n-        infos += ~[rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n+        infos += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n     }\n     ret infos;\n }\n@@ -290,8 +290,8 @@ fn get_meta_items(&ebml::doc md) -> vec[@ast::meta_item] {\n     ret items;\n }\n \n-fn get_attributes(&ebml::doc md) -> ast::attribute[] {\n-    let ast::attribute[] attrs = ~[];\n+fn get_attributes(&ebml::doc md) -> vec[ast::attribute] {\n+    let vec[ast::attribute] attrs = [];\n     alt (ebml::maybe_get_doc(md, tag_attributes)) {\n         case (option::some(?attrs_d)) {\n             for each (ebml::doc attr_doc in\n@@ -301,9 +301,9 @@ fn get_attributes(&ebml::doc md) -> ast::attribute[] {\n                 // an attribute\n                 assert (vec::len(meta_items) == 1u);\n                 auto meta_item = meta_items.(0);\n-                attrs += ~[rec(node=rec(style=ast::attr_outer,\n-                                        value=*meta_item),\n-                               span=rec(lo=0u, hi=0u))];\n+                attrs += [rec(node=rec(style=ast::attr_outer,\n+                                       value=*meta_item),\n+                              span=rec(lo=0u, hi=0u))];\n             }\n         }\n         case (option::none) { }\n@@ -327,7 +327,7 @@ fn list_crate_attributes(&ebml::doc md, io::writer out) {\n     out.write_str(\"\\n\\n\");\n }\n \n-fn get_crate_attributes(&vec[u8] data) -> ast::attribute[] {\n+fn get_crate_attributes(&vec[u8] data) -> vec[ast::attribute] {\n     ret get_attributes(ebml::new_doc(data));\n }\n "}, {"sha": "b40a84ec30551a384fc6ef06705d66487837944f", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -65,13 +65,13 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     }\n }\n \n-fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr_def)[] {\n-    let (@ty::constr_def)[] rslt = ~[];\n+fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n+    let vec[@ty::constr_def] rslt = [];\n     alt (peek(st) as char) {\n         case (':') {\n             do  {\n                 next(st);\n-                rslt += ~[parse_constr(st, sd)];\n+                vec::push(rslt, parse_constr(st, sd));\n             } while (peek(st) as char == ';')\n         }\n         case (_) { }\n@@ -80,21 +80,21 @@ fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr_def)[] {\n }\n \n fn parse_path(@pstate st, str_def sd) -> ast::path {\n-    let ast::ident[] idents = ~[];\n+    let vec[ast::ident] idents = [];\n     fn is_last(char c) -> bool {\n         ret (c == '(' || c == ':');\n     }\n-    idents += ~[parse_ident_(st, sd, is_last)];\n+    idents += [parse_ident_(st, sd, is_last)];\n     while (true) {\n         alt (peek(st) as char) {\n             case (':') { next(st); next(st); }\n             case (?c) {\n                 if (c == '(') {\n                     ret respan(rec(lo=0u, hi=0u),\n-                               rec(idents=idents, types=~[]));\n+                               rec(idents=idents, types=[]));\n                 }\n                 else {\n-                    idents += ~[parse_ident_(st, sd, is_last)];\n+                    idents += [parse_ident_(st, sd, is_last)];\n                 }\n             }\n         }\n@@ -103,7 +103,7 @@ fn parse_path(@pstate st, str_def sd) -> ast::path {\n }\n \n fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n-    let (@ast::constr_arg)[] args = ~[];\n+    let vec[@ast::constr_arg] args = [];\n     auto sp = rec(lo=0u,hi=0u); // FIXME: use a real span\n     let ast::path pth = parse_path(st, sd);\n     let char ignore = next(st) as char;\n@@ -113,15 +113,14 @@ fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n         alt (peek(st) as char) {\n             case ('*') {\n                 st.pos += 1u;\n-                args += ~[@respan(sp, ast::carg_base)];\n+                args += [@respan(sp, ast::carg_base)];\n             }\n             case (?c) {\n                 /* how will we disambiguate between\n                  an arg index and a lit argument? */\n                 if (c >= '0' && c <= '9') {\n                     // FIXME\n-                    args += ~[@respan(sp,\n-                                      ast::carg_ident((c as uint) - 48u))];\n+                    args += [@respan(sp, ast::carg_ident((c as uint) - 48u))];\n                     ignore = next(st) as char;\n                 }\n                 else {\n@@ -170,8 +169,8 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('t') {\n             assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n-            let ty::t[] params = ~[];\n-            while (peek(st) as char != ']') { params += ~[parse_ty(st, sd)]; }\n+            let vec[ty::t] params = [];\n+            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tag(st.tcx, def, params);\n         }\n@@ -227,7 +226,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n-            let ty::method[] methods = ~[];\n+            let vec[ty::method] methods = [];\n             while (peek(st) as char != ']') {\n                 auto proto;\n                 alt (next(st) as char) {\n@@ -240,12 +239,12 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods +=\n-                    ~[rec(proto=proto,\n-                          ident=name,\n-                          inputs=func._0,\n-                          output=func._1,\n-                          cf=func._2,\n-                          constrs=func._3)];\n+                    [rec(proto=proto,\n+                         ident=name,\n+                         inputs=func._0,\n+                         output=func._1,\n+                         cf=func._2,\n+                         constrs=func._3)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);\n@@ -254,8 +253,8 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n             auto inner = parse_ty(st, sd);\n-            let ty::t[] params = ~[];\n-            while (peek(st) as char != ']') { params += ~[parse_ty(st, sd)]; }\n+            let vec[ty::t] params = [];\n+            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n             st.pos = st.pos + 1u;\n             ret ty::mk_res(st.tcx, def, inner, params);\n         }\n@@ -334,7 +333,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(ty::arg[], ty::t, ast::controlflow, (@ty::constr_def)[]) {\n+   tup(ty::arg[], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n     assert (next(st) as char == '[');\n     let ty::arg[] inputs = ~[];\n     while (peek(st) as char != ']') {"}, {"sha": "f6ea1a89719860cb5ef675268dcbc0a4ceb1cfd5", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -162,7 +162,7 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n                 case (native_abi_cdecl) { w.write_char('c'); }\n                 case (native_abi_llvm) { w.write_char('l'); }\n             }\n-            enc_ty_fn(w, cx, args, out, return, ~[]);\n+            enc_ty_fn(w, cx, args, out, return, []);\n         }\n         case (ty::ty_obj(?methods)) {\n             w.write_str(\"O[\");\n@@ -205,7 +205,7 @@ fn enc_proto(&io::writer w, proto proto) {\n     }\n }\n fn enc_ty_fn(&io::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n-             &controlflow cf, &(@ty::constr_def)[] constrs) {\n+             &controlflow cf, &vec[@ty::constr_def] constrs) {\n     w.write_char('[');\n     for (ty::arg arg in args) {\n         alt (arg.mode) {"}, {"sha": "9bab6e6e067ff9a7a4b6752038f0265a8d3c0eb1", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -18,7 +18,6 @@ import syntax::ast::respan;\n import middle::ty::constr_table;\n import syntax::visit;\n import visit::vt;\n-import std::ivec;\n import std::map::hashmap;\n import std::list;\n import std::list::list;\n@@ -139,7 +138,7 @@ fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate) ->\n     auto e =\n         @rec(crate_map=new_int_hash[ast::crate_num](),\n              def_map=new_int_hash[def](),\n-             fn_constrs = new_int_hash[ty::constr_def[]](),\n+             fn_constrs = new_int_hash[vec[ty::constr_def]](),\n              ast_map=amap,\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n@@ -417,14 +416,8 @@ fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n     if (option::is_some(new_def)) {\n         alt (option::get(new_def)) {\n             case (ast::def_fn(?pred_id, ast::pure_fn)) {\n-                // FIXME: Remove this vec->ivec conversion.\n-                let (@ast::constr_arg_general[uint])[] cag_ivec = ~[];\n-                for (@ast::constr_arg_general[uint] cag in c.node.args) {\n-                    cag_ivec += ~[cag];\n-                }\n-\n                 let ty::constr_general[uint] c_ =\n-                    rec(path=c.node.path, args=cag_ivec, id=pred_id);\n+                    rec(path=c.node.path, args=c.node.args, id=pred_id);\n                 let ty::constr_def new_constr = respan(c.span, c_);\n                 add_constr(e, id, new_constr);\n             }\n@@ -440,8 +433,8 @@ fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n fn add_constr(&@env e, node_id id, &ty::constr_def c) {\n     e.fn_constrs.insert(id,\n                         alt (e.fn_constrs.find(id)) {\n-                            case (none) { ~[c] }\n-                            case (some(?cs)) { cs + ~[c] }\n+                            case (none) { [c] }\n+                            case (some(?cs)) { cs + [c] }\n                         });\n }\n \n@@ -555,9 +548,9 @@ fn mk_unresolved_msg(&ident id, &str kind) -> str {\n }\n \n // Lookup helpers\n-fn lookup_path_strict(&env e, &scopes sc, &span sp, &ident[] idents,\n+fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n                       namespace ns) -> option::t[def] {\n-    auto n_idents = ivec::len(idents);\n+    auto n_idents = vec::len(idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n     auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n     auto i = 1u;"}, {"sha": "7647ccd23fedd1344d721d25f16c17dc1468dc55", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 76, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -879,11 +879,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_res(_, ?sub, ?tps)) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t typ in tps) { tps_ivec += ~[typ]; }\n-\n-            auto sub1 = ty::substitute_type_params(cx.tcx, tps_ivec, sub);\n+            auto sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n             ret T_struct([T_i32(), type_of_inner(cx, sp, sub1)]);\n         }\n         case (ty::ty_var(_)) {\n@@ -903,7 +899,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n \n fn type_of_tag(&@crate_ctxt cx, &span sp, &ast::def_id did, &ty::t t)\n     -> TypeRef {\n-    auto degen = std::ivec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n+    auto degen = vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n         if (degen) { ret T_i8(); }\n         else { ret T_opaque_tag(cx.tn); }\n@@ -1244,12 +1240,7 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n                                                     ty::mk_nil(ccx.tcx))]);\n             }\n             case (ty::ty_res(_, ?sub, ?tps)) {\n-                // FIXME: Remove this vec->ivec conversion.\n-                auto tps_ivec = ~[];\n-                for (ty::t typ in tps) { tps_ivec += ~[typ]; }\n-\n-                auto sub1 = ty::substitute_type_params(ccx.tcx, tps_ivec,\n-                                                       sub);\n+                auto sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n                 ret ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx),\n                                               simplify_type(ccx, sub1)]);\n             }\n@@ -1268,35 +1259,36 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n                                  \"static_size_of_tag()\");\n     }\n     if (cx.tag_sizes.contains_key(t)) { ret cx.tag_sizes.get(t); }\n+    auto tid;\n+    let vec[ty::t] subtys;\n     alt (ty::struct(cx.tcx, t)) {\n-        case (ty::ty_tag(?tid, ?subtys)) {\n-            // Compute max(variant sizes).\n-\n-            auto max_size = 0u;\n-            auto variants = ty::tag_variants(cx.tcx, tid);\n-            for (ty::variant_info variant in variants) {\n-                // TODO: Remove this vec->ivec conversion.\n-                auto args = ~[];\n-                for (ty::t typ in variant.args) { args += ~[typ]; }\n-\n-                auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, args));\n-                // Perform any type parameter substitutions.\n-\n-                tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n-                // Here we possibly do a recursive call.\n-\n-                auto this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n-                if (max_size < this_size) { max_size = this_size; }\n-            }\n-            cx.tag_sizes.insert(t, max_size);\n-            ret max_size;\n-        }\n+        case (ty::ty_tag(?tid_, ?subtys_)) { tid = tid_; subtys = subtys_; }\n         case (_) {\n             cx.tcx.sess.span_fatal(sp,\n                                  \"non-tag passed to \" +\n                                      \"static_size_of_tag()\");\n         }\n     }\n+    // Compute max(variant sizes).\n+\n+    auto max_size = 0u;\n+    auto variants = ty::tag_variants(cx.tcx, tid);\n+    for (ty::variant_info variant in variants) {\n+        // TODO: Remove this vec->ivec conversion.\n+        auto args = ~[];\n+        for (ty::t typ in variant.args) { args += ~[typ]; }\n+\n+        auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, args));\n+        // Perform any type parameter substitutions.\n+\n+        tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n+        // Here we possibly do a recursive call.\n+\n+        auto this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n+        if (max_size < this_size) { max_size = this_size; }\n+    }\n+    cx.tag_sizes.insert(t, max_size);\n+    ret max_size;\n }\n \n fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n@@ -1351,7 +1343,7 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n             for (ty::variant_info variant in variants) {\n                 // Perform type substitution on the raw argument types.\n \n-                let ty::t[] raw_tys = variant.args;\n+                let vec[ty::t] raw_tys = variant.args;\n                 let vec[ty::t] tys = [];\n                 for (ty::t raw_ty in raw_tys) {\n                     auto t =\n@@ -1366,7 +1358,7 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n                 bcx.build.Store(umax(bcx, this_size, old_max_size), max_size);\n             }\n             auto max_size_val = bcx.build.Load(max_size);\n-            auto total_size = if (std::ivec::len(variants) != 1u) {\n+            auto total_size = if (vec::len(variants) != 1u) {\n                 bcx.build.Add(max_size_val, llsize_of(T_int()))\n             } else { max_size_val };\n             ret rslt(bcx, total_size);\n@@ -1524,7 +1516,7 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t, ValueRef base, &vec[int] ixs) ->\n // appropriate. @llblobptr is the data part of a tag value; its actual type is\n // meaningless, as it will be cast away.\n fn GEP_tag(@block_ctxt cx, ValueRef llblobptr, &ast::def_id tag_id,\n-           &ast::def_id variant_id, &ty::t[] ty_substs, int ix) -> result {\n+           &ast::def_id variant_id, &vec[ty::t] ty_substs, int ix) -> result {\n     auto variant =\n         ty::tag_variant_with_id(cx.fcx.lcx.ccx.tcx, tag_id, variant_id);\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n@@ -2145,7 +2137,7 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n }\n \n fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n-                  ty::t inner_t, &ty::t[] tps) -> result {\n+                  ty::t inner_t, &vec[ty::t] tps) -> result {\n     auto ccx = cx.fcx.lcx.ccx;\n     auto inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n     auto tup_ty = ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx), inner_t_s]);\n@@ -2653,9 +2645,9 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n     }\n \n     fn iter_variant(@block_ctxt cx, ValueRef a_tup, ValueRef b_tup,\n-                    &ty::variant_info variant, &ty::t[] tps,\n+                    &ty::variant_info variant, &vec[ty::t] tps,\n                     &ast::def_id tid, &val_pair_and_ty_fn f) -> result {\n-        if (std::ivec::len[ty::t](variant.args) == 0u) {\n+        if (vec::len[ty::t](variant.args) == 0u) {\n             ret rslt(cx, C_nil());\n         }\n         auto fn_ty = variant.ctor_ty;\n@@ -2664,10 +2656,12 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             case (ty::ty_fn(_, ?args, _, _, _)) {\n                 auto j = 0;\n                 for (ty::arg a in args) {\n-                    auto rslt = GEP_tag(cx, a_tup, tid, variant.id, tps, j);\n+                    auto rslt = GEP_tag(cx, a_tup, tid,\n+                                        variant.id, tps, j);\n                     auto llfldp_a = rslt.val;\n                     cx = rslt.bcx;\n-                    rslt = GEP_tag(cx, b_tup, tid, variant.id, tps, j);\n+                    rslt = GEP_tag(cx, b_tup, tid,\n+                                   variant.id, tps, j);\n                     auto llfldp_b = rslt.val;\n                     cx = rslt.bcx;\n                     auto ty_subst =\n@@ -2713,12 +2707,8 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             }\n         }\n         case (ty::ty_res(_, ?inner, ?tps)) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n             auto inner1 = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n-                                                     tps_ivec, inner);\n+                                                     tps, inner);\n             r = GEP_tup_like(r.bcx, t, av, [0, 1]);\n             auto llfld_a = r.val;\n             r = GEP_tup_like(r.bcx, t, bv, [0, 1]);\n@@ -2728,7 +2718,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, tid);\n-            auto n_variants = std::ivec::len(variants);\n+            auto n_variants = vec::len(variants);\n \n             // Cast the tags to types we can GEP into.\n             if (n_variants == 1u) {\n@@ -4147,18 +4137,14 @@ fn autoderef_lval(&@block_ctxt cx, ValueRef v, &ty::t t, bool is_lval)\n                 } else { v1 = body; }\n             }\n             case (ty::ty_res(?did, ?inner, ?tps)) {\n-                // FIXME: Remove this vec->ivec conversion.\n-                auto tps_ivec = ~[];\n-                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n                 if (is_lval) { v1 = cx.build.Load(v1); }\n-                t1 = ty::substitute_type_params(ccx.tcx, tps_ivec, inner);\n+                t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n                 v1 = cx.build.GEP(v1, [C_int(0), C_int(1)]);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = ty::tag_variants(ccx.tcx, did);\n-                if (std::ivec::len(variants) != 1u ||\n-                    std::ivec::len(variants.(0).args) != 1u) {\n+                if (vec::len(variants) != 1u ||\n+                    vec::len(variants.(0).args) != 1u) {\n                     break;\n                 }\n                 if (is_lval) { v1 = cx.build.Load(v1); }\n@@ -4698,7 +4684,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n             auto llblobptr = llval;\n \n-            if (std::ivec::len(variants) == 1u) {\n+            if (vec::len(variants) == 1u) {\n                 cx.build.Br(matched_cx.llbb);\n             } else {\n                 auto lltagptr =\n@@ -4726,19 +4712,14 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                         matched_cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n                 }\n             }\n-\n             auto ty_params = ty::node_id_to_type_params\n                 (cx.fcx.lcx.ccx.tcx, pat.id);\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t tp in ty_params) { tps_ivec += ~[tp]; }\n-\n             if (vec::len(subpats) > 0u) {\n                 auto i = 0;\n                 for (@ast::pat subpat in subpats) {\n                     auto rslt =\n                         GEP_tag(matched_cx, llblobptr, vdef._0, vdef._1,\n-                                tps_ivec, i);\n+                                ty_params, i);\n                     auto llsubvalptr = rslt.val;\n                     matched_cx = rslt.bcx;\n                     auto llsubval =\n@@ -4787,25 +4768,19 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                       \"trans_pat_binding: internal error, unbound var\"); }\n             }\n             auto llblobptr = llval;\n-            if (std::ivec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))\n-                    != 1u) {\n+            if (vec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))!=1u) {\n                 auto lltagptr = cx.build.PointerCast\n                     (llval, T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n                 llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n             }\n-\n             auto ty_param_substs =\n                 ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, pat.id);\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t tp in ty_param_substs) { tps_ivec += ~[tp]; }\n-\n             auto this_cx = cx;\n             auto i = 0;\n             for (@ast::pat subpat in subpats) {\n                 auto rslt =\n-                    GEP_tag(this_cx, llblobptr, vdef._0, vdef._1, tps_ivec,\n-                            i);\n+                    GEP_tag(this_cx, llblobptr, vdef._0, vdef._1,\n+                            ty_param_substs, i);\n                 this_cx = rslt.bcx;\n                 auto subpat_res =\n                     trans_pat_binding(this_cx, subpat, rslt.val, true);\n@@ -4890,7 +4865,7 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n     auto tys = ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n-    if (std::ivec::len[ty::t](tys) != 0u) {\n+    if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = [];\n         let vec[option::t[@tydesc_info]] tis = [];\n@@ -4986,8 +4961,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n                     auto bcx = alloc_result.bcx;\n                     auto lltagptr = bcx.build.PointerCast\n                         (lltagblob, T_ptr(lltagty));\n-                    if (std::ivec::len(ty::tag_variants(ccx.tcx, tid))\n-                            != 1u) {\n+                    if (vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u) {\n                         auto lldiscrim_gv =\n                             lookup_discriminant(bcx.fcx.lcx, tid, vid);\n                         auto lldiscrim = bcx.build.Load(lldiscrim_gv);\n@@ -8504,10 +8478,10 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n                               ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n                               fn_args, ty_params);\n-    let ty::t[] ty_param_substs = ~[];\n+    let vec[ty::t] ty_param_substs = [];\n     i = 0u;\n     for (ast::ty_param tp in ty_params) {\n-        ty_param_substs += ~[ty::mk_param(cx.ccx.tcx, i)];\n+        ty_param_substs += [ty::mk_param(cx.ccx.tcx, i)];\n         i += 1u;\n     }\n     auto arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);"}, {"sha": "aa9267656e4517f41537038c02391b1d7a0491b9", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,4 +1,5 @@\n \n+import std::vec;\n import tritv::*;\n \n type precond = t;"}, {"sha": "6f3b29716ecd491bb9d296910feb653ecd8fece3", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -24,36 +24,36 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(&@expr e, @mutable node_id[] rs) {\n-    *rs += ~[e.id];\n+fn collect_ids_expr(&@expr e, @mutable vec[node_id] rs) {\n+    vec::push(*rs, e.id);\n }\n \n-fn collect_ids_block(&block b, @mutable node_id[] rs) {\n-    *rs += ~[b.node.id];\n+fn collect_ids_block(&block b, @mutable vec[node_id] rs) {\n+    vec::push(*rs, b.node.id);\n }\n \n-fn collect_ids_stmt(&@stmt s, @mutable node_id[] rs) {\n+fn collect_ids_stmt(&@stmt s, @mutable vec[node_id] rs) {\n     alt (s.node) {\n         case (stmt_decl(_, ?id)) {\n             log \"node_id \" + int::str(id);\n             log_stmt(*s);\n-            *rs += ~[id];\n+            vec::push(*rs, id);\n         }\n         case (stmt_expr(_, ?id)) {\n             log \"node_id \" + int::str(id);\n             log_stmt(*s);\n-            *rs += ~[id];\n+            vec::push(*rs, id);\n         }\n         case (_) { }\n     }\n }\n \n-fn collect_ids_local(&@local l, @mutable node_id[] rs) {\n-    *rs += ~[l.node.id];\n+fn collect_ids_local(&@local l, @mutable vec[node_id] rs) {\n+    vec::push(*rs, l.node.id);\n }\n \n fn node_ids_in_fn(&_fn f, &vec[ty_param] tps, &span sp, &fn_ident i,\n-                  node_id id, @mutable node_id[] rs) {\n+                  node_id id, @mutable vec[node_id] rs) {\n     auto collect_ids = walk::default_visitor();\n     collect_ids =\n         rec(visit_expr_pre=bind collect_ids_expr(_, rs),\n@@ -63,7 +63,7 @@ fn node_ids_in_fn(&_fn f, &vec[ty_param] tps, &span sp, &fn_ident i,\n     walk::walk_fn(collect_ids, f, tps, sp, i, id);\n }\n \n-fn init_vecs(&crate_ctxt ccx, &node_id[] node_ids, uint len) {\n+fn init_vecs(&crate_ctxt ccx, &vec[node_id] node_ids, uint len) {\n     for (node_id i in node_ids) {\n         log int::str(i) + \" |-> \" + uint::str(len);\n         add_node(ccx, i, empty_ann(len));\n@@ -72,7 +72,7 @@ fn init_vecs(&crate_ctxt ccx, &node_id[] node_ids, uint len) {\n \n fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f, &vec[ty_param] tps,\n             &span sp, &fn_ident i, node_id id) {\n-    let @mutable node_id[] node_ids = @mutable ~[];\n+    let @mutable vec[node_id] node_ids = @mutable [];\n     node_ids_in_fn(f, tps, sp, i, id, node_ids);\n     auto node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);"}, {"sha": "0bc1ceb39517117f6628e7e1450a36575a3f8f2b", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 50, "deletions": 67, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,5 +1,8 @@\n-import std::ivec;\n import std::str;\n+import std::vec;\n+import std::vec::len;\n+import std::vec::grow;\n+import std::vec::pop;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -45,7 +48,7 @@ fn def_id_to_str(def_id d) -> str {\n     ret int::str(d._0) + \",\" + int::str(d._1);\n }\n \n-fn comma_str(&(@constr_arg_use)[] args) -> str {\n+fn comma_str(vec[@constr_arg_use] args) -> str {\n     auto rslt = \"\";\n     auto comma = false;\n     for (@constr_arg_use a in args) {\n@@ -104,17 +107,17 @@ fn first_difference_string(&fn_ctxt fcx, &tritv::t expected, &tritv::t actual)\n \n fn log_tritv_err(fn_ctxt fcx, tritv::t v) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(&uint[] v) -> str {\n+fn tos(vec[uint] v) -> str {\n     auto rslt = \"\";\n     for (uint i in v) { if (i == 0u) { rslt += \"0\"; } \n         else if (i == 1u) { rslt += \"1\"; }\n         else { rslt += \"?\"; } }\n     ret rslt;\n }\n \n-fn log_cond(&uint[] v) { log tos(v); }\n+fn log_cond(vec[uint] v) { log tos(v); }\n \n-fn log_cond_err(&uint[] v) { log_err tos(v); }\n+fn log_cond_err(vec[uint] v) { log_err tos(v); }\n \n fn log_pp(&pre_and_post pp) {\n     auto p1 = tritv::to_vec(pp.precondition);\n@@ -154,10 +157,10 @@ fn log_states_err(&pre_and_post_state pp) {\n \n fn print_ident(&ident i) { log \" \" + i + \" \"; }\n \n-fn print_idents(&mutable ident[] idents) {\n-    if (ivec::len[ident](idents) == 0u) { ret; }\n-    log \"an ident: \" + ivec::pop[ident](idents);\n-    print_idents(idents);\n+fn print_idents(vec[ident] idents) {\n+    if (len[ident](idents) == 0u) {\n+        ret;\n+    } else { log \"an ident: \" + pop[ident](idents); print_idents(idents); }\n }\n \n \n@@ -191,21 +194,18 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n-type pred_desc_ = rec((@constr_arg_use)[] args, uint bit_num);\n+type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n \n type pred_desc = spanned[pred_desc_];\n \n type constr_arg_use = constr_arg_general[tup(ident, def_id)];\n \n tag constraint {\n     cinit(uint, span, ident);\n-    cpred(path, @mutable pred_desc[]);\n+    cpred(path, @mutable vec[pred_desc]);\n }\n \n-tag constr__ {\n-    ninit(ident);\n-    npred(path, (@constr_arg_use)[]);\n-}\n+tag constr__ { ninit(ident); npred(path, vec[@constr_arg_use]); }\n \n type constr_ = rec(node_id id, constr__ c);\n \n@@ -223,11 +223,11 @@ type fn_info = rec(constr_map constrs,\n                     used*/\n                    // Doesn't seem to work without the @ --\n                    // bug?\n-                   @mutable node_id[] used_vars);\n+                   @mutable vec[node_id] used_vars);\n \n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mutable ts_ann[mutable];\n+type node_ann_table = @mutable vec[mutable ts_ann];\n \n \n /* mapping from function name to fn_info map */\n@@ -243,15 +243,15 @@ fn get_fn_info(&crate_ctxt ccx, node_id id) -> fn_info {\n }\n \n fn add_node(&crate_ctxt ccx, node_id i, &ts_ann a) {\n-    auto sz = ivec::len(*ccx.node_anns);\n+    auto sz = len(*ccx.node_anns);\n     if (sz <= i as uint) {\n-        ivec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n+        grow(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n     }\n     ccx.node_anns.(i) = a;\n }\n \n fn get_ts_ann(&crate_ctxt ccx, node_id i) -> option::t[ts_ann] {\n-    if (i as uint < ivec::len(*ccx.node_anns)) {\n+    if (i as uint < len(*ccx.node_anns)) {\n         ret some[ts_ann](ccx.node_anns.(i));\n     } else { ret none[ts_ann]; }\n }\n@@ -439,7 +439,7 @@ fn pure_exp(&crate_ctxt ccx, node_id id, &prestate p) -> bool {\n fn num_constraints(fn_info m) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n-    let ts_ann[mutable] na = ~[mutable];\n+    let vec[mutable ts_ann] na = vec::empty_mut();\n     ret rec(tcx=cx, node_anns=@mutable na, fm=@new_int_hash[fn_info]());\n }\n \n@@ -453,10 +453,10 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n-fn constraints_expr(&ty::ctxt cx, @expr e) -> (@ty::constr_def)[] {\n+fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ty::constr_def] {\n     alt (ty::struct(cx, ty::node_id_to_type(cx, e.id))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n-        case (_) { ret ~[]; }\n+        case (_) { ret []; }\n     }\n }\n \n@@ -474,18 +474,19 @@ fn node_id_to_def(&crate_ctxt ccx, node_id id) -> option::t[def] {\n     ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(node_id id, &constraint c) -> norm_constraint[] {\n+fn norm_a_constraint(node_id id, &constraint c) -> vec[norm_constraint] {\n     alt (c) {\n         case (cinit(?n, ?sp, ?i)) {\n-            ret ~[rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n+            ret [rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n         }\n         case (cpred(?p, ?descs)) {\n-            let norm_constraint[] rslt = ~[];\n+            let vec[norm_constraint] rslt = [];\n             for (pred_desc pd in *descs) {\n-                rslt += ~[rec(bit_num=pd.node.bit_num,\n+                vec::push(rslt,\n+                          rec(bit_num=pd.node.bit_num,\n                               c=respan(pd.span,\n                                        rec(id=id,\n-                                           c=npred(p, pd.node.args))))];\n+                                           c=npred(p, pd.node.args)))));\n             }\n             ret rslt;\n         }\n@@ -495,15 +496,15 @@ fn norm_a_constraint(node_id id, &constraint c) -> norm_constraint[] {\n \n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n-fn constraints(&fn_ctxt fcx) -> norm_constraint[] {\n-    let norm_constraint[] rslt = ~[];\n+fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n+    let vec[norm_constraint] rslt = [];\n     for each (@tup(node_id, constraint) p in fcx.enclosing.constrs.items()) {\n         rslt += norm_a_constraint(p._0, p._1);\n     }\n     ret rslt;\n }\n \n-fn match_args(&fn_ctxt fcx, &pred_desc[] occs, &(@constr_arg_use)[] occ) ->\n+fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n    uint {\n     log \"match_args: looking at \" +\n         constr_args_to_str(std::util::fst[ident, def_id], occ);\n@@ -512,13 +513,7 @@ fn match_args(&fn_ctxt fcx, &pred_desc[] occs, &(@constr_arg_use)[] occ) ->\n         fn eq(&tup(ident, def_id) p, &tup(ident, def_id) q) -> bool {\n             ret p._1 == q._1;\n         }\n-\n-        // FIXME: Remove this vec->ivec conversion.\n-        let (@constr_arg_use)[] cau_ivec = ~[];\n-        for (@constr_arg_use cau in pd.node.args) {\n-            cau_ivec += ~[cau];\n-        }\n-        if (ty::args_eq(eq, cau_ivec, occ)) { ret pd.node.bit_num; }\n+        if (ty::args_eq(eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n     }\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n@@ -563,10 +558,10 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n     }\n }\n \n-fn exprs_to_constr_args(ty::ctxt tcx, &(@expr)[] args)\n-        -> (@constr_arg_use)[] {\n+fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) ->\n+   vec[@constr_arg_use] {\n     auto f = bind expr_to_constr_arg(tcx, _);\n-    ret ivec::map(f, args);\n+    ret vec::map(f, args);\n }\n \n fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n@@ -577,14 +572,10 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n              expr_call(?operator, ?args)) {\n             alt (operator.node) {\n                 case (expr_path(?p)) {\n-                    // FIXME: Remove this vec->ivec conversion.\n-                    auto args_ivec = ~[];\n-                    for (@expr e in args) { args_ivec += ~[e]; }\n-\n                     ret respan(e.span,\n                                rec(id=node_id_for_constr(tcx, operator.id),\n-                                   c=npred(p, exprs_to_constr_args(tcx,\n-                                        args_ivec))));\n+                                   c=npred(p,\n+                                           exprs_to_constr_args(tcx, args))));\n                 }\n                 case (_) {\n                     tcx.sess.span_fatal(operator.span,\n@@ -602,30 +593,24 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n }\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n-    // FIXME: Remove this vec->ivec conversion.\n-    let (@constr_arg_use)[] cau_ivec = ~[];\n-    for (@constr_arg_use cau in p.node.args) {\n-        cau_ivec += ~[cau];\n-    }\n-\n     ret \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(std::util::fst[ident, def_id], cau_ivec) + \">\";\n+        constr_args_to_str(std::util::fst[ident, def_id], p.node.args) + \">\";\n }\n \n-fn substitute_constr_args(&ty::ctxt cx, &(@expr)[] actuals,\n+fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n                           &@ty::constr_def c) -> constr__ {\n-    let (@constr_arg_use)[] rslt = ~[];\n+    let vec[@constr_arg_use] rslt = [];\n     for (@constr_arg a in c.node.args) {\n-        rslt += ~[substitute_arg(cx, actuals, a)];\n+        rslt += [substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, rslt);\n }\n \n-type subst = tup(arg, @expr)[];\n+type subst = vec[tup(arg, @expr)];\n \n-fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n+fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @constr_arg a) ->\n    @constr_arg_use {\n-    auto num_actuals = ivec::len(actuals);\n+    auto num_actuals = vec::len(actuals);\n     alt (a.node) {\n         case (carg_ident(?i)) {\n             if (i < num_actuals) {\n@@ -641,7 +626,7 @@ fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n }\n \n fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n-    alt (ivec::last(p.node.idents)) {\n+    alt (vec::last(p.node.idents)) {\n         case (none) { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n         case (some(?i)) { ret i; }\n     }\n@@ -781,28 +766,26 @@ fn non_init_constraint_mentions(&fn_ctxt fcx, &norm_constraint c,\n }\n \n \n-fn args_mention(&(@constr_arg_use)[] args, &def_id v) -> bool {\n+fn args_mention(&vec[@constr_arg_use] args, &def_id v) -> bool {\n     fn mentions(&def_id v, &@constr_arg_use a) -> bool {\n         alt (a.node) {\n             case (carg_ident(?p1)) { p1._1 == v }\n             case (_)               { false }\n         }\n     }\n-    ret ivec::any[@constr_arg_use](bind mentions(v,_), args);\n+    ret util::common::any[@constr_arg_use](bind mentions(v,_), args);\n }\n \n fn use_var(&fn_ctxt fcx, &node_id v) {\n-    *fcx.enclosing.used_vars += ~[v];\n+    vec::push(*fcx.enclosing.used_vars, v);\n }\n \n-// FIXME: This should be a function in std::ivec::.\n-fn vec_contains(&@mutable (node_id[]) v, &node_id i) -> bool {\n+fn vec_contains(&@mutable vec[node_id] v, &node_id i) -> bool {\n     for (node_id d in *v) {\n         if (d == i) { ret true; }\n     }\n     ret false;\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "3dea3cef30dccd55d549d75edc6ffcb822cbc8b5", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,9 +1,10 @@\n \n import syntax::ast::*;\n import syntax::walk;\n-import std::ivec;\n import std::option::*;\n-import aux::constr_arg_use;\n+import std::vec;\n+import std::vec::len;\n+import std::vec::slice;\n import aux::local_node_id_to_def;\n import aux::fn_ctxt;\n import aux::fn_info;\n@@ -62,15 +63,7 @@ fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n         }\n         case (npred(_, ?args)) {\n             alt (rslt) {\n-                case (cpred(_, ?descs)) {\n-                    // FIXME: Remove this vec->ivec conversion.\n-                    let (@constr_arg_use)[] cau_ivec = ~[];\n-                    for (@constr_arg_use cau in args) {\n-                        cau_ivec += ~[cau];\n-                    }\n-                    auto d = *descs;\n-                    ret match_args(fcx, d, cau_ivec);\n-                }\n+                case (cpred(_, ?descs)) { ret match_args(fcx, *descs, args); }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n                                              + \" found an init constraint\");\n@@ -105,11 +98,11 @@ fn seq_tritv(&postcond p, &postcond q) {\n     }\n }\n \n-fn seq_postconds(&fn_ctxt fcx, &postcond[] ps) -> postcond {\n-    auto sz = ivec::len(ps);\n+fn seq_postconds(&fn_ctxt fcx, &vec[postcond] ps) -> postcond {\n+    auto sz = vec::len(ps);\n     if (sz >= 1u) {\n         auto prev = tritv_clone(ps.(0));\n-        for (postcond p in ivec::slice(ps, 1u, sz)) {\n+        for (postcond p in slice(ps, 1u, sz)) {\n             seq_tritv(prev, p);\n         }\n         ret prev;\n@@ -123,14 +116,14 @@ fn seq_postconds(&fn_ctxt fcx, &postcond[] ps) -> postcond {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(&fn_ctxt fcx, &pre_and_post[] pps) -> precond {\n-    let uint sz = ivec::len(pps);\n+fn seq_preconds(&fn_ctxt fcx, &vec[pre_and_post] pps) -> precond {\n+    let uint sz = len(pps);\n     let uint num_vars = num_constraints(fcx.enclosing);\n \n-    fn seq_preconds_go(&fn_ctxt fcx, &pre_and_post[] pps,\n+    fn seq_preconds_go(&fn_ctxt fcx, &vec[pre_and_post] pps,\n                        &pre_and_post first)\n         -> precond {\n-        let uint sz = ivec::len(pps);\n+        let uint sz = len(pps);\n         if (sz >= 1u) {\n             auto second = pps.(0);\n             assert (pps_len(second) == num_constraints(fcx.enclosing));\n@@ -140,7 +133,7 @@ fn seq_preconds(&fn_ctxt fcx, &pre_and_post[] pps) -> precond {\n             union(next_first, second_pre);\n             auto next_first_post = clone(first.postcondition);\n             seq_tritv(next_first_post, second.postcondition); \n-            ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz),\n+            ret seq_preconds_go(fcx, slice(pps, 1u, sz), \n                                 @rec(precondition=next_first,\n                                      postcondition=next_first_post));\n         }\n@@ -152,7 +145,7 @@ fn seq_preconds(&fn_ctxt fcx, &pre_and_post[] pps) -> precond {\n     if (sz >= 1u) {\n         auto first = pps.(0);\n         assert (pps_len(first) == num_vars);\n-        ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz), first);\n+        ret seq_preconds_go(fcx, slice(pps, 1u, sz), first);\n     } else { ret true_precond(num_vars); }\n }\n \n@@ -230,7 +223,7 @@ fn kill_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n     alt (e.node) {\n         case (expr_path(?p)) {\n-            alt (ivec::last(p.node.idents)) {\n+            alt (vec::last(p.node.idents)) {\n                 case (some(?i)) {\n                     alt (local_node_id_to_def(fcx, e.id)) {\n                         case (some(def_local(?d_id))) {"}, {"sha": "084a11aa5fd48f6fdacd59f4c58e44d76804c56f", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -33,6 +33,12 @@ import tstate::ann::prestate;\n import tstate::ann::implies;\n import tstate::ann::ann_precond;\n import tstate::ann::ann_prestate;\n+import std::vec::map;\n+import std::vec;\n+import std::vec::slice;\n+import std::vec::unzip;\n+import std::vec::plus_option;\n+import std::vec::cat_options;\n import std::option;\n import std::option::t;\n import std::option::some;"}, {"sha": "764c66e52a06320446264f874fe4b9f28c5221af", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,6 +1,6 @@\n \n-import std::ivec;\n import std::vec;\n+import std::vec::plus_option;\n import syntax::ast::*;\n import util::ppaux::fn_ident_to_string;\n import std::option::*;\n@@ -26,36 +26,32 @@ import util::common::new_def_hash;\n import syntax::codemap::span;\n import syntax::ast::respan;\n \n-type ctxt = rec(@mutable (aux::constr[]) cs, ty::ctxt tcx);\n+type ctxt = rec(@mutable vec[aux::constr] cs, ty::ctxt tcx);\n \n fn collect_local(&@local loc, &ctxt cx, &visit::vt[ctxt] v) {\n     log \"collect_local: pushing \" + loc.node.ident;\n-    *cx.cs += ~[respan(loc.span, rec(id=loc.node.id,\n-                                     c=ninit(loc.node.ident)))];\n+    vec::push(*cx.cs,\n+              respan(loc.span, rec(id=loc.node.id, c=ninit(loc.node.ident))));\n     visit::visit_local(loc, cx, v);\n }\n \n fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n     alt (e.node) {\n         case (expr_check(_, ?ch)) {\n-            *cx.cs += ~[expr_to_constr(cx.tcx, ch)];\n+            vec::push(*cx.cs, expr_to_constr(cx.tcx, ch));\n         }\n         case (expr_if_check(?ex, _, _)) {\n-            *cx.cs += ~[expr_to_constr(cx.tcx, ex)];\n+            vec::push(*cx.cs, expr_to_constr(cx.tcx, ex));\n         }\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n         case (expr_call(?operator, ?operands)) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto operands_ivec = ~[];\n-            for (@expr opd in operands) { operands_ivec += ~[opd]; }\n-\n             for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n                 let aux::constr ct = respan(c.span,\n                       rec(id=c.node.id._1,\n                           c=aux::substitute_constr_args(cx.tcx,\n-                                                        operands_ivec, c)));\n-                *cx.cs += ~[ct];\n+                                                        operands, c)));\n+                vec::push(*cx.cs, ct);\n             }\n         }\n         case (_) { }\n@@ -71,7 +67,7 @@ fn do_nothing(&_fn f, &vec[ty_param] tp, &span sp, &fn_ident i,\n fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ty_param] tps,\n                &span sp, &fn_ident i, node_id id)\n     -> ctxt {\n-    let ctxt cx = rec(cs=@mutable ~[], tcx=tcx);\n+    let ctxt cx = rec(cs=@mutable vec::alloc(0u), tcx=tcx);\n     auto visitor = visit::default_visitor[ctxt]();\n \n     visitor =\n@@ -97,17 +93,18 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n                                              \" as a variable and a pred\");\n                         }\n                         case (cpred(_, ?pds)) {\n-                            *pds += ~[respan(c.span,\n-                                             rec(args=args, bit_num=next))];\n+                            vec::push(*pds,\n+                                      respan(c.span,\n+                                             rec(args=args, bit_num=next)));\n                         }\n                     }\n                 }\n                 case (none) {\n                     tbl.insert(c.node.id,\n                                cpred(p,\n-                                     @mutable ~[respan(c.span,\n-                                                       rec(args=args,\n-                                                           bit_num=next))]));\n+                                     @mutable [respan(c.span,\n+                                                      rec(args=args,\n+                                                          bit_num=next))]));\n                 }\n             }\n         }\n@@ -137,10 +134,10 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &vec[ty_param] tp,\n     auto name = fn_ident_to_string(id, f_name);\n     add_constraint(cx.tcx, respan(f_sp, rec(id=id, c=ninit(name))), next,\n                    res_map);\n-    let @mutable node_id[] v = @mutable ~[];\n+    let @mutable vec[node_id] v = @mutable [];\n     auto rslt =\n         rec(constrs=res_map,\n-            num_constraints=ivec::len(*cx.cs) + 1u,\n+            num_constraints=vec::len(*cx.cs) + 1u,\n             cf=f.decl.cf,\n             used_vars=v);\n     ccx.fm.insert(id, rslt);"}, {"sha": "d183ef28a73eca3418294d4eaa5f4113b2e3a6d6", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,5 +1,4 @@\n \n-import std::ivec;\n import std::vec;\n import std::vec::plus_option;\n import std::option;\n@@ -111,7 +110,7 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n     alt (i.node) {\n         case (item_const(_, ?e)) {\n             // make a fake fcx\n-            let @mutable node_id[] v = @mutable ~[];\n+            let @mutable vec[node_id] v = @mutable [];\n             auto fake_fcx =\n                 rec(enclosing=rec(constrs=@new_int_hash[constraint](),\n                                   num_constraints=0u,\n@@ -164,13 +163,9 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, node_id id) {\n     }\n     auto g = bind get_pp(fcx.ccx, _);\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n-\n-    // TODO: Remove this vec->ivec conversion.\n-    auto pps_ivec = ~[];\n-    for (pre_and_post pp in pps) { pps_ivec += ~[pp]; }\n-\n-    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps_ivec),\n-                     seq_postconds(fcx, ivec::map(get_post, pps_ivec)));\n+    auto h = get_post;\n+    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n+                     seq_postconds(fcx, vec::map(h, pps)));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n@@ -184,8 +179,10 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n     // so we pretend they're used\n     use_var(fcx, l.node.id);\n \n-    auto loop_precond = seq_preconds(fcx, ~[expr_pp(fcx.ccx, index),\n-                                            block_pp(fcx.ccx, body)]);\n+    auto loop_precond =\n+        seq_preconds(fcx,\n+                     [expr_pp(fcx.ccx, index),\n+                      block_pp(fcx.ccx, body)]);\n     auto loop_postcond = intersect_states(expr_postcond(fcx.ccx, index),\n                                           block_postcond(fcx.ccx, body));\n     copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n@@ -208,8 +205,10 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 case (_) {}\n             }\n \n-            auto precond_res = seq_preconds(fcx,\n-                ~[expr_pp(fcx.ccx, antec), block_pp(fcx.ccx, conseq)]);\n+            auto precond_res =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              block_pp(fcx.ccx, conseq)]);\n             set_pre_and_post(fcx.ccx, id, precond_res,\n                              expr_poststate(fcx.ccx, antec));\n         }\n@@ -220,11 +219,13 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n               is *not* true in the alternative\n              */\n             find_pre_post_expr(fcx, altern);\n-            auto precond_false_case = seq_preconds(fcx,\n-                ~[expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n-            auto postcond_false_case = seq_postconds(fcx,\n-                ~[expr_postcond(fcx.ccx, antec),\n-                  expr_postcond(fcx.ccx, altern)]);\n+            auto precond_false_case =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              expr_pp(fcx.ccx, altern)]);\n+            auto postcond_false_case =\n+                seq_postconds(fcx, [expr_postcond(fcx.ccx, antec),\n+                                    expr_postcond(fcx.ccx, altern)]);\n \n             /* Be sure to set the bit for the check condition here,\n              so that it's *not* set in the alternative. */\n@@ -235,14 +236,17 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 }\n                 case (_) {}\n             }\n-            auto precond_true_case = seq_preconds(fcx,\n-                ~[expr_pp(fcx.ccx, antec), block_pp(fcx.ccx, conseq)]);\n-            auto postcond_true_case = seq_postconds(fcx,\n-                ~[expr_postcond(fcx.ccx, antec),\n-                  block_postcond(fcx.ccx, conseq)]);\n-\n-            auto precond_res = seq_postconds(fcx, ~[precond_true_case,\n-                                                    precond_false_case]);\n+            auto precond_true_case =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              block_pp(fcx.ccx, conseq)]);\n+            auto postcond_true_case =\n+                seq_postconds(fcx, [expr_postcond(fcx.ccx, antec),\n+                                    block_postcond(fcx.ccx, conseq)]);\n+\n+            auto precond_res =\n+                seq_postconds(fcx, [precond_true_case,\n+                                    precond_false_case]);\n             auto postcond_res =\n                 intersect_states(postcond_true_case, postcond_false_case);\n             set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n@@ -282,11 +286,6 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         case (expr_call(?operator, ?operands)) {\n             auto args = vec::clone(operands);\n             vec::push(args, operator);\n-\n-            // TODO: Remove this vec->ivec conversion.\n-            auto operands_ivec = ~[];\n-            for (@expr e in operands) { operands_ivec += ~[e]; }\n-\n             find_pre_post_exprs(fcx, args, e.id);\n             /* see if the call has any constraints on its type */\n             for (@ty::constr_def c in constraints_expr(fcx.ccx.tcx, operator))\n@@ -295,8 +294,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                         bit_num(fcx,\n                                 rec(id=c.node.id._1,\n                                     c=substitute_constr_args(fcx.ccx.tcx,\n-                                                             operands_ivec,\n-                                                             c)));\n+                                                             operands, c)));\n                     require(i, expr_pp(fcx.ccx, e));\n                 }\n \n@@ -442,7 +440,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 find_pre_post_expr(fcx, l);\n                 find_pre_post_expr(fcx, r);\n                 auto overall_pre = seq_preconds(fcx,\n-                   ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n+                   [expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n                 set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n                                  overall_pre);\n                 set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n@@ -467,27 +465,29 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_expr(fcx, test);\n             find_pre_post_block(fcx, body);\n             set_pre_and_post(fcx.ccx, e.id,\n-                             seq_preconds(fcx, ~[expr_pp(fcx.ccx, test),\n-                                                 block_pp(fcx.ccx, body)]),\n+                             seq_preconds(fcx,\n+                                          [expr_pp(fcx.ccx, test),\n+                                           block_pp(fcx.ccx, body)]),\n                              intersect_states(expr_postcond(fcx.ccx, test),\n-                                              block_postcond(fcx.ccx, body)));\n+                                              block_postcond(fcx.ccx,\n+                                                             body)));\n         }\n         case (expr_do_while(?body, ?test)) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n-            auto loop_postcond = seq_postconds(fcx,\n-                ~[block_postcond(fcx.ccx, body),\n-                  expr_postcond(fcx.ccx, test)]);\n-            /* conservative approximation: if the body\n+            auto loop_postcond =\n+                seq_postconds(fcx, [block_postcond(fcx.ccx, body),\n+                                    expr_postcond(fcx.ccx, test)]);\n+            /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n \n             if (has_nonlocal_exits(body)) {\n                 loop_postcond = empty_poststate(num_local_vars);\n             }\n             set_pre_and_post(fcx.ccx, e.id,\n                              seq_preconds(fcx,\n-                                          ~[block_pp(fcx.ccx, body),\n-                                            expr_pp(fcx.ccx, test)]),\n+                                          [block_pp(fcx.ccx, body),\n+                                           expr_pp(fcx.ccx, test)]),\n                              loop_postcond);\n         }\n         case (expr_for(?d, ?index, ?body)) {\n@@ -509,7 +509,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, fn_ctxt fcx, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n-                union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n+                union(pp.precondition, seq_preconds(fcx, [antec, next]));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n@@ -664,23 +664,27 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     fn do_inner_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     auto do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n-\n-    let pre_and_post[] pps = ~[];\n-    for (@stmt s in b.node.stmts) { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n-    alt (b.node.expr) {\n-      case (none) { /* no-op */ }\n-      case (some(?e)) { pps += ~[expr_pp(fcx.ccx, e)]; }\n+    let vec[pre_and_post] pps = [];\n+    fn get_pp_stmt(crate_ctxt ccx, &@stmt s) -> pre_and_post {\n+        ret stmt_pp(ccx, *s);\n+    }\n+    auto f = bind get_pp_stmt(fcx.ccx, _);\n+    pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n+    fn get_pp_expr(crate_ctxt ccx, &@expr e) -> pre_and_post {\n+        ret expr_pp(ccx, e);\n     }\n+    auto g = bind get_pp_expr(fcx.ccx, _);\n+    plus_option[pre_and_post](pps,\n+                              option::map[@expr,\n+                                          pre_and_post](g, b.node.expr));\n \n     auto block_precond = seq_preconds(fcx, pps);\n-\n-    auto postconds = ~[];\n-    for (pre_and_post pp in pps) { postconds += ~[get_post(pp)]; }\n-\n+    auto h = get_post;\n+    auto postconds = vec::map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    postconds += ~[block_precond];\n \n+    vec::push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n "}, {"sha": "90be1810301f274236c811cd41c8438a7b2800b9", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -240,11 +240,11 @@ fn tritv_doesntcare(&t v) -> bool {\n   ret true;\n }\n \n-fn to_vec(&t v) -> uint[] {\n+fn to_vec(&t v) -> vec[uint] {\n   let uint i = 0u;\n-  let uint[] rslt = ~[];\n+  let vec[uint] rslt = [];\n   while (i < v.nbits) {\n-    rslt += ~[alt (tritv_get(v, i)) {\n+    rslt += [alt (tritv_get(v, i)) {\n         case (dont_care) { 2u }\n         case (ttrue)     { 1u }\n         case (tfalse)    { 0u } }];"}, {"sha": "5ef38434e5d2056d1a2060bde1e3b6c7a758c6fd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 91, "deletions": 105, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -196,9 +196,9 @@ type method =\n         arg[] inputs,\n         t output,\n         controlflow cf,\n-        (@constr_def)[] constrs);\n+        vec[@constr_def] constrs);\n \n-type constr_table = hashmap[ast::node_id, constr_def[]];\n+type constr_table = hashmap[ast::node_id, vec[constr_def]]; \n \n type mt = rec(t ty, ast::mutability mut);\n \n@@ -257,7 +257,7 @@ tag sty {\n     ty_char;\n     ty_str;\n     ty_istr;\n-    ty_tag(def_id, t[]);\n+    ty_tag(def_id, vec[t]);\n     ty_box(mt);\n     ty_vec(mt);\n     ty_ivec(mt);\n@@ -267,10 +267,10 @@ tag sty {\n     ty_task;\n     ty_tup(mt[]);\n     ty_rec(field[]);\n-    ty_fn(ast::proto, arg[], t, controlflow, (@constr_def)[]);\n+    ty_fn(ast::proto, arg[], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, arg[], t);\n-    ty_obj(method[]);\n-    ty_res(def_id, t, t[]);\n+    ty_obj(vec[method]);\n+    ty_res(def_id, t, vec[t]);\n     ty_var(int); // type variable\n     ty_param(uint); // fn/tag type param\n     ty_type;\n@@ -281,7 +281,7 @@ tag sty {\n type constr_def = spanned[constr_general[uint]];\n \n type constr_general[T] =\n-    rec(ast::path path, (@constr_arg_general[T])[] args, def_id id);\n+    rec(ast::path path, vec[@constr_arg_general[T]] args, def_id id);\n \n \n // Data structures used in type unification\n@@ -351,7 +351,7 @@ const uint idx_first_others = 21u;\n \n type type_store = interner::interner[raw_t];\n \n-type ty_param_substs_opt_and_ty = tup(option::t[ty::t[]], ty::t);\n+type ty_param_substs_opt_and_ty = tup(option::t[vec[ty::t]], ty::t);\n \n type node_type_table =\n     @smallintmap::smallintmap[ty::ty_param_substs_opt_and_ty];\n@@ -378,7 +378,7 @@ fn populate_type_store(&ctxt cx) {\n     intern(cx, ty_task, none[str]);\n     intern(cx, ty_type, none[str]);\n     intern(cx, ty_bot, none[str]);\n-    assert (ivec::len(cx.ts.vect) == idx_first_others);\n+    assert (vec::len(cx.ts.vect) == idx_first_others);\n }\n \n fn mk_rcache() -> creader_cache {\n@@ -557,7 +557,7 @@ fn mk_str(&ctxt cx) -> t { ret idx_str; }\n \n fn mk_istr(&ctxt cx) -> t { ret idx_istr; }\n \n-fn mk_tag(&ctxt cx, &ast::def_id did, &t[] tys) -> t {\n+fn mk_tag(&ctxt cx, &ast::def_id did, &vec[t] tys) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n }\n \n@@ -596,19 +596,19 @@ fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_fn(&ctxt cx, &ast::proto proto, &arg[] args, &t ty, &controlflow cf,\n-         &(@constr_def)[] constrs) -> t {\n+         &vec[@constr_def] constrs) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &arg[] args, &t ty) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(&ctxt cx, &method[] meths) -> t {\n+fn mk_obj(&ctxt cx, &vec[method] meths) -> t {\n     ret gen_ty(cx, ty_obj(meths));\n }\n \n-fn mk_res(&ctxt cx, &ast::def_id did, &t inner, &t[] tps) -> t {\n+fn mk_res(&ctxt cx, &ast::def_id did, &t inner, &vec[t] tps) -> t {\n     ret gen_ty(cx, ty_res(did, inner, tps));\n }\n \n@@ -753,9 +753,9 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_chan(cx, fold_ty(cx, fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n-            let t[] new_subtys = ~[];\n+            let vec[t] new_subtys = [];\n             for (t subty in subtys) {\n-                new_subtys += ~[fold_ty(cx, fld, subty)];\n+                new_subtys += [fold_ty(cx, fld, subty)];\n             }\n             ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n         }\n@@ -799,26 +799,26 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n                                         fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_obj(?methods)) {\n-            let method[] new_methods = ~[];\n+            let vec[method] new_methods = [];\n             for (method m in methods) {\n                 let arg[] new_args = ~[];\n                 for (arg a in m.inputs) {\n                     new_args += ~[rec(mode=a.mode,\n                                       ty=fold_ty(cx, fld, a.ty))];\n                 }\n                 new_methods +=\n-                    ~[rec(proto=m.proto,\n-                          ident=m.ident,\n-                          inputs=new_args,\n-                          output=fold_ty(cx, fld, m.output),\n-                          cf=m.cf,\n-                          constrs=m.constrs)];\n+                    [rec(proto=m.proto,\n+                         ident=m.ident,\n+                         inputs=new_args,\n+                         output=fold_ty(cx, fld, m.output),\n+                         cf=m.cf,\n+                         constrs=m.constrs)];\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n         case (ty_res(?did, ?subty, ?tps)) {\n-            auto new_tps = ~[];\n-            for (t tp in tps) { new_tps += ~[fold_ty(cx, fld, tp)]; }\n+            auto new_tps = [];\n+            for (t tp in tps) { new_tps += [fold_ty(cx, fld, tp)]; }\n             ty = copy_cname(cx, mk_res(cx, did, fold_ty(cx, fld, subty),\n                                        new_tps), ty);\n         }\n@@ -1052,12 +1052,8 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n             }\n         }\n         case (ty_res(?did, ?inner, ?tps)) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n             result = type_has_pointers\n-                (cx, substitute_type_params(cx, tps_ivec, inner));\n+                (cx, substitute_type_params(cx, tps, inner));\n         }\n         case (_) { result = true; }\n     }\n@@ -1090,7 +1086,7 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         case (ty_istr) { ret false; }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n-            while (i < ivec::len[t](subtys)) {\n+            while (i < vec::len[t](subtys)) {\n                 if (type_has_dynamic_size(cx, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n@@ -1244,12 +1240,8 @@ fn type_owns_heap_mem(&ctxt cx, &t ty) -> bool {\n             }\n         }\n         case (ty_res(_, ?inner, ?tps)) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n             result = type_owns_heap_mem\n-                (cx, substitute_type_params(cx, tps_ivec, inner));\n+                (cx, substitute_type_params(cx, tps, inner));\n         }\n \n         case (ty_ptr(_)) { result = false; }\n@@ -1280,16 +1272,12 @@ fn type_autoderef(&ctxt cx, &ty::t t) -> ty::t {\n         alt (struct(cx, t1)) {\n             case (ty::ty_box(?mt)) { t1 = mt.ty; }\n             case (ty::ty_res(_, ?inner, ?tps)) {\n-                // FIXME: Remove this vec->ivec conversion.\n-                auto tps_ivec = ~[];\n-                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n-                t1 = substitute_type_params(cx, tps_ivec, inner);\n+                t1 = substitute_type_params(cx, tps, inner);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = tag_variants(cx, did);\n-                if (ivec::len(variants) != 1u ||\n-                        ivec::len(variants.(0).args) != 1u) {\n+                if (vec::len(variants) != 1u ||\n+                    vec::len(variants.(0).args) != 1u) {\n                     break;\n                 }\n                 t1 = substitute_type_params(cx, tps, variants.(0).args.(0));\n@@ -1438,8 +1426,8 @@ fn arg_eq[T](&fn(&T, &T) -> bool  eq, @ast::constr_arg_general[T] a,\n     }\n }\n \n-fn args_eq[T](fn(&T, &T) -> bool eq, &(@ast::constr_arg_general[T])[] a,\n-              &(@ast::constr_arg_general[T])[] b) -> bool {\n+fn args_eq[T](fn(&T, &T) -> bool  eq, vec[@ast::constr_arg_general[T]] a,\n+              vec[@ast::constr_arg_general[T]] b) -> bool {\n     let uint i = 0u;\n     for (@ast::constr_arg_general[T] arg in a) {\n         if (!arg_eq(eq, arg, b.(i))) { ret false; }\n@@ -1454,8 +1442,8 @@ fn constr_eq(&@constr_def c, &@constr_def d) -> bool {\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(&(@constr_def)[] cs, &(@constr_def)[] ds) -> bool {\n-    if (ivec::len(cs) != ivec::len(ds)) { ret false; }\n+fn constrs_eq(&vec[@constr_def] cs, &vec[@constr_def] ds) -> bool {\n+    if (vec::len(cs) != vec::len(ds)) { ret false; }\n     auto i = 0u;\n     for (@constr_def c in cs) {\n         if (!constr_eq(c, ds.(i))) { ret false; }\n@@ -1526,8 +1514,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n             alt (b) {\n                 case (ty_tag(?id_b, ?tys_b)) {\n                     if (!equal_def(id_a, id_b)) { ret false; }\n-                    auto len = ivec::len[t](tys_a);\n-                    if (len != ivec::len[t](tys_b)) { ret false; }\n+                    auto len = vec::len[t](tys_a);\n+                    if (len != vec::len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!eq_ty(tys_a.(i), tys_b.(i))) { ret false; }\n@@ -1634,8 +1622,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_obj(?methods_a)) {\n             alt (b) {\n                 case (ty_obj(?methods_b)) {\n-                    auto len = ivec::len[method](methods_a);\n-                    if (len != ivec::len[method](methods_b)) { ret false; }\n+                    auto len = vec::len[method](methods_a);\n+                    if (len != vec::len[method](methods_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto m_a = methods_a.(i);\n@@ -1748,16 +1736,16 @@ fn node_id_to_type(&ctxt cx, &ast::node_id id) -> t {\n     ret node_id_to_ty_param_substs_opt_and_ty(cx, id)._1;\n }\n \n-fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> t[] {\n+fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> vec[t] {\n     alt (node_id_to_ty_param_substs_opt_and_ty(cx, id)._0) {\n-        case (none)       { ret ~[]; }\n+        case (none) { let vec[t] result = []; ret result; }\n         case (some(?tps)) { ret tps; }\n     }\n }\n \n fn node_id_has_type_params(&ctxt cx, &ast::node_id id) -> bool {\n     auto tpt = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n-    ret !option::is_none[t[]](tpt._0);\n+    ret !option::is_none[vec[t]](tpt._0);\n }\n \n \n@@ -1767,13 +1755,7 @@ fn ty_param_substs_opt_and_ty_to_monotype(&ctxt cx,\n    t {\n     alt (tpot._0) {\n         case (none) { ret tpot._1; }\n-        case (some(?tps)) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto tps_ivec = ~[];\n-            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n-            ret substitute_type_params(cx, tps_ivec, tpot._1);\n-        }\n+        case (some(?tps)) { ret substitute_type_params(cx, tps, tpot._1); }\n     }\n }\n \n@@ -1788,22 +1770,24 @@ fn node_id_to_monotype(&ctxt cx, ast::node_id id) -> t {\n \n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(&ctxt cx, t ty) -> uint {\n-    fn counter(&ctxt cx, @mutable (uint[]) param_indices, t ty) {\n+    fn counter(&ctxt cx, @mutable vec[uint] param_indices, t ty) {\n         alt (struct(cx, ty)) {\n             case (ty_param(?param_idx)) {\n                 auto seen = false;\n                 for (uint other_param_idx in *param_indices) {\n                     if (param_idx == other_param_idx) { seen = true; }\n                 }\n-                if (!seen) { *param_indices += ~[param_idx]; }\n+                if (!seen) { *param_indices += [param_idx]; }\n             }\n             case (_) {/* fall through */ }\n         }\n     }\n-    let @mutable (uint[]) param_indices = @mutable ~[];\n+    let vec[uint] v = []; // FIXME: typechecker botch\n+\n+    let @mutable vec[uint] param_indices = @mutable v;\n     auto f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n-    ret ivec::len[uint](*param_indices);\n+    ret vec::len[uint](*param_indices);\n }\n \n fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n@@ -1881,7 +1865,7 @@ fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n     ret node_id_to_monotype(cx, expr.id);\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(t[], t) {\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n     ret tup(node_id_to_type_params(cx, expr.id),\n             node_id_to_type(cx, expr.id));\n }\n@@ -1941,17 +1925,17 @@ fn field_idx(&session::session sess, &span sp, &ast::ident id,\n }\n \n fn method_idx(&session::session sess, &span sp, &ast::ident id,\n-              &method[] meths) -> uint {\n+              &vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) { if (str::eq(m.ident, id)) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n-fn sort_methods(&method[] meths) -> method[] {\n+fn sort_methods(&vec[method] meths) -> vec[method] {\n     fn method_lteq(&method a, &method b) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n-    ret std::sort::ivector::merge_sort[method](bind method_lteq(_, _), meths);\n+    ret std::sort::merge_sort[method](bind method_lteq(_, _), meths);\n }\n \n fn is_lval(&@ast::expr expr) -> bool {\n@@ -2137,8 +2121,8 @@ mod unify {\n                 &t expected, &t actual, &arg[] expected_inputs,\n                 &t expected_output, &arg[] actual_inputs, &t actual_output,\n                 &controlflow expected_cf, &controlflow actual_cf,\n-                &(@constr_def)[] expected_constrs,\n-                &(@constr_def)[] actual_constrs) -> result {\n+                &vec[@constr_def] expected_constrs,\n+                &vec[@constr_def] actual_constrs) -> result {\n         if (e_proto != a_proto) { ret ures_err(terr_mismatch); }\n         alt (expected_cf) {\n             case (ast::return) { }\n@@ -2191,12 +2175,12 @@ mod unify {\n         }\n     }\n     fn unify_obj(&@ctxt cx, &t expected, &t actual,\n-                 &method[] expected_meths, &method[] actual_meths) ->\n+                 &vec[method] expected_meths, &vec[method] actual_meths) ->\n        result {\n-        let method[] result_meths = ~[];\n+        let vec[method] result_meths = [];\n         let uint i = 0u;\n-        let uint expected_len = ivec::len[method](expected_meths);\n-        let uint actual_len = ivec::len[method](actual_meths);\n+        let uint expected_len = vec::len[method](expected_meths);\n+        let uint actual_len = vec::len[method](actual_meths);\n         if (expected_len != actual_len) { ret ures_err(terr_meth_count); }\n         while (i < expected_len) {\n             auto e_meth = expected_meths.(i);\n@@ -2214,10 +2198,10 @@ mod unify {\n                     alt (struct(cx.tcx, tfn)) {\n                         case (ty_fn(?proto, ?ins, ?out, ?cf, ?constrs)) {\n                             result_meths +=\n-                                ~[rec(inputs=ins,\n-                                      output=out,\n-                                      cf=cf,\n-                                      constrs=constrs with e_meth)];\n+                                [rec(inputs=ins,\n+                                     output=out,\n+                                     cf=cf,\n+                                     constrs=constrs with e_meth)];\n                         }\n                     }\n                 }\n@@ -2344,16 +2328,18 @@ mod unify {\n                         // TODO: factor this cruft out, see the TODO in the\n                         // ty::ty_tup case\n \n-                        let t[] result_tps = ~[];\n+                        let vec[t] result_tps = [];\n                         auto i = 0u;\n-                        auto expected_len = ivec::len[t](expected_tps);\n+                        auto expected_len = vec::len[t](expected_tps);\n                         while (i < expected_len) {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n                             auto result =\n                                 unify_step(cx, expected_tp, actual_tp);\n                             alt (result) {\n-                                case (ures_ok(?rty)) { result_tps += ~[rty]; }\n+                                case (ures_ok(?rty)) {\n+                                    vec::push[t](result_tps, rty);\n+                                }\n                                 case (_) { ret result; }\n                             }\n                             i += 1u;\n@@ -2473,13 +2459,13 @@ mod unify {\n                         alt (result) {\n                             case (ures_ok(?res_inner)) {\n                                 auto i = 0u;\n-                                auto res_tps = ~[];\n+                                auto res_tps = [];\n                                 for (t ex_tp in ex_tps) {\n                                     auto result =\n                                         unify_step(cx, ex_tp, act_tps.(i));\n                                     alt (result) {\n                                         case (ures_ok(?rty)) {\n-                                            res_tps += ~[rty];\n+                                            vec::push(res_tps, rty);\n                                         }\n                                         case (_) { ret result; }\n                                     }\n@@ -2761,16 +2747,13 @@ fn type_err_to_str(&ty::type_err err) -> str {\n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n fn bind_params_in_type(&span sp, &ctxt cx, fn() -> int  next_ty_var, t typ,\n-                       uint ty_param_count) -> tup(int[], t) {\n-    let @mutable int[] param_var_ids = @mutable ~[];\n+                       uint ty_param_count) -> tup(vec[int], t) {\n+    let vec[int] param_var_ids = [];\n     auto i = 0u;\n-    while (i < ty_param_count) {\n-        *param_var_ids += ~[next_ty_var()];\n-        i += 1u;\n-    }\n-    fn binder(span sp, ctxt cx, @mutable int[] param_var_ids,\n+    while (i < ty_param_count) { param_var_ids += [next_ty_var()]; i += 1u; }\n+    fn binder(span sp, ctxt cx, vec[int] param_var_ids,\n               fn() -> int next_ty_var, uint index) -> t {\n-        if (index < ivec::len(*param_var_ids)) {\n+        if (index < vec::len(param_var_ids)) {\n             ret mk_var(cx, param_var_ids.(index));\n         }\n         else {\n@@ -2780,19 +2763,20 @@ fn bind_params_in_type(&span sp, &ctxt cx, fn() -> int  next_ty_var, t typ,\n     auto new_typ =\n         fold_ty(cx, fm_param(bind binder(sp, cx, param_var_ids,\n                                          next_ty_var, _)), typ);\n-    ret tup(*param_var_ids, new_typ);\n+    ret tup(param_var_ids, new_typ);\n }\n \n \n // Replaces type parameters in the given type using the given list of\n // substitions.\n-fn substitute_type_params(&ctxt cx, &ty::t[] substs, t typ) -> t {\n+fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n     if (!type_contains_params(cx, typ)) { ret typ; }\n-    fn substituter(ctxt cx, @ty::t[] substs, uint idx) -> t {\n+    fn substituter(ctxt cx, vec[ty::t] substs, uint idx) -> t {\n         // FIXME: bounds check can fail\n+\n         ret substs.(idx);\n     }\n-    ret fold_ty(cx, fm_param(bind substituter(cx, @substs, _)), typ);\n+    ret fold_ty(cx, fm_param(bind substituter(cx, substs, _)), typ);\n }\n \n fn def_has_ty_params(&ast::def def) -> bool {\n@@ -2815,10 +2799,12 @@ fn def_has_ty_params(&ast::def def) -> bool {\n \n \n // Tag information\n-type variant_info = rec(ty::t[] args, ty::t ctor_ty, ast::def_id id);\n+type variant_info = rec(vec[ty::t] args, ty::t ctor_ty, ast::def_id id);\n \n-fn tag_variants(&ctxt cx, &ast::def_id id) -> variant_info[] {\n-    if (ast::local_crate != id._0) { ret decoder::get_tag_variants(cx, id); }\n+fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n+    if (ast::local_crate != id._0) {\n+        ret decoder::get_tag_variants(cx, id);\n+    }\n     auto item = alt (cx.items.find(id._1)) {\n         case (some(?i)) { i }\n         case (none) {\n@@ -2829,22 +2815,22 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> variant_info[] {\n         case (ast_map::node_item(?item)) {\n             alt (item.node) {\n                 case (ast::item_tag(?variants, _)) {\n-                    let variant_info[] result = ~[];\n+                    let vec[variant_info] result = [];\n                     for (ast::variant variant in variants) {\n                         auto ctor_ty = node_id_to_monotype\n                             (cx, variant.node.id);\n-                        let t[] arg_tys = ~[];\n+                        let vec[t] arg_tys = [];\n                         if (vec::len[ast::variant_arg](variant.node.args) >\n                                 0u) {\n                             for (arg a in ty_fn_args(cx, ctor_ty)) {\n-                                arg_tys += ~[a.ty];\n+                                arg_tys += [a.ty];\n                             }\n                         }\n                         auto did = variant.node.id;\n                         result +=\n-                            ~[rec(args=arg_tys,\n-                                  ctor_ty=ctor_ty,\n-                                  id=ast::local_def(did))];\n+                            [rec(args=arg_tys,\n+                                 ctor_ty=ctor_ty,\n+                                 id=ast::local_def(did))];\n                     }\n                     ret result;\n                 }\n@@ -2859,7 +2845,7 @@ fn tag_variant_with_id(&ctxt cx, &ast::def_id tag_id, &ast::def_id variant_id)\n    -> variant_info {\n     auto variants = tag_variants(cx, tag_id);\n     auto i = 0u;\n-    while (i < ivec::len[variant_info](variants)) {\n+    while (i < vec::len[variant_info](variants)) {\n         auto variant = variants.(i);\n         if (def_eq(variant.id, variant_id)) { ret variant; }\n         i += 1u;"}, {"sha": "aa950769863d92379f6d19e6cbaf670506550b33", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 138, "deletions": 161, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -155,9 +155,9 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n                             ty_param_count);\n     auto ty_param_vars = bind_result._0;\n     auto ty_substs_opt;\n-    auto ty_substs_len = ivec::len[@ast::ty](pth.node.types);\n+    auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n-        let ty::t[] ty_substs = ~[];\n+        let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n         while (i < ty_substs_len) {\n             // TODO: Report an error if the number of type params in the item\n@@ -166,10 +166,10 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n             auto ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i));\n             auto ty_subst = ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i));\n             auto res_ty = demand::simple(fcx, pth.span, ty_var, ty_subst);\n-            ty_substs += ~[res_ty];\n+            ty_substs += [res_ty];\n             i += 1u;\n         }\n-        ty_substs_opt = some[ty::t[]](ty_substs);\n+        ty_substs_opt = some[vec[ty::t]](ty_substs);\n         if (ty_param_count == 0u) {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                       \"this item does not take type \" +\n@@ -179,13 +179,13 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     } else {\n         // We will acquire the type parameters through unification.\n \n-        let ty::t[] ty_substs = ~[];\n+        let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            ty_substs += ~[ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n+            ty_substs += [ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n             i += 1u;\n         }\n-        ty_substs_opt = some[ty::t[]](ty_substs);\n+        ty_substs_opt = some[vec[ty::t]](ty_substs);\n     }\n     ret tup(ty_substs_opt, tpt._1);\n }\n@@ -256,7 +256,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         ret rec(ty=ast_ty_to_ty(tcx, getter, mt.ty), mut=mt.mut);\n     }\n     fn instantiate(&ty::ctxt tcx, &span sp, &ty_getter getter,\n-                   &ast::def_id id, &(@ast::ty)[] args) -> ty::t {\n+                   &ast::def_id id, &vec[@ast::ty] args) -> ty::t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n \n@@ -265,11 +265,11 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         // The typedef is type-parametric. Do the type substitution.\n         //\n \n-        let ty::t[] param_bindings = ~[];\n+        let vec[ty::t] param_bindings = [];\n         for (@ast::ty ast_ty in args) {\n-            param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n+            param_bindings += [ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n-        if (ivec::len(param_bindings) !=\n+        if (vec::len(param_bindings) !=\n                 ty::count_ty_params(tcx, params_opt_and_ty._1)) {\n             tcx.sess.span_fatal(sp,\n                               \"Wrong number of type arguments for a\" +\n@@ -335,17 +335,17 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             }\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n \n-            auto out_constrs = ~[];\n-            for (@ast::constr constr in constrs) {\n-                out_constrs += ~[ast_constr_to_constr(tcx, constr)];\n-            }\n+            let fn(&@ast::constr) -> @ty::constr_def g =\n+                bind ast_constr_to_constr(tcx, _);\n+            let vec[@ty::constr_def] out_constrs = vec::map(g, constrs);\n             typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n         }\n         case (ast::ty_path(?path, ?id)) {\n             alt (tcx.def_map.find(id)) {\n                 case (some(ast::def_ty(?id))) {\n-                    typ = instantiate(tcx, ast_ty.span, getter, id,\n-                                      path.node.types);\n+                    typ =\n+                        instantiate(tcx, ast_ty.span, getter, id,\n+                                    path.node.types);\n                 }\n                 case (some(ast::def_native_ty(?id))) { typ = getter(id)._1; }\n                 case (some(ast::def_ty_arg(?id))) {\n@@ -363,26 +363,26 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             cname = some(path_to_str(path));\n         }\n         case (ast::ty_obj(?meths)) {\n-            let ty::method[] tmeths = ~[];\n+            let vec[ty::method] tmeths = [];\n             for (ast::ty_method m in meths) {\n                 auto ins = ~[];\n                 for (ast::ty_arg ta in m.node.inputs) {\n                     ins += ~[ast_arg_to_arg(tcx, getter, ta)];\n                 }\n                 auto out = ast_ty_to_ty(tcx, getter, m.node.output);\n \n-                auto out_constrs = ~[];\n-                for (@ast::constr constr in m.node.constrs) {\n-                    out_constrs += ~[ast_constr_to_constr(tcx, constr)];\n-                }\n+                let fn(&@ast::constr) -> @ty::constr_def g =\n+                    bind ast_constr_to_constr(tcx, _);\n+                let vec[@ty::constr_def] out_constrs =\n+                       vec::map(g, m.node.constrs);\n                 let ty::method new_m =\n                     rec(proto=m.node.proto,\n                         ident=m.node.ident,\n                         inputs=ins,\n                         output=out,\n                         cf=m.node.cf,\n                         constrs=out_constrs);\n-                tmeths += ~[new_m];\n+                vec::push[ty::method](tmeths, new_m);\n             }\n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n         }\n@@ -434,23 +434,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(&ty::ctxt tcx, ast::node_id node_id, ty::t typ) {\n-        ret ty(tcx, node_id, tup(none[ty::t[]], typ));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(@fn_ctxt fcx, ast::node_id node_id, ty::t typ) {\n-        ret ty_fixup(fcx, node_id, tup(none[ty::t[]], typ));\n+        ret ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_nil(tcx)));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_bot(tcx)));\n+        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n     }\n }\n \n@@ -472,11 +472,11 @@ mod write {\n mod collect {\n     type ctxt = rec(ty::ctxt tcx);\n \n-    fn mk_ty_params(&@ctxt cx, uint n) -> ty::t[] {\n-        auto tps = ~[];\n+    fn mk_ty_params(&@ctxt cx, uint n) -> vec[ty::t] {\n+        auto tps = [];\n         auto i = 0u;\n         while (i < n) {\n-            tps += ~[ty::mk_param(cx.tcx, i)];\n+            tps += [ty::mk_param(cx.tcx, i)];\n             i += 1u;\n         }\n         ret tps;\n@@ -490,10 +490,9 @@ mod collect {\n         for (ast::arg a in decl.inputs) { input_tys += ~[ty_of_arg(a)]; }\n         auto output_ty = convert(decl.output);\n \n-        auto out_constrs = ~[];\n-        for (@ast::constr constr in decl.constraints) {\n-            out_constrs += ~[ast_constr_to_constr(cx.tcx, constr)];\n-        }\n+        let fn(&@ast::constr) -> @ty::constr_def g =\n+            bind ast_constr_to_constr(cx.tcx, _);\n+        let vec[@ty::constr_def] out_constrs = vec::map(g, decl.constraints);\n         auto t_fn =\n             ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n                       out_constrs);\n@@ -569,11 +568,10 @@ mod collect {\n         }\n \n         auto output = convert(m.node.meth.decl.output);\n-\n-        auto out_constrs = ~[];\n-        for (@ast::constr constr in m.node.meth.decl.constraints) {\n-            out_constrs += ~[ast_constr_to_constr(cx.tcx, constr)];\n-        }\n+        let fn(&@ast::constr) -> @ty::constr_def g =\n+            bind ast_constr_to_constr(cx.tcx, _);\n+        let vec[@ty::constr_def] out_constrs =\n+            vec::map(g, m.node.meth.decl.constraints);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                 inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n                 constrs=out_constrs);\n@@ -598,7 +596,7 @@ mod collect {\n         }\n \n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n-                              ast::return, ~[]);\n+                              ast::return, []);\n         auto tpt = tup(t_obj._0, t_fn);\n         cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n@@ -649,8 +647,7 @@ mod collect {\n                 // Create a new generic polytype.\n \n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n-\n-                let ty::t[] subtys = mk_ty_params(cx, ty_param_count);\n+                let vec[ty::t] subtys = mk_ty_params(cx, ty_param_count);\n                 auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n                 auto tpt = tup(ty_param_count, t);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n@@ -688,7 +685,7 @@ mod collect {\n         // Create a set of parameter types shared among all the variants.\n \n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n-        let ty::t[] ty_param_tys = mk_ty_params(cx, ty_param_count);\n+        let vec[ty::t] ty_param_tys = mk_ty_params(cx, ty_param_count);\n         for (ast::variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n@@ -709,19 +706,16 @@ mod collect {\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n                 result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n-                                      ast::return, ~[]);\n+                                      ast::return, []);\n             }\n             auto tpt = tup(ty_param_count, result_ty);\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> ty::method[] {\n-        auto meths = ~[];\n-        for (@ast::method m in object.methods) {\n-            meths += ~[ty_of_method(cx, m)];\n-        }\n-        ret meths;\n+    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[ty::method] {\n+        ret vec::map[@ast::method,\n+                     method](bind ty_of_method(cx, _), object.methods);\n     }\n     fn convert(@ctxt cx, @mutable option::t[ast::native_abi] abi,\n                &@ast::item it) {\n@@ -783,7 +777,7 @@ mod collect {\n                     case (none) {/* nothing to do */ }\n                     case (some(?m)) {\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, ~[],\n-                                   ty::mk_nil(cx.tcx), ast::return, ~[]);\n+                                   ty::mk_nil(cx.tcx), ast::return, []);\n                         write::ty_only(cx.tcx, m.node.id, t);\n                     }\n                 }\n@@ -793,9 +787,9 @@ mod collect {\n                 auto t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                                         mk_ty_params(cx, vec::len(tps)));\n                 auto t_ctor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n-                                        t_res, ast::return, ~[]);\n+                                        t_res, ast::return, []);\n                 auto t_dtor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n-                                        ty::mk_nil(cx.tcx), ast::return, ~[]);\n+                                        ty::mk_nil(cx.tcx), ast::return, []);\n                 write::ty_only(cx.tcx, it.id, t_res);\n                 write::ty_only(cx.tcx, ctor_id, t_ctor);\n                 cx.tcx.tcache.insert(local_def(ctor_id),\n@@ -865,16 +859,12 @@ fn do_autoderef(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n         alt (structure_of(fcx, sp, t1)) {\n             case (ty::ty_box(?inner)) { t1 = inner.ty; }\n             case (ty::ty_res(_, ?inner, ?tps)) {\n-                // FIXME: Remove this vec->ivec conversion.\n-                auto tps_ivec = ~[];\n-                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n-                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps_ivec, inner);\n+                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = ty::tag_variants(fcx.ccx.tcx, did);\n-                if (ivec::len(variants) != 1u ||\n-                        ivec::len(variants.(0).args) != 1u) {\n+                if (vec::len(variants) != 1u ||\n+                    vec::len(variants.(0).args) != 1u) {\n                     ret t1;\n                 }\n                 t1 = ty::substitute_type_params(fcx.ccx.tcx, tps,\n@@ -914,22 +904,24 @@ fn resolve_type_vars_if_possible(&@fn_ctxt fcx, ty::t typ) -> ty::t {\n \n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n-type ty_param_substs_and_ty = tup(ty::t[], ty::t);\n+type ty_param_substs_and_ty = tup(vec[ty::t], ty::t);\n \n mod demand {\n     fn simple(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual) ->\n        ty::t {\n-        ret full(fcx, sp, expected, actual, ~[], NO_AUTODEREF)._1;\n+        let vec[ty::t] tps = [];\n+        ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n     }\n     fn autoderef(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n                  autoderef_kind adk) -> ty::t {\n-        ret full(fcx, sp, expected, actual, ~[], adk)._1;\n+        let vec[ty::t] tps = [];\n+        ret full(fcx, sp, expected, actual, tps, adk)._1;\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n     fn full(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n-            &ty::t[] ty_param_substs_0, autoderef_kind adk) ->\n+            &vec[ty::t] ty_param_substs_0, autoderef_kind adk) ->\n        ty_param_substs_and_ty {\n         auto expected_1 = expected;\n         auto actual_1 = actual;\n@@ -954,10 +946,10 @@ mod demand {\n         fn mk_result(&@fn_ctxt fcx, &ty::t result_ty,\n                      &vec[int] ty_param_subst_var_ids,\n                      uint implicit_boxes) -> ty_param_substs_and_ty {\n-            let ty::t[] result_ty_param_substs = ~[];\n+            let vec[ty::t] result_ty_param_substs = [];\n             for (int var_id in ty_param_subst_var_ids) {\n                 auto tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n-                result_ty_param_substs += ~[tp_subst];\n+                result_ty_param_substs += [tp_subst];\n             }\n             ret tup(result_ty_param_substs,\n                     add_boxes(fcx.ccx, implicit_boxes, result_ty));\n@@ -997,7 +989,7 @@ fn are_compatible(&@fn_ctxt fcx, &ty::t expected, &ty::t actual) -> bool {\n \n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n-                     &ty::t[] tag_ty_params) -> vec[ty::t] {\n+                     &vec[ty::t] tag_ty_params) -> vec[ty::t] {\n     let vec[ty::t] result = [];\n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (ty::struct(ccx.tcx, tpt._1)) {\n@@ -1047,14 +1039,13 @@ mod writeback {\n         auto new_ty = resolve_type_vars_in_type(fcx, sp, tpot._1);\n         auto new_substs_opt;\n         alt (tpot._0) {\n-            case (none[ty::t[]]) { new_substs_opt = none[ty::t[]]; }\n-            case (some[ty::t[]](?substs)) {\n-                let ty::t[] new_substs = ~[];\n+            case (none[vec[ty::t]]) { new_substs_opt = none[vec[ty::t]]; }\n+            case (some[vec[ty::t]](?substs)) {\n+                let vec[ty::t] new_substs = [];\n                 for (ty::t subst in substs) {\n-                    new_substs += ~[resolve_type_vars_in_type(fcx, sp,\n-                                                              subst)];\n+                    new_substs += [resolve_type_vars_in_type(fcx, sp, subst)];\n                 }\n-                new_substs_opt = some[ty::t[]](new_substs);\n+                new_substs_opt = some[vec[ty::t]](new_substs);\n             }\n         }\n         write::ty(fcx.ccx.tcx, id, tup(new_substs_opt, new_ty));\n@@ -1235,11 +1226,11 @@ fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n \n // AST fragment utilities\n fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n-                     &tup(ty::t[], ty::t) new_tyt) {\n+                     &tup(vec[ty::t], ty::t) new_tyt) {\n     auto new_tps;\n     if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n-        new_tps = some[ty::t[]](new_tyt._0);\n-    } else { new_tps = none[ty::t[]]; }\n+        new_tps = some[vec[ty::t]](new_tyt._0);\n+    } else { new_tps = none[vec[ty::t]]; }\n     write::ty_fixup(fcx, expr.id, tup(new_tps, new_tyt._1));\n }\n \n@@ -1287,80 +1278,74 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n             auto path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n             // Take the tag type params out of `expected`.\n \n+            auto expected_tps;\n             alt (structure_of(fcx, pat.span, expected)) {\n-              case (ty::ty_tag(_, ?expected_tps)) {\n-                // Unify with the expected tag type.\n-\n-                auto ctor_ty =\n-                    ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n-                                                               path_tpot);\n-\n-                // FIXME: Remove this ivec->vec conversion.\n-                auto tps_vec = ~[];\n-                for (ty::t tp in expected_tps) { tps_vec += ~[tp]; }\n-\n-                auto path_tpt =\n-                    demand::full(fcx, pat.span, expected, ctor_ty, tps_vec,\n-                                 NO_AUTODEREF);\n-                path_tpot = tup(some[ty::t[]](path_tpt._0), path_tpt._1);\n-                // Get the number of arguments in this tag variant.\n-\n-                auto arg_types =\n-                    variant_arg_types(fcx.ccx, pat.span, v_def_ids._1,\n-                                      expected_tps);\n-                auto subpats_len = vec::len[@ast::pat](subpats);\n-                if (vec::len[ty::t](arg_types) > 0u) {\n-                    // N-ary variant.\n-\n-                    auto arg_len = vec::len[ty::t](arg_types);\n-                    if (arg_len != subpats_len) {\n-                        // TODO: note definition of tag variant\n-                        // TODO (issue #448): Wrap a #fmt string over multiple\n-                        // lines...\n-                        auto s = #fmt(\"this pattern has %u field%s, but the \\\n-                                       corresponding variant has %u field%s\",\n-                                      subpats_len,\n-                                      if (subpats_len == 1u) {\n-                                          \"\"\n-                                      } else { \"s\" }, arg_len,\n-                                      if (arg_len == 1u) {\n-                                          \"\"\n-                                      } else { \"s\" });\n-                        fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n-                    }\n-                    // TODO: vec::iter2\n+                case (ty::ty_tag(_, ?tps)) { expected_tps = tps; }\n+                case (_) {\n+                    // FIXME: Switch expected and actual in this message? I\n+                    // can never tell.\n \n-                    auto i = 0u;\n-                    for (@ast::pat subpat in subpats) {\n-                        check_pat(fcx, subpat, arg_types.(i));\n-                        i += 1u;\n-                    }\n-                } else if (subpats_len > 0u) {\n+                    fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                                              #fmt(\"mismatched types: \\\n+                                                    expected tag, found %s\",\n+                                                   ty_to_str(fcx.ccx.tcx,\n+                                                             expected)));\n+                }\n+            }\n+            // Unify with the expected tag type.\n+\n+            auto ctor_ty =\n+                ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n+                                                           path_tpot);\n+            auto path_tpt =\n+                demand::full(fcx, pat.span, expected, ctor_ty, expected_tps,\n+                             NO_AUTODEREF);\n+            path_tpot = tup(some[vec[ty::t]](path_tpt._0), path_tpt._1);\n+            // Get the number of arguments in this tag variant.\n+\n+            auto arg_types =\n+                variant_arg_types(fcx.ccx, pat.span, v_def_ids._1,\n+                                  expected_tps);\n+            auto subpats_len = vec::len[@ast::pat](subpats);\n+            if (vec::len[ty::t](arg_types) > 0u) {\n+                // N-ary variant.\n+\n+                auto arg_len = vec::len[ty::t](arg_types);\n+                if (arg_len != subpats_len) {\n                     // TODO: note definition of tag variant\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n                     // lines...\n+                    auto s = #fmt(\"this pattern has %u field%s, but the \\\n+                                   corresponding variant has %u field%s\",\n+                                  subpats_len,\n+                                  if (subpats_len == 1u) {\n+                                      \"\"\n+                                  } else { \"s\" }, arg_len,\n+                                  if (arg_len == 1u) {\n+                                      \"\"\n+                                  } else { \"s\" });\n+                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n+                }\n+                // TODO: vec::iter2\n \n-                    fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                auto i = 0u;\n+                for (@ast::pat subpat in subpats) {\n+                    check_pat(fcx, subpat, arg_types.(i));\n+                    i += 1u;\n+                }\n+            } else if (subpats_len > 0u) {\n+                // TODO: note definition of tag variant\n+                // TODO (issue #448): Wrap a #fmt string over multiple\n+                // lines...\n+\n+                fcx.ccx.tcx.sess.span_fatal(pat.span,\n                                           #fmt(\"this pattern has %u field%s, \\\n                                                 but the corresponding \\\n                                                 variant has no fields\",\n                                                subpats_len,\n                                                if (subpats_len == 1u) {\n                                                    \"\"\n                                                } else { \"s\" }));\n-                }\n-                write::ty_fixup(fcx, pat.id, path_tpot);\n-              }\n-              case (_) {\n-                // FIXME: Switch expected and actual in this message? I\n-                // can never tell.\n-\n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                            #fmt(\"mismatched types: \\\n-                                                  expected tag, found %s\",\n-                                                 ty_to_str(fcx.ccx.tcx,\n-                                                           expected)));\n-              }\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n         }\n@@ -1619,8 +1604,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         case (ty::ty_res(_, ?inner, _)) { oper_t = inner; }\n                         case (ty::ty_tag(?id, ?tps)) {\n                             auto variants = ty::tag_variants(fcx.ccx.tcx, id);\n-                            if (ivec::len(variants) != 1u ||\n-                                    ivec::len(variants.(0).args) != 1u) {\n+                            if (vec::len(variants) != 1u ||\n+                                vec::len(variants.(0).args) != 1u) {\n                                 fcx.ccx.tcx.sess.span_fatal\n                                     (expr.span, \"can only dereference tags \" +\n                                      \"with a single variant which has a \" +\n@@ -1664,7 +1649,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n \n-            if (ivec::len[@ast::ty](pth.node.types) > 0u) {\n+            if (vec::len[@ast::ty](pth.node.types) > 0u) {\n                 fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                           \"this kind of value does not \\\n                                            take type parameters\");\n@@ -2135,7 +2120,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     let uint ix =\n                         ty::method_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                        methods);\n-                    if (ix >= ivec::len[ty::method](methods)) {\n+                    if (ix >= vec::len[ty::method](methods)) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on obj\");\n                     }\n@@ -2258,32 +2243,30 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n \n                 auto output = convert(m.node.meth.decl.output);\n-\n-                auto out_constrs = ~[];\n-                for (@ast::constr constr in m.node.meth.decl.constraints) {\n-                    out_constrs += ~[ast_constr_to_constr(ccx.tcx, constr)];\n-                }\n-\n+                let fn(&@ast::constr) -> @ty::constr_def g =\n+                    bind ast_constr_to_constr(ccx.tcx, _);\n+                let vec[@ty::constr_def] out_constrs =\n+                    vec::map(g, m.node.meth.decl.constraints);\n                 ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                         inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n                         constrs=out_constrs);\n             }\n             fn get_anon_obj_method_types(@fn_ctxt fcx,\n-                                         &ast::anon_obj anon_obj)\n-                -> ty::method[] {\n+                                         &ast::anon_obj anon_obj) ->\n+               vec[ty::method] {\n \n-                let ty::method[] methods = ~[];\n+                let vec[ty::method] methods = [];\n \n                 // Outer methods.\n-                for (@ast::method m in anon_obj.methods) {\n-                    methods += ~[ty_of_method(fcx.ccx, m)];\n-                }\n+                methods += vec::map[@ast::method,\n+                                    method](bind ty_of_method(fcx.ccx, _),\n+                                            anon_obj.methods);\n \n                 // Inner methods.\n \n                 // Typecheck 'with_obj'.  If it exists, it had better have\n                 // object type.\n-                let ty::method[] with_obj_methods = ~[];\n+                let vec[ty::method] with_obj_methods = [];\n                 alt (anon_obj.with_obj) {\n                     case (none) { }\n                     case (some(?e)) {\n@@ -2357,13 +2340,7 @@ fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n     -> @ty::constr_def {\n     alt (tcx.def_map.find(c.node.id)) {\n         case (some(ast::def_fn(?pred_id, ast::pure_fn))) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            let (@ast::constr_arg_general[uint])[] cag_ivec = ~[];\n-            for (@ast::constr_arg_general[uint] cag in c.node.args) {\n-                cag_ivec += ~[cag];\n-            }\n-\n-            ret @respan(c.span, rec(path=c.node.path, args=cag_ivec,\n+            ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n                                     id=pred_id));\n         }\n         case (_) {"}, {"sha": "5f8e301d6e2018676e11280ac2e7f0ef80439d3f", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,6 +1,4 @@\n-// The Rust abstract syntax tree.\n \n-import std::ivec;\n import std::option;\n import std::str;\n import std::vec;\n@@ -17,11 +15,11 @@ type fn_ident = option::t[ident];\n // FIXME: with typestate constraint, could say\n // idents and types are the same length, and are\n // non-empty\n-type path_ = rec(ident[] idents, (@ty)[] types);\n+type path_ = rec(vec[ident] idents, vec[@ty] types);\n \n type path = spanned[path_];\n \n-fn path_name(&path p) -> str { ret str::connect_ivec(p.node.idents, \"::\"); }\n+fn path_name(&path p) -> str { ret str::connect(p.node.idents, \"::\"); }\n \n type crate_num = int;\n type node_id = int;\n@@ -81,19 +79,19 @@ fn def_id_of_def(def d) -> def_id {\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n-type crate_cfg = (@meta_item)[];\n+type crate_cfg = vec[@meta_item];\n \n type crate = spanned[crate_];\n \n-type crate_ = rec((@crate_directive)[] directives,\n+type crate_ = rec(vec[@crate_directive] directives,\n                   _mod module,\n-                  attribute[] attrs,\n+                  vec[attribute] attrs,\n                   crate_cfg config);\n \n tag crate_directive_ {\n-    cdir_src_mod(ident, option::t[filename], attribute[]);\n+    cdir_src_mod(ident, option::t[filename], vec[attribute]);\n     cdir_dir_mod(ident, option::t[filename],\n-                 (@crate_directive)[], attribute[]);\n+                 vec[@crate_directive], vec[attribute]);\n     cdir_view_item(@view_item);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n@@ -105,7 +103,7 @@ type meta_item = spanned[meta_item_];\n \n tag meta_item_ {\n     meta_word(ident);\n-    meta_list(ident, (@meta_item)[]);\n+    meta_list(ident, vec[@meta_item]);\n     meta_name_value(ident, lit);\n }\n \n@@ -505,7 +503,7 @@ type variant = spanned[variant_];\n type view_item = spanned[view_item_];\n \n tag view_item_ {\n-    view_item_use(ident, (@meta_item)[], node_id);\n+    view_item_use(ident, vec[@meta_item], node_id);\n     view_item_import(ident, vec[ident], node_id);\n     view_item_import_glob(vec[ident], node_id);\n     view_item_export(ident, node_id);\n@@ -526,7 +524,7 @@ tag attr_style { attr_outer; attr_inner; }\n type attribute_ = rec(attr_style style, meta_item value);\n \n type item = rec(ident ident,\n-                attribute[] attrs,\n+                vec[attribute] attrs,\n                 node_id id, // For objs and resources, this is the type def_id\n                 item_ node,\n                 span span);\n@@ -544,7 +542,7 @@ tag item_ {\n }\n \n type native_item = rec(ident ident,\n-                       attribute[] attrs,\n+                       vec[attribute] attrs,\n                        native_item_ node,\n                        node_id id,\n                        span span);\n@@ -634,11 +632,11 @@ fn ternary_to_if(&@expr e) -> @ast::expr {\n \n // Path stringification\n fn path_to_str(&ast::path pth) -> str {\n-    auto result = str::connect_ivec(pth.node.idents, \"::\");\n-    if (ivec::len[@ast::ty](pth.node.types) > 0u) {\n+    auto result = str::connect(pth.node.idents, \"::\");\n+    if (vec::len[@ast::ty](pth.node.types) > 0u) {\n         fn f(&@ast::ty t) -> str { ret print::pprust::ty_to_str(*t); }\n         result += \"[\";\n-        result += str::connect_ivec(ivec::map(f, pth.node.types), \",\");\n+        result += str::connect(vec::map(f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;"}, {"sha": "a0ba306edfa5287bef6ee236cf240a7b0fa991fa", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,4 +1,3 @@\n-import std::ivec;\n import std::vec;\n import std::option;\n import std::map::hashmap;\n@@ -72,8 +71,8 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr, str error) -> str {\n fn expr_to_ident(&ext_ctxt cx, @ast::expr expr, str error) -> ast::ident {\n     alt(expr.node) {\n         case (ast::expr_path(?p)) {\n-            if (ivec::len(p.node.types) > 0u \n-                    || ivec::len(p.node.idents) != 1u) {\n+            if (vec::len(p.node.types) > 0u \n+                || vec::len(p.node.idents) != 1u) {\n                 cx.span_fatal(expr.span, error);\n             } else {\n                 ret p.node.idents.(0);"}, {"sha": "1ea2d6943744a58268ad809cb33673b32445049d", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -60,9 +60,10 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto binexpr = ast::expr_binary(ast::add, lhs, rhs);\n         ret @rec(id=cx.next_id(), node=binexpr, span=sp);\n     }\n-    fn make_path_expr(&ext_ctxt cx, span sp, &ast::ident[] idents)\n+    fn make_path_expr(&ext_ctxt cx, span sp, vec[ast::ident] idents)\n        -> @ast::expr {\n-        auto path = rec(idents=idents, types=~[]);\n+        let vec[@ast::ty] types = [];\n+        auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n         auto pathexpr = ast::expr_path(sp_path);\n         ret @rec(id=cx.next_id(), node=pathexpr, span=sp);\n@@ -72,7 +73,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n         ret @rec(id=cx.next_id(), node=vecexpr, span=sp);\n     }\n-    fn make_call(&ext_ctxt cx, span sp, &ast::ident[] fn_path,\n+    fn make_call(&ext_ctxt cx, span sp, vec[ast::ident] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n         auto callexpr = ast::expr_call(pathexpr, args);\n@@ -91,11 +92,11 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto recexpr = ast::expr_rec(astfields, option::none[@ast::expr]);\n         ret @rec(id=cx.next_id(), node=recexpr, span=sp);\n     }\n-    fn make_path_vec(str ident) -> str[] {\n+    fn make_path_vec(str ident) -> vec[str] {\n         // FIXME: #fmt can't currently be used from within std\n         // because we're explicitly referencing the 'std' crate here\n \n-        ret ~[\"std\", \"extfmt\", \"rt\", ident];\n+        ret [\"std\", \"extfmt\", \"rt\", ident];\n     }\n     fn make_rt_path_expr(&ext_ctxt cx, span sp, str ident) ->\n        @ast::expr {"}, {"sha": "e214524f0b799066227839c67ea12b7ca681b272", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,7 +1,6 @@\n use std;\n \n import codemap::span;\n-import std::ivec;\n import std::vec;\n import std::option;\n import vec::map;\n@@ -51,7 +50,7 @@ fn subst_ident(&ext_ctxt cx, &vec[@ast::expr] args,\n fn subst_path(&ext_ctxt cx, &vec[@ast::expr] args, \n               @vec[ident] param_names, &path_ p, ast_fold fld) -> path_ {\n     // Don't substitute into qualified names.\n-    if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n+    if (len(p.types) > 0u || len(p.idents) != 1u) { ret p; }\n     alt (position(p.idents.(0), *param_names)) {\n         case (some[uint](?idx)) {\n             alt (args.(idx).node) {\n@@ -76,8 +75,7 @@ fn subst_expr(&ext_ctxt cx, &vec[@ast::expr] args, @vec[ident] param_names,\n     ret alt(e) {\n         case (expr_path(?p)){\n             // Don't substitute into qualified names.\n-            if (ivec::len(p.node.types) > 0u ||\n-                    ivec::len(p.node.idents) != 1u) { e }\n+            if (len(p.node.types) > 0u || len(p.node.idents) != 1u) { e }\n             alt (position(p.node.idents.(0), *param_names)) {\n                 case (some[uint](?idx)) {\n                     args.(idx).node"}, {"sha": "f36eeddeeb673ddfe77c5c9bef132a6ad2045176", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,7 +1,6 @@\n import syntax::codemap::span;\n import ast::*;\n \n-import std::ivec;\n import std::vec;\n import std::option;\n import vec::map;\n@@ -103,7 +102,7 @@ fn fold_meta_item_(&@meta_item mi, ast_fold fld) -> @meta_item {\n                  case (meta_word(?id)) { meta_word(fld.fold_ident(id)) }\n                  case (meta_list(?id, ?mis)) {\n                      auto fold_meta_item = bind fold_meta_item_(_,fld);\n-                     meta_list(id, ivec::map(fold_meta_item, mis))\n+                     meta_list(id, map(fold_meta_item, mis))\n                  }\n                  case (meta_name_value(?id,?s)) {\n                      meta_name_value(fld.fold_ident(id),s)\n@@ -131,10 +130,10 @@ fn noop_fold_crate(&crate_ c, ast_fold fld) -> crate_ {\n     auto fold_meta_item = bind fold_meta_item_(_,fld);\n     auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n \n-    ret rec(directives=ivec::map(fld.fold_crate_directive, c.directives),\n+    ret rec(directives=map(fld.fold_crate_directive, c.directives),\n             module=fld.fold_mod(c.module),\n-            attrs=ivec::map(fold_attribute, c.attrs),\n-            config=ivec::map(fold_meta_item, c.config));\n+            attrs=map(fold_attribute, c.attrs),\n+            config=map(fold_meta_item, c.config));\n }\n \n fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld) \n@@ -145,7 +144,7 @@ fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld)\n                 }\n         case(cdir_dir_mod(?id,?fname,?cds,?attrs)) {\n             cdir_dir_mod(fld.fold_ident(id),fname,\n-                         ivec::map(fld.fold_crate_directive, cds), attrs)\n+                         map(fld.fold_crate_directive, cds), attrs)\n                 }\n         case(cdir_view_item(?vi)) { \n             cdir_view_item(fld.fold_view_item(vi))\n@@ -166,7 +165,7 @@ fn noop_fold_native_item(&@native_item ni, ast_fold fld) -> @native_item {\n     auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n \n     ret @rec(ident=fld.fold_ident(ni.ident),\n-             attrs=ivec::map(fold_attribute, ni.attrs),\n+             attrs=map(fold_attribute, ni.attrs),\n              node=alt (ni.node) {\n                  case (native_item_ty) { native_item_ty }\n                  case (native_item_fn(?st, ?fdec, ?typms)) {\n@@ -188,7 +187,7 @@ fn noop_fold_item(&@item i, ast_fold fld) -> @item {\n     auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n \n     ret @rec(ident=fld.fold_ident(i.ident),\n-             attrs=ivec::map(fold_attribute,i.attrs),\n+             attrs=map(fold_attribute,i.attrs),\n              id=i.id, node=fld.fold_item_underscore(i.node),\n              span=i.span);\n }\n@@ -486,8 +485,8 @@ fn noop_fold_ident(&ident i, ast_fold fld) -> ident {\n }\n \n fn noop_fold_path(&path_ p, ast_fold fld) -> path_ {\n-    ret rec(idents=ivec::map(fld.fold_ident, p.idents),\n-            types=ivec::map(fld.fold_ty, p.types));\n+    ret rec(idents=map(fld.fold_ident, p.idents),\n+            types=map(fld.fold_ty, p.types));\n }\n \n fn noop_fold_local(&local_ l, ast_fold fld) -> local_ {"}, {"sha": "ca26e9f8128da658a273a083d72d2836b6938b5f", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -24,16 +24,17 @@ type ctx =\n          mutable uint chpos,\n          ast::crate_cfg cfg);\n \n-fn eval_crate_directives(ctx cx, &(@ast::crate_directive)[] cdirs,\n+fn eval_crate_directives(ctx cx, vec[@ast::crate_directive] cdirs,\n                          str prefix, &mutable vec[@ast::view_item] view_items,\n                          &mutable vec[@ast::item] items) {\n     for (@ast::crate_directive sub_cdir in cdirs) {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n-fn eval_crate_directives_to_mod(ctx cx, &(@ast::crate_directive)[] cdirs,\n-                                str prefix) -> ast::_mod {\n+fn eval_crate_directives_to_mod(ctx cx,\n+                                vec[@ast::crate_directive] cdirs, str prefix)\n+   -> ast::_mod {\n     let vec[@ast::view_item] view_items = [];\n     let vec[@ast::item] items = [];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);"}, {"sha": "1e4ca951d07a6e45e2aaed05a637337d028a37da", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 65, "deletions": 100, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,6 +1,5 @@\n \n import std::io;\n-import std::ivec;\n import std::vec;\n import std::str;\n import std::option;\n@@ -410,18 +409,13 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n             // This is explicit type parameter instantiation.\n             auto seq = parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n                                         parse_ty, p);\n-\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto seq_ivec = ~[];\n-            for (@ast::ty typ in seq) { seq_ivec += ~[typ]; }\n-\n             alt (orig_t.node) {\n                 case (ast::ty_path(?pth, ?ann)) {\n                     auto hi = p.get_hi_pos();\n                     ret @spanned(lo, hi,\n                                  ast::ty_path(spanned(lo, hi,\n                                               rec(idents=pth.node.idents,\n-                                                  types=seq_ivec)),\n+                                                  types=seq)),\n                                               ann));\n                 }\n                 case (_) {\n@@ -591,24 +585,6 @@ fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n     ret v;\n }\n \n-fn parse_seq_to_end_ivec[T](token::token ket, option::t[token::token] sep,\n-                            fn(&parser)->T  f, &parser p) -> T[] {\n-    let bool first = true;\n-    let T[] v = ~[];\n-    while (p.peek() != ket) {\n-        alt (sep) {\n-            case (some(?t)) {\n-                if (first) { first = false; } else { expect(p, t); }\n-            }\n-            case (_) { }\n-        }\n-        v += ~[f(p)];\n-    }\n-    expect(p, ket);\n-    ret v;\n-}\n-\n-\n fn parse_seq[T](token::token bra, token::token ket,\n                 option::t[token::token] sep, fn(&parser) -> T  f, &parser p)\n    -> ast::spanned[vec[T]] {\n@@ -619,17 +595,6 @@ fn parse_seq[T](token::token bra, token::token ket,\n     ret spanned(lo, hi, result);\n }\n \n-fn parse_seq_ivec[T](token::token bra, token::token ket,\n-                     option::t[token::token] sep,\n-                     fn(&parser)->T  f, &parser p) -> ast::spanned[T[]] {\n-    auto lo = p.get_lo_pos();\n-    expect(p, bra);\n-    auto result = parse_seq_to_end_ivec[T](ket, sep, f, p);\n-    auto hi = p.get_hi_pos();\n-    ret spanned(lo, hi, result);\n-}\n-\n-\n fn parse_lit(&parser p) -> ast::lit {\n     auto sp = p.get_span();\n     let ast::lit_ lit = ast::lit_nil;\n@@ -672,20 +637,20 @@ fn is_ident(token::token t) -> bool {\n fn parse_path(&parser p) -> ast::path {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n-    let ast::ident[] ids = ~[];\n+    let vec[ast::ident] ids = [];\n     while (true) {\n         alt (p.peek()) {\n             case (token::IDENT(?i, _)) {\n                 hi = p.get_hi_pos();\n-                ids += ~[p.get_str(i)];\n+                ids += [p.get_str(i)];\n                 p.bump();\n                 if (p.peek() == token::MOD_SEP) { p.bump(); } else { break; }\n             }\n             case (_) { break; }\n         }\n     }\n     hi = p.get_hi_pos();\n-    ret spanned(lo, hi, rec(idents=ids, types=~[]));\n+    ret spanned(lo, hi, rec(idents=ids, types=[]));\n }\n \n fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n@@ -694,13 +659,8 @@ fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n     if (p.peek() == token::LBRACKET) {\n         auto seq = parse_seq(token::LBRACKET, token::RBRACKET,\n                              some(token::COMMA), parse_ty, p);\n-\n-        // FIXME: Remove this vec->ivec conversion.\n-        auto seq_ivec = ~[];\n-        for (@ast::ty typ in seq.node) { seq_ivec += ~[typ]; }\n-\n         auto hi = p.get_hi_pos();\n-        path = spanned(lo, hi, rec(idents=path.node.idents, types=seq_ivec));\n+        path = spanned(lo, hi, rec(idents=path.node.idents, types=seq.node));\n     }\n     ret path;\n }\n@@ -995,7 +955,7 @@ fn parse_syntax_ext(&parser p) -> @ast::expr {\n \n fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     auto pth = parse_path(p);\n-    if (ivec::len(pth.node.idents) == 0u) {\n+    if (vec::len(pth.node.idents) == 0u) {\n         p.fatal(\"expected a syntax expander name\");\n     }\n     auto es = parse_seq(token::LPAREN, token::RPAREN,\n@@ -1015,7 +975,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n fn expand_syntax_ext(&parser p, span sp, &ast::path path,\n                      vec[@ast::expr] args, option::t[str] body) ->\n    ast::expr_ {\n-    assert (ivec::len(path.node.idents) > 0u);\n+    assert (vec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n     alt (p.get_syntax_expanders().find(extname)) {\n         case (none) { p.fatal(\"unknown syntax expander: '\" + extname + \"'\"); }\n@@ -1509,7 +1469,7 @@ fn parse_stmt(&parser p) -> @ast::stmt {\n }\n \n fn parse_crate_stmt(&parser p) -> @ast::stmt {\n-    auto cdir = parse_crate_directive(p, ~[]);\n+    auto cdir = parse_crate_directive(p, []);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast::stmt_crate_directive(@cdir));\n }\n@@ -1527,7 +1487,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n         auto item_attrs;\n         alt (parse_outer_attrs_or_ext(p)) {\n             case (none) {\n-                item_attrs = ~[];\n+                item_attrs = [];\n             }\n             case (some(left(?attrs))) {\n                 item_attrs = attrs;\n@@ -1541,7 +1501,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n         auto maybe_item = parse_item(p, item_attrs);\n \n         // If we have attributes then we should have an item\n-        if (ivec::len(item_attrs) > 0u) {\n+        if (vec::len(item_attrs) > 0u) {\n             alt (maybe_item) {\n                 case (got_item(_)) { /* fallthrough */ }\n                 case (_) {\n@@ -1747,7 +1707,7 @@ fn parse_fn_header(&parser p) -> tup(ast::ident, vec[ast::ty_param]) {\n }\n \n fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n-           &ast::attribute[] attrs) -> @ast::item {\n+           &vec[ast::attribute] attrs) -> @ast::item {\n     ret @rec(ident=ident,\n              attrs=attrs,\n              id=p.get_id(),\n@@ -1756,7 +1716,7 @@ fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n }\n \n fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto,\n-                         &ast::attribute[] attrs) -> @ast::item {\n+                         vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto f = parse_fn(p, proto, purity);\n@@ -1807,7 +1767,7 @@ fn parse_dtor(&parser p) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n-fn parse_item_obj(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n+fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n    @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n@@ -1830,7 +1790,7 @@ fn parse_item_obj(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n                                                 p.get_id()), attrs);\n }\n \n-fn parse_item_res(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n+fn parse_item_res(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n    @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n@@ -1852,8 +1812,8 @@ fn parse_item_res(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n }\n \n fn parse_mod_items(&parser p, token::token term,\n-                   &ast::attribute[] first_item_attrs) -> ast::_mod {\n-    auto view_items = if (ivec::len(first_item_attrs) == 0u) {\n+                   vec[ast::attribute] first_item_attrs) -> ast::_mod {\n+    auto view_items = if (vec::len(first_item_attrs) == 0u) {\n         parse_view(p)\n     } else {\n         // Shouldn't be any view items since we've already parsed an item attr\n@@ -1863,7 +1823,7 @@ fn parse_mod_items(&parser p, token::token term,\n     auto initial_attrs = first_item_attrs;\n     while (p.peek() != term) {\n         auto attrs = initial_attrs + parse_outer_attributes(p);\n-        initial_attrs = ~[];\n+        initial_attrs = [];\n         alt (parse_item(p, attrs)) {\n             case (got_item(?i)) { vec::push(items, i); }\n             case (_) {\n@@ -1875,7 +1835,7 @@ fn parse_mod_items(&parser p, token::token term,\n     ret rec(view_items=view_items, items=items);\n }\n \n-fn parse_item_const(&parser p, &ast::attribute[] attrs) -> @ast::item {\n+fn parse_item_const(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ty = parse_ty(p);\n     auto id = parse_value_ident(p);\n@@ -1886,20 +1846,21 @@ fn parse_item_const(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n }\n \n-fn parse_item_mod(&parser p, &ast::attribute[] attrs) -> @ast::item {\n+fn parse_item_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     expect(p, token::LBRACE);\n     auto inner_attrs = parse_inner_attrs_and_next(p);\n     auto first_item_outer_attrs = inner_attrs._1;\n-    auto m = parse_mod_items(p, token::RBRACE, first_item_outer_attrs);\n+    auto m = parse_mod_items(p, token::RBRACE,\n+                             first_item_outer_attrs);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs._0);\n }\n \n-fn parse_item_native_type(&parser p, &ast::attribute[] attrs)\n-        -> @ast::native_item {\n+fn parse_item_native_type(&parser p,\n+                          &vec[ast::attribute] attrs) -> @ast::native_item {\n     auto t = parse_type_decl(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n@@ -1910,8 +1871,8 @@ fn parse_item_native_type(&parser p, &ast::attribute[] attrs)\n              span=rec(lo=t._0, hi=hi));\n }\n \n-fn parse_item_native_fn(&parser p, &ast::attribute[] attrs)\n-        -> @ast::native_item {\n+fn parse_item_native_fn(&parser p,\n+                        &vec[ast::attribute] attrs) -> @ast::native_item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n@@ -1929,8 +1890,8 @@ fn parse_item_native_fn(&parser p, &ast::attribute[] attrs)\n              span=rec(lo=lo, hi=hi));\n }\n \n-fn parse_native_item(&parser p, &ast::attribute[] attrs)\n-        -> @ast::native_item {\n+fn parse_native_item(&parser p,\n+                     &vec[ast::attribute] attrs) -> @ast::native_item {\n     parse_layer(p);\n     if (eat_word(p, \"type\")) {\n         ret parse_item_native_type(p, attrs);\n@@ -1940,9 +1901,9 @@ fn parse_native_item(&parser p, &ast::attribute[] attrs)\n }\n \n fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n-                          &ast::attribute[] first_item_attrs)\n-        -> ast::native_mod {\n-    auto view_items = if (ivec::len(first_item_attrs) == 0u) {\n+                          &vec[ast::attribute] first_item_attrs) ->\n+   ast::native_mod {\n+    auto view_items = if (vec::len(first_item_attrs) == 0u) {\n         parse_native_view(p)\n     } else {\n         // Shouldn't be any view items since we've already parsed an item attr\n@@ -1952,7 +1913,7 @@ fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n     auto initial_attrs = first_item_attrs;\n     while (p.peek() != token::RBRACE) {\n         auto attrs = initial_attrs + parse_outer_attributes(p);\n-        initial_attrs = ~[];\n+        initial_attrs = [];\n         items += [parse_native_item(p, attrs)];\n     }\n     ret rec(native_name=native_name,\n@@ -1961,7 +1922,7 @@ fn parse_native_mod_items(&parser p, &str native_name, ast::native_abi abi,\n             items=items);\n }\n \n-fn parse_item_native_mod(&parser p, &ast::attribute[] attrs) -> @ast::item {\n+fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto abi = ast::native_abi_cdecl;\n     if (!is_word(p, \"mod\")) {\n@@ -2001,7 +1962,7 @@ fn parse_type_decl(&parser p) -> tup(uint, ast::ident) {\n     ret tup(lo, id);\n }\n \n-fn parse_item_type(&parser p, &ast::attribute[] attrs) -> @ast::item {\n+fn parse_item_type(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto t = parse_type_decl(p);\n     auto tps = parse_ty_params(p);\n     expect(p, token::EQ);\n@@ -2011,7 +1972,7 @@ fn parse_item_type(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     ret mk_item(p, t._0, hi, t._1, ast::item_ty(ty, tps), attrs);\n }\n \n-fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n+fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n@@ -2090,7 +2051,7 @@ fn parse_auth(&parser p) -> ast::_auth {\n \n tag parsed_item { got_item(@ast::item); no_item; fn_no_item; }\n \n-fn parse_item(&parser p, &ast::attribute[] attrs) -> parsed_item {\n+fn parse_item(&parser p, vec[ast::attribute] attrs) -> parsed_item {\n     if (eat_word(p, \"const\")) {\n         ret got_item(parse_item_const(p, attrs));\n     } else if (eat_word(p, \"fn\")) {\n@@ -2124,15 +2085,16 @@ fn parse_item(&parser p, &ast::attribute[] attrs) -> parsed_item {\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option::t[either::t[ast::attribute[], @ast::expr]];\n+type attr_or_ext = option::t[either::t[vec[ast::attribute],\n+                                       @ast::expr]];\n \n fn parse_outer_attrs_or_ext(&parser p) -> attr_or_ext {\n     if (p.peek() == token::POUND) {\n         auto lo = p.get_lo_pos();\n         p.bump();\n         if (p.peek() == token::LBRACKET) {\n             auto first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n-            ret some(left(~[first_attr] + parse_outer_attributes(p)));\n+            ret some(left([first_attr] + parse_outer_attributes(p)));\n         } else {\n             ret some(right(parse_syntax_ext_naked(p, lo)));\n         }\n@@ -2142,10 +2104,10 @@ fn parse_outer_attrs_or_ext(&parser p) -> attr_or_ext {\n }\n \n // Parse attributes that appear before an item\n-fn parse_outer_attributes(&parser p) -> ast::attribute[] {\n-    let ast::attribute[] attrs = ~[];\n+fn parse_outer_attributes(&parser p) -> vec[ast::attribute] {\n+    let vec[ast::attribute] attrs = [];\n     while (p.peek() == token::POUND) {\n-        attrs += ~[parse_attribute(p, ast::attr_outer)];\n+        attrs += [parse_attribute(p, ast::attr_outer)];\n     }\n     ret attrs;\n }\n@@ -2171,22 +2133,22 @@ fn parse_attribute_naked(&parser p, ast::attr_style style,\n // next item (since we can't know whether the attribute is an inner attribute\n // of the containing item or an outer attribute of the first contained item\n // until we see the semi).\n-fn parse_inner_attrs_and_next(&parser p) -> tup(ast::attribute[],\n-                                                ast::attribute[]) {\n-    let ast::attribute[] inner_attrs = ~[];\n-    let ast::attribute[] next_outer_attrs = ~[];\n+fn parse_inner_attrs_and_next(&parser p) -> tup(vec[ast::attribute],\n+                                                vec[ast::attribute]) {\n+    let vec[ast::attribute] inner_attrs = [];\n+    let vec[ast::attribute] next_outer_attrs = [];\n     while (p.peek() == token::POUND) {\n         auto attr = parse_attribute(p, ast::attr_inner);\n         if (p.peek() == token::SEMI) {\n             p.bump();\n-            inner_attrs += ~[attr];\n+            inner_attrs += [attr];\n         } else {\n             // It's not really an inner attribute\n             auto outer_attr = spanned(attr.span.lo,\n                                       attr.span.hi,\n                                       rec(style=ast::attr_outer,\n                                           value=attr.node.value));\n-            next_outer_attrs += ~[outer_attr];\n+            next_outer_attrs += [outer_attr];\n             break;\n         }\n     }\n@@ -2215,15 +2177,15 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n     }\n }\n \n-fn parse_meta_seq(&parser p) -> (@ast::meta_item)[] {\n-    ret parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                       parse_meta_item, p).node;\n+fn parse_meta_seq(&parser p) -> vec[@ast::meta_item] {\n+    ret parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                  parse_meta_item, p).node;\n }\n \n-fn parse_optional_meta(&parser p) -> (@ast::meta_item)[] {\n+fn parse_optional_meta(&parser p) -> vec[@ast::meta_item] {\n     alt (p.peek()) {\n         case (token::LPAREN) { ret parse_meta_seq(p); }\n-        case (_) { ret ~[]; }\n+        case (_) { let vec[@ast::meta_item] v = []; ret v; }\n     }\n }\n \n@@ -2233,7 +2195,8 @@ fn parse_use(&parser p) -> @ast::view_item {\n     auto metadata = parse_optional_meta(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto use_decl = ast::view_item_use(ident, metadata, p.get_id());\n+    auto use_decl =\n+        ast::view_item_use(ident, metadata, p.get_id());\n     ret @spanned(lo, hi, use_decl);\n }\n \n@@ -2366,7 +2329,8 @@ fn parse_crate_from_source_file(&str input, &ast::crate_cfg cfg,\n     auto first_item_outer_attrs = crate_attrs._1;\n     auto m = parse_mod_items(p, token::EOF,\n                              first_item_outer_attrs);\n-    ret @spanned(lo, p.get_lo_pos(), rec(directives=~[],\n+    let vec[@ast::crate_directive] cdirs = [];\n+    ret @spanned(lo, p.get_lo_pos(), rec(directives=cdirs,\n                                          module=m,\n                                          attrs=crate_attrs._0,\n                                          config=p.get_cfg()));\n@@ -2387,13 +2351,14 @@ fn parse_str(&parser p) -> ast::ident {\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-fn parse_crate_directive(&parser p, &ast::attribute[] first_outer_attr)\n+fn parse_crate_directive(&parser p, vec[ast::attribute] first_outer_attr)\n     -> ast::crate_directive {\n \n     // Collect the next attributes\n-    auto outer_attrs = first_outer_attr + parse_outer_attributes(p);\n+    auto outer_attrs = first_outer_attr\n+        + parse_outer_attributes(p);\n     // In a crate file outer attributes are only going to apply to mods\n-    auto expect_mod = ivec::len(outer_attrs) > 0u;\n+    auto expect_mod = vec::len(outer_attrs) > 0u;\n \n     auto lo = p.get_lo_pos();\n     if (expect_mod || is_word(p, \"mod\")) {\n@@ -2448,20 +2413,20 @@ fn parse_crate_directive(&parser p, &ast::attribute[] first_outer_attr)\n }\n \n fn parse_crate_directives(&parser p, token::token term,\n-                          &ast::attribute[] first_outer_attr)\n-        -> (@ast::crate_directive)[] {\n+                          vec[ast::attribute] first_outer_attr) ->\n+   vec[@ast::crate_directive] {\n \n     // This is pretty ugly. If we have an outer attribute then we can't accept\n     // seeing the terminator next, so if we do see it then fail the same way\n     // parse_crate_directive would\n-    if (ivec::len(first_outer_attr) > 0u && p.peek() == term) {\n+    if (vec::len(first_outer_attr) > 0u && p.peek() == term) {\n         expect_word(p, \"mod\");\n     }\n \n-    let (@ast::crate_directive)[] cdirs = ~[];\n+    let vec[@ast::crate_directive] cdirs = [];\n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p, first_outer_attr);\n-        cdirs += ~[cdir];\n+        vec::push(cdirs, cdir);\n     }\n     ret cdirs;\n }"}, {"sha": "86ae4cbd2955e9170e8e9ff5efc001678daf60b0", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,10 +1,9 @@\n \n-import std::ivec;\n-import std::int;\n-import std::io;\n-import std::str;\n import std::uint;\n+import std::int;\n import std::vec;\n+import std::str;\n+import std::io;\n import std::option;\n import parse::lexer;\n import syntax::codemap::codemap;\n@@ -207,17 +206,6 @@ fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op) {\n     end(s);\n }\n \n-fn commasep_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op) {\n-    box(s, 0u, b);\n-    auto first = true;\n-    for (IN elt in elts) {\n-        if (first) { first = false; } else { word_space(s, \",\"); }\n-        op(s, elt);\n-    }\n-    end(s);\n-}\n-\n-\n fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op,\n                      fn(&IN) -> codemap::span  get_span) {\n     box(s, 0u, b);\n@@ -242,7 +230,7 @@ fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-fn print_mod(&ps s, ast::_mod _mod, &ast::attribute[] attrs) {\n+fn print_mod(&ps s, ast::_mod _mod, &vec[ast::attribute] attrs) {\n     print_inner_attributes(s, attrs);\n     for (@ast::view_item vitem in _mod.view_items) {\n         print_view_item(s, vitem);\n@@ -533,7 +521,7 @@ fn print_item(&ps s, &@ast::item item) {\n     s.ann.post(ann_node);\n }\n \n-fn print_outer_attributes(&ps s, &ast::attribute[] attrs) {\n+fn print_outer_attributes(&ps s, vec[ast::attribute] attrs) {\n     auto count = 0;\n     for (ast::attribute attr in attrs) {\n         alt (attr.node.style) {\n@@ -544,7 +532,7 @@ fn print_outer_attributes(&ps s, &ast::attribute[] attrs) {\n     if (count > 0) { hardbreak_if_not_bol(s); }\n }\n \n-fn print_inner_attributes(&ps s, &ast::attribute[] attrs) {\n+fn print_inner_attributes(&ps s, vec[ast::attribute] attrs) {\n     auto count = 0;\n     for (ast::attribute attr in attrs) {\n         alt (attr.node.style) {\n@@ -1025,9 +1013,9 @@ fn print_path(&ps s, &ast::path path) {\n         if (first) { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n-    if (ivec::len(path.node.types) > 0u) {\n+    if (vec::len(path.node.types) > 0u) {\n         word(s.s, \"[\");\n-        commasep_ivec(s, inconsistent, path.node.types, print_boxed_type);\n+        commasep(s, inconsistent, path.node.types, print_boxed_type);\n         word(s.s, \"]\");\n     }\n }\n@@ -1118,7 +1106,7 @@ fn print_meta_item(&ps s, &@ast::meta_item item) {\n         case (ast::meta_list(?name, ?items)) {\n             word(s.s, name);\n             popen(s);\n-            commasep_ivec(s, consistent, items, print_meta_item);\n+            commasep(s, consistent, items, print_meta_item);\n             pclose(s);\n         }\n     }\n@@ -1132,9 +1120,9 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n         case (ast::view_item_use(?id, ?mta, _)) {\n             head(s, \"use\");\n             word(s.s, id);\n-            if (ivec::len(mta) > 0u) {\n+            if (vec::len(mta) > 0u) {\n                 popen(s);\n-                commasep_ivec(s, consistent, mta, print_meta_item);\n+                commasep(s, consistent, mta, print_meta_item);\n                 pclose(s);\n             }\n         }\n@@ -1433,7 +1421,7 @@ fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n \n \n fn constr_args_to_str[T](fn(&T) -> str  f,\n-                         &(@ast::constr_arg_general[T])[] args) -> str {\n+                         &vec[@ast::constr_arg_general[T]] args) -> str {\n     auto comma = false;\n     auto s = \"(\";\n     for (@ast::constr_arg_general[T] a in args) {\n@@ -1459,13 +1447,8 @@ fn constr_arg_to_str[T](fn(&T) -> str  f, &ast::constr_arg_general_[T] c) ->\n fn uint_to_str(&uint i) -> str { ret uint::str(i); }\n \n fn ast_constr_to_str(&@ast::constr c) -> str {\n-    // TODO: Remove this vec->ivec conversion.\n-    auto cag_ivec = ~[];\n-    for (@ast::constr_arg_general[uint] cag in c.node.args) {\n-        cag_ivec += ~[cag];\n-    }\n     ret ast::path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, cag_ivec);\n+            constr_args_to_str(uint_to_str, c.node.args);\n }\n \n fn ast_constrs_str(&vec[@ast::constr] constrs) -> str {"}, {"sha": "e096b953a8915096b473f1771d6c0664ccd8698c", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,7 +1,7 @@\n // An \"interner\" is a data structure that associates values with uint tags and\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n-import std::ivec;\n+import std::vec;\n import std::map;\n import std::map::hashmap;\n import std::map::hashfn;\n@@ -12,24 +12,24 @@ import std::option::some;\n \n type interner[T] =\n     rec(hashmap[T, uint] map,\n-        mutable T[] vect,\n+        mutable vec[T] vect,\n         hashfn[T] hasher,\n         eqfn[T] eqer);\n \n fn mk[T](hashfn[T] hasher, eqfn[T] eqer) -> interner[T] {\n     auto m = map::mk_hashmap[T, uint](hasher, eqer);\n-    ret rec(map=m, mutable vect=~[], hasher=hasher, eqer=eqer);\n+    let vec[T] vect = [];\n+    ret rec(map=m, mutable vect=vect, hasher=hasher, eqer=eqer);\n }\n fn intern[T](&interner[T] itr, &T val) -> uint {\n     alt (itr.map.find(val)) {\n         case (some(?idx)) { ret idx; }\n         case (none) {\n-            auto new_idx = ivec::len[T](itr.vect);\n+            auto new_idx = vec::len[T](itr.vect);\n             itr.map.insert(val, new_idx);\n-            itr.vect += ~[val];\n+            itr.vect += [val];\n             ret new_idx;\n         }\n     }\n }\n fn get[T](&interner[T] itr, uint idx) -> T { ret itr.vect.(idx); }\n-"}, {"sha": "e3eb707dbf5fa1d784a3a73b1344ff224940ae92", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=bbdba21b1f3c7dfc4c0bac3525cc35939ae8ca4c", "patch": "@@ -1,5 +1,4 @@\n import std::io;\n-import std::ivec;\n import std::vec;\n import std::str;\n import std::int;\n@@ -47,7 +46,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n     }\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  &arg[] inputs, t output, ast::controlflow cf,\n-                 &(@constr_def)[] constrs) -> str {\n+                 &vec[@constr_def] constrs) -> str {\n         auto s;\n         alt (proto) {\n             case (ast::proto_iter) { s = \"iter\"; }\n@@ -119,9 +118,9 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             // The user should never see this if the cname is set properly!\n \n             s += \"<tag#\" + int::str(id._0) + \":\" + int::str(id._1) + \">\";\n-            if (ivec::len[t](tps) > 0u) {\n-                let vec[str] strs = [];\n-                for (t typ in tps) { strs += [ty_to_str(cx, typ)]; }\n+            if (vec::len[t](tps) > 0u) {\n+                auto f = bind ty_to_str(cx, _);\n+                auto strs = vec::map[t, str](f, tps);\n                 s += \"[\" + str::connect(strs, \",\") + \"]\";\n             }\n         }\n@@ -130,13 +129,12 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_native_fn(_, ?inputs, ?output)) {\n             s += fn_to_str(cx, ast::proto_fn, none, inputs, output,\n-                           ast::return, ~[]);\n+                           ast::return, []);\n         }\n         case (ty_obj(?meths)) {\n-            // TODO: Remove this ivec->vec conversion.\n-            auto strs = [];\n-            for (method m in meths) { strs += [method_to_str(cx, m)]; }\n-            s += \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\";\n+            auto f = bind method_to_str(cx, _);\n+            auto m = vec::map[method, str](f, meths);\n+            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n         case (ty_res(?id, _, _)) {\n             s += \"<resource#\" + int::str(id._0) + \":\" + int::str(id._1) + \">\";\n@@ -163,7 +161,7 @@ fn constr_to_str(&@constr_def c) -> str {\n         pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n-fn constrs_str(&(@constr_def)[] constrs) -> str {\n+fn constrs_str(&vec[@constr_def] constrs) -> str {\n     auto s = \"\";\n     auto colon = true;\n     for (@constr_def c in constrs) {"}]}