{"sha": "0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZWIzMGRlNmQ1YmI4MmIxNDE1OWYzN2RkNjZhM2ZkNmJjZDc1NmM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2019-01-28T22:59:30Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2019-01-28T23:00:25Z"}, "message": "add tests to a few edge cases in method lookup\n\nThese aren't fixed by this PR, but were broken in a few older attempts\nat it. Make sure they don't regress.", "tree": {"sha": "8501627ac0af1d31bf1fa3b855a903bfc440b1e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8501627ac0af1d31bf1fa3b855a903bfc440b1e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "html_url": "https://github.com/rust-lang/rust/commit/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d26c7504365127c143d540094516f0a2dd67442", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d26c7504365127c143d540094516f0a2dd67442", "html_url": "https://github.com/rust-lang/rust/commit/8d26c7504365127c143d540094516f0a2dd67442"}], "stats": {"total": 290, "additions": 290, "deletions": 0}, "files": [{"sha": "a5dae1c71cdaaf5ed7206aca3afc6499ed00acb6", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs?ref=0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "patch": "@@ -0,0 +1,177 @@\n+#![feature(arbitrary_self_types, coerce_unsized, dispatch_from_dyn, unsize, unsized_locals)]\n+\n+// This tests a few edge-cases around `arbitrary_self_types`. Most specifically,\n+// it checks that the `ObjectCandidate` you get from method matching can't\n+// match a trait with the same DefId as a supertrait but a bad type parameter.\n+\n+use std::marker::PhantomData;\n+\n+mod internal {\n+    use std::ops::{CoerceUnsized, Deref, DispatchFromDyn};\n+    use std::marker::{PhantomData, Unsize};\n+\n+    pub struct Smaht<T: ?Sized, MISC>(pub Box<T>, pub PhantomData<MISC>);\n+\n+    impl<T: ?Sized, MISC> Deref for Smaht<T, MISC> {\n+        type Target = T;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T: ?Sized + Unsize<U>, U: ?Sized, MISC> CoerceUnsized<Smaht<U, MISC>>\n+        for Smaht<T, MISC>\n+    {}\n+    impl<T: ?Sized + Unsize<U>, U: ?Sized, MISC> DispatchFromDyn<Smaht<U, MISC>>\n+        for Smaht<T, MISC>\n+    {}\n+\n+    pub trait Foo: X<u32> {}\n+    pub trait X<T> {\n+        fn foo(self: Smaht<Self, T>) -> T;\n+    }\n+\n+    impl X<u32> for () {\n+        fn foo(self: Smaht<Self, u32>) -> u32 {\n+            0\n+        }\n+    }\n+\n+    pub trait Marker {}\n+    impl Marker for dyn Foo {}\n+    impl<T: Marker + ?Sized> X<u64> for T {\n+        fn foo(self: Smaht<Self, u64>) -> u64 {\n+            1\n+        }\n+    }\n+\n+    impl Deref for dyn Foo {\n+        type Target = ();\n+        fn deref(&self) -> &() { &() }\n+    }\n+\n+    impl Foo for () {}\n+}\n+\n+pub trait FinalFoo {\n+    fn foo(&self) -> u8;\n+}\n+\n+impl FinalFoo for () {\n+    fn foo(&self) -> u8 { 0 }\n+}\n+\n+mod nuisance_foo {\n+    pub trait NuisanceFoo {\n+        fn foo(self);\n+    }\n+\n+    impl<T: ?Sized> NuisanceFoo for T {\n+        fn foo(self) {}\n+    }\n+}\n+\n+\n+fn objectcandidate_impl() {\n+    let x: internal::Smaht<(), u32> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u32> = x;\n+\n+    // This picks `<dyn internal::Foo as X<u32>>::foo` via `ObjectCandidate`.\n+    //\n+    // The `TraitCandidate` is not relevant because `X` is not in scope.\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u32`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u32\n+}\n+\n+fn traitcandidate_impl() {\n+    use internal::X;\n+\n+    let x: internal::Smaht<(), u64> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u64> = x;\n+\n+    // This picks `<dyn internal::Foo as X<u64>>::foo` via `TraitCandidate`.\n+    //\n+    // The `ObjectCandidate` does not apply, as it only applies to\n+    // `X<u32>` (and not `X<u64>`).\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u64`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u64\n+}\n+\n+fn traitcandidate_impl_with_nuisance() {\n+    use internal::X;\n+    use nuisance_foo::NuisanceFoo;\n+\n+    let x: internal::Smaht<(), u64> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u64> = x;\n+\n+    // This picks `<dyn internal::Foo as X<u64>>::foo` via `TraitCandidate`.\n+    //\n+    // The `ObjectCandidate` does not apply, as it only applies to\n+    // `X<u32>` (and not `X<u64>`).\n+    //\n+    // The NuisanceFoo impl has the same priority as the `X` impl,\n+    // so we get a conflict.\n+    let z = x.foo(); //~ ERROR multiple applicable items in scope\n+}\n+\n+\n+fn neither_impl() {\n+    let x: internal::Smaht<(), u64> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u64> = x;\n+\n+    // This can't pick the `TraitCandidate` impl, because `Foo` is not\n+    // imported. However, this also can't pick the `ObjectCandidate`\n+    // impl, because it only applies to `X<u32>` (and not `X<u64>`).\n+    //\n+    // Therefore, neither of the candidates is applicable, and we pick\n+    // the `FinalFoo` impl after another deref, which will return `u8`.\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u8`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u8\n+}\n+\n+fn both_impls() {\n+    use internal::X;\n+\n+    let x: internal::Smaht<(), u32> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u32> = x;\n+\n+    // This can pick both the `TraitCandidate` and the `ObjectCandidate` impl.\n+    //\n+    // However, the `ObjectCandidate` is considered an \"inherent candidate\",\n+    // and therefore has priority over both the `TraitCandidate` as well as\n+    // any other \"nuisance\" candidate\" (if present).\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u32`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u32\n+}\n+\n+\n+fn both_impls_with_nuisance() {\n+    // Similar to the `both_impls` example, except with a nuisance impl to\n+    // make sure the `ObjectCandidate` indeed has a higher priority.\n+\n+    use internal::X;\n+    use nuisance_foo::NuisanceFoo;\n+\n+    let x: internal::Smaht<(), u32> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u32> = x;\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u32`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u32\n+}\n+\n+fn main() {\n+}"}, {"sha": "2d8449b96de410202d0026e357df0ead1757902b", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr?ref=0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "patch": "@@ -0,0 +1,72 @@\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:85:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:102:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u64\n+   |\n+   = note: expected type `()`\n+              found type `u64`\n+\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:120:15\n+   |\n+LL |     let z = x.foo(); //~ ERROR multiple applicable items in scope\n+   |               ^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `internal::X` for the type `_`\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:43:9\n+   |\n+LL |         fn foo(self: Smaht<Self, u64>) -> u64 {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: candidate #2 is defined in an impl of the trait `nuisance_foo::NuisanceFoo` for the type `_`\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:70:9\n+   |\n+LL |         fn foo(self) {}\n+   |         ^^^^^^^^^^^^\n+note: candidate #3 is defined in the trait `FinalFoo`\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:57:5\n+   |\n+LL |     fn foo(&self) -> u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `FinalFoo::foo(x)` instead\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:137:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u8\n+   |\n+   = note: expected type `()`\n+              found type `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:155:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:172:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0034, E0308.\n+For more information about an error, try `rustc --explain E0034`."}, {"sha": "da2f13f5a2f8a5304a1be4d60fb607cc63105b25", "filename": "src/test/ui/methods/method-trait-object-with-hrtb.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/src%2Ftest%2Fui%2Fmethods%2Fmethod-trait-object-with-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c/src%2Ftest%2Fui%2Fmethods%2Fmethod-trait-object-with-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-trait-object-with-hrtb.rs?ref=0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "patch": "@@ -0,0 +1,41 @@\n+// compile-pass\n+\n+// Check that method probing ObjectCandidate works in the presence of\n+// auto traits and/or HRTBs.\n+\n+mod internal {\n+    pub trait MyObject<'a> {\n+        type Output;\n+\n+        fn foo(&self) -> Self::Output;\n+    }\n+\n+    impl<'a> MyObject<'a> for () {\n+        type Output = &'a u32;\n+\n+        fn foo(&self) -> Self::Output { &4 }\n+    }\n+}\n+\n+fn t1(d: &dyn for<'a> internal::MyObject<'a, Output=&'a u32>) {\n+    d.foo();\n+}\n+\n+fn t2(d: &dyn internal::MyObject<'static, Output=&'static u32>) {\n+    d.foo();\n+}\n+\n+fn t3(d: &(dyn for<'a> internal::MyObject<'a, Output=&'a u32> + Sync)) {\n+    d.foo();\n+}\n+\n+fn t4(d: &(dyn internal::MyObject<'static, Output=&'static u32> + Sync)) {\n+    d.foo();\n+}\n+\n+fn main() {\n+    t1(&());\n+    t2(&());\n+    t3(&());\n+    t4(&());\n+}"}]}