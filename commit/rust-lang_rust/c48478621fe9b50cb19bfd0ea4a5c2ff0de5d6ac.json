{"sha": "c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ODQ3ODYyMWZlOWI1MGNiMTliZmQwZWE0YTVjMmZmMGRlNWQ2YWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-08T21:19:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-08T21:19:31Z"}, "message": "Merge #7924\n\n7924: Use upstream cov-mark r=matklad a=lnicola\n\nCloses #7922\r\n\r\nBut doesn't remove any dependency, unfortunately.\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "3905029a42c8bb6c5d363753b34cd6b5dd43f4d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3905029a42c8bb6c5d363753b34cd6b5dd43f4d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRpTjCRBK7hj4Ov3rIwAAdHIIAKgOn4tMDG2ANfynF1qEXaLX\nV9+OU+IGIJUUnc+DG8clP1mWIUyEajq+e/PgDXCtRR7nWK/rkKj18S5FaGwvoZ9h\n1mD6WXVv5Iq2Tb/oEgt5iUcEnbciMvXZ2D7oyNpA3JPt38wWOyQevjKidF2My7F/\nPlPdO8FNpon144Lc0BaFXA2FkEYxGGan3bFR1zS9Y/6AI06u6FJI7xceArQoZycH\nAgKmpGpE5fHADAll0S7h7Sg7CpcBXoRpf0lp9Dv7YovWuRyykgOtJXNwCKdwgGpC\nwWWIA6rh+VIa3wUgwQmQ++m6ZlMJIJYqAoATnM7eQ9RfUjvBJ6GUCMgAzTtQFqE=\n=YzY4\n-----END PGP SIGNATURE-----\n", "payload": "tree 3905029a42c8bb6c5d363753b34cd6b5dd43f4d5\nparent c5189a22ccf4c28e309e4189defbb88b83bb2aea\nparent fc9eed4836dfc88fe2893c81b015ab440cea2ba6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615238371 +0000\ncommitter GitHub <noreply@github.com> 1615238371 +0000\n\nMerge #7924\n\n7924: Use upstream cov-mark r=matklad a=lnicola\n\nCloses #7922\r\n\r\nBut doesn't remove any dependency, unfortunately.\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "html_url": "https://github.com/rust-lang/rust/commit/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5189a22ccf4c28e309e4189defbb88b83bb2aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5189a22ccf4c28e309e4189defbb88b83bb2aea", "html_url": "https://github.com/rust-lang/rust/commit/c5189a22ccf4c28e309e4189defbb88b83bb2aea"}, {"sha": "fc9eed4836dfc88fe2893c81b015ab440cea2ba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9eed4836dfc88fe2893c81b015ab440cea2ba6", "html_url": "https://github.com/rust-lang/rust/commit/fc9eed4836dfc88fe2893c81b015ab440cea2ba6"}], "stats": {"total": 868, "additions": 354, "deletions": 514}, "files": [{"sha": "51a07abe3d8a90430b777a4d2d303fd4bc9b84cf", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -242,6 +242,12 @@ dependencies = [\n  \"rustc-hash\",\n ]\n \n+[[package]]\n+name = \"cov-mark\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9ffa3d3e0138386cd4361f63537765cac7ee40698028844635a54495a92f67f3\"\n+\n [[package]]\n name = \"crc32fast\"\n version = \"1.2.1\"\n@@ -492,6 +498,7 @@ dependencies = [\n  \"anymap\",\n  \"base_db\",\n  \"cfg\",\n+ \"cov-mark\",\n  \"drop_bomb\",\n  \"either\",\n  \"expect-test\",\n@@ -538,6 +545,7 @@ dependencies = [\n  \"chalk-ir\",\n  \"chalk-recursive\",\n  \"chalk-solve\",\n+ \"cov-mark\",\n  \"ena\",\n  \"expect-test\",\n  \"hir_def\",\n@@ -572,6 +580,7 @@ name = \"ide\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg\",\n+ \"cov-mark\",\n  \"either\",\n  \"expect-test\",\n  \"hir\",\n@@ -598,6 +607,7 @@ dependencies = [\n name = \"ide_assists\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cov-mark\",\n  \"either\",\n  \"expect-test\",\n  \"hir\",\n@@ -616,6 +626,7 @@ name = \"ide_completion\"\n version = \"0.0.0\"\n dependencies = [\n  \"base_db\",\n+ \"cov-mark\",\n  \"either\",\n  \"expect-test\",\n  \"hir\",\n@@ -635,6 +646,7 @@ name = \"ide_db\"\n version = \"0.0.0\"\n dependencies = [\n  \"base_db\",\n+ \"cov-mark\",\n  \"either\",\n  \"expect-test\",\n  \"fst\",\n@@ -655,6 +667,7 @@ dependencies = [\n name = \"ide_ssr\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cov-mark\",\n  \"expect-test\",\n  \"hir\",\n  \"ide_db\",\n@@ -865,6 +878,7 @@ checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n name = \"mbe\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cov-mark\",\n  \"log\",\n  \"parser\",\n  \"profile\",\n@@ -1578,6 +1592,7 @@ name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n+ \"cov-mark\",\n  \"expect-test\",\n  \"indexmap\",\n  \"itertools\","}, {"sha": "2f07b6d01a80d2d12a9be2f6cfcfb154c37f9cf7", "filename": "crates/hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n log = \"0.4.8\"\n once_cell = \"1.3.1\"\n rustc-hash = \"1.1.0\""}, {"sha": "b716d5f6e8ceef2cab79512da2a341ee15d0fb5d", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -13,7 +13,6 @@ use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     match_ast, AstToken, SmolStr, SyntaxNode,\n };\n-use test_utils::mark;\n use tt::Subtree;\n \n use crate::{\n@@ -177,7 +176,7 @@ impl RawAttrs {\n                 if cfg_options.check(&cfg) == Some(false) {\n                     None\n                 } else {\n-                    mark::hit!(cfg_attr_active);\n+                    cov_mark::hit!(cfg_attr_active);\n \n                     let attr = ast::Attr::parse(&format!(\"#[{}]\", attr)).ok()?;\n                     let hygiene = Hygiene::new_unhygienic(); // FIXME"}, {"sha": "b1a3fe1cb8b8bdddb15014514e8370dd4bac91ae", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -20,7 +20,6 @@ use la_arena::{Arena, ArenaMap};\n use profile::Count;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n-use test_utils::mark;\n \n pub(crate) use lower::LowerCtx;\n \n@@ -105,7 +104,7 @@ impl Expander {\n         macro_call: ast::MacroCall,\n     ) -> ExpandResult<Option<(Mark, T)>> {\n         if self.recursion_limit + 1 > EXPANSION_RECURSION_LIMIT {\n-            mark::hit!(your_stack_belongs_to_me);\n+            cov_mark::hit!(your_stack_belongs_to_me);\n             return ExpandResult::str_err(\"reached recursion limit during macro expansion\".into());\n         }\n "}, {"sha": "d4abe819d37f3a274dd3f9d989a897410f6f3bfb", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -19,7 +19,6 @@ use syntax::{\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n };\n-use test_utils::mark;\n \n use crate::{\n     adt::StructKind,\n@@ -286,7 +285,7 @@ impl ExprCollector<'_> {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n-                            mark::hit!(infer_resolve_while_let);\n+                            cov_mark::hit!(infer_resolve_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();"}, {"sha": "1bbb54fc6d398529fb24a37fc698baf41394af4a", "filename": "crates/hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -186,7 +186,7 @@ mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase};\n     use hir_expand::{name::AsName, InFile};\n     use syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, extract_offset, mark};\n+    use test_utils::{assert_eq_text, extract_offset};\n \n     use crate::{db::DefDatabase, test_db::TestDB, FunctionId, ModuleDefId};\n \n@@ -454,7 +454,7 @@ fn foo() {\n \n     #[test]\n     fn while_let_desugaring() {\n-        mark::check!(infer_resolve_while_let);\n+        cov_mark::check!(infer_resolve_while_let);\n         do_check_local_name(\n             r#\"\n fn test() {"}, {"sha": "991a32b150dbdaf6f5eab27f7cd07f3d1ffddc2e", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,6 @@ mod block;\n \n use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::Expect;\n-use test_utils::mark;\n \n use crate::{test_db::TestDB, ModuleDefId};\n \n@@ -48,7 +47,7 @@ fn check_at(ra_fixture: &str, expect: Expect) {\n \n #[test]\n fn your_stack_belongs_to_me() {\n-    mark::check!(your_stack_belongs_to_me);\n+    cov_mark::check!(your_stack_belongs_to_me);\n     lower(\n         \"\n macro_rules! n_nuple {"}, {"sha": "3b6ba4cdec07673e70ddf905fee61ffe32539bd1", "filename": "crates/hir_def/src/body/tests/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -165,16 +165,16 @@ fn macro_resolve() {\n     check_at(\n         r#\"\n //- /lib.rs crate:lib deps:core\n-use core::mark;\n+use core::cov_mark;\n \n fn f() {\n     fn nested() {\n-        mark::hit!(Hit);\n+        cov_mark::hit!(Hit);\n         $0\n     }\n }\n //- /core.rs crate:core\n-pub mod mark {\n+pub mod cov_mark {\n     #[macro_export]\n     macro_rules! _hit {\n         ($name:ident) => {\n@@ -193,8 +193,8 @@ pub mod mark {\n             nested: v\n \n             crate\n+            cov_mark: t\n             f: v\n-            mark: t\n         \"#]],\n     );\n }\n@@ -264,7 +264,7 @@ fn main() {\n fn underscore_import() {\n     // This used to panic, because the default (private) visibility inside block expressions would\n     // point into the containing `DefMap`, which visibilities should never be able to do.\n-    mark::check!(adjust_vis_in_block_def_map);\n+    cov_mark::check!(adjust_vis_in_block_def_map);\n     check_at(\n         r#\"\n mod m {"}, {"sha": "de08e2737a261752b8355e6ded675b3cc99d8952", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,6 @@ use std::iter;\n \n use hir_expand::name::{known, AsName, Name};\n use rustc_hash::FxHashSet;\n-use test_utils::mark;\n \n use crate::nameres::DefMap;\n use crate::{\n@@ -215,7 +214,7 @@ fn find_path_inner(\n                     best_path_len - 1,\n                     prefixed,\n                 )?;\n-                mark::hit!(partially_imported);\n+                cov_mark::hit!(partially_imported);\n                 path.push_segment(info.path.segments.last().unwrap().clone());\n                 Some(path)\n             })\n@@ -235,7 +234,7 @@ fn find_path_inner(\n     // that correctly (FIXME).\n     if let Some(item_module) = item.as_module_def_id().and_then(|did| did.module(db)) {\n         if item_module.def_map(db).block_id().is_some() && prefixed.is_some() {\n-            mark::hit!(prefixed_in_block_expression);\n+            cov_mark::hit!(prefixed_in_block_expression);\n             prefixed = Some(PrefixKind::Plain);\n         }\n     }\n@@ -252,18 +251,18 @@ fn find_path_inner(\n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n     if old_path.starts_with_std() && new_path.can_start_with_std() {\n         if prefer_no_std {\n-            mark::hit!(prefer_no_std_paths);\n+            cov_mark::hit!(prefer_no_std_paths);\n             new_path\n         } else {\n-            mark::hit!(prefer_std_paths);\n+            cov_mark::hit!(prefer_std_paths);\n             old_path\n         }\n     } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n         if prefer_no_std {\n-            mark::hit!(prefer_no_std_paths);\n+            cov_mark::hit!(prefer_no_std_paths);\n             old_path\n         } else {\n-            mark::hit!(prefer_std_paths);\n+            cov_mark::hit!(prefer_std_paths);\n             new_path\n         }\n     } else if new_path.len() < old_path.len() {\n@@ -364,7 +363,6 @@ mod tests {\n     use base_db::fixture::WithFixture;\n     use hir_expand::hygiene::Hygiene;\n     use syntax::ast::AstNode;\n-    use test_utils::mark;\n \n     use crate::test_db::TestDB;\n \n@@ -522,7 +520,7 @@ mod tests {\n \n     #[test]\n     fn partially_imported() {\n-        mark::check!(partially_imported);\n+        cov_mark::check!(partially_imported);\n         // Tests that short paths are used even for external items, when parts of the path are\n         // already in scope.\n         let code = r#\"\n@@ -686,7 +684,7 @@ mod tests {\n \n     #[test]\n     fn prefer_std_paths_over_alloc() {\n-        mark::check!(prefer_std_paths);\n+        cov_mark::check!(prefer_std_paths);\n         let code = r#\"\n         //- /main.rs crate:main deps:alloc,std\n         $0\n@@ -712,7 +710,7 @@ mod tests {\n \n     #[test]\n     fn prefer_core_paths_over_std() {\n-        mark::check!(prefer_no_std_paths);\n+        cov_mark::check!(prefer_no_std_paths);\n         let code = r#\"\n         //- /main.rs crate:main deps:core,std\n         #![no_std]\n@@ -842,7 +840,7 @@ mod tests {\n \n     #[test]\n     fn inner_items_from_inner_module() {\n-        mark::check!(prefixed_in_block_expression);\n+        cov_mark::check!(prefixed_in_block_expression);\n         check_found_path(\n             r#\"\n             fn main() {"}, {"sha": "369bc3350b7f6fcafd49cb7ff54c417c188f3edf", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -8,7 +8,6 @@ use hir_expand::name::Name;\n use indexmap::{map::Entry, IndexMap};\n use itertools::Itertools;\n use rustc_hash::{FxHashSet, FxHasher};\n-use test_utils::mark;\n \n use crate::{\n     db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n@@ -193,7 +192,7 @@ impl ImportMap {\n                 // cannot use associated type aliases directly: need a `<Struct as Trait>::TypeAlias`\n                 // qualifier, ergo no need to store it for imports in import_map\n                 AssocItemId::TypeAliasId(_) => {\n-                    mark::hit!(type_aliases_ignored);\n+                    cov_mark::hit!(type_aliases_ignored);\n                     continue;\n                 }\n             };\n@@ -463,7 +462,6 @@ fn item_import_kind(item: ItemInNs) -> Option<ImportKind> {\n mod tests {\n     use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{test_db::TestDB, AssocContainerId, Lookup};\n \n@@ -801,7 +799,7 @@ mod tests {\n \n     #[test]\n     fn fuzzy_import_trait_and_assoc_items() {\n-        mark::check!(type_aliases_ignored);\n+        cov_mark::check!(type_aliases_ignored);\n         let ra_fixture = r#\"\n         //- /main.rs crate:main deps:dep\n         //- /dep.rs crate:dep"}, {"sha": "919933813928c5e043ff862bf5ef2dd924a3f1b5", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -9,7 +9,6 @@ use hir_expand::MacroDefKind;\n use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::format_to;\n-use test_utils::mark;\n \n use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId,\n@@ -237,7 +236,7 @@ impl ItemScope {\n                         if $glob_imports.$field.contains(&$lookup)\n                             && matches!($def_import_type, ImportType::Named) =>\n                     {\n-                        mark::hit!(import_shadowed);\n+                        cov_mark::hit!(import_shadowed);\n                         $glob_imports.$field.remove(&$lookup);\n                         if let Some(fld) = $def.$field {\n                             entry.insert(fld);"}, {"sha": "6bb334573efda872a64736d0fe6dbef55f08386c", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -25,7 +25,6 @@ use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{ast, match_ast, SyntaxKind};\n-use test_utils::mark;\n \n use crate::{\n     attr::{Attrs, RawAttrs},"}, {"sha": "240fdacf94c294e5482895689b670b41fe9146fd", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -466,7 +466,7 @@ impl Ctx {\n                             .collect()\n                     })\n                     .unwrap_or_else(|| {\n-                        mark::hit!(name_res_works_for_broken_modules);\n+                        cov_mark::hit!(name_res_works_for_broken_modules);\n                         Box::new([]) as Box<[_]>\n                     }),\n             }"}, {"sha": "3bb69d935f7023be5a09a1eca434347a3ddf2099", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -18,7 +18,6 @@ use hir_expand::{\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n-use test_utils::mark;\n use tt::{Leaf, TokenTree};\n \n use crate::{\n@@ -462,7 +461,7 @@ impl DefCollector<'_> {\n         let res = self.def_map.resolve_name_in_extern_prelude(&extern_crate.name);\n \n         if let Some(ModuleDefId::ModuleId(m)) = res.take_types() {\n-            mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+            cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n             self.import_all_macros_exported(current_module_id, m.krate);\n         }\n     }\n@@ -571,10 +570,10 @@ impl DefCollector<'_> {\n             match def.take_types() {\n                 Some(ModuleDefId::ModuleId(m)) => {\n                     if import.is_prelude {\n-                        mark::hit!(std_prelude);\n+                        cov_mark::hit!(std_prelude);\n                         self.def_map.prelude = Some(m);\n                     } else if m.krate != self.def_map.krate {\n-                        mark::hit!(glob_across_crates);\n+                        cov_mark::hit!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = m.def_map(self.db);\n                         let scope = &item_map[m.local_id].scope;\n@@ -626,7 +625,7 @@ impl DefCollector<'_> {\n                     }\n                 }\n                 Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n-                    mark::hit!(glob_enum);\n+                    cov_mark::hit!(glob_enum);\n                     // glob import from enum => just import all the variants\n \n                     // XXX: urgh, so this works by accident! Here, we look at\n@@ -675,7 +674,7 @@ impl DefCollector<'_> {\n \n                     self.update(module_id, &[(name, def)], vis, ImportType::Named);\n                 }\n-                None => mark::hit!(bogus_paths),\n+                None => cov_mark::hit!(bogus_paths),\n             }\n         }\n     }\n@@ -738,7 +737,7 @@ impl DefCollector<'_> {\n                             if max_vis == old_vis {\n                                 false\n                             } else {\n-                                mark::hit!(upgrade_underscore_visibility);\n+                                cov_mark::hit!(upgrade_underscore_visibility);\n                                 true\n                             }\n                         }\n@@ -866,7 +865,7 @@ impl DefCollector<'_> {\n         depth: usize,\n     ) {\n         if depth > EXPANSION_DEPTH_LIMIT {\n-            mark::hit!(macro_expansion_overflow);\n+            cov_mark::hit!(macro_expansion_overflow);\n             log::warn!(\"macro expansion is too deep\");\n             return;\n         }\n@@ -1009,7 +1008,7 @@ impl ModCollector<'_, '_> {\n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n-                mark::hit!(prelude_is_macro_use);\n+                cov_mark::hit!(prelude_is_macro_use);\n                 self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n         }"}, {"sha": "d5de9899cfa232453ac8e15326273e1b0609cf41", "filename": "crates/hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,6 @@\n use base_db::{AnchoredPath, FileId};\n use hir_expand::name::Name;\n use syntax::SmolStr;\n-use test_utils::mark;\n \n use crate::{db::DefDatabase, HirFileId};\n \n@@ -28,7 +27,7 @@ impl ModDir {\n         let depth = self.depth + 1;\n         if depth > MOD_DEPTH_LIMIT {\n             log::error!(\"MOD_DEPTH_LIMIT exceeded\");\n-            mark::hit!(circular_mods);\n+            cov_mark::hit!(circular_mods);\n             return None;\n         }\n         Some(ModDir { dir_path, root_non_dir_owner, depth })"}, {"sha": "8258dcffbc61aa44882007d0ca587e0316296bb8", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -13,7 +13,6 @@\n use base_db::Edition;\n use hir_expand::name;\n use hir_expand::name::Name;\n-use test_utils::mark;\n \n use crate::{\n     db::DefDatabase,\n@@ -63,7 +62,7 @@ impl ResolvePathResult {\n impl DefMap {\n     pub(super) fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n         if name == &name!(self) {\n-            mark::hit!(extern_crate_self_as);\n+            cov_mark::hit!(extern_crate_self_as);\n             return PerNs::types(self.module_id(self.root).into(), Visibility::Public);\n         }\n         self.extern_prelude\n@@ -101,7 +100,7 @@ impl DefMap {\n         // DefMap they're written in, so we restrict them when that happens.\n         if let Visibility::Module(m) = vis {\n             if self.block_id() != m.block {\n-                mark::hit!(adjust_vis_in_block_def_map);\n+                cov_mark::hit!(adjust_vis_in_block_def_map);\n                 vis = Visibility::Module(self.module_id(self.root()));\n                 log::debug!(\"visibility {:?} points outside DefMap, adjusting to {:?}\", m, vis);\n             }\n@@ -169,12 +168,12 @@ impl DefMap {\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n-                    mark::hit!(macro_dollar_crate_self);\n+                    cov_mark::hit!(macro_dollar_crate_self);\n                     PerNs::types(self.crate_root(db).into(), Visibility::Public)\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n                     let module = def_map.module_id(def_map.root);\n-                    mark::hit!(macro_dollar_crate_other);\n+                    cov_mark::hit!(macro_dollar_crate_other);\n                     PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n@@ -310,7 +309,7 @@ impl DefMap {\n                 }\n                 ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n                     // enum variant\n-                    mark::hit!(can_import_enum_variant);\n+                    cov_mark::hit!(can_import_enum_variant);\n                     let enum_data = db.enum_data(e);\n                     match enum_data.variant(&segment) {\n                         Some(local_id) => {"}, {"sha": "de3aa4f9ae362946592785a584b118b85616a943", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -9,7 +9,6 @@ use std::sync::Arc;\n \n use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::{expect, Expect};\n-use test_utils::mark;\n \n use crate::{db::DefDatabase, test_db::TestDB};\n \n@@ -136,7 +135,7 @@ mod m {\n \n #[test]\n fn bogus_paths() {\n-    mark::check!(bogus_paths);\n+    cov_mark::check!(bogus_paths);\n     check(\n         r#\"\n //- /lib.rs\n@@ -243,7 +242,7 @@ pub struct Baz;\n \n #[test]\n fn std_prelude() {\n-    mark::check!(std_prelude);\n+    cov_mark::check!(std_prelude);\n     check(\n         r#\"\n //- /main.rs crate:main deps:test_crate\n@@ -267,7 +266,7 @@ pub enum Foo { Bar, Baz };\n \n #[test]\n fn can_import_enum_variant() {\n-    mark::check!(can_import_enum_variant);\n+    cov_mark::check!(can_import_enum_variant);\n     check(\n         r#\"\n enum E { V }\n@@ -628,7 +627,7 @@ use crate::reex::*;\n \n #[test]\n fn underscore_pub_crate_reexport() {\n-    mark::check!(upgrade_underscore_visibility);\n+    cov_mark::check!(upgrade_underscore_visibility);\n     check(\n         r#\"\n //- /main.rs crate:main deps:lib"}, {"sha": "d5ef8ceb577c7480c0cab512c23791dd0414858d", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use base_db::fixture::WithFixture;\n-use test_utils::mark;\n \n use crate::test_db::TestDB;\n \n@@ -63,7 +62,7 @@ fn unresolved_extern_crate() {\n \n #[test]\n fn extern_crate_self_as() {\n-    mark::check!(extern_crate_self_as);\n+    cov_mark::check!(extern_crate_self_as);\n     check_diagnostics(\n         r\"\n         //- /lib.rs\n@@ -140,7 +139,7 @@ fn inactive_item() {\n /// Tests that `cfg` attributes behind `cfg_attr` is handled properly.\n #[test]\n fn inactive_via_cfg_attr() {\n-    mark::check!(cfg_attr_active);\n+    cov_mark::check!(cfg_attr_active);\n     check_diagnostics(\n         r#\"\n         //- /lib.rs"}, {"sha": "17426d54d4057b6d7ea351b6de4fea10df6c9402", "filename": "crates/hir_def/src/nameres/tests/globs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -148,7 +148,7 @@ pub(crate) struct PubCrateStruct;\n \n #[test]\n fn glob_across_crates() {\n-    mark::check!(glob_across_crates);\n+    cov_mark::check!(glob_across_crates);\n     check(\n         r#\"\n //- /main.rs crate:main deps:test_crate\n@@ -184,7 +184,7 @@ struct Foo;\n \n #[test]\n fn glob_enum() {\n-    mark::check!(glob_enum);\n+    cov_mark::check!(glob_enum);\n     check(\n         r#\"\n enum Foo { Bar, Baz }\n@@ -201,7 +201,7 @@ use self::Foo::*;\n \n #[test]\n fn glob_enum_group() {\n-    mark::check!(glob_enum_group);\n+    cov_mark::check!(glob_enum_group);\n     check(\n         r#\"\n enum Foo { Bar, Baz }\n@@ -218,7 +218,7 @@ use self::Foo::{*};\n \n #[test]\n fn glob_shadowed_def() {\n-    mark::check!(import_shadowed);\n+    cov_mark::check!(import_shadowed);\n     check(\n         r#\"\n //- /lib.rs"}, {"sha": "f65a655bf5e706ed1b6f5fca42777ed36da8532b", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -210,7 +210,7 @@ macro_rules! bar {\n \n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n-    mark::check!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+    cov_mark::check!(macro_rules_from_other_crates_are_visible_with_macro_use);\n     check(\n         r#\"\n //- /main.rs crate:main deps:foo\n@@ -260,7 +260,7 @@ mod priv_mod {\n \n #[test]\n fn prelude_is_macro_use() {\n-    mark::check!(prelude_is_macro_use);\n+    cov_mark::check!(prelude_is_macro_use);\n     check(\n         r#\"\n //- /main.rs crate:main deps:foo\n@@ -550,7 +550,7 @@ mod m {\n \n #[test]\n fn macro_dollar_crate_is_correct_in_item() {\n-    mark::check!(macro_dollar_crate_self);\n+    cov_mark::check!(macro_dollar_crate_self);\n     check(\n         r#\"\n //- /main.rs crate:main deps:foo\n@@ -608,7 +608,7 @@ struct Baz;\n \n #[test]\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n-    mark::check!(macro_dollar_crate_other);\n+    cov_mark::check!(macro_dollar_crate_other);\n     // From std\n     check(\n         r#\"\n@@ -686,7 +686,7 @@ pub trait Clone {}\n \n #[test]\n fn macro_expansion_overflow() {\n-    mark::check!(macro_expansion_overflow);\n+    cov_mark::check!(macro_expansion_overflow);\n     check(\n         r#\"\n macro_rules! a {"}, {"sha": "dfbbad1f9084bc3670f7b7afd0e04998edfe3116", "filename": "crates/hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    mark::check!(name_res_works_for_broken_modules);\n+    cov_mark::check!(name_res_works_for_broken_modules);\n     check(\n         r\"\n //- /lib.rs\n@@ -774,7 +774,7 @@ struct X;\n \n #[test]\n fn circular_mods() {\n-    mark::check!(circular_mods);\n+    cov_mark::check!(circular_mods);\n     compute_crate_def_map(\n         r#\"\n //- /lib.rs"}, {"sha": "e2965b03365cbd5cc966e5cc28867ef9d50690bf", "filename": "crates/hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -6,7 +6,6 @@ use std::iter;\n use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName};\n use syntax::ast::{self, NameOwner};\n-use test_utils::mark;\n \n use crate::path::{ImportAlias, ModPath, PathKind};\n \n@@ -54,7 +53,7 @@ pub(crate) fn lower_use_tree(\n         // FIXME: report errors somewhere\n         // We get here if we do\n         } else if is_glob {\n-            mark::hit!(glob_enum_group);\n+            cov_mark::hit!(glob_enum_group);\n             if let Some(prefix) = prefix {\n                 cb(prefix, &tree, is_glob, None)\n             }"}, {"sha": "6131ebee810370194624f7a16d51222909b9a23a", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n itertools = \"0.10.0\"\n arrayvec = \"0.5.1\"\n smallvec = \"1.2.0\""}, {"sha": "e230f97656c034f19aa9093e5fb9efa2f53b9612", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -28,7 +28,6 @@ use syntax::{\n     ast::{self, NameOwner},\n     AstNode, AstPtr,\n };\n-use test_utils::mark;\n \n use crate::{\n     db::HirDatabase,\n@@ -93,7 +92,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     fn validate_func(&mut self, func: FunctionId) {\n         let data = self.db.function_data(func);\n         if data.is_extern {\n-            mark::hit!(extern_func_incorrect_case_ignored);\n+            cov_mark::hit!(extern_func_incorrect_case_ignored);\n             return;\n         }\n \n@@ -625,7 +624,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     fn validate_static(&mut self, static_id: StaticId) {\n         let data = self.db.static_data(static_id);\n         if data.is_extern {\n-            mark::hit!(extern_static_incorrect_case_ignored);\n+            cov_mark::hit!(extern_static_incorrect_case_ignored);\n             return;\n         }\n \n@@ -673,8 +672,6 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n@@ -889,8 +886,8 @@ fn main() {\n \n     #[test]\n     fn ignores_extern_items() {\n-        mark::check!(extern_func_incorrect_case_ignored);\n-        mark::check!(extern_static_incorrect_case_ignored);\n+        cov_mark::check!(extern_func_incorrect_case_ignored);\n+        cov_mark::check!(extern_static_incorrect_case_ignored);\n         check_diagnostics(\n             r#\"\n extern {"}, {"sha": "7e8846f274c725f53830b5457b5f5cabced4e398", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -6,7 +6,6 @@\n \n use chalk_ir::{Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n-use test_utils::mark;\n \n use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty};\n \n@@ -35,7 +34,7 @@ impl<'a> InferenceContext<'a> {\n             ty1.clone()\n         } else {\n             if let (Ty::FnDef(..), Ty::FnDef(..)) = (ty1, ty2) {\n-                mark::hit!(coerce_fn_reification);\n+                cov_mark::hit!(coerce_fn_reification);\n                 // Special case: two function types. Try to coerce both to\n                 // pointers to have a chance at getting a match. See\n                 // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n@@ -45,7 +44,7 @@ impl<'a> InferenceContext<'a> {\n                 let ptr_ty2 = Ty::fn_ptr(sig2);\n                 self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n             } else {\n-                mark::hit!(coerce_merge_fail_fallback);\n+                cov_mark::hit!(coerce_merge_fail_fallback);\n                 ty1.clone()\n             }\n         }"}, {"sha": "262177ffbe11758bd6ae1ac62abbcb580fa0e2f3", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -12,7 +12,6 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n use syntax::ast::RangeOp;\n-use test_utils::mark;\n \n use crate::{\n     autoderef,\n@@ -565,7 +564,7 @@ impl<'a> InferenceContext<'a> {\n                     let ret = op::binary_op_return_ty(*op, lhs_ty.clone(), rhs_ty.clone());\n \n                     if ret == Ty::Unknown {\n-                        mark::hit!(infer_expr_inner_binary_operator_overload);\n+                        cov_mark::hit!(infer_expr_inner_binary_operator_overload);\n \n                         self.resolve_associated_type_with_params(\n                             lhs_ty,"}, {"sha": "a0ac8d80fdd76a990b9d0d5ab97e4fe514d6a5ad", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,7 +10,6 @@ use hir_def::{\n     FieldId,\n };\n use hir_expand::name::Name;\n-use test_utils::mark;\n \n use super::{BindingMode, Expectation, InferenceContext};\n use crate::{lower::lower_to_chalk_mutability, utils::variant_data, Substs, Ty};\n@@ -108,7 +107,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         } else if let Pat::Ref { .. } = &body[pat] {\n-            mark::hit!(match_ergonomics_ref);\n+            cov_mark::hit!(match_ergonomics_ref);\n             // When you encounter a `&pat` pattern, reset to Move.\n             // This is so that `w` is by value: `let (_, &w) = &(1, &2);`\n             default_bm = BindingMode::Move;"}, {"sha": "54fcfed10891e43cdd35f252db82535c475061e3", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -5,8 +5,6 @@ use std::borrow::Cow;\n use chalk_ir::{FloatTy, IntTy, TyVariableKind};\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n-use test_utils::mark;\n-\n use super::{InferenceContext, Obligation};\n use crate::{\n     BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferenceVar, Scalar,\n@@ -387,7 +385,7 @@ impl InferenceTable {\n         // more than once\n         for i in 0..3 {\n             if i > 0 {\n-                mark::hit!(type_var_resolves_to_int_var);\n+                cov_mark::hit!(type_var_resolves_to_int_var);\n             }\n             match &*ty {\n                 Ty::InferenceVar(tv, _) => {\n@@ -416,7 +414,7 @@ impl InferenceTable {\n             Ty::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n-                    mark::hit!(type_var_cycles_resolve_as_possible);\n+                    cov_mark::hit!(type_var_cycles_resolve_as_possible);\n                     // recursive type\n                     return self.type_variable_table.fallback_value(tv, kind);\n                 }\n@@ -443,7 +441,7 @@ impl InferenceTable {\n             Ty::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n-                    mark::hit!(type_var_cycles_resolve_completely);\n+                    cov_mark::hit!(type_var_cycles_resolve_completely);\n                     // recursive type\n                     return self.type_variable_table.fallback_value(tv, kind);\n                 }"}, {"sha": "b90fdc38203f5020c975896cf9240a49b15e57fd", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -24,7 +24,6 @@ use hir_expand::name::Name;\n use la_arena::ArenaMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n-use test_utils::mark;\n \n use crate::{\n     db::HirDatabase,\n@@ -760,7 +759,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n \n impl ReturnTypeImplTrait {\n     fn from_hir(ctx: &TyLoweringContext, bounds: &[TypeBound]) -> Self {\n-        mark::hit!(lower_rpit);\n+        cov_mark::hit!(lower_rpit);\n         let self_ty = Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n         let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             bounds\n@@ -935,7 +934,7 @@ impl TraitEnvironment {\n                 // add `Self: Trait<T1, T2, ...>` to the environment in trait\n                 // function default implementations (and hypothetical code\n                 // inside consts or type aliases)\n-                test_utils::mark::hit!(trait_self_implements_self);\n+                cov_mark::hit!(trait_self_implements_self);\n                 let substs = Substs::type_params(db, trait_id);\n                 let trait_ref = TraitRef { trait_: trait_id, substs };\n                 let pred = GenericPredicate::Implemented(trait_ref);"}, {"sha": "24db33c4913a9641b8d7f17467d3162b0f9a9dd3", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -588,7 +588,7 @@ fn iterate_inherent_methods(\n                 // already happens in `is_valid_candidate` above; if not, we\n                 // check it here\n                 if receiver_ty.is_none() && inherent_impl_substs(db, impl_def, self_ty).is_none() {\n-                    test_utils::mark::hit!(impl_self_type_match_without_receiver);\n+                    cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n                 if callback(&self_ty.value, item) {"}, {"sha": "63d9d4e0b7911af61fc7cd4b1783f56683172a79", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use expect_test::expect;\n-use test_utils::mark;\n \n use super::{check_infer, check_infer_with_mismatches};\n \n@@ -381,7 +380,7 @@ fn infer_match_second_coerce() {\n \n #[test]\n fn coerce_merge_one_by_one1() {\n-    mark::check!(coerce_merge_fail_fallback);\n+    cov_mark::check!(coerce_merge_fail_fallback);\n \n     check_infer(\n         r\"\n@@ -589,7 +588,7 @@ fn coerce_fn_item_to_fn_ptr() {\n \n #[test]\n fn coerce_fn_items_in_match_arms() {\n-    mark::check!(coerce_fn_reification);\n+    cov_mark::check!(coerce_fn_reification);\n \n     check_infer_with_mismatches(\n         r\""}, {"sha": "4e3f9a9b62575bd4ce720055e4f303b45c261bf4", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -913,7 +913,7 @@ fn test() { S2.into(); }\n \n #[test]\n fn method_resolution_overloaded_method() {\n-    test_utils::mark::check!(impl_self_type_match_without_receiver);\n+    cov_mark::check!(impl_self_type_match_without_receiver);\n     check_types(\n         r#\"\n struct Wrapper<T>(T);"}, {"sha": "5da19ba5f012f9b6ff1a75936f71b0643f602c84", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use expect_test::expect;\n-use test_utils::mark;\n \n use super::{check_infer, check_infer_with_mismatches};\n \n@@ -197,7 +196,7 @@ fn infer_pattern_match_ergonomics() {\n \n #[test]\n fn infer_pattern_match_ergonomics_ref() {\n-    mark::check!(match_ergonomics_ref);\n+    cov_mark::check!(match_ergonomics_ref);\n     check_infer(\n         r#\"\n         fn test() {"}, {"sha": "69314e245bdebbe28177155976b91d4bbf879d45", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use expect_test::expect;\n-use test_utils::mark;\n \n use super::{check_infer, check_types};\n \n@@ -87,8 +86,8 @@ fn bug_651() {\n \n #[test]\n fn recursive_vars() {\n-    mark::check!(type_var_cycles_resolve_completely);\n-    mark::check!(type_var_cycles_resolve_as_possible);\n+    cov_mark::check!(type_var_cycles_resolve_completely);\n+    cov_mark::check!(type_var_cycles_resolve_as_possible);\n     check_infer(\n         r#\"\n         fn test() {\n@@ -166,7 +165,7 @@ fn infer_std_crash_1() {\n \n #[test]\n fn infer_std_crash_2() {\n-    mark::check!(type_var_resolves_to_int_var);\n+    cov_mark::check!(type_var_resolves_to_int_var);\n     // caused \"equating two type variables, ...\", taken from std\n     check_infer(\n         r#\""}, {"sha": "f5069eba51bfe72be8c7ad4a763f5aebe9c4ea62", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use expect_test::expect;\n-use test_utils::mark;\n \n use super::{check_infer, check_types};\n \n@@ -2314,7 +2313,7 @@ fn generic_default_depending_on_other_type_arg_forward() {\n \n #[test]\n fn infer_operator_overload() {\n-    mark::check!(infer_expr_inner_binary_operator_overload);\n+    cov_mark::check!(infer_expr_inner_binary_operator_overload);\n \n     check_infer(\n         r#\""}, {"sha": "5280920825947831ec476470e1ee0d64b6cba130", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use expect_test::expect;\n-use test_utils::mark;\n \n use super::{check_infer, check_infer_with_mismatches, check_types};\n \n@@ -319,7 +318,7 @@ fn infer_from_bound_2() {\n \n #[test]\n fn trait_default_method_self_bound_implements_trait() {\n-    mark::check!(trait_self_implements_self);\n+    cov_mark::check!(trait_self_implements_self);\n     check_infer(\n         r#\"\n         trait Trait {\n@@ -1189,7 +1188,7 @@ fn impl_trait() {\n \n #[test]\n fn simple_return_pos_impl_trait() {\n-    mark::check!(lower_rpit);\n+    cov_mark::check!(lower_rpit);\n     check_infer(\n         r#\"\n         trait Trait<T> {"}, {"sha": "f7c5efaf331aee9032f73855e5b81d08f2e839d3", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n either = \"1.5.3\"\n indexmap = \"1.4.0\"\n itertools = \"0.10.0\""}, {"sha": "5d1cc20529afa1c87effdca37bc91dafbcb3f86f", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -11,7 +11,6 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n-use test_utils::mark;\n \n use crate::{\n     display::{macro_label, ShortLabel, TryToNav},\n@@ -193,8 +192,8 @@ fn runnable_action(\n             ModuleDef::Function(func) => {\n                 let src = func.source(sema.db)?;\n                 if src.file_id != file_id.into() {\n-                    mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n-                    mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n+                    cov_mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n+                    cov_mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n                     return None;\n                 }\n \n@@ -2101,7 +2100,7 @@ pub fn fo$0o() {}\n \n     #[test]\n     fn test_hover_macro_generated_struct_fn_doc_comment() {\n-        mark::check!(hover_macro_generated_struct_fn_doc_comment);\n+        cov_mark::check!(hover_macro_generated_struct_fn_doc_comment);\n \n         check(\n             r#\"\n@@ -2139,7 +2138,7 @@ fn foo() { let bar = Bar; bar.fo$0o(); }\n \n     #[test]\n     fn test_hover_macro_generated_struct_fn_doc_attr() {\n-        mark::check!(hover_macro_generated_struct_fn_doc_attr);\n+        cov_mark::check!(hover_macro_generated_struct_fn_doc_attr);\n \n         check(\n             r#\""}, {"sha": "20a920ddbdfd301e6da6b39361334796de3d8046", "filename": "crates/ide/src/join_lines.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -7,7 +7,7 @@ use syntax::{\n     SyntaxKind::{self, USE_TREE, WHITESPACE},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n-use test_utils::mark;\n+\n use text_edit::{TextEdit, TextEditBuilder};\n \n // Feature: Join Lines\n@@ -60,7 +60,7 @@ fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextS\n         let mut string_open_quote = false;\n         if let Some(string) = ast::String::cast(token.clone()) {\n             if let Some(range) = string.open_quote_text_range() {\n-                mark::hit!(join_string_literal);\n+                cov_mark::hit!(join_string_literal);\n                 string_open_quote = range.end() == offset;\n             }\n         }\n@@ -206,7 +206,7 @@ fn compute_ws(left: SyntaxKind, right: SyntaxKind) -> &'static str {\n #[cfg(test)]\n mod tests {\n     use syntax::SourceFile;\n-    use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range, mark};\n+    use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n     use super::*;\n \n@@ -786,7 +786,7 @@ fn foo() {\n \n     #[test]\n     fn join_string_literal() {\n-        mark::check!(join_string_literal);\n+        cov_mark::check!(join_string_literal);\n         check_join_lines(\n             r#\"\n fn main() {"}, {"sha": "000c412d9ac067ff9ea204bb9d63484bb2f70885", "filename": "crates/ide/src/matching_brace.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmatching_brace.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,6 @@ use syntax::{\n     ast::{self, AstNode},\n     SourceFile, SyntaxKind, TextSize, T,\n };\n-use test_utils::mark;\n \n // Feature: Matching Brace\n //\n@@ -28,7 +27,7 @@ pub(crate) fn matching_brace(file: &SourceFile, offset: TextSize) -> Option<Text\n         .next()?;\n     let parent = brace_token.parent();\n     if brace_token.kind() == T![|] && !ast::ParamList::can_cast(parent.kind()) {\n-        mark::hit!(pipes_not_braces);\n+        cov_mark::hit!(pipes_not_braces);\n         return None;\n     }\n     let matching_kind = BRACES[brace_idx ^ 1];\n@@ -63,7 +62,7 @@ mod tests {\n         do_check(\"fn main() { $0|x: i32| x * 2;}\", \"fn main() { |x: i32$0| x * 2;}\");\n \n         {\n-            mark::check!(pipes_not_braces);\n+            cov_mark::check!(pipes_not_braces);\n             do_check(\n                 \"fn main() { match 92 { 1 | 2 |$0 3 => 92 } }\",\n                 \"fn main() { match 92 { 1 | 2 |$0 3 => 92 } }\","}, {"sha": "03d71b3807ac230e82330496364119c7080aa323", "filename": "crates/ide/src/parent_module.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fparent_module.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -5,7 +5,6 @@ use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstNode},\n };\n-use test_utils::mark;\n \n use crate::NavigationTarget;\n \n@@ -33,7 +32,7 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n             .item_list()\n             .map_or(false, |it| it.syntax().text_range().contains_inclusive(position.offset))\n         {\n-            mark::hit!(test_resolve_parent_module_on_module_decl);\n+            cov_mark::hit!(test_resolve_parent_module_on_module_decl);\n             module = m.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n         }\n     }\n@@ -64,7 +63,6 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;\n-    use test_utils::mark;\n \n     use crate::fixture;\n \n@@ -92,7 +90,7 @@ $0// empty\n \n     #[test]\n     fn test_resolve_parent_module_on_module_decl() {\n-        mark::check!(test_resolve_parent_module_on_module_decl);\n+        cov_mark::check!(test_resolve_parent_module_on_module_decl);\n         check(\n             r#\"\n //- /lib.rs"}, {"sha": "05c73de88f7d513222cf9518ef56071a8d8630d0", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n     ast::{self, NameOwner},\n     lex_single_syntax_kind, AstNode, SyntaxKind, SyntaxNode, T,\n };\n-use test_utils::mark;\n+\n use text_edit::TextEdit;\n \n use crate::{display::TryToNav, FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n@@ -226,34 +226,36 @@ fn rename_reference(\n         | (IdentifierKind::Ident, _)\n             if def_is_lbl_or_lt =>\n         {\n-            mark::hit!(rename_not_a_lifetime_ident_ref);\n+            cov_mark::hit!(rename_not_a_lifetime_ident_ref);\n             bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n         }\n-        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => mark::hit!(rename_lifetime),\n+        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => cov_mark::hit!(rename_lifetime),\n         (IdentifierKind::Lifetime, _) => {\n-            mark::hit!(rename_not_an_ident_ref);\n+            cov_mark::hit!(rename_not_an_ident_ref);\n             bail!(\"Invalid name `{}`: not an identifier\", new_name)\n         }\n         (IdentifierKind::ToSelf, Definition::Local(local)) if local.is_self(sema.db) => {\n             // no-op\n-            mark::hit!(rename_self_to_self);\n+            cov_mark::hit!(rename_self_to_self);\n             return Ok(SourceChange::default());\n         }\n         (ident_kind, Definition::Local(local)) if local.is_self(sema.db) => {\n-            mark::hit!(rename_self_to_param);\n+            cov_mark::hit!(rename_self_to_param);\n             return rename_self_to_param(sema, local, new_name, ident_kind);\n         }\n         (IdentifierKind::ToSelf, Definition::Local(local)) => {\n-            mark::hit!(rename_to_self);\n+            cov_mark::hit!(rename_to_self);\n             return rename_to_self(sema, local);\n         }\n         (IdentifierKind::ToSelf, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n+        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => {\n+            cov_mark::hit!(rename_ident)\n+        }\n     }\n \n     let usages = def.usages(sema).all();\n     if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n-        mark::hit!(rename_underscore_multiple);\n+        cov_mark::hit!(rename_underscore_multiple);\n         bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n     }\n     let mut source_change = SourceChange::default();\n@@ -444,7 +446,7 @@ fn source_edit_from_name_ref(\n             (Some(field_name), Some(init)) => {\n                 if field_name == *name_ref {\n                     if init.text() == new_name {\n-                        mark::hit!(test_rename_field_put_init_shorthand);\n+                        cov_mark::hit!(test_rename_field_put_init_shorthand);\n                         // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n@@ -453,7 +455,7 @@ fn source_edit_from_name_ref(\n                     }\n                 } else if init == *name_ref {\n                     if field_name.text() == new_name {\n-                        mark::hit!(test_rename_local_put_init_shorthand);\n+                        cov_mark::hit!(test_rename_local_put_init_shorthand);\n                         // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n@@ -467,12 +469,12 @@ fn source_edit_from_name_ref(\n             // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n             // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n             (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n-                mark::hit!(test_rename_field_in_field_shorthand);\n+                cov_mark::hit!(test_rename_field_in_field_shorthand);\n                 let s = name_ref.syntax().text_range().start();\n                 Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n             }\n             (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n-                mark::hit!(test_rename_local_in_field_shorthand);\n+                cov_mark::hit!(test_rename_local_in_field_shorthand);\n                 let s = name_ref.syntax().text_range().end();\n                 Some((TextRange::empty(s), format!(\": {}\", new_name)))\n             }\n@@ -486,7 +488,7 @@ fn source_edit_from_name_ref(\n             (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n                 // field name is being renamed\n                 if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n                     // same names, we can use a shorthand here instead/\n                     // we do not want to erase attributes hence this range start\n                     let s = field_name.syntax().text_range().start();\n@@ -538,7 +540,7 @@ fn source_edit_from_def(\n mod tests {\n     use expect_test::{expect, Expect};\n     use stdx::trim_indent;\n-    use test_utils::{assert_eq_text, mark};\n+    use test_utils::assert_eq_text;\n     use text_edit::TextEdit;\n \n     use crate::{fixture, FileId};\n@@ -627,7 +629,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime() {\n-        mark::check!(rename_not_an_ident_ref);\n+        cov_mark::check!(rename_not_an_ident_ref);\n         check(\n             \"'foo\",\n             r#\"fn main() { let i$0 = 1; }\"#,\n@@ -637,7 +639,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime2() {\n-        mark::check!(rename_not_a_lifetime_ident_ref);\n+        cov_mark::check!(rename_not_a_lifetime_ident_ref);\n         check(\n             \"foo\",\n             r#\"fn main<'a>(_: &'a$0 ()) {}\"#,\n@@ -647,7 +649,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_to_underscore_invalid() {\n-        mark::check!(rename_underscore_multiple);\n+        cov_mark::check!(rename_underscore_multiple);\n         check(\n             \"_\",\n             r#\"fn main(foo$0: ()) {foo;}\"#,\n@@ -666,7 +668,7 @@ mod tests {\n \n     #[test]\n     fn test_rename_for_local() {\n-        mark::check!(rename_ident);\n+        cov_mark::check!(rename_ident);\n         check(\n             \"k\",\n             r#\"\n@@ -829,7 +831,7 @@ impl Foo {\n \n     #[test]\n     fn test_rename_field_in_field_shorthand() {\n-        mark::check!(test_rename_field_in_field_shorthand);\n+        cov_mark::check!(test_rename_field_in_field_shorthand);\n         check(\n             \"j\",\n             r#\"\n@@ -855,7 +857,7 @@ impl Foo {\n \n     #[test]\n     fn test_rename_local_in_field_shorthand() {\n-        mark::check!(test_rename_local_in_field_shorthand);\n+        cov_mark::check!(test_rename_local_in_field_shorthand);\n         check(\n             \"j\",\n             r#\"\n@@ -1261,7 +1263,7 @@ fn foo(f: foo::Foo) {\n \n     #[test]\n     fn test_parameter_to_self() {\n-        mark::check!(rename_to_self);\n+        cov_mark::check!(rename_to_self);\n         check(\n             \"self\",\n             r#\"\n@@ -1401,7 +1403,7 @@ impl Foo {\n \n     #[test]\n     fn test_owned_self_to_parameter() {\n-        mark::check!(rename_self_to_param);\n+        cov_mark::check!(rename_self_to_param);\n         check(\n             \"foo\",\n             r#\"\n@@ -1454,7 +1456,7 @@ impl Foo {\n \n     #[test]\n     fn test_rename_field_put_init_shorthand() {\n-        mark::check!(test_rename_field_put_init_shorthand);\n+        cov_mark::check!(test_rename_field_put_init_shorthand);\n         check(\n             \"bar\",\n             r#\"\n@@ -1476,7 +1478,7 @@ fn foo(bar: i32) -> Foo {\n \n     #[test]\n     fn test_rename_local_put_init_shorthand() {\n-        mark::check!(test_rename_local_put_init_shorthand);\n+        cov_mark::check!(test_rename_local_put_init_shorthand);\n         check(\n             \"i\",\n             r#\"\n@@ -1498,7 +1500,7 @@ fn foo(i: i32) -> Foo {\n \n     #[test]\n     fn test_struct_field_pat_into_shorthand() {\n-        mark::check!(test_rename_field_put_init_shorthand_pat);\n+        cov_mark::check!(test_rename_field_put_init_shorthand_pat);\n         check(\n             \"baz\",\n             r#\"\n@@ -1610,7 +1612,7 @@ fn foo(foo: Foo) {\n \n     #[test]\n     fn test_rename_lifetimes() {\n-        mark::check!(rename_lifetime);\n+        cov_mark::check!(rename_lifetime);\n         check(\n             \"'yeeee\",\n             r#\"\n@@ -1698,7 +1700,7 @@ fn foo<'a>() -> &'a () {\n \n     #[test]\n     fn test_self_to_self() {\n-        mark::check!(rename_self_to_self);\n+        cov_mark::check!(rename_self_to_self);\n         check(\n             \"self\",\n             r#\""}, {"sha": "280565563834e21e0e3aa7b5329153843beaef1b", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -9,7 +9,6 @@ use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     match_ast, SyntaxNode,\n };\n-use test_utils::mark;\n \n use crate::{\n     display::{ToNav, TryToNav},\n@@ -130,7 +129,9 @@ fn runnables_mod(sema: &Semantics<RootDatabase>, acc: &mut Vec<Runnable>, module\n         if let hir::ModuleDef::Module(submodule) = def {\n             match submodule.definition_source(sema.db).value {\n                 hir::ModuleSource::Module(_) => runnables_mod(sema, acc, submodule),\n-                hir::ModuleSource::SourceFile(_) => mark::hit!(dont_recurse_in_outline_submodules),\n+                hir::ModuleSource::SourceFile(_) => {\n+                    cov_mark::hit!(dont_recurse_in_outline_submodules)\n+                }\n                 hir::ModuleSource::BlockExpr(_) => {} // inner items aren't runnable\n             }\n         }\n@@ -328,7 +329,6 @@ fn has_test_function_or_multiple_test_submodules(\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::fixture;\n \n@@ -1056,7 +1056,7 @@ mod tests {\n \n     #[test]\n     fn dont_recurse_in_outline_submodules() {\n-        mark::check!(dont_recurse_in_outline_submodules);\n+        cov_mark::check!(dont_recurse_in_outline_submodules);\n         check(\n             r#\"\n //- /lib.rs"}, {"sha": "978c479de3bd5fb71b063604df30fb8565587cc7", "filename": "crates/ide/src/typing/on_enter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -9,7 +9,7 @@ use syntax::{\n     SyntaxKind::*,\n     SyntaxToken, TextRange, TextSize, TokenAtOffset,\n };\n-use test_utils::mark;\n+\n use text_edit::TextEdit;\n \n // Feature: On Enter\n@@ -55,7 +55,7 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Text\n     // Continuing single-line non-doc comments (like this one :) ) is annoying\n     if prefix == \"//\" && comment_range.end() == position.offset {\n         if comment.text().ends_with(' ') {\n-            mark::hit!(continues_end_of_line_comment_with_space);\n+            cov_mark::hit!(continues_end_of_line_comment_with_space);\n             remove_trailing_whitespace = true;\n         } else if !followed_by_comment(&comment) {\n             return None;\n@@ -109,7 +109,7 @@ fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n #[cfg(test)]\n mod tests {\n     use stdx::trim_indent;\n-    use test_utils::{assert_eq_text, mark};\n+    use test_utils::assert_eq_text;\n \n     use crate::fixture;\n \n@@ -238,7 +238,7 @@ fn main() {\n \n     #[test]\n     fn continues_end_of_line_comment_with_space() {\n-        mark::check!(continues_end_of_line_comment_with_space);\n+        cov_mark::check!(continues_end_of_line_comment_with_space);\n         do_check(\n             r#\"\n fn main() {"}, {"sha": "3bf0099a92c5e9c45dc82decfdf6201c05c7973c", "filename": "crates/ide_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n rustc-hash = \"1.1.0\"\n itertools = \"0.10.0\"\n either = \"1.6.1\""}, {"sha": "3b6efbab42440f351be028c3eb084d4932bcbcbe", "filename": "crates/ide_assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,6 +1,5 @@\n use ide_db::defs::{Definition, NameRefClass};\n use syntax::{ast, AstNode, SyntaxKind, T};\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -30,13 +29,13 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         if arg_list.args().count() > 0 {\n             return None;\n         }\n-        mark::hit!(add_turbo_fish_after_call);\n-        mark::hit!(add_type_ascription_after_call);\n+        cov_mark::hit!(add_turbo_fish_after_call);\n+        cov_mark::hit!(add_type_ascription_after_call);\n         arg_list.l_paren_token()?.prev_token().filter(|it| it.kind() == SyntaxKind::IDENT)\n     })?;\n     let next_token = ident.next_token()?;\n     if next_token.kind() == T![::] {\n-        mark::hit!(add_turbo_fish_one_fish_is_enough);\n+        cov_mark::hit!(add_turbo_fish_one_fish_is_enough);\n         return None;\n     }\n     let name_ref = ast::NameRef::cast(ident.parent())?;\n@@ -50,7 +49,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     };\n     let generics = hir::GenericDef::Function(fun).params(ctx.sema.db);\n     if generics.is_empty() {\n-        mark::hit!(add_turbo_fish_non_generic);\n+        cov_mark::hit!(add_turbo_fish_non_generic);\n         return None;\n     }\n \n@@ -67,7 +66,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n                 },\n             )?\n         } else {\n-            mark::hit!(add_type_ascription_already_typed);\n+            cov_mark::hit!(add_type_ascription_already_typed);\n         }\n     }\n \n@@ -87,7 +86,6 @@ mod tests {\n     use crate::tests::{check_assist, check_assist_by_label, check_assist_not_applicable};\n \n     use super::*;\n-    use test_utils::mark;\n \n     #[test]\n     fn add_turbo_fish_function() {\n@@ -110,7 +108,7 @@ fn main() {\n \n     #[test]\n     fn add_turbo_fish_after_call() {\n-        mark::check!(add_turbo_fish_after_call);\n+        cov_mark::check!(add_turbo_fish_after_call);\n         check_assist(\n             add_turbo_fish,\n             r#\"\n@@ -155,7 +153,7 @@ fn main() {\n \n     #[test]\n     fn add_turbo_fish_one_fish_is_enough() {\n-        mark::check!(add_turbo_fish_one_fish_is_enough);\n+        cov_mark::check!(add_turbo_fish_one_fish_is_enough);\n         check_assist_not_applicable(\n             add_turbo_fish,\n             r#\"\n@@ -169,7 +167,7 @@ fn main() {\n \n     #[test]\n     fn add_turbo_fish_non_generic() {\n-        mark::check!(add_turbo_fish_non_generic);\n+        cov_mark::check!(add_turbo_fish_non_generic);\n         check_assist_not_applicable(\n             add_turbo_fish,\n             r#\"\n@@ -203,7 +201,7 @@ fn main() {\n \n     #[test]\n     fn add_type_ascription_after_call() {\n-        mark::check!(add_type_ascription_after_call);\n+        cov_mark::check!(add_type_ascription_after_call);\n         check_assist_by_label(\n             add_turbo_fish,\n             r#\"\n@@ -250,7 +248,7 @@ fn main() {\n \n     #[test]\n     fn add_type_ascription_already_typed() {\n-        mark::check!(add_type_ascription_already_typed);\n+        cov_mark::check!(add_type_ascription_already_typed);\n         check_assist(\n             add_turbo_fish,\n             r#\""}, {"sha": "a1c339603f74042424dfdbe985c754d0e29021cc", "filename": "crates/ide_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,5 +1,4 @@\n use syntax::ast::{self, AstNode};\n-use test_utils::mark;\n \n use crate::{utils::invert_boolean_expression, AssistContext, AssistId, AssistKind, Assists};\n \n@@ -64,10 +63,10 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n                 edit.replace(lhs_range, not_lhs.syntax().text());\n                 edit.replace(rhs_range, not_rhs.syntax().text());\n                 if let Some(neg_expr) = neg_expr {\n-                    mark::hit!(demorgan_double_negation);\n+                    cov_mark::hit!(demorgan_double_negation);\n                     edit.replace(neg_expr.op_token().unwrap().text_range(), \"\");\n                 } else {\n-                    mark::hit!(demorgan_double_parens);\n+                    cov_mark::hit!(demorgan_double_parens);\n                     edit.replace(paren_expr.l_paren_token().unwrap().text_range(), \"!(\");\n                 }\n             } else {\n@@ -90,7 +89,6 @@ fn opposite_logic_op(kind: ast::BinOp) -> Option<&'static str> {\n #[cfg(test)]\n mod tests {\n     use ide_db::helpers::FamousDefs;\n-    use test_utils::mark;\n \n     use super::*;\n \n@@ -188,13 +186,13 @@ fn f() {\n \n     #[test]\n     fn demorgan_doesnt_double_negation() {\n-        mark::check!(demorgan_double_negation);\n+        cov_mark::check!(demorgan_double_negation);\n         check_assist(apply_demorgan, \"fn f() { !(x ||$0 x) }\", \"fn f() { (!x && !x) }\")\n     }\n \n     #[test]\n     fn demorgan_doesnt_double_parens() {\n-        mark::check!(demorgan_double_parens);\n+        cov_mark::check!(demorgan_double_parens);\n         check_assist(apply_demorgan, \"fn f() { (x ||$0 x) }\", \"fn f() { !(!x && !x) }\")\n     }\n }"}, {"sha": "ec99a5505e7da0534736098e6c79829488dce94d", "filename": "crates/ide_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,6 @@ use syntax::{\n     SyntaxKind::{CONST, ENUM, FN, MODULE, STATIC, STRUCT, TRAIT, TYPE_ALIAS, VISIBILITY},\n     T,\n };\n-use test_utils::mark;\n \n use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n \n@@ -56,7 +55,7 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     } else if let Some(field_name) = ctx.find_node_at_offset::<ast::Name>() {\n         let field = field_name.syntax().ancestors().find_map(ast::RecordField::cast)?;\n         if field.name()? != field_name {\n-            mark::hit!(change_visibility_field_false_positive);\n+            cov_mark::hit!(change_visibility_field_false_positive);\n             return None;\n         }\n         if field.visibility().is_some() {\n@@ -110,8 +109,6 @@ fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n@@ -139,7 +136,7 @@ mod tests {\n \n     #[test]\n     fn change_visibility_field_false_positive() {\n-        mark::check!(change_visibility_field_false_positive);\n+        cov_mark::check!(change_visibility_field_false_positive);\n         check_assist_not_applicable(\n             change_visibility,\n             r\"struct S { field: [(); { let $0x = ();}] }\","}, {"sha": "dd45017099c3242b9809c8fef7f1f29c76f4a123", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -20,7 +20,6 @@ use syntax::{\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -59,7 +58,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n     let node = ctx.covering_element();\n     if node.kind() == COMMENT {\n-        mark::hit!(extract_function_in_comment_is_not_applicable);\n+        cov_mark::hit!(extract_function_in_comment_is_not_applicable);\n         return None;\n     }\n \n@@ -197,26 +196,26 @@ fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<Con\n                 if let Some(kind) = expr_err_kind(&expr, ctx) {\n                     Some(FlowKind::TryReturn { expr, kind })\n                 } else {\n-                    mark::hit!(external_control_flow_try_and_return_non_err);\n+                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n                     return None;\n                 }\n             }\n             None => return None,\n         },\n         (Some(_), _, _, _) => {\n-            mark::hit!(external_control_flow_try_and_bc);\n+            cov_mark::hit!(external_control_flow_try_and_bc);\n             return None;\n         }\n         (None, Some(r), None, None) => match r.expr() {\n             Some(expr) => Some(FlowKind::ReturnValue(expr)),\n             None => Some(FlowKind::Return),\n         },\n         (None, Some(_), _, _) => {\n-            mark::hit!(external_control_flow_return_and_bc);\n+            cov_mark::hit!(external_control_flow_return_and_bc);\n             return None;\n         }\n         (None, None, Some(_), Some(_)) => {\n-            mark::hit!(external_control_flow_break_and_continue);\n+            cov_mark::hit!(external_control_flow_break_and_continue);\n             return None;\n         }\n         (None, None, Some(b), None) => match b.expr() {\n@@ -1837,7 +1836,7 @@ fn $0fun_name(n: u32) -> u32 {\n \n     #[test]\n     fn in_comment_is_not_applicable() {\n-        mark::check!(extract_function_in_comment_is_not_applicable);\n+        cov_mark::check!(extract_function_in_comment_is_not_applicable);\n         check_assist_not_applicable(extract_function, r\"fn main() { 1 + /* $0comment$0 */ 1; }\");\n     }\n \n@@ -2822,7 +2821,7 @@ fn $0fun_name(n: i32) -> Result<i32, i64> {\n \n     #[test]\n     fn break_and_continue() {\n-        mark::check!(external_control_flow_break_and_continue);\n+        cov_mark::check!(external_control_flow_break_and_continue);\n         check_assist_not_applicable(\n             extract_function,\n             r##\"\n@@ -2842,7 +2841,7 @@ fn foo() {\n \n     #[test]\n     fn return_and_break() {\n-        mark::check!(external_control_flow_return_and_bc);\n+        cov_mark::check!(external_control_flow_return_and_bc);\n         check_assist_not_applicable(\n             extract_function,\n             r##\"\n@@ -3341,7 +3340,7 @@ fn $0fun_name() -> Result<i32, i64> {\n \n     #[test]\n     fn try_and_break() {\n-        mark::check!(external_control_flow_try_and_bc);\n+        cov_mark::check!(external_control_flow_try_and_bc);\n         check_assist_not_applicable(\n             extract_function,\n             r##\"\n@@ -3363,7 +3362,7 @@ fn foo() -> Option<()> {\n \n     #[test]\n     fn try_and_return_ok() {\n-        mark::check!(external_control_flow_try_and_return_non_err);\n+        cov_mark::check!(external_control_flow_try_and_return_non_err);\n         check_assist_not_applicable(\n             extract_function,\n             r##\""}, {"sha": "7a32483dc9459703563c01ecdaa8b21abb9a1a39", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -6,7 +6,6 @@ use syntax::{\n     },\n     SyntaxNode,\n };\n-use test_utils::mark;\n \n use crate::{utils::suggest_name, AssistContext, AssistId, AssistKind, Assists};\n \n@@ -32,7 +31,7 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n     }\n     let node = ctx.covering_element();\n     if node.kind() == COMMENT {\n-        mark::hit!(extract_var_in_comment_is_not_applicable);\n+        cov_mark::hit!(extract_var_in_comment_is_not_applicable);\n         return None;\n     }\n     let to_extract = node.ancestors().find_map(valid_target_expr)?;\n@@ -69,7 +68,7 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n             format_to!(buf, \"{}\", to_extract.syntax());\n \n             if let Anchor::Replace(stmt) = anchor {\n-                mark::hit!(test_extract_var_expr_stmt);\n+                cov_mark::hit!(test_extract_var_expr_stmt);\n                 if stmt.semicolon_token().is_none() {\n                     buf.push_str(\";\");\n                 }\n@@ -142,7 +141,7 @@ impl Anchor {\n                 node.parent().and_then(ast::BlockExpr::cast).and_then(|it| it.tail_expr())\n             {\n                 if expr.syntax() == &node {\n-                    mark::hit!(test_extract_var_last_expr);\n+                    cov_mark::hit!(test_extract_var_last_expr);\n                     return Some(Anchor::Before(node));\n                 }\n             }\n@@ -175,8 +174,6 @@ impl Anchor {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n@@ -199,13 +196,13 @@ fn foo() {\n \n     #[test]\n     fn extract_var_in_comment_is_not_applicable() {\n-        mark::check!(extract_var_in_comment_is_not_applicable);\n+        cov_mark::check!(extract_var_in_comment_is_not_applicable);\n         check_assist_not_applicable(extract_variable, \"fn main() { 1 + /* $0comment$0 */ 1; }\");\n     }\n \n     #[test]\n     fn test_extract_var_expr_stmt() {\n-        mark::check!(test_extract_var_expr_stmt);\n+        cov_mark::check!(test_extract_var_expr_stmt);\n         check_assist(\n             extract_variable,\n             r#\"\n@@ -250,7 +247,7 @@ fn foo() {\n \n     #[test]\n     fn test_extract_var_last_expr() {\n-        mark::check!(test_extract_var_last_expr);\n+        cov_mark::check!(test_extract_var_last_expr);\n         check_assist(\n             extract_variable,\n             r#\""}, {"sha": "878b3a3fac4b0ec4998b96646d4404ea9c896357", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -5,7 +5,6 @@ use ide_db::helpers::{mod_path_to_ast, FamousDefs};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n use syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n-use test_utils::mark;\n \n use crate::{\n     utils::{does_pat_match_variant, render_snippet, Cursor},\n@@ -62,7 +61,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             .collect::<Vec<_>>();\n         if Some(enum_def) == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option() {\n             // Match `Some` variant first.\n-            mark::hit!(option_order);\n+            cov_mark::hit!(option_order);\n             variants.reverse()\n         }\n         variants\n@@ -195,7 +194,6 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::Variant) -> Optio\n #[cfg(test)]\n mod tests {\n     use ide_db::helpers::FamousDefs;\n-    use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n@@ -730,7 +728,7 @@ fn main() {\n \n     #[test]\n     fn option_order() {\n-        mark::check!(option_order);\n+        cov_mark::check!(option_order);\n         let before = r#\"\n fn foo(opt: Option<i32>) {\n     match opt$0 {"}, {"sha": "588ee13509899564d0144332f0cecf8532db415c", "filename": "crates/ide_assists/src/handlers/generate_default_from_enum_variant.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,7 +1,6 @@\n use ide_db::helpers::FamousDefs;\n use ide_db::RootDatabase;\n use syntax::ast::{self, AstNode, NameOwner};\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -38,12 +37,12 @@ pub(crate) fn generate_default_from_enum_variant(\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n     if !matches!(variant.kind(), ast::StructKind::Unit) {\n-        mark::hit!(test_gen_default_on_non_unit_variant_not_implemented);\n+        cov_mark::hit!(test_gen_default_on_non_unit_variant_not_implemented);\n         return None;\n     }\n \n     if existing_default_impl(&ctx.sema, &variant).is_some() {\n-        mark::hit!(test_gen_default_impl_already_exists);\n+        cov_mark::hit!(test_gen_default_impl_already_exists);\n         return None;\n     }\n \n@@ -89,8 +88,6 @@ fn existing_default_impl(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n@@ -127,7 +124,7 @@ impl Default for Variant {\n \n     #[test]\n     fn test_generate_default_already_implemented() {\n-        mark::check!(test_gen_default_impl_already_exists);\n+        cov_mark::check!(test_gen_default_impl_already_exists);\n         check_not_applicable(\n             r#\"\n enum Variant {\n@@ -146,7 +143,7 @@ impl Default for Variant {\n \n     #[test]\n     fn test_add_from_impl_no_element() {\n-        mark::check!(test_gen_default_on_non_unit_variant_not_implemented);\n+        cov_mark::check!(test_gen_default_on_non_unit_variant_not_implemented);\n         check_not_applicable(\n             r#\"\n enum Variant {"}, {"sha": "81c54ba3ec6c0e91de21dc6a8de53e7d92e9e0dd", "filename": "crates/ide_assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -7,7 +7,6 @@ use syntax::{\n     ast::{self, Impl, NameOwner},\n     AstNode,\n };\n-use test_utils::mark;\n \n // Assist: generate_default_from_new\n //\n@@ -43,19 +42,19 @@ pub(crate) fn generate_default_from_new(acc: &mut Assists, ctx: &AssistContext)\n     let fn_name = fn_node.name()?;\n \n     if fn_name.text() != \"new\" {\n-        mark::hit!(other_function_than_new);\n+        cov_mark::hit!(other_function_than_new);\n         return None;\n     }\n \n     if fn_node.param_list()?.params().next().is_some() {\n-        mark::hit!(new_function_with_parameters);\n+        cov_mark::hit!(new_function_with_parameters);\n         return None;\n     }\n \n     let impl_ = fn_node.syntax().ancestors().into_iter().find_map(ast::Impl::cast)?;\n     if is_default_implemented(ctx, &impl_) {\n-        mark::hit!(default_block_is_already_present);\n-        mark::hit!(struct_in_module_with_default);\n+        cov_mark::hit!(default_block_is_already_present);\n+        cov_mark::hit!(struct_in_module_with_default);\n         return None;\n     }\n \n@@ -178,7 +177,7 @@ impl Default for Test {\n \n     #[test]\n     fn new_function_with_parameters() {\n-        mark::check!(new_function_with_parameters);\n+        cov_mark::check!(new_function_with_parameters);\n         check_not_applicable(\n             r#\"\n struct Example { _inner: () }\n@@ -194,7 +193,7 @@ impl Example {\n \n     #[test]\n     fn other_function_than_new() {\n-        mark::check!(other_function_than_new);\n+        cov_mark::check!(other_function_than_new);\n         check_not_applicable(\n             r#\"\n struct Example { _inner: () }\n@@ -211,7 +210,7 @@ impl Example {\n \n     #[test]\n     fn default_block_is_already_present() {\n-        mark::check!(default_block_is_already_present);\n+        cov_mark::check!(default_block_is_already_present);\n         check_not_applicable(\n             r#\"\n struct Example { _inner: () }\n@@ -340,7 +339,7 @@ impl Default for Example {\n \n     #[test]\n     fn struct_in_module_with_default() {\n-        mark::check!(struct_in_module_with_default);\n+        cov_mark::check!(struct_in_module_with_default);\n         check_not_applicable(\n             r#\"\n mod test {"}, {"sha": "c13c6eebe8845083b4851b931ccb44cf90010b2e", "filename": "crates/ide_assists/src/handlers/generate_from_impl_for_enum.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,7 +1,6 @@\n use ide_db::helpers::FamousDefs;\n use ide_db::RootDatabase;\n use syntax::ast::{self, AstNode, NameOwner};\n-use test_utils::mark;\n \n use crate::{utils::generate_trait_impl_text, AssistContext, AssistId, AssistKind, Assists};\n \n@@ -44,7 +43,7 @@ pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext\n     };\n \n     if existing_from_impl(&ctx.sema, &variant).is_some() {\n-        mark::hit!(test_add_from_impl_already_exists);\n+        cov_mark::hit!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n@@ -103,8 +102,6 @@ fn existing_from_impl(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n@@ -172,7 +169,7 @@ impl From<u32> for A {\n \n     #[test]\n     fn test_add_from_impl_already_exists() {\n-        mark::check!(test_add_from_impl_already_exists);\n+        cov_mark::check!(test_add_from_impl_already_exists);\n         check_not_applicable(\n             r#\"\n enum A { $0One(u32), }"}, {"sha": "66113751c66c26dce1d8c817ec0262fadd72dc98", "filename": "crates/ide_assists/src/handlers/infer_function_return_type.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,6 +1,5 @@\n use hir::HirDisplay;\n use syntax::{ast, AstNode, TextRange, TextSize};\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -42,7 +41,7 @@ pub(crate) fn infer_function_return_type(acc: &mut Assists, ctx: &AssistContext)\n                 }\n             }\n             if let FnType::Closure { wrap_expr: true } = fn_type {\n-                mark::hit!(wrap_closure_non_block_expr);\n+                cov_mark::hit!(wrap_closure_non_block_expr);\n                 // `|x| x` becomes `|x| -> T x` which is invalid, so wrap it in a block\n                 builder.replace(tail_expr.syntax().text_range(), &format!(\"{{{}}}\", tail_expr));\n             }\n@@ -61,13 +60,13 @@ fn ret_ty_to_action(ret_ty: Option<ast::RetType>, insert_pos: TextSize) -> Optio\n     match ret_ty {\n         Some(ret_ty) => match ret_ty.ty() {\n             Some(ast::Type::InferType(_)) | None => {\n-                mark::hit!(existing_infer_ret_type);\n-                mark::hit!(existing_infer_ret_type_closure);\n+                cov_mark::hit!(existing_infer_ret_type);\n+                cov_mark::hit!(existing_infer_ret_type_closure);\n                 Some(InsertOrReplace::Replace(ret_ty.syntax().text_range()))\n             }\n             _ => {\n-                mark::hit!(existing_ret_type);\n-                mark::hit!(existing_ret_type_closure);\n+                cov_mark::hit!(existing_ret_type);\n+                cov_mark::hit!(existing_ret_type_closure);\n                 None\n             }\n         },\n@@ -109,11 +108,11 @@ fn extract_tail(ctx: &AssistContext) -> Option<(FnType, ast::Expr, InsertOrRepla\n         };\n     let frange = ctx.frange.range;\n     if return_type_range.contains_range(frange) {\n-        mark::hit!(cursor_in_ret_position);\n-        mark::hit!(cursor_in_ret_position_closure);\n+        cov_mark::hit!(cursor_in_ret_position);\n+        cov_mark::hit!(cursor_in_ret_position_closure);\n     } else if tail_expr.syntax().text_range().contains_range(frange) {\n-        mark::hit!(cursor_on_tail);\n-        mark::hit!(cursor_on_tail_closure);\n+        cov_mark::hit!(cursor_on_tail);\n+        cov_mark::hit!(cursor_on_tail_closure);\n     } else {\n         return None;\n     }\n@@ -128,7 +127,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type_specified_inferred() {\n-        mark::check!(existing_infer_ret_type);\n+        cov_mark::check!(existing_infer_ret_type);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() -> $0_ {\n@@ -142,7 +141,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type_specified_inferred_closure() {\n-        mark::check!(existing_infer_ret_type_closure);\n+        cov_mark::check!(existing_infer_ret_type_closure);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() {\n@@ -156,7 +155,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type_cursor_at_return_type_pos() {\n-        mark::check!(cursor_in_ret_position);\n+        cov_mark::check!(cursor_in_ret_position);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() $0{\n@@ -170,7 +169,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type_cursor_at_return_type_pos_closure() {\n-        mark::check!(cursor_in_ret_position_closure);\n+        cov_mark::check!(cursor_in_ret_position_closure);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() {\n@@ -184,7 +183,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type() {\n-        mark::check!(cursor_on_tail);\n+        cov_mark::check!(cursor_on_tail);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() {\n@@ -219,7 +218,7 @@ mod tests {\n \n     #[test]\n     fn not_applicable_ret_type_specified() {\n-        mark::check!(existing_ret_type);\n+        cov_mark::check!(existing_ret_type);\n         check_assist_not_applicable(\n             infer_function_return_type,\n             r#\"fn foo() -> i32 {\n@@ -251,7 +250,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type_closure_block() {\n-        mark::check!(cursor_on_tail_closure);\n+        cov_mark::check!(cursor_on_tail_closure);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() {\n@@ -282,7 +281,7 @@ mod tests {\n \n     #[test]\n     fn infer_return_type_closure_wrap() {\n-        mark::check!(wrap_closure_non_block_expr);\n+        cov_mark::check!(wrap_closure_non_block_expr);\n         check_assist(\n             infer_function_return_type,\n             r#\"fn foo() {\n@@ -321,7 +320,7 @@ mod tests {\n \n     #[test]\n     fn not_applicable_ret_type_specified_closure() {\n-        mark::check!(existing_ret_type_closure);\n+        cov_mark::check!(existing_ret_type_closure);\n         check_assist_not_applicable(\n             infer_function_return_type,\n             r#\"fn foo() {"}, {"sha": "8e56029cb3f8457e6d1fecc85784815bc752334b", "filename": "crates/ide_assists/src/handlers/inline_function.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,6 @@ use syntax::{\n     ast::{self, edit::AstNodeEdit, ArgListOwner},\n     AstNode,\n };\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -49,7 +48,7 @@ pub(crate) fn inline_function(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     if arguments.len() != parameters.len() {\n         // Can't inline the function because they've passed the wrong number of\n         // arguments to this function\n-        mark::hit!(inline_function_incorrect_number_of_arguments);\n+        cov_mark::hit!(inline_function_incorrect_number_of_arguments);\n         return None;\n     }\n \n@@ -155,7 +154,7 @@ fn main() { Foo.bar$0(); }\n \n     #[test]\n     fn not_applicable_when_incorrect_number_of_parameters_are_provided() {\n-        mark::check!(inline_function_incorrect_number_of_arguments);\n+        cov_mark::check!(inline_function_incorrect_number_of_arguments);\n         check_assist_not_applicable(\n             inline_function,\n             r#\""}, {"sha": "ea1466dc8c2d75517926234ccaa2ddc62a8b6cd6", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,6 @@ use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n };\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -34,11 +33,11 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         _ => return None,\n     };\n     if bind_pat.mut_token().is_some() {\n-        mark::hit!(test_not_inline_mut_variable);\n+        cov_mark::hit!(test_not_inline_mut_variable);\n         return None;\n     }\n     if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n-        mark::hit!(not_applicable_outside_of_bind_pat);\n+        cov_mark::hit!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n     let initializer_expr = let_stmt.initializer()?;\n@@ -47,7 +46,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     let def = Definition::Local(def);\n     let usages = def.usages(&ctx.sema).all();\n     if usages.is_empty() {\n-        mark::hit!(test_not_applicable_if_variable_unused);\n+        cov_mark::hit!(test_not_applicable_if_variable_unused);\n         return None;\n     };\n \n@@ -130,7 +129,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n                         Some(name_ref)\n                             if ast::RecordExprField::for_field_name(name_ref).is_some() =>\n                         {\n-                            mark::hit!(inline_field_shorthand);\n+                            cov_mark::hit!(inline_field_shorthand);\n                             builder.insert(reference.range.end(), format!(\": {}\", replacement));\n                         }\n                         _ => builder.replace(reference.range, replacement),\n@@ -143,8 +142,6 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n@@ -351,7 +348,7 @@ fn foo() {\n \n     #[test]\n     fn test_not_inline_mut_variable() {\n-        mark::check!(test_not_inline_mut_variable);\n+        cov_mark::check!(test_not_inline_mut_variable);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\"\n@@ -684,7 +681,7 @@ fn foo() {\n \n     #[test]\n     fn inline_field_shorthand() {\n-        mark::check!(inline_field_shorthand);\n+        cov_mark::check!(inline_field_shorthand);\n         check_assist(\n             inline_local_variable,\n             r\"\n@@ -705,7 +702,7 @@ fn main() {\n \n     #[test]\n     fn test_not_applicable_if_variable_unused() {\n-        mark::check!(test_not_applicable_if_variable_unused);\n+        cov_mark::check!(test_not_applicable_if_variable_unused);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\"\n@@ -718,7 +715,7 @@ fn foo() {\n \n     #[test]\n     fn not_applicable_outside_of_bind_pat() {\n-        mark::check!(not_applicable_outside_of_bind_pat);\n+        cov_mark::check!(not_applicable_outside_of_bind_pat);\n         check_assist_not_applicable(\n             inline_local_variable,\n             r\""}, {"sha": "6e685b4b293f7eac125fc71ae8fc172b59d47773", "filename": "crates/ide_assists/src/handlers/move_module_to_file.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -5,7 +5,6 @@ use syntax::{\n     ast::{self, edit::AstNodeEdit, NameOwner},\n     AstNode, TextRange,\n };\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -28,7 +27,7 @@ pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext) -> Opt\n \n     let l_curly_offset = module_items.syntax().text_range().start();\n     if l_curly_offset <= ctx.offset() {\n-        mark::hit!(available_before_curly);\n+        cov_mark::hit!(available_before_curly);\n         return None;\n     }\n     let target = TextRange::new(module_ast.syntax().text_range().start(), l_curly_offset);\n@@ -182,7 +181,7 @@ pub(crate) mod tests;\n \n     #[test]\n     fn available_before_curly() {\n-        mark::check!(available_before_curly);\n+        cov_mark::check!(available_before_curly);\n         check_assist_not_applicable(move_module_to_file, r#\"mod m { $0 }\"#);\n     }\n }"}, {"sha": "04bae4e58283fc97144f1463bc90b78ba6c1b146", "filename": "crates/ide_assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,6 @@ use syntax::{\n     ast::{self, edit::AstNodeEdit, make},\n     AstNode,\n };\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -104,7 +103,7 @@ fn exprify_if(\n             ast::ElseBranch::Block(exprify_block(block, sema, name)?)\n         }\n         ast::ElseBranch::IfExpr(expr) => {\n-            mark::hit!(test_pull_assignment_up_chained_if);\n+            cov_mark::hit!(test_pull_assignment_up_chained_if);\n             ast::ElseBranch::IfExpr(ast::IfExpr::cast(\n                 exprify_if(&expr, sema, name)?.syntax().to_owned(),\n             )?)\n@@ -144,7 +143,7 @@ fn is_equivalent(\n ) -> bool {\n     match (expr0, expr1) {\n         (ast::Expr::FieldExpr(field_expr0), ast::Expr::FieldExpr(field_expr1)) => {\n-            mark::hit!(test_pull_assignment_up_field_assignment);\n+            cov_mark::hit!(test_pull_assignment_up_field_assignment);\n             sema.resolve_field(field_expr0) == sema.resolve_field(field_expr1)\n         }\n         (ast::Expr::PathExpr(path0), ast::Expr::PathExpr(path1)) => {\n@@ -160,7 +159,7 @@ fn is_equivalent(\n             if prefix0.op_kind() == Some(ast::PrefixOp::Deref)\n                 && prefix1.op_kind() == Some(ast::PrefixOp::Deref) =>\n         {\n-            mark::hit!(test_pull_assignment_up_deref);\n+            cov_mark::hit!(test_pull_assignment_up_deref);\n             if let (Some(prefix0), Some(prefix1)) = (prefix0.expr(), prefix1.expr()) {\n                 is_equivalent(sema, &prefix0, &prefix1)\n             } else {\n@@ -263,7 +262,7 @@ fn foo() {\n \n     #[test]\n     fn test_pull_assignment_up_chained_if() {\n-        mark::check!(test_pull_assignment_up_chained_if);\n+        cov_mark::check!(test_pull_assignment_up_chained_if);\n         check_assist(\n             pull_assignment_up,\n             r#\"\n@@ -379,7 +378,7 @@ fn foo() {\n \n     #[test]\n     fn test_pull_assignment_up_field_assignment() {\n-        mark::check!(test_pull_assignment_up_field_assignment);\n+        cov_mark::check!(test_pull_assignment_up_field_assignment);\n         check_assist(\n             pull_assignment_up,\n             r#\"\n@@ -411,7 +410,7 @@ fn foo() {\n \n     #[test]\n     fn test_pull_assignment_up_deref() {\n-        mark::check!(test_pull_assignment_up_deref);\n+        cov_mark::check!(test_pull_assignment_up_deref);\n         check_assist(\n             pull_assignment_up,\n             r#\""}, {"sha": "d3e34e5403a14707957fc652c9142f1cdd49b944", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -8,7 +8,6 @@ use syntax::{\n     ast::{make, ArgListOwner},\n     AstNode,\n };\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -47,25 +46,25 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let qualify_candidate = match candidate {\n         ImportCandidate::Path(candidate) => {\n             if candidate.qualifier.is_some() {\n-                mark::hit!(qualify_path_qualifier_start);\n+                cov_mark::hit!(qualify_path_qualifier_start);\n                 let path = ast::Path::cast(syntax_under_caret)?;\n                 let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n                 QualifyCandidate::QualifierStart(segment, prev_segment.generic_arg_list())\n             } else {\n-                mark::hit!(qualify_path_unqualified_name);\n+                cov_mark::hit!(qualify_path_unqualified_name);\n                 let path = ast::Path::cast(syntax_under_caret)?;\n                 let generics = path.segment()?.generic_arg_list();\n                 QualifyCandidate::UnqualifiedName(generics)\n             }\n         }\n         ImportCandidate::TraitAssocItem(_) => {\n-            mark::hit!(qualify_path_trait_assoc_item);\n+            cov_mark::hit!(qualify_path_trait_assoc_item);\n             let path = ast::Path::cast(syntax_under_caret)?;\n             let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n             QualifyCandidate::TraitAssocItem(qualifier, segment)\n         }\n         ImportCandidate::TraitMethod(_) => {\n-            mark::hit!(qualify_path_trait_method);\n+            cov_mark::hit!(qualify_path_trait_method);\n             let mcall_expr = ast::MethodCallExpr::cast(syntax_under_caret)?;\n             QualifyCandidate::TraitMethod(ctx.sema.db, mcall_expr)\n         }\n@@ -212,7 +211,7 @@ mod tests {\n \n     #[test]\n     fn applicable_when_found_an_import_partial() {\n-        mark::check!(qualify_path_unqualified_name);\n+        cov_mark::check!(qualify_path_unqualified_name);\n         check_assist(\n             qualify_path,\n             r\"\n@@ -504,7 +503,7 @@ fn main() {\n \n     #[test]\n     fn associated_struct_const() {\n-        mark::check!(qualify_path_qualifier_start);\n+        cov_mark::check!(qualify_path_qualifier_start);\n         check_assist(\n             qualify_path,\n             r\"\n@@ -605,7 +604,7 @@ fn main() {\n \n     #[test]\n     fn associated_trait_const() {\n-        mark::check!(qualify_path_trait_assoc_item);\n+        cov_mark::check!(qualify_path_trait_assoc_item);\n         check_assist(\n             qualify_path,\n             r\"\n@@ -675,7 +674,7 @@ fn main() {\n \n     #[test]\n     fn trait_method() {\n-        mark::check!(qualify_path_trait_method);\n+        cov_mark::check!(qualify_path_trait_method);\n         check_assist(\n             qualify_path,\n             r\""}, {"sha": "d0f1613f37b158453fe0515ff737201f5cc7b3a1", "filename": "crates/ide_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,7 +1,6 @@\n use std::borrow::Cow;\n \n use syntax::{ast, AstToken, TextRange, TextSize};\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -149,7 +148,7 @@ pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let internal_text = &text[token.text_range_between_quotes()? - text_range.start()];\n \n     if existing_hashes == required_hashes(internal_text) {\n-        mark::hit!(cant_remove_required_hash);\n+        cov_mark::hit!(cant_remove_required_hash);\n         return None;\n     }\n \n@@ -182,8 +181,6 @@ fn test_required_hashes() {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n@@ -396,7 +393,7 @@ string\"###;\n \n     #[test]\n     fn cant_remove_required_hash() {\n-        mark::check!(cant_remove_required_hash);\n+        cov_mark::check!(cant_remove_required_hash);\n         check_assist_not_applicable(\n             remove_hash,\n             r##\""}, {"sha": "2699d2861c60155df4f4517eb28678f3d7b3bf48", "filename": "crates/ide_assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,7 @@ use syntax::{\n     ast::{self, ArgListOwner},\n     AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, T,\n };\n-use test_utils::mark;\n+\n use SyntaxKind::WHITESPACE;\n \n use crate::{\n@@ -49,7 +49,7 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n         Definition::Local(local)\n     };\n     if param_def.usages(&ctx.sema).at_least_one() {\n-        mark::hit!(keep_used);\n+        cov_mark::hit!(keep_used);\n         return None;\n     }\n     acc.add(\n@@ -243,7 +243,7 @@ fn b2() { foo(9) }\n \n     #[test]\n     fn keep_used() {\n-        mark::check!(keep_used);\n+        cov_mark::check!(keep_used);\n         check_assist_not_applicable(\n             remove_unused_param,\n             r#\""}, {"sha": "794c8932365693e8ecf0b22e822c31015bf0f1f4", "filename": "crates/ide_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,6 @@ use rustc_hash::FxHashMap;\n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n use ide_db::RootDatabase;\n use syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -39,7 +38,7 @@ fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     });\n \n     if sorted_fields == fields {\n-        mark::hit!(reorder_sorted_fields);\n+        cov_mark::hit!(reorder_sorted_fields);\n         return None;\n     }\n \n@@ -109,15 +108,13 @@ fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashM\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n     #[test]\n     fn reorder_sorted_fields() {\n-        mark::check!(reorder_sorted_fields);\n+        cov_mark::check!(reorder_sorted_fields);\n         check_assist_not_applicable(\n             reorder_fields,\n             r#\""}, {"sha": "edf4b0bfeb5c0a82755cf6e556edd0e3e1796b27", "filename": "crates/ide_assists/src/handlers/reorder_impl.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -8,7 +8,6 @@ use syntax::{\n     ast::{self, NameOwner},\n     AstNode,\n };\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -71,7 +70,7 @@ pub(crate) fn reorder_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     // Don't edit already sorted methods:\n     if methods == sorted {\n-        mark::hit!(not_applicable_if_sorted);\n+        cov_mark::hit!(not_applicable_if_sorted);\n         return None;\n     }\n \n@@ -121,15 +120,13 @@ fn get_methods(items: &ast::AssocItemList) -> Vec<ast::Fn> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n     #[test]\n     fn not_applicable_if_sorted() {\n-        mark::check!(not_applicable_if_sorted);\n+        cov_mark::check!(not_applicable_if_sorted);\n         check_assist_not_applicable(\n             reorder_impl,\n             r#\""}, {"sha": "50b05ab0b2cffe4726d080409a3a78514ace936b", "filename": "crates/ide_assists/src/handlers/replace_for_loop_with_for_each.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@ use hir::known;\n use ide_db::helpers::FamousDefs;\n use stdx::format_to;\n use syntax::{ast, AstNode};\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -34,7 +33,7 @@ pub(crate) fn replace_for_loop_with_for_each(acc: &mut Assists, ctx: &AssistCont\n     let pat = for_loop.pat()?;\n     let body = for_loop.loop_body()?;\n     if body.syntax().text_range().start() < ctx.offset() {\n-        mark::hit!(not_available_in_body);\n+        cov_mark::hit!(not_available_in_body);\n         return None;\n     }\n \n@@ -187,7 +186,7 @@ fn main() {\n \n     #[test]\n     fn not_available_in_body() {\n-        mark::check!(not_available_in_body);\n+        cov_mark::check!(not_available_in_body);\n         check_assist_not_applicable(\n             replace_for_loop_with_for_each,\n             r\""}, {"sha": "36d2e0331ec5fd0867d971f1e8262e688619f858", "filename": "crates/ide_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,6 +1,5 @@\n use ide_db::helpers::insert_use::{insert_use, ImportScope};\n use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode};\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -27,7 +26,7 @@ pub(crate) fn replace_qualified_name_with_use(\n         return None;\n     }\n     if path.qualifier().is_none() {\n-        mark::hit!(dont_import_trivial_paths);\n+        cov_mark::hit!(dont_import_trivial_paths);\n         return None;\n     }\n \n@@ -458,7 +457,7 @@ impl Debug for Foo {\n \n     #[test]\n     fn dont_import_trivial_paths() {\n-        mark::check!(dont_import_trivial_paths);\n+        cov_mark::check!(dont_import_trivial_paths);\n         check_assist_not_applicable(\n             replace_qualified_name_with_use,\n             r\""}, {"sha": "616af7c2e6ea13551e462da5cd1ac4015bd14da1", "filename": "crates/ide_assists/src/handlers/unmerge_use.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funmerge_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funmerge_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funmerge_use.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@ use syntax::{\n     ast::{self, edit::AstNodeEdit, VisibilityOwner},\n     AstNode, SyntaxKind,\n };\n-use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -27,7 +26,7 @@ pub(crate) fn unmerge_use(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let tree_list = tree.syntax().parent().and_then(ast::UseTreeList::cast)?;\n     if tree_list.use_trees().count() < 2 {\n-        mark::hit!(skip_single_use_item);\n+        cov_mark::hit!(skip_single_use_item);\n         return None;\n     }\n \n@@ -89,7 +88,7 @@ mod tests {\n \n     #[test]\n     fn skip_single_use_item() {\n-        mark::check!(skip_single_use_item);\n+        cov_mark::check!(skip_single_use_item);\n         check_assist_not_applicable(\n             unmerge_use,\n             r\""}, {"sha": "e838630eaa0fa301b7ea2d414902125f22c3cf0c", "filename": "crates/ide_assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -4,7 +4,6 @@ use syntax::{\n     ast::{self, make, BlockExpr, Expr, LoopBodyOwner},\n     match_ast, AstNode, SyntaxNode,\n };\n-use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -39,7 +38,7 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n     let first_part_ret_type = ret_type_str.splitn(2, '<').next();\n     if let Some(ret_type_first_part) = first_part_ret_type {\n         if ret_type_first_part.ends_with(\"Result\") {\n-            mark::hit!(wrap_return_type_in_result_simple_return_type_already_result);\n+            cov_mark::hit!(wrap_return_type_in_result_simple_return_type_already_result);\n             return None;\n         }\n     }\n@@ -367,7 +366,7 @@ fn foo() -> std::result::Result<i32$0, String> {\n \n     #[test]\n     fn wrap_return_type_in_result_simple_return_type_already_result() {\n-        mark::check!(wrap_return_type_in_result_simple_return_type_already_result);\n+        cov_mark::check!(wrap_return_type_in_result_simple_return_type_already_result);\n         check_assist_not_applicable(\n             wrap_return_type_in_result,\n             r#\""}, {"sha": "84aa40736d7d4490f3016090d050cead7432aaa0", "filename": "crates/ide_completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n itertools = \"0.10.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\""}, {"sha": "5ee9a9f0770441d72baaef20dcdd3c0befc450be", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,6 @@\n \n use hir::{HasVisibility, Type};\n use rustc_hash::FxHashSet;\n-use test_utils::mark;\n \n use crate::{context::CompletionContext, Completions};\n \n@@ -19,7 +18,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     };\n \n     if ctx.is_call {\n-        mark::hit!(test_no_struct_field_completion_for_method_call);\n+        cov_mark::hit!(test_no_struct_field_completion_for_method_call);\n     } else {\n         complete_fields(acc, ctx, &receiver_ty);\n     }\n@@ -62,7 +61,6 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{test_utils::completion_list, CompletionKind};\n \n@@ -122,7 +120,7 @@ impl A {\n \n     #[test]\n     fn test_no_struct_field_completion_for_method_call() {\n-        mark::check!(test_no_struct_field_completion_for_method_call);\n+        cov_mark::check!(test_no_struct_field_completion_for_method_call);\n         check(\n             r#\"\n struct A { the_field: u32 }"}, {"sha": "f34764b6103ea538b6f87a4d44ddcfb7657868ee", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -55,7 +55,6 @@ use ide_db::helpers::{\n };\n use rustc_hash::FxHashSet;\n use syntax::{AstNode, SyntaxNode, T};\n-use test_utils::mark;\n \n use crate::{\n     context::CompletionContext,\n@@ -174,7 +173,7 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n         if matches!(assets_for_path.as_ref()?.import_candidate(), ImportCandidate::Path(_))\n             && fuzzy_name_length < 2\n         {\n-            mark::hit!(ignore_short_input_for_path);\n+            cov_mark::hit!(ignore_short_input_for_path);\n             None\n         } else {\n             assets_for_path\n@@ -186,7 +185,7 @@ fn compute_fuzzy_completion_order_key(\n     proposed_mod_path: &ModPath,\n     user_input_lowercased: &str,\n ) -> usize {\n-    mark::hit!(certain_fuzzy_order_test);\n+    cov_mark::hit!(certain_fuzzy_order_test);\n     let proposed_import_name = match proposed_mod_path.segments().last() {\n         Some(name) => name.to_string().to_lowercase(),\n         None => return usize::MAX,\n@@ -200,7 +199,6 @@ fn compute_fuzzy_completion_order_key(\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{\n         item::CompletionKind,\n@@ -295,7 +293,7 @@ fn main() {\n \n     #[test]\n     fn short_paths_are_ignored() {\n-        mark::check!(ignore_short_input_for_path);\n+        cov_mark::check!(ignore_short_input_for_path);\n \n         check(\n             r#\"\n@@ -319,7 +317,7 @@ fn main() {\n \n     #[test]\n     fn fuzzy_completions_come_in_specific_order() {\n-        mark::check!(certain_fuzzy_order_test);\n+        cov_mark::check!(certain_fuzzy_order_test);\n         check(\n             r#\"\n //- /lib.rs crate:dep"}, {"sha": "80aa9fb064a9f5a9fab5501a2b97691f5c141851", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@\n use std::iter;\n \n use syntax::SyntaxKind;\n-use test_utils::mark;\n \n use crate::{CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions};\n \n@@ -47,11 +46,11 @@ pub(crate) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     if ctx.token.kind() == SyntaxKind::COMMENT {\n-        mark::hit!(no_keyword_completion_in_comments);\n+        cov_mark::hit!(no_keyword_completion_in_comments);\n         return;\n     }\n     if ctx.record_lit_syntax.is_some() {\n-        mark::hit!(no_keyword_completion_in_record_lit);\n+        cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }\n \n@@ -172,7 +171,7 @@ fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet\n         Some(cap) => {\n             let tmp;\n             let snippet = if snippet.ends_with('}') && ctx.incomplete_let {\n-                mark::hit!(let_semi);\n+                cov_mark::hit!(let_semi);\n                 tmp = format!(\"{};\", snippet);\n                 &tmp\n             } else {\n@@ -188,7 +187,6 @@ fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{\n         test_utils::{check_edit, completion_list},\n@@ -494,7 +492,7 @@ fn quux() -> i32 {\n \n     #[test]\n     fn no_keyword_completion_in_comments() {\n-        mark::check!(no_keyword_completion_in_comments);\n+        cov_mark::check!(no_keyword_completion_in_comments);\n         check(\n             r#\"\n fn test() {\n@@ -599,7 +597,7 @@ struct Foo {\n \n     #[test]\n     fn skip_struct_initializer() {\n-        mark::check!(no_keyword_completion_in_record_lit);\n+        cov_mark::check!(no_keyword_completion_in_record_lit);\n         check(\n             r#\"\n struct Foo {\n@@ -643,7 +641,7 @@ fn foo() {\n \n     #[test]\n     fn let_semi() {\n-        mark::check!(let_semi);\n+        cov_mark::check!(let_semi);\n         check_edit(\n             \"match\",\n             r#\""}, {"sha": "df74b739e9dc184815945e364e04a79585b1984c", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@\n use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n use rustc_hash::FxHashSet;\n use syntax::AstNode;\n-use test_utils::mark;\n \n use crate::{CompletionContext, Completions};\n \n@@ -39,7 +38,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                         if let Some(name_ref) = ctx.name_ref_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_string().as_str() {\n                                 // for `use self::foo$0`, don't suggest `foo` as a completion\n-                                mark::hit!(dont_complete_current_use);\n+                                cov_mark::hit!(dont_complete_current_use);\n                                 continue;\n                             }\n                         }\n@@ -155,7 +154,6 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{\n         test_utils::{check_edit, completion_list},\n@@ -174,7 +172,7 @@ mod tests {\n \n     #[test]\n     fn dont_complete_current_use() {\n-        mark::check!(dont_complete_current_use);\n+        cov_mark::check!(dont_complete_current_use);\n         check(r#\"use self::foo$0;\"#, expect![[\"\"]]);\n     }\n "}, {"sha": "044dfd16027b09ee9772efd8983772c053bc9ccb", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -2,7 +2,6 @@\n \n use hir::ScopeDef;\n use syntax::AstNode;\n-use test_utils::mark;\n \n use crate::{CompletionContext, Completions};\n \n@@ -30,13 +29,13 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n \n     ctx.scope.process_all_names(&mut |name, res| {\n         if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) = res {\n-            mark::hit!(skip_lifetime_completion);\n+            cov_mark::hit!(skip_lifetime_completion);\n             return;\n         }\n         if ctx.use_item_syntax.is_some() {\n             if let (ScopeDef::Unknown, Some(name_ref)) = (&res, &ctx.name_ref_syntax) {\n                 if name_ref.syntax().text() == name.to_string().as_str() {\n-                    mark::hit!(self_fulfilling_completion);\n+                    cov_mark::hit!(self_fulfilling_completion);\n                     return;\n                 }\n             }\n@@ -48,7 +47,6 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{\n         test_utils::{check_edit, completion_list_with_config, TEST_CONFIG},\n@@ -66,7 +64,7 @@ mod tests {\n \n     #[test]\n     fn self_fulfilling_completion() {\n-        mark::check!(self_fulfilling_completion);\n+        cov_mark::check!(self_fulfilling_completion);\n         check(\n             r#\"\n use foo$0\n@@ -185,7 +183,7 @@ fn quux() {\n \n     #[test]\n     fn completes_if_prefix_is_keyword() {\n-        mark::check!(completes_if_prefix_is_keyword);\n+        cov_mark::check!(completes_if_prefix_is_keyword);\n         check_edit(\n             \"wherewolf\",\n             r#\"\n@@ -223,7 +221,7 @@ fn main() {\n \n     #[test]\n     fn does_not_complete_lifetimes() {\n-        mark::check!(skip_lifetime_completion);\n+        cov_mark::check!(skip_lifetime_completion);\n         check(\n             r#\"fn quux<'a>() { $0 }\"#,\n             expect![[r#\""}, {"sha": "17d9a3adf8f235e9b8596aafd9b5d85a4d3c2b18", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -7,7 +7,7 @@ use syntax::{\n     algo::find_node_at_offset, ast, match_ast, AstNode, NodeOrToken, SyntaxKind::*, SyntaxNode,\n     SyntaxToken, TextRange, TextSize,\n };\n-use test_utils::mark;\n+\n use text_edit::Indel;\n \n use crate::{\n@@ -240,7 +240,7 @@ impl<'a> CompletionContext<'a> {\n         // check kind of macro-expanded token, but use range of original token\n         let kind = self.token.kind();\n         if kind == IDENT || kind == UNDERSCORE || kind.is_keyword() {\n-            mark::hit!(completes_if_prefix_is_keyword);\n+            cov_mark::hit!(completes_if_prefix_is_keyword);\n             self.original_token.text_range()\n         } else {\n             TextRange::empty(self.position.offset)"}, {"sha": "dcfac23c55fbc597b9d874aabcd11e087b13ba04", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -15,7 +15,6 @@ use hir::{\n };\n use ide_db::{helpers::SnippetCap, RootDatabase, SymbolKind};\n use syntax::TextRange;\n-use test_utils::mark;\n \n use crate::{\n     item::ImportEdit, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n@@ -115,11 +114,11 @@ impl<'a> RenderContext<'a> {\n \n     fn active_name_and_type(&self) -> Option<(String, Type)> {\n         if let Some(record_field) = &self.completion.record_field_syntax {\n-            mark::hit!(record_field_type_match);\n+            cov_mark::hit!(record_field_type_match);\n             let (struct_field, _local) = self.completion.sema.resolve_record_field(record_field)?;\n             Some((struct_field.name(self.db()).to_string(), struct_field.signature_ty(self.db())))\n         } else if let Some(active_parameter) = &self.completion.active_parameter {\n-            mark::hit!(active_param_type_match);\n+            cov_mark::hit!(active_param_type_match);\n             Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n         } else {\n             None\n@@ -269,7 +268,7 @@ impl<'a> Render<'a> {\n                     _ => false,\n                 };\n                 if has_non_default_type_params {\n-                    mark::hit!(inserts_angle_brackets_for_generics);\n+                    cov_mark::hit!(inserts_angle_brackets_for_generics);\n                     item = item\n                         .lookup_by(local_name.clone())\n                         .label(format!(\"{}<\u2026>\", local_name))\n@@ -358,7 +357,6 @@ mod tests {\n     use std::cmp::Reverse;\n \n     use expect_test::{expect, Expect};\n-    use test_utils::mark;\n \n     use crate::{\n         test_utils::{check_edit, do_completion, get_all_items, TEST_CONFIG},\n@@ -734,7 +732,7 @@ fn foo(s: S) { s.$0 }\n \n     #[test]\n     fn no_call_parens_if_fn_ptr_needed() {\n-        mark::check!(no_call_parens_if_fn_ptr_needed);\n+        cov_mark::check!(no_call_parens_if_fn_ptr_needed);\n         check_edit(\n             \"foo\",\n             r#\"\n@@ -758,7 +756,7 @@ fn main() -> ManualVtable {\n \n     #[test]\n     fn no_parens_in_use_item() {\n-        mark::check!(no_parens_in_use_item);\n+        cov_mark::check!(no_parens_in_use_item);\n         check_edit(\n             \"foo\",\n             r#\"\n@@ -802,7 +800,7 @@ fn f(foo: &Foo) { foo.foo(); }\n \n     #[test]\n     fn inserts_angle_brackets_for_generics() {\n-        mark::check!(inserts_angle_brackets_for_generics);\n+        cov_mark::check!(inserts_angle_brackets_for_generics);\n         check_edit(\n             \"Vec\",\n             r#\"\n@@ -851,7 +849,7 @@ fn foo(xs: Vec<i128>)\n \n     #[test]\n     fn active_param_score() {\n-        mark::check!(active_param_type_match);\n+        cov_mark::check!(active_param_type_match);\n         check_scores(\n             r#\"\n struct S { foo: i64, bar: u32, baz: u32 }\n@@ -868,7 +866,7 @@ fn foo(s: S) { test(s.$0) }\n \n     #[test]\n     fn record_field_scores() {\n-        mark::check!(record_field_type_match);\n+        cov_mark::check!(record_field_type_match);\n         check_scores(\n             r#\"\n struct A { foo: i64, bar: u32, baz: u32 }"}, {"sha": "95a7596c11d1c1ab1ee6c515a86099b47a0d379d", "filename": "crates/ide_completion/src/render/builder_ext.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,7 +1,6 @@\n //! Extensions for `Builder` structure required for item rendering.\n \n use itertools::Itertools;\n-use test_utils::mark;\n \n use crate::{item::Builder, CompletionContext};\n \n@@ -30,7 +29,7 @@ impl Builder {\n             return false;\n         }\n         if ctx.use_item_syntax.is_some() {\n-            mark::hit!(no_parens_in_use_item);\n+            cov_mark::hit!(no_parens_in_use_item);\n             return false;\n         }\n         if ctx.is_pattern_call {\n@@ -43,7 +42,7 @@ impl Builder {\n         // Don't add parentheses if the expected type is some function reference.\n         if let Some(ty) = &ctx.expected_type {\n             if ty.is_fn() {\n-                mark::hit!(no_call_parens_if_fn_ptr_needed);\n+                cov_mark::hit!(no_call_parens_if_fn_ptr_needed);\n                 return false;\n             }\n         }\n@@ -67,7 +66,7 @@ impl Builder {\n             None => return self,\n         };\n         // If not an import, add parenthesis automatically.\n-        mark::hit!(inserts_parens_for_function_calls);\n+        cov_mark::hit!(inserts_parens_for_function_calls);\n \n         let (snippet, label) = if params.is_empty() {\n             (format!(\"{}()$0\", name), format!(\"{}()\", name))\n@@ -82,7 +81,7 @@ impl Builder {\n                     format!(\"{}({})$0\", name, function_params_snippet)\n                 }\n                 _ => {\n-                    mark::hit!(suppress_arg_snippets);\n+                    cov_mark::hit!(suppress_arg_snippets);\n                     format!(\"{}($0)\", name)\n                 }\n             };"}, {"sha": "ed055c1fb7faa6689098d31d95ae2973297ac6bf", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@\n use hir::{HasAttrs, HirDisplay, ModPath, StructKind};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n-use test_utils::mark;\n \n use crate::{\n     item::{CompletionItem, CompletionKind, ImportEdit},\n@@ -68,7 +67,7 @@ impl<'a> EnumRender<'a> {\n         .detail(self.detail());\n \n         if self.variant_kind == StructKind::Tuple {\n-            mark::hit!(inserts_parens_for_tuple_enums);\n+            cov_mark::hit!(inserts_parens_for_tuple_enums);\n             let params = Params::Anonymous(self.variant.fields(self.ctx.db()).len());\n             builder =\n                 builder.add_call_parens(self.ctx.completion, self.short_qualified_name, params);\n@@ -103,13 +102,11 @@ impl<'a> EnumRender<'a> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::test_utils::check_edit;\n \n     #[test]\n     fn inserts_parens_for_tuple_enums() {\n-        mark::check!(inserts_parens_for_tuple_enums);\n+        cov_mark::check!(inserts_parens_for_tuple_enums);\n         check_edit(\n             \"Some\",\n             r#\""}, {"sha": "5931945a8e28e709ec74729c2e0e98e7c1af3c8e", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@\n use hir::{HasSource, HirDisplay, Type};\n use ide_db::SymbolKind;\n use syntax::ast::Fn;\n-use test_utils::mark;\n \n use crate::{\n     item::{CompletionItem, CompletionItemKind, CompletionKind, ImportEdit},\n@@ -82,7 +81,7 @@ impl<'a> FunctionRender<'a> {\n             self.func.method_params(self.ctx.db()).unwrap_or_default()\n         } else {\n             if let Some(s) = ast_params.self_param() {\n-                mark::hit!(parens_for_method_call_as_assoc_fn);\n+                cov_mark::hit!(parens_for_method_call_as_assoc_fn);\n                 params_pats.push(Some(s.to_string()));\n             }\n             self.func.assoc_fn_params(self.ctx.db())\n@@ -114,16 +113,14 @@ impl<'a> FunctionRender<'a> {\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::{\n         test_utils::{check_edit, check_edit_with_config, TEST_CONFIG},\n         CompletionConfig,\n     };\n \n     #[test]\n     fn inserts_parens_for_function_calls() {\n-        mark::check!(inserts_parens_for_function_calls);\n+        cov_mark::check!(inserts_parens_for_function_calls);\n         check_edit(\n             \"no_args\",\n             r#\"\n@@ -191,7 +188,7 @@ fn bar(s: &S) {\n \n     #[test]\n     fn parens_for_method_call_as_assoc_fn() {\n-        mark::check!(parens_for_method_call_as_assoc_fn);\n+        cov_mark::check!(parens_for_method_call_as_assoc_fn);\n         check_edit(\n             \"foo\",\n             r#\"\n@@ -213,7 +210,7 @@ fn main() { S::foo(${1:&self})$0 }\n \n     #[test]\n     fn suppress_arg_snippets() {\n-        mark::check!(suppress_arg_snippets);\n+        cov_mark::check!(suppress_arg_snippets);\n         check_edit_with_config(\n             CompletionConfig { add_call_argument_snippets: false, ..TEST_CONFIG },\n             \"with_args\","}, {"sha": "a6cf3e479118012375908d73fc4180f9a7db33a7", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,6 @@\n use hir::{Documentation, HasSource};\n use ide_db::SymbolKind;\n use syntax::display::macro_label;\n-use test_utils::mark;\n \n use crate::{\n     item::{CompletionItem, CompletionKind, ImportEdit},\n@@ -57,7 +56,7 @@ impl<'a> MacroRender<'a> {\n             }\n             None if needs_bang => builder.insert_text(self.banged_name()),\n             _ => {\n-                mark::hit!(dont_insert_macro_call_parens_unncessary);\n+                cov_mark::hit!(dont_insert_macro_call_parens_unncessary);\n                 builder.insert_text(&self.name)\n             }\n         };\n@@ -125,13 +124,11 @@ fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static s\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::mark;\n-\n     use crate::test_utils::check_edit;\n \n     #[test]\n     fn dont_insert_macro_call_parens_unncessary() {\n-        mark::check!(dont_insert_macro_call_parens_unncessary);\n+        cov_mark::check!(dont_insert_macro_call_parens_unncessary);\n         check_edit(\n             \"frobnicate!\",\n             r#\""}, {"sha": "1f855c6214d64b2b1b4a2ff5f9d938e768ced68e", "filename": "crates/ide_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n log = \"0.4.8\"\n rayon = \"1.5.0\"\n fst = { version = \"0.4\", default-features = false }"}, {"sha": "d8878aa912bfd5f140b514891ae2baccc0b0e206", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -7,7 +7,6 @@ use syntax::{\n     ast::{self, ArgListOwner},\n     match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n-use test_utils::mark;\n \n use crate::RootDatabase;\n \n@@ -122,7 +121,7 @@ fn call_info_impl(\n \n         let arg_list_range = arg_list.syntax().text_range();\n         if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-            mark::hit!(call_info_bad_offset);\n+            cov_mark::hit!(call_info_bad_offset);\n             return None;\n         }\n         let param = std::cmp::min(\n@@ -162,7 +161,7 @@ impl ActiveParameter {\n         let idx = active_parameter?;\n         let mut params = signature.params(sema.db);\n         if !(idx < params.len()) {\n-            mark::hit!(too_many_arguments);\n+            cov_mark::hit!(too_many_arguments);\n             return None;\n         }\n         let (pat, ty) = params.swap_remove(idx);"}, {"sha": "9f84c253c1d25a71bfaf6f620f6f3d2ae6f886df", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -1,7 +1,7 @@\n use crate::RootDatabase;\n use base_db::{fixture::ChangeFixture, FilePosition};\n use expect_test::{expect, Expect};\n-use test_utils::{mark, RangeOrOffset};\n+use test_utils::RangeOrOffset;\n \n /// Creates analysis from a multi-file fixture, returns positions marked with $0.\n pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n@@ -347,7 +347,7 @@ pub fn foo(mut r: WriteHandler<()>) {\n \n #[test]\n fn call_info_bad_offset() {\n-    mark::check!(call_info_bad_offset);\n+    cov_mark::check!(call_info_bad_offset);\n     check(\n         r#\"\n fn foo(x: u32, y: u32) -> u32 {x + y}"}, {"sha": "df66d8ea04d04b71b1d9695caf50da8b1712f4d3", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -13,7 +13,6 @@ use syntax::{\n     },\n     AstToken, InsertPosition, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n };\n-use test_utils::mark;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub struct InsertUseConfig {\n@@ -138,7 +137,7 @@ pub fn insert_use<'a>(\n \n         if add_blank.has_before() {\n             if let Some(indent) = indent.clone() {\n-                mark::hit!(insert_use_indent_before);\n+                cov_mark::hit!(insert_use_indent_before);\n                 buf.push(indent);\n             }\n         }\n@@ -156,11 +155,11 @@ pub fn insert_use<'a>(\n         // only add indentation *after* our stuff if there's another node directly after it\n         if add_blank.has_after() && matches!(insert_position, InsertPosition::Before(_)) {\n             if let Some(indent) = indent {\n-                mark::hit!(insert_use_indent_after);\n+                cov_mark::hit!(insert_use_indent_after);\n                 buf.push(indent);\n             }\n         } else if add_blank.has_after() && matches!(insert_position, InsertPosition::After(_)) {\n-            mark::hit!(insert_use_no_indent_after);\n+            cov_mark::hit!(insert_use_no_indent_after);\n         }\n \n         buf"}, {"sha": "3d151e629d29f9ded330fe85d46f24175ecf26c2", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -51,7 +51,7 @@ use std::bar::G;\",\n \n #[test]\n fn insert_start_indent() {\n-    mark::check!(insert_use_indent_after);\n+    cov_mark::check!(insert_use_indent_after);\n     check_none(\n         \"std::bar::AA\",\n         r\"\n@@ -120,7 +120,7 @@ use std::bar::ZZ;\",\n \n #[test]\n fn insert_end_indent() {\n-    mark::check!(insert_use_indent_before);\n+    cov_mark::check!(insert_use_indent_before);\n     check_none(\n         \"std::bar::ZZ\",\n         r\"\n@@ -255,7 +255,7 @@ fn insert_empty_file() {\n \n #[test]\n fn insert_empty_module() {\n-    mark::check!(insert_use_no_indent_after);\n+    cov_mark::check!(insert_use_no_indent_after);\n     check(\n         \"foo::bar\",\n         \"mod x {}\","}, {"sha": "315691f40c6287985a41abc870979b42c751189e", "filename": "crates/ide_ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -11,6 +11,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n rustc-hash = \"1.1.0\"\n itertools = \"0.10.0\"\n "}, {"sha": "e1adb381efbd88e667fab5ae62c47a6387a92b69", "filename": "crates/ide_ssr/src/matching.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fmatching.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -15,7 +15,6 @@ use syntax::{\n     ast::{AstNode, AstToken},\n     SmolStr,\n };\n-use test_utils::mark;\n \n // Creates a match error. If we're currently attempting to match some code that we thought we were\n // going to match, as indicated by the --debug-snippet flag, then populate the reason field.\n@@ -731,7 +730,7 @@ impl NodeKind {\n     fn matches(&self, node: &SyntaxNode) -> Result<(), MatchFailed> {\n         let ok = match self {\n             Self::Literal => {\n-                mark::hit!(literal_constraint);\n+                cov_mark::hit!(literal_constraint);\n                 ast::Literal::can_cast(node.kind())\n             }\n         };"}, {"sha": "5ff25cb6d75c7ce22f6844cae6dca1b27dbfa579", "filename": "crates/ide_ssr/src/parsing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fparsing.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,7 +10,6 @@ use crate::{SsrError, SsrPattern, SsrRule};\n use rustc_hash::{FxHashMap, FxHashSet};\n use std::{fmt::Display, str::FromStr};\n use syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, T};\n-use test_utils::mark;\n \n #[derive(Debug)]\n pub(crate) struct ParsedRule {\n@@ -131,7 +130,7 @@ impl RuleBuilder {\n             let old_len = self.rules.len();\n             self.rules.retain(|rule| contains_path(&rule.pattern));\n             if self.rules.len() < old_len {\n-                mark::hit!(pattern_is_a_single_segment_path);\n+                cov_mark::hit!(pattern_is_a_single_segment_path);\n             }\n         }\n         Ok(self.rules)"}, {"sha": "c9ccc1961007892f51926f6122e3efdc3f07bdba", "filename": "crates/ide_ssr/src/replacing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Freplacing.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast::{self, AstNode, AstToken};\n use syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize};\n-use test_utils::mark;\n+\n use text_edit::TextEdit;\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n@@ -128,7 +128,7 @@ impl ReplacementRenderer<'_> {\n                     && (placeholder_value.autoderef_count > 0\n                         || placeholder_value.autoref_kind != ast::SelfParamKind::Owned)\n                 {\n-                    mark::hit!(replace_autoref_autoderef_capture);\n+                    cov_mark::hit!(replace_autoref_autoderef_capture);\n                     let ref_kind = match placeholder_value.autoref_kind {\n                         ast::SelfParamKind::Owned => \"\",\n                         ast::SelfParamKind::Ref => \"&\","}, {"sha": "af94c7bb1bee81785ada06c8ed016e09649a00ca", "filename": "crates/ide_ssr/src/resolving.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fresolving.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -6,7 +6,6 @@ use ide_db::base_db::FilePosition;\n use parsing::Placeholder;\n use rustc_hash::FxHashMap;\n use syntax::{ast, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken};\n-use test_utils::mark;\n \n pub(crate) struct ResolutionScope<'db> {\n     scope: hir::SemanticsScope<'db>,\n@@ -170,13 +169,13 @@ impl Resolver<'_, '_> {\n                     // calls. e.g. `Foo::bar($s)` should match `x.bar()`.\n                     true\n                 } else {\n-                    mark::hit!(replace_associated_trait_default_function_call);\n+                    cov_mark::hit!(replace_associated_trait_default_function_call);\n                     false\n                 }\n             }\n             hir::PathResolution::AssocItem(_) => {\n                 // Not a function. Could be a constant or an associated type.\n-                mark::hit!(replace_associated_trait_constant);\n+                cov_mark::hit!(replace_associated_trait_constant);\n                 false\n             }\n             _ => true,\n@@ -267,7 +266,7 @@ fn pick_node_for_resolution(node: SyntaxNode) -> SyntaxNode {\n     match node.kind() {\n         SyntaxKind::EXPR_STMT => {\n             if let Some(n) = node.first_child() {\n-                mark::hit!(cursor_after_semicolon);\n+                cov_mark::hit!(cursor_after_semicolon);\n                 return n;\n             }\n         }\n@@ -291,7 +290,7 @@ fn path_contains_type_arguments(path: Option<ast::Path>) -> bool {\n     if let Some(path) = path {\n         if let Some(segment) = path.segment() {\n             if segment.generic_arg_list().is_some() {\n-                mark::hit!(type_arguments_within_path);\n+                cov_mark::hit!(type_arguments_within_path);\n                 return true;\n             }\n         }"}, {"sha": "28cef742c4f8cd5b8b8bb1f52c3306605a8a6494", "filename": "crates/ide_ssr/src/search.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fsearch.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -12,7 +12,6 @@ use ide_db::{\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode, SyntaxKind, SyntaxNode};\n-use test_utils::mark;\n \n /// A cache for the results of find_usages. This is for when we have multiple patterns that have the\n /// same path. e.g. if the pattern was `foo::Bar` that can parse as a path, an expression, a type\n@@ -61,7 +60,7 @@ impl<'db> MatchFinder<'db> {\n             for file_range in self.find_usages(usage_cache, definition).file_ranges() {\n                 if let Some(node_to_match) = self.find_node_to_match(resolved_path, file_range) {\n                     if !is_search_permitted_ancestors(&node_to_match) {\n-                        mark::hit!(use_declaration_with_braces);\n+                        cov_mark::hit!(use_declaration_with_braces);\n                         continue;\n                     }\n                     self.try_add_match(rule, &node_to_match, &None, matches_out);\n@@ -205,7 +204,7 @@ impl<'db> MatchFinder<'db> {\n         matches_out: &mut Vec<Match>,\n     ) {\n         if !self.within_range_restrictions(code) {\n-            mark::hit!(replace_nonpath_within_selection);\n+            cov_mark::hit!(replace_nonpath_within_selection);\n             return;\n         }\n         if let Ok(m) = matching::get_match(false, rule, code, restrict_range, &self.sema) {"}, {"sha": "1d8565dc0ede1914dae579a6aadeaed03c0ccdb9", "filename": "crates/ide_ssr/src/tests.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fide_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Ftests.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -3,7 +3,7 @@ use expect_test::{expect, Expect};\n use ide_db::base_db::{salsa::Durability, FileId, FilePosition, FileRange, SourceDatabaseExt};\n use rustc_hash::FxHashSet;\n use std::sync::Arc;\n-use test_utils::{mark, RangeOrOffset};\n+use test_utils::RangeOrOffset;\n \n fn parse_error_text(query: &str) -> String {\n     format!(\"{}\", query.parse::<SsrRule>().unwrap_err())\n@@ -492,7 +492,7 @@ fn match_resolved_type_name() {\n \n #[test]\n fn type_arguments_within_path() {\n-    mark::check!(type_arguments_within_path);\n+    cov_mark::check!(type_arguments_within_path);\n     let code = r#\"\n         mod foo {\n             pub struct Bar<T> {t: T}\n@@ -508,7 +508,7 @@ fn type_arguments_within_path() {\n \n #[test]\n fn literal_constraint() {\n-    mark::check!(literal_constraint);\n+    cov_mark::check!(literal_constraint);\n     let code = r#\"\n         enum Option<T> { Some(T), None }\n         use Option::Some;\n@@ -641,7 +641,7 @@ fn replace_associated_function_call() {\n \n #[test]\n fn replace_associated_trait_default_function_call() {\n-    mark::check!(replace_associated_trait_default_function_call);\n+    cov_mark::check!(replace_associated_trait_default_function_call);\n     assert_ssr_transform(\n         \"Bar2::foo() ==>> Bar2::foo2()\",\n         r#\"\n@@ -673,7 +673,7 @@ fn replace_associated_trait_default_function_call() {\n \n #[test]\n fn replace_associated_trait_constant() {\n-    mark::check!(replace_associated_trait_constant);\n+    cov_mark::check!(replace_associated_trait_constant);\n     assert_ssr_transform(\n         \"Bar2::VALUE ==>> Bar2::VALUE_2222\",\n         r#\"\n@@ -998,7 +998,7 @@ fn use_declaration_with_braces() {\n     // It would be OK for a path rule to match and alter a use declaration. We shouldn't mess it up\n     // though. In particular, we must not change `use foo::{baz, bar}` to `use foo::{baz,\n     // foo2::bar2}`.\n-    mark::check!(use_declaration_with_braces);\n+    cov_mark::check!(use_declaration_with_braces);\n     assert_ssr_transform(\n         \"foo::bar ==>> foo2::bar2\",\n         r#\"\n@@ -1076,7 +1076,7 @@ fn ufcs_matches_method_call() {\n \n #[test]\n fn pattern_is_a_single_segment_path() {\n-    mark::check!(pattern_is_a_single_segment_path);\n+    cov_mark::check!(pattern_is_a_single_segment_path);\n     // The first function should not be altered because the `foo` in scope at the cursor position is\n     // a different `foo`. This case is special because \"foo\" can be parsed as a pattern (IDENT_PAT ->\n     // NAME -> IDENT), which contains no path. If we're not careful we'll end up matching the `foo`\n@@ -1118,7 +1118,7 @@ fn replace_local_variable_reference() {\n     // The pattern references a local variable `foo` in the block containing the cursor. We should\n     // only replace references to this variable `foo`, not other variables that just happen to have\n     // the same name.\n-    mark::check!(cursor_after_semicolon);\n+    cov_mark::check!(cursor_after_semicolon);\n     assert_ssr_transform(\n         \"foo + $a ==>> $a - foo\",\n         r#\"\n@@ -1179,7 +1179,7 @@ fn replace_path_within_selection() {\n \n #[test]\n fn replace_nonpath_within_selection() {\n-    mark::check!(replace_nonpath_within_selection);\n+    cov_mark::check!(replace_nonpath_within_selection);\n     assert_ssr_transform(\n         \"$a + $b ==>> $b * $a\",\n         r#\"\n@@ -1269,7 +1269,7 @@ fn replace_autoref_autoderef_capture() {\n     // second, we already have a reference, so it isn't. When $a is used in a context where autoref\n     // doesn't apply, we need to prefix it with `&`. Finally, we have some cases where autoderef\n     // needs to be applied.\n-    mark::check!(replace_autoref_autoderef_capture);\n+    cov_mark::check!(replace_autoref_autoderef_capture);\n     let code = r#\"\n         struct Foo {}\n         impl Foo {"}, {"sha": "c7d5e39fa3148d7a6dfd56fe5226e6c43d60de6c", "filename": "crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,6 +10,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n rustc-hash = \"1.1.0\"\n smallvec = \"1.2.0\"\n log = \"0.4.8\""}, {"sha": "33b85e23dbd0b37948e2c8beecd417fde050be71", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -17,7 +17,6 @@ mod benchmark;\n \n use std::fmt;\n \n-use test_utils::mark;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n use crate::{\n@@ -217,7 +216,7 @@ impl MacroDef {\n         let mut rules = Vec::new();\n \n         if Some(tt::DelimiterKind::Brace) == tt.delimiter_kind() {\n-            mark::hit!(parse_macro_def_rules);\n+            cov_mark::hit!(parse_macro_def_rules);\n             while src.len() > 0 {\n                 let rule = Rule::parse(&mut src, true)?;\n                 rules.push(rule);\n@@ -229,7 +228,7 @@ impl MacroDef {\n                 }\n             }\n         } else {\n-            mark::hit!(parse_macro_def_simple);\n+            cov_mark::hit!(parse_macro_def_simple);\n             let rule = Rule::parse(&mut src, false)?;\n             if src.len() != 0 {\n                 return Err(ParseError::Expected(\"remain tokens in macro def\".to_string()));"}, {"sha": "3a168bb4b4fb8af2bcd39711be0b72ef9dea388a", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -6,7 +6,7 @@ use syntax::{\n     SyntaxKind::{ERROR, IDENT},\n     SyntaxNode, WalkEvent, T,\n };\n-use test_utils::{assert_eq_text, mark};\n+use test_utils::assert_eq_text;\n \n use super::*;\n \n@@ -687,7 +687,7 @@ fn test_match_literal() {\n \n #[test]\n fn test_parse_macro_def_simple() {\n-    mark::check!(parse_macro_def_simple);\n+    cov_mark::check!(parse_macro_def_simple);\n \n     parse_macro2(\n         r#\"\n@@ -701,7 +701,7 @@ macro foo($id:ident) {\n \n #[test]\n fn test_parse_macro_def_rules() {\n-    mark::check!(parse_macro_def_rules);\n+    cov_mark::check!(parse_macro_def_rules);\n \n     parse_macro2(\n         r#\""}, {"sha": "e679026823aacd0d9185c5362ed60baeb84aa909", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -268,7 +268,7 @@ trait Mark {\n     fn mark(unmarked: Self::Unmarked) -> Self;\n }\n \n-/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n+/// Unwrap types wrapped by `cov_mark::mark` (see `Mark` for details).\n trait Unmark {\n     type Unmarked;\n     fn unmark(self) -> Self::Unmarked;"}, {"sha": "c39095def07c142454a0636d970c736780e4198d", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -11,6 +11,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n+cov-mark = \"1.1\"\n itertools = \"0.10.0\"\n rowan = \"0.12.2\"\n rustc_lexer = { version = \"709.0.0\", package = \"rustc-ap-rustc_lexer\" }"}, {"sha": "b13252eec4cec9de8053331f5c6dd232fd2931e0", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -10,7 +10,6 @@ use std::{\n use indexmap::IndexMap;\n use itertools::Itertools;\n use rustc_hash::FxHashMap;\n-use test_utils::mark;\n use text_edit::TextEditBuilder;\n \n use crate::{\n@@ -184,7 +183,7 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n         let (lhs, rhs) = match lhs.as_node().zip(rhs.as_node()) {\n             Some((lhs, rhs)) => (lhs, rhs),\n             _ => {\n-                mark::hit!(diff_node_token_replace);\n+                cov_mark::hit!(diff_node_token_replace);\n                 diff.replacements.insert(lhs, rhs);\n                 return;\n             }\n@@ -202,19 +201,19 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n                 (None, Some(element)) => {\n                     let insert_pos = match last_lhs.clone() {\n                         Some(prev) => {\n-                            mark::hit!(diff_insert);\n+                            cov_mark::hit!(diff_insert);\n                             TreeDiffInsertPos::After(prev)\n                         }\n                         // first iteration, insert into out parent as the first child\n                         None => {\n-                            mark::hit!(diff_insert_as_first_child);\n+                            cov_mark::hit!(diff_insert_as_first_child);\n                             TreeDiffInsertPos::AsFirstChild(lhs.clone().into())\n                         }\n                     };\n                     diff.insertions.entry(insert_pos).or_insert_with(Vec::new).push(element);\n                 }\n                 (Some(element), None) => {\n-                    mark::hit!(diff_delete);\n+                    cov_mark::hit!(diff_delete);\n                     diff.deletions.push(element);\n                 }\n                 (Some(ref lhs_ele), Some(ref rhs_ele)) if syntax_element_eq(lhs_ele, rhs_ele) => {}\n@@ -228,7 +227,7 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n                     let mut insert = false;\n                     while let Some(rhs_child) = rhs_children_clone.next() {\n                         if syntax_element_eq(&lhs_ele, &rhs_child) {\n-                            mark::hit!(diff_insertions);\n+                            cov_mark::hit!(diff_insertions);\n                             insert = true;\n                             break;\n                         } else {\n@@ -240,7 +239,7 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n                         let insert_pos = if let Some(prev) = last_lhs.clone().filter(|_| insert) {\n                             TreeDiffInsertPos::After(prev)\n                         } else {\n-                            mark::hit!(insert_first_child);\n+                            cov_mark::hit!(insert_first_child);\n                             TreeDiffInsertPos::AsFirstChild(lhs.clone().into())\n                         };\n \n@@ -635,14 +634,13 @@ mod tests {\n     use expect_test::{expect, Expect};\n     use itertools::Itertools;\n     use parser::SyntaxKind;\n-    use test_utils::mark;\n     use text_edit::TextEdit;\n \n     use crate::{AstNode, SyntaxElement};\n \n     #[test]\n     fn replace_node_token() {\n-        mark::check!(diff_node_token_replace);\n+        cov_mark::check!(diff_node_token_replace);\n         check_diff(\n             r#\"use node;\"#,\n             r#\"ident\"#,\n@@ -666,7 +664,7 @@ mod tests {\n \n     #[test]\n     fn replace_parent() {\n-        mark::check!(diff_insert_as_first_child);\n+        cov_mark::check!(diff_insert_as_first_child);\n         check_diff(\n             r#\"\"#,\n             r#\"use foo::bar;\"#,\n@@ -689,7 +687,7 @@ mod tests {\n \n     #[test]\n     fn insert_last() {\n-        mark::check!(diff_insert);\n+        cov_mark::check!(diff_insert);\n         check_diff(\n             r#\"\n use foo;\n@@ -774,7 +772,7 @@ use baz;\"#,\n \n     #[test]\n     fn first_child_insertion() {\n-        mark::check!(insert_first_child);\n+        cov_mark::check!(insert_first_child);\n         check_diff(\n             r#\"fn main() {\n         stdi\n@@ -804,7 +802,7 @@ use baz;\"#,\n \n     #[test]\n     fn delete_last() {\n-        mark::check!(diff_delete);\n+        cov_mark::check!(diff_delete);\n         check_diff(\n             r#\"use foo;\n             use bar;\"#,\n@@ -828,7 +826,7 @@ use baz;\"#,\n \n     #[test]\n     fn delete_middle() {\n-        mark::check!(diff_insertions);\n+        cov_mark::check!(diff_insertions);\n         check_diff(\n             r#\"\n use expect_test::{expect, Expect};"}, {"sha": "c5f859790667bb4defaaafb119ee5507d9c6df3c", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -6,8 +6,6 @@\n //! * Extracting markup (mainly, `$0` markers) out of fixture strings.\n //! * marks (see the eponymous module).\n \n-#[macro_use]\n-pub mod mark;\n pub mod bench_fixture;\n mod fixture;\n "}, {"sha": "97f5a93ad9345a71ac01e81944b0a221574bab44", "filename": "crates/test_utils/src/mark.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Ftest_utils%2Fsrc%2Fmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Ftest_utils%2Fsrc%2Fmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmark.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -1,78 +0,0 @@\n-//! This module implements manually tracked test coverage, which is useful for\n-//! quickly finding a test responsible for testing a particular bit of code.\n-//!\n-//! See <https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html>\n-//! for details, but the TL;DR is that you write your test as\n-//!\n-//! ```\n-//! #[test]\n-//! fn test_foo() {\n-//!     mark::check!(test_foo);\n-//! }\n-//! ```\n-//!\n-//! and in the code under test you write\n-//!\n-//! ```\n-//! # use test_utils::mark;\n-//! # fn some_condition() -> bool { true }\n-//! fn foo() {\n-//!     if some_condition() {\n-//!         mark::hit!(test_foo);\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! This module then checks that executing the test indeed covers the specified\n-//! function. This is useful if you come back to the `foo` function ten years\n-//! later and wonder where the test are: now you can grep for `test_foo`.\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-#[macro_export]\n-macro_rules! _hit {\n-    ($ident:ident) => {{\n-        #[cfg(test)]\n-        {\n-            extern \"C\" {\n-                #[no_mangle]\n-                static $ident: std::sync::atomic::AtomicUsize;\n-            }\n-            unsafe {\n-                $ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n-            }\n-        }\n-    }};\n-}\n-pub use _hit as hit;\n-\n-#[macro_export]\n-macro_rules! _check {\n-    ($ident:ident) => {\n-        #[no_mangle]\n-        static $ident: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);\n-        let _checker = $crate::mark::MarkChecker::new(&$ident);\n-    };\n-}\n-pub use _check as check;\n-\n-pub struct MarkChecker {\n-    mark: &'static AtomicUsize,\n-    value_on_entry: usize,\n-}\n-\n-impl MarkChecker {\n-    pub fn new(mark: &'static AtomicUsize) -> MarkChecker {\n-        let value_on_entry = mark.load(Ordering::Relaxed);\n-        MarkChecker { mark, value_on_entry }\n-    }\n-}\n-\n-impl Drop for MarkChecker {\n-    fn drop(&mut self) {\n-        if std::thread::panicking() {\n-            return;\n-        }\n-        let value_on_exit = self.mark.load(Ordering::Relaxed);\n-        assert!(value_on_exit > self.value_on_entry, \"mark was not hit\")\n-    }\n-}"}, {"sha": "46bd8b9b2131c18cc97411ce56a5bbfa63482f92", "filename": "docs/dev/style.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "patch": "@@ -145,7 +145,7 @@ Formatting ensures that you can use your editor's \"number of selected characters\n ## Marked Tests\n \n Use\n-[`mark::hit! / mark::check!`](https://github.com/rust-analyzer/rust-analyzer/blob/71fe719dd5247ed8615641d9303d7ca1aa201c2f/crates/test_utils/src/mark.rs)\n+[`cov_mark::hit! / cov_mark::check!`](https://github.com/matklad/cov-mark)\n when testing specific conditions.\n Do not place several marks into a single test or condition.\n Do not reuse marks between several tests."}]}