{"sha": "976c6b2d193148ca9df3a505e55c5ba5da22cd96", "node_id": "C_kwDOAAsO6NoAKDk3NmM2YjJkMTkzMTQ4Y2E5ZGYzYTUwNWU1NWM1YmE1ZGEyMmNkOTY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-20T23:14:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-20T23:14:13Z"}, "message": "Rollup merge of #90630 - GuillaumeGomez:improve-rustdoc-search, r=notriddle\n\nCreate real parser for search queries\n\nYou can test it [here](https://rustdoc.crud.net/imperio/improve-rustdoc-search/std/index.html).\n\nThis PR adds a real parser for the query engine in rustdoc. The parser is quite simple but it allows to makes query handling much easier. I added a new testsuite to ensure it works as expected and ran fuzzing checks on it for a few hours without problems.\n\nSo about the parser: as you can see in the screenshot, it handles recursive generics parsing. It also allows to set which item should use exact matching by adding double-quotes around it (look for `exact_search` in the screenshot).\n\nNow about the query engine itself: I simplified it a lot thanks to the parsed query. It behaves mostly the same when there is only one argument, but is much more powerful when there are more than one.\n\nWhen making this change, we also removed the support for multi-query.\n\nPS: A big part of the PR is tests and test-related code. :)\n\nr? `@camelid`", "tree": {"sha": "e190b90c0d06101df0a683fdc5b5fc339c47349a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e190b90c0d06101df0a683fdc5b5fc339c47349a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/976c6b2d193148ca9df3a505e55c5ba5da22cd96", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiYJPFCRBK7hj4Ov3rIwAA6gMIABvWfc5bLYMCc5bqTFJ6W7qm\nbKK3naI8mVR/MTdKE3Yd9V3Hl6nx8INDtMxpN1kHlJOYaSlaRyRdevP5IBsQ5ek6\nH3X9/84iBGexcoSLD0exvk/QxztCz5DnD5M2uXLKxMGA1juJaJaQEv8dF34fT/Cb\nKd9X00HCSZPt2tb5towo16jaHF0J5vaBf4Bl/V+Fqy/e5lUUC8oyUQnEqFveL8xv\nRoCxfE0XPu+jJbXCZzSWm5N58XEqkoZkAWhGthYJZQaZm1SSIch+od6bCHtxr/Z+\nKdrpZWRwv5PdasjBy1G5F0nfcjy35vzLUGp+LuEHP7Gro1y3rna3UVXrE6w3Xjw=\n=HgBd\n-----END PGP SIGNATURE-----\n", "payload": "tree e190b90c0d06101df0a683fdc5b5fc339c47349a\nparent 51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e\nparent 4d26bde4f0b24ca6121eec167bc8d48f4b7179cc\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650496453 +0200\ncommitter GitHub <noreply@github.com> 1650496453 +0200\n\nRollup merge of #90630 - GuillaumeGomez:improve-rustdoc-search, r=notriddle\n\nCreate real parser for search queries\n\nYou can test it [here](https://rustdoc.crud.net/imperio/improve-rustdoc-search/std/index.html).\n\nThis PR adds a real parser for the query engine in rustdoc. The parser is quite simple but it allows to makes query handling much easier. I added a new testsuite to ensure it works as expected and ran fuzzing checks on it for a few hours without problems.\n\nSo about the parser: as you can see in the screenshot, it handles recursive generics parsing. It also allows to set which item should use exact matching by adding double-quotes around it (look for `exact_search` in the screenshot).\n\nNow about the query engine itself: I simplified it a lot thanks to the parsed query. It behaves mostly the same when there is only one argument, but is much more powerful when there are more than one.\n\nWhen making this change, we also removed the support for multi-query.\n\nPS: A big part of the PR is tests and test-related code. :)\n\nr? `@camelid`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/976c6b2d193148ca9df3a505e55c5ba5da22cd96", "html_url": "https://github.com/rust-lang/rust/commit/976c6b2d193148ca9df3a505e55c5ba5da22cd96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/976c6b2d193148ca9df3a505e55c5ba5da22cd96/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "html_url": "https://github.com/rust-lang/rust/commit/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e"}, {"sha": "4d26bde4f0b24ca6121eec167bc8d48f4b7179cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d26bde4f0b24ca6121eec167bc8d48f4b7179cc", "html_url": "https://github.com/rust-lang/rust/commit/4d26bde4f0b24ca6121eec167bc8d48f4b7179cc"}], "stats": {"total": 2756, "additions": 2299, "deletions": 457}, "files": [{"sha": "0fe0fdadbd21050b3c27aa51331e81797a5a74b5", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -8,10 +8,34 @@ function initSearch(searchIndex){}\n \n /**\n  * @typedef {{\n- *   raw: string,\n- *   query: string,\n- *   type: string,\n- *   id: string,\n+ *     name: string,\n+ *     fullPath: Array<string>,\n+ *     pathWithoutLast: Array<string>,\n+ *     pathLast: string,\n+ *     generics: Array<QueryElement>,\n+ * }}\n+ */\n+var QueryElement;\n+\n+/**\n+ * @typedef {{\n+ *      pos: number,\n+ *      totalElems: number,\n+ *      typeFilter: (null|string),\n+ *      userQuery: string,\n+ * }}\n+ */\n+var ParserState;\n+\n+/**\n+ * @typedef {{\n+ *     original: string,\n+ *     userQuery: string,\n+ *     typeFilter: number,\n+ *     elems: Array<QueryElement>,\n+ *     args: Array<QueryElement>,\n+ *     returned: Array<QueryElement>,\n+ *     foundElems: number,\n  * }}\n  */\n var ParsedQuery;\n@@ -30,3 +54,30 @@ var ParsedQuery;\n  * }}\n  */\n var Row;\n+\n+/**\n+ * @typedef {{\n+ *    in_args: Array<Object>,\n+ *    returned: Array<Object>,\n+ *    others: Array<Object>,\n+ *    query: ParsedQuery,\n+ * }}\n+ */\n+var ResultsTable;\n+\n+/**\n+ * @typedef {{\n+ *     desc: string,\n+ *     displayPath: string,\n+ *     fullPath: string,\n+ *     href: string,\n+ *     id: number,\n+ *     lev: number,\n+ *     name: string,\n+ *     normalizedName: string,\n+ *     parent: (Object|undefined),\n+ *     path: string,\n+ *     ty: number,\n+ * }}\n+ */\n+var Results;"}, {"sha": "0d4e0a0b3289dac7f763875b074733448725459c", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 955, "deletions": 421, "changes": 1376, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -61,15 +61,6 @@ function printTab(nb) {\n     });\n }\n \n-function removeEmptyStringsFromArray(x) {\n-    for (var i = 0, len = x.length; i < len; ++i) {\n-        if (x[i] === \"\") {\n-            x.splice(i, 1);\n-            i -= 1;\n-        }\n-    }\n-}\n-\n /**\n  * A function to compute the Levenshtein distance between two strings\n  * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n@@ -133,11 +124,436 @@ window.initSearch = function(rawSearchIndex) {\n         searchState.input.value = params.search || \"\";\n     }\n \n+    function isWhitespace(c) {\n+        return \" \\t\\n\\r\".indexOf(c) !== -1;\n+    }\n+\n+    function isSpecialStartCharacter(c) {\n+        return \"<\\\"\".indexOf(c) !== -1;\n+    }\n+\n+    function isEndCharacter(c) {\n+        return \",>-\".indexOf(c) !== -1;\n+    }\n+\n+    function isStopCharacter(c) {\n+        return isWhitespace(c) || isEndCharacter(c);\n+    }\n+\n+    function isErrorCharacter(c) {\n+        return \"()\".indexOf(c) !== -1;\n+    }\n+\n+    function itemTypeFromName(typename) {\n+        for (var i = 0, len = itemTypes.length; i < len; ++i) {\n+            if (itemTypes[i] === typename) {\n+                return i;\n+            }\n+        }\n+\n+        throw new Error(\"Unknown type filter `\" + typename + \"`\");\n+    }\n+\n+    /**\n+     * If we encounter a `\"`, then we try to extract the string from it until we find another `\"`.\n+     *\n+     * This function will throw an error in the following cases:\n+     * * There is already another string element.\n+     * * We are parsing a generic argument.\n+     * * There is more than one element.\n+     * * There is no closing `\"`.\n+     *\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {boolean} isInGenerics\n+     */\n+    function getStringElem(query, parserState, isInGenerics) {\n+        if (isInGenerics) {\n+            throw new Error(\"`\\\"` cannot be used in generics\");\n+        } else if (query.literalSearch) {\n+            throw new Error(\"Cannot have more than one literal search element\");\n+        } else if (parserState.totalElems - parserState.genericsElems > 0) {\n+            throw new Error(\"Cannot use literal search when there is more than one element\");\n+        }\n+        parserState.pos += 1;\n+        var start = parserState.pos;\n+        var end = getIdentEndPosition(parserState);\n+        if (parserState.pos >= parserState.length) {\n+            throw new Error(\"Unclosed `\\\"`\");\n+        } else if (parserState.userQuery[end] !== \"\\\"\") {\n+            throw new Error(`Unexpected \\`${parserState.userQuery[end]}\\` in a string element`);\n+        } else if (start === end) {\n+            throw new Error(\"Cannot have empty string element\");\n+        }\n+        // To skip the quote at the end.\n+        parserState.pos += 1;\n+        query.literalSearch = true;\n+    }\n+\n+    /**\n+     * Returns `true` if the current parser position is starting with \"::\".\n+     *\n+     * @param {ParserState} parserState\n+     *\n+     * @return {boolean}\n+     */\n+    function isPathStart(parserState) {\n+        return parserState.userQuery.slice(parserState.pos, parserState.pos + 2) == '::';\n+    }\n+\n+    /**\n+     * Returns `true` if the current parser position is starting with \"->\".\n+     *\n+     * @param {ParserState} parserState\n+     *\n+     * @return {boolean}\n+     */\n+    function isReturnArrow(parserState) {\n+        return parserState.userQuery.slice(parserState.pos, parserState.pos + 2) == '->';\n+    }\n+\n+    /**\n+     * Returns `true` if the given `c` character is valid for an ident.\n+     *\n+     * @param {string} c\n+     *\n+     * @return {boolean}\n+     */\n+    function isIdentCharacter(c) {\n+        return (\n+            c === '_' ||\n+            (c >= '0' && c <= '9') ||\n+            (c >= 'a' && c <= 'z') ||\n+            (c >= 'A' && c <= 'Z'));\n+    }\n+\n+    /**\n+     * Returns `true` if the given `c` character is a separator.\n+     *\n+     * @param {string} c\n+     *\n+     * @return {boolean}\n+     */\n+    function isSeparatorCharacter(c) {\n+        return c === \",\" || isWhitespaceCharacter(c);\n+    }\n+\n+    /**\n+     * Returns `true` if the given `c` character is a whitespace.\n+     *\n+     * @param {string} c\n+     *\n+     * @return {boolean}\n+     */\n+    function isWhitespaceCharacter(c) {\n+        return c === \" \" || c === \"\\t\";\n+    }\n+\n+    /**\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {string} name                  - Name of the query element.\n+     * @param {Array<QueryElement>} generics - List of generics of this query element.\n+     *\n+     * @return {QueryElement}                - The newly created `QueryElement`.\n+     */\n+    function createQueryElement(query, parserState, name, generics, isInGenerics) {\n+        if (name === '*' || (name.length === 0 && generics.length === 0)) {\n+            return;\n+        }\n+        if (query.literalSearch && parserState.totalElems - parserState.genericsElems > 0) {\n+            throw new Error(\"You cannot have more than one element if you use quotes\");\n+        }\n+        var pathSegments = name.split(\"::\");\n+        if (pathSegments.length > 1) {\n+            for (var i = 0, len = pathSegments.length; i < len; ++i) {\n+                var pathSegment = pathSegments[i];\n+\n+                if (pathSegment.length === 0) {\n+                    if (i === 0) {\n+                        throw new Error(\"Paths cannot start with `::`\");\n+                    } else if (i + 1 === len) {\n+                        throw new Error(\"Paths cannot end with `::`\");\n+                    }\n+                    throw new Error(\"Unexpected `::::`\");\n+                }\n+            }\n+        }\n+        // In case we only have something like `<p>`, there is no name.\n+        if (pathSegments.length === 0 || (pathSegments.length === 1 && pathSegments[0] === \"\")) {\n+            throw new Error(\"Found generics without a path\");\n+        }\n+        parserState.totalElems += 1;\n+        if (isInGenerics) {\n+            parserState.genericsElems += 1;\n+        }\n+        return {\n+            name: name,\n+            fullPath: pathSegments,\n+            pathWithoutLast: pathSegments.slice(0, pathSegments.length - 1),\n+            pathLast: pathSegments[pathSegments.length - 1],\n+            generics: generics,\n+        };\n+    }\n+\n+    /**\n+     * This function goes through all characters until it reaches an invalid ident character or the\n+     * end of the query. It returns the position of the last character of the ident.\n+     *\n+     * @param {ParserState} parserState\n+     *\n+     * @return {integer}\n+     */\n+    function getIdentEndPosition(parserState) {\n+        var end = parserState.pos;\n+        while (parserState.pos < parserState.length) {\n+            var c = parserState.userQuery[parserState.pos];\n+            if (!isIdentCharacter(c)) {\n+                if (isErrorCharacter(c)) {\n+                    throw new Error(`Unexpected \\`${c}\\``);\n+                } else if (\n+                    isStopCharacter(c) ||\n+                    isSpecialStartCharacter(c) ||\n+                    isSeparatorCharacter(c))\n+                {\n+                    break;\n+                }\n+                // If we allow paths (\"str::string\" for example).\n+                else if (c === \":\") {\n+                    if (!isPathStart(parserState)) {\n+                        break;\n+                    }\n+                    // Skip current \":\".\n+                    parserState.pos += 1;\n+                } else {\n+                    throw new Error(`Unexpected \\`${c}\\``);\n+                }\n+            }\n+            parserState.pos += 1;\n+            end = parserState.pos;\n+        }\n+        return end;\n+    }\n+\n+    /**\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {Array<QueryElement>} elems - This is where the new {QueryElement} will be added.\n+     * @param {boolean} isInGenerics\n+     */\n+    function getNextElem(query, parserState, elems, isInGenerics) {\n+        var generics = [];\n+\n+        var start = parserState.pos;\n+        var end;\n+        // We handle the strings on their own mostly to make code easier to follow.\n+        if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n+            start += 1;\n+            getStringElem(query, parserState, isInGenerics);\n+            end = parserState.pos - 1;\n+        } else {\n+            end = getIdentEndPosition(parserState);\n+        }\n+        if (parserState.pos < parserState.length &&\n+            parserState.userQuery[parserState.pos] === \"<\")\n+        {\n+            if (isInGenerics) {\n+                throw new Error(\"Unexpected `<` after `<`\");\n+            } else if (start >= end) {\n+                throw new Error(\"Found generics without a path\");\n+            }\n+            parserState.pos += 1;\n+            getItemsBefore(query, parserState, generics, \">\");\n+        }\n+        if (start >= end && generics.length === 0) {\n+            return;\n+        }\n+        elems.push(\n+            createQueryElement(\n+                query,\n+                parserState,\n+                parserState.userQuery.slice(start, end),\n+                generics,\n+                isInGenerics\n+            )\n+        );\n+    }\n+\n+    /**\n+     * This function parses the next query element until it finds `endChar`, calling `getNextElem`\n+     * to collect each element.\n+     *\n+     * If there is no `endChar`, this function will implicitly stop at the end without raising an\n+     * error.\n+     *\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {Array<QueryElement>} elems - This is where the new {QueryElement} will be added.\n+     * @param {string} endChar            - This function will stop when it'll encounter this\n+     *                                      character.\n+     */\n+    function getItemsBefore(query, parserState, elems, endChar) {\n+        var foundStopChar = true;\n+\n+        while (parserState.pos < parserState.length) {\n+            var c = parserState.userQuery[parserState.pos];\n+            if (c === endChar) {\n+                break;\n+            } else if (isSeparatorCharacter(c)) {\n+                parserState.pos += 1;\n+                foundStopChar = true;\n+                continue;\n+            } else if (c === \":\" && isPathStart(parserState)) {\n+                throw new Error(\"Unexpected `::`: paths cannot start with `::`\");\n+            } else if (c === \":\" || isEndCharacter(c)) {\n+                var extra = \"\";\n+                if (endChar === \">\") {\n+                    extra = \"`<`\";\n+                } else if (endChar === \"\") {\n+                    extra = \"`->`\";\n+                }\n+                throw new Error(\"Unexpected `\" + c + \"` after \" + extra);\n+            }\n+            if (!foundStopChar) {\n+                if (endChar !== \"\") {\n+                    throw new Error(`Expected \\`,\\`, \\` \\` or \\`${endChar}\\`, found \\`${c}\\``);\n+                }\n+                throw new Error(`Expected \\`,\\` or \\` \\`, found \\`${c}\\``);\n+            }\n+            var posBefore = parserState.pos;\n+            getNextElem(query, parserState, elems, endChar === \">\");\n+            // This case can be encountered if `getNextElem` encounted a \"stop character\" right from\n+            // the start. For example if you have `,,` or `<>`. In this case, we simply move up the\n+            // current position to continue the parsing.\n+            if (posBefore === parserState.pos) {\n+                parserState.pos += 1;\n+            }\n+            foundStopChar = false;\n+        }\n+        // We are either at the end of the string or on the `endChar`` character, let's move forward\n+        // in any case.\n+        parserState.pos += 1;\n+    }\n+\n+    /**\n+     * Checks that the type filter doesn't have unwanted characters like `<>` (which are ignored\n+     * if empty).\n+     *\n+     * @param {ParserState} parserState\n+     */\n+    function checkExtraTypeFilterCharacters(parserState) {\n+        var query = parserState.userQuery;\n+\n+        for (var pos = 0; pos < parserState.pos; ++pos) {\n+            if (!isIdentCharacter(query[pos]) && !isWhitespaceCharacter(query[pos])) {\n+                throw new Error(`Unexpected \\`${query[pos]}\\` in type filter`);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parses the provided `query` input to fill `parserState`. If it encounters an error while\n+     * parsing `query`, it'll throw an error.\n+     *\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     */\n+    function parseInput(query, parserState) {\n+        var c, before;\n+        var foundStopChar = true;\n+\n+        while (parserState.pos < parserState.length) {\n+            c = parserState.userQuery[parserState.pos];\n+            if (isStopCharacter(c)) {\n+                foundStopChar = true;\n+                if (isSeparatorCharacter(c)) {\n+                    parserState.pos += 1;\n+                    continue;\n+                } else if (c === \"-\" || c === \">\") {\n+                    if (isReturnArrow(parserState)) {\n+                        break;\n+                    }\n+                    throw new Error(`Unexpected \\`${c}\\` (did you mean \\`->\\`?)`);\n+                }\n+                throw new Error(`Unexpected \\`${c}\\``);\n+            } else if (c === \":\" && !isPathStart(parserState)) {\n+                if (parserState.typeFilter !== null) {\n+                    throw new Error(\"Unexpected `:`\");\n+                }\n+                if (query.elems.length === 0) {\n+                    throw new Error(\"Expected type filter before `:`\");\n+                } else if (query.elems.length !== 1 || parserState.totalElems !== 1) {\n+                    throw new Error(\"Unexpected `:`\");\n+                } else if (query.literalSearch) {\n+                    throw new Error(\"You cannot use quotes on type filter\");\n+                }\n+                checkExtraTypeFilterCharacters(parserState);\n+                // The type filter doesn't count as an element since it's a modifier.\n+                parserState.typeFilter = query.elems.pop().name;\n+                parserState.pos += 1;\n+                parserState.totalElems = 0;\n+                query.literalSearch = false;\n+                foundStopChar = true;\n+                continue;\n+            }\n+            if (!foundStopChar) {\n+                if (parserState.typeFilter !== null) {\n+                    throw new Error(`Expected \\`,\\`, \\` \\` or \\`->\\`, found \\`${c}\\``);\n+                }\n+                throw new Error(`Expected \\`,\\`, \\` \\`, \\`:\\` or \\`->\\`, found \\`${c}\\``);\n+            }\n+            before = query.elems.length;\n+            getNextElem(query, parserState, query.elems, false);\n+            if (query.elems.length === before) {\n+                // Nothing was added, weird... Let's increase the position to not remain stuck.\n+                parserState.pos += 1;\n+            }\n+            foundStopChar = false;\n+        }\n+        while (parserState.pos < parserState.length) {\n+            c = parserState.userQuery[parserState.pos];\n+            if (isReturnArrow(parserState)) {\n+                parserState.pos += 2;\n+                // Get returned elements.\n+                getItemsBefore(query, parserState, query.returned, \"\");\n+                // Nothing can come afterward!\n+                if (query.returned.length === 0) {\n+                    throw new Error(\"Expected at least one item after `->`\");\n+                }\n+                break;\n+            } else {\n+                parserState.pos += 1;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Takes the user search input and returns an empty `ParsedQuery`.\n+     *\n+     * @param {string} userQuery\n+     *\n+     * @return {ParsedQuery}\n+     */\n+    function newParsedQuery(userQuery) {\n+        return {\n+            original: userQuery,\n+            userQuery: userQuery.toLowerCase(),\n+            typeFilter: NO_TYPE_FILTER,\n+            elems: [],\n+            returned: [],\n+            // Total number of \"top\" elements (does not include generics).\n+            foundElems: 0,\n+            literalSearch: false,\n+            error: null,\n+        };\n+    }\n+\n     /**\n      * Build an URL with search parameters.\n      *\n      * @param {string} search            - The current search being performed.\n      * @param {string|null} filterCrates - The current filtering crate (if any).\n+     *\n      * @return {string}\n      */\n     function buildUrl(search, filterCrates) {\n@@ -167,33 +583,139 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     /**\n-     * Executes the query and returns a list of results for each results tab.\n-     * @param  {Object}        query          - The user query\n-     * @param  {Array<string>} searchWords    - The list of search words to query against\n-     * @param  {string}        [filterCrates] - Crate to search in\n-     * @return {{\n-     *   in_args: Array<?>,\n-     *   returned: Array<?>,\n-     *   others: Array<?>\n-     * }}\n+     * Parses the query.\n+     *\n+     * The supported syntax by this parser is as follow:\n+     *\n+     * ident = *(ALPHA / DIGIT / \"_\")\n+     * path = ident *(DOUBLE-COLON ident)\n+     * arg = path [generics]\n+     * arg-without-generic = path\n+     * type-sep = COMMA/WS *(COMMA/WS)\n+     * nonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep)\n+     * nonempty-arg-list-without-generics = *(type-sep) arg-without-generic\n+     *                                      *(type-sep arg-without-generic) *(type-sep)\n+     * generics = OPEN-ANGLE-BRACKET [ nonempty-arg-list-without-generics ] *(type-sep)\n+     *            CLOSE-ANGLE-BRACKET/EOF\n+     * return-args = RETURN-ARROW *(type-sep) nonempty-arg-list\n+     *\n+     * exact-search = [type-filter *WS COLON] [ RETURN-ARROW ] *WS QUOTE ident QUOTE [ generics ]\n+     * type-search = [type-filter *WS COLON] [ nonempty-arg-list ] [ return-args ]\n+     *\n+     * query = *WS (exact-search / type-search) *WS\n+     *\n+     * type-filter = (\n+     *     \"mod\" /\n+     *     \"externcrate\" /\n+     *     \"import\" /\n+     *     \"struct\" /\n+     *     \"enum\" /\n+     *     \"fn\" /\n+     *     \"type\" /\n+     *     \"static\" /\n+     *     \"trait\" /\n+     *     \"impl\" /\n+     *     \"tymethod\" /\n+     *     \"method\" /\n+     *     \"structfield\" /\n+     *     \"variant\" /\n+     *     \"macro\" /\n+     *     \"primitive\" /\n+     *     \"associatedtype\" /\n+     *     \"constant\" /\n+     *     \"associatedconstant\" /\n+     *     \"union\" /\n+     *     \"foreigntype\" /\n+     *     \"keyword\" /\n+     *     \"existential\" /\n+     *     \"attr\" /\n+     *     \"derive\" /\n+     *     \"traitalias\")\n+     *\n+     * OPEN-ANGLE-BRACKET = \"<\"\n+     * CLOSE-ANGLE-BRACKET = \">\"\n+     * COLON = \":\"\n+     * DOUBLE-COLON = \"::\"\n+     * QUOTE = %x22\n+     * COMMA = \",\"\n+     * RETURN-ARROW = \"->\"\n+     *\n+     * ALPHA = %x41-5A / %x61-7A ; A-Z / a-z\n+     * DIGIT = %x30-39\n+     * WS = %x09 / \" \"\n+     *\n+     * @param  {string} val     - The user query\n+     *\n+     * @return {ParsedQuery}    - The parsed query\n      */\n-    function execQuery(query, searchWords, filterCrates) {\n-        function itemTypeFromName(typename) {\n-            for (var i = 0, len = itemTypes.length; i < len; ++i) {\n-                if (itemTypes[i] === typename) {\n-                    return i;\n+    function parseQuery(userQuery) {\n+        userQuery = userQuery.trim();\n+        var parserState = {\n+            length: userQuery.length,\n+            pos: 0,\n+            // Total number of elements (includes generics).\n+            totalElems: 0,\n+            genericsElems: 0,\n+            typeFilter: null,\n+            userQuery: userQuery.toLowerCase(),\n+        };\n+        var query = newParsedQuery(userQuery);\n+\n+        try {\n+            parseInput(query, parserState);\n+            if (parserState.typeFilter !== null) {\n+                var typeFilter = parserState.typeFilter;\n+                if (typeFilter === \"const\") {\n+                    typeFilter = \"constant\";\n                 }\n+                query.typeFilter = itemTypeFromName(typeFilter);\n             }\n-            return NO_TYPE_FILTER;\n+        } catch (err) {\n+            query = newParsedQuery(userQuery);\n+            query.error = err.message;\n+            query.typeFilter = -1;\n+            return query;\n         }\n \n-        var valLower = query.query.toLowerCase(),\n-            val = valLower,\n-            typeFilter = itemTypeFromName(query.type),\n-            results = {}, results_in_args = {}, results_returned = {},\n-            split = valLower.split(\"::\");\n+        if (!query.literalSearch) {\n+            // If there is more than one element in the query, we switch to literalSearch in any\n+            // case.\n+            query.literalSearch = parserState.totalElems > 1;\n+        }\n+        query.foundElems = query.elems.length + query.returned.length;\n+        return query;\n+    }\n \n-        removeEmptyStringsFromArray(split);\n+    /**\n+     * Creates the query results.\n+     *\n+     * @param {Array<Result>} results_in_args\n+     * @param {Array<Result>} results_returned\n+     * @param {Array<Result>} results_in_args\n+     * @param {ParsedQuery} parsedQuery\n+     *\n+     * @return {ResultsTable}\n+     */\n+    function createQueryResults(results_in_args, results_returned, results_others, parsedQuery) {\n+        return {\n+            \"in_args\": results_in_args,\n+            \"returned\": results_returned,\n+            \"others\": results_others,\n+            \"query\": parsedQuery,\n+        };\n+    }\n+\n+    /**\n+     * Executes the parsed query and builds a {ResultsTable}.\n+     *\n+     * @param  {ParsedQuery} parsedQuery - The parsed user query\n+     * @param  {Object} searchWords      - The list of search words to query against\n+     * @param  {Object} [filterCrates]   - Crate to search in if defined\n+     *\n+     * @return {ResultsTable}\n+     */\n+    function execQuery(parsedQuery, searchWords, filterCrates) {\n+        var results_others = {}, results_in_args = {}, results_returned = {};\n \n         function transformResults(results) {\n             var duplicates = {};\n@@ -227,6 +749,7 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function sortResults(results, isType) {\n+            var userQuery = parsedQuery.userQuery;\n             var ar = [];\n             for (var entry in results) {\n                 if (hasOwnPropertyRustdoc(results, entry)) {\n@@ -246,8 +769,8 @@ window.initSearch = function(rawSearchIndex) {\n                 var a, b;\n \n                 // sort by exact match with regard to the last word (mismatch goes later)\n-                a = (aaa.word !== val);\n-                b = (bbb.word !== val);\n+                a = (aaa.word !== userQuery);\n+                b = (bbb.word !== userQuery);\n                 if (a !== b) { return a - b; }\n \n                 // Sort by non levenshtein results and then levenshtein results by the distance\n@@ -309,6 +832,12 @@ window.initSearch = function(rawSearchIndex) {\n                 return 0;\n             });\n \n+            var nameSplit = null;\n+            if (parsedQuery.elems.length === 1) {\n+                var hasPath = typeof parsedQuery.elems[0].path === \"undefined\";\n+                nameSplit = hasPath ? null : parsedQuery.elems[0].path;\n+            }\n+\n             for (var i = 0, len = results.length; i < len; ++i) {\n                 result = results[i];\n \n@@ -320,215 +849,222 @@ window.initSearch = function(rawSearchIndex) {\n                     path = result.item.path.toLowerCase(),\n                     parent = result.item.parent;\n \n-                if (!isType && !validateResult(name, path, split, parent)) {\n+                if (!isType && !validateResult(name, path, nameSplit, parent)) {\n                     result.id = -1;\n                 }\n             }\n             return transformResults(results);\n         }\n \n-        function extractGenerics(val) {\n-            val = val.toLowerCase();\n-            if (val.indexOf(\"<\") !== -1) {\n-                var values = val.substring(val.indexOf(\"<\") + 1, val.lastIndexOf(\">\"));\n-                return {\n-                    name: val.substring(0, val.indexOf(\"<\")),\n-                    generics: values.split(/\\s*,\\s*/),\n-                };\n+        /**\n+         * This function checks if the object (`row`) generics match the given type (`elem`)\n+         * generics. If there are no generics on `row`, `defaultLev` is returned.\n+         *\n+         * @param {Row} row            - The object to check.\n+         * @param {QueryElement} elem  - The element from the parsed query.\n+         * @param {integer} defaultLev - This is the value to return in case there are no generics.\n+         *\n+         * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n+         */\n+        function checkGenerics(row, elem, defaultLev) {\n+            if (row.length <= GENERICS_DATA || row[GENERICS_DATA].length === 0) {\n+                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n+            } else if (row[GENERICS_DATA].length > 0 && row[GENERICS_DATA][0][NAME] === \"\") {\n+                if (row.length > GENERICS_DATA) {\n+                    return checkGenerics(row[GENERICS_DATA][0], elem, defaultLev);\n+                }\n+                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n             }\n-            return {\n-                name: val,\n-                generics: [],\n-            };\n-        }\n-\n-        function checkGenerics(obj, val) {\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n-            var tmp_lev, elem_name;\n-            if (val.generics.length > 0) {\n-                if (obj.length > GENERICS_DATA &&\n-                      obj[GENERICS_DATA].length >= val.generics.length) {\n-                    var elems = Object.create(null);\n-                    var elength = obj[GENERICS_DATA].length;\n-                    for (var x = 0; x < elength; ++x) {\n-                        if (!elems[obj[GENERICS_DATA][x][NAME]]) {\n-                            elems[obj[GENERICS_DATA][x][NAME]] = 0;\n+            var elem_name;\n+            if (elem.generics.length > 0 && row[GENERICS_DATA].length >= elem.generics.length) {\n+                var elems = Object.create(null);\n+                for (var x = 0, length = row[GENERICS_DATA].length; x < length; ++x) {\n+                    elem_name = row[GENERICS_DATA][x][NAME];\n+                    if (elem_name === \"\") {\n+                        // Pure generic, needs to check into it.\n+                        if (checkGenerics(\n+                                row[GENERICS_DATA][x], elem, MAX_LEV_DISTANCE + 1) !== 0) {\n+                            return MAX_LEV_DISTANCE + 1;\n                         }\n-                        elems[obj[GENERICS_DATA][x][NAME]] += 1;\n+                        continue;\n+                    }\n+                    if (elems[elem_name] === undefined) {\n+                        elems[elem_name] = 0;\n                     }\n-                    var total = 0;\n-                    var done = 0;\n-                    // We need to find the type that matches the most to remove it in order\n-                    // to move forward.\n-                    var vlength = val.generics.length;\n-                    for (x = 0; x < vlength; ++x) {\n-                        var lev = MAX_LEV_DISTANCE + 1;\n-                        var firstGeneric = val.generics[x];\n-                        var match = null;\n-                        if (elems[firstGeneric]) {\n-                            match = firstGeneric;\n-                            lev = 0;\n-                        } else {\n-                            for (elem_name in elems) {\n-                                tmp_lev = levenshtein(elem_name, firstGeneric);\n-                                if (tmp_lev < lev) {\n-                                    lev = tmp_lev;\n-                                    match = elem_name;\n-                                }\n+                    elems[elem_name] += 1;\n+                }\n+                // We need to find the type that matches the most to remove it in order\n+                // to move forward.\n+                for (x = 0, length = elem.generics.length; x < length; ++x) {\n+                    var generic = elem.generics[x];\n+                    var match = null;\n+                    if (elems[generic.name]) {\n+                        match = generic.name;\n+                    } else {\n+                        for (elem_name in elems) {\n+                            if (!hasOwnPropertyRustdoc(elems, elem_name)) {\n+                                continue;\n                             }\n-                        }\n-                        if (match !== null) {\n-                            elems[match] -= 1;\n-                            if (elems[match] == 0) {\n-                                delete elems[match];\n+                            if (elem_name === generic) {\n+                                match = elem_name;\n+                                break;\n                             }\n-                            total += lev;\n-                            done += 1;\n-                        } else {\n-                            return MAX_LEV_DISTANCE + 1;\n                         }\n                     }\n-                    return Math.ceil(total / done);\n+                    if (match === null) {\n+                        return MAX_LEV_DISTANCE + 1;\n+                    }\n+                    elems[match] -= 1;\n+                    if (elems[match] === 0) {\n+                        delete elems[match];\n+                    }\n                 }\n+                return 0;\n             }\n             return MAX_LEV_DISTANCE + 1;\n         }\n \n         /**\n-          * This function checks if the object (`obj`) matches the given type (`val`) and its\n+          * This function checks if the object (`row`) matches the given type (`elem`) and its\n+          * generics (if any).\n+          *\n+          * @param {Row} row\n+          * @param {QueryElement} elem    - The element from the parsed query.\n+          *\n+          * @return {integer} - Returns a Levenshtein distance to the best match.\n+          */\n+        function checkIfInGenerics(row, elem) {\n+            var lev = MAX_LEV_DISTANCE + 1;\n+            for (var x = 0, length = row[GENERICS_DATA].length; x < length && lev !== 0; ++x) {\n+                lev = Math.min(\n+                    checkType(row[GENERICS_DATA][x], elem, true),\n+                    lev\n+                );\n+            }\n+            return lev;\n+        }\n+\n+        /**\n+          * This function checks if the object (`row`) matches the given type (`elem`) and its\n           * generics (if any).\n           *\n-          * @param {Object} obj\n-          * @param {string} val\n+          * @param {Row} row\n+          * @param {QueryElement} elem      - The element from the parsed query.\n           * @param {boolean} literalSearch\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n           *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n           */\n-        function checkType(obj, val, literalSearch) {\n-            var lev_distance = MAX_LEV_DISTANCE + 1;\n-            var tmp_lev = MAX_LEV_DISTANCE + 1;\n-            var len, x, firstGeneric;\n-            if (obj[NAME] === val.name) {\n-                if (literalSearch) {\n-                    if (val.generics && val.generics.length !== 0) {\n-                        if (obj.length > GENERICS_DATA &&\n-                             obj[GENERICS_DATA].length > 0) {\n-                            var elems = Object.create(null);\n-                            len = obj[GENERICS_DATA].length;\n-                            for (x = 0; x < len; ++x) {\n-                                if (!elems[obj[GENERICS_DATA][x][NAME]]) {\n-                                    elems[obj[GENERICS_DATA][x][NAME]] = 0;\n-                                }\n-                                elems[obj[GENERICS_DATA][x][NAME]] += 1;\n-                            }\n+        function checkType(row, elem, literalSearch) {\n+            if (row[NAME].length === 0) {\n+                // This is a pure \"generic\" search, no need to run other checks.\n+                if (row.length > GENERICS_DATA) {\n+                    return checkIfInGenerics(row, elem);\n+                }\n+                return MAX_LEV_DISTANCE + 1;\n+            }\n \n-                            len = val.generics.length;\n-                            for (x = 0; x < len; ++x) {\n-                                firstGeneric = val.generics[x];\n-                                if (elems[firstGeneric]) {\n-                                    elems[firstGeneric] -= 1;\n-                                } else {\n-                                    // Something wasn't found and this is a literal search so\n-                                    // abort and return a \"failing\" distance.\n-                                    return MAX_LEV_DISTANCE + 1;\n-                                }\n-                            }\n-                            // Everything was found, success!\n+            var lev = levenshtein(row[NAME], elem.name);\n+            if (literalSearch) {\n+                if (lev !== 0) {\n+                    // The name didn't match, let's try to check if the generics do.\n+                    if (elem.generics.length === 0) {\n+                        var checkGeneric = (row.length > GENERICS_DATA &&\n+                            row[GENERICS_DATA].length > 0);\n+                        if (checkGeneric && row[GENERICS_DATA].findIndex(function(tmp_elem) {\n+                            return tmp_elem[NAME] === elem.name;\n+                        }) !== -1) {\n                             return 0;\n                         }\n-                        return MAX_LEV_DISTANCE + 1;\n                     }\n-                    return 0;\n-                } else {\n-                    // If the type has generics but don't match, then it won't return at this point.\n-                    // Otherwise, `checkGenerics` will return 0 and it'll return.\n-                    if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n-                        tmp_lev = checkGenerics(obj, val);\n-                        if (tmp_lev <= MAX_LEV_DISTANCE) {\n-                            return tmp_lev;\n-                        }\n-                    }\n-                }\n-            } else if (literalSearch) {\n-                var found = false;\n-                if ((!val.generics || val.generics.length === 0) &&\n-                      obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                    found = obj[GENERICS_DATA].some(\n-                        function(gen) {\n-                            return gen[NAME] === val.name;\n-                        });\n-                }\n-                return found ? 0 : MAX_LEV_DISTANCE + 1;\n-            }\n-            lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n-            if (lev_distance <= MAX_LEV_DISTANCE) {\n-                // The generics didn't match but the name kinda did so we give it\n-                // a levenshtein distance value that isn't *this* good so it goes\n-                // into the search results but not too high.\n-                lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n-            }\n-            if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                // We can check if the type we're looking for is inside the generics!\n-                var olength = obj[GENERICS_DATA].length;\n-                for (x = 0; x < olength; ++x) {\n-                    tmp_lev = Math.min(levenshtein(obj[GENERICS_DATA][x][NAME], val.name), tmp_lev);\n+                    return MAX_LEV_DISTANCE + 1;\n+                } else if (elem.generics.length > 0) {\n+                    return checkGenerics(row, elem, MAX_LEV_DISTANCE + 1);\n                 }\n-                if (tmp_lev !== 0) {\n-                    // If we didn't find a good enough result, we go check inside the generics of\n-                    // the generics.\n-                    for (x = 0; x < olength && tmp_lev !== 0; ++x) {\n-                        tmp_lev = Math.min(\n-                            checkType(obj[GENERICS_DATA][x], val, literalSearch),\n-                            tmp_lev\n-                        );\n+                return 0;\n+            } else if (row.length > GENERICS_DATA) {\n+                if (elem.generics.length === 0) {\n+                    if (lev === 0) {\n+                        return 0;\n+                    }\n+                    // The name didn't match so we now check if the type we're looking for is inside\n+                    // the generics!\n+                    lev = checkIfInGenerics(row, elem);\n+                    // Now whatever happens, the returned distance is \"less good\" so we should mark\n+                    // it as such, and so we add 0.5 to the distance to make it \"less good\".\n+                    return lev + 0.5;\n+                } else if (lev > MAX_LEV_DISTANCE) {\n+                    // So our item's name doesn't match at all and has generics.\n+                    //\n+                    // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n+                    // looking for \"B<C>\", we'll need to go down.\n+                    return checkIfInGenerics(row, elem);\n+                } else {\n+                    // At this point, the name kinda match and we have generics to check, so\n+                    // let's go!\n+                    var tmp_lev = checkGenerics(row, elem, lev);\n+                    if (tmp_lev > MAX_LEV_DISTANCE) {\n+                        return MAX_LEV_DISTANCE + 1;\n                     }\n+                    // We compute the median value of both checks and return it.\n+                    return (tmp_lev + lev) / 2;\n                 }\n+            } else if (elem.generics.length > 0) {\n+                // In this case, we were expecting generics but there isn't so we simply reject this\n+                // one.\n+                return MAX_LEV_DISTANCE + 1;\n             }\n-            // Now whatever happens, the returned distance is \"less good\" so we should mark it\n-            // as such, and so we add 1 to the distance to make it \"less good\".\n-            return Math.min(lev_distance, tmp_lev) + 1;\n+            // No generics on our query or on the target type so we can return without doing\n+            // anything else.\n+            return lev;\n         }\n \n         /**\n-         * This function checks if the object (`obj`) has an argument with the given type (`val`).\n+         * This function checks if the object (`row`) has an argument with the given type (`elem`).\n          *\n-         * @param {Object} obj\n-         * @param {string} val\n-         * @param {boolean} literalSearch\n+         * @param {Row} row\n+         * @param {QueryElement} elem    - The element from the parsed query.\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n-        function findArg(obj, val, literalSearch, typeFilter) {\n-            var lev_distance = MAX_LEV_DISTANCE + 1;\n+        function findArg(row, elem, typeFilter) {\n+            var lev = MAX_LEV_DISTANCE + 1;\n \n-            if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n-                var length = obj.type[INPUTS_DATA].length;\n+            if (row && row.type && row.type[INPUTS_DATA] && row.type[INPUTS_DATA].length > 0) {\n+                var length = row.type[INPUTS_DATA].length;\n                 for (var i = 0; i < length; i++) {\n-                    var tmp = obj.type[INPUTS_DATA][i];\n+                    var tmp = row.type[INPUTS_DATA][i];\n                     if (!typePassesFilter(typeFilter, tmp[1])) {\n                         continue;\n                     }\n-                    tmp = checkType(tmp, val, literalSearch);\n-                    if (tmp === 0) {\n+                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n+                    if (lev === 0) {\n                         return 0;\n-                    } else if (literalSearch) {\n-                        continue;\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n                 }\n             }\n-            return literalSearch ? MAX_LEV_DISTANCE + 1 : lev_distance;\n+            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n-        function checkReturned(obj, val, literalSearch, typeFilter) {\n-            var lev_distance = MAX_LEV_DISTANCE + 1;\n+        /**\n+         * This function checks if the object (`row`) returns the given type (`elem`).\n+         *\n+         * @param {Row} row\n+         * @param {QueryElement} elem   - The element from the parsed query.\n+         * @param {integer} typeFilter\n+         *\n+         * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n+         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         */\n+        function checkReturned(row, elem, typeFilter) {\n+            var lev = MAX_LEV_DISTANCE + 1;\n \n-            if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                var ret = obj.type[OUTPUT_DATA];\n+            if (row && row.type && row.type.length > OUTPUT_DATA) {\n+                var ret = row.type[OUTPUT_DATA];\n                 if (typeof ret[0] === \"string\") {\n                     ret = [ret];\n                 }\n@@ -537,16 +1073,13 @@ window.initSearch = function(rawSearchIndex) {\n                     if (!typePassesFilter(typeFilter, tmp[1])) {\n                         continue;\n                     }\n-                    tmp = checkType(tmp, val, literalSearch);\n-                    if (tmp === 0) {\n+                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n+                    if (lev === 0) {\n                         return 0;\n-                    } else if (literalSearch) {\n-                        continue;\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n                 }\n             }\n-            return literalSearch ? MAX_LEV_DISTANCE + 1 : lev_distance;\n+            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n         function checkPath(contains, lastElem, ty) {\n@@ -621,23 +1154,24 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function handleAliases(ret, query, filterCrates) {\n+            var lowerQuery = query.toLowerCase();\n             // We separate aliases and crate aliases because we want to have current crate\n             // aliases to be before the others in the displayed results.\n             var aliases = [];\n             var crateAliases = [];\n             if (filterCrates !== null) {\n-                if (ALIASES[filterCrates] && ALIASES[filterCrates][query.search]) {\n-                    var query_aliases = ALIASES[filterCrates][query.search];\n+                if (ALIASES[filterCrates] && ALIASES[filterCrates][lowerQuery]) {\n+                    var query_aliases = ALIASES[filterCrates][lowerQuery];\n                     var len = query_aliases.length;\n                     for (var i = 0; i < len; ++i) {\n                         aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n                     }\n                 }\n             } else {\n                 Object.keys(ALIASES).forEach(function(crate) {\n-                    if (ALIASES[crate][query.search]) {\n+                    if (ALIASES[crate][lowerQuery]) {\n                         var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                        var query_aliases = ALIASES[crate][query.search];\n+                        var query_aliases = ALIASES[crate][lowerQuery];\n                         var len = query_aliases.length;\n                         for (var i = 0; i < len; ++i) {\n                             pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n@@ -658,7 +1192,7 @@ window.initSearch = function(rawSearchIndex) {\n             aliases.sort(sortFunc);\n \n             var pushFunc = function(alias) {\n-                alias.alias = query.raw;\n+                alias.alias = query;\n                 var res = buildHrefAndPath(alias);\n                 alias.displayPath = pathSplitter(res[0]);\n                 alias.fullPath = alias.displayPath + alias.name;\n@@ -674,208 +1208,237 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         /**\n-         * This function adds the given result into the provided `res` map if it matches the\n+         * This function adds the given result into the provided `results` map if it matches the\n          * following condition:\n          *\n-         * * If it is a \"literal search\" (`isExact`), then `lev` must be 0.\n+         * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `lev` must be 0.\n          * * If it is not a \"literal search\", `lev` must be <= `MAX_LEV_DISTANCE`.\n          *\n-         * The `res` map contains information which will be used to sort the search results:\n+         * The `results` map contains information which will be used to sort the search results:\n          *\n-         * * `fullId` is a `string`` used as the key of the object we use for the `res` map.\n+         * * `fullId` is a `string`` used as the key of the object we use for the `results` map.\n          * * `id` is the index in both `searchWords` and `searchIndex` arrays for this element.\n          * * `index` is an `integer`` used to sort by the position of the word in the item's name.\n          * * `lev` is the main metric used to sort the search results.\n          *\n-         * @param {boolean} isExact\n-         * @param {Object} res\n+         * @param {Results} results\n          * @param {string} fullId\n          * @param {integer} id\n          * @param {integer} index\n          * @param {integer} lev\n          */\n-        function addIntoResults(isExact, res, fullId, id, index, lev) {\n-            if (lev === 0 || (!isExact && lev <= MAX_LEV_DISTANCE)) {\n-                if (res[fullId] !== undefined) {\n-                    var result = res[fullId];\n+        function addIntoResults(results, fullId, id, index, lev) {\n+            if (lev === 0 || (!parsedQuery.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n+                if (results[fullId] !== undefined) {\n+                    var result = results[fullId];\n                     if (result.dontValidate || result.lev <= lev) {\n                         return;\n                     }\n                 }\n-                res[fullId] = {\n+                results[fullId] = {\n                     id: id,\n                     index: index,\n-                    dontValidate: isExact,\n+                    dontValidate: parsedQuery.literalSearch,\n                     lev: lev,\n                 };\n             }\n         }\n \n-        // quoted values mean literal search\n-        var nSearchWords = searchWords.length;\n-        var i, it;\n-        var ty;\n-        var fullId;\n-        var returned;\n-        var in_args;\n-        var len;\n-        if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n-            val.charAt(val.length - 1) === val.charAt(0))\n-        {\n-            val = extractGenerics(val.substr(1, val.length - 2));\n-            for (i = 0; i < nSearchWords; ++i) {\n-                if (filterCrates !== null && searchIndex[i].crate !== filterCrates) {\n-                    continue;\n+        /**\n+         * This function is called in case the query is only one element (with or without generics).\n+         * This element will be compared to arguments' and returned values' items and also to items.\n+         *\n+         * Other important thing to note: since there is only one element, we use levenshtein\n+         * distance for name comparisons.\n+         *\n+         * @param {Row} row\n+         * @param {integer} pos              - Position in the `searchIndex`.\n+         * @param {QueryElement} elem        - The element from the parsed query.\n+         * @param {Results} results_others   - Unqualified results (not in arguments nor in\n+         *                                     returned values).\n+         * @param {Results} results_in_args  - Matching arguments results.\n+         * @param {Results} results_returned - Matching returned arguments results.\n+         */\n+        function handleSingleArg(\n+            row,\n+            pos,\n+            elem,\n+            results_others,\n+            results_in_args,\n+            results_returned\n+        ) {\n+            if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n+                return;\n+            }\n+            var lev, lev_add = 0, index = -1;\n+            var fullId = row.id;\n+\n+            var in_args = findArg(row, elem, parsedQuery.typeFilter);\n+            var returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+\n+            addIntoResults(results_in_args, fullId, pos, index, in_args);\n+            addIntoResults(results_returned, fullId, pos, index, returned);\n+\n+            if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n+                return;\n+            }\n+            var searchWord = searchWords[pos];\n+\n+            if (parsedQuery.literalSearch) {\n+                if (searchWord === elem.name) {\n+                    addIntoResults(results_others, fullId, pos, -1, 0);\n                 }\n-                in_args = findArg(searchIndex[i], val, true, typeFilter);\n-                returned = checkReturned(searchIndex[i], val, true, typeFilter);\n-                ty = searchIndex[i];\n-                fullId = ty.id;\n-\n-                if (searchWords[i] === val.name\n-                    && typePassesFilter(typeFilter, searchIndex[i].ty)) {\n-                    addIntoResults(true, results, fullId, i, -1, 0);\n+                return;\n+            }\n+\n+            // No need to check anything else if it's a \"pure\" generics search.\n+            if (elem.name.length === 0) {\n+                if (row.type !== null) {\n+                    lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n+                    addIntoResults(results_others, fullId, pos, index, lev);\n                 }\n-                addIntoResults(true, results_in_args, fullId, i, -1, in_args);\n-                addIntoResults(true, results_returned, fullId, i, -1, returned);\n-            }\n-            query.inputs = [val];\n-            query.output = val;\n-            query.search = val;\n-        // searching by type\n-        } else if (val.search(\"->\") > -1) {\n-            var trimmer = function(s) { return s.trim(); };\n-            var parts = val.split(\"->\").map(trimmer);\n-            var input = parts[0];\n-            // sort inputs so that order does not matter\n-            var inputs = input.split(\",\").map(trimmer).sort();\n-            for (i = 0, len = inputs.length; i < len; ++i) {\n-                inputs[i] = extractGenerics(inputs[i]);\n-            }\n-            var output = extractGenerics(parts[1]);\n-\n-            for (i = 0; i < nSearchWords; ++i) {\n-                if (filterCrates !== null && searchIndex[i].crate !== filterCrates) {\n-                    continue;\n+                return;\n+            }\n+\n+            if (elem.fullPath.length > 1) {\n+                lev = checkPath(elem.pathWithoutLast, elem.pathLast, row);\n+                if (lev > MAX_LEV_DISTANCE || (parsedQuery.literalSearch && lev !== 0)) {\n+                    return;\n+                } else if (lev > 0) {\n+                    lev_add = lev / 10;\n                 }\n-                var type = searchIndex[i].type;\n-                ty = searchIndex[i];\n-                if (!type) {\n-                    continue;\n+            }\n+\n+            if (searchWord.indexOf(elem.pathLast) > -1 ||\n+                row.normalizedName.indexOf(elem.pathLast) > -1)\n+            {\n+                // filter type: ... queries\n+                if (!results_others[fullId] !== undefined) {\n+                    index = row.normalizedName.indexOf(elem.pathLast);\n                 }\n-                fullId = ty.id;\n+            }\n+            lev = levenshtein(searchWord, elem.pathLast);\n+            lev += lev_add;\n+            if (lev > 0 && elem.pathLast.length > 2 && searchWord.indexOf(elem.pathLast) > -1)\n+            {\n+                if (elem.pathLast.length < 6) {\n+                    lev = 1;\n+                } else {\n+                    lev = 0;\n+                }\n+            }\n+            if (lev > MAX_LEV_DISTANCE) {\n+                return;\n+            } else if (index !== -1 && elem.fullPath.length < 2) {\n+                lev -= 1;\n+            }\n+            if (lev < 0) {\n+                lev = 0;\n+            }\n+            addIntoResults(results_others, fullId, pos, index, lev);\n+        }\n \n-                returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n-                if (output.name === \"*\" || returned === 0) {\n-                    in_args = false;\n-                    var is_module = false;\n+        /**\n+         * This function is called in case the query has more than one element. In this case, it'll\n+         * try to match the items which validates all the elements. For `aa -> bb` will look for\n+         * functions which have a parameter `aa` and has `bb` in its returned values.\n+         *\n+         * @param {Row} row\n+         * @param {integer} pos      - Position in the `searchIndex`.\n+         * @param {Object} results\n+         */\n+        function handleArgs(row, pos, results) {\n+            if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n+                return;\n+            }\n \n-                    if (input === \"*\") {\n-                        is_module = true;\n+            var totalLev = 0;\n+            var nbLev = 0;\n+            var lev;\n+\n+            // If the result is too \"bad\", we return false and it ends this search.\n+            function checkArgs(elems, callback) {\n+                for (var i = 0, len = elems.length; i < len; ++i) {\n+                    var elem = elems[i];\n+                    // There is more than one parameter to the query so all checks should be \"exact\"\n+                    lev = callback(row, elem, NO_TYPE_FILTER);\n+                    if (lev <= 1) {\n+                        nbLev += 1;\n+                        totalLev += lev;\n                     } else {\n-                        var firstNonZeroDistance = 0;\n-                        for (it = 0, len = inputs.length; it < len; it++) {\n-                            var distance = checkType(type, inputs[it], true);\n-                            if (distance > 0) {\n-                                firstNonZeroDistance = distance;\n-                                break;\n-                            }\n-                        }\n-                        in_args = firstNonZeroDistance;\n-                    }\n-                    addIntoResults(true, results_in_args, fullId, i, -1, in_args);\n-                    addIntoResults(true, results_returned, fullId, i, -1, returned);\n-                    if (is_module) {\n-                        addIntoResults(true, results, fullId, i, -1, 0);\n+                        return false;\n                     }\n                 }\n+                return true;\n+            }\n+            if (!checkArgs(parsedQuery.elems, findArg)) {\n+                return;\n+            }\n+            if (!checkArgs(parsedQuery.returned, checkReturned)) {\n+                return;\n             }\n-            query.inputs = inputs.map(function(input) {\n-                return input.name;\n-            });\n-            query.output = output.name;\n-        } else {\n-            query.inputs = [val];\n-            query.output = val;\n-            query.search = val;\n-            // gather matching search results up to a certain maximum\n-            val = val.replace(/_/g, \"\");\n-\n-            var valGenerics = extractGenerics(val);\n-\n-            var paths = valLower.split(\"::\");\n-            removeEmptyStringsFromArray(paths);\n-            val = paths[paths.length - 1];\n-            var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n-\n-            var lev, j;\n-            for (j = 0; j < nSearchWords; ++j) {\n-                ty = searchIndex[j];\n-                if (!ty || (filterCrates !== null && ty.crate !== filterCrates)) {\n-                    continue;\n-                }\n-                var lev_add = 0;\n-                if (paths.length > 1) {\n-                    lev = checkPath(contains, paths[paths.length - 1], ty);\n-                    if (lev > MAX_LEV_DISTANCE) {\n-                        continue;\n-                    } else if (lev > 0) {\n-                        lev_add = lev / 10;\n-                    }\n-                }\n \n-                returned = MAX_LEV_DISTANCE + 1;\n-                in_args = MAX_LEV_DISTANCE + 1;\n-                var index = -1;\n-                // we want lev results to go lower than others\n-                lev = MAX_LEV_DISTANCE + 1;\n-                fullId = ty.id;\n+            if (nbLev === 0) {\n+                return;\n+            }\n+            lev = Math.round(totalLev / nbLev);\n+            addIntoResults(results, row.id, pos, 0, lev);\n+        }\n \n-                if (searchWords[j].indexOf(split[i]) > -1 ||\n-                    searchWords[j].indexOf(val) > -1 ||\n-                    ty.normalizedName.indexOf(val) > -1)\n-                {\n-                    // filter type: ... queries\n-                    if (typePassesFilter(typeFilter, ty.ty) && results[fullId] === undefined) {\n-                        index = ty.normalizedName.indexOf(val);\n+        function innerRunQuery() {\n+            var elem, i, nSearchWords, in_returned, row;\n+\n+            if (parsedQuery.foundElems === 1) {\n+                if (parsedQuery.elems.length === 1) {\n+                    elem = parsedQuery.elems[0];\n+                    for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                        // It means we want to check for this element everywhere (in names, args and\n+                        // returned).\n+                        handleSingleArg(\n+                            searchIndex[i],\n+                            i,\n+                            elem,\n+                            results_others,\n+                            results_in_args,\n+                            results_returned\n+                        );\n                     }\n-                }\n-                if ((lev = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                    if (typePassesFilter(typeFilter, ty.ty)) {\n-                        lev += 1;\n-                    } else {\n-                        lev = MAX_LEV_DISTANCE + 1;\n+                } else if (parsedQuery.returned.length === 1) {\n+                    // We received one returned argument to check, so looking into returned values.\n+                    elem = parsedQuery.returned[0];\n+                    for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                        row = searchIndex[i];\n+                        in_returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+                        addIntoResults(results_returned, row.id, i, -1, in_returned);\n                     }\n                 }\n-                in_args = findArg(ty, valGenerics, false, typeFilter);\n-                returned = checkReturned(ty, valGenerics, false, typeFilter);\n-\n-                lev += lev_add;\n-                if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {\n-                    if (val.length < 6) {\n-                        lev -= 1;\n-                    } else {\n-                        lev = 0;\n-                    }\n+            } else if (parsedQuery.foundElems > 0) {\n+                var container = results_others;\n+                // In the special case where only a \"returned\" information is available, we want to\n+                // put the information into the \"results_returned\" dict.\n+                if (parsedQuery.returned.length !== 0 && parsedQuery.elems.length === 0) {\n+                    container = results_returned;\n                 }\n-                addIntoResults(false, results_in_args, fullId, j, index, in_args);\n-                addIntoResults(false, results_returned, fullId, j, index, returned);\n-                if (typePassesFilter(typeFilter, ty.ty) &&\n-                        (index !== -1 || lev <= MAX_LEV_DISTANCE)) {\n-                    if (index !== -1 && paths.length < 2) {\n-                        lev = 0;\n-                    }\n-                    addIntoResults(false, results, fullId, j, index, lev);\n+                for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                    handleArgs(searchIndex[i], i, container);\n                 }\n             }\n         }\n \n-        var ret = {\n-            \"in_args\": sortResults(results_in_args, true),\n-            \"returned\": sortResults(results_returned, true),\n-            \"others\": sortResults(results, false),\n-        };\n-        handleAliases(ret, query, filterCrates);\n+        if (parsedQuery.error === null) {\n+            innerRunQuery();\n+        }\n+\n+        var ret = createQueryResults(\n+            sortResults(results_in_args, true),\n+            sortResults(results_returned, true),\n+            sortResults(results_others, false),\n+            parsedQuery);\n+        handleAliases(ret, parsedQuery.original.replace(/\"/g, \"\"), filterCrates);\n+        if (parsedQuery.error !== null && ret.others.length !== 0) {\n+            // It means some doc aliases were found so let's \"remove\" the error!\n+            ret.query.error = null;\n+        }\n         return ret;\n     }\n \n@@ -892,9 +1455,13 @@ window.initSearch = function(rawSearchIndex) {\n      * @param  {string} path   - The path of the result\n      * @param  {string} keys   - The keys to be used ([\"file\", \"open\"])\n      * @param  {Object} parent - The parent of the result\n+     *\n      * @return {boolean}       - Whether the result is valid or not\n      */\n     function validateResult(name, path, keys, parent) {\n+        if (!keys || !keys.length) {\n+            return true;\n+        }\n         for (var i = 0, len = keys.length; i < len; ++i) {\n             // each check is for validation so we negate the conditions and invalidate\n             if (!(\n@@ -913,30 +1480,6 @@ window.initSearch = function(rawSearchIndex) {\n         return true;\n     }\n \n-    /**\n-     * Parse a string into a query object.\n-     *\n-     * @param {string} raw - The text that the user typed.\n-     * @returns {ParsedQuery}\n-     */\n-    function getQuery(raw) {\n-        var matches, type = \"\", query;\n-        query = raw;\n-\n-        matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n-        if (matches) {\n-            type = matches[1].replace(/^const$/, \"constant\");\n-            query = query.substring(matches[0].length);\n-        }\n-\n-        return {\n-            raw: raw,\n-            query: query,\n-            type: type,\n-            id: query + type\n-        };\n-    }\n-\n     function nextTab(direction) {\n         var next = (searchState.currentTab + direction + 3) % searchState.focusedByTab.length;\n         searchState.focusedByTab[searchState.currentTab] = document.activeElement;\n@@ -1088,11 +1631,11 @@ window.initSearch = function(rawSearchIndex) {\n                 link.appendChild(wrapper);\n                 output.appendChild(link);\n             });\n-        } else {\n+        } else if (query.error === null) {\n             output.className = \"search-failed\" + extraClass;\n             output.innerHTML = \"No results :(<br/>\" +\n                 \"Try on <a href=\\\"https://duckduckgo.com/?q=\" +\n-                encodeURIComponent(\"rust \" + query.query) +\n+                encodeURIComponent(\"rust \" + query.userQuery) +\n                 \"\\\">DuckDuckGo</a>?<br/><br/>\" +\n                 \"Or try looking in one of these:<ul><li>The <a \" +\n                 \"href=\\\"https://doc.rust-lang.org/reference/index.html\\\">Rust Reference</a> \" +\n@@ -1115,6 +1658,11 @@ window.initSearch = function(rawSearchIndex) {\n         return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n     }\n \n+    /**\n+     * @param {ResultsTable} results\n+     * @param {boolean} go_to_first\n+     * @param {string} filterCrates\n+     */\n     function showResults(results, go_to_first, filterCrates) {\n         var search = searchState.outputElement();\n         if (go_to_first || (results.others.length === 1\n@@ -1132,13 +1680,15 @@ window.initSearch = function(rawSearchIndex) {\n             elem.click();\n             return;\n         }\n-        var query = getQuery(searchState.input.value);\n+        if (results.query === undefined) {\n+            results.query = parseQuery(searchState.input.value);\n+        }\n \n-        currentResults = query.id;\n+        currentResults = results.query.userQuery;\n \n-        var ret_others = addTab(results.others, query, true);\n-        var ret_in_args = addTab(results.in_args, query, false);\n-        var ret_returned = addTab(results.returned, query, false);\n+        var ret_others = addTab(results.others, results.query, true);\n+        var ret_in_args = addTab(results.in_args, results.query, false);\n+        var ret_returned = addTab(results.returned, results.query, false);\n \n         // Navigate to the relevant tab if the current tab is empty, like in case users search\n         // for \"-> String\". If they had selected another tab previously, they have to click on\n@@ -1164,11 +1714,19 @@ window.initSearch = function(rawSearchIndex) {\n             }\n             crates += `</select>`;\n         }\n-        var output = `<div id=\"search-settings\">\n-            <h1 class=\"search-results-title\">Results for ${escape(query.query)} ` +\n-            (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n-            crates +\n-            `</div><div id=\"titles\">` +\n+\n+        var typeFilter = \"\";\n+        if (results.query.typeFilter !== NO_TYPE_FILTER) {\n+            typeFilter = \" (type: \" + escape(itemTypes[results.query.typeFilter]) + \")\";\n+        }\n+\n+        var output = `<div id=\"search-settings\">` +\n+            `<h1 class=\"search-results-title\">Results for ${escape(results.query.userQuery)}` +\n+            `${typeFilter}</h1> in ${crates} </div>`;\n+        if (results.query.error !== null) {\n+            output += `<h3>Query parser error: \"${results.query.error}\".</h3>`;\n+        }\n+        output += `<div id=\"titles\">` +\n             makeTabHeader(0, \"In Names\", ret_others[1]) +\n             makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n             makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n@@ -1196,28 +1754,6 @@ window.initSearch = function(rawSearchIndex) {\n         printTab(currentTab);\n     }\n \n-    function execSearch(query, searchWords, filterCrates) {\n-        query = query.raw.trim();\n-        var results = {\n-            \"in_args\": [],\n-            \"returned\": [],\n-            \"others\": [],\n-        };\n-\n-        if (query.length !== 0) {\n-            var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n-\n-            results.in_args.push(tmp.in_args);\n-            results.returned.push(tmp.returned);\n-            results.others.push(tmp.others);\n-        }\n-        return {\n-            \"in_args\": results.in_args[0],\n-            \"returned\": results.returned[0],\n-            \"others\": results.others[0],\n-        };\n-    }\n-\n     /**\n      * Perform a search based on the current state of the search input element\n      * and display the results.\n@@ -1226,17 +1762,14 @@ window.initSearch = function(rawSearchIndex) {\n      */\n     function search(e, forced) {\n         var params = searchState.getQueryStringParams();\n-        var query = getQuery(searchState.input.value.trim());\n+        var query = parseQuery(searchState.input.value.trim());\n \n         if (e) {\n             e.preventDefault();\n         }\n \n-        if (query.query.length === 0) {\n-            return;\n-        }\n-        if (!forced && query.id === currentResults) {\n-            if (query.query.length > 0) {\n+        if (!forced && query.userQuery === currentResults) {\n+            if (query.userQuery.length > 0) {\n                 putBackSearch();\n             }\n             return;\n@@ -1251,22 +1784,23 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         // Update document title to maintain a meaningful browser history\n-        searchState.title = \"Results for \" + query.query + \" - Rust\";\n+        searchState.title = \"Results for \" + query.original + \" - Rust\";\n \n         // Because searching is incremental by character, only the most\n         // recent search query is added to the browser history.\n         if (searchState.browserSupportsHistoryApi()) {\n-            var newURL = buildUrl(query.raw, filterCrates);\n-\n+            var newURL = buildUrl(query.original, filterCrates);\n             if (!history.state && !params.search) {\n                 history.pushState(null, \"\", newURL);\n             } else {\n                 history.replaceState(null, \"\", newURL);\n             }\n         }\n \n-        showResults(execSearch(query, searchWords, filterCrates),\n-            params[\"go_to_first\"], filterCrates);\n+        showResults(\n+            execQuery(query, searchWords, filterCrates),\n+            params.go_to_first,\n+            filterCrates);\n     }\n \n     function buildIndex(rawSearchIndex) {"}, {"sha": "b47a1fefa41d00d7e8646c32bdf38d1016733914", "filename": "src/test/rustdoc-js-std/filter-crate.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Ffilter-crate.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Ffilter-crate.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Ffilter-crate.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -1,6 +1,6 @@\n // exact-check\n \n-const QUERY = 'hashmap';\n+const QUERY = '\"hashmap\"';\n const FILTER_CRATE = 'core';\n \n const EXPECTED = {"}, {"sha": "779ab867c12b1afc7adcf34a5418d2638bee889a", "filename": "src/test/rustdoc-js-std/parser-errors.js", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,365 @@\n+const QUERY = [\n+    '<P>',\n+    '-> <P>',\n+    'a<\"P\">',\n+    '\"P\" \"P\"',\n+    'P \"P\"',\n+    '\"p\" p',\n+    '\"const\": p',\n+    \"a<:a>\",\n+    \"a<::a>\",\n+    \"((a))\",\n+    \"(p -> p\",\n+    \"::a::b\",\n+    \"a::::b\",\n+    \"a::b::\",\n+    \":a\",\n+    \"a b:\",\n+    \"a (b:\",\n+    \"_:\",\n+    \"a-bb\",\n+    \"a>bb\",\n+    \"ab'\",\n+    \"a->\",\n+    '\"p\" <a>',\n+    '\"p\" a<a>',\n+    \"a,<\",\n+    \"aaaaa<>b\",\n+    \"fn:aaaaa<>b\",\n+    \"->a<>b\",\n+    \"a<->\",\n+    \"a:: a\",\n+    \"a ::a\",\n+    \"a<a>:\",\n+    \"a<>:\",\n+    \"a,:\",\n+    \"  a<>  :\",\n+    \"mod : :\",\n+];\n+\n+const PARSED = [\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"<P>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"<p>\",\n+        error: \"Found generics without a path\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"-> <P>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"-> <p>\",\n+        error: \"Found generics without a path\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a<\\\"P\\\">\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<\\\"p\\\">\",\n+        error: \"`\\\"` cannot be used in generics\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"\\\"P\\\" \\\"P\\\"\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"\\\"p\\\" \\\"p\\\"\",\n+        error: \"Cannot have more than one literal search element\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"P \\\"P\\\"\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"p \\\"p\\\"\",\n+        error: \"Cannot use literal search when there is more than one element\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"\\\"p\\\" p\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"\\\"p\\\" p\",\n+        error: \"You cannot have more than one element if you use quotes\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"\\\"const\\\": p\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"\\\"const\\\": p\",\n+        error: \"You cannot use quotes on type filter\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a<:a>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<:a>\",\n+        error: \"Unexpected `:` after `<`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a<::a>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<::a>\",\n+        error: \"Unexpected `::`: paths cannot start with `::`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"((a))\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"((a))\",\n+        error: \"Unexpected `(`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"(p -> p\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"(p -> p\",\n+        error: \"Unexpected `(`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"::a::b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"::a::b\",\n+        error: \"Paths cannot start with `::`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a::::b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a::::b\",\n+        error: \"Unexpected `::::`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a::b::\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a::b::\",\n+        error: \"Paths cannot end with `::`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \":a\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \":a\",\n+        error: \"Expected type filter before `:`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a b:\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a b:\",\n+        error: \"Unexpected `:`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a (b:\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a (b:\",\n+        error: \"Unexpected `(`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"_:\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"_:\",\n+        error: \"Unknown type filter `_`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a-bb\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a-bb\",\n+        error: \"Unexpected `-` (did you mean `->`?)\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a>bb\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a>bb\",\n+        error: \"Unexpected `>` (did you mean `->`?)\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"ab'\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"ab'\",\n+        error: \"Unexpected `'`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a->\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a->\",\n+        error: \"Expected at least one item after `->`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '\"p\" <a>',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"p\" <a>',\n+        error: \"Found generics without a path\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '\"p\" a<a>',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"p\" a<a>',\n+        error: \"You cannot have more than one element if you use quotes\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'a,<',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a,<',\n+        error: 'Found generics without a path',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'aaaaa<>b',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'aaaaa<>b',\n+        error: 'Expected `,`, ` `, `:` or `->`, found `b`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'fn:aaaaa<>b',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'fn:aaaaa<>b',\n+        error: 'Expected `,`, ` ` or `->`, found `b`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '->a<>b',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '->a<>b',\n+        error: 'Expected `,` or ` `, found `b`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'a<->',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a<->',\n+        error: 'Unexpected `-` after `<`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'a:: a',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a:: a',\n+        error: 'Paths cannot end with `::`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'a ::a',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a ::a',\n+        error: 'Paths cannot start with `::`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a<a>:\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<a>:\",\n+        error: 'Unexpected `:`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a<>:\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<>:\",\n+        error: 'Unexpected `<` in type filter',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a,:\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a,:\",\n+        error: 'Unexpected `,` in type filter',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a<>  :\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<>  :\",\n+        error: 'Unexpected `<` in type filter',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"mod : :\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"mod : :\",\n+        error: 'Unexpected `:`',\n+    },\n+];"}, {"sha": "e5a87a415ac476e8bdf59920435f7550627ff172", "filename": "src/test/rustdoc-js-std/parser-filter.js", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-filter.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-filter.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-filter.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,43 @@\n+const QUERY = ['fn:foo', 'enum : foo', 'macro<f>:foo'];\n+\n+const PARSED = [\n+    {\n+        elems: [{\n+            name: \"foo\",\n+            fullPath: [\"foo\"],\n+            pathWithoutLast: [],\n+            pathLast: \"foo\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"fn:foo\",\n+        returned: [],\n+        typeFilter: 5,\n+        userQuery: \"fn:foo\",\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"foo\",\n+            fullPath: [\"foo\"],\n+            pathWithoutLast: [],\n+            pathLast: \"foo\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"enum : foo\",\n+        returned: [],\n+        typeFilter: 4,\n+        userQuery: \"enum : foo\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"macro<f>:foo\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"macro<f>:foo\",\n+        error: \"Unexpected `:`\",\n+    },\n+];"}, {"sha": "0cf7f5019aa5f2053b8dd4e3168bae7caf539a28", "filename": "src/test/rustdoc-js-std/parser-generics.js", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-generics.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-generics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-generics.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,62 @@\n+const QUERY = ['A<B<C<D>,  E>', 'p<> u8', '\"p\"<a>'];\n+\n+const PARSED = [\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'A<B<C<D>,  E>',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a<b<c<d>,  e>',\n+        error: 'Unexpected `<` after `<`',\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"p\",\n+                fullPath: [\"p\"],\n+                pathWithoutLast: [],\n+                pathLast: \"p\",\n+                generics: [],\n+            },\n+            {\n+                name: \"u8\",\n+                fullPath: [\"u8\"],\n+                pathWithoutLast: [],\n+                pathLast: \"u8\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"p<> u8\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"p<> u8\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"p\",\n+                fullPath: [\"p\"],\n+                pathWithoutLast: [],\n+                pathLast: \"p\",\n+                generics: [\n+                    {\n+                        name: \"a\",\n+                        fullPath: [\"a\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"a\",\n+                        generics: [],\n+                    },\n+                ],\n+            },\n+        ],\n+        foundElems: 1,\n+        original: '\"p\"<a>',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"p\"<a>',\n+        error: null,\n+    },\n+];"}, {"sha": "87b3baff1e2a4bcdedf0ddfab5d82f44bdfac641", "filename": "src/test/rustdoc-js-std/parser-literal.js", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-literal.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-literal.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-literal.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,27 @@\n+const QUERY = ['R<P>'];\n+\n+const PARSED = [\n+    {\n+        elems: [{\n+            name: \"r\",\n+            fullPath: [\"r\"],\n+            pathWithoutLast: [],\n+            pathLast: \"r\",\n+            generics: [\n+                {\n+                    name: \"p\",\n+                    fullPath: [\"p\"],\n+                    pathWithoutLast: [],\n+                    pathLast: \"p\",\n+                    generics: [],\n+                },\n+            ],\n+        }],\n+        foundElems: 1,\n+        original: \"R<P>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"r<p>\",\n+        error: null,\n+    }\n+];"}, {"sha": "9f823f9336a888a21c9450870fa22ec4183bf5c4", "filename": "src/test/rustdoc-js-std/parser-paths.js", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-paths.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-paths.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-paths.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,90 @@\n+const QUERY = ['A::B', 'A::B,C',  'A::B<f>,C', 'mod::a'];\n+\n+const PARSED = [\n+    {\n+        elems: [{\n+            name: \"a::b\",\n+            fullPath: [\"a\", \"b\"],\n+            pathWithoutLast: [\"a\"],\n+            pathLast: \"b\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"A::B\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a::b\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"a::b\",\n+                fullPath: [\"a\", \"b\"],\n+                pathWithoutLast: [\"a\"],\n+                pathLast: \"b\",\n+                generics: [],\n+            },\n+            {\n+                name: \"c\",\n+                fullPath: [\"c\"],\n+                pathWithoutLast: [],\n+                pathLast: \"c\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: 'A::B,C',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a::b,c',\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"a::b\",\n+                fullPath: [\"a\", \"b\"],\n+                pathWithoutLast: [\"a\"],\n+                pathLast: \"b\",\n+                generics: [\n+                    {\n+                        name: \"f\",\n+                        fullPath: [\"f\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"f\",\n+                        generics: [],\n+                    },\n+                ],\n+            },\n+            {\n+                name: \"c\",\n+                fullPath: [\"c\"],\n+                pathWithoutLast: [],\n+                pathLast: \"c\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: 'A::B<f>,C',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: 'a::b<f>,c',\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"mod::a\",\n+            fullPath: [\"mod\", \"a\"],\n+            pathWithoutLast: [\"mod\"],\n+            pathLast: \"a\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: \"mod::a\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"mod::a\",\n+        error: null,\n+    },\n+];"}, {"sha": "1e16c90de5ea2fc554c089188534dff686662744", "filename": "src/test/rustdoc-js-std/parser-quote.js", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-quote.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-quote.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-quote.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,87 @@\n+const QUERY = [\n+    '-> \"p\"',\n+    '\"p\",',\n+    '\"p\" -> a',\n+    '\"a\" -> \"p\"',\n+    '->\"-\"',\n+    '\"a',\n+    '\"\"',\n+];\n+\n+const PARSED = [\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: '-> \"p\"',\n+        returned: [{\n+            name: \"p\",\n+            fullPath: [\"p\"],\n+            pathWithoutLast: [],\n+            pathLast: \"p\",\n+            generics: [],\n+        }],\n+        typeFilter: -1,\n+        userQuery: '-> \"p\"',\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"p\",\n+            fullPath: [\"p\"],\n+            pathWithoutLast: [],\n+            pathLast: \"p\",\n+            generics: [],\n+        }],\n+        foundElems: 1,\n+        original: '\"p\",',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"p\",',\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '\"p\" -> a',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"p\" -> a',\n+        error: \"You cannot have more than one element if you use quotes\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '\"a\" -> \"p\"',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"a\" -> \"p\"',\n+        error: \"Cannot have more than one literal search element\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '->\"-\"',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '->\"-\"',\n+        error: 'Unexpected `-` in a string element',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '\"a',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"a',\n+        error: 'Unclosed `\"`',\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '\"\"',\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: '\"\"',\n+        error: 'Cannot have empty string element',\n+    },\n+];"}, {"sha": "b45466aa940a46938e7d52305676f6f73cebdab3", "filename": "src/test/rustdoc-js-std/parser-returned.js", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,78 @@\n+const QUERY = ['-> F<P>', '-> P', '->,a', 'aaaaa->a'];\n+\n+const PARSED = [\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"-> F<P>\",\n+        returned: [{\n+            name: \"f\",\n+            fullPath: [\"f\"],\n+            pathWithoutLast: [],\n+            pathLast: \"f\",\n+            generics: [\n+                {\n+                    name: \"p\",\n+                    fullPath: [\"p\"],\n+                    pathWithoutLast: [],\n+                    pathLast: \"p\",\n+                    generics: [],\n+                },\n+            ],\n+        }],\n+        typeFilter: -1,\n+        userQuery: \"-> f<p>\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"-> P\",\n+        returned: [{\n+            name: \"p\",\n+            fullPath: [\"p\"],\n+            pathWithoutLast: [],\n+            pathLast: \"p\",\n+            generics: [],\n+        }],\n+        typeFilter: -1,\n+        userQuery: \"-> p\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 1,\n+        original: \"->,a\",\n+        returned: [{\n+            name: \"a\",\n+            fullPath: [\"a\"],\n+            pathWithoutLast: [],\n+            pathLast: \"a\",\n+            generics: [],\n+        }],\n+        typeFilter: -1,\n+        userQuery: \"->,a\",\n+        error: null,\n+    },\n+    {\n+        elems: [{\n+            name: \"aaaaa\",\n+            fullPath: [\"aaaaa\"],\n+            pathWithoutLast: [],\n+            pathLast: \"aaaaa\",\n+            generics: [],\n+        }],\n+        foundElems: 2,\n+        original: \"aaaaa->a\",\n+        returned: [{\n+            name: \"a\",\n+            fullPath: [\"a\"],\n+            pathWithoutLast: [],\n+            pathLast: \"a\",\n+            generics: [],\n+        }],\n+        typeFilter: -1,\n+        userQuery: \"aaaaa->a\",\n+        error: null,\n+    },\n+];"}, {"sha": "5b7abdfa8d684ce2ab1faa579dc571368a82f92b", "filename": "src/test/rustdoc-js-std/parser-separators.js", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-separators.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-separators.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-separators.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,206 @@\n+// ignore-tidy-tab\n+\n+const QUERY = [\n+    'aaaaaa\tb',\n+    'a b',\n+    'a,b',\n+    'a\\tb',\n+    'a<b c>',\n+    'a<b,c>',\n+    'a<b\\tc>',\n+];\n+\n+const PARSED = [\n+    {\n+        elems: [\n+            {\n+                name: 'aaaaaa',\n+                fullPath: ['aaaaaa'],\n+                pathWithoutLast: [],\n+                pathLast: 'aaaaaa',\n+                generics: [],\n+            },\n+            {\n+                name: 'b',\n+                fullPath: ['b'],\n+                pathWithoutLast: [],\n+                pathLast: 'b',\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"aaaaaa\tb\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"aaaaaa\tb\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: 'a',\n+                fullPath: ['a'],\n+                pathWithoutLast: [],\n+                pathLast: 'a',\n+                generics: [],\n+            },\n+            {\n+                name: 'b',\n+                fullPath: ['b'],\n+                pathWithoutLast: [],\n+                pathLast: 'b',\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"a b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a b\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: 'a',\n+                fullPath: ['a'],\n+                pathWithoutLast: [],\n+                pathLast: 'a',\n+                generics: [],\n+            },\n+            {\n+                name: 'b',\n+                fullPath: ['b'],\n+                pathWithoutLast: [],\n+                pathLast: 'b',\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"a,b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a,b\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: 'a',\n+                fullPath: ['a'],\n+                pathWithoutLast: [],\n+                pathLast: 'a',\n+                generics: [],\n+            },\n+            {\n+                name: 'b',\n+                fullPath: ['b'],\n+                pathWithoutLast: [],\n+                pathLast: 'b',\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"a\\tb\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a\\tb\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: 'a',\n+                fullPath: ['a'],\n+                pathWithoutLast: [],\n+                pathLast: 'a',\n+                generics: [\n+                    {\n+                        name: 'b',\n+                        fullPath: ['b'],\n+                        pathWithoutLast: [],\n+                        pathLast: 'b',\n+                        generics: [],\n+                    },\n+                    {\n+                        name: 'c',\n+                        fullPath: ['c'],\n+                        pathWithoutLast: [],\n+                        pathLast: 'c',\n+                        generics: [],\n+                    },\n+                ],\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"a<b c>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<b c>\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: 'a',\n+                fullPath: ['a'],\n+                pathWithoutLast: [],\n+                pathLast: 'a',\n+                generics: [\n+                    {\n+                        name: 'b',\n+                        fullPath: ['b'],\n+                        pathWithoutLast: [],\n+                        pathLast: 'b',\n+                        generics: [],\n+                    },\n+                    {\n+                        name: 'c',\n+                        fullPath: ['c'],\n+                        pathWithoutLast: [],\n+                        pathLast: 'c',\n+                        generics: [],\n+                    },\n+                ],\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"a<b,c>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<b,c>\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: 'a',\n+                fullPath: ['a'],\n+                pathWithoutLast: [],\n+                pathLast: 'a',\n+                generics: [\n+                    {\n+                        name: 'b',\n+                        fullPath: ['b'],\n+                        pathWithoutLast: [],\n+                        pathLast: 'b',\n+                        generics: [],\n+                    },\n+                    {\n+                        name: 'c',\n+                        fullPath: ['c'],\n+                        pathWithoutLast: [],\n+                        pathLast: 'c',\n+                        generics: [],\n+                    },\n+                ],\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"a<b\\tc>\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a<b\\tc>\",\n+        error: null,\n+    },\n+];"}, {"sha": "a3d85aeca5e0015a45117beb91c871e91606a7ea", "filename": "src/test/rustdoc-js-std/parser-weird-queries.js", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-weird-queries.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fparser-weird-queries.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-weird-queries.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -0,0 +1,123 @@\n+// This test is mostly to check that the parser still kinda outputs something\n+// (and doesn't enter an infinite loop!) even though the query is completely\n+// invalid.\n+const QUERY = [\n+    'a b',\n+    'a   b',\n+    'a,b(c)',\n+    'aaa,a',\n+    ',,,,',\n+    'mod    :',\n+    'mod\\t:',\n+];\n+\n+const PARSED = [\n+    {\n+        elems: [\n+            {\n+                name: \"a\",\n+                fullPath: [\"a\"],\n+                pathWithoutLast: [],\n+                pathLast: \"a\",\n+                generics: [],\n+            },\n+            {\n+                name: \"b\",\n+                fullPath: [\"b\"],\n+                pathWithoutLast: [],\n+                pathLast: \"b\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"a b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a b\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"a\",\n+                fullPath: [\"a\"],\n+                pathWithoutLast: [],\n+                pathLast: \"a\",\n+                generics: [],\n+            },\n+            {\n+                name: \"b\",\n+                fullPath: [\"b\"],\n+                pathWithoutLast: [],\n+                pathLast: \"b\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"a   b\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a   b\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"a,b(c)\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"a,b(c)\",\n+        error: \"Unexpected `(`\",\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"aaa\",\n+                fullPath: [\"aaa\"],\n+                pathWithoutLast: [],\n+                pathLast: \"aaa\",\n+                generics: [],\n+            },\n+            {\n+                name: \"a\",\n+                fullPath: [\"a\"],\n+                pathWithoutLast: [],\n+                pathLast: \"a\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"aaa,a\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"aaa,a\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \",,,,\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \",,,,\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'mod    :',\n+        returned: [],\n+        typeFilter: 0,\n+        userQuery: 'mod    :',\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: 'mod\\t:',\n+        returned: [],\n+        typeFilter: 0,\n+        userQuery: 'mod\\t:',\n+        error: null,\n+    },\n+];"}, {"sha": "aec8484a41f6dcb6e27ad2cee6a0247163bdc4d3", "filename": "src/test/rustdoc-js-std/quoted.js", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fquoted.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fquoted.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fquoted.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -1,12 +1,20 @@\n+// ignore-order\n+\n const QUERY = '\"error\"';\n+const FILTER_CRATE = 'std';\n \n const EXPECTED = {\n     'others': [\n         { 'path': 'std', 'name': 'error' },\n         { 'path': 'std::fmt', 'name': 'Error' },\n         { 'path': 'std::io', 'name': 'Error' },\n     ],\n-    'in_args': [],\n+    'in_args': [\n+        { 'path': 'std::fmt::Error', 'name': 'eq' },\n+        { 'path': 'std::fmt::Error', 'name': 'cmp' },\n+        { 'path': 'std::fmt::Error', 'name': 'partial_cmp' },\n+\n+    ],\n     'returned': [\n         { 'path': 'std::fmt::LowerExp', 'name': 'fmt' },\n     ],"}, {"sha": "29609904b1957a52f893b9de8f097f796d399a49", "filename": "src/test/rustdoc-js-std/struct-vec.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fstruct-vec.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fstruct-vec.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fstruct-vec.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -1,8 +1,8 @@\n-const QUERY = 'struct:Vec';\n+const QUERY = 'struct:VecD';\n \n const EXPECTED = {\n     'others': [\n-        { 'path': 'std::vec', 'name': 'Vec' },\n         { 'path': 'std::collections', 'name': 'VecDeque' },\n+        { 'path': 'std::vec', 'name': 'Vec' },\n     ],\n };"}, {"sha": "25efbad26954003233d959692152f34888221bd7", "filename": "src/test/rustdoc-js-std/typed-query.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Ftyped-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Ftyped-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Ftyped-query.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -1,6 +1,7 @@\n // exact-check\n \n const QUERY = 'macro:print';\n+const FILTER_CRATE = 'std';\n \n const EXPECTED = {\n     'others': [\n@@ -9,6 +10,8 @@ const EXPECTED = {\n         { 'path': 'std', 'name': 'println' },\n         { 'path': 'std', 'name': 'eprintln' },\n         { 'path': 'std::pin', 'name': 'pin' },\n-        { 'path': 'core::pin', 'name': 'pin' },\n+        { 'path': 'std::future', 'name': 'join' },\n+        { 'path': 'std', 'name': 'line' },\n+        { 'path': 'std', 'name': 'write' },\n     ],\n };"}, {"sha": "cd0e8e7b4a9eb41524adbb55fc8d9c931a8d20d4", "filename": "src/test/rustdoc-js-std/vec-new.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -4,6 +4,6 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'std::vec::Vec', 'name': 'new' },\n         { 'path': 'std::vec::Vec', 'name': 'ne' },\n-        { 'path': 'std::rc::Rc', 'name': 'ne' },\n+        { 'path': 'alloc::vec::Vec', 'name': 'ne' },\n     ],\n };"}, {"sha": "e06047ba7606e78b8de5591ec8ecbbda03993a9d", "filename": "src/test/rustdoc-js/doc-alias-filter.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -1,6 +1,6 @@\n // exact-check\n \n-const QUERY = 'true';\n+const QUERY = '\"true\"';\n \n const FILTER_CRATE = 'doc_alias_filter';\n "}, {"sha": "7bb0cbe388fee1c8d7626b2d4aa74edd9ac80d10", "filename": "src/test/rustdoc-js/doc-alias.js", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -27,6 +27,7 @@ const QUERY = [\n \n const EXPECTED = [\n     {\n+        // StructItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -38,6 +39,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // StructFieldItem\n         'others': [\n             {\n                 'path': 'doc_alias::Struct',\n@@ -49,6 +51,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // StructMethodItem\n         'others': [\n             {\n                 'path': 'doc_alias::Struct',\n@@ -76,6 +79,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // ImplTraitFunction\n         'others': [\n             {\n                 'path': 'doc_alias::Struct',\n@@ -87,6 +91,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // EnumItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -98,6 +103,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // VariantItem\n         'others': [\n             {\n                 'path': 'doc_alias::Enum',\n@@ -109,6 +115,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // EnumMethodItem\n         'others': [\n             {\n                 'path': 'doc_alias::Enum',\n@@ -120,6 +127,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // TypedefItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -131,6 +139,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // TraitItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -142,6 +151,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // TraitTypeItem\n         'others': [\n             {\n                 'path': 'doc_alias::Trait',\n@@ -153,6 +163,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // AssociatedConstItem\n         'others': [\n             {\n                 'path': 'doc_alias::Trait',\n@@ -164,6 +175,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // TraitFunctionItem\n         'others': [\n             {\n                 'path': 'doc_alias::Trait',\n@@ -175,6 +187,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // FunctionItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -186,6 +199,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // ModuleItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -197,6 +211,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // ConstItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -212,6 +227,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // StaticItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -223,6 +239,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // UnionItem\n         'others': [\n             {\n                 'path': 'doc_alias',\n@@ -240,6 +257,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // UnionFieldItem\n         'others': [\n             {\n                 'path': 'doc_alias::Union',\n@@ -251,6 +269,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // UnionMethodItem\n         'others': [\n             {\n                 'path': 'doc_alias::Union',\n@@ -262,6 +281,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // MacroItem\n         'others': [\n             {\n                 'path': 'doc_alias',"}, {"sha": "5e5ba7cd9ac8f55c35c4525e182390592ae6c335", "filename": "src/test/rustdoc-js/generics.js", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fgenerics.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fgenerics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -1,16 +1,18 @@\n // exact-check\n \n const QUERY = [\n-    '\"R<P>\"',\n+    'R<P>',\n     '\"P\"',\n     'P',\n-    '\"ExtraCreditStructMulti<ExtraCreditInnerMulti, ExtraCreditInnerMulti>\"',\n+    'ExtraCreditStructMulti<ExtraCreditInnerMulti, ExtraCreditInnerMulti>',\n     'TraitCat',\n     'TraitDog',\n+    'Result<String>',\n ];\n \n const EXPECTED = [\n     {\n+        // R<P>\n         'returned': [\n             { 'path': 'generics', 'name': 'alef' },\n         ],\n@@ -19,6 +21,7 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // \"P\"\n         'others': [\n             { 'path': 'generics', 'name': 'P' },\n         ],\n@@ -30,29 +33,41 @@ const EXPECTED = [\n         ],\n     },\n     {\n+        // P\n         'returned': [\n             { 'path': 'generics', 'name': 'alef' },\n-            { 'path': 'generics', 'name': 'bet' },\n         ],\n         'in_args': [\n             { 'path': 'generics', 'name': 'alpha' },\n-            { 'path': 'generics', 'name': 'beta' },\n         ],\n     },\n     {\n+        // \"ExtraCreditStructMulti\"<ExtraCreditInnerMulti, ExtraCreditInnerMulti>\n         'in_args': [\n             { 'path': 'generics', 'name': 'extracreditlabhomework' },\n         ],\n         'returned': [],\n     },\n     {\n+        // TraitCat\n         'in_args': [\n             { 'path': 'generics', 'name': 'gamma' },\n         ],\n     },\n     {\n+        // TraitDog\n         'in_args': [\n             { 'path': 'generics', 'name': 'gamma' },\n         ],\n     },\n+    {\n+        // Result<String>\n+        'others': [],\n+        'returned': [\n+            { 'path': 'generics', 'name': 'super_soup' },\n+        ],\n+        'in_args': [\n+            { 'path': 'generics', 'name': 'super_soup' },\n+        ],\n+    },\n ];"}, {"sha": "055c51c7ec5781f819196bbf9e1907b5ff61194b", "filename": "src/test/rustdoc-js/generics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftest%2Frustdoc-js%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics.rs?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -24,3 +24,5 @@ pub trait TraitCat {}\n pub trait TraitDog {}\n \n pub fn gamma<T: TraitCat + TraitDog>(t: T) {}\n+\n+pub fn super_soup(s: Result<String, i32>) -> Result<String, i32> { s }"}, {"sha": "1736233835529a260525228f3dab6411be275fc5", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 149, "deletions": 21, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/976c6b2d193148ca9df3a505e55c5ba5da22cd96/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=976c6b2d193148ca9df3a505e55c5ba5da22cd96", "patch": "@@ -58,7 +58,8 @@ function extractFunction(content, functionName) {\n                 } while (pos < content.length && content[pos] !== '/' && content[pos - 1] !== '*');\n \n             // Eat quoted strings\n-            } else if (content[pos] === '\"' || content[pos] === \"'\" || content[pos] === \"`\") {\n+            } else if ((content[pos] === '\"' || content[pos] === \"'\" || content[pos] === \"`\") &&\n+                       (pos === 0 || content[pos - 1] !== '/')) {\n                 stop = content[pos];\n                 do {\n                     if (content[pos] === '\\\\') {\n@@ -269,8 +270,13 @@ function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n     // execQuery last parameter is built in buildIndex.\n     // buildIndex requires the hashmap from search-index.\n     var functionsToLoad = [\"buildHrefAndPath\", \"pathSplitter\", \"levenshtein\", \"validateResult\",\n-                           \"handleAliases\", \"getQuery\", \"buildIndex\", \"execQuery\", \"execSearch\",\n-                           \"removeEmptyStringsFromArray\"];\n+                           \"buildIndex\", \"execQuery\", \"parseQuery\", \"createQueryResults\",\n+                           \"isWhitespace\", \"isSpecialStartCharacter\", \"isStopCharacter\",\n+                           \"parseInput\", \"getItemsBefore\", \"getNextElem\", \"createQueryElement\",\n+                           \"isReturnArrow\", \"isPathStart\", \"getStringElem\", \"newParsedQuery\",\n+                           \"itemTypeFromName\", \"isEndCharacter\", \"isErrorCharacter\",\n+                           \"isIdentCharacter\", \"isSeparatorCharacter\", \"getIdentEndPosition\",\n+                           \"checkExtraTypeFilterCharacters\", \"isWhitespaceCharacter\"];\n \n     const functions = [\"hasOwnPropertyRustdoc\", \"onEach\"];\n     ALIASES = {};\n@@ -286,12 +292,99 @@ function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n     return [loaded, index];\n }\n \n+// This function checks if `expected` has all the required fields needed for the checks.\n+function checkNeededFields(fullPath, expected, error_text, queryName, position) {\n+    let fieldsToCheck;\n+    if (fullPath.length === 0) {\n+        fieldsToCheck = [\n+            \"foundElems\",\n+            \"original\",\n+            \"returned\",\n+            \"typeFilter\",\n+            \"userQuery\",\n+            \"error\",\n+        ];\n+    } else if (fullPath.endsWith(\"elems\") || fullPath.endsWith(\"generics\")) {\n+        fieldsToCheck = [\n+            \"name\",\n+            \"fullPath\",\n+            \"pathWithoutLast\",\n+            \"pathLast\",\n+            \"generics\",\n+        ];\n+    } else {\n+        fieldsToCheck = [];\n+    }\n+    for (var i = 0; i < fieldsToCheck.length; ++i) {\n+        const field = fieldsToCheck[i];\n+        if (!expected.hasOwnProperty(field)) {\n+            let text = `${queryName}==> Mandatory key \\`${field}\\` is not present`;\n+            if (fullPath.length > 0) {\n+                text += ` in field \\`${fullPath}\\``;\n+                if (position != null) {\n+                    text += ` (position ${position})`;\n+                }\n+            }\n+            error_text.push(text);\n+        }\n+    }\n+}\n+\n+function valueCheck(fullPath, expected, result, error_text, queryName) {\n+    if (Array.isArray(expected)) {\n+        for (var i = 0; i < expected.length; ++i) {\n+            checkNeededFields(fullPath, expected[i], error_text, queryName, i);\n+            if (i >= result.length) {\n+                error_text.push(`${queryName}==> EXPECTED has extra value in array from field ` +\n+                    `\\`${fullPath}\\` (position ${i}): \\`${JSON.stringify(expected[i])}\\``);\n+            } else {\n+                valueCheck(fullPath + '[' + i + ']', expected[i], result[i], error_text, queryName);\n+            }\n+        }\n+        for (; i < result.length; ++i) {\n+            error_text.push(`${queryName}==> RESULT has extra value in array from field ` +\n+                `\\`${fullPath}\\` (position ${i}): \\`${JSON.stringify(result[i])}\\` ` +\n+                'compared to EXPECTED');\n+        }\n+    } else if (expected !== null && typeof expected !== \"undefined\" &&\n+               expected.constructor == Object)\n+    {\n+        for (const key in expected) {\n+            if (!expected.hasOwnProperty(key)) {\n+                continue;\n+            }\n+            if (!result.hasOwnProperty(key)) {\n+                error_text.push('==> Unknown key \"' + key + '\"');\n+                break;\n+            }\n+            const obj_path = fullPath + (fullPath.length > 0 ? '.' : '') + key;\n+            valueCheck(obj_path, expected[key], result[key], error_text, queryName);\n+        }\n+    } else {\n+        expectedValue = JSON.stringify(expected);\n+        resultValue = JSON.stringify(result);\n+        if (expectedValue != resultValue) {\n+            error_text.push(`${queryName}==> Different values for field \\`${fullPath}\\`:\\n` +\n+                `EXPECTED: \\`${expectedValue}\\`\\nRESULT:   \\`${resultValue}\\``);\n+        }\n+    }\n+}\n+\n+function runParser(query, expected, loaded, loadedFile, queryName) {\n+    var error_text = [];\n+    checkNeededFields(\"\", expected, error_text, queryName, null);\n+    if (error_text.length === 0) {\n+        valueCheck('', expected, loaded.parseQuery(query), error_text, queryName);\n+    }\n+    return error_text;\n+}\n+\n function runSearch(query, expected, index, loaded, loadedFile, queryName) {\n     const filter_crate = loadedFile.FILTER_CRATE;\n     const ignore_order = loadedFile.ignore_order;\n     const exact_check = loadedFile.exact_check;\n \n-    var results = loaded.execSearch(loaded.getQuery(query), index, filter_crate);\n+    var results = loaded.execQuery(loaded.parseQuery(query), index, filter_crate);\n     var error_text = [];\n \n     for (var key in expected) {\n@@ -353,40 +446,75 @@ function checkResult(error_text, loadedFile, displaySuccess) {\n     return 1;\n }\n \n-function runChecks(testFile, loaded, index) {\n-    var testFileContent = readFile(testFile) + 'exports.QUERY = QUERY;exports.EXPECTED = EXPECTED;';\n-    if (testFileContent.indexOf(\"FILTER_CRATE\") !== -1) {\n-        testFileContent += \"exports.FILTER_CRATE = FILTER_CRATE;\";\n-    } else {\n-        testFileContent += \"exports.FILTER_CRATE = null;\";\n-    }\n-    var loadedFile = loadContent(testFileContent);\n-\n-    const expected = loadedFile.EXPECTED;\n+function runCheck(loadedFile, key, callback) {\n+    const expected = loadedFile[key];\n     const query = loadedFile.QUERY;\n \n     if (Array.isArray(query)) {\n         if (!Array.isArray(expected)) {\n             console.log(\"FAILED\");\n-            console.log(\"==> If QUERY variable is an array, EXPECTED should be an array too\");\n+            console.log(`==> If QUERY variable is an array, ${key} should be an array too`);\n             return 1;\n         } else if (query.length !== expected.length) {\n             console.log(\"FAILED\");\n-            console.log(\"==> QUERY variable should have the same length as EXPECTED\");\n+            console.log(`==> QUERY variable should have the same length as ${key}`);\n             return 1;\n         }\n         for (var i = 0; i < query.length; ++i) {\n-            var error_text = runSearch(query[i], expected[i], index, loaded, loadedFile,\n-                \"[ query `\" + query[i] + \"`]\");\n+            var error_text = callback(query[i], expected[i], \"[ query `\" + query[i] + \"`]\");\n             if (checkResult(error_text, loadedFile, false) !== 0) {\n                 return 1;\n             }\n         }\n         console.log(\"OK\");\n-        return 0;\n+    } else {\n+        var error_text = callback(query, expected, \"\");\n+        if (checkResult(error_text, loadedFile, true) !== 0) {\n+            return 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+function runChecks(testFile, loaded, index) {\n+    var checkExpected = false;\n+    var checkParsed = false;\n+    var testFileContent = readFile(testFile) + 'exports.QUERY = QUERY;';\n+\n+    if (testFileContent.indexOf(\"FILTER_CRATE\") !== -1) {\n+        testFileContent += \"exports.FILTER_CRATE = FILTER_CRATE;\";\n+    } else {\n+        testFileContent += \"exports.FILTER_CRATE = null;\";\n+    }\n+\n+    if (testFileContent.indexOf(\"\\nconst EXPECTED\") !== -1) {\n+        testFileContent += 'exports.EXPECTED = EXPECTED;';\n+        checkExpected = true;\n+    }\n+    if (testFileContent.indexOf(\"\\nconst PARSED\") !== -1) {\n+        testFileContent += 'exports.PARSED = PARSED;';\n+        checkParsed = true;\n+    }\n+    if (!checkParsed && !checkExpected) {\n+        console.log(\"FAILED\");\n+        console.log(\"==> At least `PARSED` or `EXPECTED` is needed!\");\n+        return 1;\n+    }\n+\n+    const loadedFile = loadContent(testFileContent);\n+    var res = 0;\n+\n+    if (checkExpected) {\n+        res += runCheck(loadedFile, \"EXPECTED\", (query, expected, text) => {\n+            return runSearch(query, expected, index, loaded, loadedFile, text);\n+        });\n+    }\n+    if (checkParsed) {\n+        res += runCheck(loadedFile, \"PARSED\", (query, expected, text) => {\n+            return runParser(query, expected, loaded, loadedFile, text);\n+        });\n     }\n-    var error_text = runSearch(query, expected, index, loaded, loadedFile, \"\");\n-    return checkResult(error_text, loadedFile, true);\n+    return res;\n }\n \n function load_files(doc_folder, resource_suffix, crate) {"}]}