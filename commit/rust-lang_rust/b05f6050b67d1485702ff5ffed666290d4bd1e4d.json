{"sha": "b05f6050b67d1485702ff5ffed666290d4bd1e4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNWY2MDUwYjY3ZDE0ODU3MDJmZjVmZmVkNjY2MjkwZDRiZDFlNGQ=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-20T12:32:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-21T16:54:31Z"}, "message": "Document BitvSet.", "tree": {"sha": "c133b0ae8c899400acb091ffb87b9341da90ef16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c133b0ae8c899400acb091ffb87b9341da90ef16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b05f6050b67d1485702ff5ffed666290d4bd1e4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b05f6050b67d1485702ff5ffed666290d4bd1e4d", "html_url": "https://github.com/rust-lang/rust/commit/b05f6050b67d1485702ff5ffed666290d4bd1e4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b05f6050b67d1485702ff5ffed666290d4bd1e4d/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "681aa582142abb0d74e20fc90ff93152acd2a006", "url": "https://api.github.com/repos/rust-lang/rust/commits/681aa582142abb0d74e20fc90ff93152acd2a006", "html_url": "https://github.com/rust-lang/rust/commit/681aa582142abb0d74e20fc90ff93152acd2a006"}], "stats": {"total": 316, "additions": 297, "deletions": 19}, "files": [{"sha": "ce1683ea879cbaeaf317edb12833a403e23c07ad", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 297, "deletions": 19, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/b05f6050b67d1485702ff5ffed666290d4bd1e4d/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05f6050b67d1485702ff5ffed666290d4bd1e4d/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=b05f6050b67d1485702ff5ffed666290d4bd1e4d", "patch": "@@ -839,11 +839,45 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n }\n \n /// An implementation of a set using a bit vector as an underlying\n-/// representation for holding numerical elements.\n+/// representation for holding unsigned numerical elements.\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n /// as a `uint`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::{BitvSet, Bitv};\n+/// use std::collections::bitv::from_bytes;\n+///\n+/// // It's a regular set\n+/// let mut s = BitvSet::new();\n+/// s.insert(0);\n+/// s.insert(3);\n+/// s.insert(7);\n+///\n+/// s.remove(&7);\n+///\n+/// if !s.contains(&7) {\n+///     println!(\"There is no 7\");\n+/// }\n+///\n+/// // Can initialize from a `Bitv`\n+/// let other = BitvSet::from_bitv(from_bytes([0b11010000]));\n+///\n+/// s.union_with(&other);\n+///\n+/// // Print 0, 1, 3 in some order\n+/// for x in s.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // Can convert back to a `Bitv`\n+/// let bv: Bitv = s.unwrap();\n+/// assert!(bv.eq_vec([true, true, false, true,\n+///                    false, false, false, false]));\n+/// ```\n #[deriving(Clone, PartialEq, Eq)]\n pub struct BitvSet(Bitv);\n \n@@ -853,54 +887,143 @@ impl Default for BitvSet {\n }\n \n impl BitvSet {\n-    /// Creates a new bit vector set with initially no contents\n+    /// Create a new bit vector set with initially no contents.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// let mut s = BitvSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> BitvSet {\n         BitvSet(Bitv::new())\n     }\n \n-    /// Creates a new bit vector set with initially no contents, able to\n-    /// hold `nbits` elements without resizing\n+    /// Create a new bit vector set with initially no contents, able to\n+    /// hold `nbits` elements without resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// let mut s = BitvSet::with_capacity(100);\n+    /// assert!(s.capacity() >= 100);\n+    /// ```\n     #[inline]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         BitvSet(Bitv::with_capacity(nbits, false))\n     }\n \n-    /// Creates a new bit vector set from the given bit vector\n+    /// Create a new bit vector set from the given bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{Bitv, BitvSet};\n+    ///\n+    /// let bv: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// let s = BitvSet::from_bitv(bv);\n+    ///\n+    /// // Print 1, 2 in arbitrary order\n+    /// for x in s.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         BitvSet(bitv)\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::with_capacity(100);\n+    /// assert!(s.capacity() >= 100);\n+    /// ```\n     #[inline]\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n         bitv.capacity()\n     }\n \n-    /// Grows the underlying vector to be able to store `size` bits\n+    /// Grows the underlying vector to be able to store `size` bits.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.reserve(10);\n+    /// assert!(s.capacity() >= 10);\n+    /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let &BitvSet(ref mut bitv) = self;\n         bitv.reserve(size)\n     }\n \n-    /// Consumes this set to return the underlying bit vector\n+    /// Consume this set to return the underlying bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(0);\n+    /// s.insert(3);\n+    ///\n+    /// let bv = s.unwrap();\n+    /// assert!(bv.eq_vec([true, false, false, true]));\n+    /// ```\n     #[inline]\n     pub fn unwrap(self) -> Bitv {\n         let BitvSet(bitv) = self;\n         bitv\n     }\n \n-    /// Returns a reference to the underlying bit vector\n+    /// Return a reference to the underlying bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(0);\n+    ///\n+    /// let bv = s.get_ref();\n+    /// assert_eq!(bv.get(0), true);\n+    /// ```\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n         let &BitvSet(ref bitv) = self;\n         bitv\n     }\n \n-    /// Returns a mutable reference to the underlying bit vector\n+    /// Return a mutable reference to the underlying bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(0);\n+    /// assert_eq!(s.contains(&0), true);\n+    /// {\n+    ///     // Will free the set during bv's lifetime\n+    ///     let bv = s.get_mut_ref();\n+    ///     bv.set(0, false);\n+    /// }\n+    /// assert_eq!(s.contains(&0), false);\n+    /// ```\n     #[inline]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut Bitv {\n         let &BitvSet(ref mut bitv) = self;\n@@ -922,8 +1045,25 @@ impl BitvSet {\n         }\n     }\n \n+    /// Truncate the underlying vector to the least length required.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(32183231);\n+    /// s.remove(&32183231);\n+    ///\n+    /// // Internal storage will probably be bigger than necessary\n+    /// println!(\"old capacity: {}\", s.capacity());\n+    ///\n+    /// // Now should be smaller\n+    /// s.shrink_to_fit();\n+    /// println!(\"new capacity: {}\", s.capacity());\n+    /// ```\n     #[inline]\n-    /// Truncate the underlying vector to the least length required\n     pub fn shrink_to_fit(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         // Obtain original length\n@@ -936,13 +1076,43 @@ impl BitvSet {\n         bitv.nbits = trunc_len * uint::BITS;\n     }\n \n-    /// Iterator over each uint stored in the BitvSet\n+    /// Iterator over each uint stored in the BitvSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let s = BitvSet::from_bitv(from_bytes([0b01001010]));\n+    ///\n+    /// // Print 1, 4, 6 in arbitrary order\n+    /// for x in s.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n         BitPositions {set: self, next_idx: 0}\n     }\n \n-    /// Iterator over each uint stored in `self` union `other`\n+    /// Iterator over each uint stored in `self` union `other`.\n+    /// See [union_with](#method.union_with) for an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// // Print 0, 1, 2, 4 in arbitrary order\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n@@ -954,7 +1124,30 @@ impl BitvSet {\n         }\n     }\n \n-    /// Iterator over each uint stored in the `self` setminus `other`\n+    /// Iterator over each uint stored in the `self` setminus `other`.\n+    /// See [difference_with](#method.difference_with) for an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// // Print 2, 4 in arbitrary order\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else.\n+    /// // This prints 0\n+    /// for x in b.difference(&a) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n@@ -966,7 +1159,24 @@ impl BitvSet {\n         }\n     }\n \n-    /// Iterator over each uint stored in the symmetric difference of `self` and `other`\n+    /// Iterator over each uint stored in the symmetric difference of `self` and `other`.\n+    /// See [symmetric_difference_with](#method.symmetric_difference_with) for\n+    /// an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// // Print 0, 1, 4 in arbitrary order\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n@@ -978,7 +1188,23 @@ impl BitvSet {\n         }\n     }\n \n-    /// Iterator over each uint stored in `self` intersect `other`\n+    /// Iterator over each uint stored in `self` intersect `other`.\n+    /// See [intersect_with](#method.intersect_with) for an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// // Print 2\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n         let min = cmp::min(self.capacity(), other.capacity());\n@@ -991,25 +1217,77 @@ impl BitvSet {\n         }.take(min)\n     }\n \n-    /// Union in-place with the specified other bit vector\n+    /// Union in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// a.union_with(&b);\n+    /// assert_eq!(a.unwrap(), from_bytes([0b11101000]));\n+    /// ```\n     #[inline]\n     pub fn union_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n-    /// Intersect in-place with the specified other bit vector\n+    /// Intersect in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// a.intersect_with(&b);\n+    /// assert_eq!(a.unwrap(), from_bytes([0b00100000]));\n+    /// ```\n     #[inline]\n     pub fn intersect_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n-    /// Difference in-place with the specified other bit vector\n+    /// Difference in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// a.difference_with(&b);\n+    /// assert_eq!(a.unwrap(), from_bytes([0b01001000]));\n+    /// ```\n     #[inline]\n     pub fn difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n-    /// Symmetric difference in-place with the specified other bit vector\n+    /// Symmetric difference in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv::from_bytes;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(from_bytes([0b10100000]));\n+    ///\n+    /// a.symmetric_difference_with(&b);\n+    /// assert_eq!(a.unwrap(), from_bytes([0b11001000]));\n+    /// ```\n     #[inline]\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);"}]}