{"sha": "b54344401adff783f93255f3263437156ef0f4bd", "node_id": "C_kwDOAAsO6NoAKGI1NDM0NDQwMWFkZmY3ODNmOTMyNTVmMzI2MzQzNzE1NmVmMGY0YmQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-26T22:56:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-26T22:56:23Z"}, "message": "Rollup merge of #100738 - nidnogg:diagnostics_migr_const_eval, r=davidtwco\n\nDiagnostics migr const eval\n\nThis PR should eventually contain all diagnostic migrations for the `rustc_const_eval` crate.\n\nr? `@davidtwco`\n`@rustbot` label +A-translation", "tree": {"sha": "44ec4f676ef3c1fe540ea1c92b042fa3576264f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44ec4f676ef3c1fe540ea1c92b042fa3576264f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b54344401adff783f93255f3263437156ef0f4bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjCU+XCRBK7hj4Ov3rIwAAV9YIAC3v/TjZQlJZxhRWWFa8wOhv\nj5zjFwKobgn/ATHl+7/O+s5HEKWEk0LVuqWvXdjMEd95hfPYBtVSswQCH6cmEErr\n9/J4Lm39Bq8+PJW/Y+iiL+yXW3a9CF0AdAMEpjPgEEjxtplZsUjBTs06uOrX6lVE\nmLGLqUsw+hOYJ+FsqQsR9XNqvFR+RrR3utMGRpSReS2v9rwff9bq6/RQt6kftL0b\nRJS88m5+rE94BQr/hYRcvPeRFIa4VGoA5K0mM6wWmJ+hI5pzHtNWhb2IrNwK/XBS\nIldSpA+xUe93Qsr5A9cFPJp/8xqQmAWSg3iRpWMT18Qy1xO5Y93d3nkfNMysLRs=\n=lYUe\n-----END PGP SIGNATURE-----\n", "payload": "tree 44ec4f676ef3c1fe540ea1c92b042fa3576264f7\nparent 181b0410eca5cb5b9953f59db5c146d157c86c0d\nparent 5101688d4f92d94b93e038e2b53f7ca0ba6c29a4\nauthor Michael Goulet <michael@errs.io> 1661554583 -0700\ncommitter GitHub <noreply@github.com> 1661554583 -0700\n\nRollup merge of #100738 - nidnogg:diagnostics_migr_const_eval, r=davidtwco\n\nDiagnostics migr const eval\n\nThis PR should eventually contain all diagnostic migrations for the `rustc_const_eval` crate.\n\nr? `@davidtwco`\n`@rustbot` label +A-translation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b54344401adff783f93255f3263437156ef0f4bd", "html_url": "https://github.com/rust-lang/rust/commit/b54344401adff783f93255f3263437156ef0f4bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b54344401adff783f93255f3263437156ef0f4bd/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "181b0410eca5cb5b9953f59db5c146d157c86c0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/181b0410eca5cb5b9953f59db5c146d157c86c0d", "html_url": "https://github.com/rust-lang/rust/commit/181b0410eca5cb5b9953f59db5c146d157c86c0d"}, {"sha": "5101688d4f92d94b93e038e2b53f7ca0ba6c29a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5101688d4f92d94b93e038e2b53f7ca0ba6c29a4", "html_url": "https://github.com/rust-lang/rust/commit/5101688d4f92d94b93e038e2b53f7ca0ba6c29a4"}], "stats": {"total": 343, "additions": 228, "deletions": 115}, "files": [{"sha": "d9c4ae4d53f91d3946fce0f16368aaf45f5f86d0", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=b54344401adff783f93255f3263437156ef0f4bd", "patch": "@@ -1,16 +1,16 @@\n // Not in interpret to make sure we do not use private implementation details\n \n+use crate::errors::MaxNumNodesInConstErr;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n+    Scalar,\n+};\n use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n-    Scalar,\n-};\n-\n mod error;\n mod eval_queries;\n mod fn_queries;\n@@ -72,12 +72,17 @@ pub(crate) fn eval_to_valtree<'tcx>(\n         Ok(valtree) => Ok(Some(valtree)),\n         Err(err) => {\n             let did = cid.instance.def_id();\n-            let s = cid.display(tcx);\n+            let global_const_id = cid.display(tcx);\n             match err {\n                 ValTreeCreationError::NodesOverflow => {\n-                    let msg = format!(\"maximum number of nodes exceeded in constant {}\", &s);\n+                    let msg = format!(\n+                        \"maximum number of nodes exceeded in constant {}\",\n+                        &global_const_id\n+                    );\n                     let mut diag = match tcx.hir().span_if_local(did) {\n-                        Some(span) => tcx.sess.struct_span_err(span, &msg),\n+                        Some(span) => {\n+                            tcx.sess.create_err(MaxNumNodesInConstErr { span, global_const_id })\n+                        }\n                         None => tcx.sess.struct_err(&msg),\n                     };\n                     diag.emit();"}, {"sha": "c3547cb3abdf3ff2fefa5205545281ebb6087bb4", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=b54344401adff783f93255f3263437156ef0f4bd", "patch": "@@ -87,3 +87,110 @@ pub(crate) struct TransientMutBorrowErrRaw {\n     pub span: Span,\n     pub kind: ConstContext,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::max_num_nodes_in_const)]\n+pub(crate) struct MaxNumNodesInConstErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub global_const_id: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_fn_pointer_call)]\n+pub(crate) struct UnallowedFnPointerCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unstable_const_fn)]\n+pub(crate) struct UnstableConstFn {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefs {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefsRaw {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n+pub(crate) struct NonConstFmtMacroCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::non_const_fn_call, code = \"E0015\")]\n+pub(crate) struct NonConstFnCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path_str: String,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_op_in_const_context)]\n+pub(crate) struct UnallowedOpInConstContext {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n+pub(crate) struct UnallowedHeapAllocations {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_inline_asm, code = \"E0015\")]\n+pub(crate) struct UnallowedInlineAsm {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n+pub(crate) struct InteriorMutableDataRefer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[help]\n+    pub opt_help: Option<()>,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::interior_mutability_borrow)]\n+pub(crate) struct InteriorMutabilityBorrow {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "5fb4bf638b342648d8648926c4aaeba2872e0a07", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 51, "deletions": 105, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=b54344401adff783f93255f3263437156ef0f4bd", "patch": "@@ -24,8 +24,11 @@ use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n use crate::errors::{\n-    MutDerefErr, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n-    TransientMutBorrowErr, TransientMutBorrowErrRaw,\n+    InteriorMutabilityBorrow, InteriorMutableDataRefer, MutDerefErr, NonConstFmtMacroCall,\n+    NonConstFnCall, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n+    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall,\n+    UnallowedHeapAllocations, UnallowedInlineAsm, UnallowedMutableRefs, UnallowedMutableRefsRaw,\n+    UnallowedOpInConstContext, UnstableConstFn,\n };\n use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n@@ -97,10 +100,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\"function pointer calls are not allowed in {}s\", ccx.const_kind()),\n-        )\n+        ccx.tcx.sess.create_err(UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -308,22 +308,13 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 err\n             }\n             _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n-                struct_span_err!(\n-                    ccx.tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const formatting macro in {}s\",\n-                    ccx.const_kind(),\n-                )\n+                ccx.tcx.sess.create_err(NonConstFmtMacroCall { span, kind: ccx.const_kind() })\n             }\n-            _ => struct_span_err!(\n-                ccx.tcx.sess,\n+            _ => ccx.tcx.sess.create_err(NonConstFnCall {\n                 span,\n-                E0015,\n-                \"cannot call non-const fn `{}` in {}s\",\n-                ccx.tcx.def_path_str_with_substs(callee, substs),\n-                ccx.const_kind(),\n-            ),\n+                def_path_str: ccx.tcx.def_path_str_with_substs(callee, substs),\n+                kind: ccx.const_kind(),\n+            }),\n         };\n \n         err.note(&format!(\n@@ -354,10 +345,10 @@ impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n-        let mut err = ccx.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n-        );\n+        let mut err = ccx\n+            .tcx\n+            .sess\n+            .create_err(UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n \n         if ccx.is_const_stable_const_fn() {\n             err.help(\"const-stable functions can only call other const-stable functions\");\n@@ -392,9 +383,12 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n-            feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n+            ccx.tcx.sess.create_feature_err(\n+                UnallowedOpInConstContext { span, msg },\n+                sym::const_async_blocks,\n+            )\n         } else {\n-            ccx.tcx.sess.struct_span_err(span, &msg)\n+            ccx.tcx.sess.create_err(UnallowedOpInConstContext { span, msg })\n         }\n     }\n }\n@@ -407,23 +401,11 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n+        ccx.tcx.sess.create_err(UnallowedHeapAllocations {\n             span,\n-            E0010,\n-            \"allocations are not allowed in {}s\",\n-            ccx.const_kind()\n-        );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"The value of statics and constants must be known at compile time, \\\n-                 and they live for the entire lifetime of a program. Creating a boxed \\\n-                 value allocates memory on the heap at runtime, and therefore cannot \\\n-                 be done at compile time.\",\n-            );\n-        }\n-        err\n+            kind: ccx.const_kind(),\n+            teach: ccx.tcx.sess.teach(&error_code!(E0010)).then_some(()),\n+        })\n     }\n }\n \n@@ -435,13 +417,7 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"inline assembly is not allowed in {}s\",\n-            ccx.const_kind()\n-        )\n+        ccx.tcx.sess.create_err(UnallowedInlineAsm { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -487,12 +463,7 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        feature_err(\n-            &ccx.tcx.sess.parse_sess,\n-            sym::const_refs_to_cell,\n-            span,\n-            \"cannot borrow here, since the borrowed element may contain interior mutability\",\n-        )\n+        ccx.tcx.sess.create_feature_err(InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n     }\n }\n \n@@ -507,32 +478,22 @@ impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0492,\n-            \"{}s cannot refer to interior mutable data\",\n-            ccx.const_kind(),\n-        );\n-        err.span_label(\n-            span,\n-            \"this borrow of an interior mutable value may end up in the final value\",\n-        );\n+        // FIXME: Maybe a more elegant solution to this if else case\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n-            err.help(\n-                \"to fix this, the value can be extracted to a separate \\\n-                `static` item and then referenced\",\n-            );\n-        }\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"A constant containing interior mutable data behind a reference can allow you\n-                 to modify that data. This would make multiple uses of a constant to be able to\n-                 see different values and allow circumventing the `Send` and `Sync` requirements\n-                 for shared mutable data, which is unsound.\",\n-            );\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: Some(()),\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n+        } else {\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: None,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n         }\n-        err\n     }\n }\n \n@@ -558,33 +519,18 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let raw = match self.0 {\n-            hir::BorrowKind::Raw => \"raw \",\n-            hir::BorrowKind::Ref => \"\",\n-        };\n-\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0764,\n-            \"{}mutable references are not allowed in the final value of {}s\",\n-            raw,\n-            ccx.const_kind(),\n-        );\n-\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"References in statics and constants may only refer \\\n-                      to immutable values.\\n\\n\\\n-                      Statics are shared everywhere, and if they refer to \\\n-                      mutable data one might violate memory safety since \\\n-                      holding multiple mutable references to shared data \\\n-                      is not allowed.\\n\\n\\\n-                      If you really want global mutable state, try using \\\n-                      static mut or a global UnsafeCell.\",\n-            );\n+        match self.0 {\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(UnallowedMutableRefsRaw {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n         }\n-        err\n     }\n }\n "}, {"sha": "33bb116d6fa23f01c513d1b34b0d7e8ed9007070", "filename": "compiler/rustc_error_messages/locales/en-US/const_eval.ftl", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl?ref=b54344401adff783f93255f3263437156ef0f4bd", "patch": "@@ -29,3 +29,55 @@ const_eval_mut_deref =\n const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n \n const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n+\n+const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n+\n+const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n+\n+const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n+\n+const_eval_unallowed_mutable_refs =\n+    mutable references are not allowed in the final value of {$kind}s\n+    .teach_note =\n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory\n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_unallowed_mutable_refs_raw =\n+    raw mutable references are not allowed in the final value of {$kind}s\n+    .teach_note =\n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory\n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_non_const_fmt_macro_call =\n+    cannot call non-const formatting macro in {$kind}s\n+\n+const_eval_non_const_fn_call =\n+    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+\n+const_eval_unallowed_op_in_const_context =\n+    {$msg}\n+\n+const_eval_unallowed_heap_allocations =\n+    allocations are not allowed in {$kind}s\n+    .label = allocation not allowed in {$kind}s\n+    .teach_note =\n+        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n+\n+const_eval_unallowed_inline_asm =\n+    inline assembly is not allowed in {$kind}s\n+\n+const_eval_interior_mutable_data_refer =\n+    {$kind}s cannot refer to interior mutable data\n+    .label = this borrow of an interior mutable value may end up in the final value\n+    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n+    .teach_note =\n+        A constant containing interior mutable data behind a reference can allow you to modify that data.\n+        This would make multiple uses of a constant to be able to see different values and allow circumventing\n+        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n+\n+const_eval_interior_mutability_borrow =\n+    cannot borrow here, since the borrowed element may contain interior mutability"}, {"sha": "ec5e5170d359494fbeae05002849ef132dd91c1d", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b54344401adff783f93255f3263437156ef0f4bd/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=b54344401adff783f93255f3263437156ef0f4bd", "patch": "@@ -20,8 +20,8 @@ use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{\n-    fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, EmissionGuarantee,\n-    ErrorGuaranteed, FluentBundle, LazyFallbackBundle, MultiSpan,\n+    error_code, fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n+    EmissionGuarantee, ErrorGuaranteed, FluentBundle, LazyFallbackBundle, MultiSpan,\n };\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n@@ -467,6 +467,9 @@ impl Session {\n         feature: Symbol,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = self.parse_sess.create_err(err);\n+        if err.code.is_none() {\n+            err.code = std::option::Option::Some(error_code!(E0658));\n+        }\n         add_feature_diagnostics(&mut err, &self.parse_sess, feature);\n         err\n     }"}]}