{"sha": "aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlY2FlYWI1ZWM0N2NhMzRkYTk1YjQ3MzBjYmZlODBhMTljZTZmZTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-04T11:21:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-04T11:21:41Z"}, "message": "share more alloc printing code between Miri and MIR dumping", "tree": {"sha": "daa8f362bba506d1802c8b73111f3ae3e6f40cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daa8f362bba506d1802c8b73111f3ae3e6f40cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6", "html_url": "https://github.com/rust-lang/rust/commit/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbdff5145ac3f6ecfe7bde656cfa41f5a77c8f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdff5145ac3f6ecfe7bde656cfa41f5a77c8f10", "html_url": "https://github.com/rust-lang/rust/commit/fbdff5145ac3f6ecfe7bde656cfa41f5a77c8f10"}], "stats": {"total": 141, "additions": 78, "deletions": 63}, "files": [{"sha": "e61b0796cc182ce2400db5e149b2b76e64168b58", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6", "patch": "@@ -20,6 +20,7 @@ use super::{\n     AllocId, AllocMap, Allocation, AllocationExtra, CheckInAllocMsg, ErrorHandled, GlobalAlloc,\n     GlobalId, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Scalar,\n };\n+use crate::util::pretty;\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n@@ -644,22 +645,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.dump_allocs(vec![id]);\n     }\n \n-    fn dump_alloc_helper<Tag, Extra>(\n-        &self,\n-        allocs_to_print: &mut VecDeque<AllocId>,\n-        alloc: &Allocation<Tag, Extra>,\n-    ) {\n-        for &(_, target_id) in alloc.relocations().values() {\n-            allocs_to_print.push_back(target_id);\n-        }\n-        crate::util::pretty::write_allocation(self.tcx.tcx, alloc, &mut std::io::stderr(), \"\")\n-            .unwrap();\n-    }\n-\n     /// Print a list of allocations and all allocations they point to, recursively.\n     /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n     /// control for this.\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n+        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Tag, Extra>(\n+            tcx: TyCtxtAt<'tcx>,\n+            allocs_to_print: &mut VecDeque<AllocId>,\n+            alloc: &Allocation<Tag, Extra>,\n+        ) {\n+            for &(_, target_id) in alloc.relocations().values() {\n+                allocs_to_print.push_back(target_id);\n+            }\n+            pretty::write_allocation(tcx.tcx, alloc, &mut std::io::stderr()).unwrap();\n+        }\n+\n         allocs.sort();\n         allocs.dedup();\n         let mut allocs_to_print = VecDeque::from(allocs);\n@@ -671,46 +672,42 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // Already printed, so skip this.\n                 continue;\n             }\n-            eprint!(\"Alloc {:<5}: \", id);\n-            fn msg<Tag, Extra>(alloc: &Allocation<Tag, Extra>, extra: &str) {\n-                eprintln!(\n-                    \"({} bytes, alignment {}){}\",\n-                    alloc.size.bytes(),\n-                    alloc.align.bytes(),\n-                    extra\n-                )\n-            };\n \n-            // normal alloc?\n-            match self.alloc_map.get_or(id, || Err(())) {\n-                Ok((kind, alloc)) => {\n+            eprint!(\"{}\", id);\n+            match self.alloc_map.get(id) {\n+                Some(&(kind, ref alloc)) => {\n+                    // normal alloc\n                     match kind {\n-                        MemoryKind::Stack => msg(alloc, \" (stack)\"),\n-                        MemoryKind::Vtable => msg(alloc, \" (vtable)\"),\n-                        MemoryKind::CallerLocation => msg(alloc, \" (caller_location)\"),\n-                        MemoryKind::Machine(m) => msg(alloc, &format!(\" ({:?})\", m)),\n+                        MemoryKind::Stack => eprint!(\" (stack variable, \"),\n+                        MemoryKind::Vtable => eprint!(\" (vtable, \"),\n+                        MemoryKind::CallerLocation => eprint!(\" (caller_location, \"),\n+                        MemoryKind::Machine(m) if Some(m) == M::GLOBAL_KIND => {\n+                            eprint!(\" (global, \")\n+                        }\n+                        MemoryKind::Machine(m) => eprint!(\" ({:?}, \", m),\n                     };\n-                    self.dump_alloc_helper(&mut allocs_to_print, alloc);\n+                    write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n                 }\n-                Err(()) => {\n-                    // global alloc?\n+                None => {\n+                    // global alloc\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            msg(alloc, \" (immutable)\");\n-                            self.dump_alloc_helper(&mut allocs_to_print, alloc);\n+                            eprint!(\" (global, \");\n+                            write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n                         }\n                         Some(GlobalAlloc::Function(func)) => {\n-                            eprintln!(\"{}\", func);\n+                            eprint!(\" (fn: {})\", func);\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n-                            eprintln!(\"{:?}\", did);\n+                            eprint!(\" (static: {})\", self.tcx.def_path_str(did));\n                         }\n                         None => {\n-                            eprintln!(\"(deallocated)\");\n+                            eprint!(\" (deallocated)\");\n                         }\n                     }\n                 }\n-            };\n+            }\n+            eprintln!();\n         }\n     }\n "}, {"sha": "64221c41bffe4f56f1b373f99eced4b42d48d152", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=aecaeab5ec47ca34da95b4730cbfe80a19ce6fe6", "patch": "@@ -567,26 +567,21 @@ pub fn write_allocations<'tcx>(\n     }\n     let mut visitor = CollectAllocIds(Default::default());\n     body.visit_with(&mut visitor);\n+    // `seen` contains all seen allocations, including the ones we have *not* printed yet.\n+    // The protocol is to first `insert` into `seen`, and only if that returns `true`\n+    // then push to `todo`.\n     let mut seen = visitor.0;\n     let mut todo: Vec<_> = seen.iter().copied().collect();\n     while let Some(id) = todo.pop() {\n-        let mut write_header_and_allocation =\n+        let mut write_allocation_track_relocs =\n             |w: &mut dyn Write, alloc: &Allocation| -> io::Result<()> {\n-                write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n-                if alloc.size == Size::ZERO {\n-                    write!(w, \" {{}}\")?;\n-                } else {\n-                    writeln!(w, \" {{\")?;\n-                    write_allocation(tcx, alloc, w, \"    \")?;\n-                    write!(w, \"}}\")?;\n-                    // `.rev()` because we are popping them from the back of the `todo` vector.\n-                    for id in alloc_ids_from_alloc(alloc).rev() {\n-                        if seen.insert(id) {\n-                            todo.push(id);\n-                        }\n+                // `.rev()` because we are popping them from the back of the `todo` vector.\n+                for id in alloc_ids_from_alloc(alloc).rev() {\n+                    if seen.insert(id) {\n+                        todo.push(id);\n                     }\n                 }\n-                Ok(())\n+                write_allocation(tcx, alloc, w)\n             };\n         write!(w, \"\\n{}\", id)?;\n         let alloc = tcx.alloc_map.lock().get(id);\n@@ -599,7 +594,7 @@ pub fn write_allocations<'tcx>(\n                 match tcx.const_eval_poly(did) {\n                     Ok(ConstValue::ByRef { alloc, .. }) => {\n                         write!(w, \" (static: {}, \", tcx.def_path_str(did))?;\n-                        write_header_and_allocation(w, alloc)?;\n+                        write_allocation_track_relocs(w, alloc)?;\n                     }\n                     Ok(_) => {\n                         span_bug!(tcx.def_span(did), \" static item without `ByRef` initializer\")\n@@ -616,15 +611,46 @@ pub fn write_allocations<'tcx>(\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {\n                 write!(w, \" (\")?;\n-                write_header_and_allocation(w, alloc)?\n+                write_allocation_track_relocs(w, alloc)?\n             }\n         }\n-\n         writeln!(w)?;\n     }\n     Ok(())\n }\n \n+/// Dumps the size and metadata and content of an allocation to the given writer.\n+/// The expectation is that the caller first prints other relevant metadata, so the exact\n+/// format of this function is (*without* leading or trailing newline):\n+/// ```\n+/// size: {}, align: {}) {\n+///     <bytes>\n+/// }\n+/// ```\n+///\n+/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n+/// the start of the line, followed by all bytes in hex format (space separated).\n+/// If the allocation is small enough to fit into a single line, no start address is given.\n+/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n+/// characters or characters whose value is larger than 127) with a `.`\n+/// This also prints relocations adequately.\n+pub fn write_allocation<Tag, Extra>(\n+    tcx: TyCtxt<'tcx>,\n+    alloc: &Allocation<Tag, Extra>,\n+    w: &mut dyn Write,\n+) -> io::Result<()> {\n+    write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n+    if alloc.size == Size::ZERO {\n+        // We are done.\n+        return write!(w, \" {{}}\");\n+    }\n+    // Write allocation bytes.\n+    writeln!(w, \" {{\")?;\n+    write_allocation_bytes(tcx, alloc, w, \"    \")?;\n+    write!(w, \"}}\")?;\n+    Ok(())\n+}\n+\n fn write_allocation_endline(w: &mut dyn Write, ascii: &str) -> io::Result<()> {\n     for _ in 0..(BYTES_PER_LINE - ascii.chars().count()) {\n         write!(w, \"   \")?;\n@@ -649,18 +675,10 @@ fn write_allocation_newline(\n     Ok(line_start)\n }\n \n-/// Dumps the bytes of an allocation to the given writer. This also prints relocations instead of\n-/// the raw bytes where applicable.\n-/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n-/// the start of the line, followed by all bytes in hex format (space separated).\n-/// If the allocation is small enough to fit into a single line, no start address is given.\n-/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n-/// characters or characters whose value is larger than 127) with a `.`\n-///\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-pub fn write_allocation<Tag, Extra>(\n+fn write_allocation_bytes<Tag, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Tag, Extra>,\n     w: &mut dyn Write,"}]}