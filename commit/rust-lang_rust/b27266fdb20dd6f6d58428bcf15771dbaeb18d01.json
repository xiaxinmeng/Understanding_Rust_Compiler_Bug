{"sha": "b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNzI2NmZkYjIwZGQ2ZjZkNTg0MjhiY2YxNTc3MWRiYWViMThkMDE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-18T22:53:42Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-19T16:51:56Z"}, "message": "Use a QueryContext for try_mark_green.", "tree": {"sha": "ffcf08b18f51c71271e486e0a06cdf14f7314ea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffcf08b18f51c71271e486e0a06cdf14f7314ea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "html_url": "https://github.com/rust-lang/rust/commit/b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd14c7bbee10aaff2466014ae1c2455010dfafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd14c7bbee10aaff2466014ae1c2455010dfafe", "html_url": "https://github.com/rust-lang/rust/commit/3bd14c7bbee10aaff2466014ae1c2455010dfafe"}], "stats": {"total": 276, "additions": 133, "deletions": 143}, "files": [{"sha": "39781e2482a6a8f3cf83d4daf09d5590de678083", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -465,9 +465,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        CguReuse::PreLto\n-    } else {\n-        CguReuse::No\n-    }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n }"}, {"sha": "08e31c3b37f345eaed02667f0e933387e4a8841e", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -867,7 +867,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+    if tcx.try_mark_green(&dep_node) {\n         // We can re-use either the pre- or the post-thinlto state. If no LTO is\n         // being performed then we can use post-LTO artifacts, otherwise we must\n         // reuse pre-LTO artifacts"}, {"sha": "823bcebe23b14007ac779daed1ac6cd48534d1bb", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -135,7 +135,7 @@ pub struct DepKindStruct {\n     /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n     /// add it to the \"We don't have enough information to reconstruct...\" group in\n     /// the match below.\n-    pub(super) force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n+    pub(crate) force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n \n     /// Invoke a query to put the on-disk cached value in memory.\n     pub(crate) try_load_from_on_disk_cache: fn(QueryCtxt<'_>, &DepNode),"}, {"sha": "da9b0b7e48af40b3bc55bc610b5cf1cf55348807", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -2,9 +2,6 @@ use crate::ich::StableHashingContext;\n use crate::ty::{self, TyCtxt};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n@@ -116,99 +113,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         &self.dep_graph\n     }\n \n-    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n-        // FIXME: This match is just a workaround for incremental bugs and should\n-        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-        // bug that must be fixed before removing this.\n-        match dep_node.kind {\n-            DepKind::hir_owner | DepKind::hir_owner_nodes => {\n-                if let Some(def_id) = dep_node.extract_def_id(*self) {\n-                    if !def_id_corresponds_to_hir_dep_node(*self, def_id.expect_local()) {\n-                        // This `DefPath` does not have a\n-                        // corresponding `DepNode` (e.g. a\n-                        // struct field), and the ` DefPath`\n-                        // collided with the `DefPath` of a\n-                        // proper item that existed in the\n-                        // previous compilation session.\n-                        //\n-                        // Since the given `DefPath` does not\n-                        // denote the item that previously\n-                        // existed, we just fail to mark green.\n-                        return false;\n-                    }\n-                } else {\n-                    // If the node does not exist anymore, we\n-                    // just fail to mark green.\n-                    return false;\n-                }\n-            }\n-            _ => {\n-                // For other kinds of nodes it's OK to be\n-                // forced.\n-            }\n-        }\n-\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n-        // We must avoid ever having to call `force_from_dep_node()` for a\n-        // `DepNode::codegen_unit`:\n-        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-        // would always end up having to evaluate the first caller of the\n-        // `codegen_unit` query that *is* reconstructible. This might very well be\n-        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-        // to re-trigger calling the `codegen_unit` query with the right key. At\n-        // that point we would already have re-done all the work we are trying to\n-        // avoid doing in the first place.\n-        // The solution is simple: Just explicitly call the `codegen_unit` query for\n-        // each CGU, right after partitioning. This way `try_mark_green` will always\n-        // hit the cache instead of having to go through `force_from_dep_node`.\n-        // This assertion makes sure, we actually keep applying the solution above.\n-        debug_assert!(\n-            dep_node.kind != DepKind::codegen_unit,\n-            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-        );\n-\n-        (dep_node.kind.force_from_dep_node)(*self, dep_node)\n-    }\n-\n-    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n-        self.sess.has_errors_or_delayed_span_bugs()\n-    }\n-\n-    fn diagnostic(&self) -> &rustc_errors::Handler {\n-        self.sess.diagnostic()\n-    }\n-\n-    // Interactions with on_disk_cache\n-    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n-        self.on_disk_cache\n-            .as_ref()\n-            .map(|c| c.load_diagnostics(*self, prev_dep_node_index))\n-            .unwrap_or_default()\n-    }\n-\n-    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n-        if let Some(c) = self.on_disk_cache.as_ref() {\n-            c.store_diagnostics(dep_node_index, diagnostics)\n-        }\n-    }\n-\n-    fn store_diagnostics_for_anon_node(\n-        &self,\n-        dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n-    ) {\n-        if let Some(c) = self.on_disk_cache.as_ref() {\n-            c.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n-        }\n-    }\n-\n     fn profiler(&self) -> &SelfProfilerRef {\n         &self.prof\n     }\n }\n-\n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    def_id == hir_id.owner\n-}"}, {"sha": "970deb659facec401515648e59dd616d6a6d3926", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -119,6 +119,11 @@ impl TyCtxt<'tcx> {\n     pub fn at(self, span: Span) -> TyCtxtAt<'tcx> {\n         TyCtxtAt { tcx: self, span }\n     }\n+\n+    pub fn try_mark_green(self, dep_node: &dep_graph::DepNode) -> bool {\n+        let qcx = QueryCtxt { tcx: self, queries: self.queries };\n+        self.dep_graph.try_mark_green(qcx, dep_node).is_some()\n+    }\n }\n \n macro_rules! define_callbacks {"}, {"sha": "23eb7ce324898cdaac43ae8ab3a6496f4fdc0969", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph;\n+use crate::dep_graph::{self, DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::{on_disk_cache, Queries, Query};\n use crate::ty::tls::{self, ImplicitCtxt};\n use crate::ty::{self, TyCtxt};\n@@ -72,6 +72,95 @@ impl QueryContext for QueryCtxt<'tcx> {\n         (dep_node.kind.try_load_from_on_disk_cache)(*self, dep_node)\n     }\n \n+    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n+        // FIXME: This match is just a workaround for incremental bugs and should\n+        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n+        // bug that must be fixed before removing this.\n+        match dep_node.kind {\n+            DepKind::hir_owner | DepKind::hir_owner_nodes => {\n+                if let Some(def_id) = dep_node.extract_def_id(**self) {\n+                    let def_id = def_id.expect_local();\n+                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                    if def_id != hir_id.owner {\n+                        // This `DefPath` does not have a\n+                        // corresponding `DepNode` (e.g. a\n+                        // struct field), and the ` DefPath`\n+                        // collided with the `DefPath` of a\n+                        // proper item that existed in the\n+                        // previous compilation session.\n+                        //\n+                        // Since the given `DefPath` does not\n+                        // denote the item that previously\n+                        // existed, we just fail to mark green.\n+                        return false;\n+                    }\n+                } else {\n+                    // If the node does not exist anymore, we\n+                    // just fail to mark green.\n+                    return false;\n+                }\n+            }\n+            _ => {\n+                // For other kinds of nodes it's OK to be\n+                // forced.\n+            }\n+        }\n+\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            dep_node.kind != DepKind::codegen_unit,\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        (dep_node.kind.force_from_dep_node)(**self, dep_node)\n+    }\n+\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.sess.has_errors_or_delayed_span_bugs()\n+    }\n+\n+    fn diagnostic(&self) -> &rustc_errors::Handler {\n+        self.sess.diagnostic()\n+    }\n+\n+    // Interactions with on_disk_cache\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n+        self.on_disk_cache\n+            .as_ref()\n+            .map(|c| c.load_diagnostics(**self, prev_dep_node_index))\n+            .unwrap_or_default()\n+    }\n+\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+        if let Some(c) = self.on_disk_cache.as_ref() {\n+            c.store_diagnostics(dep_node_index, diagnostics)\n+        }\n+    }\n+\n+    fn store_diagnostics_for_anon_node(\n+        &self,\n+        dep_node_index: DepNodeIndex,\n+        diagnostics: ThinVec<Diagnostic>,\n+    ) {\n+        if let Some(c) = self.on_disk_cache.as_ref() {\n+            c.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n+        }\n+    }\n+\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result."}, {"sha": "f579052c106b6dee89794a38c07b1aba785c1fc1", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -587,7 +587,7 @@ impl<K: DepKind> DepGraph<K> {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green_and_read<Ctxt: DepContext<DepKind = K>>(\n+    pub fn try_mark_green_and_read<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         dep_node: &DepNode<K>,\n@@ -599,7 +599,7 @@ impl<K: DepKind> DepGraph<K> {\n         })\n     }\n \n-    pub fn try_mark_green<Ctxt: DepContext<DepKind = K>>(\n+    pub fn try_mark_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         dep_node: &DepNode<K>,\n@@ -627,7 +627,7 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<Ctxt: DepContext<DepKind = K>>(\n+    fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         data: &DepGraphData<K>,\n@@ -811,7 +811,7 @@ impl<K: DepKind> DepGraph<K> {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_diagnostics<Ctxt: DepContext<DepKind = K>>(\n+    fn emit_diagnostics<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         data: &DepGraphData<K>,"}, {"sha": "a647381fb03fa89ef39a561143667f913eb98458", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -13,8 +13,6 @@ pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::Diagnostic;\n \n use std::fmt;\n use std::hash::Hash;\n@@ -32,30 +30,8 @@ pub trait DepContext: Copy {\n     /// Access the DepGraph.\n     fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n \n-    /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n-\n     fn register_reused_dep_node(&self, dep_node: &DepNode<Self::DepKind>);\n \n-    /// Return whether the current session is tainted by errors.\n-    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n-\n-    /// Return the diagnostic handler.\n-    fn diagnostic(&self) -> &rustc_errors::Handler;\n-\n-    /// Load diagnostics associated to the node in the previous session.\n-    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n-\n-    /// Register diagnostics for the given node, for use in next session.\n-    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n-\n-    /// Register diagnostics for the given node, for use in next session.\n-    fn store_diagnostics_for_anon_node(\n-        &self,\n-        dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n-    );\n-\n     /// Access the profiler.\n     fn profiler(&self) -> &SelfProfilerRef;\n }"}, {"sha": "c935e1b9c5cd61912082588d2400639ab017be34", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -14,7 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n-use crate::dep_graph::{DepNode, HasDepContext};\n+use crate::dep_graph::{DepNode, DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n use crate::query::job::QueryMap;\n \n use rustc_data_structures::stable_hasher::HashStable;\n@@ -40,6 +40,28 @@ pub trait QueryContext: HasDepContext {\n     /// Load data from the on-disk cache.\n     fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n \n+    /// Try to force a dep node to execute and see if it's green.\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+\n+    /// Return whether the current session is tainted by errors.\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n+\n+    /// Return the diagnostic handler.\n+    fn diagnostic(&self) -> &rustc_errors::Handler;\n+\n+    /// Load diagnostics associated to the node in the previous session.\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics_for_anon_node(\n+        &self,\n+        dep_node_index: DepNodeIndex,\n+        diagnostics: ThinVec<Diagnostic>,\n+    );\n+\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result."}, {"sha": "bd22ee2c18b2b89047574a1ce6429ed2b7fa6473", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27266fdb20dd6f6d58428bcf15771dbaeb18d01/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=b27266fdb20dd6f6d58428bcf15771dbaeb18d01", "patch": "@@ -460,7 +460,7 @@ where\n         tcx.dep_context().dep_graph().read_index(dep_node_index);\n \n         if unlikely!(!diagnostics.is_empty()) {\n-            tcx.dep_context().store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+            tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n         }\n \n         return job.complete(result, dep_node_index);\n@@ -473,10 +473,7 @@ where\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         let loaded = tcx.start_query(job.id, None, || {\n-            let marked = tcx\n-                .dep_context()\n-                .dep_graph()\n-                .try_mark_green_and_read(*tcx.dep_context(), &dep_node);\n+            let marked = tcx.dep_context().dep_graph().try_mark_green_and_read(tcx, &dep_node);\n             marked.map(|(prev_dep_node_index, dep_node_index)| {\n                 (\n                     load_from_disk_and_cache_in_memory(\n@@ -641,7 +638,7 @@ where\n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n     if unlikely!(!diagnostics.is_empty()) && dep_node.kind != DepKind::NULL {\n-        tcx.dep_context().store_diagnostics(dep_node_index, diagnostics);\n+        tcx.store_diagnostics(dep_node_index, diagnostics);\n     }\n \n     let result = job.complete(result, dep_node_index);\n@@ -676,7 +673,7 @@ where\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<CTX, K, V>(tcx: CTX::DepContext, key: &K, query: &QueryVtable<CTX, K, V>) -> bool\n+fn ensure_must_run<CTX, K, V>(tcx: CTX, key: &K, query: &QueryVtable<CTX, K, V>) -> bool\n where\n     K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n@@ -688,9 +685,9 @@ where\n     // Ensuring an anonymous query makes no sense\n     assert!(!query.anon);\n \n-    let dep_node = query.to_dep_node(tcx, key);\n+    let dep_node = query.to_dep_node(*tcx.dep_context(), key);\n \n-    match tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node) {\n+    match tcx.dep_context().dep_graph().try_mark_green_and_read(tcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green_and_read` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -701,7 +698,7 @@ where\n             true\n         }\n         Some((_, dep_node_index)) => {\n-            tcx.profiler().query_cache_hit(dep_node_index.into());\n+            tcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n             false\n         }\n     }\n@@ -768,7 +765,7 @@ where\n {\n     let query = &Q::VTABLE;\n     if let QueryMode::Ensure = mode {\n-        if !ensure_must_run(*tcx.dep_context(), &key, query) {\n+        if !ensure_must_run(tcx, &key, query) {\n             return None;\n         }\n     }"}]}