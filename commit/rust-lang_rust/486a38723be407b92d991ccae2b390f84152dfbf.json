{"sha": "486a38723be407b92d991ccae2b390f84152dfbf", "node_id": "C_kwDOAAsO6NoAKDQ4NmEzODcyM2JlNDA3YjkyZDk5MWNjYWUyYjM5MGY4NDE1MmRmYmY", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-03-10T13:45:45Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-03-19T16:39:34Z"}, "message": "Split `execute_job` into `execute_job_incr` and `execute_job_non_incr`", "tree": {"sha": "d26bd3af85e0bc00eae23df5d7fcf9591dbd8143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d26bd3af85e0bc00eae23df5d7fcf9591dbd8143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/486a38723be407b92d991ccae2b390f84152dfbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/486a38723be407b92d991ccae2b390f84152dfbf", "html_url": "https://github.com/rust-lang/rust/commit/486a38723be407b92d991ccae2b390f84152dfbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/486a38723be407b92d991ccae2b390f84152dfbf/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab9bb3ea368b2412531a3e8c07ba73d1dd690134", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9bb3ea368b2412531a3e8c07ba73d1dd690134", "html_url": "https://github.com/rust-lang/rust/commit/ab9bb3ea368b2412531a3e8c07ba73d1dd690134"}], "stats": {"total": 69, "additions": 39, "deletions": 30}, "files": [{"sha": "a6c464d0972e0d647cf414e2ead38ef313d2c3e5", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/486a38723be407b92d991ccae2b390f84152dfbf/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486a38723be407b92d991ccae2b390f84152dfbf/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=486a38723be407b92d991ccae2b390f84152dfbf", "patch": "@@ -379,7 +379,11 @@ where\n \n     match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n+            let (result, dep_node_index) = match qcx.dep_context().dep_graph().data() {\n+                None => execute_job_non_incr(query, qcx, key, job.id),\n+                Some(data) => execute_job_incr(query, qcx, data, key, dep_node, job.id),\n+            };\n+\n             let cache = query.query_cache(qcx);\n             if query.feedable() {\n                 // We should not compute queries that also got a value via feeding.\n@@ -413,48 +417,53 @@ where\n     }\n }\n \n+// Fast path for when incr. comp. is off.\n #[inline(always)]\n-fn execute_job<Q, Qcx>(\n+fn execute_job_non_incr<Q, Qcx>(\n     query: Q,\n     qcx: Qcx,\n     key: Q::Key,\n-    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n     job_id: QueryJobId,\n ) -> (Q::Value, DepNodeIndex)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let dep_graph = qcx.dep_context().dep_graph();\n-    let dep_graph_data = match dep_graph.data() {\n-        // Fast path for when incr. comp. is off.\n-        None => {\n-            // Fingerprint the key, just to assert that it doesn't\n-            // have anything we don't consider hashable\n-            if cfg!(debug_assertions) {\n-                let _ = key.to_fingerprint(*qcx.dep_context());\n-            }\n+    // Fingerprint the key, just to assert that it doesn't\n+    // have anything we don't consider hashable\n+    if cfg!(debug_assertions) {\n+        let _ = key.to_fingerprint(*qcx.dep_context());\n+    }\n \n-            let prof_timer = qcx.dep_context().profiler().query_provider();\n-            let result =\n-                qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n-            let dep_node_index = dep_graph.next_virtual_depnode_index();\n-            prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-\n-            // Similarly, fingerprint the result to assert that\n-            // it doesn't have anything not considered hashable.\n-            if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result()\n-            {\n-                qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n-                    hash_result(&mut hcx, &result);\n-                });\n-            }\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n+    let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n+    let dep_node_index = qcx.dep_context().dep_graph().next_virtual_depnode_index();\n+    prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-            return (result, dep_node_index);\n-        }\n-        Some(data) => data,\n-    };\n+    // Similarly, fingerprint the result to assert that\n+    // it doesn't have anything not considered hashable.\n+    if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result() {\n+        qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+            hash_result(&mut hcx, &result);\n+        });\n+    }\n \n+    (result, dep_node_index)\n+}\n+\n+#[inline(always)]\n+fn execute_job_incr<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    dep_graph_data: &DepGraphData<Qcx::DepKind>,\n+    key: Q::Key,\n+    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n+    job_id: QueryJobId,\n+) -> (Q::Value, DepNodeIndex)\n+where\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n+{\n     if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node ="}]}