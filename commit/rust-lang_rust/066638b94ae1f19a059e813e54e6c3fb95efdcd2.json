{"sha": "066638b94ae1f19a059e813e54e6c3fb95efdcd2", "node_id": "C_kwDOAAsO6NoAKDA2NjYzOGI5NGFlMWYxOWEwNTllODEzZTU0ZTZjM2ZiOTVlZmRjZDI", "commit": {"author": {"name": "Obei Sideg", "email": "obei.sideg@gmail.com", "date": "2023-04-06T23:04:42Z"}, "committer": {"name": "Obei Sideg", "email": "obei.sideg@gmail.com", "date": "2023-04-07T22:24:54Z"}, "message": "Migrate `rustc_hir_analysis` to session diagnostic\n\nPart 3: Finishing `collect.rs` file", "tree": {"sha": "99b4fbee047b653126c170485e515ed27dd92284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b4fbee047b653126c170485e515ed27dd92284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066638b94ae1f19a059e813e54e6c3fb95efdcd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066638b94ae1f19a059e813e54e6c3fb95efdcd2", "html_url": "https://github.com/rust-lang/rust/commit/066638b94ae1f19a059e813e54e6c3fb95efdcd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066638b94ae1f19a059e813e54e6c3fb95efdcd2/comments", "author": {"login": "obeis", "id": 54103142, "node_id": "MDQ6VXNlcjU0MTAzMTQy", "avatar_url": "https://avatars.githubusercontent.com/u/54103142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/obeis", "html_url": "https://github.com/obeis", "followers_url": "https://api.github.com/users/obeis/followers", "following_url": "https://api.github.com/users/obeis/following{/other_user}", "gists_url": "https://api.github.com/users/obeis/gists{/gist_id}", "starred_url": "https://api.github.com/users/obeis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/obeis/subscriptions", "organizations_url": "https://api.github.com/users/obeis/orgs", "repos_url": "https://api.github.com/users/obeis/repos", "events_url": "https://api.github.com/users/obeis/events{/privacy}", "received_events_url": "https://api.github.com/users/obeis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "obeis", "id": 54103142, "node_id": "MDQ6VXNlcjU0MTAzMTQy", "avatar_url": "https://avatars.githubusercontent.com/u/54103142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/obeis", "html_url": "https://github.com/obeis", "followers_url": "https://api.github.com/users/obeis/followers", "following_url": "https://api.github.com/users/obeis/following{/other_user}", "gists_url": "https://api.github.com/users/obeis/gists{/gist_id}", "starred_url": "https://api.github.com/users/obeis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/obeis/subscriptions", "organizations_url": "https://api.github.com/users/obeis/orgs", "repos_url": "https://api.github.com/users/obeis/repos", "events_url": "https://api.github.com/users/obeis/events{/privacy}", "received_events_url": "https://api.github.com/users/obeis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de74dab880447f5227030b261dbd0f2bc4f32dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/de74dab880447f5227030b261dbd0f2bc4f32dba", "html_url": "https://github.com/rust-lang/rust/commit/de74dab880447f5227030b261dbd0f2bc4f32dba"}], "stats": {"total": 325, "additions": 215, "deletions": 110}, "files": [{"sha": "1d7965ff5f66e544361e4ebb1a6e027a936a0fc7", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/066638b94ae1f19a059e813e54e6c3fb95efdcd2/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/066638b94ae1f19a059e813e54e6c3fb95efdcd2/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=066638b94ae1f19a059e813e54e6c3fb95efdcd2", "patch": "@@ -189,3 +189,39 @@ hir_analysis_return_type_notation_equality_bound =\n \n hir_analysis_return_type_notation_missing_method =\n     cannot find associated function `{$assoc_name}` in trait `{$trait_name}`\n+\n+hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n+    .label = not allowed in type signatures\n+\n+hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n+    .suggestion = use a fully qualified path with inferred lifetimes\n+\n+hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n+\n+hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n+    .label = overflowed on value after {$discr}\n+    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n+\n+hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n+    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n+\n+hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n+\n+hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n+\n+hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n+    .note = required by this annotation\n+\n+hir_analysis_must_implement_not_function = not a function\n+\n+hir_analysis_must_implement_not_function_span_note = required by this annotation\n+\n+hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n+\n+hir_analysis_function_not_found_in_trait = function not found in this trait\n+\n+hir_analysis_functions_names_duplicated = functions names are duplicated\n+    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n+    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable"}, {"sha": "50862e3426238420bbe1d563c02ee13a8e924955", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 55, "deletions": 110, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/066638b94ae1f19a059e813e54e6c3fb95efdcd2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066638b94ae1f19a059e813e54e6c3fb95efdcd2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=066638b94ae1f19a059e813e54e6c3fb95efdcd2", "patch": "@@ -20,7 +20,7 @@ use crate::errors;\n use hir::def::DefKind;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n@@ -333,17 +333,7 @@ fn bad_placeholder<'tcx>(\n     let kind = if kind.ends_with('s') { format!(\"{}es\", kind) } else { format!(\"{}s\", kind) };\n \n     spans.sort();\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        spans.clone(),\n-        E0121,\n-        \"the placeholder `_` is not allowed within types on item signatures for {}\",\n-        kind\n-    );\n-    for span in spans {\n-        err.span_label(span, \"not allowed in type signatures\");\n-    }\n-    err\n+    tcx.sess.create_err(errors::PlaceholderNotAllowedItemSignatures { spans, kind })\n }\n \n impl<'tcx> ItemCtxt<'tcx> {\n@@ -419,13 +409,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n             self.tcx().mk_projection(item_def_id, item_substs)\n         } else {\n             // There are no late-bound regions; we can just ignore the binder.\n-            let mut err = struct_span_err!(\n-                self.tcx().sess,\n-                span,\n-                E0212,\n-                \"cannot use the associated type of a trait \\\n-                 with uninferred generic parameters\"\n-            );\n+            let (mut mpart_sugg, mut inferred_sugg) = (None, None);\n+            let mut bound = String::new();\n \n             match self.node() {\n                 hir::Node::Field(_) | hir::Node::Ctor(_) | hir::Node::Variant(_) => {\n@@ -444,31 +429,25 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                                     (bound.span.shrink_to_lo(), format!(\"{}, \", lt_name))\n                                 }\n                             };\n-                            let suggestions = vec![\n-                                (lt_sp, sugg),\n-                                (\n-                                    span.with_hi(item_segment.ident.span.lo()),\n-                                    format!(\n-                                        \"{}::\",\n-                                        // Replace the existing lifetimes with a new named lifetime.\n-                                        self.tcx.replace_late_bound_regions_uncached(\n-                                            poly_trait_ref,\n-                                            |_| {\n-                                                self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                                                    def_id: item_def_id,\n-                                                    index: 0,\n-                                                    name: Symbol::intern(&lt_name),\n-                                                })\n-                                            }\n-                                        ),\n+                            mpart_sugg = Some(errors::AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion {\n+                                fspan: lt_sp,\n+                                first: sugg,\n+                                sspan: span.with_hi(item_segment.ident.span.lo()),\n+                                second: format!(\n+                                    \"{}::\",\n+                                    // Replace the existing lifetimes with a new named lifetime.\n+                                    self.tcx.replace_late_bound_regions_uncached(\n+                                        poly_trait_ref,\n+                                        |_| {\n+                                            self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                                                def_id: item_def_id,\n+                                                index: 0,\n+                                                name: Symbol::intern(&lt_name),\n+                                            })\n+                                        }\n                                     ),\n                                 ),\n-                            ];\n-                            err.multipart_suggestion(\n-                                \"use a fully qualified path with explicit lifetimes\",\n-                                suggestions,\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            });\n                         }\n                         _ => {}\n                     }\n@@ -482,20 +461,23 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 | hir::Node::ForeignItem(_)\n                 | hir::Node::TraitItem(_)\n                 | hir::Node::ImplItem(_) => {\n-                    err.span_suggestion_verbose(\n-                        span.with_hi(item_segment.ident.span.lo()),\n-                        \"use a fully qualified path with inferred lifetimes\",\n-                        format!(\n-                            \"{}::\",\n-                            // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n-                            self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n-                        ),\n-                        Applicability::MaybeIncorrect,\n+                    inferred_sugg = Some(span.with_hi(item_segment.ident.span.lo()));\n+                    bound = format!(\n+                        \"{}::\",\n+                        // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n+                        self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n                     );\n                 }\n                 _ => {}\n             }\n-            self.tcx().ty_error(err.emit())\n+            self.tcx().ty_error(self.tcx().sess.emit_err(\n+                errors::AssociatedTypeTraitUninferredGenericParams {\n+                    span,\n+                    inferred_sugg,\n+                    bound,\n+                    mpart_sugg,\n+                },\n+            ))\n         }\n     }\n \n@@ -763,14 +745,12 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n                 Some(discr)\n             } else {\n                 let span = tcx.def_span(variant.def_id);\n-                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n-                    .note(&format!(\n-                        \"explicitly set `{} = {}` if that is desired outcome\",\n-                        tcx.item_name(variant.def_id),\n-                        wrapped_discr\n-                    ))\n-                    .emit();\n+                tcx.sess.emit_err(errors::EnumDiscriminantOverflowed {\n+                    span,\n+                    discr: prev_discr.unwrap().to_string(),\n+                    item_name: tcx.item_name(variant.def_id),\n+                    wrapped_discr: wrapped_discr.to_string(),\n+                });\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n@@ -915,14 +895,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n \n     let paren_sugar = tcx.has_attr(def_id, sym::rustc_paren_sugar);\n     if paren_sugar && !tcx.features().unboxed_closures {\n-        tcx.sess\n-            .struct_span_err(\n-                item.span,\n-                \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-                 which traits can use parenthetical notation\",\n-            )\n-            .help(\"add `#![feature(unboxed_closures)]` to the crate attributes to use it\")\n-            .emit();\n+        tcx.sess.emit_err(errors::ParenSugarAttribute { span: item.span });\n     }\n \n     let is_marker = tcx.has_attr(def_id, sym::marker);\n@@ -942,13 +915,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n         // and that they are all identifiers\n         .and_then(|attr| match attr.meta_item_list() {\n             Some(items) if items.len() < 2 => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"the `#[rustc_must_implement_one_of]` attribute must be \\\n-                         used with at least 2 args\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::MustImplementOneOfAttribute { span: attr.span });\n \n                 None\n             }\n@@ -957,9 +924,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n                 .map(|item| item.ident().ok_or(item.span()))\n                 .collect::<Result<Box<[_]>, _>>()\n                 .map_err(|span| {\n-                    tcx.sess\n-                        .struct_span_err(span, \"must be a name of an associated function\")\n-                        .emit();\n+                    tcx.sess.emit_err(errors::MustBeNameOfAssociatedFunction { span });\n                 })\n                 .ok()\n                 .zip(Some(attr.span)),\n@@ -975,33 +940,25 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n                 match item {\n                     Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n                         if !tcx.impl_defaultness(item.id.owner_id).has_value() {\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    item.span,\n-                                    \"function doesn't have a default implementation\",\n-                                )\n-                                .span_note(attr_span, \"required by this annotation\")\n-                                .emit();\n+                            tcx.sess.emit_err(errors::FunctionNotHaveDefaultImplementation {\n+                                span: item.span,\n+                                note_span: attr_span,\n+                            });\n \n                             return Some(());\n                         }\n \n                         return None;\n                     }\n                     Some(item) => {\n-                        tcx.sess\n-                            .struct_span_err(item.span, \"not a function\")\n-                            .span_note(attr_span, \"required by this annotation\")\n-                            .note(\n-                                \"all `#[rustc_must_implement_one_of]` arguments must be associated \\\n-                                 function names\",\n-                            )\n-                            .emit();\n+                        tcx.sess.emit_err(errors::MustImplementNotFunction {\n+                            span: item.span,\n+                            span_note: errors::MustImplementNotFunctionSpanNote { span: attr_span },\n+                            note: errors::MustImplementNotFunctionNote {},\n+                        });\n                     }\n                     None => {\n-                        tcx.sess\n-                            .struct_span_err(ident.span, \"function not found in this trait\")\n-                            .emit();\n+                        tcx.sess.emit_err(errors::FunctionNotFoundInTrait { span: ident.span });\n                     }\n                 }\n \n@@ -1018,9 +975,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n             for ident in &*list {\n                 if let Some(dup) = set.insert(ident.name, ident.span) {\n                     tcx.sess\n-                        .struct_span_err(vec![dup, ident.span], \"functions names are duplicated\")\n-                        .note(\"all `#[rustc_must_implement_one_of]` arguments must be unique\")\n-                        .emit();\n+                        .emit_err(errors::FunctionNamesDuplicated { spans: vec![dup, ident.span] });\n \n                     no_dups = false;\n                 }\n@@ -1485,17 +1440,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .source_map()\n                     .span_to_snippet(ast_ty.span)\n                     .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s));\n-                tcx.sess\n-                    .struct_span_err(\n-                        ast_ty.span,\n-                        &format!(\n-                            \"use of SIMD type{} in FFI is highly experimental and \\\n-                             may result in invalid code\",\n-                            snip\n-                        ),\n-                    )\n-                    .help(\"add `#![feature(simd_ffi)]` to the crate attributes to enable\")\n-                    .emit();\n+                tcx.sess.emit_err(errors::SIMDFFIHighlyExperimental { span: ast_ty.span, snip });\n             }\n         };\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {"}, {"sha": "2a3a683489ddd21b5a5dcff9c175c9d741a7b7c2", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/066638b94ae1f19a059e813e54e6c3fb95efdcd2/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066638b94ae1f19a059e813e54e6c3fb95efdcd2/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=066638b94ae1f19a059e813e54e6c3fb95efdcd2", "patch": "@@ -507,3 +507,127 @@ pub(crate) struct ReturnTypeNotationMissingMethod {\n     pub trait_name: Symbol,\n     pub assoc_name: Symbol,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_placeholder_not_allowed_item_signatures, code = \"E0121\")]\n+pub(crate) struct PlaceholderNotAllowedItemSignatures {\n+    #[primary_span]\n+    #[label]\n+    pub spans: Vec<Span>,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_associated_type_trait_uninferred_generic_params, code = \"E0212\")]\n+pub(crate) struct AssociatedTypeTraitUninferredGenericParams {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(style = \"verbose\", applicability = \"maybe-incorrect\", code = \"{bound}\")]\n+    pub inferred_sugg: Option<Span>,\n+    pub bound: String,\n+    #[subdiagnostic]\n+    pub mpart_sugg: Option<AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion,\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion {\n+    #[suggestion_part(code = \"{first}\")]\n+    pub fspan: Span,\n+    pub first: String,\n+    #[suggestion_part(code = \"{second}\")]\n+    pub sspan: Span,\n+    pub second: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_enum_discriminant_overflowed, code = \"E0370\")]\n+#[note]\n+pub(crate) struct EnumDiscriminantOverflowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub discr: String,\n+    pub item_name: Symbol,\n+    pub wrapped_discr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_paren_sugar_attribute)]\n+#[help]\n+pub(crate) struct ParenSugarAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_implement_one_of_attribute)]\n+pub(crate) struct MustImplementOneOfAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_be_name_of_associated_function)]\n+pub(crate) struct MustBeNameOfAssociatedFunction {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_function_not_have_default_implementation)]\n+pub(crate) struct FunctionNotHaveDefaultImplementation {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub note_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_implement_not_function)]\n+pub(crate) struct MustImplementNotFunction {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub span_note: MustImplementNotFunctionSpanNote,\n+    #[subdiagnostic]\n+    pub note: MustImplementNotFunctionNote,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(hir_analysis_must_implement_not_function_span_note)]\n+pub(crate) struct MustImplementNotFunctionSpanNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(hir_analysis_must_implement_not_function_note)]\n+pub(crate) struct MustImplementNotFunctionNote {}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_function_not_found_in_trait)]\n+pub(crate) struct FunctionNotFoundInTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_functions_names_duplicated)]\n+#[note]\n+pub(crate) struct FunctionNamesDuplicated {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_simd_ffi_highly_experimental)]\n+#[help]\n+pub(crate) struct SIMDFFIHighlyExperimental {\n+    #[primary_span]\n+    pub span: Span,\n+    pub snip: String,\n+}"}]}