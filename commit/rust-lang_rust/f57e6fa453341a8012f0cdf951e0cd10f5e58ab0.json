{"sha": "f57e6fa453341a8012f0cdf951e0cd10f5e58ab0", "node_id": "C_kwDOAAsO6NoAKGY1N2U2ZmE0NTMzNDFhODAxMmYwY2RmOTUxZTBjZDEwZjVlNThhYjA", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-08-17T10:54:12Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-08-17T10:54:12Z"}, "message": "`compare_predicate_entailment` move comment", "tree": {"sha": "b8d4f541150371dac49839790097f050a8a46e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8d4f541150371dac49839790097f050a8a46e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f57e6fa453341a8012f0cdf951e0cd10f5e58ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f57e6fa453341a8012f0cdf951e0cd10f5e58ab0", "html_url": "https://github.com/rust-lang/rust/commit/f57e6fa453341a8012f0cdf951e0cd10f5e58ab0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f57e6fa453341a8012f0cdf951e0cd10f5e58ab0/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe666ee64d9f2a73571f0ab74a29cd30190573e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe666ee64d9f2a73571f0ab74a29cd30190573e", "html_url": "https://github.com/rust-lang/rust/commit/4fe666ee64d9f2a73571f0ab74a29cd30190573e"}], "stats": {"total": 129, "additions": 66, "deletions": 63}, "files": [{"sha": "0716b3bc6708b5c4a408ffb3f1252001d7cd5f9f", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/f57e6fa453341a8012f0cdf951e0cd10f5e58ab0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f57e6fa453341a8012f0cdf951e0cd10f5e58ab0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=f57e6fa453341a8012f0cdf951e0cd10f5e58ab0", "patch": "@@ -70,6 +70,72 @@ pub(crate) fn compare_impl_method<'tcx>(\n     }\n }\n \n+/// This function is best explained by example. Consider a trait:\n+///\n+///     trait Trait<'t, T> {\n+///         // `trait_m`\n+///         fn method<'a, M>(t: &'t T, m: &'a M) -> Self;\n+///     }\n+///\n+/// And an impl:\n+///\n+///     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n+///          // `impl_m`\n+///          fn method<'b, N>(t: &'j &'i U, m: &'b N) -> Foo;\n+///     }\n+///\n+/// We wish to decide if those two method types are compatible.\n+/// For this we have to show that, assuming the bounds of the impl hold, the\n+/// bounds of `trait_m` imply the bounds of `impl_m`.\n+///\n+/// We start out with `trait_to_impl_substs`, that maps the trait\n+/// type parameters to impl type parameters. This is taken from the\n+/// impl trait reference:\n+///\n+///     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n+///\n+/// We create a mapping `dummy_substs` that maps from the impl type\n+/// parameters to fresh types and regions. For type parameters,\n+/// this is the identity transform, but we could as well use any\n+/// placeholder types. For regions, we convert from bound to free\n+/// regions (Note: but only early-bound regions, i.e., those\n+/// declared on the impl or used in type parameter bounds).\n+///\n+///     impl_to_placeholder_substs = {'i => 'i0, U => U0, N => N0 }\n+///\n+/// Now we can apply `placeholder_substs` to the type of the impl method\n+/// to yield a new function type in terms of our fresh, placeholder\n+/// types:\n+///\n+///     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n+///\n+/// We now want to extract and substitute the type of the *trait*\n+/// method and compare it. To do so, we must create a compound\n+/// substitution by combining `trait_to_impl_substs` and\n+/// `impl_to_placeholder_substs`, and also adding a mapping for the method\n+/// type parameters. We extend the mapping to also include\n+/// the method parameters.\n+///\n+///     trait_to_placeholder_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n+///\n+/// Applying this to the trait method type yields:\n+///\n+///     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n+///\n+/// This type is also the same but the name of the bound region (`'a`\n+/// vs `'b`).  However, the normal subtyping rules on fn types handle\n+/// this kind of equivalency just fine.\n+///\n+/// We now use these substitutions to ensure that all declared bounds are\n+/// satisfied by the implementation's method.\n+///\n+/// We do this by creating a parameter environment which contains a\n+/// substitution corresponding to `impl_to_placeholder_substs`. We then build\n+/// `trait_to_placeholder_substs` and use it to convert the predicates contained\n+/// in the `trait_m` generics to the placeholder form.\n+///\n+/// Finally we register each of these predicates as an obligation and check that\n+/// they hold.\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n@@ -96,69 +162,6 @@ fn compare_predicate_entailment<'tcx>(\n         },\n     );\n \n-    // This code is best explained by example. Consider a trait:\n-    //\n-    //     trait Trait<'t, T> {\n-    //         fn method<'a, M>(t: &'t T, m: &'a M) -> Self;\n-    //     }\n-    //\n-    // And an impl:\n-    //\n-    //     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n-    //          fn method<'b, N>(t: &'j &'i U, m: &'b N) -> Foo;\n-    //     }\n-    //\n-    // We wish to decide if those two method types are compatible.\n-    //\n-    // We start out with trait_to_impl_substs, that maps the trait\n-    // type parameters to impl type parameters. This is taken from the\n-    // impl trait reference:\n-    //\n-    //     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n-    //\n-    // We create a mapping `dummy_substs` that maps from the impl type\n-    // parameters to fresh types and regions. For type parameters,\n-    // this is the identity transform, but we could as well use any\n-    // placeholder types. For regions, we convert from bound to free\n-    // regions (Note: but only early-bound regions, i.e., those\n-    // declared on the impl or used in type parameter bounds).\n-    //\n-    //     impl_to_placeholder_substs = {'i => 'i0, U => U0, N => N0 }\n-    //\n-    // Now we can apply placeholder_substs to the type of the impl method\n-    // to yield a new function type in terms of our fresh, placeholder\n-    // types:\n-    //\n-    //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n-    //\n-    // We now want to extract and substitute the type of the *trait*\n-    // method and compare it. To do so, we must create a compound\n-    // substitution by combining trait_to_impl_substs and\n-    // impl_to_placeholder_substs, and also adding a mapping for the method\n-    // type parameters. We extend the mapping to also include\n-    // the method parameters.\n-    //\n-    //     trait_to_placeholder_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n-    //\n-    // Applying this to the trait method type yields:\n-    //\n-    //     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n-    //\n-    // This type is also the same but the name of the bound region ('a\n-    // vs 'b).  However, the normal subtyping rules on fn types handle\n-    // this kind of equivalency just fine.\n-    //\n-    // We now use these substitutions to ensure that all declared bounds are\n-    // satisfied by the implementation's method.\n-    //\n-    // We do this by creating a parameter environment which contains a\n-    // substitution corresponding to impl_to_placeholder_substs. We then build\n-    // trait_to_placeholder_substs and use it to convert the predicates contained\n-    // in the trait_m.generics to the placeholder form.\n-    //\n-    // Finally we register each of these predicates as an obligation in\n-    // a fresh FulfillmentCtxt, and invoke select_all_or_error.\n-\n     // Create mapping from impl to placeholder.\n     let impl_to_placeholder_substs = InternalSubsts::identity_for_item(tcx, impl_m.def_id);\n "}]}