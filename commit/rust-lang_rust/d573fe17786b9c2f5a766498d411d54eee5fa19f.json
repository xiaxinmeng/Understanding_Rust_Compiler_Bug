{"sha": "d573fe17786b9c2f5a766498d411d54eee5fa19f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NzNmZTE3Nzg2YjljMmY1YTc2NjQ5OGQ0MTFkNTRlZWU1ZmExOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-11T16:24:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-11T16:24:46Z"}, "message": "Auto merge of #51702 - ecstatic-morse:infinite-loop-detection, r=oli-obk\n\nInfinite loop detection for const evaluation\n\nResolves #50637.\n\nAn `EvalContext` stores the transient state (stack, heap, etc.) of the MIRI virtual machine while it executing code. As long as MIRI only executes pure functions, we can detect if a program is in a state where it will never terminate by periodically taking a \"snapshot\" of this transient state and comparing it to previous ones. If any two states are exactly equal, the machine must be in an infinite loop.\n\nInstead of fully cloning a snapshot every time the detector is run, we store a snapshot's hash. Only when a hash collision occurs do we fully clone the interpreter state. Future snapshots which cause a collision will be compared against this clone, causing the interpreter to abort if they are equal.\n\nAt the moment, snapshots are not taken until MIRI has progressed a certain amount. After this threshold, snapshots are taken every `DETECTOR_SNAPSHOT_PERIOD` steps. This means that an infinite loop with period `P` will be detected after a maximum of `2 * P * DETECTOR_SNAPSHOT_PERIOD` interpreter steps. The factor of 2 arises because we only clone a snapshot after it causes a hash collision.", "tree": {"sha": "03d5b85004a849dff84569e88063e24b4826f8f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03d5b85004a849dff84569e88063e24b4826f8f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d573fe17786b9c2f5a766498d411d54eee5fa19f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d573fe17786b9c2f5a766498d411d54eee5fa19f", "html_url": "https://github.com/rust-lang/rust/commit/d573fe17786b9c2f5a766498d411d54eee5fa19f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d573fe17786b9c2f5a766498d411d54eee5fa19f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66787e05242d86e0bcfa227265559330c45cdc42", "url": "https://api.github.com/repos/rust-lang/rust/commits/66787e05242d86e0bcfa227265559330c45cdc42", "html_url": "https://github.com/rust-lang/rust/commit/66787e05242d86e0bcfa227265559330c45cdc42"}, {"sha": "cf5eaa75bb171f00d6baa475333b741b86f93f72", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5eaa75bb171f00d6baa475333b741b86f93f72", "html_url": "https://github.com/rust-lang/rust/commit/cf5eaa75bb171f00d6baa475333b741b86f93f72"}], "stats": {"total": 327, "additions": 301, "deletions": 26}, "files": [{"sha": "a3600c04800176d447f14787779c65d76ca765a1", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -549,7 +549,8 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             RemainderByZero |\n             DivisionByZero |\n             GeneratorResumedAfterReturn |\n-            GeneratorResumedAfterPanic => {}\n+            GeneratorResumedAfterPanic |\n+            InfiniteLoop => {}\n             ReferencedConstant(ref err) => err.hash_stable(hcx, hasher),\n             MachineError(ref err) => err.hash_stable(hcx, hasher),\n             FunctionPointerTyMismatch(a, b) => {"}, {"sha": "9125597a7273eeae9558950f429b010099a0bbbb", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -264,6 +264,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     ReferencedConstant(Lrc<ConstEvalErr<'tcx>>),\n     GeneratorResumedAfterReturn,\n     GeneratorResumedAfterPanic,\n+    InfiniteLoop,\n }\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n@@ -398,6 +399,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n             RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n             GeneratorResumedAfterReturn => \"generator resumed after completion\",\n             GeneratorResumedAfterPanic => \"generator resumed after panicking\",\n+            InfiniteLoop =>\n+                \"duplicate interpreter state observed here, const evaluation will never terminate\",\n         }\n     }\n }"}, {"sha": "4164fe3fd933b80a8c65eb7c300127a94a0d4539", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -36,7 +36,7 @@ use ty::codec::TyDecoder;\n use std::sync::atomic::{AtomicU32, Ordering};\n use std::num::NonZeroU32;\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Lock {\n     NoLock,\n     WriteLock(DynamicLifetime),"}, {"sha": "fd443d8973c1c7415e7361bd48660b54df514d5d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -1636,7 +1636,7 @@ impl Debug for ValidationOp {\n }\n \n // This is generic so that it can be reused by miri\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct ValidationOperand<'tcx, T> {\n     pub place: T,\n     pub ty: Ty<'tcx>,"}, {"sha": "874dabaf1c9e773cc6e052b76de9cf6cead06cf3", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -587,6 +587,7 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n             RemainderByZero => RemainderByZero,\n             GeneratorResumedAfterReturn => GeneratorResumedAfterReturn,\n             GeneratorResumedAfterPanic => GeneratorResumedAfterPanic,\n+            InfiniteLoop => InfiniteLoop,\n         })\n     }\n }"}, {"sha": "e84132f27cc62d66090b1f535c63aa6ec8b80f7f", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -185,6 +185,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     Ok((value, ptr, layout.ty))\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub struct CompileTimeEvaluator;\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {"}, {"sha": "a92c81e046a0ffd9f01d650d54875ab30191c272", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 130, "deletions": 10, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -1,4 +1,5 @@\n use std::fmt::Write;\n+use std::hash::{Hash, Hasher};\n use std::mem;\n \n use rustc::hir::def_id::DefId;\n@@ -9,6 +10,7 @@ use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf,\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n use rustc::ty::query::TyCtxtAt;\n+use rustc_data_structures::fx::{FxHashSet, FxHasher};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::mir::interpret::{\n     FrameInfo, GlobalId, Value, Scalar,\n@@ -41,13 +43,17 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n \n-    /// The maximum number of terminators that may be evaluated.\n-    /// This prevents infinite loops and huge computations from freezing up const eval.\n-    /// Remove once halting problem is solved.\n-    pub(crate) terminators_remaining: usize,\n+    /// When this value is negative, it indicates the number of interpreter\n+    /// steps *until* the loop detector is enabled. When it is positive, it is\n+    /// the number of steps after the detector has been enabled modulo the loop\n+    /// detector period.\n+    pub(crate) steps_since_detector_enabled: isize,\n+\n+    pub(crate) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n /// A stack frame.\n+#[derive(Clone)]\n pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n@@ -89,6 +95,121 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n+impl<'mir, 'tcx: 'mir> Eq for Frame<'mir, 'tcx> {}\n+\n+impl<'mir, 'tcx: 'mir> PartialEq for Frame<'mir, 'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        let Frame {\n+            mir: _,\n+            instance,\n+            span: _,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        // Some of these are constant during evaluation, but are included\n+        // anyways for correctness.\n+        *instance == other.instance\n+            && *return_to_block == other.return_to_block\n+            && *return_place == other.return_place\n+            && *locals == other.locals\n+            && *block == other.block\n+            && *stmt == other.stmt\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let Frame {\n+            mir: _,\n+            instance,\n+            span: _,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        instance.hash(state);\n+        return_to_block.hash(state);\n+        return_place.hash(state);\n+        locals.hash(state);\n+        block.hash(state);\n+        stmt.hash(state);\n+    }\n+}\n+\n+/// The virtual machine state during const-evaluation at a given point in time.\n+type EvalSnapshot<'a, 'mir, 'tcx, M>\n+    = (M, Vec<Frame<'mir, 'tcx>>, Memory<'a, 'mir, 'tcx, M>);\n+\n+pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n+    ///\n+    /// When a collision occurs in this table, we store the full snapshot in\n+    /// `snapshots`.\n+    hashes: FxHashSet<u64>,\n+\n+    /// The set of all `EvalSnapshot`s observed by this detector.\n+    ///\n+    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n+    /// collision in `hashes`. As a result, the detector must observe at least\n+    /// *two* full cycles of an infinite loop before it triggers.\n+    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn default() -> Self {\n+        InfiniteLoopDetector {\n+            hashes: FxHashSet::default(),\n+            snapshots: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    /// Returns `true` if the loop detector has not yet observed a snapshot.\n+    pub fn is_empty(&self) -> bool {\n+        self.hashes.is_empty()\n+    }\n+\n+    pub fn observe_and_analyze(\n+        &mut self,\n+        machine: &M,\n+        stack: &Vec<Frame<'mir, 'tcx>>,\n+        memory: &Memory<'a, 'mir, 'tcx, M>,\n+    ) -> EvalResult<'tcx, ()> {\n+        let snapshot = (machine, stack, memory);\n+\n+        let mut fx = FxHasher::default();\n+        snapshot.hash(&mut fx);\n+        let hash = fx.finish();\n+\n+        if self.hashes.insert(hash) {\n+            // No collision\n+            return Ok(())\n+        }\n+\n+        if self.snapshots.insert((machine.clone(), stack.clone(), memory.clone())) {\n+            // Spurious collision or first cycle\n+            return Ok(())\n+        }\n+\n+        // Second cycle\n+        Err(EvalErrorKind::InfiniteLoop.into())\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// The stackframe existed to compute the initial value of a static/constant, make sure it\n@@ -173,7 +294,7 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n     }\n }\n \n-const MAX_TERMINATORS: usize = 1_000_000;\n+const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n \n impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n@@ -189,16 +310,17 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n             stack_limit: tcx.sess.const_eval_stack_frame_limit,\n-            terminators_remaining: MAX_TERMINATORS,\n+            loop_detector: Default::default(),\n+            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n         }\n     }\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n         let stack = mem::replace(&mut self.stack, Vec::new());\n-        let terminators_remaining = mem::replace(&mut self.terminators_remaining, MAX_TERMINATORS);\n+        let steps = mem::replace(&mut self.steps_since_detector_enabled, -STEPS_UNTIL_DETECTOR_ENABLED);\n         let r = f(self);\n         self.stack = stack;\n-        self.terminators_remaining = terminators_remaining;\n+        self.steps_since_detector_enabled = steps;\n         r\n     }\n \n@@ -538,8 +660,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             Aggregate(ref kind, ref operands) => {\n-                self.inc_step_counter_and_check_limit(operands.len());\n-\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         self.write_discriminant_value(dest_ty, dest, variant_index)?;"}, {"sha": "e2086c57c7c7c5ee53da4097bda0f93610809dac", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -2,6 +2,8 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n+use std::hash::Hash;\n+\n use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n use super::{EvalContext, Place, ValTy, Memory};\n \n@@ -13,9 +15,9 @@ use syntax::ast::Mutability;\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'mir, 'tcx>: Sized {\n+pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData;\n+    type MemoryData: Clone + Eq + Hash;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + PartialEq + Copy + Clone;"}, {"sha": "ac4d1c74b8cc1296d8e15eab450cc600ebabfa08", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -1,4 +1,5 @@\n use std::collections::VecDeque;\n+use std::hash::{Hash, Hasher};\n use std::ptr;\n \n use rustc::hir::def_id::DefId;\n@@ -9,7 +10,7 @@ use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n \n@@ -19,7 +20,7 @@ use super::{EvalContext, Machine};\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Debug, PartialEq, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n@@ -31,6 +32,7 @@ pub enum MemoryKind<T> {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[derive(Clone)]\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n@@ -47,6 +49,64 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n+impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{}\n+\n+impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        let Memory {\n+            data,\n+            alloc_kind,\n+            alloc_map,\n+            cur_frame,\n+            tcx: _,\n+        } = self;\n+\n+        *data == other.data\n+            && *alloc_kind == other.alloc_kind\n+            && *alloc_map == other.alloc_map\n+            && *cur_frame == other.cur_frame\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let Memory {\n+            data,\n+            alloc_kind: _,\n+            alloc_map: _,\n+            cur_frame,\n+            tcx: _,\n+        } = self;\n+\n+        data.hash(state);\n+        cur_frame.hash(state);\n+\n+        // We ignore some fields which don't change between evaluation steps.\n+\n+        // Since HashMaps which contain the same items may have different\n+        // iteration orders, we use a commutative operation (in this case\n+        // addition, but XOR would also work), to combine the hash of each\n+        // `Allocation`.\n+        self.allocations()\n+            .map(|allocs| {\n+                let mut h = FxHasher::default();\n+                allocs.hash(&mut h);\n+                h.finish()\n+            })\n+            .fold(0u64, |hash, x| hash.wrapping_add(x))\n+            .hash(state);\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n@@ -866,7 +926,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         for i in 0..size.bytes() {\n             let defined = undef_mask.get(src.offset + Size::from_bytes(i));\n-            \n+\n             for j in 0..repeat {\n                 dest_allocation.undef_mask.set(\n                     dest.offset + Size::from_bytes(i + (size.bytes() * j)),"}, {"sha": "bb8e5c99d499be8fc3e64017db1fff181a851d1a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr {\n@@ -24,7 +24,7 @@ pub enum Place {\n     Local { frame: usize, local: mir::Local },\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum PlaceExtra {\n     None,\n     Length(u64),"}, {"sha": "db90714d0e6231d7b747fa142f8c6e21d112ac00", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -8,13 +8,34 @@ use rustc::mir::interpret::EvalResult;\n use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn inc_step_counter_and_check_limit(&mut self, n: usize) {\n-        self.terminators_remaining = self.terminators_remaining.saturating_sub(n);\n-        if self.terminators_remaining == 0 {\n+    pub fn inc_step_counter_and_detect_loops(&mut self) -> EvalResult<'tcx, ()> {\n+        /// The number of steps between loop detector snapshots.\n+        /// Should be a power of two for performance reasons.\n+        const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n+\n+        {\n+            let steps = &mut self.steps_since_detector_enabled;\n+\n+            *steps += 1;\n+            if *steps < 0 {\n+                return Ok(());\n+            }\n+\n+            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n+            if *steps != 0 {\n+                return Ok(());\n+            }\n+        }\n+\n+        if self.loop_detector.is_empty() {\n+            // First run of the loop detector\n+\n             // FIXME(#49980): make this warning a lint\n-            self.tcx.sess.span_warn(self.frame().span, \"Constant evaluating a complex constant, this might take some time\");\n-            self.terminators_remaining = 1_000_000;\n+            self.tcx.sess.span_warn(self.frame().span,\n+                \"Constant evaluating a complex constant, this might take some time\");\n         }\n+\n+        self.loop_detector.observe_and_analyze(&self.machine, &self.stack, &self.memory)\n     }\n \n     /// Returns true as long as there are more things to do.\n@@ -36,7 +57,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return Ok(true);\n         }\n \n-        self.inc_step_counter_and_check_limit(1);\n+        self.inc_step_counter_and_detect_loops()?;\n \n         let terminator = basic_block.terminator();\n         assert_eq!(old_frames, self.cur_frame());"}, {"sha": "a1f8ab7f878824f78e0cf1948a0412f7807c6b0e", "filename": "src/test/ui/const-eval/infinite_loop.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Ftest%2Fui%2Fconst-eval%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Ftest%2Fui%2Fconst-eval%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Finfinite_loop.rs?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_let)]\n+\n+fn main() {\n+    // Tests the Collatz conjecture with an incorrect base case (0 instead of 1).\n+    // The value of `n` will loop indefinitely (4 - 2 - 1 - 4).\n+    let _ = [(); {\n+        //~^ WARNING Constant evaluating a complex constant, this might take some time\n+        //~| ERROR could not evaluate repeat length\n+        let mut n = 113383; // #20 in https://oeis.org/A006884\n+        while n != 0 { //~ ERROR constant contains unimplemented expression type\n+            n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n+        }\n+        n\n+    }];\n+}"}, {"sha": "f69aae29203600102a6e20e96a7b9c394ebd6766", "filename": "src/test/ui/const-eval/infinite_loop.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Ftest%2Fui%2Fconst-eval%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d573fe17786b9c2f5a766498d411d54eee5fa19f/src%2Ftest%2Fui%2Fconst-eval%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Finfinite_loop.stderr?ref=d573fe17786b9c2f5a766498d411d54eee5fa19f", "patch": "@@ -0,0 +1,41 @@\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/infinite_loop.rs:20:9\n+   |\n+LL | /         while n != 0 { //~ ERROR constant contains unimplemented expression type\n+LL | |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n+LL | |         }\n+   | |_________^\n+\n+warning: Constant evaluating a complex constant, this might take some time\n+  --> $DIR/infinite_loop.rs:16:18\n+   |\n+LL |       let _ = [(); {\n+   |  __________________^\n+LL | |         //~^ WARNING Constant evaluating a complex constant, this might take some time\n+LL | |         //~| ERROR could not evaluate repeat length\n+LL | |         let mut n = 113383; // #20 in https://oeis.org/A006884\n+...  |\n+LL | |         n\n+LL | |     }];\n+   | |_____^\n+\n+error[E0080]: could not evaluate repeat length\n+  --> $DIR/infinite_loop.rs:16:18\n+   |\n+LL |       let _ = [(); {\n+   |  __________________^\n+LL | |         //~^ WARNING Constant evaluating a complex constant, this might take some time\n+LL | |         //~| ERROR could not evaluate repeat length\n+LL | |         let mut n = 113383; // #20 in https://oeis.org/A006884\n+LL | |         while n != 0 { //~ ERROR constant contains unimplemented expression type\n+LL | |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n+   | |                    ---------- duplicate interpreter state observed here, const evaluation will never terminate\n+LL | |         }\n+LL | |         n\n+LL | |     }];\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0019, E0080.\n+For more information about an error, try `rustc --explain E0019`."}]}