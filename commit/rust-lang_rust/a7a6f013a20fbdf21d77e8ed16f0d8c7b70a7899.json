{"sha": "a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YTZmMDEzYTIwZmJkZjIxZDc3ZThlZDE2ZjBkOGM3YjcwYTc4OTk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-01T13:29:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-01T13:29:28Z"}, "message": "Rollup merge of #78641 - the8472:buffered-copy, r=sfackler\n\nLet io::copy reuse BufWriter buffers\n\nThis optimization will allow users to implicitly set the buffer size for io::copy by wrapping the writer into a `BufWriter` if the default block size is insufficient, which should fix #49921\n\nDue to min_specialization limitations this approach only works with `BufWriter` but not for `BufReader<R>` since `R` is unconstrained and thus the necessary specialization on `R: Read` is not always applicable. Once specialization becomes more powerful this optimization could be extended to look at the reader and writer side and use whichever buffer is larger.", "tree": {"sha": "a429ac3685b6866f890f5a5a1b7871e32dfecab7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a429ac3685b6866f890f5a5a1b7871e32dfecab7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGAI4CRBK7hj4Ov3rIwAAdHIIACHAkrGuVpCmG4GLvFwa96oX\nSODb9jktTWtCwtjveeZmDotdihrSrbn4KYTp0Wsq/HW0lZsWba+KE0eE974xwJcO\nUp4lIsEPZmhpEaVcCbCIrlXpUg9N+XTHRntv/BukqdRQKeLSlWZ5YZRjn1i4puwl\nxh2SCBYQcCl9fUnWW2JRIwghsOApAaGjmZGGbsRveDbBydjBEc0Y9ewe+RmO7Lp0\nzp0eM3XGTrBzAzM+A+MD+C2CE62VUnvNbT2q6r8nbj6MccU0SElQvNZWMPFSW96G\nx9s17HhflW+UEtO+8T0+1iIxJbBiHfU1oAA37ROwaUunlIqWsXKXQa0tAbLsvMw=\n=5JAt\n-----END PGP SIGNATURE-----\n", "payload": "tree a429ac3685b6866f890f5a5a1b7871e32dfecab7\nparent e0d9f793990d20f8f640097e28556886ba5362f0\nparent 410550665601a8abe8935f7b55d5732fe4c4224f\nauthor Jonas Schievink <jonasschievink@gmail.com> 1612186168 +0100\ncommitter GitHub <noreply@github.com> 1612186168 +0100\n\nRollup merge of #78641 - the8472:buffered-copy, r=sfackler\n\nLet io::copy reuse BufWriter buffers\n\nThis optimization will allow users to implicitly set the buffer size for io::copy by wrapping the writer into a `BufWriter` if the default block size is insufficient, which should fix #49921\n\nDue to min_specialization limitations this approach only works with `BufWriter` but not for `BufReader<R>` since `R` is unconstrained and thus the necessary specialization on `R: Read` is not always applicable. Once specialization becomes more powerful this optimization could be extended to look at the reader and writer side and use whichever buffer is larger.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "html_url": "https://github.com/rust-lang/rust/commit/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0d9f793990d20f8f640097e28556886ba5362f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d9f793990d20f8f640097e28556886ba5362f0", "html_url": "https://github.com/rust-lang/rust/commit/e0d9f793990d20f8f640097e28556886ba5362f0"}, {"sha": "410550665601a8abe8935f7b55d5732fe4c4224f", "url": "https://api.github.com/repos/rust-lang/rust/commits/410550665601a8abe8935f7b55d5732fe4c4224f", "html_url": "https://github.com/rust-lang/rust/commit/410550665601a8abe8935f7b55d5732fe4c4224f"}], "stats": {"total": 146, "additions": 138, "deletions": 8}, "files": [{"sha": "65bc2fcf00ae02dc9f8ff23f5cdf7f213e79c401", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "patch": "@@ -117,7 +117,7 @@ impl<W: Write> BufWriter<W> {\n     /// \"successfully written\" (by returning nonzero success values from\n     /// `write`), any 0-length writes from `inner` must be reported as i/o\n     /// errors from this method.\n-    pub(super) fn flush_buf(&mut self) -> io::Result<()> {\n+    pub(in crate::io) fn flush_buf(&mut self) -> io::Result<()> {\n         /// Helper struct to ensure the buffer is updated after all the writes\n         /// are complete. It tracks the number of written bytes and drains them\n         /// all from the front of the buffer when dropped.\n@@ -243,6 +243,18 @@ impl<W: Write> BufWriter<W> {\n         &self.buf\n     }\n \n+    /// Returns a mutable reference to the internal buffer.\n+    ///\n+    /// This can be used to write data directly into the buffer without triggering writers\n+    /// to the underlying writer.\n+    ///\n+    /// That the buffer is a `Vec` is an implementation detail.\n+    /// Callers should not modify the capacity as there currently is no public API to do so\n+    /// and thus any capacity changes would be unexpected by the user.\n+    pub(in crate::io) fn buffer_mut(&mut self) -> &mut Vec<u8> {\n+        &mut self.buf\n+    }\n+\n     /// Returns the number of bytes the internal buffer can hold without flushing.\n     ///\n     /// # Examples"}, {"sha": "3780f2044cb9039659c0d0262a78e4b6c9210e12", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, ErrorKind, Read, Write};\n+use super::{BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -40,7 +40,7 @@ use crate::mem::MaybeUninit;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\n where\n     R: Read,\n     W: Write,\n@@ -54,14 +54,82 @@ where\n     }\n }\n \n-/// The general read-write-loop implementation of\n-/// `io::copy` that is used when specializations are not available or not applicable.\n-pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+/// The userspace read-write-loop implementation of `io::copy` that is used when\n+/// OS-specific specializations for copy offloading are not available or not applicable.\n+pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\n where\n     R: Read,\n     W: Write,\n {\n-    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n+    BufferedCopySpec::copy_to(reader, writer)\n+}\n+\n+/// Specialization of the read-write loop that either uses a stack buffer\n+/// or reuses the internal buffer of a BufWriter\n+trait BufferedCopySpec: Write {\n+    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64>;\n+}\n+\n+impl<W: Write + ?Sized> BufferedCopySpec for W {\n+    default fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n+        stack_buffer_copy(reader, writer)\n+    }\n+}\n+\n+impl<I: Write> BufferedCopySpec for BufWriter<I> {\n+    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n+        if writer.capacity() < DEFAULT_BUF_SIZE {\n+            return stack_buffer_copy(reader, writer);\n+        }\n+\n+        // FIXME: #42788\n+        //\n+        //   - This creates a (mut) reference to a slice of\n+        //     _uninitialized_ integers, which is **undefined behavior**\n+        //\n+        //   - Only the standard library gets to soundly \"ignore\" this,\n+        //     based on its privileged knowledge of unstable rustc\n+        //     internals;\n+        unsafe {\n+            let spare_cap = writer.buffer_mut().spare_capacity_mut();\n+            reader.initializer().initialize(MaybeUninit::slice_assume_init_mut(spare_cap));\n+        }\n+\n+        let mut len = 0;\n+\n+        loop {\n+            let buf = writer.buffer_mut();\n+            let spare_cap = buf.spare_capacity_mut();\n+\n+            if spare_cap.len() >= DEFAULT_BUF_SIZE {\n+                match reader.read(unsafe { MaybeUninit::slice_assume_init_mut(spare_cap) }) {\n+                    Ok(0) => return Ok(len), // EOF reached\n+                    Ok(bytes_read) => {\n+                        assert!(bytes_read <= spare_cap.len());\n+                        // Safety: The initializer contract guarantees that either it or `read`\n+                        // will have initialized these bytes. And we just checked that the number\n+                        // of bytes is within the buffer capacity.\n+                        unsafe { buf.set_len(buf.len() + bytes_read) };\n+                        len += bytes_read as u64;\n+                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n+                        // This will occur if the reader returns short reads\n+                        continue;\n+                    }\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            writer.flush_buf()?;\n+        }\n+    }\n+}\n+\n+fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n+    reader: &mut R,\n+    writer: &mut W,\n+) -> Result<u64> {\n+    let mut buf = MaybeUninit::<[u8; DEFAULT_BUF_SIZE]>::uninit();\n     // FIXME: #42788\n     //\n     //   - This creates a (mut) reference to a slice of"}, {"sha": "7632eaf872a5b01e67a7c55e37e01b0eca9d9f9b", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "patch": "@@ -1,5 +1,8 @@\n+use crate::cmp::{max, min};\n use crate::io::prelude::*;\n-use crate::io::{copy, empty, repeat, sink, Empty, Repeat, SeekFrom, Sink};\n+use crate::io::{\n+    copy, empty, repeat, sink, BufWriter, Empty, Repeat, Result, SeekFrom, Sink, DEFAULT_BUF_SIZE,\n+};\n \n #[test]\n fn copy_copies() {\n@@ -11,6 +14,51 @@ fn copy_copies() {\n     assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n }\n \n+struct ShortReader {\n+    cap: usize,\n+    read_size: usize,\n+    observed_buffer: usize,\n+}\n+\n+impl Read for ShortReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let bytes = min(self.cap, self.read_size);\n+        self.cap -= bytes;\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(bytes)\n+    }\n+}\n+\n+struct WriteObserver {\n+    observed_buffer: usize,\n+}\n+\n+impl Write for WriteObserver {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn copy_specializes_bufwriter() {\n+    let cap = 117 * 1024;\n+    let buf_sz = 16 * 1024;\n+    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n+    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n+    assert_eq!(\n+        copy(&mut r, &mut w).unwrap(),\n+        cap as u64,\n+        \"expected the whole capacity to be copied\"\n+    );\n+    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n+    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n+}\n+\n #[test]\n fn sink_sinks() {\n     let mut s = sink();"}, {"sha": "b6929f59395764f18e6e958e06246ec004249c34", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a7a6f013a20fbdf21d77e8ed16f0d8c7b70a7899", "patch": "@@ -284,6 +284,7 @@\n #![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n@@ -327,6 +328,7 @@\n #![feature(unsafe_cell_raw_get)]\n #![feature(unwind_attributes)]\n #![feature(vec_into_raw_parts)]\n+#![feature(vec_spare_capacity)]\n #![feature(wake_trait)]\n // NB: the above list is sorted to minimize merge conflicts.\n #![default_lib_allocator]"}]}