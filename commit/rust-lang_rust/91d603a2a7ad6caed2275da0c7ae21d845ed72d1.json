{"sha": "91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZDYwM2EyYTdhZDZjYWVkMjI3NWRhMGM3YWUyMWQ4NDVlZDcyZDE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-20T20:52:52Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: move autoref and unsize from Adjust::DerefRef to Adjustment.", "tree": {"sha": "5813dcfc2005240f19eb62696800e735a711d7e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5813dcfc2005240f19eb62696800e735a711d7e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "html_url": "https://github.com/rust-lang/rust/commit/91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a754f224d2ec61268649bc2421b7843b686375b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a754f224d2ec61268649bc2421b7843b686375b", "html_url": "https://github.com/rust-lang/rust/commit/4a754f224d2ec61268649bc2421b7843b686375b"}], "stats": {"total": 594, "additions": 290, "deletions": 304}, "files": [{"sha": "f0fdb94b81b361cfb6ab59b641d7ca643727ca03", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -100,16 +100,14 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n             ty::adjustment::Adjust::MutToConstPointer => {}\n-            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize } => {\n+            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n                 autoderefs.hash_stable(hcx, hasher);\n-                autoref.hash_stable(hcx, hasher);\n-                unsize.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n+impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, autoref, unsize, target });\n impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl, target });\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });"}, {"sha": "9120990777dfaad5a0f23ce5455ea4e0d36d3425", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -707,9 +707,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n         let adj = infcx.tables.borrow().adjustments.get(&expr.id).cloned();\n-        let cmt_unadjusted =\n-            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+        let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         if let Some(adjustment) = adj {\n+            debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n                 adjustment::Adjust::ReifyFnPointer |\n@@ -718,23 +718,20 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::MutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    debug!(\"walk_adjustment: trivial adjustment\");\n-                    self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                    self.delegate_consume(expr.id, expr.span, cmt);\n+                    assert!(adjustment.autoref.is_none() && !adjustment.unsize);\n+                    return;\n                 }\n-                adjustment::Adjust::DerefRef { ref autoderefs, autoref, unsize } => {\n-                    debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n-\n-                    let cmt_derefd =\n-                        return_if_err!(self.walk_autoderefs(expr, cmt_unadjusted, autoderefs));\n+                adjustment::Adjust::Deref(ref autoderefs) => {\n+                    cmt = return_if_err!(self.walk_autoderefs(expr, cmt, autoderefs));\n+                }\n+            }\n \n-                    let cmt_refd =\n-                        self.walk_autoref(expr, cmt_derefd, autoref);\n+            cmt = self.walk_autoref(expr, cmt, adjustment.autoref);\n \n-                    if unsize {\n-                        // Unsizing consumes the thin pointer and produces a fat one.\n-                        self.delegate_consume(expr.id, expr.span, cmt_refd);\n-                    }\n-                }\n+            if adjustment.unsize {\n+                // Unsizing consumes the thin pointer and produces a fat one.\n+                self.delegate_consume(expr.id, expr.span, cmt);\n             }\n         }\n     }"}, {"sha": "707b52a1a22fa18134e4d15797594ab89eaa3840", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -475,11 +475,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             Some(adjustment) => {\n                 debug!(\"cat_expr({:?}): {:?}\", adjustment, expr);\n                 match adjustment.kind {\n-                    adjustment::Adjust::DerefRef {\n-                        ref autoderefs,\n-                        autoref: None,\n-                        unsize: false\n-                    } => {\n+                    adjustment::Adjust::Deref(ref autoderefs)\n+                    if adjustment.autoref.is_none() && !adjustment.unsize => {\n                         // Equivalent to *expr or something similar.\n                         let mut cmt = self.cat_expr_unadjusted(expr)?;\n                         debug!(\"cat_expr: autoderefs={:?}, cmt={:?}\",\n@@ -499,7 +496,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     adjustment::Adjust::UnsafeFnPointer |\n                     adjustment::Adjust::ClosureFnPointer |\n                     adjustment::Adjust::MutToConstPointer |\n-                    adjustment::Adjust::DerefRef {..} => {\n+                    adjustment::Adjust::Deref(_) => {\n                         // Result is an rvalue.\n                         let expr_ty = self.expr_ty_adjusted(expr)?;\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))"}, {"sha": "e2e017e9f519a6e945a4d7316b8a9619ea8ef29e", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 82, "deletions": 87, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -13,10 +13,83 @@ use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt, TypeAndMut};\n use ty::subst::Substs;\n \n+\n+/// Represents coercing a value to a different type of value.\n+///\n+/// We transform values by following the following steps in order:\n+/// 1. Apply a step of `Adjust` (see its variants for details).\n+/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+///    `&` or `*` pointer.\n+/// 3. If `unsize` is `true`, then apply the unsize transformation,\n+///    which will do things like convert thin pointers to fat\n+///    pointers, or convert structs containing thin pointers to\n+///    structs containing fat pointers, or convert between fat\n+///    pointers.  We don't store the details of how the transform is\n+///    done (in fact, we don't know that, because it might depend on\n+///    the precise type parameters). We just store the target\n+///    type. Trans figures out what has to be done at monomorphization\n+///    time based on the precise source/target type at hand.\n+///\n+/// To make that more concrete, here are some common scenarios:\n+///\n+/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+/// Here the pointer will be dereferenced N times (where a dereference can\n+/// happen to raw or borrowed pointers or any smart pointer which implements\n+/// Deref, including Box<_>). The types of dereferences is given by\n+/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+/// `false`.\n+///\n+/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// with a thin pointer, deref a number of times, unsize the underlying data,\n+/// then autoref. The 'unsize' phase may change a fixed length array to a\n+/// dynamically sized one, a concrete object to a trait object, or statically\n+/// sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n+/// represented by:\n+///\n+/// ```\n+/// Adjustment {\n+///     kind: Adjust::Deref(vec![None]),// &[i32; 4] -> [i32; 4]\n+///     autoref: Some(AutoBorrow::Ref), // [i32; 4] -> &[i32; 4]\n+///     unsize: true,                   // &[i32; 4] -> &[i32]\n+///     target: `[i32]`,\n+/// }\n+/// ```\n+///\n+/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+/// The autoderef and -ref are the same as in the above example, but the type\n+/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+/// the underlying conversions from `[i32; 4]` to `[i32]`.\n+///\n+/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+/// that case, we have the pointer we need coming in, so there are no\n+/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+/// At some point, of course, `Box` should move out of the compiler, in which\n+/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// Box<[i32]> is represented by:\n+///\n+/// ```\n+/// Adjustment {\n+///     kind: Adjust::Deref(vec![]),\n+///     autoref: None,\n+///     unsize: true,\n+///     target: `Box<[i32]>`,\n+/// }\n+/// ```\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {\n+    /// Step 1.\n     pub kind: Adjust<'tcx>,\n-    pub target: Ty<'tcx>\n+\n+    /// Step 2. Optionally produce a pointer/reference from the value.\n+    pub autoref: Option<AutoBorrow<'tcx>>,\n+\n+    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// `&[T]`. Note that the source could be a thin or fat pointer.\n+    pub unsize: bool,\n+\n+    pub target: Ty<'tcx>,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n@@ -36,103 +109,25 @@ pub enum Adjust<'tcx> {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n-    /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-    /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-    ///\n-    /// We transform pointers by following the following steps in order:\n-    /// 1. Deref the pointer through `self.autoderefs` steps (may be no steps).\n-    /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-    ///    `&` or `*` pointer.\n-    /// 3. If `unsize` is `true`, then apply the unsize transformation,\n-    ///    which will do things like convert thin pointers to fat\n-    ///    pointers, or convert structs containing thin pointers to\n-    ///    structs containing fat pointers, or convert between fat\n-    ///    pointers.  We don't store the details of how the transform is\n-    ///    done (in fact, we don't know that, because it might depend on\n-    ///    the precise type parameters). We just store the target\n-    ///    type. Trans figures out what has to be done at monomorphization\n-    ///    time based on the precise source/target type at hand.\n-    ///\n-    /// To make that more concrete, here are some common scenarios:\n-    ///\n-    /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-    /// Here the pointer will be dereferenced N times (where a dereference can\n-    /// happen to raw or borrowed pointers or any smart pointer which implements\n-    /// Deref, including Box<_>). The types of dereferences is given by\n-    /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-    /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-    /// `false`.\n-    ///\n-    /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-    /// with a thin pointer, deref a number of times, unsize the underlying data,\n-    /// then autoref. The 'unsize' phase may change a fixed length array to a\n-    /// dynamically sized one, a concrete object to a trait object, or statically\n-    /// sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n-    /// represented by:\n-    ///\n-    /// ```\n-    /// Adjustment {\n-    ///     kind: Adjust::DerefRef {\n-    ///         autoderefs: vec![None],         // &[i32; 4] -> [i32; 4]\n-    ///         autoref: Some(AutoBorrow::Ref), // [i32; 4] -> &[i32; 4]\n-    ///         unsize: true,                   // &[i32; 4] -> &[i32]\n-    ///     },\n-    ///     target: `[i32]`,\n-    /// }\n-    /// ```\n-    ///\n-    /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-    /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-    /// The autoderef and -ref are the same as in the above example, but the type\n-    /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-    /// the underlying conversions from `[i32; 4]` to `[i32]`.\n-    ///\n-    /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-    /// that case, we have the pointer we need coming in, so there are no\n-    /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-    /// At some point, of course, `Box` should move out of the compiler, in which\n-    /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-    /// Box<[i32]> is represented by:\n-    ///\n-    /// ```\n-    /// Adjustment {\n-    ///     Adjust::DerefRef {\n-    ///         autoderefs: vec![],\n-    ///         autoref: None,\n-    ///         unsize: true,\n-    ///     },\n-    ///     target: `Box<[i32]>`,\n-    /// }\n-    /// ```\n-    DerefRef {\n-        /// Step 1. Apply a number of dereferences, producing an lvalue.\n-        autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n-\n-        /// Step 2. Optionally produce a pointer/reference from the value.\n-        autoref: Option<AutoBorrow<'tcx>>,\n-\n-        /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-        /// `&[T]`. Note that the source could be a thin or fat pointer.\n-        unsize: bool,\n-    }\n+    /// Apply a number of dereferences, producing an lvalue,\n+    /// if there are more than 0 dereferences.\n+    Deref(Vec<Option<OverloadedDeref<'tcx>>>),\n }\n \n impl<'tcx> Adjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n+        if self.autoref.is_some() || self.unsize {\n+            return false;\n+        }\n         match self.kind {\n             Adjust::NeverToAny => self.target.is_never(),\n \n-            Adjust::DerefRef {\n-                ref autoderefs,\n-                autoref: None,\n-                unsize: false\n-            } if autoderefs.is_empty() => true,\n+            Adjust::Deref(ref autoderefs) => autoderefs.is_empty(),\n \n             Adjust::ReifyFnPointer |\n             Adjust::UnsafeFnPointer |\n             Adjust::ClosureFnPointer |\n-            Adjust::MutToConstPointer |\n-            Adjust::DerefRef {..} => false,\n+            Adjust::MutToConstPointer => false,\n         }\n     }\n }"}, {"sha": "cd34ebc7650b366f9d5e3d45289df59155734e00", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -224,8 +224,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.kind).and_then(|kind| {\n-            tcx.lift(&self.target).map(|target| {\n-                ty::adjustment::Adjustment { kind, target }\n+            tcx.lift(&(self.autoref, self.target)).map(|(autoref, target)| {\n+                ty::adjustment::Adjustment {\n+                    kind,\n+                    autoref,\n+                    unsize: self.unsize,\n+                    target,\n+                }\n             })\n         })\n     }\n@@ -245,12 +250,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n                 Some(ty::adjustment::Adjust::ClosureFnPointer),\n             ty::adjustment::Adjust::MutToConstPointer =>\n                 Some(ty::adjustment::Adjust::MutToConstPointer),\n-            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize } => {\n-                tcx.lift(autoderefs).and_then(|autoderefs| {\n-                    tcx.lift(autoref).map(|autoref| {\n-                        ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize }\n-                    })\n-                })\n+            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n+                tcx.lift(autoderefs).map(ty::adjustment::Adjust::Deref)\n             }\n         }\n     }\n@@ -684,12 +685,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::adjustment::Adjustment {\n             kind: self.kind.fold_with(folder),\n+            autoref: self.autoref.fold_with(folder),\n+            unsize: self.unsize,\n             target: self.target.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.kind.visit_with(visitor) || self.target.visit_with(visitor)\n+        self.kind.visit_with(visitor) ||\n+        self.autoref.visit_with(visitor) ||\n+        self.target.visit_with(visitor)\n     }\n }\n \n@@ -701,12 +706,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n             ty::adjustment::Adjust::MutToConstPointer => self.clone(),\n-            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize } => {\n-                ty::adjustment::Adjust::DerefRef {\n-                    autoderefs: autoderefs.fold_with(folder),\n-                    autoref: autoref.fold_with(folder),\n-                    unsize,\n-                }\n+            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n+                ty::adjustment::Adjust::Deref(autoderefs.fold_with(folder))\n             }\n         }\n     }\n@@ -718,8 +719,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n             ty::adjustment::Adjust::MutToConstPointer => false,\n-            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize: _ } => {\n-                autoderefs.visit_with(visitor) || autoref.visit_with(visitor)\n+            ty::adjustment::Adjust::Deref(ref autoderefs) => {\n+                autoderefs.visit_with(visitor)\n             }\n         }\n     }"}, {"sha": "e4a8a1267f0c8000d9e04070f3755527121e8cb5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -890,7 +890,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for overloaded autoderef method calls.\n             if let Some(&Adjustment {\n-                kind: Adjust::DerefRef { ref autoderefs, .. }, ..\n+                kind: Adjust::Deref(ref autoderefs), ..\n             }) = cx.tables.adjustments.get(&id) {\n                 let mut source = cx.tables.expr_ty(expr);\n                 for &overloaded in autoderefs {"}, {"sha": "4db27647d427a0ee2b8273822b88f69d2d36a447", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -469,20 +469,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n         }\n \n         if let Some(adjustment) = cx.tables.adjustments.get(&e.id) {\n-            if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n-                match autoref {\n-                    Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION,\n-                                     e.span,\n-                                     \"unnecessary allocation, use & instead\");\n-                    }\n-                    Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION,\n-                                     e.span,\n-                                     \"unnecessary allocation, use &mut instead\");\n-                    }\n-                    _ => (),\n+            match adjustment.autoref {\n+                Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n+                    cx.span_lint(UNUSED_ALLOCATION,\n+                                 e.span,\n+                                 \"unnecessary allocation, use & instead\");\n                 }\n+                Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n+                    cx.span_lint(UNUSED_ALLOCATION,\n+                                 e.span,\n+                                 \"unnecessary allocation, use &mut instead\");\n+                }\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "dbf35971fa32325b27a5571c7a74b9923d9b8f15", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -86,8 +86,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::Cast { source: expr.to_ref() },\n                 };\n             }\n-            Some((&ty::adjustment::Adjust::DerefRef { ref autoderefs, autoref, unsize },\n-                  adjusted_ty)) => {\n+            Some((&ty::adjustment::Adjust::Deref(ref autoderefs), _)) => {\n                 for &overloaded in autoderefs {\n                     let source = expr.ty;\n                     let target;\n@@ -143,64 +142,66 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         kind: kind,\n                     };\n                 }\n+            }\n+        }\n \n-                if let Some(autoref) = autoref {\n-                    let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n-                    match autoref {\n-                        ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                            expr = Expr {\n-                                temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n-                                ty: adjusted_ty,\n-                                span: self.span,\n-                                kind: ExprKind::Borrow {\n-                                    region: r,\n-                                    borrow_kind: to_borrow_kind(m),\n-                                    arg: expr.to_ref(),\n-                                },\n-                            };\n-                        }\n-                        ty::adjustment::AutoBorrow::RawPtr(m) => {\n-                            // Convert this to a suitable `&foo` and\n-                            // then an unsafe coercion. Limit the region to be just this\n-                            // expression.\n-                            let region = ty::ReScope(expr_extent);\n-                            let region = cx.tcx.mk_region(region);\n-                            expr = Expr {\n-                                temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n-                                ty: cx.tcx.mk_ref(region,\n-                                                  ty::TypeAndMut {\n-                                                      ty: expr.ty,\n-                                                      mutbl: m,\n-                                                  }),\n-                                span: self.span,\n-                                kind: ExprKind::Borrow {\n-                                    region: region,\n-                                    borrow_kind: to_borrow_kind(m),\n-                                    arg: expr.to_ref(),\n-                                },\n-                            };\n-                            expr = Expr {\n-                                temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n-                                ty: adjusted_ty,\n-                                span: self.span,\n-                                kind: ExprKind::Cast { source: expr.to_ref() },\n-                            };\n-                        }\n+        if let Some(adj) = adj {\n+            if let Some(autoref) = adj.autoref {\n+                let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n+                match autoref {\n+                    ty::adjustment::AutoBorrow::Ref(r, m) => {\n+                        expr = Expr {\n+                            temp_lifetime: temp_lifetime,\n+                            temp_lifetime_was_shrunk: was_shrunk,\n+                            ty: adjusted_ty,\n+                            span: self.span,\n+                            kind: ExprKind::Borrow {\n+                                region: r,\n+                                borrow_kind: to_borrow_kind(m),\n+                                arg: expr.to_ref(),\n+                            },\n+                        };\n+                    }\n+                    ty::adjustment::AutoBorrow::RawPtr(m) => {\n+                        // Convert this to a suitable `&foo` and\n+                        // then an unsafe coercion. Limit the region to be just this\n+                        // expression.\n+                        let region = ty::ReScope(expr_extent);\n+                        let region = cx.tcx.mk_region(region);\n+                        expr = Expr {\n+                            temp_lifetime: temp_lifetime,\n+                            temp_lifetime_was_shrunk: was_shrunk,\n+                            ty: cx.tcx.mk_ref(region,\n+                                              ty::TypeAndMut {\n+                                                    ty: expr.ty,\n+                                                    mutbl: m,\n+                                              }),\n+                            span: self.span,\n+                            kind: ExprKind::Borrow {\n+                                region: region,\n+                                borrow_kind: to_borrow_kind(m),\n+                                arg: expr.to_ref(),\n+                            },\n+                        };\n+                        expr = Expr {\n+                            temp_lifetime: temp_lifetime,\n+                            temp_lifetime_was_shrunk: was_shrunk,\n+                            ty: adjusted_ty,\n+                            span: self.span,\n+                            kind: ExprKind::Cast { source: expr.to_ref() },\n+                        };\n                     }\n                 }\n+            }\n \n-                if unsize {\n-                    expr = Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: adjusted_ty,\n-                        span: self.span,\n-                        kind: ExprKind::Unsize { source: expr.to_ref() },\n-                    };\n-                }\n+            if adj.unsize {\n+                expr = Expr {\n+                    temp_lifetime: temp_lifetime,\n+                    temp_lifetime_was_shrunk: was_shrunk,\n+                    ty: adj.target,\n+                    span: self.span,\n+                    kind: ExprKind::Unsize { source: expr.to_ref() },\n+                };\n             }\n         }\n "}, {"sha": "e7aa74494f9e8f5448a1a6e29a575c450610e6ee", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -449,7 +449,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(&Adjust::ClosureFnPointer) |\n         Some(&Adjust::MutToConstPointer) => {}\n \n-        Some(&Adjust::DerefRef { ref autoderefs, .. }) => {\n+        Some(&Adjust::Deref(ref autoderefs)) => {\n             if autoderefs.iter().any(|overloaded| overloaded.is_some()) {\n                 v.promotable = false;\n             }"}, {"sha": "579bcda8dc6195a635cdac302a0ae19284837959", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -144,11 +144,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n             let autoderefs = autoderef.adjust_steps(LvaluePreference::NoPreference);\n             self.apply_adjustment(callee_expr.id, Adjustment {\n-                kind: Adjust::DerefRef {\n-                    autoderefs,\n-                    autoref,\n-                    unsize: false\n-                },\n+                kind: Adjust::Deref(autoderefs),\n+                autoref,\n+                unsize: false,\n                 target: method.sig.inputs()[0]\n             });\n             CallStep::Overloaded(method)\n@@ -356,11 +354,9 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n \n                 fcx.apply_adjustment(self.callee_expr.id, Adjustment {\n-                    kind: Adjust::DerefRef {\n-                        autoderefs: self.autoderefs,\n-                        autoref,\n-                        unsize: false\n-                    },\n+                    kind: Adjust::Deref(self.autoderefs),\n+                    autoref,\n+                    unsize: false,\n                     target: method_sig.inputs()[0]\n                 });\n "}, {"sha": "dc373610814dde16cc2a1ddb435843c6e988563b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -108,23 +108,24 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-fn identity<'tcx>() -> Adjust<'tcx> {\n-    Adjust::DerefRef {\n-        autoderefs: vec![],\n+fn identity<'tcx>(target: Ty<'tcx>) -> Adjustment<'tcx> {\n+    simple(Adjust::Deref(vec![]))(target)\n+}\n+\n+fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Adjustment<'tcx> {\n+    move |target| Adjustment {\n+        kind,\n         autoref: None,\n         unsize: false,\n+        target\n     }\n }\n \n-fn success<'tcx>(kind: Adjust<'tcx>,\n-                 target: Ty<'tcx>,\n+fn success<'tcx>(adj: Adjustment<'tcx>,\n                  obligations: traits::PredicateObligations<'tcx>)\n                  -> CoerceResult<'tcx> {\n     Ok(InferOk {\n-        value: Adjustment {\n-            kind,\n-            target\n-        },\n+        value: adj,\n         obligations\n     })\n }\n@@ -150,10 +151,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     }\n \n     /// Unify two types (using sub or lub) and produce a specific coercion.\n-    fn unify_and(&self, a: Ty<'tcx>, b: Ty<'tcx>, kind: Adjust<'tcx>)\n-                 -> CoerceResult<'tcx> {\n+    fn unify_and<F>(&self, a: Ty<'tcx>, b: Ty<'tcx>, f: F)\n+                    -> CoerceResult<'tcx>\n+        where F: FnOnce(Ty<'tcx>) -> Adjustment<'tcx>\n+    {\n         self.unify(&a, &b).and_then(|InferOk { value: ty, obligations }| {\n-            success(kind, ty, obligations)\n+            success(f(ty), obligations)\n         })\n     }\n \n@@ -163,7 +166,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return success(identity(), b, vec![]);\n+            return success(identity(b), vec![]);\n         }\n \n         if a.is_never() {\n@@ -180,9 +183,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n-                self.unify_and(&b, &diverging_ty, Adjust::NeverToAny)\n+                self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n-                success(Adjust::NeverToAny, b, vec![])\n+                success(simple(Adjust::NeverToAny)(b), vec![])\n             };\n         }\n \n@@ -231,7 +234,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify_and(a, b, identity())\n+                self.unify_and(a, b, identity)\n             }\n         }\n     }\n@@ -259,7 +262,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n-            _ => return self.unify_and(a, b, identity()),\n+            _ => return self.unify_and(a, b, identity),\n         };\n \n         let span = self.cause.span;\n@@ -404,7 +407,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n             assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n-            return success(identity(), ty, obligations);\n+            return success(identity(ty), obligations);\n         }\n \n         // Now apply the autoref. We have to extract the region out of\n@@ -426,11 +429,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                autoderefs,\n                autoref);\n \n-        success(Adjust::DerefRef {\n-            autoderefs,\n+        success(Adjustment {\n+            kind: Adjust::Deref(autoderefs),\n             autoref,\n             unsize: false,\n-        }, ty, obligations)\n+            target: ty\n+        }, obligations)\n     }\n \n \n@@ -471,19 +475,18 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         };\n         let coerce_source = source.adjust_for_autoref(self.tcx, reborrow);\n \n-        let adjust = Adjust::DerefRef {\n-            autoderefs: if reborrow.is_some() { vec![None] } else { vec![] },\n-            autoref: reborrow,\n-            unsize: true,\n-        };\n-\n         // Setup either a subtyping or a LUB relationship between\n         // the `CoerceUnsized` target type and the expected type.\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n         let coerce_target = self.next_ty_var(origin);\n-        let mut coercion = self.unify_and(coerce_target, target, adjust)?;\n+        let mut coercion = self.unify_and(coerce_target, target, |target| Adjustment {\n+            kind: Adjust::Deref(if reborrow.is_some() { vec![None] } else { vec![] }),\n+            autoref: reborrow,\n+            unsize: true,\n+            target\n+        })?;\n \n         let mut selcx = traits::SelectionContext::new(self);\n \n@@ -536,13 +539,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         Ok(coercion)\n     }\n \n-    fn coerce_from_safe_fn(&self,\n-                           a: Ty<'tcx>,\n-                           fn_ty_a: ty::PolyFnSig<'tcx>,\n-                           b: Ty<'tcx>,\n-                           to_unsafe: Adjust<'tcx>,\n-                           normal: Adjust<'tcx>)\n-                           -> CoerceResult<'tcx> {\n+    fn coerce_from_safe_fn<F, G>(&self,\n+                                 a: Ty<'tcx>,\n+                                 fn_ty_a: ty::PolyFnSig<'tcx>,\n+                                 b: Ty<'tcx>,\n+                                 to_unsafe: F,\n+                                 normal: G)\n+                                 -> CoerceResult<'tcx>\n+        where F: FnOnce(Ty<'tcx>) -> Adjustment<'tcx>,\n+              G: FnOnce(Ty<'tcx>) -> Adjustment<'tcx>\n+    {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n@@ -568,7 +574,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n         self.coerce_from_safe_fn(a, fn_ty_a, b,\n-            Adjust::UnsafeFnPointer, identity())\n+            simple(Adjust::UnsafeFnPointer), identity)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -587,9 +593,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n                 self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n-                    Adjust::ReifyFnPointer, Adjust::ReifyFnPointer)\n+                    simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))\n             }\n-            _ => self.unify_and(a, b, identity()),\n+            _ => self.unify_and(a, b, identity),\n         }\n     }\n \n@@ -631,9 +637,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n-                self.unify_and(pointer_ty, b, Adjust::ClosureFnPointer)\n+                self.unify_and(pointer_ty, b, simple(Adjust::ClosureFnPointer))\n             }\n-            _ => self.unify_and(a, b, identity()),\n+            _ => self.unify_and(a, b, identity),\n         }\n     }\n \n@@ -648,7 +654,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify_and(a, b, identity());\n+                return self.unify_and(a, b, identity);\n             }\n         };\n \n@@ -661,17 +667,18 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        self.unify_and(a_unsafe, b, if is_ref {\n-            Adjust::DerefRef {\n-                autoderefs: vec![None],\n+        if is_ref {\n+            self.unify_and(a_unsafe, b, |target| Adjustment {\n+                kind: Adjust::Deref(vec![None]),\n                 autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n                 unsize: false,\n-            }\n+                target\n+            })\n         } else if mt_a.mutbl != mutbl_b {\n-            Adjust::MutToConstPointer\n+            self.unify_and(a_unsafe, b, simple(Adjust::MutToConstPointer))\n         } else {\n-            identity()\n-        })\n+            self.unify_and(a_unsafe, b, identity)\n+        }\n     }\n }\n \n@@ -776,6 +783,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // `NeverToAny`, so this should always be valid.\n                     self.apply_adjustment(expr.id, Adjustment {\n                         kind: Adjust::ReifyFnPointer,\n+                        autoref: None,\n+                        unsize: false,\n                         target: fn_ptr\n                     });\n                 }\n@@ -808,11 +817,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs {\n             let expr = expr.as_coercion_site();\n-            let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| &adj.kind) {\n-                Some(&Adjust::DerefRef {\n-                    ref autoderefs,\n+            let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n+                Some(&Adjustment {\n+                    kind: Adjust::Deref(ref autoderefs),\n                     autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n-                    unsize: false\n+                    unsize: false,\n+                    target: _\n                 }) if autoderefs.len() == 1 => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n@@ -824,7 +834,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => false,\n                     }\n                 }\n-                Some(&Adjust::NeverToAny) => true,\n+                Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => true,\n                 Some(_) => false,\n                 None => true,\n             };"}, {"sha": "bdbc7f677e4cf24f7c26607bb5f0bbf14eb54864", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -147,12 +147,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Write out the final adjustment.\n         self.apply_adjustment(self.self_expr.id, Adjustment {\n-            kind: Adjust::DerefRef {\n-                autoderefs,\n-                autoref,\n-                unsize: pick.unsize.is_some(),\n-            },\n-            target: target\n+            kind: Adjust::Deref(autoderefs),\n+            autoref,\n+            unsize: pick.unsize.is_some(),\n+            target,\n         });\n \n         target\n@@ -440,7 +438,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // the correct region.\n             let expr_ty = self.node_ty(expr.id);\n             if let Some(adj) = self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n-                if let Adjust::DerefRef { ref mut autoderefs, .. } = adj.kind {\n+                if let Adjust::Deref(ref mut autoderefs) = adj.kind {\n                     let mut autoderef = self.autoderef(expr.span, expr_ty);\n                     autoderef.nth(autoderefs.len()).unwrap_or_else(|| {\n                         span_bug!(expr.span,\n@@ -502,9 +500,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability.\n         if let Some(&mut Adjustment {\n-            ref mut target, kind: Adjust::DerefRef {\n-                autoref: Some(AutoBorrow::Ref(ref mut r, ref mut mutbl)), ..\n-            }\n+            ref mut target,\n+            autoref: Some(AutoBorrow::Ref(ref mut r, ref mut mutbl)), ..\n         }) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n             debug!(\"convert_lvalue_op_to_mutable: converting autoref of {:?}\", target);\n "}, {"sha": "e6d43f00403625fed7f8d7115e135d687cd866dc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -1779,11 +1779,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n                                       adjusted_ty: Ty<'tcx>) {\n         self.apply_adjustment(node_id, Adjustment {\n-            kind: Adjust::DerefRef {\n-                autoderefs,\n-                autoref: None,\n-                unsize: false\n-            },\n+            kind: Adjust::Deref(autoderefs),\n+            autoref: None,\n+            unsize: false,\n             target: adjusted_ty\n         });\n     }\n@@ -1799,17 +1797,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n-                match (&entry.get().kind, &adj.kind) {\n+                match (entry.get(), &adj) {\n                     // Applying any adjustment on top of a NeverToAny\n                     // is a valid NeverToAny adjustment, because it can't\n                     // be reached.\n-                    (&Adjust::NeverToAny, _) => return,\n-                    (&Adjust::DerefRef {\n-                        autoderefs: ref old,\n+                    (&Adjustment { kind: Adjust::NeverToAny, .. }, _) => return,\n+                    (&Adjustment {\n+                        kind: Adjust::Deref(ref old),\n                         autoref: Some(AutoBorrow::Ref(..)),\n-                        unsize: false\n-                    }, &Adjust::DerefRef {\n-                        autoderefs: ref new, ..\n+                        unsize: false, ..\n+                    }, &Adjustment {\n+                        kind: Adjust::Deref(ref new), ..\n                     }) if old.len() == 1 && new.len() >= 1 => {\n                         // A reborrow has no effect before a dereference.\n                     }\n@@ -2235,11 +2233,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 let autoderefs = autoderef.adjust_steps(lvalue_pref);\n                 self.apply_adjustment(base_expr.id, Adjustment {\n-                    kind: Adjust::DerefRef {\n-                        autoderefs,\n-                        autoref,\n-                        unsize\n-                    },\n+                    kind: Adjust::Deref(autoderefs),\n+                    autoref,\n+                    unsize,\n                     target: method.sig.inputs()[0]\n                 });\n \n@@ -2651,6 +2647,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n             self.apply_adjustment(expr.id, Adjustment {\n                 kind: Adjust::NeverToAny,\n+                autoref: None,\n+                unsize: false,\n                 target: adj_ty\n             });\n             ty = adj_ty;\n@@ -3450,11 +3448,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 expr.span, oprnd_t, lvalue_pref) {\n                             let (autoref, method) = self.register_infer_ok_obligations(ok);\n                             self.apply_adjustment(oprnd.id, Adjustment {\n-                                kind: Adjust::DerefRef {\n-                                    autoderefs: vec![],\n-                                    autoref,\n-                                    unsize: false\n-                                },\n+                                kind: Adjust::Deref(vec![]),\n+                                autoref,\n+                                unsize: false,\n                                 target: method.sig.inputs()[0]\n                             });\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;"}, {"sha": "8d442aae70e3b5990ed7ff187bf436b98e734e07", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -414,11 +414,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.select_obligations_where_possible();\n \n                 self.apply_adjustment(lhs_expr.id, Adjustment {\n-                    kind: Adjust::DerefRef {\n-                        autoderefs: vec![],\n-                        autoref,\n-                        unsize: false\n-                    },\n+                    kind: Adjust::Deref(vec![]),\n+                    autoref,\n+                    unsize: false,\n                     target: method.sig.inputs()[0]\n                 });\n                 self.write_method_call(expr.id, method);"}, {"sha": "119ae748f85cd9cecb3371402a6ff723cd3ca310", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d603a2a7ad6caed2275da0c7ae21d845ed72d1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=91d603a2a7ad6caed2275da0c7ae21d845ed72d1", "patch": "@@ -546,9 +546,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         if let Some(adjustment) = adjustment {\n             debug!(\"adjustment={:?}\", adjustment);\n             match adjustment.kind {\n-                adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, .. } => {\n+                adjustment::Adjust::Deref(ref autoderefs) => {\n                     let cmt = ignore_err!(self.constrain_autoderefs(expr, autoderefs));\n-                    if let Some(ref autoref) = *autoref {\n+                    if let Some(ref autoref) = adjustment.autoref {\n                         self.link_autoref(expr, cmt, autoref);\n \n                         // Require that the resulting region encompasses\n@@ -569,7 +569,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                                            source_ty, bounds.region_bound);\n                 }\n                 */\n-                _ => {}\n+                _ => {\n+                    assert!(adjustment.autoref.is_none());\n+                }\n             }\n \n             // If necessary, constrain destructors in the unadjusted form of this"}]}