{"sha": "175d6a74355ea1b9470866818c9b47d1a50900c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NWQ2YTc0MzU1ZWExYjk0NzA4NjY4MThjOWI0N2QxYTUwOTAwYzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-27T16:07:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-27T22:12:30Z"}, "message": "rollup merge of #18332 : jbcrail/fix-comments", "tree": {"sha": "c82095f4b47b9732ba8da3561aac2328fbff8fc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c82095f4b47b9732ba8da3561aac2328fbff8fc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/175d6a74355ea1b9470866818c9b47d1a50900c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/175d6a74355ea1b9470866818c9b47d1a50900c7", "html_url": "https://github.com/rust-lang/rust/commit/175d6a74355ea1b9470866818c9b47d1a50900c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/175d6a74355ea1b9470866818c9b47d1a50900c7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "287df9e0ebf5cb5c855f69d4b617ab5df5824f98", "url": "https://api.github.com/repos/rust-lang/rust/commits/287df9e0ebf5cb5c855f69d4b617ab5df5824f98", "html_url": "https://github.com/rust-lang/rust/commit/287df9e0ebf5cb5c855f69d4b617ab5df5824f98"}, {"sha": "30403204d695b687cc264c875eae829ae9368937", "url": "https://api.github.com/repos/rust-lang/rust/commits/30403204d695b687cc264c875eae829ae9368937", "html_url": "https://github.com/rust-lang/rust/commit/30403204d695b687cc264c875eae829ae9368937"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "f255dbf15071b6dc3852bace3c21aa7d706ab759", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -376,7 +376,7 @@ fn bar(   a:int,\n           -> int\n { }\n \n-fn baz(   a:int,  // shoudl work with a comment here\n+fn baz(   a:int,  // should work with a comment here\n           b:char)\n           -> int\n { }"}, {"sha": "77fb6d4a1203b360fa4e624cb382168fed73f62f", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -41,10 +41,10 @@ use ringbuf::RingBuf;\n /// the BST strategy.\n ///\n /// A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing\n-/// this, we reduce the number of allocations by a factor of B, and improve cache effeciency in\n+/// this, we reduce the number of allocations by a factor of B, and improve cache efficiency in\n /// searches. However, this does mean that searches will have to do *more* comparisons on average.\n /// The precise number of comparisons depends on the node search strategy used. For optimal cache\n-/// effeciency, one could search the nodes linearly. For optimal comparisons, one could search\n+/// efficiency, one could search the nodes linearly. For optimal comparisons, one could search\n /// the node using binary search. As a compromise, one could also perform a linear search\n /// that initially only checks every i<sup>th</sup> element for some choice of i.\n ///"}, {"sha": "4da362952b67c8fadec70ee436f7897644944da8", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -53,7 +53,7 @@ pub struct Node<K, V> {\n     // hard. For now, we accept this cost in the name of correctness and simplicity.\n     //\n     // As a compromise, keys and vals could be merged into one Vec<(K, V)>, which would shave\n-    // off 3 words, but possibly hurt our cache effeciency during search, which only cares about\n+    // off 3 words, but possibly hurt our cache efficiency during search, which only cares about\n     // keys. This would also avoid the Zip we use in our iterator implementations. This is\n     // probably worth investigating.\n     //\n@@ -72,7 +72,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n     pub fn search(&self, key: &K) -> SearchResult {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n-        // For the B configured as of this writing (B = 6), binary search was *singnificantly*\n+        // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n         self.search_linear(key)\n     }\n@@ -375,7 +375,7 @@ impl<K, V> Node<K, V> {\n         }\n     }\n \n-    /// Steal! Stealing is roughly analagous to a binary tree rotation.\n+    /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n     unsafe fn steal_to_left(&mut self, underflowed_child_index: uint) {\n         // Take the biggest stuff off left\n@@ -387,7 +387,7 @@ impl<K, V> Node<K, V> {\n             }\n         };\n \n-        // Swap the parent's seperating key-value pair with left's\n+        // Swap the parent's separating key-value pair with left's\n         self.unsafe_swap(underflowed_child_index - 1, &mut key, &mut val);\n \n         // Put them at the start of right\n@@ -402,7 +402,7 @@ impl<K, V> Node<K, V> {\n         }\n     }\n \n-    /// Steal! Stealing is roughly analagous to a binary tree rotation.\n+    /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" left.\n     unsafe fn steal_to_right(&mut self, underflowed_child_index: uint) {\n         // Take the smallest stuff off right\n@@ -414,7 +414,7 @@ impl<K, V> Node<K, V> {\n             }\n         };\n \n-        // Swap the parent's seperating key-value pair with right's\n+        // Swap the parent's separating key-value pair with right's\n         self.unsafe_swap(underflowed_child_index, &mut key, &mut val);\n \n         // Put them at the end of left\n@@ -430,9 +430,9 @@ impl<K, V> Node<K, V> {\n     }\n \n     /// Merge! Left and right will be smooshed into one node, along with the key-value\n-    /// pair that seperated them in their parent.\n+    /// pair that separated them in their parent.\n     unsafe fn merge_children(&mut self, left_index: uint) {\n-        // Permanently remove right's index, and the key-value pair that seperates\n+        // Permanently remove right's index, and the key-value pair that separates\n         // left and right\n         let (key, val, right) = {\n             match (self.keys.remove(left_index),\n@@ -448,7 +448,7 @@ impl<K, V> Node<K, V> {\n         left.absorb(key, val, right);\n     }\n \n-    /// Take all the values from right, seperated by the given key and value\n+    /// Take all the values from right, separated by the given key and value\n     fn absorb(&mut self, key: K, val: V, right: Node<K, V>) {\n         // Just as a sanity check, make sure we can fit this guy in\n         debug_assert!(self.len() + right.len() <= self.capacity())"}, {"sha": "97e68bcbb2c6ca52d0c316b8e6cebc199152f7c6", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -173,7 +173,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n     fn reseed(&mut self, seed: &'a [u32]) {\n         // reset state\n         self.init(&[0u32, ..KEY_WORDS]);\n-        // set key inplace\n+        // set key in place\n         let key = self.state.slice_mut(4, 4+KEY_WORDS);\n         for (k, s) in key.iter_mut().zip(seed.iter()) {\n             *k = *s;"}, {"sha": "8f1fcf77ee38a6f565793d0c1abb03bf35bef809", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -211,7 +211,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // can be applied to particular types. It skips the \"confirmation\"\n     // step and hence completely ignores output type parameters.\n     //\n-    // The result is \"true\" if the obliation *may* hold and \"false\" if\n+    // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n     pub fn evaluate_obligation_intercrate(&mut self,"}, {"sha": "622da4840b047bee4eccf44f8602b8d809a208a8", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -2117,7 +2117,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 deref_owned_pointer(bcx, expr, datum, content_ty)\n             } else {\n                 // A fat pointer and an opened DST value have the same\n-                // represenation just different types. Since there is no\n+                // representation just different types. Since there is no\n                 // temporary for `*e` here (because it is unsized), we cannot\n                 // emulate the sized object code path for running drop glue and\n                 // free. Instead, we schedule cleanup for `e`, turning it into\n@@ -2142,7 +2142,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // owner (or, in the case of *T, by the user).\n                 DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n             } else {\n-                // A fat pointer and an opened DST value have the same represenation\n+                // A fat pointer and an opened DST value have the same representation\n                 // just different types.\n                 DatumBlock::new(bcx, Datum::new(datum.val,\n                                                 ty::mk_open(bcx.tcx(), content_ty),"}, {"sha": "569c256a738b13966c8a7e6537c89401c160fbc6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -3619,7 +3619,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n                 // Special case: A unit like struct's constructor must be called without () at the\n                 // end (like `UnitStruct`) which means this is an ExprPath to a DefFn. But in case\n-                // of unit structs this is should not be interpretet as function pointer but as\n+                // of unit structs this is should not be interpreted as function pointer but as\n                 // call to the constructor.\n                 def::DefFn(_, _, true) => RvalueDpsExpr,\n \n@@ -5423,7 +5423,7 @@ impl BorrowKind {\n             MutBorrow => ast::MutMutable,\n             ImmBorrow => ast::MutImmutable,\n \n-            // We have no type correponding to a unique imm borrow, so\n+            // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n             UniqueImmBorrow => ast::MutMutable,"}, {"sha": "deeee67ac6eab5174a98df261e5b7537523dc737", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -1674,7 +1674,7 @@ fn link_reborrowed_region(rcx: &Rcx,\n             //\n             // If mutability was inferred from an upvar, we may be\n             // forced to revisit this decision later if processing\n-            // another borrow or nested closure ends up coverting the\n+            // another borrow or nested closure ends up converting the\n             // upvar borrow kind to mutable/unique.  Record the\n             // information needed to perform the recursive link in the\n             // maybe link map."}, {"sha": "ca954679c1c9d7db7851c03df088a8bf33524f32", "filename": "src/libstd/collections/hashmap/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -186,7 +186,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// This is a slightly silly example where we define the number's\n-    /// parity as the equivilance class. It is important that the\n+    /// parity as the equivalance class. It is important that the\n     /// values hash the same, which is why we implement `Hash`.\n     ///\n     /// ```"}, {"sha": "eaa370d95a85c1321e15691922165648dae287be", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -439,7 +439,7 @@ pub enum Stmt_ {\n     /// Expr with trailing semi-colon (may have any type):\n     StmtSemi(P<Expr>, NodeId),\n \n-    /// bool: is there a trailing sem-colon?\n+    /// bool: is there a trailing semi-colon?\n     StmtMac(Mac, bool),\n }\n "}, {"sha": "dbad546ce1ae3fd1a427b91afa99d06deecaed6f", "filename": "src/test/run-pass/dst-coercions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coercions.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n \n     let x: *mut S = &mut S;\n \n-    // Test we can chnage the mutability from mut to const.\n+    // Test we can change the mutability from mut to const.\n     let x: &T = &mut S;\n     let x: *const T = &mut S;\n }"}, {"sha": "966e34dfe49c6902ae161768403ebf9dfd167608", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -30,7 +30,7 @@ unsafe fn test_triangle() -> bool {\n     let ascend = ascend.as_mut_slice();\n     static ALIGN : uint = 1;\n \n-    // Checks that `ascend` forms triangle of acending size formed\n+    // Checks that `ascend` forms triangle of ascending size formed\n     // from pairs of rows (where each pair of rows is equally sized),\n     // and the elements of the triangle match their row-pair index.\n     unsafe fn sanity_check(ascend: &[*mut u8]) {"}, {"sha": "11b58948e0535d1f928630cf16740ece3ce9efb2", "filename": "src/test/run-pass/vec-dst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d6a74355ea1b9470866818c9b47d1a50900c7/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=175d6a74355ea1b9470866818c9b47d1a50900c7", "patch": "@@ -10,7 +10,7 @@\n \n fn sub_expr() {\n     // Test for a &[T] => &&[T] coercion in sub-expression position\n-    // (surpisingly, this can cause errors which are not caused by either of:\n+    // (surprisingly, this can cause errors which are not caused by either of:\n     //    `let x = vec.slice_mut(0, 2);`\n     //    `foo(vec.slice_mut(0, 2));` ).\n     let mut vec: Vec<int> = vec!(1, 2, 3, 4);"}]}