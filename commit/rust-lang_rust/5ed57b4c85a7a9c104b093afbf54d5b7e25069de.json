{"sha": "5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZDU3YjRjODVhN2E5YzEwNGIwOTNhZmJmNTRkNWI3ZTI1MDY5ZGU=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-07T19:28:27Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-07T19:28:27Z"}, "message": "Remove most usage of type aliases", "tree": {"sha": "441211ec7a7034b8637033af80dbb013803a24f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441211ec7a7034b8637033af80dbb013803a24f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "html_url": "https://github.com/rust-lang/rust/commit/5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e11286a362a844a40dfa1c74f4d656568e7bdf07", "url": "https://api.github.com/repos/rust-lang/rust/commits/e11286a362a844a40dfa1c74f4d656568e7bdf07", "html_url": "https://github.com/rust-lang/rust/commit/e11286a362a844a40dfa1c74f4d656568e7bdf07"}], "stats": {"total": 297, "additions": 145, "deletions": 152}, "files": [{"sha": "f403f4d90473a8cd3db98470559dca38aefdc3a8", "filename": "crates/core_simd/src/iter.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fiter.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -1,54 +1,58 @@\n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+use core::{\n+    iter::{Product, Sum},\n+    ops::{Add, Mul},\n+};\n \n macro_rules! impl_traits {\n-    { $type:ident } => {\n-        impl<const LANES: usize> core::iter::Sum<Self> for crate::$type<LANES>\n+    { $type:ty } => {\n+        impl<const LANES: usize> Sum<Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn sum<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Add::add)\n+            fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(0 as $type), Add::add)\n             }\n         }\n \n-        impl<const LANES: usize> core::iter::Product<Self> for crate::$type<LANES>\n+        impl<const LANES: usize> core::iter::Product<Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn product<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Mul::mul)\n+            fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(1 as $type), Mul::mul)\n             }\n         }\n \n-        impl<'a, const LANES: usize> core::iter::Sum<&'a Self> for crate::$type<LANES>\n+        impl<'a, const LANES: usize> Sum<&'a Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn sum<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Add::add)\n+            fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(0 as $type), Add::add)\n             }\n         }\n \n-        impl<'a, const LANES: usize> core::iter::Product<&'a Self> for crate::$type<LANES>\n+        impl<'a, const LANES: usize> Product<&'a Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn product<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Mul::mul)\n+            fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(1 as $type), Mul::mul)\n             }\n         }\n     }\n }\n \n-impl_traits! { SimdF32 }\n-impl_traits! { SimdF64 }\n-impl_traits! { SimdU8 }\n-impl_traits! { SimdU16 }\n-impl_traits! { SimdU32 }\n-impl_traits! { SimdU64 }\n-impl_traits! { SimdUsize }\n-impl_traits! { SimdI8 }\n-impl_traits! { SimdI16 }\n-impl_traits! { SimdI32 }\n-impl_traits! { SimdI64 }\n-impl_traits! { SimdIsize }\n+impl_traits! { f32 }\n+impl_traits! { f64 }\n+impl_traits! { u8 }\n+impl_traits! { u16 }\n+impl_traits! { u32 }\n+impl_traits! { u64 }\n+impl_traits! { usize }\n+impl_traits! { i8 }\n+impl_traits! { i16 }\n+impl_traits! { i32 }\n+impl_traits! { i64 }\n+impl_traits! { isize }"}, {"sha": "b7bde44b384f9bf835809a921e775d680fea2930", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -522,21 +522,21 @@ pub type masksizex4 = MaskSize<4>;\n pub type masksizex8 = MaskSize<8>;\n \n macro_rules! impl_from {\n-    { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n+    { $from:ty  => $($to:ty),* } => {\n         $(\n-        impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n+        impl<const LANES: usize> From<Mask<$from, LANES>> for Mask<$to, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn from(value: $from<LANES>) -> Self {\n+            fn from(value: Mask<$from, LANES>) -> Self {\n                 Self(value.0.convert())\n             }\n         }\n         )*\n     }\n }\n-impl_from! { Mask8 (SimdI8) => Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize) }\n-impl_from! { Mask16 (SimdI16) => Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8) }\n-impl_from! { Mask32 (SimdI32) => Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16) }\n-impl_from! { Mask64 (SimdI64) => MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32) }\n-impl_from! { MaskSize (SimdIsize) => Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64) }\n+impl_from! { i8 => i16, i32, i64, isize }\n+impl_from! { i16 => i32, i64, isize, i8 }\n+impl_from! { i32 => i64, isize, i8, i16 }\n+impl_from! { i64 => isize, i8, i16, i32 }\n+impl_from! { isize => i8, i16, i32, i64 }"}, {"sha": "b45ace3791d3a9572b1a2d149e20dbaac65d1df9", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -158,6 +158,16 @@ where\n             ))\n         }\n     }\n+\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n+    }\n+\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n+    }\n }\n \n impl<Element, const LANES: usize> core::convert::From<Mask<Element, LANES>> for Simd<Element, LANES>\n@@ -217,5 +227,3 @@ where\n         Self::splat(true) ^ self\n     }\n }\n-\n-impl_full_mask_reductions! {}"}, {"sha": "7affecbafd68db235a64bc471d2f03574e1cb346", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -1,16 +1,18 @@\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n macro_rules! impl_uint_arith {\n-    ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+    ($($ty:ty),+) => {\n+        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::MAX;\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([2, 1, 0, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n+            /// let x = Simd::from_array([2, 1, 0, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n             /// assert_eq!(x - 1, unsat);\n@@ -27,13 +29,13 @@ macro_rules! impl_uint_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::MAX;\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([2, 1, 0, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n+            /// let x = Simd::from_array([2, 1, 0, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n             /// assert_eq!(unsat, x + 1);\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::splat(0));\")]\n+            /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n@@ -43,22 +45,22 @@ macro_rules! impl_uint_arith {\n }\n \n macro_rules! impl_int_arith {\n-    ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+    ($($ty:ty),+) => {\n+        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([MIN, 0, 1, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([-1, MAX, MIN, -2]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([-1, MAX, MAX, MAX]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n+            /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n@@ -71,13 +73,13 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([MIN, -2, -1, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([1, MAX, MIN, 0]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([MIN, MIN, MIN, 0]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n+            /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n@@ -90,13 +92,13 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let xs = \", stringify!($name), \"::from_array([MIN, MIN +1, -5, 0]);\")]\n-            #[doc = concat!(\"assert_eq!(xs.abs(), \", stringify!($name), \"::from_array([MIN, MAX, 5, 0]));\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n+            /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n             /// ```\n             #[inline]\n             pub fn abs(self) -> Self {\n-                const SHR: $n = <$n>::BITS as $n - 1;\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n                 let m = self >> SHR;\n                 (self^m) - m\n             }\n@@ -108,17 +110,17 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let xs = \", stringify!($name), \"::from_array([MIN, -2, 0, 3]);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n             /// let unsat = xs.abs();\n             /// let sat = xs.saturating_abs();\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([MIN, 2, 0, 3]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([MAX, 2, 0, 3]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n+            /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n             /// ```\n             #[inline]\n             pub fn saturating_abs(self) -> Self {\n                 // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n-                const SHR: $n = <$n>::BITS as $n - 1;\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n                 let m = self >> SHR;\n                 (self^m).saturating_sub(m)\n             }\n@@ -130,12 +132,12 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([MIN, -2, 3, MAX]);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n             /// let unsat = -x;\n             /// let sat = x.saturating_neg();\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([MIN, 2, -3, MIN + 1]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([MAX, 2, -3, MIN + 1]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n+            /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n             /// ```\n             #[inline]\n             pub fn saturating_neg(self) -> Self {\n@@ -145,7 +147,5 @@ macro_rules! impl_int_arith {\n     }\n }\n \n-use crate::vector::*;\n-\n-impl_uint_arith! { (SimdU8, u8), (SimdU16, u16), (SimdU32, u32), (SimdU64, u64), (SimdUsize, usize) }\n-impl_int_arith! { (SimdI8, i8), (SimdI16, i16), (SimdI32, i32), (SimdI64, i64), (SimdIsize, isize) }\n+impl_uint_arith! { u8, u16, u32, u64, usize }\n+impl_int_arith! { i8, i16, i32, i64, isize }"}, {"sha": "943d2856e359034760003d784e45c18ce5abd18c", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -1,8 +1,10 @@\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n macro_rules! impl_integer_reductions {\n-    { $name:ident, $scalar:ty } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $scalar:ty } => {\n+        impl<const LANES: usize> Simd<$scalar, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n@@ -52,11 +54,22 @@ macro_rules! impl_integer_reductions {\n     }\n }\n \n+impl_integer_reductions! { i8 }\n+impl_integer_reductions! { i16 }\n+impl_integer_reductions! { i32 }\n+impl_integer_reductions! { i64 }\n+impl_integer_reductions! { isize }\n+impl_integer_reductions! { u8 }\n+impl_integer_reductions! { u16 }\n+impl_integer_reductions! { u32 }\n+impl_integer_reductions! { u64 }\n+impl_integer_reductions! { usize }\n+\n macro_rules! impl_float_reductions {\n-    { $name:ident, $scalar:ty } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $scalar:ty } => {\n+        impl<const LANES: usize> Simd<$scalar, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n \n             /// Horizontal add.  Returns the sum of the lanes of the vector.\n@@ -102,22 +115,5 @@ macro_rules! impl_float_reductions {\n     }\n }\n \n-macro_rules! impl_full_mask_reductions {\n-    {} => {\n-        impl<Element, const LANES: usize> Mask<Element, LANES>\n-        where\n-            Element: MaskElement,\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            pub fn any(self) -> bool {\n-                unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n-            }\n-\n-            #[inline]\n-            pub fn all(self) -> bool {\n-                unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n-            }\n-        }\n-    }\n-}\n+impl_float_reductions! { f32 }\n+impl_float_reductions! { f64 }"}, {"sha": "96d46b9a12320c47ddab809abb2a644c0adf47d6", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -1,11 +1,13 @@\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n macro_rules! implement {\n     {\n-        $type:ident, $int_type:ident\n+        $type:ty, $int_type:ty\n     } => {\n         #[cfg(feature = \"std\")]\n-        impl<const LANES: usize> crate::$type<LANES>\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Returns the smallest integer greater than or equal to each lane.\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n@@ -43,9 +45,9 @@ macro_rules! implement {\n             }\n         }\n \n-        impl<const LANES: usize> crate::$type<LANES>\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Rounds toward zero and converts to the same-width integer type, assuming that\n             /// the value is finite and fits in that type.\n@@ -57,19 +59,19 @@ macro_rules! implement {\n             /// * Not be infinite\n             /// * Be representable in the return type, after truncating off its fractional part\n             #[inline]\n-            pub unsafe fn to_int_unchecked(self) -> crate::$int_type<LANES> {\n+            pub unsafe fn to_int_unchecked(self) -> Simd<$int_type, LANES> {\n                 crate::intrinsics::simd_cast(self)\n             }\n \n             /// Creates a floating-point vector from an integer vector.  Rounds values that are\n             /// not exactly representable.\n             #[inline]\n-            pub fn round_from_int(value: crate::$int_type<LANES>) -> Self {\n+            pub fn round_from_int(value: Simd<$int_type, LANES>) -> Self {\n                 unsafe { crate::intrinsics::simd_cast(value) }\n             }\n         }\n     }\n }\n \n-implement! { SimdF32, SimdI32 }\n-implement! { SimdF64, SimdI64 }\n+implement! { f32, i32 }\n+implement! { f64, i64 }"}, {"sha": "bd818f5321182a93d85e9a4f4c38c041eabccd45", "filename": "crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -1,39 +1,39 @@\n macro_rules! impl_to_bytes {\n-    { $name:ident, $size:literal } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $ty:ty, $size:literal } => {\n+        impl<const LANES: usize> crate::Simd<$ty, LANES>\n         where\n             crate::LaneCount<LANES>: crate::SupportedLaneCount,\n             crate::LaneCount<{{ $size * LANES }}>: crate::SupportedLaneCount,\n         {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order.\n-            pub fn to_ne_bytes(self) -> crate::SimdU8<{{ $size * LANES }}> {\n+            pub fn to_ne_bytes(self) -> crate::Simd<u8, {{ $size * LANES }}> {\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Create a native endian integer value from its memory representation as a byte array\n             /// in native endianness.\n-            pub fn from_ne_bytes(bytes: crate::SimdU8<{{ $size * LANES }}>) -> Self {\n+            pub fn from_ne_bytes(bytes: crate::Simd<u8, {{ $size * LANES }}>) -> Self {\n                 unsafe { core::mem::transmute_copy(&bytes) }\n             }\n         }\n     }\n }\n \n-impl_to_bytes! { SimdU8, 1 }\n-impl_to_bytes! { SimdU16, 2 }\n-impl_to_bytes! { SimdU32, 4 }\n-impl_to_bytes! { SimdU64, 8 }\n+impl_to_bytes! { u8, 1 }\n+impl_to_bytes! { u16, 2 }\n+impl_to_bytes! { u32, 4 }\n+impl_to_bytes! { u64, 8 }\n #[cfg(target_pointer_width = \"32\")]\n-impl_to_bytes! { SimdUsize, 4 }\n+impl_to_bytes! { usize, 4 }\n #[cfg(target_pointer_width = \"64\")]\n-impl_to_bytes! { SimdUsize, 8 }\n+impl_to_bytes! { usize, 8 }\n \n-impl_to_bytes! { SimdI8, 1 }\n-impl_to_bytes! { SimdI16, 2 }\n-impl_to_bytes! { SimdI32, 4 }\n-impl_to_bytes! { SimdI64, 8 }\n+impl_to_bytes! { i8, 1 }\n+impl_to_bytes! { i16, 2 }\n+impl_to_bytes! { i32, 4 }\n+impl_to_bytes! { i64, 8 }\n #[cfg(target_pointer_width = \"32\")]\n-impl_to_bytes! { SimdIsize, 4 }\n+impl_to_bytes! { isize, 4 }\n #[cfg(target_pointer_width = \"64\")]\n-impl_to_bytes! { SimdIsize, 8 }\n+impl_to_bytes! { isize, 8 }"}, {"sha": "840ad049d2e34dac1c62a3d34f545190e38d2143", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -7,8 +7,6 @@ use crate::{LaneCount, SupportedLaneCount};\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n     { $name:ident, $type:ident, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl_float_reductions! { $name, $type }\n-\n         impl<const LANES: usize> $name<LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "3dad2abbe7ccc69a53702cc71d37a6067917434d", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -5,8 +5,6 @@ use crate::{LaneCount, SupportedLaneCount};\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n     { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl_integer_reductions! { $name, $type }\n-\n         impl<const LANES: usize> $name<LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "ba6dab930901731163018adeb5fa8fa7b907735c", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -1,12 +1,5 @@\n #![allow(non_camel_case_types)]\n \n-/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_unsigned_vector {\n-    { $name:ident, $type:ty } => {\n-        impl_integer_reductions! { $name, $type }\n-    }\n-}\n-\n /// A SIMD vector of containing `LANES` `u8` values.\n pub type SimdU8<const LANES: usize> = crate::Simd<u8, LANES>;\n \n@@ -22,12 +15,6 @@ pub type SimdU64<const LANES: usize> = crate::Simd<u64, LANES>;\n /// A SIMD vector of containing `LANES` `usize` values.\n pub type SimdUsize<const LANES: usize> = crate::Simd<usize, LANES>;\n \n-impl_unsigned_vector! { SimdUsize, usize }\n-impl_unsigned_vector! { SimdU16, u16 }\n-impl_unsigned_vector! { SimdU32, u32 }\n-impl_unsigned_vector! { SimdU64, u64 }\n-impl_unsigned_vector! { SimdU8, u8 }\n-\n /// Vector of two `usize` values\n pub type usizex2 = SimdUsize<2>;\n "}, {"sha": "e39173a9c3c40506fd2dc46bcca896f0cc8038c9", "filename": "crates/core_simd/src/vendor/arm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -28,26 +28,26 @@ from_transmute! { unsafe u32x4 => uint32x4_t }\n from_transmute! { unsafe i32x2 => int32x2_t }\n from_transmute! { unsafe i32x4 => int32x4_t }\n \n-from_transmute! { unsafe SimdU64<1> => uint64x1_t }\n+from_transmute! { unsafe Simd<u64, 1> => uint64x1_t }\n from_transmute! { unsafe u64x2 => uint64x2_t }\n-from_transmute! { unsafe SimdI64<1> => int64x1_t }\n+from_transmute! { unsafe Simd<i64, 1> => int64x1_t }\n from_transmute! { unsafe i64x2 => int64x2_t }\n-from_transmute! { unsafe SimdU64<1> => poly64x1_t }\n+from_transmute! { unsafe Simd<u64, 1> => poly64x1_t }\n from_transmute! { unsafe u64x2 => poly64x2_t }\n \n #[cfg(target_arch = \"arm\")]\n mod arm {\n     use super::*;\n-    from_transmute! { unsafe SimdU8<4> => uint8x4_t }\n-    from_transmute! { unsafe SimdI8<4> => int8x4_t }\n+    from_transmute! { unsafe Simd<u8, 4> => uint8x4_t }\n+    from_transmute! { unsafe Simd<i8, 4> => int8x4_t }\n \n-    from_transmute! { unsafe SimdU16<2> => uint16x2_t }\n-    from_transmute! { unsafe SimdI16<2> => int16x2_t }\n+    from_transmute! { unsafe Simd<u16, 2> => uint16x2_t }\n+    from_transmute! { unsafe Simd<i16, 2> => int16x2_t }\n }\n \n #[cfg(target_arch = \"aarch64\")]\n mod aarch64 {\n     use super::*;\n-    from_transmute! { unsafe SimdF64<1> => float64x1_t }\n+    from_transmute! { unsafe Simd<f64, 1> => float64x1_t }\n     from_transmute! { unsafe f64x2 => float64x2_t }\n }"}, {"sha": "0090c37564813952c33f38957a6e026136d11436", "filename": "crates/core_simd/src/vendor/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed57b4c85a7a9c104b093afbf54d5b7e25069de/crates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs?ref=5ed57b4c85a7a9c104b093afbf54d5b7e25069de", "patch": "@@ -45,10 +45,10 @@ mod p32 {\n     use super::*;\n     from_transmute! { unsafe usizex4 => __m128i }\n     from_transmute! { unsafe usizex8 => __m256i }\n-    from_transmute! { unsafe SimdUsize<16> => __m512i }\n+    from_transmute! { unsafe Simd<usize, 16> => __m512i }\n     from_transmute! { unsafe isizex4 => __m128i }\n     from_transmute! { unsafe isizex8 => __m256i }\n-    from_transmute! { unsafe SimdIsize<16> => __m512i }\n+    from_transmute! { unsafe Simd<isize, 16> => __m512i }\n }\n \n #[cfg(target_pointer_width = \"64\")]"}]}