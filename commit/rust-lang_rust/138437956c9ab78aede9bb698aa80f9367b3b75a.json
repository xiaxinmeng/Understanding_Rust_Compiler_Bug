{"sha": "138437956c9ab78aede9bb698aa80f9367b3b75a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzODQzNzk1NmM5YWI3OGFlZGU5YmI2OThhYTgwZjkzNjdiM2I3NWE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-05-07T02:03:14Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-05-10T23:58:17Z"}, "message": "initial port of the exchange allocator to jemalloc\n\nIn stage0, all allocations are 8-byte aligned. Passing a size and\nalignment to free is not yet implemented everywhere (0 size and 8 align\nare used as placeholders). Fixing this is part of #13994.\n\nCloses #13616", "tree": {"sha": "b1614baf6a134ee7e8a6f728c86ceb9f4996dd60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1614baf6a134ee7e8a6f728c86ceb9f4996dd60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/138437956c9ab78aede9bb698aa80f9367b3b75a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/138437956c9ab78aede9bb698aa80f9367b3b75a", "html_url": "https://github.com/rust-lang/rust/commit/138437956c9ab78aede9bb698aa80f9367b3b75a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/138437956c9ab78aede9bb698aa80f9367b3b75a/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaf6e06b01c4f7490e71693d3c96f466032e80d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf6e06b01c4f7490e71693d3c96f466032e80d0", "html_url": "https://github.com/rust-lang/rust/commit/aaf6e06b01c4f7490e71693d3c96f466032e80d0"}], "stats": {"total": 370, "additions": 219, "deletions": 151}, "files": [{"sha": "526b72e9b86acfd09aebd3ff04426bb4af876abe", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -37,7 +37,7 @@ use std::mem::min_align_of;\n use std::num;\n use std::ptr::read;\n use std::rc::Rc;\n-use std::rt::global_heap;\n+use std::rt::heap::exchange_malloc;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -365,7 +365,7 @@ impl<T> TypedArenaChunk<T> {\n         size = size.checked_add(&elems_size).unwrap();\n \n         let mut chunk = unsafe {\n-            let chunk = global_heap::exchange_malloc(size);\n+            let chunk = exchange_malloc(size);\n             let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk\n@@ -386,7 +386,7 @@ impl<T> TypedArenaChunk<T> {\n         size = size.checked_add(&elems_size).unwrap();\n \n         let mut chunk = unsafe {\n-            let chunk = global_heap::exchange_malloc(size, min_align_of::<TypedArenaChunk<T>>());\n+            let chunk = exchange_malloc(size, min_align_of::<TypedArenaChunk<T>>());\n             let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk"}, {"sha": "f199aa051d1663416c00d97c8f2be5944c98119e", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -33,7 +33,7 @@ extern {\n     fn rust_malloc(size: uint) -> *u8;\n     #[cfg(not(stage0))]\n     fn rust_malloc(size: uint, align: uint) -> *u8;\n-    fn rust_free(ptr: *u8);\n+    fn rust_free(ptr: *u8, size: uint, align: uint);\n }\n \n #[cfg(stage0)]\n@@ -51,6 +51,7 @@ unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n #[cfg(not(stage0))]\n unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n     let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n+    // this should use the real alignment, but the new representation will take care of that\n     let ret = rust_malloc(cap, 8) as *mut Vec<()>;\n     if ret.is_null() {\n         intrinsics::abort();\n@@ -118,7 +119,8 @@ impl FromIterator<char> for ~str {\n                     ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n                                                     &(*ptr).data,\n                                                     len);\n-                    rust_free(ptr as *u8);\n+                    // FIXME: #13994: port to the sized deallocation API when available\n+                    rust_free(ptr as *u8, 0, 8);\n                     cast::forget(ret);\n                     ret = cast::transmute(ptr2);\n                     ptr = ptr2;\n@@ -188,7 +190,7 @@ impl<A: Clone> Clone for ~[A] {\n                     for j in range(0, *i as int) {\n                         ptr::read(&*p.offset(j));\n                     }\n-                    rust_free(ret as *u8);\n+                    rust_free(ret as *u8, 0, 8);\n                 });\n             cast::transmute(ret)\n         }"}, {"sha": "3f22a76c1f4e78ec9243f372c58099e882eaf568", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -110,6 +110,7 @@\n // Don't link to std. We are std.\n #![no_std]\n \n+#![allow(deprecated)]\n #![deny(missing_doc)]\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print"}, {"sha": "e0fe75fd907101aa291ca6726c80c739eedec0b9", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -32,7 +32,8 @@ use ops::{Deref, Drop};\n use option::{Option, Some, None};\n use ptr;\n use ptr::RawPtr;\n-use rt::global_heap::exchange_free;\n+use mem::{min_align_of, size_of};\n+use rt::heap::exchange_free;\n \n struct RcBox<T> {\n     value: T,\n@@ -104,7 +105,8 @@ impl<T> Drop for Rc<T> {\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n-                        exchange_free(self.ptr as *u8)\n+                        exchange_free(self.ptr as *mut u8, size_of::<RcBox<T>>(),\n+                                      min_align_of::<RcBox<T>>())\n                     }\n                 }\n             }\n@@ -177,7 +179,8 @@ impl<T> Drop for Weak<T> {\n                 // the weak count starts at 1, and will only go to\n                 // zero if all the strong pointers have disappeared.\n                 if self.weak() == 0 {\n-                    exchange_free(self.ptr as *u8)\n+                    exchange_free(self.ptr as *mut u8, size_of::<RcBox<T>>(),\n+                                  min_align_of::<RcBox<T>>())\n                 }\n             }\n         }"}, {"sha": "ece51ab99893c9953eb5d4d9af897ba66cdd52be", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -14,23 +14,6 @@\n use libc::{c_void, size_t, free, malloc, realloc};\n use ptr::{RawPtr, mut_null};\n use intrinsics::abort;\n-use raw;\n-use mem::size_of;\n-\n-#[inline]\n-pub fn get_box_size(body_size: uint, body_align: uint) -> uint {\n-    let header_size = size_of::<raw::Box<()>>();\n-    let total_size = align_to(header_size, body_align) + body_size;\n-    total_size\n-}\n-\n-// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n-// of two.\n-#[inline]\n-fn align_to(size: uint, align: uint) -> uint {\n-    assert!(align != 0);\n-    (size + align - 1) & !(align - 1)\n-}\n \n /// A wrapper around libc::malloc, aborting on out-of-memory\n #[inline]\n@@ -66,117 +49,3 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n         p as *mut u8\n     }\n }\n-\n-/// The allocator for unique pointers without contained managed pointers.\n-#[cfg(not(test), stage0)]\n-#[lang=\"exchange_malloc\"]\n-#[inline]\n-pub unsafe fn exchange_malloc(size: uint) -> *mut u8 {\n-    // The compiler never calls `exchange_free` on Box<ZeroSizeType>, so\n-    // zero-size allocations can point to this `static`. It would be incorrect\n-    // to use a null pointer, due to enums assuming types like unique pointers\n-    // are never null.\n-    static EMPTY: () = ();\n-\n-    if size == 0 {\n-        &EMPTY as *() as *mut u8\n-    } else {\n-        malloc_raw(size)\n-    }\n-}\n-\n-/// The allocator for unique pointers without contained managed pointers.\n-#[cfg(not(test), not(stage0))]\n-#[lang=\"exchange_malloc\"]\n-#[inline]\n-pub unsafe fn exchange_malloc(size: uint, _align: uint) -> *mut u8 {\n-    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n-    // allocations can point to this `static`. It would be incorrect to use a null\n-    // pointer, due to enums assuming types like unique pointers are never null.\n-    static EMPTY: () = ();\n-\n-    if size == 0 {\n-        &EMPTY as *() as *mut u8\n-    } else {\n-        malloc_raw(size)\n-    }\n-}\n-\n-// FIXME: #7496\n-#[cfg(not(test))]\n-#[lang=\"closure_exchange_malloc\"]\n-#[inline]\n-pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n-    closure_exchange_malloc(drop_glue, size, align)\n-}\n-\n-#[inline]\n-pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n-    let total_size = get_box_size(size, align);\n-    let p = malloc_raw(total_size);\n-\n-    let alloc = p as *mut raw::Box<()>;\n-    (*alloc).drop_glue = drop_glue;\n-\n-    alloc as *u8\n-}\n-\n-// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n-// inside a landing pad may corrupt the state of the exception handler.\n-#[cfg(not(test))]\n-#[lang=\"exchange_free\"]\n-#[inline]\n-pub unsafe fn exchange_free_(ptr: *u8) {\n-    exchange_free(ptr)\n-}\n-\n-#[inline]\n-pub unsafe fn exchange_free(ptr: *u8) {\n-    free(ptr as *mut c_void);\n-}\n-\n-// hack for libcore\n-#[no_mangle]\n-#[doc(hidden)]\n-#[deprecated]\n-#[cfg(stage0)]\n-pub extern \"C\" fn rust_malloc(size: uint) -> *mut u8 {\n-    unsafe { exchange_malloc(size) }\n-}\n-\n-// hack for libcore\n-#[no_mangle]\n-#[doc(hidden)]\n-#[deprecated]\n-#[cfg(not(stage0))]\n-pub extern \"C\" fn rust_malloc(size: uint, align: uint) -> *mut u8 {\n-    unsafe { exchange_malloc(size, align) }\n-}\n-\n-// hack for libcore\n-#[no_mangle]\n-#[doc(hidden)]\n-#[deprecated]\n-pub extern \"C\" fn rust_free(ptr: *u8) {\n-    unsafe { exchange_free(ptr) }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-\n-    #[bench]\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            box 10\n-        })\n-    }\n-\n-    #[bench]\n-    fn alloc_owned_big(b: &mut Bencher) {\n-        b.iter(|| {\n-            box [10, ..1000]\n-        })\n-    }\n-}"}, {"sha": "30583f76330b9549c8a4e82dd5260562324b63a5", "filename": "src/libstd/rt/heap.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fheap.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -98,3 +98,125 @@ pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n pub fn usable_size(size: uint, align: uint) -> uint {\n     unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n }\n+\n+/// The allocator for unique pointers.\n+#[cfg(stage0)]\n+#[lang=\"exchange_malloc\"]\n+#[inline(always)]\n+pub unsafe fn exchange_malloc_(size: uint) -> *mut u8 {\n+    exchange_malloc(size)\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(not(test), not(stage0))]\n+#[lang=\"exchange_malloc\"]\n+#[inline(always)]\n+pub unsafe fn exchange_malloc_(size: uint, align: uint) -> *mut u8 {\n+    exchange_malloc(size, align)\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(stage0)]\n+#[inline]\n+pub unsafe fn exchange_malloc(size: uint) -> *mut u8 {\n+    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+    // allocations can point to this `static`. It would be incorrect to use a null\n+    // pointer, due to enums assuming types like unique pointers are never null.\n+    static EMPTY: () = ();\n+\n+    if size == 0 {\n+        &EMPTY as *() as *mut u8\n+    } else {\n+        allocate(size, 8)\n+    }\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n+    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+    // allocations can point to this `static`. It would be incorrect to use a null\n+    // pointer, due to enums assuming types like unique pointers are never null.\n+    static EMPTY: () = ();\n+\n+    if size == 0 {\n+        &EMPTY as *() as *mut u8\n+    } else {\n+        allocate(size, align)\n+    }\n+}\n+\n+#[cfg(not(test))]\n+#[lang=\"exchange_free\"]\n+#[inline]\n+// FIXME: #13994 (rustc should pass align and size here)\n+pub unsafe fn exchange_free_(ptr: *mut u8) {\n+    exchange_free(ptr, 0, 8)\n+}\n+\n+#[inline]\n+pub unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n+    deallocate(ptr, size, align);\n+}\n+\n+// FIXME: #7496\n+#[cfg(not(test))]\n+#[lang=\"closure_exchange_malloc\"]\n+#[inline]\n+unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut u8 {\n+    let total_size = ::rt::util::get_box_size(size, align);\n+    let p = allocate(total_size, 8);\n+\n+    let alloc = p as *mut ::raw::Box<()>;\n+    (*alloc).drop_glue = drop_glue;\n+\n+    alloc as *mut u8\n+}\n+\n+// hack for libcore\n+#[no_mangle]\n+#[doc(hidden)]\n+#[deprecated]\n+#[cfg(stage0, not(test))]\n+pub extern \"C\" fn rust_malloc(size: uint) -> *mut u8 {\n+    unsafe { exchange_malloc(size) }\n+}\n+\n+// hack for libcore\n+#[no_mangle]\n+#[doc(hidden)]\n+#[deprecated]\n+#[cfg(not(stage0), not(test))]\n+pub extern \"C\" fn rust_malloc(size: uint, align: uint) -> *mut u8 {\n+    unsafe { exchange_malloc(size, align) }\n+}\n+\n+// hack for libcore\n+#[no_mangle]\n+#[doc(hidden)]\n+#[deprecated]\n+#[cfg(not(test))]\n+pub extern \"C\" fn rust_free(ptr: *mut u8, size: uint, align: uint) {\n+    unsafe { exchange_free(ptr, size, align) }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+    use self::test::Bencher;\n+\n+    #[bench]\n+    fn alloc_owned_small(b: &mut Bencher) {\n+        b.iter(|| {\n+            box 10\n+        })\n+    }\n+\n+    #[bench]\n+    fn alloc_owned_big(b: &mut Bencher) {\n+        b.iter(|| {\n+            box [10, ..1000]\n+        })\n+    }\n+}"}, {"sha": "8795736b3f58edbca6b9a4ba47377c48094aa8c1", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -12,6 +12,7 @@\n \n use cast;\n use iter::Iterator;\n+use libc::{c_void, free};\n use mem;\n use ops::Drop;\n use option::{Option, None, Some};\n@@ -58,7 +59,7 @@ impl LocalHeap {\n \n     #[inline]\n     pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n-        let total_size = global_heap::get_box_size(size, align);\n+        let total_size = ::rt::util::get_box_size(size, align);\n         let alloc = self.memory_region.malloc(total_size);\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n@@ -226,7 +227,7 @@ impl MemoryRegion {\n             self.release(cast::transmute(alloc));\n             rtassert!(self.live_allocations > 0);\n             self.live_allocations -= 1;\n-            global_heap::exchange_free(alloc as *u8)\n+            free(alloc as *mut c_void)\n         }\n     }\n "}, {"sha": "e8b1acb10241f331d970058695aeeb6810e0e437", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -26,6 +26,23 @@ use slice::ImmutableVector;\n // FIXME: Once the runtime matures remove the `true` below to turn off rtassert, etc.\n pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(rtassert);\n \n+#[deprecated]\n+#[doc(hidden)]\n+#[inline]\n+pub fn get_box_size(body_size: uint, body_align: uint) -> uint {\n+    let header_size = ::mem::size_of::<::raw::Box<()>>();\n+    let total_size = align_to(header_size, body_align) + body_size;\n+    total_size\n+}\n+\n+// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n+// of two.\n+#[inline]\n+fn align_to(size: uint, align: uint) -> uint {\n+    assert!(align != 0);\n+    (size + align - 1) & !(align - 1)\n+}\n+\n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n     unsafe {"}, {"sha": "b97c55ad70139a6957bca134bd1dc28318efd457", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -110,7 +110,7 @@ use ops::Drop;\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use ptr;\n-use rt::global_heap::{exchange_free};\n+use rt::heap::{exchange_malloc, exchange_free};\n use unstable::finally::try_finally;\n use vec::Vec;\n \n@@ -292,9 +292,9 @@ pub trait CloneableVector<T> {\n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n+    #[cfg(stage0)]\n     fn to_owned(&self) -> ~[T] {\n         use RawVec = core::raw::Vec;\n-        use rt::global_heap::{malloc_raw, exchange_free};\n         use num::{CheckedAdd, CheckedMul};\n         use option::Expect;\n \n@@ -305,7 +305,8 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n         let size = size.expect(\"overflow in to_owned()\");\n \n         unsafe {\n-            let ret = malloc_raw(size) as *mut RawVec<()>;\n+            // this should pass the real required alignment\n+            let ret = exchange_malloc(size) as *mut RawVec<()>;\n \n             (*ret).fill = len * mem::nonzero_size_of::<T>();\n             (*ret).alloc = len * mem::nonzero_size_of::<T>();\n@@ -329,7 +330,55 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                     for j in range(0, *i as int) {\n                         ptr::read(&*p.offset(j));\n                     }\n-                    exchange_free(ret as *u8);\n+                    // FIXME: #13994 (should pass align and size here)\n+                    exchange_free(ret as *mut u8, 0, 8);\n+                });\n+            cast::transmute(ret)\n+        }\n+    }\n+\n+    /// Returns a copy of `v`.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn to_owned(&self) -> ~[T] {\n+        use RawVec = core::raw::Vec;\n+        use num::{CheckedAdd, CheckedMul};\n+        use option::Expect;\n+\n+        let len = self.len();\n+        let data_size = len.checked_mul(&mem::size_of::<T>());\n+        let data_size = data_size.expect(\"overflow in to_owned()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in to_owned()\");\n+\n+        unsafe {\n+            // this should pass the real required alignment\n+            let ret = exchange_malloc(size, 8) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<T>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+\n+            // Be careful with the following loop. We want it to be optimized\n+            // to a memcpy (or something similarly fast) when T is Copy. LLVM\n+            // is easily confused, so any extra operations during the loop can\n+            // prevent this optimization.\n+            let mut i = 0;\n+            let p = &mut (*ret).data as *mut _ as *mut T;\n+            try_finally(\n+                &mut i, (),\n+                |i, ()| while *i < len {\n+                    mem::move_val_init(\n+                        &mut(*p.offset(*i as int)),\n+                        self.unsafe_ref(*i).clone());\n+                    *i += 1;\n+                },\n+                |i| if *i < len {\n+                    // we must be failing, clean up after ourselves\n+                    for j in range(0, *i as int) {\n+                        ptr::read(&*p.offset(j));\n+                    }\n+                    // FIXME: #13994 (should pass align and size here)\n+                    exchange_free(ret as *mut u8, 0, 8);\n                 });\n             cast::transmute(ret)\n         }\n@@ -768,7 +817,8 @@ impl<T> Drop for MoveItems<T> {\n         // destroy the remaining elements\n         for _x in *self {}\n         unsafe {\n-            exchange_free(self.allocation as *u8)\n+            // FIXME: #13994 (should pass align and size here)\n+            exchange_free(self.allocation, 0, 8)\n         }\n     }\n }"}, {"sha": "31b4112f1e7a51b5580f6046b17bd316bcf15fb1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -1512,7 +1512,7 @@ impl<T> FromVec<T> for ~[T] {\n         let vp = v.as_mut_ptr();\n \n         unsafe {\n-            let ret = malloc_raw(size) as *mut RawVec<()>;\n+            let ret = allocate(size, 8) as *mut RawVec<()>;\n \n             (*ret).fill = len * mem::nonzero_size_of::<T>();\n             (*ret).alloc = len * mem::nonzero_size_of::<T>();"}, {"sha": "226eb7afb5f801f4d44cd809ff484540e3543db3", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138437956c9ab78aede9bb698aa80f9367b3b75a/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=138437956c9ab78aede9bb698aa80f9367b3b75a", "patch": "@@ -15,8 +15,9 @@\n \n use std::cast;\n use std::ptr;\n-use std::rt::global_heap;\n+use std::rt::heap::exchange_free;\n use std::sync::atomics;\n+use std::mem::{min_align_of, size_of};\n \n /// An atomically reference counted wrapper for shared state.\n ///\n@@ -190,7 +191,8 @@ impl<T: Share + Send> Drop for Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, atomics::Release) == 1 {\n             atomics::fence(atomics::Acquire);\n-            unsafe { global_heap::exchange_free(self.x as *u8) }\n+            unsafe { exchange_free(self.x as *mut u8, size_of::<ArcInner<T>>(),\n+                                   min_align_of::<ArcInner<T>>()) }\n         }\n     }\n }\n@@ -240,7 +242,8 @@ impl<T: Share + Send> Drop for Weak<T> {\n         // the memory orderings\n         if self.inner().weak.fetch_sub(1, atomics::Release) == 1 {\n             atomics::fence(atomics::Acquire);\n-            unsafe { global_heap::exchange_free(self.x as *u8) }\n+            unsafe { exchange_free(self.x as *mut u8, size_of::<ArcInner<T>>(),\n+                                   min_align_of::<ArcInner<T>>()) }\n         }\n     }\n }"}]}