{"sha": "f733f484f80a6dc627cca62c74b750de74f49031", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MzNmNDg0ZjgwYTZkYzYyN2NjYTYyYzc0Yjc1MGRlNzRmNDkwMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-08T09:43:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-08T09:43:27Z"}, "message": "Auto merge of #45862 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 4 pull requests\n\n- Successful merges: #45582, #45766, #45830, #45849\n- Failed merges:", "tree": {"sha": "cb0012d9458fcadaf99ab95e16e9d1aec0614176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb0012d9458fcadaf99ab95e16e9d1aec0614176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f733f484f80a6dc627cca62c74b750de74f49031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f733f484f80a6dc627cca62c74b750de74f49031", "html_url": "https://github.com/rust-lang/rust/commit/f733f484f80a6dc627cca62c74b750de74f49031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f733f484f80a6dc627cca62c74b750de74f49031/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49bee9d09a8f8c2baf4aff7d6a46cebff0c64594", "url": "https://api.github.com/repos/rust-lang/rust/commits/49bee9d09a8f8c2baf4aff7d6a46cebff0c64594", "html_url": "https://github.com/rust-lang/rust/commit/49bee9d09a8f8c2baf4aff7d6a46cebff0c64594"}, {"sha": "661c507a2eaad79bd04ffb3e159e981e4762dfb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/661c507a2eaad79bd04ffb3e159e981e4762dfb0", "html_url": "https://github.com/rust-lang/rust/commit/661c507a2eaad79bd04ffb3e159e981e4762dfb0"}], "stats": {"total": 313, "additions": 276, "deletions": 37}, "files": [{"sha": "8c14d1bbe8f8ac02ba9500335b758cbffe06dccf", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -105,7 +105,7 @@ r##\"<!DOCTYPE html>\n                     <dd>Switch tab</dd>\n                     <dt>&#9166;</dt>\n                     <dd>Go to active search result</dd>\n-                    <dt>+</dt>\n+                    <dt style=\"width:31px;\">+ / -</dt>\n                     <dd>Collapse/expand all sections</dd>\n                 </dl>\n             </div>"}, {"sha": "eb59c57603aaed77eb0a1946e12b1ecf65cd17dd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 139, "deletions": 31, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -2498,7 +2498,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n         if !foreign.is_empty() {\n             write!(w, \"\n-                <h2 id='foreign-impls' class='section-header'>\n+                <h2 id='foreign-impls' class='small-section-header'>\n                   Implementations on Foreign Types<a href='#foreign-impls' class='anchor'></a>\n                 </h2>\n             \")?;\n@@ -3591,7 +3591,8 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n             let mut links = HashSet::new();\n             let ret = v.iter()\n                        .filter_map(|i| if let Some(ref i) = i.inner_impl().trait_ {\n-                           let out = format!(\"{:#}\", i).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\n+                           let i_display = format!(\"{:#}\", i);\n+                           let out = Escape(&i_display);\n                            let encoded = small_url_encode(&format!(\"{:#}\", i));\n                            let generated = format!(\"<a href=\\\"#impl-{}\\\">{}</a>\", encoded, out);\n                            if !links.contains(&generated) && links.insert(generated.clone()) {\n@@ -3617,11 +3618,12 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n                   s: &clean::Struct) -> fmt::Result {\n     let mut sidebar = String::new();\n+    let fields = get_struct_fields_name(&s.fields);\n \n-    if s.fields.iter()\n-               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n+    if !fields.is_empty() {\n         if let doctree::Plain = s.struct_type {\n-            sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+            sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#fields\\\">Fields</a>\\\n+                                       <div class=\\\"sidebar-links\\\">{}</div>\", fields));\n         }\n     }\n \n@@ -3633,40 +3635,122 @@ fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n+fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n+    match item.inner {\n+        clean::ItemEnum::ImplItem(ref i) => {\n+            if let Some(ref trait_) = i.trait_ {\n+                Some((format!(\"{:#}\", i.for_), format!(\"{:#}\", trait_)))\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n                  t: &clean::Trait) -> fmt::Result {\n     let mut sidebar = String::new();\n \n-    let has_types = t.items.iter().any(|m| m.is_associated_type());\n-    let has_consts = t.items.iter().any(|m| m.is_associated_const());\n-    let has_required = t.items.iter().any(|m| m.is_ty_method());\n-    let has_provided = t.items.iter().any(|m| m.is_method());\n+    let types = t.items\n+                 .iter()\n+                 .filter_map(|m| {\n+                     match m.name {\n+                         Some(ref name) if m.is_associated_type() => {\n+                             Some(format!(\"<a href=\\\"#associatedtype.{name}\\\">{name}</a>\",\n+                                          name=name))\n+                         }\n+                         _ => None,\n+                     }\n+                 })\n+                 .collect::<String>();\n+    let consts = t.items\n+                  .iter()\n+                  .filter_map(|m| {\n+                      match m.name {\n+                          Some(ref name) if m.is_associated_const() => {\n+                              Some(format!(\"<a href=\\\"#associatedconstant.{name}\\\">{name}</a>\",\n+                                           name=name))\n+                          }\n+                          _ => None,\n+                      }\n+                  })\n+                  .collect::<String>();\n+    let required = t.items\n+                    .iter()\n+                    .filter_map(|m| {\n+                        match m.name {\n+                            Some(ref name) if m.is_ty_method() => {\n+                                Some(format!(\"<a href=\\\"#tymethod.{name}\\\">{name}</a>\",\n+                                             name=name))\n+                            }\n+                            _ => None,\n+                        }\n+                    })\n+                    .collect::<String>();\n+    let provided = t.items\n+                    .iter()\n+                    .filter_map(|m| {\n+                        match m.name {\n+                            Some(ref name) if m.is_method() => {\n+                                Some(format!(\"<a href=\\\"#method.{name}\\\">{name}</a>\", name=name))\n+                            }\n+                            _ => None,\n+                        }\n+                    })\n+                    .collect::<String>();\n \n-    if has_types {\n-        sidebar.push_str(\"<li><a href=\\\"#associated-types\\\">Associated Types</a></li>\");\n+    if !types.is_empty() {\n+        sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#associated-types\\\">\\\n+                                   Associated Types</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                                  types));\n     }\n-    if has_consts {\n-        sidebar.push_str(\"<li><a href=\\\"#associated-const\\\">Associated Constants</a></li>\");\n+    if !consts.is_empty() {\n+        sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#associated-const\\\">\\\n+                                   Associated Constants</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                                  consts));\n     }\n-    if has_required {\n-        sidebar.push_str(\"<li><a href=\\\"#required-methods\\\">Required Methods</a></li>\");\n+    if !required.is_empty() {\n+        sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#required-methods\\\">\\\n+                                   Required Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                                  required));\n     }\n-    if has_provided {\n-        sidebar.push_str(\"<li><a href=\\\"#provided-methods\\\">Provided Methods</a></li>\");\n+    if !provided.is_empty() {\n+        sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#provided-methods\\\">\\\n+                                   Provided Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                                  provided));\n     }\n \n     let c = cache();\n \n     if let Some(implementors) = c.implementors.get(&it.def_id) {\n-        if implementors.iter().any(|i| i.impl_.for_.def_id()\n-                                   .map_or(false, |d| !c.paths.contains_key(&d)))\n-        {\n-            sidebar.push_str(\"<li><a href=\\\"#foreign-impls\\\">\\\n-                             Implementations on Foreign Types</a></li>\");\n-        }\n-    }\n-\n-    sidebar.push_str(\"<li><a href=\\\"#implementors\\\">Implementors</a></li>\");\n+        let res = implementors.iter()\n+                              .filter(|i| i.impl_.for_.def_id()\n+                                                      .map_or(false, |d| !c.paths.contains_key(&d)))\n+                              .filter_map(|i| {\n+                                  if let Some(item) = implementor2item(&c, i) {\n+                                      match extract_for_impl_name(&item) {\n+                                          Some((ref name, ref url)) => {\n+                                              Some(format!(\"<a href=\\\"#impl-{}\\\">{}</a>\",\n+                                                           small_url_encode(url),\n+                                                           Escape(name)))\n+                                          }\n+                                          _ => None,\n+                                      }\n+                                  } else {\n+                                      None\n+                                  }\n+                              })\n+                              .collect::<String>();\n+        if !res.is_empty() {\n+            sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#foreign-impls\\\">\\\n+                                       Implementations on Foreign Types</a><div \\\n+                                       class=\\\"sidebar-links\\\">{}</div>\",\n+                                      res));\n+        }\n+    }\n+\n+    sidebar.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementors\\\">Implementors</a>\");\n \n     sidebar.push_str(&sidebar_assoc_items(it));\n \n@@ -3693,13 +3777,29 @@ fn sidebar_typedef(fmt: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n+fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n+    fields.iter()\n+          .filter(|f| if let clean::StructFieldItem(..) = f.inner {\n+              true\n+          } else {\n+              false\n+          })\n+          .filter_map(|f| match f.name {\n+              Some(ref name) => Some(format!(\"<a href=\\\"#structfield.{name}\\\">\\\n+                                              {name}</a>\", name=name)),\n+              _ => None,\n+          })\n+          .collect()\n+}\n+\n fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n                  u: &clean::Union) -> fmt::Result {\n     let mut sidebar = String::new();\n+    let fields = get_struct_fields_name(&u.fields);\n \n-    if u.fields.iter()\n-               .any(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false }) {\n-        sidebar.push_str(\"<li><a href=\\\"#fields\\\">Fields</a></li>\");\n+    if !fields.is_empty() {\n+        sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#fields\\\">Fields</a>\\\n+                                   <div class=\\\"sidebar-links\\\">{}</div>\", fields));\n     }\n \n     sidebar.push_str(&sidebar_assoc_items(it));\n@@ -3714,8 +3814,16 @@ fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n                 e: &clean::Enum) -> fmt::Result {\n     let mut sidebar = String::new();\n \n-    if !e.variants.is_empty() {\n-        sidebar.push_str(\"<li><a href=\\\"#variants\\\">Variants</a></li>\");\n+    let variants = e.variants.iter()\n+                             .filter_map(|v| match v.name {\n+                                 Some(ref name) => Some(format!(\"<a href=\\\"#variant.{name}\\\">{name}\\\n+                                                                 </a>\", name = name)),\n+                                 _ => None,\n+                             })\n+                             .collect::<String>();\n+    if !variants.is_empty() {\n+        sidebar.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#variants\\\">Variants</a>\\\n+                                   <div class=\\\"sidebar-links\\\">{}</div>\", variants));\n     }\n \n     sidebar.push_str(&sidebar_assoc_items(it));"}, {"sha": "1d9bfa260bf5b1af08ba3e07cb7a8279304c0d27", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -213,6 +213,7 @@\n             break;\n \n         case \"+\":\n+        case \"-\":\n             ev.preventDefault();\n             toggleAllDocs();\n             break;"}, {"sha": "599b032b6303055a5ec29296c07985e2c716542d", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -582,13 +582,14 @@ body.blur > :not(#help) {\n \tdisplay: block;\n \tmargin-top: -1px;\n }\n-#help dd { margin: 5px 33px; }\n+#help dd { margin: 5px 35px; }\n #help .infos { padding-left: 0; }\n #help h1, #help h2 { margin-top: 0; }\n #help > div div {\n \twidth: 50%;\n \tfloat: left;\n \tpadding: 20px;\n+\tpadding-left: 17px;\n }\n \n .stab {"}, {"sha": "457c6e1409d3cf60628a18268c4558f548ee3274", "filename": "src/libstd/env.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -671,6 +671,10 @@ pub struct ArgsOs { inner: sys::args::Args }\n /// set to arbitrary text, and may not even exist. This means this property should\n /// not be relied upon for security purposes.\n ///\n+/// On Unix systems shell usually expands unquoted arguments with glob patterns\n+/// (such as `*` and `?`). On Windows this is not done, and such arguments are\n+/// passed as-is.\n+///\n /// # Panics\n ///\n /// The returned iterator will panic during iteration if any argument to the"}, {"sha": "15f858bca164310d7a27e6c49f697ad80b20c922", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -20,7 +20,9 @@ use sys;\n use sys_common::{FromInner, AsInner, AsInnerMut};\n use sys::platform::fs::MetadataExt as UnixMetadataExt;\n \n-/// Unix-specific extensions to `File`\n+/// Unix-specific extensions to [`File`].\n+///\n+/// [`File`]: ../../../../std/fs/struct.File.html\n #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n pub trait FileExt {\n     /// Reads a number of bytes starting from a given offset.\n@@ -515,19 +517,79 @@ impl MetadataExt for fs::Metadata {\n     fn blocks(&self) -> u64 { self.st_blocks() }\n }\n \n-/// Add special unix types (block/char device, fifo and socket)\n+/// Add support for special unix types (block/char device, fifo and socket).\n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n pub trait FileTypeExt {\n     /// Returns whether this file type is a block device.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    ///\n+    /// # use std::io;\n+    /// # fn f() -> io::Result<()> {\n+    /// let meta = fs::metadata(\"block_device_file\")?;\n+    /// let file_type = meta.file_type();\n+    /// assert!(file_type.is_block_device());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_block_device(&self) -> bool;\n     /// Returns whether this file type is a char device.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    ///\n+    /// # use std::io;\n+    /// # fn f() -> io::Result<()> {\n+    /// let meta = fs::metadata(\"char_device_file\")?;\n+    /// let file_type = meta.file_type();\n+    /// assert!(file_type.is_char_device());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_char_device(&self) -> bool;\n     /// Returns whether this file type is a fifo.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    ///\n+    /// # use std::io;\n+    /// # fn f() -> io::Result<()> {\n+    /// let meta = fs::metadata(\"fifo_file\")?;\n+    /// let file_type = meta.file_type();\n+    /// assert!(file_type.is_fifo());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_fifo(&self) -> bool;\n     /// Returns whether this file type is a socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    ///\n+    /// # use std::io;\n+    /// # fn f() -> io::Result<()> {\n+    /// let meta = fs::metadata(\"unix.socket\")?;\n+    /// let file_type = meta.file_type();\n+    /// assert!(file_type.is_socket());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_socket(&self) -> bool;\n }\n@@ -540,7 +602,9 @@ impl FileTypeExt for fs::FileType {\n     fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n }\n \n-/// Unix-specific extension methods for `fs::DirEntry`\n+/// Unix-specific extension methods for [`fs::DirEntry`].\n+///\n+/// [`fs::DirEntry`]: ../../../../std/fs/struct.DirEntry.html\n #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n pub trait DirEntryExt {\n     /// Returns the underlying `d_ino` field in the contained `dirent`\n@@ -600,7 +664,9 @@ pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n }\n \n #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-/// An extension trait for `fs::DirBuilder` for unix-specific options.\n+/// An extension trait for [`fs::DirBuilder`] for unix-specific options.\n+///\n+/// [`fs::DirBuilder`]: ../../../../std/fs/struct.DirBuilder.html\n pub trait DirBuilderExt {\n     /// Sets the mode to create new directories with. This option defaults to\n     /// 0o777."}, {"sha": "9be40441e9d4f60fef5f4ed16be864662ace2691", "filename": "src/test/rustdoc/sidebar-items.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f733f484f80a6dc627cca62c74b750de74f49031/src%2Ftest%2Frustdoc%2Fsidebar-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f733f484f80a6dc627cca62c74b750de74f49031/src%2Ftest%2Frustdoc%2Fsidebar-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsidebar-items.rs?ref=f733f484f80a6dc627cca62c74b750de74f49031", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/trait.Foo.html\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#required-methods\"]' 'Required Methods'\n+// @has - '//*[@class=\"sidebar-links\"]/a' 'bar'\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#provided-methods\"]' 'Provided Methods'\n+// @has - '//*[@class=\"sidebar-links\"]/a' 'foo'\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#associated-const\"]' 'Associated Constants'\n+// @has - '//*[@class=\"sidebar-links\"]/a' 'BAR'\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#associated-types\"]' 'Associated Types'\n+// @has - '//*[@class=\"sidebar-links\"]/a' 'Output'\n+pub trait Foo {\n+    const BAR: u32 = 0;\n+    type Output: ?Sized;\n+\n+    fn foo() {}\n+    fn bar() -> Self::Output;\n+}\n+\n+// @has foo/struct.Bar.html\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#fields\"]' 'Fields'\n+// @has - '//*[@class=\"sidebar-links\"]/a[@href=\"#structfield.f\"]' 'f'\n+// @has - '//*[@class=\"sidebar-links\"]/a[@href=\"#structfield.u\"]' 'u'\n+// @!has - '//*[@class=\"sidebar-links\"]/a' 'w'\n+pub struct Bar {\n+    pub f: u32,\n+    pub u: u32,\n+    w: u32,\n+}\n+\n+// @has foo/enum.En.html\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#variants\"]' 'Variants'\n+// @has - '//*[@class=\"sidebar-links\"]/a' 'foo'\n+// @has - '//*[@class=\"sidebar-links\"]/a' 'bar'\n+pub enum En {\n+    foo,\n+    bar,\n+}\n+\n+// @has foo/union.MyUnion.html\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#fields\"]' 'Fields'\n+// @has - '//*[@class=\"sidebar-links\"]/a[@href=\"#structfield.f1\"]' 'f1'\n+// @has - '//*[@class=\"sidebar-links\"]/a[@href=\"#structfield.f2\"]' 'f2'\n+// @!has - '//*[@class=\"sidebar-links\"]/a' 'w'\n+pub union MyUnion {\n+    pub f1: u32,\n+    pub f2: f32,\n+    w: u32,\n+}"}]}