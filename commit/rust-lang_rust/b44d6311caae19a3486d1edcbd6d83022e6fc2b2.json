{"sha": "b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NGQ2MzExY2FhZTE5YTM0ODZkMWVkY2JkNmQ4MzAyMmU2ZmMyYjI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-13T20:38:46Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-14T11:29:04Z"}, "message": "Rustup to rustc 1.42.0-nightly (3ebcfa145 2020-01-12)", "tree": {"sha": "08d3ec19738f27de8d3c5bbdffa39c6fed8a69e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08d3ec19738f27de8d3c5bbdffa39c6fed8a69e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "html_url": "https://github.com/rust-lang/rust/commit/b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c74b3060372cb1057f5623a2d09d8b1599c133f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c74b3060372cb1057f5623a2d09d8b1599c133f8", "html_url": "https://github.com/rust-lang/rust/commit/c74b3060372cb1057f5623a2d09d8b1599c133f8"}], "stats": {"total": 224, "additions": 113, "deletions": 111}, "files": [{"sha": "c5541b1525732a013da3007c28e7728335558f73", "filename": "src/analyze.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "patch": "@@ -23,7 +23,7 @@ pub fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {\n                     Rvalue::Ref(_, _, place) => {\n-                        analyze_non_ssa_place(&mut flag_map, place);\n+                        not_ssa(&mut flag_map, place.local)\n                     }\n                     _ => {}\n                 },\n@@ -36,7 +36,7 @@ pub fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind\n                 if let Some((dest_place, _dest_bb)) = destination {\n                     let dest_layout = fx.layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n                     if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n-                        analyze_non_ssa_place(&mut flag_map, dest_place);\n+                        not_ssa(&mut flag_map, dest_place.local)\n                     }\n                 }\n             }\n@@ -47,13 +47,6 @@ pub fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind\n     flag_map\n }\n \n-fn analyze_non_ssa_place(flag_map: &mut IndexVec<Local, SsaKind>, place: &Place) {\n-    match place.base {\n-        PlaceBase::Local(local) => not_ssa(flag_map, local),\n-        _ => {}\n-    }\n-}\n-\n fn not_ssa(flag_map: &mut IndexVec<Local, SsaKind>, local: Local) {\n     flag_map[local] = SsaKind::NotSsa;\n }"}, {"sha": "0c0f43d076e3df5f72f6e7348b0e42eccbc95d5a", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "patch": "@@ -292,7 +292,7 @@ fn trans_stmt<'tcx>(\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(debug_assertions)]\n+    #[cfg(false_debug_assertions)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {\n@@ -646,20 +646,7 @@ pub fn trans_place<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     place: &Place<'tcx>,\n ) -> CPlace<'tcx> {\n-    let mut cplace = match &place.base {\n-        PlaceBase::Local(local) => fx.get_local_place(*local),\n-        PlaceBase::Static(static_) => match static_.kind {\n-            StaticKind::Static => {\n-                // Statics can't be generic, so `static_.ty` doesn't need to be monomorphized.\n-                crate::constant::codegen_static_ref(fx, static_.def_id, static_.ty)\n-            }\n-            StaticKind::Promoted(promoted, substs) => {\n-                let instance = Instance::new(static_.def_id, fx.monomorphize(&substs));\n-                let ty = fx.monomorphize(&static_.ty);\n-                crate::constant::trans_promoted(fx, instance, promoted, ty)\n-            }\n-        },\n-    };\n+    let mut cplace = fx.get_local_place(place.local);\n \n     for elem in &*place.projection {\n         match *elem {"}, {"sha": "92ccaa1b1646c1dab3a3e7a527a3b95729aa15a8", "filename": "src/constant.rs", "status": "modified", "additions": 107, "deletions": 69, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "patch": "@@ -40,7 +40,7 @@ pub fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n     constants_cx.todo.insert(TodoItem::Static(def_id));\n }\n \n-pub fn codegen_static_ref<'tcx>(\n+fn codegen_static_ref<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     def_id: DefId,\n     ty: Ty<'tcx>,\n@@ -50,31 +50,37 @@ pub fn codegen_static_ref<'tcx>(\n     cplace_for_dataid(fx, ty, data_id)\n }\n \n-pub fn trans_promoted<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    instance: Instance<'tcx>,\n-    promoted: Promoted,\n-    dest_ty: Ty<'tcx>,\n-) -> CPlace<'tcx> {\n-    match fx.tcx.const_eval_promoted(instance, promoted) {\n-        Ok(const_) => {\n-            let cplace = trans_const_place(fx, const_);\n-            debug_assert_eq!(cplace.layout(), fx.layout_of(dest_ty));\n-            cplace\n-        }\n-        Err(_) => crate::trap::trap_unreachable_ret_place(\n-            fx,\n-            fx.layout_of(dest_ty),\n-            \"[panic] Tried to get value of promoted value with errored during const eval.\",\n-        ),\n-    }\n-}\n-\n pub fn trans_constant<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let const_ = force_eval_const(fx, &constant.literal);\n+    let const_ = match constant.literal.val {\n+        ConstKind::Unevaluated(def_id, ref substs, promoted) if fx.tcx.is_static(def_id) => {\n+            assert!(substs.is_empty());\n+            assert!(promoted.is_none());\n+\n+            return codegen_static_ref(\n+                fx,\n+                def_id,\n+                fx.monomorphize(&constant.literal.ty),\n+            ).to_cvalue(fx);\n+        }\n+        ConstKind::Unevaluated(def_id, ref substs, promoted) => {\n+            let substs = fx.monomorphize(substs);\n+            fx.tcx.const_eval_resolve(\n+                ParamEnv::reveal_all(),\n+                def_id,\n+                substs,\n+                promoted,\n+                None, // FIXME use correct span\n+            ).unwrap_or_else(|_| {\n+                fx.tcx.sess.abort_if_errors();\n+                unreachable!();\n+            })\n+        }\n+        _ => fx.monomorphize(&constant.literal),\n+    };\n+\n     trans_const_value(fx, const_)\n }\n \n@@ -83,9 +89,15 @@ pub fn force_eval_const<'tcx>(\n     const_: &'tcx Const,\n ) -> &'tcx Const<'tcx> {\n     match const_.val {\n-        ConstKind::Unevaluated(def_id, ref substs) => {\n+        ConstKind::Unevaluated(def_id, ref substs, promoted) => {\n             let substs = fx.monomorphize(substs);\n-            fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def_id, substs, None).unwrap_or_else(|_| {\n+            fx.tcx.const_eval_resolve(\n+                ParamEnv::reveal_all(),\n+                def_id,\n+                substs,\n+                promoted,\n+                None, // FIXME pass correct span\n+            ).unwrap_or_else(|_| {\n                 fx.tcx.sess.abort_if_errors();\n                 unreachable!();\n             })\n@@ -100,38 +112,78 @@ pub fn trans_const_value<'tcx>(\n ) -> CValue<'tcx> {\n     let ty = fx.monomorphize(&const_.ty);\n     let layout = fx.layout_of(ty);\n-    match ty.kind {\n-        ty::Bool | ty::Uint(_) => {\n-            let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            CValue::const_val(fx, ty, bits)\n+\n+    if layout.is_zst() {\n+        return CValue::by_ref(\n+            crate::Pointer::const_addr(fx, i64::try_from(layout.align.pref.bytes()).unwrap()),\n+            layout,\n+        );\n+    }\n+\n+    let const_val = match const_.val {\n+        ConstKind::Value(const_val) => const_val,\n+        _ => unreachable!(\"Const {:?} should have been evaluated\", const_),\n+    };\n+\n+    match const_val {\n+        ConstValue::Scalar(x) => {\n+            let scalar = match layout.abi {\n+                layout::Abi::Scalar(ref x) => x,\n+                _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n+            };\n+\n+            match ty.kind {\n+                ty::Bool | ty::Uint(_) => {\n+                    let bits = const_.val.try_to_bits(layout.size).unwrap_or_else(|| {\n+                        panic!(\"{:?}\\n{:?}\", const_, layout);\n+                    });\n+                    CValue::const_val(fx, ty, bits)\n+                }\n+                ty::Int(_) => {\n+                    let bits = const_.val.try_to_bits(layout.size).unwrap();\n+                    CValue::const_val(\n+                        fx,\n+                        ty,\n+                        rustc::mir::interpret::sign_extend(bits, layout.size),\n+                    )\n+                }\n+                ty::Float(fty) => {\n+                    let bits = const_.val.try_to_bits(layout.size).unwrap();\n+                    let val = match fty {\n+                        FloatTy::F32 => fx\n+                            .bcx\n+                            .ins()\n+                            .f32const(Ieee32::with_bits(u32::try_from(bits).unwrap())),\n+                        FloatTy::F64 => fx\n+                            .bcx\n+                            .ins()\n+                            .f64const(Ieee64::with_bits(u64::try_from(bits).unwrap())),\n+                    };\n+                    CValue::by_val(val, layout)\n+                }\n+                ty::FnDef(_def_id, _substs) => CValue::by_ref(\n+                    crate::pointer::Pointer::const_addr(fx, fx.pointer_type.bytes() as i64),\n+                    layout,\n+                ),\n+                _ => trans_const_place(fx, const_).to_cvalue(fx),\n+            }\n         }\n-        ty::Int(_) => {\n-            let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            CValue::const_val(\n-                fx,\n-                ty,\n-                rustc::mir::interpret::sign_extend(bits, layout.size),\n+        ConstValue::ByRef { alloc, offset } => {\n+            let alloc_id = fx.tcx.alloc_map.lock().create_memory_alloc(alloc);\n+            fx.constants_cx.todo.insert(TodoItem::Alloc(alloc_id));\n+            let data_id = data_id_for_alloc_id(fx.module, alloc_id, alloc.align);\n+            let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+            let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n+            assert!(!layout.is_unsized(), \"unsized ConstValue::ByRef not supported\");\n+            CValue::by_ref(\n+                crate::pointer::Pointer::new(global_ptr)\n+                    .offset_i64(fx, i64::try_from(offset.bytes()).unwrap()),\n+                layout,\n             )\n         }\n-        ty::Float(fty) => {\n-            let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            let val = match fty {\n-                FloatTy::F32 => fx\n-                    .bcx\n-                    .ins()\n-                    .f32const(Ieee32::with_bits(u32::try_from(bits).unwrap())),\n-                FloatTy::F64 => fx\n-                    .bcx\n-                    .ins()\n-                    .f64const(Ieee64::with_bits(u64::try_from(bits).unwrap())),\n-            };\n-            CValue::by_val(val, layout)\n+        ConstValue::Slice { data: _, start: _, end: _ } => {\n+            trans_const_place(fx, const_).to_cvalue(fx)\n         }\n-        ty::FnDef(_def_id, _substs) => CValue::by_ref(\n-            crate::pointer::Pointer::const_addr(fx, fx.pointer_type.bytes() as i64),\n-            layout,\n-        ),\n-        _ => trans_const_place(fx, const_).to_cvalue(fx),\n     }\n }\n \n@@ -480,22 +532,8 @@ pub fn mir_operand_get_const_val<'tcx>(\n     fx: &FunctionCx<'_, 'tcx, impl Backend>,\n     operand: &Operand<'tcx>,\n ) -> Option<&'tcx Const<'tcx>> {\n-    let place = match operand {\n-        Operand::Copy(place) | Operand::Move(place) => place,\n+    match operand {\n+        Operand::Copy(_) | Operand::Move(_) => return None,\n         Operand::Constant(const_) => return Some(force_eval_const(fx, const_.literal)),\n-    };\n-\n-    assert!(place.projection.is_empty());\n-    let static_ = match &place.base {\n-        PlaceBase::Static(static_) => static_,\n-        PlaceBase::Local(_) => return None,\n-    };\n-\n-    Some(match &static_.kind {\n-        StaticKind::Static => unimplemented!(),\n-        StaticKind::Promoted(promoted, substs) => {\n-            let instance = Instance::new(static_.def_id, fx.monomorphize(substs));\n-            fx.tcx.const_eval_promoted(instance, *promoted).unwrap()\n-        }\n-    })\n+    }\n }"}, {"sha": "d4be26885a042a195666846d906501e874547290", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n                     &local_map,\n                     &value_labels_ranges,\n                     Place {\n-                        base: PlaceBase::Local(local),\n+                        local,\n                         projection: ty::List::empty(),\n                     },\n                 );\n@@ -305,12 +305,8 @@ fn place_location<'a, 'tcx>(\n     place: Place<'tcx>,\n ) -> AttributeValue {\n     assert!(place.projection.is_empty()); // FIXME implement them\n-    let cplace = match place.base {\n-        PlaceBase::Local(local) => local_map[&local],\n-        PlaceBase::Static(_) => bug!(\"Unenforced invariant that the place is based on a Local violated: {:?}\", place),\n-    };\n \n-    match cplace.inner() {\n+    match local_map[&place.local].inner() {\n         CPlaceInner::Var(local) => {\n             let value_label = cranelift_codegen::ir::ValueLabel::from_u32(local.as_u32());\n             if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {"}, {"sha": "316a26781dab49b55936a02ea9ddab31d460eaad", "filename": "src/trap.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44d6311caae19a3486d1edcbd6d83022e6fc2b2/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=b44d6311caae19a3486d1edcbd6d83022e6fc2b2", "patch": "@@ -93,15 +93,3 @@ pub fn trap_unreachable_ret_value<'tcx>(\n     trap_unimplemented(fx, msg);\n     CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n }\n-\n-/// Like `trap_unreachable` but returns a fake place for the specified type.\n-///\n-/// Trap code: user65535\n-pub fn trap_unreachable_ret_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>,\n-    dest_layout: TyLayout<'tcx>,\n-    msg: impl AsRef<str>,\n-) -> CPlace<'tcx> {\n-    trap_unimplemented(fx, msg);\n-    CPlace::for_ptr(Pointer::const_addr(fx, 0), dest_layout)\n-}"}]}