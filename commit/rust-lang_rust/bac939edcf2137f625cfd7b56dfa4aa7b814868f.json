{"sha": "bac939edcf2137f625cfd7b56dfa4aa7b814868f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYzkzOWVkY2YyMTM3ZjYyNWNmZDdiNTZkZmE0YWE3YjgxNDg2OGY=", "commit": {"author": {"name": "pawanbisht62", "email": "36775517+pawanbisht62@users.noreply.github.com", "date": "2020-08-06T11:30:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-06T11:30:51Z"}, "message": "Merge branch 'master' into feature/incorporate-tracing", "tree": {"sha": "bbeab2a9f6869b0be809a8e7029a62a77c8e22da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbeab2a9f6869b0be809a8e7029a62a77c8e22da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac939edcf2137f625cfd7b56dfa4aa7b814868f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfK+nrCRBK7hj4Ov3rIwAAdHIIAI+WOcUBfti0NeSTKHC+HxEZ\nTa7459YbZ15NyggdS90N72shrAaC28kZO/dCGHo47hal2Ibx2U5bpWXdxutJ5yqu\nNt3B7tGSgMRugzp1E/V7vxPdDUu4+ktBzp3kAUIABQDUfDQaSe2PaV2RZ/hiy59B\nwsEXGBe8S6h1MILr5f6Yw5QHUmezkM0p8QbwqQeabfAIr70a+iLcAZ4ATp9De+fF\njtgurQ5GpFi7ttkgvj79tcbah592vJfSBLwGPUMBYJVG/6qNuqAJ1AHhicHMK+6c\n0gNbdmbtKntLBCl27Ul2Ihc8fYM6SyRUpi8+TzeuKmZwzNpnam1y/68aeSHvwBw=\n=y7Ku\n-----END PGP SIGNATURE-----\n", "payload": "tree bbeab2a9f6869b0be809a8e7029a62a77c8e22da\nparent fdfbd89946ca34d12eec658d111ce9a85cd23df0\nparent 3cfc7fe78eccc754b16981704a098d7bd520e2fd\nauthor pawanbisht62 <36775517+pawanbisht62@users.noreply.github.com> 1596713451 +0530\ncommitter GitHub <noreply@github.com> 1596713451 +0530\n\nMerge branch 'master' into feature/incorporate-tracing"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac939edcf2137f625cfd7b56dfa4aa7b814868f", "html_url": "https://github.com/rust-lang/rust/commit/bac939edcf2137f625cfd7b56dfa4aa7b814868f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac939edcf2137f625cfd7b56dfa4aa7b814868f/comments", "author": {"login": "pawanbisht62", "id": 36775517, "node_id": "MDQ6VXNlcjM2Nzc1NTE3", "avatar_url": "https://avatars.githubusercontent.com/u/36775517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pawanbisht62", "html_url": "https://github.com/pawanbisht62", "followers_url": "https://api.github.com/users/pawanbisht62/followers", "following_url": "https://api.github.com/users/pawanbisht62/following{/other_user}", "gists_url": "https://api.github.com/users/pawanbisht62/gists{/gist_id}", "starred_url": "https://api.github.com/users/pawanbisht62/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pawanbisht62/subscriptions", "organizations_url": "https://api.github.com/users/pawanbisht62/orgs", "repos_url": "https://api.github.com/users/pawanbisht62/repos", "events_url": "https://api.github.com/users/pawanbisht62/events{/privacy}", "received_events_url": "https://api.github.com/users/pawanbisht62/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdfbd89946ca34d12eec658d111ce9a85cd23df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdfbd89946ca34d12eec658d111ce9a85cd23df0", "html_url": "https://github.com/rust-lang/rust/commit/fdfbd89946ca34d12eec658d111ce9a85cd23df0"}, {"sha": "3cfc7fe78eccc754b16981704a098d7bd520e2fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfc7fe78eccc754b16981704a098d7bd520e2fd", "html_url": "https://github.com/rust-lang/rust/commit/3cfc7fe78eccc754b16981704a098d7bd520e2fd"}], "stats": {"total": 8520, "additions": 4636, "deletions": 3884}, "files": [{"sha": "a19cca9071f011c582289a2807bcb96293f63839", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -575,8 +575,14 @@ jobs:\n       CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n+      fail-fast: false\n       matrix:\n         include:\n+          - name: aarch64-gnu\n+            os:\n+              - self-hosted\n+              - ARM64\n+              - linux\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist\""}, {"sha": "d4f4ec7f6f0a3ae00a39e8fed136aeca559ef890", "filename": "Cargo.lock", "status": "modified", "additions": 143, "deletions": 218, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -37,19 +37,20 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand 0.7.3\",\n- \"rand_xorshift 0.2.0\",\n+ \"rand\",\n+ \"rand_xorshift\",\n ]\n \n [[package]]\n name = \"ammonia\"\n-version = \"3.0.0\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e266e1f4be5ffa05309f650e2586fe1d3ae6034eb24025a7ae1dfecc330823a\"\n+checksum = \"89eac85170f4b3fb3dc5e442c1cfb036cb8eecf9dbbd431a161ffad15d90ea3b\"\n dependencies = [\n  \"html5ever\",\n  \"lazy_static\",\n  \"maplit\",\n+ \"markup5ever_rcdom\",\n  \"matches\",\n  \"tendril\",\n  \"url 2.1.0\",\n@@ -343,7 +344,7 @@ dependencies = [\n  \"termcolor\",\n  \"toml\",\n  \"unicode-width\",\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n  \"url 2.1.0\",\n  \"walkdir\",\n  \"winapi 0.3.8\",\n@@ -444,9 +445,9 @@ version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d463e01905d607e181de72e8608721d3269f29176c9a14ce037011316ae7131d\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -547,12 +548,12 @@ dependencies = [\n  \"lazy_static\",\n  \"pulldown-cmark\",\n  \"quine-mc_cluskey\",\n- \"quote 1.0.2\",\n+ \"quote\",\n  \"regex-syntax\",\n  \"semver 0.9.0\",\n  \"serde\",\n  \"smallvec 1.4.0\",\n- \"syn 1.0.11\",\n+ \"syn\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -667,7 +668,7 @@ checksum = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n ]\n \n [[package]]\n@@ -788,8 +789,8 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"47c5e5ac752e18207b12e16b10631ae5f7f68f8805f335f9b817ead83d9ffce1\"\n dependencies = [\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -835,9 +836,9 @@ version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -846,9 +847,9 @@ version = \"0.99.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2159be042979966de68315bce7034bb000c775f22e3e834e1c52ff78f041cae8\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -923,9 +924,9 @@ checksum = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \n [[package]]\n name = \"elasticlunr-rs\"\n-version = \"2.3.4\"\n+version = \"2.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n+checksum = \"35622eb004c8f0c5e7e2032815f3314a93df0db30a1ce5c94e62c1ecc81e22b9\"\n dependencies = [\n  \"lazy_static\",\n  \"regex\",\n@@ -1003,9 +1004,9 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -1298,16 +1299,16 @@ dependencies = [\n \n [[package]]\n name = \"html5ever\"\n-version = \"0.24.1\"\n+version = \"0.25.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"025483b0a1e4577bb28578318c886ee5f817dda6eb62473269349044406644cb\"\n+checksum = \"aafcf38a1a36118242d29b92e1b08ef84e67e4a5ed06e0a80be20e6a32bfed6b\"\n dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -1515,9 +1516,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8609af8f63b626e8e211f52441fcdb6ec54f1a446606b10d5c89ae9bf8a20058\"\n dependencies = [\n  \"proc-macro-crate\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -1586,9 +1587,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.73\"\n+version = \"0.2.74\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd7d4bd64732af4bf3a67f367c27df8520ad7e230c5817b8ff485864d80242b9\"\n+checksum = \"a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1735,9 +1736,9 @@ checksum = \"08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43\"\n \n [[package]]\n name = \"markup5ever\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65381d9d47506b8592b97c4efd936afcf673b09b059f2bef39c7211ee78b9d03\"\n+checksum = \"aae38d669396ca9b707bfc3db254bc382ddb94f57cc5c235f34623a669a01dab\"\n dependencies = [\n  \"log\",\n  \"phf\",\n@@ -1750,6 +1751,18 @@ dependencies = [\n  \"tendril\",\n ]\n \n+[[package]]\n+name = \"markup5ever_rcdom\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f015da43bcd8d4f144559a3423f4591d69b8ce0652c905374da7205df336ae2b\"\n+dependencies = [\n+ \"html5ever\",\n+ \"markup5ever\",\n+ \"tendril\",\n+ \"xml5ever\",\n+]\n+\n [[package]]\n name = \"matchers\"\n version = \"0.0.1\"\n@@ -1937,7 +1950,7 @@ dependencies = [\n  \"hex 0.4.0\",\n  \"libc\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -2131,7 +2144,7 @@ dependencies = [\n  \"log\",\n  \"mio-named-pipes\",\n  \"miow 0.3.3\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"tokio\",\n  \"tokio-named-pipes\",\n  \"tokio-uds\",\n@@ -2233,9 +2246,9 @@ checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -2261,38 +2274,38 @@ dependencies = [\n \n [[package]]\n name = \"phf\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3da44b85f8e8dfaec21adae67f95d93244b2ecf6ad2a692320598dcc8e6dd18\"\n+checksum = \"3dfb61232e34fcb633f43d12c58f83c1df82962dcdfa565a4e866ffc17dafe12\"\n dependencies = [\n  \"phf_shared\",\n ]\n \n [[package]]\n name = \"phf_codegen\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b03e85129e324ad4166b06b2c7491ae27fe3ec353af72e72cd1654c7225d517e\"\n+checksum = \"cbffee61585b0411840d3ece935cce9cb6321f01c45477d30066498cd5e1a815\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n ]\n \n [[package]]\n name = \"phf_generator\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09364cc93c159b8b06b1f4dd8a4398984503483891b0c26b867cf431fb132662\"\n+checksum = \"17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526\"\n dependencies = [\n  \"phf_shared\",\n- \"rand 0.6.1\",\n+ \"rand\",\n ]\n \n [[package]]\n name = \"phf_shared\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"234f71a15de2288bcb7e3b6515828d22af7ec8598ee6d24c3b526fa0a80b67a0\"\n+checksum = \"c00cf8b9eafe68dde5e9eaa2cef8ee84a9336a47d566ec55ca16589633b65af7\"\n dependencies = [\n  \"siphasher\",\n ]\n@@ -2363,18 +2376,9 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n-]\n-\n-[[package]]\n-name = \"proc-macro2\"\n-version = \"0.4.30\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n-dependencies = [\n- \"unicode-xid 0.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -2383,7 +2387,7 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -2441,22 +2445,13 @@ version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \n-[[package]]\n-name = \"quote\"\n-version = \"0.6.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n-]\n-\n [[package]]\n name = \"quote\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n+ \"proc-macro2\",\n ]\n \n [[package]]\n@@ -2482,25 +2477,6 @@ dependencies = [\n  \"rustc-ap-rustc_span\",\n ]\n \n-[[package]]\n-name = \"rand\"\n-version = \"0.6.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a\"\n-dependencies = [\n- \"cloudabi\",\n- \"fuchsia-zircon\",\n- \"libc\",\n- \"rand_chacha 0.1.0\",\n- \"rand_core 0.3.0\",\n- \"rand_hc 0.1.0\",\n- \"rand_isaac\",\n- \"rand_pcg\",\n- \"rand_xorshift 0.1.0\",\n- \"rustc_version\",\n- \"winapi 0.3.8\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.7.3\"\n@@ -2509,19 +2485,10 @@ checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom\",\n  \"libc\",\n- \"rand_chacha 0.2.2\",\n+ \"rand_chacha\",\n  \"rand_core 0.5.1\",\n- \"rand_hc 0.2.0\",\n-]\n-\n-[[package]]\n-name = \"rand_chacha\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"771b009e3a508cb67e8823dda454aaa5368c7bc1c16829fb77d3e980440dd34a\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n- \"rustc_version\",\n+ \"rand_hc\",\n+ \"rand_pcg\",\n ]\n \n [[package]]\n@@ -2555,15 +2522,6 @@ dependencies = [\n  \"getrandom\",\n ]\n \n-[[package]]\n-name = \"rand_hc\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n-]\n-\n [[package]]\n name = \"rand_hc\"\n version = \"0.2.0\"\n@@ -2573,15 +2531,6 @@ dependencies = [\n  \"rand_core 0.5.1\",\n ]\n \n-[[package]]\n-name = \"rand_isaac\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n-]\n-\n [[package]]\n name = \"rand_os\"\n version = \"0.1.3\"\n@@ -2598,21 +2547,11 @@ dependencies = [\n \n [[package]]\n name = \"rand_pcg\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"086bd09a33c7044e56bb44d5bdde5a60e7f119a9e95b0775f545de759a32fe05\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n- \"rustc_version\",\n-]\n-\n-[[package]]\n-name = \"rand_xorshift\"\n-version = \"0.1.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"effa3fcaa47e18db002bdde6060944b6d2f9cfd8db471c30e873448ad9187be3\"\n+checksum = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n dependencies = [\n- \"rand_core 0.3.0\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2752,7 +2691,7 @@ dependencies = [\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -2824,7 +2763,7 @@ dependencies = [\n  \"env_logger 0.7.1\",\n  \"futures\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -3051,7 +2990,7 @@ version = \"669.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"456af5f09c006cf6c22c1a433ee0232c4bb74bdc6c647a010166a47c94ed2a63\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -3060,9 +2999,9 @@ version = \"669.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"64f6acd192f313047759a346b892998b626466b93fe04f415da5f38906bb3b4c\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -3224,13 +3163,13 @@ name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"crossbeam-utils 0.7.2\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n+ \"proc-macro2\",\n+ \"quote\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec 0.6.10\",\n  \"smallvec 1.4.0\",\n- \"syn 1.0.11\",\n+ \"syn\",\n  \"url 2.1.0\",\n  \"winapi 0.3.8\",\n ]\n@@ -3555,7 +3494,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3644,7 +3583,7 @@ dependencies = [\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -3681,9 +3620,9 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -3738,7 +3677,6 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"scoped-tls\",\n  \"smallvec 1.4.0\",\n  \"tracing\",\n ]\n@@ -3808,6 +3746,7 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"smallvec 1.4.0\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n@@ -4134,10 +4073,10 @@ dependencies = [\n name = \"rustfmt-config_proc_macro\"\n version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n+ \"proc-macro2\",\n+ \"quote\",\n  \"serde\",\n- \"syn 1.0.11\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4264,9 +4203,9 @@ version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4295,9 +4234,9 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4345,9 +4284,9 @@ dependencies = [\n \n [[package]]\n name = \"siphasher\"\n-version = \"0.2.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n+checksum = \"fa8f3741c7372e75519bd9346068370c9cdaabcc1f9599cbcf2a2719352286b7\"\n \n [[package]]\n name = \"sized-chunks\"\n@@ -4427,46 +4366,37 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc-demangle\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n [[package]]\n name = \"string_cache\"\n-version = \"0.7.3\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n+checksum = \"2940c75beb4e3bf3a494cef919a747a2cb81e52571e212bfbd185074add7208a\"\n dependencies = [\n  \"lazy_static\",\n  \"new_debug_unreachable\",\n  \"phf_shared\",\n  \"precomputed-hash\",\n  \"serde\",\n- \"string_cache_codegen\",\n- \"string_cache_shared\",\n ]\n \n [[package]]\n name = \"string_cache_codegen\"\n-version = \"0.4.2\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n+checksum = \"f24c8e5e19d22a726626f1a5e16fe15b132dcf21d10177fa5a45ce7962996b97\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"string_cache_shared\",\n+ \"proc-macro2\",\n+ \"quote\",\n ]\n \n-[[package]]\n-name = \"string_cache_shared\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\"\n-\n [[package]]\n name = \"strip-ansi-escapes\"\n version = \"0.1.0\"\n@@ -4500,38 +4430,27 @@ checksum = \"2ae9e5165d463a0dea76967d021f8d0f9316057bf5163aa2a4843790e842ff37\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"strum\"\n-version = \"0.11.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6c3a2071519ab6a48f465808c4c1ffdd00dfc8e93111d02b4fc5abab177676e\"\n+checksum = \"57bd81eb48f4c437cadc685403cad539345bf703d78e63707418431cecd4522b\"\n \n [[package]]\n name = \"strum_macros\"\n-version = \"0.11.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n+checksum = \"87c85aa3f8ea653bfd3ddf25f7ee357ee4d204731f6aa9ad04002306f6e2774c\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n-]\n-\n-[[package]]\n-name = \"syn\"\n-version = \"0.15.35\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"unicode-xid 0.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4540,9 +4459,9 @@ version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dff0acdb207ae2fe6d5976617f887eb1e35a2ba52c13c7234c790960cdad9238\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"unicode-xid 0.2.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -4551,10 +4470,10 @@ version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n- \"unicode-xid 0.2.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -4577,7 +4496,7 @@ checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.8\",\n@@ -4682,9 +4601,9 @@ version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"24069c0ba08aab54289d6a25f5036d94afc61e1538bbc42ae5501df141c9027d\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4983,9 +4902,9 @@ version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f0693bf8d6f2bf22c690fc61a9d21ac69efdbb894a17ed596b9af0f01e64b84b\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -5102,12 +5021,6 @@ dependencies = [\n  \"rustc-std-workspace-std\",\n ]\n \n-[[package]]\n-name = \"unicode-xid\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n-\n [[package]]\n name = \"unicode-xid\"\n version = \"0.2.0\"\n@@ -5295,6 +5208,18 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"xml5ever\"\n+version = \"0.16.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b1b52e6e8614d4a58b8e70cf51ec0cc21b256ad8206708bcff8139b5bbd6a59\"\n+dependencies = [\n+ \"log\",\n+ \"mac\",\n+ \"markup5ever\",\n+ \"time\",\n+]\n+\n [[package]]\n name = \"xz2\"\n version = \"0.1.5\""}, {"sha": "a9835ad12ad5a6f93e468e84b7b16e4de514f70b", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -433,7 +433,7 @@\n #\n # LLD will not be used if we're cross linking or running tests.\n #\n-# Explicitly setting the linker for a target will override this option.\n+# Explicitly setting the linker for a target will override this option when targeting MSVC.\n #use-lld = false\n \n # Indicates whether some LLVM tools, like llvm-objdump, will be made available in the\n@@ -503,7 +503,7 @@\n # Linker to be used to link Rust code. Note that the\n # default value is platform specific, and if not specified it may also depend on\n # what platform is crossing to what platform.\n-# Setting this will override the `use-lld` option for Rust code.\n+# Setting this will override the `use-lld` option for Rust code when targeting MSVC.\n #linker = \"cc\"\n \n # Path to the `llvm-config` binary of the installation of a custom LLVM to link"}, {"sha": "7c2e5694a62fc4249859748c47d16499752ad066", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -282,3 +282,305 @@ pub fn iter_10k(b: &mut Bencher) {\n pub fn iter_1m(b: &mut Bencher) {\n     bench_iter(b, 1_000, 1_000_000);\n }\n+\n+const FAT: usize = 256;\n+\n+// The returned map has small keys and values.\n+// Benchmarks on it have a counterpart in set.rs with the same keys and no values at all.\n+fn slim_map(n: usize) -> BTreeMap<usize, usize> {\n+    (0..n).map(|i| (i, i)).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has small keys and large values.\n+fn fat_val_map(n: usize) -> BTreeMap<usize, [usize; FAT]> {\n+    (0..n).map(|i| (i, [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has large keys and values.\n+fn fat_map(n: usize) -> BTreeMap<[usize; FAT], [usize; FAT]> {\n+    (0..n).map(|i| ([i; FAT], [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+#[bench]\n+pub fn clone_slim_100(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_clear(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_clear(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(map.len(), 10_000 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..10_000).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 10_000 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_clear(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_clear(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i[0] % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&[i; FAT]);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}"}, {"sha": "07bf5093727c04b4589f7260416a1e275f0ce717", "filename": "library/alloc/benches/btree/set.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -50,27 +50,31 @@ macro_rules! set_bench {\n     };\n }\n \n+fn slim_set(n: usize) -> BTreeSet<usize> {\n+    (0..n).collect::<BTreeSet<_>>()\n+}\n+\n #[bench]\n pub fn clone_100(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_100_and_clear(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_100_and_drain_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_100_and_drain_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n@@ -80,13 +84,13 @@ pub fn clone_100_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_100_and_pop_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -96,23 +100,25 @@ pub fn clone_100_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_remove_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_100_and_remove_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=100 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..100).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 100 / 2);\n         set\n@@ -121,25 +127,25 @@ pub fn clone_100_and_remove_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_10k_and_clear(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n@@ -149,13 +155,13 @@ pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -165,23 +171,25 @@ pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_remove_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_10k_and_remove_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=10_000 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..10_000).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 10_000 / 2);\n         set"}, {"sha": "518ac11b5a009850d07869b8d182ba4b483680ee", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 96, "deletions": 67, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -164,25 +164,34 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = match init {\n-                    AllocInit::Uninitialized => alloc(layout),\n-                    AllocInit::Zeroed => alloc_zeroed(layout),\n-                };\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n+    }\n+\n+    #[inline]\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n+            // SAFETY: `layout` is non-zero in size,\n+            // other conditions must be upheld by the caller\n             unsafe { dealloc(ptr.as_ptr(), layout) }\n         }\n     }\n@@ -193,38 +202,59 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n-    ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n+                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n+            }\n         }\n+    }\n \n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout =\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                self.alloc(new_layout, init)\n-            }\n-            ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size > size` or something similar.\n-                let ptr = unsafe {\n-                    intrinsics::assume(new_size > size);\n-                    realloc(ptr.as_ptr(), layout, new_size)\n-                };\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                unsafe {\n-                    init.init_offset(memory, size);\n+    #[inline]\n+    unsafe fn grow_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        debug_assert!(\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n+                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n                 }\n-                Ok(memory)\n             }\n         }\n     }\n@@ -235,35 +265,34 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+            new_size <= old_size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if new_size == 0 => {\n-                unsafe {\n-                    self.dealloc(ptr, layout);\n-                }\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            }\n-            ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size < size` or something similar.\n-                let ptr = unsafe {\n-                    intrinsics::assume(new_size < size);\n-                    realloc(ptr.as_ptr(), layout, new_size)\n-                };\n-                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n+        let ptr = if new_size == old_size {\n+            ptr\n+        } else if new_size == 0 {\n+            // SAFETY: `layout` is non-zero in size as `old_size` != `new_size`\n+            // Other conditions must be upheld by the caller\n+            unsafe {\n+                self.dealloc(ptr, layout);\n             }\n-        }\n+            layout.dangling()\n+        } else {\n+            // SAFETY: new_size is not zero,\n+            // Other conditions must be upheld by the caller\n+            let raw_ptr = unsafe {\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                realloc(ptr.as_ptr(), layout, new_size)\n+            };\n+            NonNull::new(raw_ptr).ok_or(AllocErr)?\n+        };\n+\n+        Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n     }\n }\n \n@@ -274,8 +303,8 @@ unsafe impl AllocRef for Global {\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n-    match Global.alloc(layout, AllocInit::Uninitialized) {\n-        Ok(memory) => memory.ptr.as_ptr(),\n+    match Global.alloc(layout) {\n+        Ok(ptr) => ptr.as_non_null_ptr().as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }\n }"}, {"sha": "f7463d0daac93ad9fb9876c3e286c5ccd38d682e", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -8,17 +8,16 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let memory = Global\n-            .alloc(layout.clone(), AllocInit::Zeroed)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr =\n+            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = memory.ptr.cast::<u8>().as_ptr();\n+        let mut i = ptr.as_non_null_ptr().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(memory.ptr, layout);\n+        Global.dealloc(ptr.as_non_null_ptr(), layout);\n     }\n }\n "}, {"sha": "5e304beff78ab1cb469ce5bdab2e24a2004e4407", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -146,7 +146,7 @@ use core::pin::Pin;\n use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, AllocInit, AllocRef, Global};\n+use crate::alloc::{self, AllocRef, Global};\n use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -197,11 +197,7 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .ptr\n-            .cast();\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n@@ -227,9 +223,8 @@ impl<T> Box<T> {\n     pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = Global\n-            .alloc(layout, AllocInit::Zeroed)\n+            .alloc_zeroed(layout)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .ptr\n             .cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }"}, {"sha": "1db629c3bdf8da0e7f9754c9514e6b88168a4b9f", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -174,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n-                        let mut out_node = out_root.push_level();\n+                        let mut out_node = out_root.push_internal_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -1080,9 +1080,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 test_node = parent.forget_type();\n                             }\n                         }\n-                        Err(node) => {\n+                        Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = node.into_root_mut().push_level();\n+                            open_node = root.push_internal_level();\n                             break;\n                         }\n                     }\n@@ -1092,7 +1092,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let tree_height = open_node.height() - 1;\n                 let mut right_tree = node::Root::new_leaf();\n                 for _ in 0..tree_height {\n-                    right_tree.push_level();\n+                    right_tree.push_internal_level();\n                 }\n                 open_node.push(key, value, right_tree);\n \n@@ -1171,7 +1171,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n         for _ in 0..left_root.height() {\n-            right_root.push_level();\n+            right_root.push_internal_level();\n         }\n \n         {\n@@ -1255,7 +1255,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n-        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+        DrainFilterInner {\n+            length: &mut self.length,\n+            cur_leaf_edge: front,\n+            emptied_internal_root: false,\n+        }\n     }\n \n     /// Calculates the number of elements if it is incorrect.\n@@ -1625,6 +1629,7 @@ where\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    emptied_internal_root: bool,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n@@ -1665,6 +1670,17 @@ where\n     }\n }\n \n+impl<K, V> Drop for DrainFilterInner<'_, K, V> {\n+    fn drop(&mut self) {\n+        if self.emptied_internal_root {\n+            if let Some(handle) = self.cur_leaf_edge.take() {\n+                let root = handle.into_node().into_root_mut();\n+                root.pop_internal_level();\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n@@ -1681,9 +1697,10 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                self.cur_leaf_edge = Some(leaf_edge_location);\n-                return Some((k, v));\n+                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(pos);\n+                self.emptied_internal_root |= emptied_internal_root;\n+                return Some(old_kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2448,40 +2465,17 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         *self.length += 1;\n \n-        let out_ptr;\n-\n-        let mut ins_k;\n-        let mut ins_v;\n-        let mut ins_edge;\n-\n-        let mut cur_parent = match self.handle.insert(self.key, value) {\n-            (Fit(handle), _) => return handle.into_kv_mut().1,\n-            (Split(left, k, v, right), ptr) => {\n-                ins_k = k;\n-                ins_v = v;\n-                ins_edge = right;\n-                out_ptr = ptr;\n-                left.ascend().map_err(|n| n.into_root_mut())\n+        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n+            (Fit(_), val_ptr) => val_ptr,\n+            (Split(ins), val_ptr) => {\n+                let root = ins.left.into_root_mut();\n+                root.push_internal_level().push(ins.k, ins.v, ins.right);\n+                val_ptr\n             }\n         };\n-\n-        loop {\n-            match cur_parent {\n-                Ok(parent) => match parent.insert(ins_k, ins_v, ins_edge) {\n-                    Fit(_) => return unsafe { &mut *out_ptr },\n-                    Split(left, k, v, right) => {\n-                        ins_k = k;\n-                        ins_v = v;\n-                        ins_edge = right;\n-                        cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n-                    }\n-                },\n-                Err(root) => {\n-                    root.push_level().push(ins_k, ins_v, ins_edge);\n-                    return unsafe { &mut *out_ptr };\n-                }\n-            }\n-        }\n+        // Now that we have finished growing the tree using borrowed references,\n+        // dereference the pointer to a part of it, that we picked up along the way.\n+        unsafe { &mut *out_ptr }\n     }\n }\n \n@@ -2647,20 +2641,35 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.remove_kv().1\n     }\n \n+    // Body of `remove_entry`, separate to keep the above implementations short.\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n-        (old_key, old_val)\n+        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n+        let root = pos.into_node().into_root_mut();\n+        if emptied_internal_root {\n+            root.pop_internal_level();\n+        }\n+        old_kv\n     }\n }\n \n+struct RemoveResult<'a, K, V> {\n+    // Key and value removed.\n+    old_kv: (K, V),\n+    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n+    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    // Whether the remove left behind and empty internal root node, that should be removed\n+    // using `pop_internal_level`.\n+    emptied_internal_root: bool,\n+}\n+\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking(\n-        self,\n-    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair. It's possible this leaves\n+    /// an empty internal root node, which the caller should subsequently pop from\n+    /// the map holding the tree. The caller should also decrement the map's length.\n+    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n         let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n@@ -2689,6 +2698,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n         };\n \n         // Handle underflow\n+        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2709,8 +2719,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        // This empty parent must be the root, and should be popped off the tree.\n+                        emptied_internal_root = true;\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2737,15 +2747,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        (old_key, old_val, pos)\n+        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n     }\n }\n \n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n         while self.height() > 0 && self.as_ref().len() == 0 {\n-            self.pop_level();\n+            self.pop_internal_level();\n         }\n     }\n \n@@ -2817,8 +2827,16 @@ fn handle_underfull_node<K, V>(\n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n         Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(_) => {\n+                    // The underfull node has an empty parent, so it is the only child\n+                    // of an empty root. It is destined to become the new root, thus\n+                    // allowed to be underfull. The empty parent should be removed later\n+                    // by `pop_internal_level`.\n+                    return AtRoot;\n+                }\n+            }\n         }\n     };\n "}, {"sha": "0dcb593096467be93aa45c28839f86d143939fc3", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -19,7 +19,7 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n                 Ok(internal_kv) => return Ok(internal_kv),\n                 Err(last_edge) => match last_edge.into_node().ascend() {\n                     Ok(parent_edge) => parent_edge.forget_node_type(),\n-                    Err(root) => return Err(root.forget_type()),\n+                    Err(root) => return Err(root),\n                 },\n             }\n         }\n@@ -40,7 +40,7 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n                 Ok(internal_kv) => return Ok(internal_kv),\n                 Err(last_edge) => match last_edge.into_node().ascend() {\n                     Ok(parent_edge) => parent_edge.forget_node_type(),\n-                    Err(root) => return Err(root.forget_type()),\n+                    Err(root) => return Err(root),\n                 },\n             }\n         }"}, {"sha": "6a4c495ea14642d0ec1f8f720df9508621885116", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 129, "deletions": 72, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -191,8 +191,9 @@ impl<K, V> Root<K, V> {\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n-    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+    /// new node the root. This increases the height by 1 and is the opposite of\n+    /// `pop_internal_level`.\n+    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -213,11 +214,12 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    /// Removes the root node, using its first child as the new root. This cannot be called when\n-    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children of the root.\n-    /// This decreases the height by 1 and is the opposite of `push_level`.\n-    pub fn pop_level(&mut self) {\n+    /// Removes the internal root node, using its first child as the new root.\n+    /// As it is intended only to be called when the root has only one child,\n+    /// no cleanup is done on any of the other children of the root.\n+    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n+    /// Panics if there is no internal level, i.e. if the root is a leaf.\n+    pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n         let top = self.node.ptr;\n@@ -305,12 +307,6 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.height\n     }\n \n-    /// Removes any static information about whether this node is a `Leaf` or an\n-    /// `Internal` node.\n-    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n-    }\n-\n     /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n@@ -466,12 +462,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_val_slice(self) -> &'a [V] {\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n-\n-    fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n-        let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice(), self.into_val_slice())\n-    }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n@@ -829,13 +819,13 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n+    /// Helps implementations of `insert_fit` for a particular `NodeType`,\n+    /// by taking care of leaf data.\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+    fn leafy_insert_fit(&mut self, key: K, val: V) {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n \n@@ -844,16 +834,28 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             slice_insert(self.node.vals_mut(), self.idx, val);\n \n             (*self.node.as_leaf_mut()).len += 1;\n-\n-            self.node.vals_mut().get_unchecked_mut(self.idx)\n         }\n     }\n+}\n \n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method assumes that there is enough space in the node for the new\n+    /// pair to fit.\n+    ///\n+    /// The returned pointer points to the inserted value.\n+    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+        self.leafy_insert_fit(key, val);\n+        unsafe { self.node.vals_mut().get_unchecked_mut(self.idx) }\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n     /// The returned pointer points to the inserted value.\n-    pub fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n+    fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let ptr = self.insert_fit(key, val);\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n@@ -872,7 +874,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n                     .insert_fit(key, val)\n                 }\n             };\n-            (InsertResult::Split(left, k, v, right), ptr)\n+            (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), ptr)\n         }\n     }\n }\n@@ -890,14 +892,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Unsafely asserts to the compiler some static information about whether the underlying\n-    /// node of this handle is a `Leaf` or an `Internal`.\n-    unsafe fn cast_unchecked<NewType>(\n-        &mut self,\n-    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n-        unsafe { Handle::new_edge(self.node.cast_unchecked(), self.idx) }\n-    }\n-\n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n@@ -907,8 +901,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n-            // This cast is a lie, but it allows us to reuse the key/value insertion logic.\n-            self.cast_unchecked::<marker::Leaf>().insert_fit(key, val);\n+            self.leafy_insert_fit(key, val);\n \n             slice_insert(\n                 slice::from_raw_parts_mut(\n@@ -928,7 +921,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key/value pair to the right of this edge. This method splits\n     /// the node if there isn't enough room.\n-    pub fn insert(\n+    fn insert(\n         mut self,\n         key: K,\n         val: V,\n@@ -956,7 +949,43 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                     .insert_fit(key, val, edge);\n                 }\n             }\n-            InsertResult::Split(left, k, v, right)\n+            InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right })\n+        }\n+    }\n+}\n+\n+impl<'a, K: 'a, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method splits the node if there isn't enough room, and tries to\n+    /// insert the split off portion into the parent node recursively, until the root is reached.\n+    ///\n+    /// If the returned result is a `Fit`, its handle's node can be this edge's node or an ancestor.\n+    /// If the returned result is a `Split`, the `left` field will be the root node.\n+    /// The returned pointer points to the inserted value.\n+    pub fn insert_recursing(\n+        self,\n+        key: K,\n+        value: V,\n+    ) -> (InsertResult<'a, K, V, marker::LeafOrInternal>, *mut V) {\n+        let (mut split, val_ptr) = match self.insert(key, value) {\n+            (InsertResult::Fit(handle), ptr) => {\n+                return (InsertResult::Fit(handle.forget_node_type()), ptr);\n+            }\n+            (InsertResult::Split(split), val_ptr) => (split, val_ptr),\n+        };\n+\n+        loop {\n+            split = match split.left.ascend() {\n+                Ok(parent) => match parent.insert(split.k, split.v, split.right) {\n+                    InsertResult::Fit(handle) => {\n+                        return (InsertResult::Fit(handle.forget_node_type()), val_ptr);\n+                    }\n+                    InsertResult::Split(split) => split,\n+                },\n+                Err(root) => {\n+                    return (InsertResult::Split(SplitResult { left: root, ..split }), val_ptr);\n+                }\n+            };\n         }\n     }\n }\n@@ -980,10 +1009,9 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        unsafe {\n-            let (keys, vals) = self.node.into_slices();\n-            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n-        }\n+        let keys = self.node.into_key_slice();\n+        let vals = self.node.into_val_slice();\n+        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n     }\n }\n \n@@ -1005,18 +1033,11 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n-    /// Splits the underlying node into three parts:\n-    ///\n-    /// - The node is truncated to only contain the key/value pairs to the right of\n-    ///   this handle.\n-    /// - The key and value pointed to by this handle and extracted.\n-    /// - All the key/value pairs to the right of this handle are put into a newly\n-    ///   allocated node.\n-    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    /// Helps implementations of `split` for a particular `NodeType`,\n+    /// by taking care of leaf data.\n+    fn leafy_split(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V, usize) {\n         unsafe {\n-            let mut new_node = Box::new(LeafNode::new());\n-\n             let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n             let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n \n@@ -1035,6 +1056,24 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n \n             (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.len = new_len as u16;\n+            (k, v, new_len)\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the key/value pairs to the right of\n+    ///   this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the key/value pairs to the right of this handle are put into a newly\n+    ///   allocated node.\n+    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+        unsafe {\n+            let mut new_node = Box::new(LeafNode::new());\n+\n+            let (k, v, _) = self.leafy_split(&mut new_node);\n \n             (self.node, k, v, Root { node: BoxedNode::from_leaf(new_node), height: 0 })\n         }\n@@ -1066,31 +1105,15 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n \n-            let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n-            let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n-\n+            let (k, v, new_len) = self.leafy_split(&mut new_node.data);\n             let height = self.node.height;\n-            let new_len = self.node.len() - self.idx - 1;\n \n-            ptr::copy_nonoverlapping(\n-                self.node.keys().as_ptr().add(self.idx + 1),\n-                new_node.data.keys.as_mut_ptr() as *mut K,\n-                new_len,\n-            );\n-            ptr::copy_nonoverlapping(\n-                self.node.vals().as_ptr().add(self.idx + 1),\n-                new_node.data.vals.as_mut_ptr() as *mut V,\n-                new_len,\n-            );\n             ptr::copy_nonoverlapping(\n                 self.node.as_internal().edges.as_ptr().add(self.idx + 1),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n \n-            (*self.node.as_leaf_mut()).len = self.idx as u16;\n-            new_node.data.len = new_len as u16;\n-\n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n             for i in 0..(new_len + 1) {\n@@ -1362,6 +1385,20 @@ unsafe fn move_edges<K, V>(\n     }\n }\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n+    /// Removes any static information asserting that this node is a `Leaf` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Removes any static information asserting that this node is an `Internal` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+    }\n+}\n+\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     pub fn forget_node_type(\n         self,\n@@ -1386,6 +1423,14 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::K\n     }\n }\n \n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n impl<BorrowType, K, V, HandleType>\n     Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType>\n {\n@@ -1452,9 +1497,21 @@ pub enum ForceResult<Leaf, Internal> {\n     Internal(Internal),\n }\n \n+/// Result of insertion, when a node needed to expand beyond its capacity.\n+/// Does not distinguish between `Leaf` and `Internal` because `Root` doesn't.\n+pub struct SplitResult<'a, K, V> {\n+    // Altered node in existing tree with elements and edges that belong to the left of `k`.\n+    pub left: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+    // Some key and value split off, to be inserted elsewhere.\n+    pub k: K,\n+    pub v: V,\n+    // Owned, unattached, new node with elements and edges that belong to the right of `k`.\n+    pub right: Root<K, V>,\n+}\n+\n pub enum InsertResult<'a, K, V, Type> {\n     Fit(Handle<NodeRef<marker::Mut<'a>, K, V, Type>, marker::KV>),\n-    Split(NodeRef<marker::Mut<'a>, K, V, Type>, K, V, Root<K, V>),\n+    Split(SplitResult<'a, K, V>),\n }\n \n pub mod marker {"}, {"sha": "d74f91c752c0407778b18520da2a7d335764df54", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -107,7 +107,8 @@ fn test_insert() {\n     let cap = tester.capacity();\n \n     // len is the length *after* insertion\n-    for len in 1..cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 1 }; // Miri is too slow\n+    for len in minlen..cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n         for tail_pos in 0..cap {\n@@ -221,7 +222,8 @@ fn test_remove() {\n     let cap = tester.capacity();\n \n     // len is the length *after* removal\n-    for len in 0..cap - 1 {\n+    let minlen = if cfg!(miri) { cap - 2 } else { 0 }; // Miri is too slow\n+    for len in minlen..cap - 1 {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n         for tail_pos in 0..cap {\n@@ -251,7 +253,8 @@ fn test_range() {\n     let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n \n     let cap = tester.capacity();\n-    for len in 0..=cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n+    for len in minlen..=cap {\n         for tail in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n@@ -384,7 +387,8 @@ fn test_split_off() {\n     let cap = tester.capacity();\n \n     // len is the length *before* splitting\n-    for len in 0..cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n+    for len in minlen..cap {\n         // index to split at\n         for at in 0..=len {\n             // 0, 1, 2, .., at - 1 (may be empty)\n@@ -495,8 +499,9 @@ fn test_vec_from_vecdeque() {\n fn test_clone_from() {\n     let m = vec![1; 8];\n     let n = vec![2; 12];\n-    for pfv in 0..8 {\n-        for pfu in 0..8 {\n+    let limit = if cfg!(miri) { 4 } else { 8 }; // Miri is too slow\n+    for pfv in 0..limit {\n+        for pfu in 0..limit {\n             for longer in 0..2 {\n                 let (vr, ur) = if longer == 0 { (&m, &n) } else { (&n, &m) };\n                 let mut v = VecDeque::from(vr.clone());"}, {"sha": "9ac23886d4e15666c6b871f3e9fe1263784d91fe", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -104,6 +104,7 @@\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(nll)]\n+#![feature(nonnull_slice_from_raw_parts)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(pattern)]\n@@ -113,6 +114,8 @@\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![feature(min_specialization)]\n+#![feature(slice_ptr_get)]\n+#![feature(slice_ptr_len)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(str_internals)]"}, {"sha": "2abd7231711f3c4ebfeec9c53d78c8d444f809bd", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,25 +1,27 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::{LayoutErr, MemoryBlock};\n+use core::alloc::LayoutErr;\n use core::cmp;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n use core::ptr::{NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{\n-    handle_alloc_error,\n-    AllocInit::{self, *},\n-    AllocRef, Global, Layout,\n-    ReallocPlacement::{self, *},\n-};\n+use crate::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n #[cfg(test)]\n mod tests;\n \n+enum AllocInit {\n+    /// The contents of the new memory are uninitialized.\n+    Uninitialized,\n+    /// The new memory is guaranteed to be zeroed.\n+    Zeroed,\n+}\n+\n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n@@ -156,14 +158,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n-        Self::allocate_in(capacity, Uninitialized, alloc)\n+        Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)\n     }\n \n     /// Like `with_capacity_zeroed`, but parameterized over the choice\n     /// of allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n-        Self::allocate_in(capacity, Zeroed, alloc)\n+        Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n     }\n \n     fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n@@ -180,14 +182,18 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 Ok(_) => {}\n                 Err(_) => capacity_overflow(),\n             }\n-            let memory = match alloc.alloc(layout, init) {\n-                Ok(memory) => memory,\n+            let result = match init {\n+                AllocInit::Uninitialized => alloc.alloc(layout),\n+                AllocInit::Zeroed => alloc.alloc_zeroed(layout),\n+            };\n+            let ptr = match result {\n+                Ok(ptr) => ptr,\n                 Err(_) => handle_alloc_error(layout),\n             };\n \n             Self {\n-                ptr: unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) },\n-                cap: Self::capacity_from_bytes(memory.size),\n+                ptr: unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) },\n+                cap: Self::capacity_from_bytes(ptr.len()),\n                 alloc,\n             }\n         }\n@@ -358,7 +364,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// Aborts on OOM.\n     pub fn shrink_to_fit(&mut self, amount: usize) {\n-        match self.shrink(amount, MayMove) {\n+        match self.shrink(amount) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n@@ -378,9 +384,9 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         excess / mem::size_of::<T>()\n     }\n \n-    fn set_memory(&mut self, memory: MemoryBlock) {\n-        self.ptr = unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) };\n-        self.cap = Self::capacity_from_bytes(memory.size);\n+    fn set_ptr(&mut self, ptr: NonNull<[u8]>) {\n+        self.ptr = unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) };\n+        self.cap = Self::capacity_from_bytes(ptr.len());\n     }\n \n     // This method is usually instantiated many times. So we want it to be as\n@@ -426,8 +432,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`.\n-        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n-        self.set_memory(memory);\n+        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n+        self.set_ptr(ptr);\n         Ok(())\n     }\n \n@@ -445,30 +451,24 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`.\n-        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n-        self.set_memory(memory);\n+        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n+        self.set_ptr(ptr);\n         Ok(())\n     }\n \n-    fn shrink(\n-        &mut self,\n-        amount: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<(), TryReserveError> {\n+    fn shrink(&mut self, amount: usize) -> Result<(), TryReserveError> {\n         assert!(amount <= self.capacity(), \"Tried to shrink to a larger capacity\");\n \n         let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n         let new_size = amount * mem::size_of::<T>();\n \n-        let memory = unsafe {\n-            self.alloc.shrink(ptr, layout, new_size, placement).map_err(|_| {\n-                TryReserveError::AllocError {\n-                    layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n-                    non_exhaustive: (),\n-                }\n+        let ptr = unsafe {\n+            self.alloc.shrink(ptr, layout, new_size).map_err(|_| TryReserveError::AllocError {\n+                layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n+                non_exhaustive: (),\n             })?\n         };\n-        self.set_memory(memory);\n+        self.set_ptr(ptr);\n         Ok(())\n     }\n }\n@@ -481,7 +481,7 @@ fn finish_grow<A>(\n     new_layout: Result<Layout, LayoutErr>,\n     current_memory: Option<(NonNull<u8>, Layout)>,\n     alloc: &mut A,\n-) -> Result<MemoryBlock, TryReserveError>\n+) -> Result<NonNull<[u8]>, TryReserveError>\n where\n     A: AllocRef,\n {\n@@ -492,9 +492,9 @@ where\n \n     let memory = if let Some((ptr, old_layout)) = current_memory {\n         debug_assert_eq!(old_layout.align(), new_layout.align());\n-        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), MayMove, Uninitialized) }\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size()) }\n     } else {\n-        alloc.alloc(new_layout, Uninitialized)\n+        alloc.alloc(new_layout)\n     }\n     .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n "}, {"sha": "cadd913aa6bf244f1f6e9bc530dd069dcc002a36", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -20,12 +20,12 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n-            match Global.alloc(layout, init) {\n+            match Global.alloc(layout) {\n                 ok @ Ok(_) => {\n                     self.fuel -= size;\n                     ok"}, {"sha": "d0a47ccea0a76f96fabc05773bb226bd74d69a37", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -250,7 +250,7 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -928,12 +928,10 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let mem = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = mem_to_rcbox(mem.ptr.as_ptr());\n+        let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());\n         unsafe {\n             debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n@@ -2101,7 +2099,7 @@ impl<T: ?Sized> Unpin for Rc<T> {}\n ///\n /// - This function is safe for any argument if `T` is sized, and\n /// - if `T` is unsized, the pointer must have appropriate pointer metadata\n-///   aquired from the real instance that you are getting this offset for.\n+///   acquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `RcBox`.\n     // Because it is ?Sized, it will always be the last field in memory."}, {"sha": "b37633031375883844506603a0e2c2872c699a09", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -23,7 +23,7 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -883,12 +883,10 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let mem = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = mem_to_arcinner(mem.ptr.as_ptr());\n+        let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n         debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);\n \n         unsafe {\n@@ -988,7 +986,7 @@ impl<T> Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.cast(), self.layout);\n+                    Global.dealloc(self.mem, self.layout);\n                 }\n             }\n         }\n@@ -2255,7 +2253,7 @@ impl<T: ?Sized> Unpin for Arc<T> {}\n ///\n /// - This function is safe for any argument if `T` is sized, and\n /// - if `T` is unsized, the pointer must have appropriate pointer metadata\n-///   aquired from the real instance that you are getting this offset for.\n+///   acquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `ArcInner`.\n     // Because it is `?Sized`, it will always be the last field in memory."}, {"sha": "851ca17a365484370abe8d14971221533330ac84", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -37,7 +37,7 @@ fn box_clone_and_clone_from_equivalence() {\n /// This test might give a false positive in case the box realocates, but the alocator keeps the\n /// original pointer.\n ///\n-/// On the other hand it won't give a false negative, if it fails than the memory was definitly not\n+/// On the other hand it won't give a false negative, if it fails than the memory was definitely not\n /// reused\n #[test]\n fn box_clone_from_ptr_stability() {"}, {"sha": "cbde2a7e28e8f134004678ecd8b64478c27f4943", "filename": "library/alloc/tests/heap.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fheap.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -20,26 +20,23 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator\n-                            .alloc(\n-                                Layout::from_size_align(size, align).unwrap(),\n-                                AllocInit::Uninitialized,\n-                            )\n-                            .unwrap()\n-                            .ptr\n+                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n                     })\n                     .collect();\n                 for &ptr in &pointers {\n                     assert_eq!(\n-                        (ptr.as_ptr() as usize) % align,\n+                        (ptr.as_non_null_ptr().as_ptr() as usize) % align,\n                         0,\n                         \"Got a pointer less aligned than requested\"\n                     )\n                 }\n \n                 // Clean up\n                 for &ptr in &pointers {\n-                    allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                    allocator.dealloc(\n+                        ptr.as_non_null_ptr(),\n+                        Layout::from_size_align(size, align).unwrap(),\n+                    )\n                 }\n             }\n         }"}, {"sha": "c680a3fc25bd40b84a656d7983903b0c23f7dcb6", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -13,6 +13,7 @@\n #![feature(associated_type_bounds)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n+#![feature(slice_ptr_get)]\n #![feature(split_inclusive)]\n #![feature(binary_heap_retain)]\n "}, {"sha": "147f7f7d0c72956156c39fbaea656556ddb62994", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1721,8 +1721,8 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    // Miri is too slow\n-    let lens = if cfg!(miri) { (1..10).chain(20..21) } else { (1..20).chain(70..MAX_LEN) };\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n     let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n \n     for len in lens {"}, {"sha": "2833768f213bfc8ae95e2a7f03a819930c8790ce", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 181, "deletions": 193, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -29,92 +29,6 @@ impl fmt::Display for AllocErr {\n     }\n }\n \n-/// A desired initial state for allocated memory.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub enum AllocInit {\n-    /// The contents of the new memory are uninitialized.\n-    Uninitialized,\n-    /// The new memory is guaranteed to be zeroed.\n-    Zeroed,\n-}\n-\n-impl AllocInit {\n-    /// Initialize the specified memory block.\n-    ///\n-    /// This behaves like calling [`AllocInit::init_offset(memory, 0)`][off].\n-    ///\n-    /// [off]: AllocInit::init_offset\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `memory.ptr` must be [valid] for writes of `memory.size` bytes.\n-    ///\n-    /// [valid]: ../../core/ptr/index.html#safety\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub unsafe fn init(self, memory: MemoryBlock) {\n-        // SAFETY: the safety contract for `init_offset` must be\n-        // upheld by the caller.\n-        unsafe { self.init_offset(memory, 0) }\n-    }\n-\n-    /// Initialize the memory block like specified by `init` at the specified `offset`.\n-    ///\n-    /// This is a no-op for [`AllocInit::Uninitialized`][] and writes zeroes for\n-    /// [`AllocInit::Zeroed`][] at `ptr + offset` until `ptr + layout.size()`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `memory.ptr` must be [valid] for writes of `memory.size` bytes.\n-    /// * `offset` must be smaller than or equal to `memory.size`\n-    ///\n-    /// [valid]: ../../core/ptr/index.html#safety\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub unsafe fn init_offset(self, memory: MemoryBlock, offset: usize) {\n-        debug_assert!(\n-            offset <= memory.size,\n-            \"`offset` must be smaller than or equal to `memory.size`\"\n-        );\n-        match self {\n-            AllocInit::Uninitialized => (),\n-            AllocInit::Zeroed => {\n-                // SAFETY: the caller must guarantee that `offset` is smaller than or equal to `memory.size`,\n-                // so the memory from `memory.ptr + offset` of length `memory.size - offset`\n-                // is guaranteed to be contaned in `memory` and thus valid for writes.\n-                unsafe { memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset) }\n-            }\n-        }\n-    }\n-}\n-\n-/// Represents a block of allocated memory returned by an allocator.\n-#[derive(Debug, Copy, Clone)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub struct MemoryBlock {\n-    pub ptr: NonNull<u8>,\n-    pub size: usize,\n-}\n-\n-/// A placement constraint when growing or shrinking an existing allocation.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub enum ReallocPlacement {\n-    /// The allocator is allowed to move the allocation to a different memory address.\n-    // FIXME(wg-allocators#46): Add a section to the module documentation \"What is a legal\n-    //                          allocator\" and link it at \"valid location\".\n-    ///\n-    /// If the allocation _does_ move, it's the responsibility of the allocator\n-    /// to also move the data from the previous location to the new location.\n-    MayMove,\n-    /// The address of the new memory must not change.\n-    ///\n-    /// If the allocation would have to be moved to a new location to fit, the\n-    /// reallocation request will fail.\n-    InPlace,\n-}\n-\n /// An implementation of `AllocRef` can allocate, grow, shrink, and deallocate arbitrary blocks of\n /// data described via [`Layout`][].\n ///\n@@ -175,12 +89,12 @@ pub enum ReallocPlacement {\n pub unsafe trait AllocRef {\n     /// Attempts to allocate a block of memory.\n     ///\n-    /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n+    /// On success, returns a [`NonNull<[u8]>`] meeting the size and alignment guarantees of `layout`.\n     ///\n-    /// The returned block may have a larger size than specified by `layout.size()` and is\n-    /// initialized as specified by [`init`], all the way up to the returned size of the block.\n+    /// The returned block may have a larger size than specified by `layout.size()`, and may or may\n+    /// not have its contents initialized.\n     ///\n-    /// [`init`]: AllocInit\n+    /// [`NonNull<[u8]>`]: NonNull\n     ///\n     /// # Errors\n     ///\n@@ -195,7 +109,29 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n+\n+    /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n+    /// allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        let ptr = self.alloc(layout)?;\n+        // SAFETY: `alloc` returns a valid memory block\n+        unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }\n+        Ok(ptr)\n+    }\n \n     /// Deallocates the memory referenced by `ptr`.\n     ///\n@@ -210,44 +146,100 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n-    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n-    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n-    ///\n-    /// If [`MayMove`] is used then ownership of the memory block referenced by `ptr`\n-    /// is transferred to this allocator. The memory may or may not be freed, and should be\n-    /// considered unusable (unless of course it is transferred back to the caller again via the\n-    /// return value of this method).\n+    /// allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n-    /// The memory block will contain the following contents after a successful call to `grow`:\n+    /// [`NonNull<[u8]>`]: NonNull\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n+    /// * `new_size` must be greater than or equal to `layout.size()`, and\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n+    ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    // Note: We can't require that `new_size` is strictly greater than `layout.size()` because of ZSTs.\n+    // alternative: `new_size` must be strictly greater than `layout.size()` or both are zero\n+    ///\n+    /// [*currently allocated*]: #currently-allocated-memory\n+    /// [*fit*]: #memory-fitting\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n+    /// constraints of the allocator, or if growing otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn grow(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(NonNull::slice_from_raw_parts(ptr, size));\n+        }\n+\n+        let new_layout =\n+            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+            // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n+            // to zero, it's catched beforehand.\n+            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_ptr = self.alloc(new_layout)?;\n+\n+        // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+        // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+        // allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n+        // `copy_nonoverlapping` is safe.\n+        // The safety contract for `dealloc` must be upheld by the caller.\n+        unsafe {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n+            self.dealloc(ptr, layout);\n+            Ok(new_ptr)\n+        }\n+    }\n+\n+    /// Behaves like `grow`, but also ensures that the new contents are set to zero before being\n+    /// returned.\n+    ///\n+    /// The memory block will contain the following contents after a successful call to\n+    /// `grow_zeroed`:\n     ///   * Bytes `0..layout.size()` are preserved from the original allocation.\n-    ///   * Bytes `layout.size()..old_size` will either be preserved or initialized according to\n-    ///     [`init`], depending on the allocator implementation. `old_size` refers to the size of\n-    ///     the `MemoryBlock` prior to the `grow` call, which may be larger than the size\n+    ///   * Bytes `layout.size()..old_size` will either be preserved or zeroed,\n+    ///     depending on the allocator implementation. `old_size` refers to the size of\n+    ///     the `MemoryBlock` prior to the `grow_zeroed` call, which may be larger than the size\n     ///     that was originally requested when it was allocated.\n-    ///   * Bytes `old_size..new_size` are initialized according to [`init`]. `new_size` refers to\n+    ///   * Bytes `old_size..new_size` are zeroed. `new_size` refers to\n     ///     the size of the `MemoryBlock` returned by the `grow` call.\n     ///\n-    /// [`InPlace`]: ReallocPlacement::InPlace\n-    /// [`MayMove`]: ReallocPlacement::MayMove\n-    /// [`placement`]: ReallocPlacement\n-    /// [`init`]: AllocInit\n-    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n     /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n-    // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n-    // An alternative would be\n-    // * `new_size must be strictly greater than `memory.size` or both are zero\n     /// * `new_size` must be greater than or equal to `layout.size()`, and\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    // Note: We can't require that `new_size` is strictly greater than `layout.size()` because of ZSTs.\n+    // alternative: `new_size` must be strictly greater than `layout.size()` or both are zero\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -265,55 +257,48 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn grow(\n+    unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n-    ) -> Result<MemoryBlock, AllocErr> {\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove => {\n-                let size = layout.size();\n-                debug_assert!(\n-                    new_size >= size,\n-                    \"`new_size` must be greater than or equal to `layout.size()`\"\n-                );\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n \n-                if new_size == size {\n-                    return Ok(MemoryBlock { ptr, size });\n-                }\n+        if size == new_size {\n+            return Ok(NonNull::slice_from_raw_parts(ptr, size));\n+        }\n \n-                let new_layout =\n-                    // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-                    // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-                    // The caller must ensure that `new_size` is greater than zero.\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                let new_memory = self.alloc(new_layout, init)?;\n+        let new_layout =\n+            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+            // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n+            // to zero, it's caught beforehand.\n+            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_ptr = self.alloc_zeroed(new_layout)?;\n \n-                // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n-                // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n-                // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n-                // `copy_nonoverlapping` is safe.\n-                // The safety contract for `dealloc` must be upheld by the caller.\n-                unsafe {\n-                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n-                    self.dealloc(ptr, layout);\n-                    Ok(new_memory)\n-                }\n-            }\n+        // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+        // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+        // allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n+        // `copy_nonoverlapping` is safe.\n+        // The safety contract for `dealloc` must be upheld by the caller.\n+        unsafe {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n+            self.dealloc(ptr, layout);\n+            Ok(new_ptr)\n         }\n     }\n \n     /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n-    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n-    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n+    /// allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n     /// transferred to this allocator. The memory may or may not have been freed, and should be\n@@ -323,19 +308,15 @@ pub unsafe trait AllocRef {\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n-    /// The behavior of how the allocator tries to shrink the memory is specified by [`placement`].\n-    ///\n-    /// [`InPlace`]: ReallocPlacement::InPlace\n-    /// [`placement`]: ReallocPlacement\n+    /// [`NonNull<[u8]>`]: NonNull\n     ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n     /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n-    // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n-    // An alternative would be\n-    // * `new_size must be strictly smaller than `memory.size` or both are zero\n     /// * `new_size` must be smaller than or equal to `layout.size()`.\n+    // Note: We can't require that `new_size` is strictly smaller than `layout.size()` because of ZSTs.\n+    // alternative: `new_size` must be smaller than `layout.size()` or both are zero\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -358,39 +339,33 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<MemoryBlock, AllocErr> {\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove => {\n-                let size = layout.size();\n-                debug_assert!(\n-                    new_size <= size,\n-                    \"`new_size` must be smaller than or equal to `layout.size()`\"\n-                );\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size <= size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+        );\n \n-                if new_size == size {\n-                    return Ok(MemoryBlock { ptr, size });\n-                }\n+        if size == new_size {\n+            return Ok(NonNull::slice_from_raw_parts(ptr, size));\n+        }\n \n-                let new_layout =\n-                // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-                // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-                // The caller must ensure that `new_size` is greater than zero.\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n+        let new_layout =\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+        // The caller must ensure that `new_size` is greater than zero.\n+            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_ptr = self.alloc(new_layout)?;\n \n-                // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n-                // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n-                // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n-                // `copy_nonoverlapping` is safe.\n-                // The safety contract for `dealloc` must be upheld by the caller.\n-                unsafe {\n-                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n-                    self.dealloc(ptr, layout);\n-                    Ok(new_memory)\n-                }\n-            }\n+        // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n+        // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n+        // old allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n+        // `copy_nonoverlapping` is safe.\n+        // The safety contract for `dealloc` must be upheld by the caller.\n+        unsafe {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n+            self.dealloc(ptr, layout);\n+            Ok(new_ptr)\n         }\n     }\n \n@@ -409,8 +384,13 @@ where\n     A: AllocRef + ?Sized,\n {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n-        (**self).alloc(layout, init)\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        (**self).alloc(layout)\n+    }\n+\n+    #[inline]\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        (**self).alloc_zeroed(layout)\n     }\n \n     #[inline]\n@@ -425,11 +405,20 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).grow(ptr, layout, new_size) }\n+    }\n+\n+    #[inline]\n+    unsafe fn grow_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).grow(ptr, layout, new_size, placement, init) }\n+        unsafe { (**self).grow_zeroed(ptr, layout, new_size) }\n     }\n \n     #[inline]\n@@ -438,9 +427,8 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).shrink(ptr, layout, new_size, placement) }\n+        unsafe { (**self).shrink(ptr, layout, new_size) }\n     }\n }"}, {"sha": "cbbfcb4611321a68ae861f650552de7e8a278cd8", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -788,6 +788,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[track_caller]\n     pub fn borrow(&self) -> Ref<'_, T> {\n         self.try_borrow().expect(\"already mutably borrowed\")\n     }\n@@ -863,6 +864,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> RefMut<'_, T> {\n         self.try_borrow_mut().expect(\"already borrowed\")\n     }"}, {"sha": "3a28bc79effafd6fc25b0bf4036ab5ad89d15543", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1950,15 +1950,20 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n-    /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n-    /// generation.\n+    /// option is enabled. The source code region information is extracted prior to code generation,\n+    /// and added to the \"coverage map\", which is injected into the generated code as additional\n+    /// data. This intrinsic then triggers the generation of LLVM intrinsic call\n+    /// `instrprof.increment`, using the remaining args (`function_source_hash` and `index`).\n     #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n     pub fn count_code_region(\n         function_source_hash: u64,\n         index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n     );\n \n     /// Internal marker for code coverage expressions, injected into the MIR when the\n@@ -1973,8 +1978,11 @@ extern \"rust-intrinsic\" {\n         index: u32,\n         left_index: u32,\n         right_index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n     );\n \n     /// This marker identifies a code region and two other counters or counter expressions\n@@ -1986,14 +1994,24 @@ extern \"rust-intrinsic\" {\n         index: u32,\n         left_index: u32,\n         right_index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n     );\n \n     /// This marker identifies a code region to be added to the \"coverage map\" to indicate source\n     /// code that can never be reached.\n     /// (See `coverage_counter_add` for more information.)\n-    pub fn coverage_unreachable(start_byte_pos: u32, end_byte_pos: u32);\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_unreachable(\n+        file_name: &'static str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n+    );\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]"}, {"sha": "eb50dc28b9f1101e8afe9d9c04de69fc4f3c947b", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1601,6 +1601,29 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Computes the absolute value of `self` without any wrapping\n+or panicking.\n+\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"#![feature(unsigned_abs)]\n+assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\n+assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\n+assert_eq!((-128i8).unsigned_abs(), 128u8);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"unsigned_abs\", issue = \"74913\")]\n+            #[inline]\n+            pub const fn unsigned_abs(self) -> $UnsignedT {\n+                 self.wrapping_abs() as $UnsignedT\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n wrapping around at the boundary of the type."}, {"sha": "e68dbf5215f6d06b9f6924464a86a1325fc2da4f", "filename": "library/core/src/result.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1145,7 +1145,6 @@ impl<T, E: Into<!>> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T: Deref, E> Result<T, E> {\n     /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n     ///\n@@ -1155,7 +1154,6 @@ impl<T: Deref, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inner_deref)]\n     /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n     /// let y: Result<&str, &u32> = Ok(\"hello\");\n     /// assert_eq!(x.as_deref(), y);\n@@ -1164,23 +1162,12 @@ impl<T: Deref, E> Result<T, E> {\n     /// let y: Result<&str, &u32> = Err(&42);\n     /// assert_eq!(x.as_deref(), y);\n     /// ```\n+    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n     pub fn as_deref(&self) -> Result<&T::Target, &E> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n-impl<T, E: Deref> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T, &<E as Deref>::Target>`.\n-    ///\n-    /// Coerces the [`Err`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n-    /// and returns the new [`Result`].\n-    pub fn as_deref_err(&self) -> Result<&T, &E::Target> {\n-        self.as_ref().map_err(|e| e.deref())\n-    }\n-}\n-\n-#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T: DerefMut, E> Result<T, E> {\n     /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n     ///\n@@ -1190,7 +1177,6 @@ impl<T: DerefMut, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inner_deref)]\n     /// let mut s = \"HELLO\".to_string();\n     /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n     /// let y: Result<&mut str, &mut u32> = Ok(&mut s);\n@@ -1201,22 +1187,12 @@ impl<T: DerefMut, E> Result<T, E> {\n     /// let y: Result<&mut str, &mut u32> = Err(&mut i);\n     /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n     /// ```\n+    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n     pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n-impl<T, E: DerefMut> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T, &mut <E as DerefMut>::Target>`.\n-    ///\n-    /// Coerces the [`Err`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n-    /// and returns the new [`Result`].\n-    pub fn as_deref_mut_err(&mut self) -> Result<&mut T, &mut E::Target> {\n-        self.as_mut().map_err(|e| e.deref_mut())\n-    }\n-}\n-\n impl<T, E> Result<Option<T>, E> {\n     /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n     ///"}, {"sha": "b4c299d390586d05665923f442e2043135078f8f", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -27,7 +27,6 @@\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_trait)]\n-#![feature(inner_deref)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]"}, {"sha": "e5656eb204c733ab8933f0ddd21be3463e0b75d8", "filename": "library/core/tests/num/flt2dec/random.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -188,7 +188,7 @@ fn exact_f32_random_equivalence_test() {\n fn exact_f64_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n     // Miri is too slow\n-    let n = if cfg!(miri) { 3 } else { 1_000 };\n+    let n = if cfg!(miri) { 2 } else { 1_000 };\n \n     for k in 1..21 {\n         f64_random_equivalence_test("}, {"sha": "7e6c8add3339d2d0052fc800fbbb7ce5e2eeda61", "filename": "library/core/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,6 +2,7 @@ use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n #[test]\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_cached_power() {\n     assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n     assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);"}, {"sha": "caa2d916cd7a8c542e80f6b99c092aeafa9da545", "filename": "library/core/tests/result.rs", "status": "modified", "additions": 9, "deletions": 118, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fresult.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -250,24 +250,11 @@ fn test_result_as_deref() {\n     let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n-    // &Result<T, E: Deref>::Err(T).as_deref_err() ->\n-    //      Result<&T, &E::Deref::Target>::Err(&*E)\n-    let ref_err = &Result::Err::<u8, &i32>(&41);\n-    let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.as_deref_err(), expected_result);\n-\n-    let ref_err = &Result::Err::<u32, String>(String::from(\"an error\"));\n-    let expected_result = Result::Err::<&u32, &str>(\"an error\");\n-    assert_eq!(ref_err.as_deref_err(), expected_result);\n-\n-    let ref_err = &Result::Err::<u32, Vec<i32>>(vec![5, 4, 3, 2, 1]);\n-    let expected_result = Result::Err::<&u32, &[i32]>([5, 4, 3, 2, 1].as_slice());\n-    assert_eq!(ref_err.as_deref_err(), expected_result);\n-\n-    // &Result<T: Deref, E: Deref>::Err(T).as_deref_err() ->\n-    //      Result<&T, &E::Deref::Target>::Err(&*E)\n-    let ref_err = &Result::Err::<&u8, &i32>(&41);\n-    let expected_result = Result::Err::<&u8, &&i32>(&&41);\n+    // &Result<T: Deref, E>::Err(T).as_deref() ->\n+    //      Result<&T::Deref::Target, &E>::Err(&*E)\n+    let val = 41;\n+    let ref_err = &Result::Err::<&u8, i32>(val);\n+    let expected_result = Result::Err::<&u8, &i32>(&val);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n     let s = String::from(\"an error\");\n@@ -279,46 +266,12 @@ fn test_result_as_deref() {\n     let ref_err = &Result::Err::<&u32, Vec<i32>>(v.clone());\n     let expected_result = Result::Err::<&u32, &Vec<i32>>(&v);\n     assert_eq!(ref_err.as_deref(), expected_result);\n-\n-    // The following cases test calling `as_deref_*` with the wrong variant (i.e.\n-    // `as_deref()` with a `Result::Err()`, or `as_deref_err()` with a `Result::Ok()`.\n-    // While uncommon, these cases are supported to ensure that an `as_deref_*`\n-    // call can still be made even when one of the Result types does not implement\n-    // `Deref` (for example, std::io::Error).\n-\n-    // &Result<T, E: Deref>::Ok(T).as_deref_err() ->\n-    //      Result<&T, &E::Deref::Target>::Ok(&T)\n-    let ref_ok = &Result::Ok::<i32, &u8>(42);\n-    let expected_result = Result::Ok::<&i32, &u8>(&42);\n-    assert_eq!(ref_ok.as_deref_err(), expected_result);\n-\n-    let ref_ok = &Result::Ok::<&str, &u32>(\"a result\");\n-    let expected_result = Result::Ok::<&&str, &u32>(&\"a result\");\n-    assert_eq!(ref_ok.as_deref_err(), expected_result);\n-\n-    let ref_ok = &Result::Ok::<[i32; 5], &u32>([1, 2, 3, 4, 5]);\n-    let expected_result = Result::Ok::<&[i32; 5], &u32>(&[1, 2, 3, 4, 5]);\n-    assert_eq!(ref_ok.as_deref_err(), expected_result);\n-\n-    // &Result<T: Deref, E>::Err(E).as_deref() ->\n-    //      Result<&T::Deref::Target, &E>::Err(&E)\n-    let ref_err = &Result::Err::<&u8, i32>(41);\n-    let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.as_deref(), expected_result);\n-\n-    let ref_err = &Result::Err::<&u32, &str>(\"an error\");\n-    let expected_result = Result::Err::<&u32, &&str>(&\"an error\");\n-    assert_eq!(ref_err.as_deref(), expected_result);\n-\n-    let ref_err = &Result::Err::<&u32, [i32; 5]>([5, 4, 3, 2, 1]);\n-    let expected_result = Result::Err::<&u32, &[i32; 5]>(&[5, 4, 3, 2, 1]);\n-    assert_eq!(ref_err.as_deref(), expected_result);\n }\n \n #[test]\n fn test_result_as_deref_mut() {\n-    // &mut Result<T: Deref, E>::Ok(T).as_deref_mut() ->\n-    //      Result<&mut T::Deref::Target, &mut E>::Ok(&mut *T)\n+    // &mut Result<T: DerefMut, E>::Ok(T).as_deref_mut() ->\n+    //      Result<&mut T::DerefMut::Target, &mut E>::Ok(&mut *T)\n     let mut val = 42;\n     let mut expected_val = 42;\n     let mut_ok = &mut Result::Ok::<&mut i32, u8>(&mut val);\n@@ -335,26 +288,8 @@ fn test_result_as_deref_mut() {\n     let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n-    // &mut Result<T, E: Deref>::Err(T).as_deref_mut_err() ->\n-    //      Result<&mut T, &mut E::Deref::Target>::Err(&mut *E)\n-    let mut val = 41;\n-    let mut expected_val = 41;\n-    let mut_err = &mut Result::Err::<u8, &mut i32>(&mut val);\n-    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n-    assert_eq!(mut_err.as_deref_mut_err(), expected_result);\n-\n-    let mut expected_string = String::from(\"an error\");\n-    let mut_err = &mut Result::Err::<u32, String>(expected_string.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut str>(expected_string.deref_mut());\n-    assert_eq!(mut_err.as_deref_mut_err(), expected_result);\n-\n-    let mut expected_vec = vec![5, 4, 3, 2, 1];\n-    let mut_err = &mut Result::Err::<u32, Vec<i32>>(expected_vec.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut [i32]>(expected_vec.as_mut_slice());\n-    assert_eq!(mut_err.as_deref_mut_err(), expected_result);\n-\n-    // &mut Result<T: Deref, E: Deref>::Err(T).as_deref_mut_err() ->\n-    //      Result<&mut T, &mut E::Deref::Target>::Err(&mut *E)\n+    // &mut Result<T: DerefMut, E>::Err(T).as_deref_mut() ->\n+    //      Result<&mut T, &mut E>::Err(&mut *E)\n     let mut val = 41;\n     let mut_err = &mut Result::Err::<&mut u8, i32>(val);\n     let expected_result = Result::Err::<&mut u8, &mut i32>(&mut val);\n@@ -369,48 +304,4 @@ fn test_result_as_deref_mut() {\n     let mut_err = &mut Result::Err::<&mut u32, Vec<i32>>(expected_vec.clone());\n     let expected_result = Result::Err::<&mut u32, &mut Vec<i32>>(&mut expected_vec);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n-\n-    // The following cases test calling `as_deref_mut_*` with the wrong variant (i.e.\n-    // `as_deref_mut()` with a `Result::Err()`, or `as_deref_mut_err()` with a `Result::Ok()`.\n-    // While uncommon, these cases are supported to ensure that an `as_deref_mut_*`\n-    // call can still be made even when one of the Result types does not implement\n-    // `Deref` (for example, std::io::Error).\n-\n-    // &mut Result<T, E: Deref>::Ok(T).as_deref_mut_err() ->\n-    //      Result<&mut T, &mut E::Deref::Target>::Ok(&mut T)\n-    let mut expected_val = 42;\n-    let mut_ok = &mut Result::Ok::<i32, &mut u8>(expected_val.clone());\n-    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n-    assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n-\n-    let string = String::from(\"a result\");\n-    let expected_string = string.clone();\n-    let mut ref_str = expected_string.as_ref();\n-    let mut_ok = &mut Result::Ok::<&str, &mut u32>(string.as_str());\n-    let expected_result = Result::Ok::<&mut &str, &mut u32>(&mut ref_str);\n-    assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n-\n-    let mut expected_arr = [1, 2, 3, 4, 5];\n-    let mut_ok = &mut Result::Ok::<[i32; 5], &mut u32>(expected_arr.clone());\n-    let expected_result = Result::Ok::<&mut [i32; 5], &mut u32>(&mut expected_arr);\n-    assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n-\n-    // &mut Result<T: Deref, E>::Err(E).as_deref_mut() ->\n-    //      Result<&mut T::Deref::Target, &mut E>::Err(&mut E)\n-    let mut expected_val = 41;\n-    let mut_err = &mut Result::Err::<&mut u8, i32>(expected_val.clone());\n-    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n-    assert_eq!(mut_err.as_deref_mut(), expected_result);\n-\n-    let string = String::from(\"an error\");\n-    let expected_string = string.clone();\n-    let mut ref_str = expected_string.as_ref();\n-    let mut_err = &mut Result::Err::<&mut u32, &str>(string.as_str());\n-    let expected_result = Result::Err::<&mut u32, &mut &str>(&mut ref_str);\n-    assert_eq!(mut_err.as_deref_mut(), expected_result);\n-\n-    let mut expected_arr = [5, 4, 3, 2, 1];\n-    let mut_err = &mut Result::Err::<&mut u32, [i32; 5]>(expected_arr.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut [i32; 5]>(&mut expected_arr);\n-    assert_eq!(mut_err.as_deref_mut(), expected_result);\n }"}, {"sha": "42b483f33ba44a2dc1c123d5a070697589bcb8f1", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1358,15 +1358,15 @@ fn sort_unstable() {\n     use core::slice::heapsort;\n     use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n \n-    // Miri is too slow\n-    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (2..20).chain(0..0) } else { (2..25).chain(500..510) };\n     let rounds = if cfg!(miri) { 1 } else { 100 };\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n     let mut rng = StdRng::from_entropy();\n \n-    for len in (2..25).chain(large_range) {\n+    for len in lens {\n         let v = &mut v[0..len];\n         let tmp = &mut tmp[0..len];\n "}, {"sha": "de3866d92fc3f181ee192baa930917031b51bef0", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -24,7 +24,6 @@\n #![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n-#![feature(inner_deref)]\n #![feature(negative_impls)]\n #![feature(optin_builtin_traits)]\n #![feature(restricted_std)]\n@@ -849,7 +848,7 @@ impl Ident {\n     /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     /// The `string` argument must be a valid identifier permitted by the\n-    /// language, otherwise the function will panic.\n+    /// language (including keywords, e.g. `self` or `fn`). Otherwise, the function will panic.\n     ///\n     /// Note that `span`, currently in rustc, configures the hygiene information\n     /// for this identifier.\n@@ -871,7 +870,10 @@ impl Ident {\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n-    #[unstable(feature = \"proc_macro_raw_ident\", issue = \"54723\")]\n+    /// The `string` argument be a valid identifier permitted by the language\n+    /// (including keywords, e.g. `fn`). Keywords which are usable in path segments\n+    /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n+    #[stable(feature = \"proc_macro_raw_ident\", since = \"1.47.0\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n         Ident(bridge::client::Ident::new(string, span.0, true))\n     }"}, {"sha": "4712cc95b4ab744fd11e655c546c11bd9b0dc897", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 96, "deletions": 94, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -140,28 +140,35 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = match init {\n-                    AllocInit::Uninitialized => GlobalAlloc::alloc(self, layout),\n-                    AllocInit::Zeroed => GlobalAlloc::alloc_zeroed(self, layout),\n-                };\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(GlobalAlloc::alloc(&System, layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n+    }\n+\n+    #[inline]\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(GlobalAlloc::alloc_zeroed(&System, layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            // SAFETY: The safety guarantees are explained in the documentation\n-            // for the `GlobalAlloc` trait and its `dealloc` method.\n-            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n+            // SAFETY: `layout` is non-zero in size,\n+            // other conditions must be upheld by the caller\n+            unsafe { GlobalAlloc::dealloc(&System, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -171,53 +178,59 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n-    ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n+                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n+            }\n         }\n+    }\n \n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout =\n-                    // SAFETY: The new size and layout alignement guarantees\n-                    // are transfered to the caller (they come from parameters).\n-                    //\n-                    // See the preconditions for `Layout::from_size_align` to\n-                    // see what must be checked.\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                self.alloc(new_layout, init)\n-            }\n-            ReallocPlacement::MayMove => {\n-                // SAFETY:\n-                //\n-                // The safety guarantees are explained in the documentation\n-                // for the `GlobalAlloc` trait and its `dealloc` method.\n-                //\n-                // `realloc` probably checks for `new_size > size` or something\n-                // similar.\n-                //\n-                // For the guarantees about `init_offset`, see its documentation:\n-                // `ptr` is assumed valid (and checked for non-NUL) and\n-                // `memory.size` is set to `new_size` so the offset being `size`\n-                // is valid.\n-                let memory = unsafe {\n-                    intrinsics::assume(new_size > size);\n-                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                    let memory =\n-                        MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                    init.init_offset(memory, size);\n-                    memory\n-                };\n-                Ok(memory)\n+    #[inline]\n+    unsafe fn grow_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        debug_assert!(\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n+                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n             }\n         }\n     }\n@@ -228,45 +241,34 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+            new_size <= old_size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if new_size == 0 => {\n-                // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n-                // must be respected. `ptr` and `layout` are parameters and so\n-                // those guarantees must be checked by the caller.\n-                unsafe { self.dealloc(ptr, layout) };\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+        let ptr = if new_size == old_size {\n+            ptr\n+        } else if new_size == 0 {\n+            // SAFETY: `layout` is non-zero in size as `old_size` != `new_size`\n+            // Other conditions must be upheld by the caller\n+            unsafe {\n+                self.dealloc(ptr, layout);\n             }\n-            ReallocPlacement::MayMove => {\n-                // SAFETY:\n-                //\n-                // See `GlobalAlloc::realloc` for more informations about the\n-                // guarantees expected by this method. `ptr`, `layout` and\n-                // `new_size` are parameters and the responsability for their\n-                // correctness is left to the caller.\n-                //\n-                // `realloc` probably checks for `new_size < size` or something\n-                // similar.\n-                let memory = unsafe {\n-                    intrinsics::assume(new_size < size);\n-                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n-                };\n-                Ok(memory)\n-            }\n-        }\n+            layout.dangling()\n+        } else {\n+            // SAFETY: new_size is not zero,\n+            // Other conditions must be upheld by the caller\n+            let raw_ptr = unsafe {\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size)\n+            };\n+            NonNull::new(raw_ptr).ok_or(AllocErr)?\n+        };\n+\n+        Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n     }\n }\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());"}, {"sha": "c98008688ab4f078d39f7511e3b522faddb8601a", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1363,7 +1363,7 @@ mod self_upper_keyword {}\n ///\n /// let r1 = &FOO as *const _;\n /// let r2 = &FOO as *const _;\n-/// // With a strictly read-only static, references will have the same adress\n+/// // With a strictly read-only static, references will have the same address\n /// assert_eq!(r1, r2);\n /// // A static item can be used just like a variable in many cases\n /// println!(\"{:?}\", FOO);"}, {"sha": "0569e46241a8075622e76c247e5b990b80b372a9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -291,6 +291,7 @@\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(nonnull_slice_from_raw_parts)]\n #![feature(once_cell)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n@@ -308,6 +309,8 @@\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n+#![feature(slice_ptr_get)]\n+#![feature(slice_ptr_len)]\n #![feature(slice_strip)]\n #![feature(staged_api)]\n #![feature(std_internals)]"}, {"sha": "714ec3e878617adfad8c2308741d9f599d8e2c84", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -81,7 +81,7 @@\n //   see the changes to drop the `Waiter` struct correctly.\n // * There is one place where the two atomics `Once.state_and_queue` and\n //   `Waiter.signaled` come together, and might be reordered by the compiler or\n-//   processor. Because both use Aquire ordering such a reordering is not\n+//   processor. Because both use Acquire ordering such a reordering is not\n //   allowed, so no need for SeqCst.\n \n use crate::cell::Cell;"}, {"sha": "e36a53084bae1874a92be0ba1056e7edf691f899", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -3,6 +3,8 @@\n use crate::cmp;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n+#[cfg(not(any(target_os = \"redox\", target_env = \"newlib\")))]\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n \n@@ -26,6 +28,27 @@ const READ_LIMIT: usize = c_int::MAX as usize - 1;\n #[cfg(not(target_os = \"macos\"))]\n const READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n \n+#[cfg(not(any(target_os = \"redox\", target_env = \"newlib\")))]\n+fn max_iov() -> usize {\n+    static LIM: AtomicUsize = AtomicUsize::new(0);\n+\n+    let mut lim = LIM.load(Ordering::Relaxed);\n+    if lim == 0 {\n+        let ret = unsafe { libc::sysconf(libc::_SC_IOV_MAX) };\n+\n+        // 16 is the minimum value required by POSIX.\n+        lim = if ret > 0 { ret as usize } else { 16 };\n+        LIM.store(lim, Ordering::Relaxed);\n+    }\n+\n+    lim\n+}\n+\n+#[cfg(any(target_os = \"redox\", target_env = \"newlib\"))]\n+fn max_iov() -> usize {\n+    16 // The minimum value required by POSIX.\n+}\n+\n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n         FileDesc { fd }\n@@ -54,7 +77,7 @@ impl FileDesc {\n             libc::readv(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n+                cmp::min(bufs.len(), max_iov()) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -111,7 +134,7 @@ impl FileDesc {\n             libc::writev(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n+                cmp::min(bufs.len(), max_iov()) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -256,3 +279,16 @@ impl Drop for FileDesc {\n         let _ = unsafe { libc::close(self.fd) };\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{FileDesc, IoSlice};\n+\n+    #[test]\n+    fn limit_vector_count() {\n+        let stdout = FileDesc { fd: 1 };\n+        let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n+\n+        assert!(stdout.write_vectored(&bufs).is_ok());\n+    }\n+}"}, {"sha": "6782d845bb056cf841ed32a00c30e6a4af337319", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -331,6 +331,7 @@ impl OpenOptions {\n         // FIXME: some of these should probably be read-only or write-only...\n         base |= wasi::RIGHTS_FD_ADVISE;\n         base |= wasi::RIGHTS_FD_FDSTAT_SET_FLAGS;\n+        base |= wasi::RIGHTS_FD_FILESTAT_GET;\n         base |= wasi::RIGHTS_FD_FILESTAT_SET_TIMES;\n         base |= wasi::RIGHTS_FD_SEEK;\n         base |= wasi::RIGHTS_FD_SYNC;"}, {"sha": "78891cdf292c23278ca8723bd543100249159604", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1 +1 @@\n-Subproject commit 311d56cd91609c1c1c0370cbd2ece8e3048653a5\n+Subproject commit 78891cdf292c23278ca8723bd543100249159604"}, {"sha": "4dd71ebade1a416a54f643bd248ccaa530ef2467", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -171,7 +171,9 @@ fn main() {\n         // note: everything below here is unreachable. do not put code that\n         // should run on success, after this block.\n     }\n-    println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+    if verbose > 0 {\n+        println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+    }\n \n     if let Some(mut on_fail) = on_fail {\n         on_fail.status().expect(\"Could not run the on_fail command\");"}, {"sha": "e13a5f2465336fbea5d44ab4c4bd3a87e13556d0", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1037,7 +1037,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        // FIXME: Don't use LLD if we're compiling libtest, since it fails to link it.\n+        // FIXME: Don't use LLD with MSVC if we're compiling libtest, since it fails to link it.\n         // See https://github.com/rust-lang/rust/issues/68647.\n         let can_use_lld = mode != Mode::Std;\n \n@@ -1049,6 +1049,11 @@ impl<'a> Builder<'a> {\n             let target = crate::envify(&target.triple);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n+\n+        if self.config.use_lld && !target.contains(\"msvc\") {\n+            rustflags.arg(\"-Clink-args=-fuse-ld=lld\");\n+        }\n+\n         if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler));\n         }"}, {"sha": "98b6be29c073b80d337744658f75f50ad74e2ced", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1355,7 +1355,7 @@ pub struct RustAnalyzer {\n }\n \n impl Step for RustAnalyzer {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1373,11 +1373,17 @@ impl Step for RustAnalyzer {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n+        if target.contains(\"riscv64\") {\n+            // riscv64 currently has an LLVM bug that makes rust-analyzer unable\n+            // to build. See #74813 for details.\n+            return None;\n+        }\n+\n         let src = builder.src.join(\"src/tools/rust-analyzer\");\n         let release_num = builder.release_num(\"rust-analyzer/crates/rust-analyzer\");\n         let name = pkgname(builder, \"rust-analyzer\");\n@@ -1431,7 +1437,7 @@ impl Step for RustAnalyzer {\n         builder.info(&format!(\"Dist rust-analyzer stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple))\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target.triple)))\n     }\n }\n \n@@ -1789,7 +1795,7 @@ impl Step for Extended {\n         tarballs.push(rustc_installer);\n         tarballs.push(cargo_installer);\n         tarballs.extend(rls_installer.clone());\n-        tarballs.push(rust_analyzer_installer.clone());\n+        tarballs.extend(rust_analyzer_installer.clone());\n         tarballs.push(clippy_installer);\n         tarballs.extend(miri_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n@@ -1867,7 +1873,9 @@ impl Step for Extended {\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n-            contents = filter(&contents, \"rust-analyzer\");\n+            if rust_analyzer_installer.is_none() {\n+                contents = filter(&contents, \"rust-analyzer\");\n+            }\n             if miri_installer.is_none() {\n                 contents = filter(&contents, \"miri\");\n             }\n@@ -1914,7 +1922,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            prepare(\"rust-analyzer\");\n+            if rust_analyzer_installer.is_some() {\n+                prepare(\"rust-analyzer\");\n+            }\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -1976,7 +1986,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            prepare(\"rust-analyzer\");\n+            if rust_analyzer_installer.is_some() {\n+                prepare(\"rust-analyzer\");\n+            }\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -2076,23 +2088,25 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            builder.run(\n-                Command::new(&heat)\n-                    .current_dir(&exe)\n-                    .arg(\"dir\")\n-                    .arg(\"rust-analyzer\")\n-                    .args(&heat_flags)\n-                    .arg(\"-cg\")\n-                    .arg(\"RustAnalyzerGroup\")\n-                    .arg(\"-dr\")\n-                    .arg(\"RustAnalyzer\")\n-                    .arg(\"-var\")\n-                    .arg(\"var.RustAnalyzerDir\")\n-                    .arg(\"-out\")\n-                    .arg(exe.join(\"RustAnalyzerGroup.wxs\"))\n-                    .arg(\"-t\")\n-                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n-            );\n+            if rust_analyzer_installer.is_some() {\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"rust-analyzer\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"RustAnalyzerGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"RustAnalyzer\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.RustAnalyzerDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"RustAnalyzerGroup.wxs\"))\n+                        .arg(\"-t\")\n+                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+                );\n+            }\n             builder.run(\n                 Command::new(&heat)\n                     .current_dir(&exe)\n@@ -2186,7 +2200,9 @@ impl Step for Extended {\n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n-                cmd.arg(\"-dRustAnalyzerDir=rust-analyzer\");\n+                if rust_analyzer_installer.is_some() {\n+                    cmd.arg(\"-dRustAnalyzerDir=rust-analyzer\");\n+                }\n                 if miri_installer.is_some() {\n                     cmd.arg(\"-dMiriDir=miri\");\n                 }\n@@ -2206,7 +2222,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n-            candle(\"RustAnalyzerGroup.wxs\".as_ref());\n+            if rust_analyzer_installer.is_some() {\n+                candle(\"RustAnalyzerGroup.wxs\".as_ref());\n+            }\n             if miri_installer.is_some() {\n                 candle(\"MiriGroup.wxs\".as_ref());\n             }\n@@ -2244,7 +2262,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n-            cmd.arg(\"RustAnalyzerGroup.wixobj\");\n+            if rust_analyzer_installer.is_some() {\n+                cmd.arg(\"RustAnalyzerGroup.wixobj\");\n+            }\n             if miri_installer.is_some() {\n                 cmd.arg(\"MiriGroup.wixobj\");\n             }"}, {"sha": "bb5b9296c0aa73e2c5e2b822abf5036ad95834df", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1158,13 +1158,19 @@ impl Step for Compiletest {\n             cmd.arg(\"--quiet\");\n         }\n \n+        let mut llvm_components_passed = false;\n+        let mut copts_passed = false;\n         if builder.config.llvm_enabled() {\n             let llvm_config = builder.ensure(native::Llvm { target: builder.config.build });\n             if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 // Remove trailing newline from llvm-config output.\n-                let llvm_version = llvm_version.trim_end();\n-                cmd.arg(\"--llvm-version\").arg(llvm_version);\n+                cmd.arg(\"--llvm-version\")\n+                    .arg(llvm_version.trim())\n+                    .arg(\"--llvm-components\")\n+                    .arg(llvm_components.trim());\n+                llvm_components_passed = true;\n             }\n             if !builder.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n@@ -1182,15 +1188,13 @@ impl Step for Compiletest {\n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n-                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 cmd.arg(\"--cc\")\n                     .arg(builder.cc(target))\n                     .arg(\"--cxx\")\n                     .arg(builder.cxx(target).unwrap())\n                     .arg(\"--cflags\")\n-                    .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"))\n-                    .arg(\"--llvm-components\")\n-                    .arg(llvm_components.trim());\n+                    .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"));\n+                copts_passed = true;\n                 if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n@@ -1220,15 +1224,11 @@ impl Step for Compiletest {\n             }\n         }\n \n-        if suite != \"run-make-fulldeps\" {\n-            cmd.arg(\"--cc\")\n-                .arg(\"\")\n-                .arg(\"--cxx\")\n-                .arg(\"\")\n-                .arg(\"--cflags\")\n-                .arg(\"\")\n-                .arg(\"--llvm-components\")\n-                .arg(\"\");\n+        if !llvm_components_passed {\n+            cmd.arg(\"--llvm-components\").arg(\"\");\n+        }\n+        if !copts_passed {\n+            cmd.arg(\"--cc\").arg(\"\").arg(\"--cxx\").arg(\"\").arg(\"--cflags\").arg(\"\");\n         }\n \n         if builder.remote_tested(target) {"}, {"sha": "0ff77de003d311eb826279d1e18b334325287c57", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -84,6 +84,9 @@ x--expand-yaml-anchors--remove:\n     os: windows-latest-xl\n     <<: *base-job\n \n+  - &job-aarch64-linux\n+    os: [self-hosted, ARM64, linux]\n+\n   - &step\n     if: success() && !env.SKIP_JOB\n \n@@ -584,8 +587,16 @@ jobs:\n       <<: [*shared-ci-variables, *dummy-variables]\n     if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n     strategy:\n+      fail-fast: false\n       matrix:\n         include:\n+          #############################\n+          #   Linux/Docker builders   #\n+          #############################\n+\n+          - name: aarch64-gnu\n+            <<: *job-aarch64-linux\n+\n           ####################\n           #  macOS Builders  #\n           ####################"}, {"sha": "28d8aa3b6e71a156ec9a58eeb91967d1cfa8eba5", "filename": "src/ci/scripts/symlink-build-dir.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -12,7 +12,7 @@ source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n if isWindows && isAzurePipelines; then\n     cmd //c \"mkdir c:\\\\MORE_SPACE\"\n     cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n-elif isLinux && isGitHubActions; then\n+elif isLinux && isGitHubActions && ! isSelfHostedGitHubActions; then\n     sudo mkdir -p /mnt/more-space\n     sudo chown -R \"$(whoami):\" /mnt/more-space\n "}, {"sha": "8222758ed6dc4e5bf62eec89239bb0415fe657d1", "filename": "src/ci/shared.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -38,6 +38,11 @@ function isGitHubActions {\n     [[ \"${GITHUB_ACTIONS-false}\" = \"true\" ]]\n }\n \n+\n+function isSelfHostedGitHubActions {\n+    [[ \"${RUST_GHA_SELF_HOSTED-false}\" = \"true\" ]]\n+}\n+\n function isMacOS {\n     [[ \"${OSTYPE}\" = \"darwin\"* ]]\n }"}, {"sha": "363293c1c5ce9e84ea3935a5e29ce8624801208a", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1 +1 @@\n-Subproject commit a914f2c7e5cdb771fa465de142381a51c53b580e\n+Subproject commit 363293c1c5ce9e84ea3935a5e29ce8624801208a"}, {"sha": "b5256448a2a4c1bec68b93c0847066f92f2ff5a9", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1 +1 @@\n-Subproject commit 94d9ea8460bcbbbfef1877b47cb930260b5849a7\n+Subproject commit b5256448a2a4c1bec68b93c0847066f92f2ff5a9"}, {"sha": "c9b2736a059469043177e1e4ed41a55d7c63ac28", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1 +1 @@\n-Subproject commit b329ce37424874ad4db94f829a55807c6e21d2cb\n+Subproject commit c9b2736a059469043177e1e4ed41a55d7c63ac28"}, {"sha": "2e9271981adc32613365810f3428334c07095215", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1 +1 @@\n-Subproject commit 229c6945a26a53a751ffa4f9cb418388c00029d3\n+Subproject commit 2e9271981adc32613365810f3428334c07095215"}, {"sha": "809fda865422a8fea4c2bd94ec819fcd50cedc89", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -100,8 +100,8 @@ impl NestedMetaItem {\n     }\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn check_name(&self, name: Symbol) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n     }\n \n     /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n@@ -173,8 +173,13 @@ impl Attribute {\n         }\n     }\n \n-    /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n-    /// attribute is marked as used.\n+    /// Returns `true` if the attribute's path matches the argument.\n+    /// If it matches, then the attribute is marked as used.\n+    /// Should only be used by rustc, other tools can use `has_name` instead,\n+    /// because only rustc is supposed to report the `unused_attributes` lint.\n+    /// `MetaItem` and `NestedMetaItem` are produced by \"lowering\" an `Attribute`\n+    /// and don't have identity, so they only has the `has_name` method,\n+    /// and you need to mark the original `Attribute` as used when necessary.\n     pub fn check_name(&self, name: Symbol) -> bool {\n         let matches = self.has_name(name);\n         if matches {\n@@ -278,7 +283,7 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn check_name(&self, name: Symbol) -> bool {\n+    pub fn has_name(&self, name: Symbol) -> bool {\n         self.path == name\n     }\n \n@@ -405,7 +410,7 @@ pub fn mk_doc_comment(style: AttrStyle, comment: Symbol, span: Span) -> Attribut\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n-    items.iter().any(|item| item.check_name(name))\n+    items.iter().any(|item| item.has_name(name))\n }\n \n pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {"}, {"sha": "e1c94ddf782881d16571fa154727471f1f2159c3", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -673,62 +673,6 @@ impl Token {\n \n         Some(Token::new(kind, self.span.to(joint.span)))\n     }\n-\n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    crate fn probably_equal_for_proc_macro(&self, other: &Token) -> bool {\n-        if mem::discriminant(&self.kind) != mem::discriminant(&other.kind) {\n-            return false;\n-        }\n-        match (&self.kind, &other.kind) {\n-            (&Eq, &Eq)\n-            | (&Lt, &Lt)\n-            | (&Le, &Le)\n-            | (&EqEq, &EqEq)\n-            | (&Ne, &Ne)\n-            | (&Ge, &Ge)\n-            | (&Gt, &Gt)\n-            | (&AndAnd, &AndAnd)\n-            | (&OrOr, &OrOr)\n-            | (&Not, &Not)\n-            | (&Tilde, &Tilde)\n-            | (&At, &At)\n-            | (&Dot, &Dot)\n-            | (&DotDot, &DotDot)\n-            | (&DotDotDot, &DotDotDot)\n-            | (&DotDotEq, &DotDotEq)\n-            | (&Comma, &Comma)\n-            | (&Semi, &Semi)\n-            | (&Colon, &Colon)\n-            | (&ModSep, &ModSep)\n-            | (&RArrow, &RArrow)\n-            | (&LArrow, &LArrow)\n-            | (&FatArrow, &FatArrow)\n-            | (&Pound, &Pound)\n-            | (&Dollar, &Dollar)\n-            | (&Question, &Question)\n-            | (&Whitespace, &Whitespace)\n-            | (&Comment, &Comment)\n-            | (&Eof, &Eof) => true,\n-\n-            (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n-\n-            (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n-\n-            (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n-\n-            (&Literal(a), &Literal(b)) => a == b,\n-\n-            (&Lifetime(a), &Lifetime(b)) => a == b,\n-            (&Ident(a, b), &Ident(c, d)) => {\n-                b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n-            }\n-\n-            (&Interpolated(..), &Interpolated(..)) => false,\n-\n-            _ => panic!(\"forgot to add a token?\"),\n-        }\n-    }\n }\n \n impl PartialEq<TokenKind> for Token {\n@@ -760,6 +704,67 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n+#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum NonterminalKind {\n+    Item,\n+    Block,\n+    Stmt,\n+    Pat,\n+    Expr,\n+    Ty,\n+    Ident,\n+    Lifetime,\n+    Literal,\n+    Meta,\n+    Path,\n+    Vis,\n+    TT,\n+}\n+\n+impl NonterminalKind {\n+    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+        Some(match symbol {\n+            sym::item => NonterminalKind::Item,\n+            sym::block => NonterminalKind::Block,\n+            sym::stmt => NonterminalKind::Stmt,\n+            sym::pat => NonterminalKind::Pat,\n+            sym::expr => NonterminalKind::Expr,\n+            sym::ty => NonterminalKind::Ty,\n+            sym::ident => NonterminalKind::Ident,\n+            sym::lifetime => NonterminalKind::Lifetime,\n+            sym::literal => NonterminalKind::Literal,\n+            sym::meta => NonterminalKind::Meta,\n+            sym::path => NonterminalKind::Path,\n+            sym::vis => NonterminalKind::Vis,\n+            sym::tt => NonterminalKind::TT,\n+            _ => return None,\n+        })\n+    }\n+    fn symbol(self) -> Symbol {\n+        match self {\n+            NonterminalKind::Item => sym::item,\n+            NonterminalKind::Block => sym::block,\n+            NonterminalKind::Stmt => sym::stmt,\n+            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Expr => sym::expr,\n+            NonterminalKind::Ty => sym::ty,\n+            NonterminalKind::Ident => sym::ident,\n+            NonterminalKind::Lifetime => sym::lifetime,\n+            NonterminalKind::Literal => sym::literal,\n+            NonterminalKind::Meta => sym::meta,\n+            NonterminalKind::Path => sym::path,\n+            NonterminalKind::Vis => sym::vis,\n+            NonterminalKind::TT => sym::tt,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NonterminalKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.symbol())\n+    }\n+}\n+\n impl Nonterminal {\n     fn span(&self) -> Span {\n         match self {"}, {"sha": "9d0199078fa6a354eb4ee9f51305aa95fbb4e4fa", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -21,8 +21,6 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n-use log::debug;\n-\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -68,23 +66,6 @@ impl TokenTree {\n         }\n     }\n \n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    //\n-    // This is otherwise the same as `eq_unspanned`, only recursing with a\n-    // different method.\n-    pub fn probably_equal_for_proc_macro(&self, other: &TokenTree) -> bool {\n-        match (self, other) {\n-            (TokenTree::Token(token), TokenTree::Token(token2)) => {\n-                token.probably_equal_for_proc_macro(token2)\n-            }\n-            (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-                delim == delim2 && tts.probably_equal_for_proc_macro(&tts2)\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     /// Retrieves the TokenTree's span.\n     pub fn span(&self) -> Span {\n         match self {\n@@ -307,112 +288,6 @@ impl TokenStream {\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    //\n-    // This is otherwise the same as `eq_unspanned`, only recursing with a\n-    // different method.\n-    pub fn probably_equal_for_proc_macro(&self, other: &TokenStream) -> bool {\n-        // When checking for `probably_eq`, we ignore certain tokens that aren't\n-        // preserved in the AST. Because they are not preserved, the pretty\n-        // printer arbitrarily adds or removes them when printing as token\n-        // streams, making a comparison between a token stream generated from an\n-        // AST and a token stream which was parsed into an AST more reliable.\n-        fn semantic_tree(tree: &TokenTree) -> bool {\n-            if let TokenTree::Token(token) = tree {\n-                if let\n-                    // The pretty printer tends to add trailing commas to\n-                    // everything, and in particular, after struct fields.\n-                    | token::Comma\n-                    // The pretty printer emits `NoDelim` as whitespace.\n-                    | token::OpenDelim(DelimToken::NoDelim)\n-                    | token::CloseDelim(DelimToken::NoDelim)\n-                    // The pretty printer collapses many semicolons into one.\n-                    | token::Semi\n-                    // The pretty printer collapses whitespace arbitrarily and can\n-                    // introduce whitespace from `NoDelim`.\n-                    | token::Whitespace\n-                    // The pretty printer can turn `$crate` into `::crate_name`\n-                    | token::ModSep = token.kind {\n-                    return false;\n-                }\n-            }\n-            true\n-        }\n-\n-        // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n-        //\n-        // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n-        // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n-        // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n-        // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n-        // when determining if two `TokenStream`s are 'probably equal'.\n-        //\n-        // Therefore, we use `break_two_token_op` to convert all tokens\n-        // to the 'unglued' form (if it exists). This ensures that two\n-        // `TokenStream`s which differ only in how their tokens are glued\n-        // will be considered 'probably equal', which allows us to keep spans.\n-        //\n-        // This is important when the original `TokenStream` contained\n-        // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n-        // will be omitted when we pretty-print, which can cause the original\n-        // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n-        // leading to some tokens being 'glued' together in one stream but not\n-        // the other. See #68489 for more details.\n-        fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n-            // In almost all cases, we should have either zero or one levels\n-            // of 'unglueing'. However, in some unusual cases, we may need\n-            // to iterate breaking tokens mutliple times. For example:\n-            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n-            let mut token_trees: SmallVec<[_; 2]>;\n-            if let TokenTree::Token(token) = &tree {\n-                let mut out = SmallVec::<[_; 2]>::new();\n-                out.push(token.clone());\n-                // Iterate to fixpoint:\n-                // * We start off with 'out' containing our initial token, and `temp` empty\n-                // * If we are able to break any tokens in `out`, then `out` will have\n-                //   at least one more element than 'temp', so we will try to break tokens\n-                //   again.\n-                // * If we cannot break any tokens in 'out', we are done\n-                loop {\n-                    let mut temp = SmallVec::<[_; 2]>::new();\n-                    let mut changed = false;\n-\n-                    for token in out.into_iter() {\n-                        if let Some((first, second)) = token.kind.break_two_token_op() {\n-                            temp.push(Token::new(first, DUMMY_SP));\n-                            temp.push(Token::new(second, DUMMY_SP));\n-                            changed = true;\n-                        } else {\n-                            temp.push(token);\n-                        }\n-                    }\n-                    out = temp;\n-                    if !changed {\n-                        break;\n-                    }\n-                }\n-                token_trees = out.into_iter().map(TokenTree::Token).collect();\n-                if token_trees.len() != 1 {\n-                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n-                }\n-            } else {\n-                token_trees = SmallVec::new();\n-                token_trees.push(tree);\n-            }\n-            token_trees.into_iter()\n-        }\n-\n-        let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);\n-        let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n-        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n-            if !t1.probably_equal_for_proc_macro(&t2) {\n-                return false;\n-            }\n-        }\n-        t1.next().is_none() && t2.next().is_none()\n-    }\n-\n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n         TokenStream(Lrc::new(\n             self.0"}, {"sha": "bf7e69a31abcba446d7238ff3e7c310ef7941332", "filename": "src/librustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2FCargo.toml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n-log = { package = \"tracing\", version = \"0.1\" }\n+tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "5414e5842904726f8d5a32746425d56236553789", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -17,9 +17,9 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n \n-use log::debug;\n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n+use tracing::debug;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,"}, {"sha": "9df7ad2a9acf47d22e2c72c948a6b0c4ce4254bd", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -64,10 +64,10 @@ use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use log::{debug, trace};\n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeMap;\n use std::mem;\n+use tracing::{debug, trace};\n \n macro_rules! arena_vec {\n     ($this:expr; $($x:expr),*) => ({"}, {"sha": "171856e7e637181fa2878216b484213d2cfbd999", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -112,7 +112,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n                 // This is not allowed as a sub-tuple pattern\n                 PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n-                    rest = Some((idx, pat.span));\n                     let sp = pat.span;\n                     self.diagnostic()\n                         .struct_span_err(\n@@ -128,7 +127,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n-                    break;\n                 }\n                 _ => {}\n             }"}, {"sha": "2541d6824fec4e66331ca93d7915dc347b3a59c3", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -12,8 +12,8 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-use log::debug;\n use smallvec::smallvec;\n+use tracing::debug;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     crate fn lower_qpath("}, {"sha": "6db9bce3164bb120579594334a151b12f55d220d", "filename": "src/librustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2FCargo.toml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n \n [dependencies]\n itertools = \"0.8\"\n-log = { package = \"tracing\", version = \"0.1\" }\n+tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "22eaca4f071e21748c62d7d25d80e92883fa28ca", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,7 +10,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n+use tracing::debug;\n \n macro_rules! gate_feature_fn {\n     ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n@@ -243,7 +243,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         if attr.check_name(sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n-                    $(if nested_meta.check_name(sym::$name) {\n+                    $(if nested_meta.has_name(sym::$name) {\n                         let msg = concat!(\"`#[doc(\", stringify!($name), \")]` is experimental\");\n                         gate_feature_post!(self, $feature, attr.span, msg);\n                     })*\n@@ -314,7 +314,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ItemKind::Struct(..) => {\n                 for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(sym::simd) {\n+                        if item.has_name(sym::simd) {\n                             gate_feature_post!(\n                                 &self,\n                                 repr_simd,"}, {"sha": "d26205c791dc0f67c70d366de2c43ee301de57c5", "filename": "src/librustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2FCargo.toml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-log = { package = \"tracing\", version = \"0.1\" }\n+tracing = \"0.1\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "ca7f127ced60d4c5111e24ee4ce8b3b2ea7f719b", "filename": "src/librustc_ast_pretty/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_pretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_pretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpp.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -132,10 +132,10 @@\n //! methods called `Printer::scan_*`, and the 'PRINT' process is the\n //! method called `Printer::print`.\n \n-use log::debug;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::fmt;\n+use tracing::debug;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]"}, {"sha": "4b228629ad719e2e2bac4a58687b2a5a00398326", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -450,7 +450,9 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_comment(&mut self, cmnt: &comments::Comment) {\n         match cmnt.style {\n             comments::Mixed => {\n-                self.zerobreak();\n+                if !self.is_beginning_of_line() {\n+                    self.zerobreak();\n+                }\n                 if let Some((last, lines)) = cmnt.lines.split_last() {\n                     self.ibox(0);\n "}, {"sha": "983202aafabd58c4d12e8904d11c458e15af1487", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -92,9 +92,9 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.kind {\n                     if items.len() == 1 {\n-                        if items[0].check_name(sym::allowed) {\n+                        if items[0].has_name(sym::allowed) {\n                             return Some(UnwindAttr::Allowed);\n-                        } else if items[0].check_name(sym::aborts) {\n+                        } else if items[0].has_name(sym::aborts) {\n                             return Some(UnwindAttr::Aborts);\n                         }\n                     }\n@@ -168,7 +168,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool\n         item.check_name(sym::feature)\n             && item\n                 .meta_item_list()\n-                .map(|list| list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name)))\n+                .map(|list| list.iter().any(|mi| mi.is_word() && mi.has_name(feature_name)))\n                 .unwrap_or(false)\n     })\n }\n@@ -505,7 +505,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n }\n \n fn try_gate_cfg(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) {\n-    let gate = find_gated_cfg(|sym| cfg.check_name(sym));\n+    let gate = find_gated_cfg(|sym| cfg.has_name(sym));\n     if let (Some(feats), Some(gated_cfg)) = (features, gate) {\n         gate_cfg(&gated_cfg, cfg.span, sess, feats);\n     }\n@@ -898,7 +898,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.check_name(sym::align) {\n+                        if meta_item.has_name(sym::align) {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n                                 recognised = true;\n                                 let mut err = struct_span_err!("}, {"sha": "87be6d1743a2a4a736f7888d77929eae7ffa1c18", "filename": "src/librustc_builtin_macros/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_builtin_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_builtin_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,7 +5,6 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n-#![feature(inner_deref)]\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]"}, {"sha": "763bdca35ebe61c166aaf0dc70cc0a572c0b76fa", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -143,7 +143,7 @@ impl<'a> CollectProcMacros<'a> {\n \n         let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n-            if !attr.check_name(sym::attributes) {\n+            if !attr.has_name(sym::attributes) {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n             }\n             attr.meta_item_list()"}, {"sha": "de8f81bdadf0e00360eee07931791f022f94d047", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -336,7 +336,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n                 Some(list) => {\n                     let msg = list\n                         .iter()\n-                        .find(|mi| mi.check_name(sym::expected))\n+                        .find(|mi| mi.has_name(sym::expected))\n                         .and_then(|mi| mi.meta_item())\n                         .and_then(|mi| mi.value_str());\n                     if list.len() != 1 || msg.is_none() {"}, {"sha": "1d0b810165a6450a4f01612c4ff2b9cb07c5a3d0", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -703,11 +703,67 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         None\n     }\n \n+    fn fptosui_may_trap(&self, val: &'ll Value, dest_ty: &'ll Type) -> bool {\n+        // Most of the time we'll be generating the `fptosi` or `fptoui`\n+        // instruction for floating-point-to-integer conversions. These\n+        // instructions by definition in LLVM do not trap. For the WebAssembly\n+        // target, however, we'll lower in some cases to intrinsic calls instead\n+        // which may trap. If we detect that this is a situation where we'll be\n+        // using the intrinsics then we report that the call map trap, which\n+        // callers might need to handle.\n+        if !self.wasm_and_missing_nontrapping_fptoint() {\n+            return false;\n+        }\n+        let src_ty = self.cx.val_ty(val);\n+        let float_width = self.cx.float_width(src_ty);\n+        let int_width = self.cx.int_width(dest_ty);\n+        match (int_width, float_width) {\n+            (32, 32) | (32, 64) | (64, 32) | (64, 64) => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        // When we can, use the native wasm intrinsics which have tighter\n+        // codegen. Note that this has a semantic difference in that the\n+        // intrinsic can trap whereas `fptoui` never traps. That difference,\n+        // however, is handled by `fptosui_may_trap` above.\n+        if self.wasm_and_missing_nontrapping_fptoint() {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return self.call(intrinsic, &[val], None);\n+            }\n+        }\n         unsafe { llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        if self.wasm_and_missing_nontrapping_fptoint() {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return self.call(intrinsic, &[val], None);\n+            }\n+        }\n         unsafe { llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n@@ -1349,4 +1405,9 @@ impl Builder<'a, 'll, 'tcx> {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n+\n+    fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n+        self.sess().target.target.arch == \"wasm32\"\n+            && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+    }\n }"}, {"sha": "5d1bfd810b2fea3bcfdd06bd2a8913bb9c5bedb1", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -92,7 +92,7 @@ impl CoverageMapGenerator {\n     fn write_coverage_mappings(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n-        counter_regions: impl Iterator<Item = (Counter, &'a Region)>,\n+        counter_regions: impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>,\n         coverage_mappings_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n@@ -102,7 +102,7 @@ impl CoverageMapGenerator {\n \n         let mut virtual_file_mapping = Vec::new();\n         let mut mapping_regions = Vec::new();\n-        let mut current_file_path = None;\n+        let mut current_file_name = None;\n         let mut current_file_id = 0;\n \n         // Convert the list of (Counter, Region) pairs to an array of `CounterMappingRegion`, sorted\n@@ -112,22 +112,22 @@ impl CoverageMapGenerator {\n         // `filenames` array.\n         counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n-            let (file_path, start_line, start_col, end_line, end_col) = region.file_start_and_end();\n-            let same_file = current_file_path.as_ref().map_or(false, |p| p == file_path);\n+            let Region { file_name, start_line, start_col, end_line, end_col } = *region;\n+            let same_file = current_file_name.as_ref().map_or(false, |p| p == file_name);\n             if !same_file {\n-                if current_file_path.is_some() {\n+                if current_file_name.is_some() {\n                     current_file_id += 1;\n                 }\n-                current_file_path = Some(file_path.clone());\n-                let filename = CString::new(file_path.to_string_lossy().to_string())\n-                    .expect(\"null error converting filename to C string\");\n-                debug!(\"  file_id: {} = '{:?}'\", current_file_id, filename);\n-                let filenames_index = match self.filename_to_index.get(&filename) {\n+                current_file_name = Some(file_name.to_string());\n+                let c_filename =\n+                    CString::new(file_name).expect(\"null error converting filename to C string\");\n+                debug!(\"  file_id: {} = '{:?}'\", current_file_id, c_filename);\n+                let filenames_index = match self.filename_to_index.get(&c_filename) {\n                     Some(index) => *index,\n                     None => {\n                         let index = self.filenames.len() as u32;\n-                        self.filenames.push(filename.clone());\n-                        self.filename_to_index.insert(filename.clone(), index);\n+                        self.filenames.push(c_filename.clone());\n+                        self.filename_to_index.insert(c_filename.clone(), index);\n                         index\n                     }\n                 };"}, {"sha": "4d51f8b059166c6c6e343589216be48463cdd2e2", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,7 +5,7 @@ use crate::common::CodegenCx;\n \n use libc::c_uint;\n use llvm::coverageinfo::CounterMappingRegion;\n-use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage};\n+use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage, Region};\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n };\n@@ -49,19 +49,18 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         id: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     ) {\n         debug!(\n             \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={}, \\\n-             byte range {}..{}\",\n-            instance, function_source_hash, id, start_byte_pos, end_byte_pos,\n+             at {:?}\",\n+            instance, function_source_hash, id, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter(function_source_hash, id, start_byte_pos, end_byte_pos);\n+            .add_counter(function_source_hash, id, region);\n     }\n \n     fn add_counter_expression_region(\n@@ -71,43 +70,30 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         lhs: u32,\n         op: ExprKind,\n         rhs: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     ) {\n         debug!(\n             \"adding counter expression to coverage_regions: instance={:?}, id={}, {} {:?} {}, \\\n-             byte range {}..{}\",\n-            instance, id_descending_from_max, lhs, op, rhs, start_byte_pos, end_byte_pos,\n+             at {:?}\",\n+            instance, id_descending_from_max, lhs, op, rhs, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(\n-                id_descending_from_max,\n-                lhs,\n-                op,\n-                rhs,\n-                start_byte_pos,\n-                end_byte_pos,\n-            );\n+            .add_counter_expression(id_descending_from_max, lhs, op, rhs, region);\n     }\n \n-    fn add_unreachable_region(\n-        &mut self,\n-        instance: Instance<'tcx>,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n-    ) {\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: Region<'tcx>) {\n         debug!(\n-            \"adding unreachable code to coverage_regions: instance={:?}, byte range {}..{}\",\n-            instance, start_byte_pos, end_byte_pos,\n+            \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n+            instance, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_unreachable_region(start_byte_pos, end_byte_pos);\n+            .add_unreachable_region(region);\n     }\n }\n "}, {"sha": "8d6b3f9ccb6bfd6e2cdc676fcfc1c7f15ebf3669", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 76, "deletions": 115, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::coverageinfo::ExprKind;\n+use rustc_codegen_ssa::coverageinfo;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -93,64 +93,64 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let mut is_codegen_intrinsic = true;\n         // Set `is_codegen_intrinsic` to `false` to bypass `codegen_intrinsic_call()`.\n \n-        if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // If the intrinsic is from the local MIR, add the coverage information to the Codegen\n-            // context, to be encoded into the local crate's coverage map.\n-            if caller_instance.def_id().is_local() {\n-                // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n-                // external crate dependencies, where:\n-                //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n-                //   2. Only binary is compiled with `-Zinstrument-coverage`\n-                //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n-                match intrinsic {\n-                    sym::count_code_region => {\n-                        use coverage::count_code_region_args::*;\n-                        self.add_counter_region(\n-                            caller_instance,\n-                            op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                            op_to_u32(&args[COUNTER_ID]),\n-                            op_to_u32(&args[START_BYTE_POS]),\n-                            op_to_u32(&args[END_BYTE_POS]),\n-                        );\n-                    }\n-                    sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                        use coverage::coverage_counter_expression_args::*;\n-                        self.add_counter_expression_region(\n-                            caller_instance,\n-                            op_to_u32(&args[EXPRESSION_ID]),\n-                            op_to_u32(&args[LEFT_ID]),\n-                            if intrinsic == sym::coverage_counter_add {\n-                                ExprKind::Add\n-                            } else {\n-                                ExprKind::Subtract\n-                            },\n-                            op_to_u32(&args[RIGHT_ID]),\n-                            op_to_u32(&args[START_BYTE_POS]),\n-                            op_to_u32(&args[END_BYTE_POS]),\n-                        );\n-                    }\n-                    sym::coverage_unreachable => {\n-                        use coverage::coverage_unreachable_args::*;\n-                        self.add_unreachable_region(\n-                            caller_instance,\n-                            op_to_u32(&args[START_BYTE_POS]),\n-                            op_to_u32(&args[END_BYTE_POS]),\n-                        );\n-                    }\n-                    _ => {}\n-                }\n+        // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n+        // external crate dependencies, where:\n+        //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n+        //   2. Only binary is compiled with `-Zinstrument-coverage`\n+        //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n+        match intrinsic {\n+            sym::count_code_region => {\n+                use coverage::count_code_region_args::*;\n+                self.add_counter_region(\n+                    caller_instance,\n+                    op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                    op_to_u32(&args[COUNTER_ID]),\n+                    coverageinfo::Region::new(\n+                        op_to_str_slice(&args[FILE_NAME]),\n+                        op_to_u32(&args[START_LINE]),\n+                        op_to_u32(&args[START_COL]),\n+                        op_to_u32(&args[END_LINE]),\n+                        op_to_u32(&args[END_COL]),\n+                    ),\n+                );\n             }\n-\n-            // Only the `count_code_region` coverage intrinsic is translated into an actual LLVM\n-            // intrinsic call (local or not); otherwise, set `is_codegen_intrinsic` to `false`.\n-            match intrinsic {\n-                sym::coverage_counter_add\n-                | sym::coverage_counter_subtract\n-                | sym::coverage_unreachable => {\n-                    is_codegen_intrinsic = false;\n-                }\n-                _ => {}\n+            sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                is_codegen_intrinsic = false;\n+                use coverage::coverage_counter_expression_args::*;\n+                self.add_counter_expression_region(\n+                    caller_instance,\n+                    op_to_u32(&args[EXPRESSION_ID]),\n+                    op_to_u32(&args[LEFT_ID]),\n+                    if intrinsic == sym::coverage_counter_add {\n+                        coverageinfo::ExprKind::Add\n+                    } else {\n+                        coverageinfo::ExprKind::Subtract\n+                    },\n+                    op_to_u32(&args[RIGHT_ID]),\n+                    coverageinfo::Region::new(\n+                        op_to_str_slice(&args[FILE_NAME]),\n+                        op_to_u32(&args[START_LINE]),\n+                        op_to_u32(&args[START_COL]),\n+                        op_to_u32(&args[END_LINE]),\n+                        op_to_u32(&args[END_COL]),\n+                    ),\n+                );\n             }\n+            sym::coverage_unreachable => {\n+                is_codegen_intrinsic = false;\n+                use coverage::coverage_unreachable_args::*;\n+                self.add_unreachable_region(\n+                    caller_instance,\n+                    coverageinfo::Region::new(\n+                        op_to_str_slice(&args[FILE_NAME]),\n+                        op_to_u32(&args[START_LINE]),\n+                        op_to_u32(&args[START_COL]),\n+                        op_to_u32(&args[END_LINE]),\n+                        op_to_u32(&args[END_COL]),\n+                    ),\n+                );\n+            }\n+            _ => {}\n         }\n         is_codegen_intrinsic\n     }\n@@ -215,9 +215,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             sym::count_code_region => {\n-                // FIXME(richkadel): The current implementation assumes the MIR for the given\n-                // caller_instance represents a single function. Validate and/or correct if inlining\n-                // and/or monomorphization invalidates these assumptions.\n                 let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(Symbol::intern(mangled_fn.name));\n@@ -634,22 +631,19 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n \n             sym::float_to_int_unchecked => {\n-                let float_width = match float_type_width(arg_tys[0]) {\n-                    Some(width) => width,\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `float_to_int_unchecked` \\\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        tcx.sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `float_to_int_unchecked` \\\n                                   intrinsic: expected basic float type, \\\n                                   found `{}`\",\n-                                arg_tys[0]\n-                            ),\n-                        );\n-                        return;\n-                    }\n-                };\n+                            arg_tys[0]\n+                        ),\n+                    );\n+                    return;\n+                }\n                 let (width, signed) = match int_type_width_signed(ret_ty, self.cx) {\n                     Some(pair) => pair,\n                     None => {\n@@ -666,48 +660,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         return;\n                     }\n                 };\n-\n-                // The LLVM backend can reorder and speculate `fptosi` and\n-                // `fptoui`, so on WebAssembly the codegen for this instruction\n-                // is quite heavyweight. To avoid this heavyweight codegen we\n-                // instead use the raw wasm intrinsics which will lower to one\n-                // instruction in WebAssembly (`iNN.trunc_fMM_{s,u}`). This one\n-                // instruction will trap if the operand is out of bounds, but\n-                // that's ok since this intrinsic is UB if the operands are out\n-                // of bounds, so the behavior can be different on WebAssembly\n-                // than other targets.\n-                //\n-                // Note, however, that when the `nontrapping-fptoint` feature is\n-                // enabled in LLVM then LLVM will lower `fptosi` to\n-                // `iNN.trunc_sat_fMM_{s,u}`, so if that's the case we don't\n-                // bother with intrinsics.\n-                let mut result = None;\n-                if self.sess().target.target.arch == \"wasm32\"\n-                    && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-                {\n-                    let name = match (width, float_width, signed) {\n-                        (32, 32, true) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n-                        (32, 64, true) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n-                        (64, 32, true) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n-                        (64, 64, true) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n-                        (32, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n-                        (32, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n-                        (64, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n-                        (64, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n-                        _ => None,\n-                    };\n-                    if let Some(name) = name {\n-                        let intrinsic = self.get_intrinsic(name);\n-                        result = Some(self.call(intrinsic, &[args[0].immediate()], None));\n-                    }\n+                if signed {\n+                    self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                } else {\n+                    self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n                 }\n-                result.unwrap_or_else(|| {\n-                    if signed {\n-                        self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n-                    } else {\n-                        self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n-                    }\n-                })\n             }\n \n             sym::discriminant_value => {\n@@ -2283,6 +2240,10 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n     }\n }\n \n+fn op_to_str_slice<'tcx>(op: &Operand<'tcx>) -> &'tcx str {\n+    Operand::value_from_const(op).try_to_str_slice().expect(\"Value is &str\")\n+}\n+\n fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n     Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n }"}, {"sha": "7f6841f9daa603f2b70c4f8ef8a1ef5210ce88a4", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 37, "deletions": 147, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -3,12 +3,8 @@ pub use super::ffi::*;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::source_map::{Pos, SourceMap};\n-use rustc_span::{BytePos, FileName, Loc, RealFileName};\n \n-use std::cmp::{Ord, Ordering};\n-use std::fmt;\n-use std::path::PathBuf;\n+use std::cmp::Ord;\n \n rustc_index::newtype_index! {\n     pub struct ExpressionOperandId {\n@@ -38,127 +34,35 @@ rustc_index::newtype_index! {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Region {\n-    start: Loc,\n-    end: Loc,\n-}\n-\n-impl Ord for Region {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        (&self.start.file.name, &self.start.line, &self.start.col, &self.end.line, &self.end.col)\n-            .cmp(&(\n-                &other.start.file.name,\n-                &other.start.line,\n-                &other.start.col,\n-                &other.end.line,\n-                &other.end.col,\n-            ))\n-    }\n-}\n-\n-impl PartialOrd for Region {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl PartialEq for Region {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.start.file.name == other.start.file.name\n-            && self.start.line == other.start.line\n-            && self.start.col == other.start.col\n-            && self.end.line == other.end.line\n-            && self.end.col == other.end.col\n-    }\n-}\n-\n-impl Eq for Region {}\n-\n-impl fmt::Display for Region {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (file_path, start_line, start_col, end_line, end_col) = self.file_start_and_end();\n-        write!(f, \"{:?}:{}:{} - {}:{}\", file_path, start_line, start_col, end_line, end_col)\n-    }\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Region<'tcx> {\n+    pub file_name: &'tcx str,\n+    pub start_line: u32,\n+    pub start_col: u32,\n+    pub end_line: u32,\n+    pub end_col: u32,\n }\n \n-impl Region {\n-    pub fn new(source_map: &SourceMap, start_byte_pos: u32, end_byte_pos: u32) -> Self {\n-        let start = source_map.lookup_char_pos(BytePos::from_u32(start_byte_pos));\n-        let end = source_map.lookup_char_pos(BytePos::from_u32(end_byte_pos));\n-        assert_eq!(\n-            start.file.name, end.file.name,\n-            \"Region start ({} -> {:?}) and end ({} -> {:?}) don't come from the same source file!\",\n-            start_byte_pos, start, end_byte_pos, end\n-        );\n-        Self { start, end }\n-    }\n-\n-    pub fn file_start_and_end<'a>(&'a self) -> (&'a PathBuf, u32, u32, u32, u32) {\n-        let start = &self.start;\n-        let end = &self.end;\n-        match &start.file.name {\n-            FileName::Real(RealFileName::Named(path)) => (\n-                path,\n-                start.line as u32,\n-                start.col.to_u32() + 1,\n-                end.line as u32,\n-                end.col.to_u32() + 1,\n-            ),\n-            _ => {\n-                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n-            }\n-        }\n+impl<'tcx> Region<'tcx> {\n+    pub fn new(\n+        file_name: &'tcx str,\n+        start_line: u32,\n+        start_col: u32,\n+        end_line: u32,\n+        end_col: u32,\n+    ) -> Self {\n+        Self { file_name, start_line, start_col, end_line, end_col }\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub struct ExpressionRegion {\n+pub struct ExpressionRegion<'tcx> {\n     lhs: ExpressionOperandId,\n     op: ExprKind,\n     rhs: ExpressionOperandId,\n-    region: Region,\n+    region: Region<'tcx>,\n }\n \n-// FIXME(richkadel): There seems to be a problem computing the file location in\n-// some cases. I need to investigate this more. When I generate and show coverage\n-// for the example binary in the crates.io crate `json5format`, I had a couple of\n-// notable problems:\n-//\n-//   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n-//      various comments (not corresponding to rustdoc code), indicating a possible\n-//      problem with the byte_pos-to-source-map implementation.\n-//\n-//   2. And (perhaps not related) when I build the aforementioned example binary with:\n-//      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n-//      and then run that binary with\n-//      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n-//      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n-//      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n-//      name, in this case).\n-//\n-//   3. I think that if I eliminate regions within a function, their region_ids,\n-//      referenced in expressions, will be wrong? I think the ids are implied by their\n-//      array position in the final coverage map output (IIRC).\n-//\n-//   4. I suspect a problem (if not the only problem) is the SourceMap is wrong for some\n-//      region start/end byte positions. Just like I couldn't get the function hash at\n-//      intrinsic codegen time for external crate functions, I think the SourceMap I\n-//      have here only applies to the local crate, and I know I have coverages that\n-//      reference external crates.\n-//\n-//          I still don't know if I fixed the hash problem correctly. If external crates\n-//          implement the function, can't I use the coverage counters already compiled\n-//          into those external crates? (Maybe not for generics and/or maybe not for\n-//          macros... not sure. But I need to understand this better.)\n-//\n-// If the byte range conversion is wrong, fix it. But if it\n-// is right, then it is possible for the start and end to be in different files.\n-// Can I do something other than ignore coverages that span multiple files?\n-//\n-// If I can resolve this, remove the \"Option<>\" result type wrapper\n-// `regions_in_file_order()` accordingly.\n-\n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n /// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n /// for a given Function. Counters and counter expressions have non-overlapping `id`s because they\n@@ -171,19 +75,17 @@ pub struct ExpressionRegion {\n /// only whitespace or comments). According to LLVM Code Coverage Mapping documentation, \"A count\n /// for a gap area is only used as the line execution count if there are no other regions on a\n /// line.\"\n-pub struct FunctionCoverage<'a> {\n-    source_map: &'a SourceMap,\n+pub struct FunctionCoverage<'tcx> {\n     source_hash: u64,\n-    counters: IndexVec<CounterValueReference, Option<Region>>,\n-    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion>>,\n-    unreachable_regions: Vec<Region>,\n+    counters: IndexVec<CounterValueReference, Option<Region<'tcx>>>,\n+    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion<'tcx>>>,\n+    unreachable_regions: Vec<Region<'tcx>>,\n }\n \n-impl<'a> FunctionCoverage<'a> {\n-    pub fn new<'tcx: 'a>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+impl<'tcx> FunctionCoverage<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n         let coverageinfo = tcx.coverageinfo(instance.def_id());\n         Self {\n-            source_map: tcx.sess.source_map(),\n             source_hash: 0, // will be set with the first `add_counter()`\n             counters: IndexVec::from_elem_n(None, coverageinfo.num_counters as usize),\n             expressions: IndexVec::from_elem_n(None, coverageinfo.num_expressions as usize),\n@@ -194,20 +96,14 @@ impl<'a> FunctionCoverage<'a> {\n     /// Adds a code region to be counted by an injected counter intrinsic.\n     /// The source_hash (computed during coverage instrumentation) should also be provided, and\n     /// should be the same for all counters in a given function.\n-    pub fn add_counter(\n-        &mut self,\n-        source_hash: u64,\n-        id: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n-    ) {\n+    pub fn add_counter(&mut self, source_hash: u64, id: u32, region: Region<'tcx>) {\n         if self.source_hash == 0 {\n             self.source_hash = source_hash;\n         } else {\n             debug_assert_eq!(source_hash, self.source_hash);\n         }\n         self.counters[CounterValueReference::from(id)]\n-            .replace(Region::new(self.source_map, start_byte_pos, end_byte_pos))\n+            .replace(region)\n             .expect_none(\"add_counter called with duplicate `id`\");\n     }\n \n@@ -231,27 +127,21 @@ impl<'a> FunctionCoverage<'a> {\n         lhs: u32,\n         op: ExprKind,\n         rhs: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     ) {\n         let expression_id = ExpressionOperandId::from(id_descending_from_max);\n         let lhs = ExpressionOperandId::from(lhs);\n         let rhs = ExpressionOperandId::from(rhs);\n \n         let expression_index = self.expression_index(expression_id);\n         self.expressions[expression_index]\n-            .replace(ExpressionRegion {\n-                lhs,\n-                op,\n-                rhs,\n-                region: Region::new(self.source_map, start_byte_pos, end_byte_pos),\n-            })\n+            .replace(ExpressionRegion { lhs, op, rhs, region })\n             .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n     }\n \n     /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\".\n-    pub fn add_unreachable_region(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.unreachable_regions.push(Region::new(self.source_map, start_byte_pos, end_byte_pos));\n+    pub fn add_unreachable_region(&mut self, region: Region<'tcx>) {\n+        self.unreachable_regions.push(region)\n     }\n \n     /// Return the source hash, generated from the HIR node structure, and used to indicate whether\n@@ -264,8 +154,8 @@ impl<'a> FunctionCoverage<'a> {\n     /// associated `Regions` (from which the LLVM-specific `CoverageMapGenerator` will create\n     /// `CounterMappingRegion`s.\n     pub fn get_expressions_and_counter_regions(\n-        &'a self,\n-    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n+        &'tcx self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>) {\n         assert!(self.source_hash != 0);\n \n         let counter_regions = self.counter_regions();\n@@ -277,7 +167,7 @@ impl<'a> FunctionCoverage<'a> {\n         (counter_expressions, counter_regions)\n     }\n \n-    fn counter_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+    fn counter_regions(&'tcx self) -> impl Iterator<Item = (Counter, &'tcx Region<'tcx>)> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n@@ -288,8 +178,8 @@ impl<'a> FunctionCoverage<'a> {\n     }\n \n     fn expressions_with_regions(\n-        &'a self,\n-    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n+        &'tcx self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>) {\n         let mut counter_expressions = Vec::with_capacity(self.expressions.len());\n         let mut expression_regions = Vec::with_capacity(self.expressions.len());\n         let mut new_indexes =\n@@ -350,7 +240,7 @@ impl<'a> FunctionCoverage<'a> {\n         (counter_expressions, expression_regions.into_iter())\n     }\n \n-    fn unreachable_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+    fn unreachable_regions(&'tcx self) -> impl Iterator<Item = (Counter, &'tcx Region<'tcx>)> {\n         self.unreachable_regions.iter().map(|region| (Counter::zero(), region))\n     }\n "}, {"sha": "ff794a75c360d97756530437ce29823313ab8a55", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,3 +2,4 @@ pub mod ffi;\n pub mod map;\n \n pub use map::ExprKind;\n+pub use map::Region;"}, {"sha": "77e94fe3d0adc150d311e798a8da022a6d2268b1", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 134, "deletions": 33, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -11,7 +11,7 @@ use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_hir::lang_items::ExchangeMallocFnLangItem;\n use rustc_middle::mir;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n-use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::sym;\n@@ -369,10 +369,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out)\n+                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out, cast)\n                             }\n                             (CastTy::Float, CastTy::Int(_)) => {\n-                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out)\n+                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out, cast)\n                             }\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty),\n                         };\n@@ -772,6 +772,7 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     x: Bx::Value,\n     float_ty: Bx::Type,\n     int_ty: Bx::Type,\n+    int_layout: TyAndLayout<'tcx>,\n ) -> Bx::Value {\n     if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n         return if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n@@ -782,8 +783,6 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         return try_sat_result;\n     }\n \n-    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-\n     let int_width = bx.cx().int_width(int_ty);\n     let float_width = bx.cx().float_width(float_ty);\n     // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n@@ -870,36 +869,138 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n     // QED.\n \n-    // Step 1 was already performed above.\n-\n-    // Step 2: We use two comparisons and two selects, with %s1 being the result:\n-    //     %less_or_nan = fcmp ult %x, %f_min\n-    //     %greater = fcmp olt %x, %f_max\n-    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-    //     %s1 = select %greater, int_ty::MAX, %s0\n-    // Note that %less_or_nan uses an *unordered* comparison. This comparison is true if the\n-    // operands are not comparable (i.e., if x is NaN). The unordered comparison ensures that s1\n-    // becomes int_ty::MIN if x is NaN.\n-    // Performance note: Unordered comparison can be lowered to a \"flipped\" comparison and a\n-    // negation, and the negation can be merged into the select. Therefore, it not necessarily any\n-    // more expensive than a ordered (\"normal\") comparison. Whether these optimizations will be\n-    // performed is ultimately up to the backend, but at least x86 does perform them.\n-    let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n-    let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n     let int_max = bx.cx().const_uint_big(int_ty, int_max(signed, int_width));\n     let int_min = bx.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n-    let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n-    let s1 = bx.select(greater, int_max, s0);\n-\n-    // Step 3: NaN replacement.\n-    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-    // Therefore we only need to execute this step for signed integer types.\n-    if signed {\n-        // LLVM has no isNaN predicate, so we use (x == x) instead\n-        let zero = bx.cx().const_uint(int_ty, 0);\n-        let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n-        bx.select(cmp, s1, zero)\n+    let zero = bx.cx().const_uint(int_ty, 0);\n+\n+    // The codegen here differs quite a bit depending on whether our builder's\n+    // `fptosi` and `fptoui` instructions may trap for out-of-bounds values. If\n+    // they don't trap then we can start doing everything inline with a\n+    // `select` instruction because it's ok to execute `fptosi` and `fptoui`\n+    // even if we don't use the results.\n+    if !bx.fptosui_may_trap(x, int_ty) {\n+        // Step 1 ...\n+        let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n+        let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n+        let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %x, %f_min\n+        //     %greater = fcmp olt %x, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if x is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // x is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than a\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = bx.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (x == x) instead\n+            let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n+            bx.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n     } else {\n-        s1\n+        // In this case we cannot execute `fptosi` or `fptoui` and then later\n+        // discard the result. The builder is telling us that these instructions\n+        // will trap on out-of-bounds values, so we need to use basic blocks and\n+        // control flow to avoid executing the `fptosi` and `fptoui`\n+        // instructions.\n+        //\n+        // The general idea of what we're constructing here is, for f64 -> i32:\n+        //\n+        //      ;; block so far... %0 is the argument\n+        //      %result = alloca i32, align 4\n+        //      %inbound_lower = fcmp oge double %0, 0xC1E0000000000000\n+        //      %inbound_upper = fcmp ole double %0, 0x41DFFFFFFFC00000\n+        //      ;; match (inbound_lower, inbound_upper) {\n+        //      ;;     (true, true) => %0 can be converted without trapping\n+        //      ;;     (false, false) => %0 is a NaN\n+        //      ;;     (true, false) => %0 is too large\n+        //      ;;     (false, true) => %0 is too small\n+        //      ;; }\n+        //      ;;\n+        //      ;; The (true, true) check, go to %convert if so.\n+        //      %inbounds = and i1 %inbound_lower, %inbound_upper\n+        //      br i1 %inbounds, label %convert, label %specialcase\n+        //\n+        //  convert:\n+        //      %cvt = call i32 @llvm.wasm.trunc.signed.i32.f64(double %0)\n+        //      store i32 %cvt, i32* %result, align 4\n+        //      br label %done\n+        //\n+        //  specialcase:\n+        //      ;; Handle the cases where the number is NaN, too large or too small\n+        //\n+        //      ;; Either (true, false) or (false, true)\n+        //      %is_not_nan = or i1 %inbound_lower, %inbound_upper\n+        //      ;; Figure out which saturated value we are interested in if not `NaN`\n+        //      %saturated = select i1 %inbound_lower, i32 2147483647, i32 -2147483648\n+        //      ;; Figure out between saturated and NaN representations\n+        //      %result_nan = select i1 %is_not_nan, i32 %saturated, i32 0\n+        //      store i32 %result_nan, i32* %result, align 4\n+        //      br label %done\n+        //\n+        //  done:\n+        //      %r = load i32, i32* %result, align 4\n+        //      ;; ...\n+        let done = bx.build_sibling_block(\"float_cast_done\");\n+        let mut convert = bx.build_sibling_block(\"float_cast_convert\");\n+        let mut specialcase = bx.build_sibling_block(\"float_cast_specialcase\");\n+\n+        let result = PlaceRef::alloca(bx, int_layout);\n+        result.storage_live(bx);\n+\n+        // Use control flow to figure out whether we can execute `fptosi` in a\n+        // basic block, or whether we go to a different basic block to implement\n+        // the saturating logic.\n+        let inbound_lower = bx.fcmp(RealPredicate::RealOGE, x, f_min);\n+        let inbound_upper = bx.fcmp(RealPredicate::RealOLE, x, f_max);\n+        let inbounds = bx.and(inbound_lower, inbound_upper);\n+        bx.cond_br(inbounds, convert.llbb(), specialcase.llbb());\n+\n+        // Translation of the `convert` basic block\n+        let cvt = if signed { convert.fptosi(x, int_ty) } else { convert.fptoui(x, int_ty) };\n+        convert.store(cvt, result.llval, result.align);\n+        convert.br(done.llbb());\n+\n+        // Translation of the `specialcase` basic block. Note that like above\n+        // we try to be a bit clever here for unsigned conversions. In those\n+        // cases the `int_min` is zero so we don't need two select instructions,\n+        // just one to choose whether we need `int_max` or not. If\n+        // `inbound_lower` is true then we're guaranteed to not be `NaN` and\n+        // since we're greater than zero we must be saturating to `int_max`. If\n+        // `inbound_lower` is false then we're either NaN or less than zero, so\n+        // we saturate to zero.\n+        let result_nan = if signed {\n+            let is_not_nan = specialcase.or(inbound_lower, inbound_upper);\n+            let saturated = specialcase.select(inbound_lower, int_max, int_min);\n+            specialcase.select(is_not_nan, saturated, zero)\n+        } else {\n+            specialcase.select(inbound_lower, int_max, int_min)\n+        };\n+        specialcase.store(result_nan, result.llval, result.align);\n+        specialcase.br(done.llbb());\n+\n+        // Translation of the `done` basic block, positioning ourselves to\n+        // continue from that point as well.\n+        *bx = done;\n+        let ret = bx.load(result.llval, result.align);\n+        result.storage_dead(bx);\n+        ret\n     }\n }"}, {"sha": "4e11ef5fd6e829cf8d3e90b227b9aceb14d18a9f", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -160,6 +160,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n     fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n+    fn fptosui_may_trap(&self, val: Self::Value, dest_ty: Self::Type) -> bool;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;"}, {"sha": "2b5878f46bc43bfc7540b45468f6657e5c7e07ee", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use crate::coverageinfo::ExprKind;\n+use crate::coverageinfo::{ExprKind, Region};\n use rustc_middle::ty::Instance;\n \n pub trait CoverageInfoMethods: BackendTypes {\n@@ -12,8 +12,7 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         index: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     );\n \n     fn add_counter_expression_region(\n@@ -23,14 +22,8 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         lhs: u32,\n         op: ExprKind,\n         rhs: u32,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n+        region: Region<'tcx>,\n     );\n \n-    fn add_unreachable_region(\n-        &mut self,\n-        instance: Instance<'tcx>,\n-        start_byte_pos: u32,\n-        end_byte_pos: u32,\n-    );\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: Region<'tcx>);\n }"}, {"sha": "051b75148e5095df27ca39b1dd4f96b345e9b120", "filename": "src/librustc_error_codes/error_codes/E0733.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,6 @@\n-Recursion in an `async fn` requires boxing. For example, this will not compile:\n+An [`async`] function used recursion without boxing.\n+\n+Erroneous code example:\n \n ```edition2018,compile_fail,E0733\n async fn foo(n: usize) {\n@@ -8,8 +10,8 @@ async fn foo(n: usize) {\n }\n ```\n \n-To achieve async recursion, the `async fn` needs to be desugared\n-such that the `Future` is explicit in the return type:\n+To perform async recursion, the `async fn` needs to be desugared such that the\n+`Future` is explicit in the return type:\n \n ```edition2018,compile_fail,E0720\n use std::future::Future;\n@@ -36,5 +38,7 @@ fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n }\n ```\n \n-The `Box<...>` ensures that the result is of known size,\n-and the pin is required to keep it in the same place in memory.\n+The `Box<...>` ensures that the result is of known size, and the pin is\n+required to keep it in the same place in memory.\n+\n+[`async`]: https://doc.rust-lang.org/std/keyword.async.html"}, {"sha": "14cff3613e02394acfe42a93b269013e6cf82f4b", "filename": "src/librustc_error_codes/error_codes/E0744.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,7 +1,6 @@\n-Control-flow expressions are not allowed inside a const context.\n+A control-flow expression was used inside a const context.\n \n-At the moment, `if` and `match`, as well as the looping constructs `for`,\n-`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+Erroneous code example:\n \n ```compile_fail,E0744\n const _: i32 = {\n@@ -13,6 +12,9 @@ const _: i32 = {\n };\n ```\n \n+At the moment, `if` and `match`, as well as the looping constructs `for`,\n+`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+\n This will be allowed at some point in the future, but the implementation is not\n yet complete. See the tracking issue for [conditionals] or [loops] in a const\n context for the current status."}, {"sha": "23ee7af30f418b9e8a940173281cd00772c622b6", "filename": "src/librustc_error_codes/error_codes/E0745.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,20 +1,23 @@\n-Cannot take address of temporary value.\n+The address of temporary value was taken.\n \n Erroneous code example:\n \n ```compile_fail,E0745\n # #![feature(raw_ref_op)]\n fn temp_address() {\n-    let ptr = &raw const 2;   // ERROR\n+    let ptr = &raw const 2; // error!\n }\n ```\n \n-To avoid the error, first bind the temporary to a named local variable.\n+In this example, `2` is destroyed right after the assignment, which means that\n+`ptr` now points to an unavailable location.\n+\n+To avoid this error, first bind the temporary to a named local variable:\n \n ```\n # #![feature(raw_ref_op)]\n fn temp_address() {\n     let val = 2;\n-    let ptr = &raw const val;\n+    let ptr = &raw const val; // ok!\n }\n ```"}, {"sha": "cca8b47c78122a2cd319123e73e607b16c0bbb3d", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -362,7 +362,7 @@ pub trait Emitter {\n                         format!(\n                             \"in this expansion of `{}`{}\",\n                             trace.kind.descr(),\n-                            if macro_backtrace.len() > 2 {\n+                            if macro_backtrace.len() > 1 {\n                                 // if macro_backtrace.len() == 1 it'll be\n                                 // pointed at by \"in this macro invocation\"\n                                 format!(\" (#{})\", i + 1)\n@@ -393,7 +393,7 @@ pub trait Emitter {\n                         trace.call_site,\n                         format!(\n                             \"in this macro invocation{}\",\n-                            if macro_backtrace.len() > 2 && always_backtrace {\n+                            if macro_backtrace.len() > 1 && always_backtrace {\n                                 // only specify order when the macro\n                                 // backtrace is multiple levels deep\n                                 format!(\" (#{})\", i + 1)"}, {"sha": "0cc340c205ac8db7daf5073f33b87712a7174f96", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1644,14 +1644,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         if let Some(list) = at.meta_item_list() {\n-            if !list.iter().any(|it| it.check_name(sym::include)) {\n+            if !list.iter().any(|it| it.has_name(sym::include)) {\n                 return noop_visit_attribute(at, self);\n             }\n \n             let mut items = vec![];\n \n             for mut it in list {\n-                if !it.check_name(sym::include) {\n+                if !it.has_name(sym::include) {\n                     items.push({\n                         noop_visit_meta_list_item(&mut it, self);\n                         it"}, {"sha": "6f2daaa81c02f5a6b1bd9669539afbce2d7edb83", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -9,7 +9,7 @@ crate mod macro_rules;\n crate mod quoted;\n crate mod transcribe;\n \n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, NonterminalKind, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n \n use rustc_span::symbol::Ident;\n@@ -84,7 +84,7 @@ enum TokenTree {\n     /// e.g., `$var`\n     MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(Span, Ident /* name to bind */, Ident /* kind of nonterminal */),\n+    MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n }\n \n impl TokenTree {"}, {"sha": "d2fe7fe10a8301b1cd24cdbe4d23a78b2690f04b", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 189, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -76,15 +76,11 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_ast_pretty::pprust;\n-use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n+use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n \n-use rustc_errors::PResult;\n-use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -382,7 +378,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n-            TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+            TokenTree::MetaVarDecl(span, _, None) => {\n                 if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n@@ -565,18 +561,18 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n-                TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+                TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }\n \n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(_, _, id) => {\n+                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(token, id.name) {\n+                    if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -706,7 +702,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, name) => format!(\"{} ('{}')\", name, bind),\n+                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n                     _ => panic!(),\n                 })\n                 .collect::<Vec<String>>()\n@@ -736,10 +732,17 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n+            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                let nt = match parse_nt(parser.to_mut(), span, ident.name) {\n-                    Err(()) => return ErrorReported,\n+                let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                    Err(mut err) => {\n+                        err.span_label(\n+                            span,\n+                            format!(\"while parsing argument for this `{}` macro fragment\", kind),\n+                        )\n+                        .emit();\n+                        return ErrorReported;\n+                    }\n                     Ok(nt) => nt,\n                 };\n                 item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n@@ -754,178 +757,3 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n         assert!(!cur_items.is_empty());\n     }\n }\n-\n-/// The token is an identifier, but not `_`.\n-/// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n-    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n-}\n-\n-/// Checks whether a non-terminal may begin with a particular token.\n-///\n-/// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n-/// token. Be conservative (return true) if not sure.\n-fn may_begin_with(token: &Token, name: Symbol) -> bool {\n-    /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n-    fn may_be_ident(nt: &token::Nonterminal) -> bool {\n-        match *nt {\n-            token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => false,\n-            _ => true,\n-        }\n-    }\n-\n-    match name {\n-        sym::expr => {\n-            token.can_begin_expr()\n-            // This exception is here for backwards compatibility.\n-            && !token.is_keyword(kw::Let)\n-        }\n-        sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_ident(token).is_some(),\n-        sym::literal => token.can_begin_literal_maybe_minus(),\n-        sym::vis => match token.kind {\n-            // The follow-set of :vis + \"priv\" keyword + interpolated\n-            token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n-            _ => token.can_begin_type(),\n-        },\n-        sym::block => match token.kind {\n-            token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtItem(_)\n-                | token::NtPat(_)\n-                | token::NtTy(_)\n-                | token::NtIdent(..)\n-                | token::NtMeta(_)\n-                | token::NtPath(_)\n-                | token::NtVis(_) => false, // none of these may start with '{'.\n-                _ => true,\n-            },\n-            _ => false,\n-        },\n-        sym::path | sym::meta => match token.kind {\n-            token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPath(_) | token::NtMeta(_) => true,\n-                _ => may_be_ident(&nt),\n-            },\n-            _ => false,\n-        },\n-        sym::pat => match token.kind {\n-            token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n-            token::OpenDelim(token::Paren) |    // tuple pattern\n-            token::OpenDelim(token::Bracket) |  // slice pattern\n-            token::BinOp(token::And) |          // reference\n-            token::BinOp(token::Minus) |        // negative literal\n-            token::AndAnd |                     // double reference\n-            token::Literal(..) |                // literal\n-            token::DotDot |                     // range pattern (future compat)\n-            token::DotDotDot |                  // range pattern (future compat)\n-            token::ModSep |                     // path\n-            token::Lt |                         // path (UFCS constant)\n-            token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt) => may_be_ident(nt),\n-            _ => false,\n-        },\n-        sym::lifetime => match token.kind {\n-            token::Lifetime(_) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtLifetime(_) | token::NtTT(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => match token.kind {\n-            token::CloseDelim(_) => false,\n-            _ => true,\n-        },\n-    }\n-}\n-\n-/// A call to the \"black-box\" parser to parse some Rust non-terminal.\n-///\n-/// # Parameters\n-///\n-/// - `p`: the \"black-box\" parser to use\n-/// - `sp`: the `Span` we want to parse\n-/// - `name`: the name of the metavar _matcher_ we want to match (e.g., `tt`, `ident`, `block`,\n-///   etc...)\n-///\n-/// # Returns\n-///\n-/// The parsed non-terminal.\n-fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, ()> {\n-    // FIXME(Centril): Consider moving this to `parser.rs` to make\n-    // the visibilities of the methods used below `pub(super)` at most.\n-    if name == sym::tt {\n-        return Ok(token::NtTT(p.parse_token_tree()));\n-    }\n-    parse_nt_inner(p, sp, name).map_err(|mut err| {\n-        err.span_label(sp, format!(\"while parsing argument for this `{}` macro fragment\", name))\n-            .emit()\n-    })\n-}\n-\n-fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {\n-    // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n-    // needs to have them force-captured here.\n-    // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n-    // which requires having captured tokens available. Since we cannot determine\n-    // in advance whether or not a proc-macro will be (transitively) invoked,\n-    // we always capture tokens for any `Nonterminal` which needs them.\n-    Ok(match name {\n-        sym::item => match p.collect_tokens(|this| this.parse_item())? {\n-            (Some(mut item), tokens) => {\n-                // If we captured tokens during parsing (due to outer attributes),\n-                // use those.\n-                if item.tokens.is_none() {\n-                    item.tokens = Some(tokens);\n-                }\n-                token::NtItem(item)\n-            }\n-            (None, _) => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n-        },\n-        sym::block => token::NtBlock(p.parse_block()?),\n-        sym::stmt => match p.parse_stmt()? {\n-            Some(s) => token::NtStmt(s),\n-            None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n-        },\n-        sym::pat => token::NtPat(p.parse_pat(None)?),\n-        sym::expr => {\n-            let (mut expr, tokens) = p.collect_tokens(|this| this.parse_expr())?;\n-            // If we captured tokens during parsing (due to outer attributes),\n-            // use those.\n-            if expr.tokens.is_none() {\n-                expr.tokens = Some(tokens);\n-            }\n-            token::NtExpr(expr)\n-        }\n-        sym::literal => token::NtLiteral(p.parse_literal_maybe_minus()?),\n-        sym::ty => token::NtTy(p.parse_ty()?),\n-        // this could be handled like a token, since it is one\n-        sym::ident => {\n-            if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n-                p.bump();\n-                token::NtIdent(ident, is_raw)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected ident, found {}\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n-        sym::meta => token::NtMeta(P(p.parse_attr_item()?)),\n-        sym::vis => token::NtVis(p.parse_visibility(FollowedByType::Yes)?),\n-        sym::lifetime => {\n-            if p.check_lifetime() {\n-                token::NtLifetime(p.expect_lifetime().ident)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        // this is not supposed to happen, since it has been checked\n-        // when compiling the macro.\n-        _ => p.span_bug(sp, \"invalid fragment specifier\"),\n-    })\n-}"}, {"sha": "74d4023b41075b52e4872b2518ac4f5be8c6c8ec", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 43, "deletions": 132, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -9,7 +9,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, NtTT, Token, TokenKind::*};\n+use rustc_ast::token::{self, NonterminalKind, NtTT, Token, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n@@ -21,18 +21,14 @@ use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use log::debug;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n-const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n-                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n-                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n-\n crate struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -403,7 +399,7 @@ pub fn compile_declarative_macro(\n     let diag = &sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n-    let tt_spec = Ident::new(sym::tt, def.span);\n+    let tt_spec = Some(NonterminalKind::TT);\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n@@ -571,7 +567,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none()\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n+                        TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n@@ -890,21 +886,7 @@ fn check_matcher_core(\n         // of NT tokens that might end the sequence `... token`.\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n-                let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n-                    let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n-                    sess.span_diagnostic\n-                        .struct_span_err(token.span(), &msg)\n-                        .help(VALID_FRAGMENT_NAMES_MSG)\n-                        .emit();\n-                    // (This eliminates false positives and duplicates\n-                    // from error messages.)\n-                    can_be_followed_by_any = true;\n-                } else {\n-                    can_be_followed_by_any = token_can_be_followed_by_any(token);\n-                }\n-\n-                if can_be_followed_by_any {\n+                if token_can_be_followed_by_any(token) {\n                     // don't need to track tokens that work with any,\n                     last.replace_with_irrelevant();\n                     // ... and don't need to check tokens that can be\n@@ -967,19 +949,10 @@ fn check_matcher_core(\n \n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n-        'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n+        for token in &last.tokens {\n+            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, frag_spec.name) {\n-                        IsInFollow::Invalid(msg, help) => {\n-                            sess.span_diagnostic\n-                                .struct_span_err(next_token.span(), &msg)\n-                                .help(help)\n-                                .emit();\n-                            // don't bother reporting every source of\n-                            // conflict for a particular element of `last`.\n-                            continue 'each_last;\n-                        }\n+                    match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n                         IsInFollow::No(possible) => {\n                             let may_be = if last.tokens.len() == 1 && suffix_first.tokens.len() == 1\n@@ -996,22 +969,19 @@ fn check_matcher_core(\n                                     \"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n                                      is not allowed for `{frag}` fragments\",\n                                     name = name,\n-                                    frag = frag_spec,\n+                                    frag = kind,\n                                     next = quoted_tt_to_string(next_token),\n                                     may_be = may_be\n                                 ),\n                             );\n-                            err.span_label(\n-                                sp,\n-                                format!(\"not allowed after `{}` fragments\", frag_spec),\n-                            );\n+                            err.span_label(sp, format!(\"not allowed after `{}` fragments\", kind));\n                             let msg = \"allowed there are: \";\n                             match possible {\n                                 &[] => {}\n                                 &[t] => {\n                                     err.note(&format!(\n                                         \"only {} is allowed after `{}` fragments\",\n-                                        t, frag_spec,\n+                                        t, kind,\n                                     ));\n                                 }\n                                 ts => {\n@@ -1038,8 +1008,8 @@ fn check_matcher_core(\n }\n \n fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n-    if let mbe::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(frag_spec.name)\n+    if let mbe::TokenTree::MetaVarDecl(_, _, Some(kind)) = *tok {\n+        frag_can_be_followed_by_any(kind)\n     } else {\n         // (Non NT's can always be followed by anything in matchers.)\n         true\n@@ -1054,26 +1024,23 @@ fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n-    match frag {\n-        sym::item     | // always terminated by `}` or `;`\n-        sym::block    | // exactly one token tree\n-        sym::ident    | // exactly one token tree\n-        sym::literal  | // exactly one token tree\n-        sym::meta     | // exactly one token tree\n-        sym::lifetime | // exactly one token tree\n-        sym::tt =>   // exactly one token tree\n-            true,\n-\n-        _ =>\n-            false,\n+fn frag_can_be_followed_by_any(kind: NonterminalKind) -> bool {\n+    match kind {\n+        NonterminalKind::Item           // always terminated by `}` or `;`\n+        | NonterminalKind::Block        // exactly one token tree\n+        | NonterminalKind::Ident        // exactly one token tree\n+        | NonterminalKind::Literal      // exactly one token tree\n+        | NonterminalKind::Meta         // exactly one token tree\n+        | NonterminalKind::Lifetime     // exactly one token tree\n+        | NonterminalKind::TT => true,  // exactly one token tree\n+\n+        _ => false,\n     }\n }\n \n enum IsInFollow {\n     Yes,\n     No(&'static [&'static str]),\n-    Invalid(String, &'static str),\n }\n \n /// Returns `true` if `frag` can legally be followed by the token `tok`. For\n@@ -1084,26 +1051,26 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n+fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n     use mbe::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n         // closing a token tree can never be matched by any fragment;\n         // iow, we always require that `(` and `)` match, etc.\n         IsInFollow::Yes\n     } else {\n-        match frag {\n-            sym::item => {\n+        match kind {\n+            NonterminalKind::Item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            sym::block => {\n+            NonterminalKind::Block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            sym::stmt | sym::expr => {\n+            NonterminalKind::Stmt | NonterminalKind::Expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1113,7 +1080,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::pat => {\n+            NonterminalKind::Pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1124,7 +1091,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::path | sym::ty => {\n+            NonterminalKind::Path | NonterminalKind::Ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1146,26 +1113,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                         }\n                         _ => IsInFollow::No(TOKENS),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block => {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Block)) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::ident | sym::lifetime => {\n+            NonterminalKind::Ident | NonterminalKind::Lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            sym::literal => {\n+            NonterminalKind::Literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            sym::meta | sym::tt => {\n+            NonterminalKind::Meta | NonterminalKind::TT => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            sym::vis => {\n+            NonterminalKind::Vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1180,78 +1145,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                             }\n                         }\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag)\n-                        if frag.name == sym::ident\n-                            || frag.name == sym::ty\n-                            || frag.name == sym::path =>\n-                    {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(\n+                        _,\n+                        _,\n+                        Some(NonterminalKind::Ident | NonterminalKind::Ty | NonterminalKind::Path),\n+                    ) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            kw::Invalid => IsInFollow::Yes,\n-            _ => IsInFollow::Invalid(\n-                format!(\"invalid fragment specifier `{}`\", frag),\n-                VALID_FRAGMENT_NAMES_MSG,\n-            ),\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(\n-    sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    tok: &mbe::TokenTree,\n-) -> Result<(), String> {\n-    debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let mbe::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n-        let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, attrs, frag_spec.name, frag_span) {\n-            return Err(frag_spec.to_string());\n-        }\n-    }\n-    Ok(())\n-}\n-\n-fn is_legal_fragment_specifier(\n-    _sess: &ParseSess,\n-    _features: &Features,\n-    _attrs: &[ast::Attribute],\n-    frag_name: Symbol,\n-    _frag_span: Span,\n-) -> bool {\n-    /*\n-     * If new fragment specifiers are invented in nightly, `_sess`,\n-     * `_features`, `_attrs`, and `_frag_span` will be useful here\n-     * for checking against feature gates. See past versions of\n-     * this function.\n-     */\n-    match frag_name {\n-        sym::item\n-        | sym::block\n-        | sym::stmt\n-        | sym::expr\n-        | sym::pat\n-        | sym::lifetime\n-        | sym::path\n-        | sym::ty\n-        | sym::ident\n-        | sym::meta\n-        | sym::tt\n-        | sym::vis\n-        | sym::literal\n-        | kw::Invalid => true,\n-        _ => false,\n-    }\n-}\n-\n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     match *tt {\n         mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n-        mbe::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),\n         _ => panic!(\n             \"unexpected mbe::TokenTree::{{Sequence or Delimited}} \\\n              in follow set checker\""}, {"sha": "774cc84afdeb11df0f8fb7c7c1b3d73d9dcaa057", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -12,6 +12,10 @@ use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n \n+const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n+                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n+                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n+\n /// Takes a `tokenstream::TokenStream` and returns a `Vec<self::TokenTree>`. Specifically, this\n /// takes a generic `TokenStream`, such as is used in the rest of the compiler, and returns a\n /// collection of `TokenTree` for use in parsing a macro.\n@@ -55,9 +59,21 @@ pub(super) fn parse(\n                     Some(tokenstream::TokenTree::Token(Token { kind: token::Colon, span })) => {\n                         match trees.next() {\n                             Some(tokenstream::TokenTree::Token(token)) => match token.ident() {\n-                                Some((kind, _)) => {\n+                                Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n-                                    result.push(TokenTree::MetaVarDecl(span, ident, kind));\n+                                    let kind = token::NonterminalKind::from_symbol(frag.name)\n+                                        .unwrap_or_else(|| {\n+                                            let msg = format!(\n+                                                \"invalid fragment specifier `{}`\",\n+                                                frag.name\n+                                            );\n+                                            sess.span_diagnostic\n+                                                .struct_span_err(span, &msg)\n+                                                .help(VALID_FRAGMENT_NAMES_MSG)\n+                                                .emit();\n+                                            token::NonterminalKind::Ident\n+                                        });\n+                                    result.push(TokenTree::MetaVarDecl(span, ident, Some(kind)));\n                                     continue;\n                                 }\n                                 _ => token.span,\n@@ -71,7 +87,7 @@ pub(super) fn parse(\n                     // Macros loaded from other crates have dummy node ids.\n                     sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n                 }\n-                result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n+                result.push(TokenTree::MetaVarDecl(span, ident, None));\n             }\n \n             // Not a metavar or no matchers allowed, so just return the tree"}, {"sha": "d451d9a22a48b359cf2ace4005e5f26e7551439b", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -149,7 +149,7 @@ impl AssertModuleSource<'tcx> {\n \n     fn field(&self, attr: &ast::Attribute, name: Symbol) -> Symbol {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.check_name(name) {\n+            if item.has_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;\n                 } else {"}, {"sha": "02f37f82352a9b762ef180a2e19b3158281b860a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -231,7 +231,7 @@ impl DirtyCleanVisitor<'tcx> {\n \n     fn labels(&self, attr: &Attribute) -> Option<Labels> {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.check_name(LABEL) {\n+            if item.has_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return Some(self.resolve_labels(&item, value));\n             }\n@@ -242,7 +242,7 @@ impl DirtyCleanVisitor<'tcx> {\n     /// `except=` attribute value\n     fn except(&self, attr: &Attribute) -> Labels {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.check_name(EXCEPT) {\n+            if item.has_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n             }\n@@ -474,15 +474,15 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     debug!(\"check_config: config={:?}\", config);\n     let (mut cfg, mut except, mut label) = (None, false, false);\n     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-        if item.check_name(CFG) {\n+        if item.has_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             cfg = Some(config.contains(&(value, None)));\n         }\n-        if item.check_name(LABEL) {\n+        if item.has_name(LABEL) {\n             label = true;\n         }\n-        if item.check_name(EXCEPT) {\n+        if item.has_name(EXCEPT) {\n             except = true;\n         }\n     }"}, {"sha": "e4b7c24a24989b3e9adffb533740013db24f773d", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1034,6 +1034,30 @@ pub trait FiniteBitSetTy:\n     fn checked_shr(self, rhs: u32) -> Option<Self>;\n }\n \n+impl FiniteBitSetTy for u32 {\n+    const DOMAIN_SIZE: u32 = 32;\n+\n+    const FILLED: Self = Self::MAX;\n+    const EMPTY: Self = Self::MIN;\n+\n+    const ONE: Self = 1u32;\n+    const ZERO: Self = 0u32;\n+\n+    fn checked_shl(self, rhs: u32) -> Option<Self> {\n+        self.checked_shl(rhs)\n+    }\n+\n+    fn checked_shr(self, rhs: u32) -> Option<Self> {\n+        self.checked_shr(rhs)\n+    }\n+}\n+\n+impl std::fmt::Debug for FiniteBitSet<u32> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:032b}\", self.0)\n+    }\n+}\n+\n impl FiniteBitSetTy for u64 {\n     const DOMAIN_SIZE: u32 = 64;\n "}, {"sha": "ea32a1ae5a51ac174e9eea405dbc3f4b6b8d5890", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -199,8 +199,8 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n                 // rust-lang/rust#57464: `impl Trait` can leak local\n                 // scopes (in manner violating typeck). Therefore, use\n                 // `delay_span_bug` to allow type error over an ICE.\n-                ty::tls::with_context(|c| {\n-                    c.tcx.sess.delay_span_bug(\n+                ty::tls::with(|tcx| {\n+                    tcx.sess.delay_span_bug(\n                         rustc_span::DUMMY_SP,\n                         &format!(\"unexpected region in query response: `{:?}`\", r),\n                     );"}, {"sha": "133c4bf2db5f7a869c8ecd8a6db3654dcc67f9eb", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -166,15 +166,15 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                 return self.unify_const_variable(!a_is_expected, vid, a);\n             }\n             (ty::ConstKind::Unevaluated(..), _) if self.tcx.lazy_normalization() => {\n-                // FIXME(#59490): Need to remove the leak check to accomodate\n+                // FIXME(#59490): Need to remove the leak check to accommodate\n                 // escaping bound variables here.\n                 if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n                     relation.const_equate_obligation(a, b);\n                 }\n                 return Ok(b);\n             }\n             (_, ty::ConstKind::Unevaluated(..)) if self.tcx.lazy_normalization() => {\n-                // FIXME(#59490): Need to remove the leak check to accomodate\n+                // FIXME(#59490): Need to remove the leak check to accommodate\n                 // escaping bound variables here.\n                 if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n                     relation.const_equate_obligation(a, b);"}, {"sha": "0125e0f48e8852944dc4e5ecdacbf3b42b75c023", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n-            // Provide a more targetted error code and description.\n+            // Provide a more targeted error code and description.\n             err.code(rustc_errors::error_code!(E0772));\n             err.set_primary_message(&format!(\n                 \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\"}, {"sha": "ad30f5eda4d69f93cb797c362cf648e9534b988f", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -17,7 +17,6 @@ use rustc_session::early_error;\n use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::{DiagnosticOutput, Session};\n-use rustc_span::edition;\n use rustc_span::source_map::{FileLoader, FileName};\n use std::path::PathBuf;\n use std::result;\n@@ -208,13 +207,3 @@ pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R\n         || create_compiler_and_run(config, f),\n     )\n }\n-\n-pub fn setup_callbacks_and_run_in_default_thread_pool_with_globals<R: Send>(\n-    edition: edition::Edition,\n-    f: impl FnOnce() -> R + Send,\n-) -> R {\n-    // the 1 here is duplicating code in config.opts.debugging_opts.threads\n-    // which also defaults to 1; it ultimately doesn't matter as the default\n-    // isn't threaded, and just ignores this parameter\n-    util::setup_callbacks_and_run_in_thread_pool_with_globals(edition, 1, &None, f)\n-}"}, {"sha": "3a562847d3eb5f7161054e2b80f451e003c8b99f", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -752,7 +752,8 @@ impl<'tcx> QueryContext<'tcx> {\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        ty::tls::enter_global(self.0, f)\n+        let icx = ty::tls::ImplicitCtxt::new(self.0);\n+        ty::tls::enter_context(&icx, |_| f(icx.tcx))\n     }\n \n     pub fn print_stats(&mut self) {\n@@ -811,8 +812,9 @@ pub fn create_global_ctxt<'tcx>(\n     });\n \n     // Do some initialization of the DepGraph that can only be done with the tcx available.\n-    ty::tls::enter_global(&gcx, |tcx| {\n-        tcx.sess.time(\"dep_graph_tcx_init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n+    let icx = ty::tls::ImplicitCtxt::new(&gcx);\n+    ty::tls::enter_context(&icx, |_| {\n+        icx.tcx.sess.time(\"dep_graph_tcx_init\", || rustc_incremental::dep_graph_tcx_init(icx.tcx));\n     });\n \n     QueryContext(gcx)"}, {"sha": "bbb2f9d8b2500b212e496ffcd5a79dc2965c4a29", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,10 +10,9 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n #[cfg(parallel_compiler)]\n use rustc_data_structures::jobserver;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n-use rustc_middle::ty;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n use rustc_session::config::{self, CrateType};\n@@ -144,12 +143,10 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n \n     let main_handler = move || {\n         rustc_ast::with_session_globals(edition, || {\n-            ty::tls::GCX_PTR.set(&Lock::new(0), || {\n-                if let Some(stderr) = stderr {\n-                    io::set_panic(Some(box Sink(stderr.clone())));\n-                }\n-                f()\n-            })\n+            if let Some(stderr) = stderr {\n+                io::set_panic(Some(box Sink(stderr.clone())));\n+            }\n+            f()\n         })\n     };\n \n@@ -163,6 +160,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n ) -> R {\n+    use rustc_middle::ty;\n     crate::callbacks::setup_callbacks();\n \n     let mut config = rayon::ThreadPoolBuilder::new()\n@@ -189,12 +187,10 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n                 let main_handler = move |thread: rayon::ThreadBuilder| {\n                     rustc_ast::SESSION_GLOBALS.set(ast_session_globals, || {\n                         rustc_span::SESSION_GLOBALS.set(span_session_globals, || {\n-                            ty::tls::GCX_PTR.set(&Lock::new(0), || {\n-                                if let Some(stderr) = stderr {\n-                                    io::set_panic(Some(box Sink(stderr.clone())));\n-                                }\n-                                thread.run()\n-                            })\n+                            if let Some(stderr) = stderr {\n+                                io::set_panic(Some(box Sink(stderr.clone())));\n+                            }\n+                            thread.run()\n                         })\n                     })\n                 };"}, {"sha": "6515708e115a59101249b6a5951de08e6b123760", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -330,7 +330,7 @@ fn has_doc(attr: &ast::Attribute) -> bool {\n \n     if let Some(list) = attr.meta_item_list() {\n         for meta in list {\n-            if meta.check_name(sym::include) || meta.check_name(sym::hidden) {\n+            if meta.has_name(sym::include) || meta.has_name(sym::hidden) {\n                 return true;\n             }\n         }"}, {"sha": "31d30a264a59ed57c193ec36ffaa68f4332e63fe", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -573,7 +573,7 @@ pub trait LintContext: Sized {\n                     }\n                 }\n                 BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n-                    stability::deprecation_suggestion(&mut db, suggestion, span)\n+                    stability::deprecation_suggestion(&mut db, \"macro\", suggestion, span)\n                 }\n                 BuiltinLintDiagnostics::UnusedDocComment(span) => {\n                     db.span_label(span, \"rustdoc does not generate documentation for macro invocations\");"}, {"sha": "1e98ddbd7db4a1849c988b9595e2a5cb206ce1b6", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -275,10 +275,26 @@ declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n \n impl<'tcx> LateLintPass<'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n-        if let hir::StmtKind::Semi(ref expr) = s.kind {\n+        if let hir::StmtKind::Semi(expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| {\n-                    lint.build(\"path statement with no effect\").emit()\n+                    let ty = cx.typeck_results().expr_ty(expr);\n+                    if ty.needs_drop(cx.tcx, cx.param_env) {\n+                        let mut lint = lint.build(\"path statement drops value\");\n+                        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n+                            lint.span_suggestion(\n+                                s.span,\n+                                \"use `drop` to clarify the intent\",\n+                                format!(\"drop({});\", snippet),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            lint.span_help(s.span, \"use `drop` to clarify the intent\");\n+                        }\n+                        lint.emit()\n+                    } else {\n+                        lint.build(\"path statement with no effect\").emit()\n+                    }\n                 });\n             }\n         }\n@@ -422,7 +438,7 @@ trait UnusedDelimLint {\n         lhs_needs_parens\n             || (followed_by_block\n                 && match inner.kind {\n-                    ExprKind::Ret(_) | ExprKind::Break(..) => true,\n+                    ExprKind::Ret(_) | ExprKind::Break(..) | ExprKind::Yield(..) => true,\n                     _ => parser::contains_exterior_struct_lit(&inner),\n                 })\n     }\n@@ -520,7 +536,10 @@ trait UnusedDelimLint {\n                 (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n             }\n \n-            While(ref cond, ref block, ..) => {\n+            // Do not lint `unused_braces` in `while let` expressions.\n+            While(ref cond, ref block, ..)\n+                if !matches!(cond.kind, Let(_, _)) || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n+            {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n                 (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right))"}, {"sha": "9bc6c054e4d018840cc20987e946dfeb6cbf0561", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -13,7 +13,7 @@ use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::cstore::{CrateSource, DepKind, ExternCrate};\n+use rustc_middle::middle::cstore::{CrateDepKind, CrateSource, ExternCrate};\n use rustc_middle::middle::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n@@ -306,7 +306,7 @@ impl<'a> CrateLoader<'a> {\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         lib: Library,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         name: Symbol,\n     ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n@@ -437,7 +437,7 @@ impl<'a> CrateLoader<'a> {\n         &'b mut self,\n         name: Symbol,\n         span: Span,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> CrateNum {\n         if dep.is_none() {\n@@ -450,7 +450,7 @@ impl<'a> CrateLoader<'a> {\n     fn maybe_resolve_crate<'b>(\n         &'b mut self,\n         name: Symbol,\n-        mut dep_kind: DepKind,\n+        mut dep_kind: CrateDepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> Result<CrateNum, CrateError> {\n         info!(\"resolving crate `{}`\", name);\n@@ -487,7 +487,7 @@ impl<'a> CrateLoader<'a> {\n             match self.load(&mut locator)? {\n                 Some(res) => (res, None),\n                 None => {\n-                    dep_kind = DepKind::MacrosOnly;\n+                    dep_kind = CrateDepKind::MacrosOnly;\n                     match self.load_proc_macro(&mut locator, path_kind)? {\n                         Some(res) => res,\n                         None => return Err(locator.into_error()),\n@@ -500,7 +500,7 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n                 if data.is_proc_macro_crate() {\n-                    dep_kind = DepKind::MacrosOnly;\n+                    dep_kind = CrateDepKind::MacrosOnly;\n                 }\n                 data.update_dep_kind(|data_dep_kind| cmp::max(data_dep_kind, dep_kind));\n                 Ok(cnum)\n@@ -560,7 +560,7 @@ impl<'a> CrateLoader<'a> {\n         crate_root: &CrateRoot<'_>,\n         metadata: &MetadataBlob,\n         krate: CrateNum,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n     ) -> Result<CrateNumMap, CrateError> {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.is_proc_macro_crate() {\n@@ -579,7 +579,7 @@ impl<'a> CrateLoader<'a> {\n                 dep.name, dep.hash, dep.extra_filename\n             );\n             let dep_kind = match dep_kind {\n-                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                CrateDepKind::MacrosOnly => CrateDepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n             let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;\n@@ -646,7 +646,7 @@ impl<'a> CrateLoader<'a> {\n                 self.inject_dependency_if(cnum, \"a panic runtime\", &|data| {\n                     data.needs_panic_runtime()\n                 });\n-                runtime_found = runtime_found || data.dep_kind() == DepKind::Explicit;\n+                runtime_found = runtime_found || data.dep_kind() == CrateDepKind::Explicit;\n             }\n         });\n \n@@ -675,7 +675,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n@@ -705,7 +705,7 @@ impl<'a> CrateLoader<'a> {\n             info!(\"loading profiler\");\n \n             let name = sym::profiler_builtins;\n-            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n             let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n@@ -901,9 +901,9 @@ impl<'a> CrateLoader<'a> {\n                     None => item.ident.name,\n                 };\n                 let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n-                    DepKind::MacrosOnly\n+                    CrateDepKind::MacrosOnly\n                 } else {\n-                    DepKind::Explicit\n+                    CrateDepKind::Explicit\n                 };\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n@@ -925,7 +925,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n+        let cnum = self.resolve_crate(name, span, CrateDepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -942,6 +942,6 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {\n-        self.maybe_resolve_crate(name, DepKind::Explicit, None).ok()\n+        self.maybe_resolve_crate(name, CrateDepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "bb5ae4d0557c9866a221ae6d7053b519c2397f9b", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -56,7 +56,7 @@ use crate::creader::CStore;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n-use rustc_middle::middle::cstore::{self, DepKind};\n+use rustc_middle::middle::cstore::{self, CrateDepKind};\n use rustc_middle::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n@@ -188,7 +188,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none()\n             && !formats.contains_key(&cnum)\n-            && tcx.dep_kind(cnum) == DepKind::Explicit\n+            && tcx.dep_kind(cnum) == CrateDepKind::Explicit\n         {\n             assert!(src.rlib.is_some() || src.rmeta.is_some());\n             log::info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n@@ -284,7 +284,7 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate + 1)\n         .map(|cnum| {\n-            if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+            if tcx.dep_kind(CrateNum::new(cnum)) == CrateDepKind::Explicit {\n                 Linkage::Static\n             } else {\n                 Linkage::NotLinked"}, {"sha": "d01c598d059c0a468e6b0ffd17f2aedb39bd84d4", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -58,7 +58,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n             let mut kind_specified = false;\n \n             for item in items.iter() {\n-                if item.check_name(sym::kind) {\n+                if item.has_name(sym::kind) {\n                     kind_specified = true;\n                     let kind = match item.value_str() {\n                         Some(name) => name,\n@@ -84,9 +84,9 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                             NativeLibKind::Unspecified\n                         }\n                     };\n-                } else if item.check_name(sym::name) {\n+                } else if item.has_name(sym::name) {\n                     lib.name = item.value_str();\n-                } else if item.check_name(sym::cfg) {\n+                } else if item.has_name(sym::cfg) {\n                     let cfg = match item.meta_item_list() {\n                         Some(list) => list,\n                         None => continue, // skip like historical compilers\n@@ -98,7 +98,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                     } else {\n                         self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n-                } else if item.check_name(sym::wasm_import_module) {\n+                } else if item.has_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {"}, {"sha": "9fb4e08e2844a1908218271bcb337e6de815dcb7", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -78,7 +78,8 @@ crate struct CrateMetadata {\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n-    trait_impls: FxHashMap<(u32, DefIndex), Lazy<[DefIndex]>>,\n+    trait_impls:\n+        FxHashMap<(u32, DefIndex), Lazy<[(DefIndex, Option<ty::fast_reject::SimplifiedType>)]>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n@@ -100,7 +101,7 @@ crate struct CrateMetadata {\n     /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n     dependencies: Lock<Vec<CrateNum>>,\n     /// How to link (or not link) this crate to the currently compiled crate.\n-    dep_kind: Lock<DepKind>,\n+    dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n     source: CrateSource,\n     /// Whether or not this crate should be consider a private dependency\n@@ -1150,7 +1151,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u64> {\n+    fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {\n         self.root\n             .tables\n             .unused_generic_params\n@@ -1289,7 +1290,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n-    ) -> &'tcx [DefId] {\n+    ) -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n         if self.root.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[];\n@@ -1305,16 +1306,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         if let Some(filter) = filter {\n             if let Some(impls) = self.trait_impls.get(&filter) {\n-                tcx.arena.alloc_from_iter(impls.decode(self).map(|idx| self.local_def_id(idx)))\n+                tcx.arena.alloc_from_iter(\n+                    impls.decode(self).map(|(idx, simplified_self_ty)| {\n+                        (self.local_def_id(idx), simplified_self_ty)\n+                    }),\n+                )\n             } else {\n                 &[]\n             }\n         } else {\n-            tcx.arena.alloc_from_iter(\n-                self.trait_impls\n-                    .values()\n-                    .flat_map(|impls| impls.decode(self).map(|idx| self.local_def_id(idx))),\n-            )\n+            tcx.arena.alloc_from_iter(self.trait_impls.values().flat_map(|impls| {\n+                impls\n+                    .decode(self)\n+                    .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n+            }))\n         }\n     }\n \n@@ -1669,7 +1674,7 @@ impl CrateMetadata {\n         raw_proc_macros: Option<&'static [ProcMacro]>,\n         cnum: CrateNum,\n         cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         source: CrateSource,\n         private_dep: bool,\n         host_hash: Option<Svh>,\n@@ -1727,11 +1732,11 @@ impl CrateMetadata {\n         &self.source\n     }\n \n-    crate fn dep_kind(&self) -> DepKind {\n+    crate fn dep_kind(&self) -> CrateDepKind {\n         *self.dep_kind.lock()\n     }\n \n-    crate fn update_dep_kind(&self, f: impl FnOnce(DepKind) -> DepKind) {\n+    crate fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n "}, {"sha": "acae44e6bf7c92ae0339c80719a1f1fedfec4100", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // real code should never need to care about this.\n         //\n         // 2. Using `Span::def_site` or `Span::mixed_site` will not\n-        // include any hygiene information associated with the defintion\n+        // include any hygiene information associated with the definition\n         // site. This means that a proc-macro cannot emit a `$crate`\n         // identifier which resolves to one of its dependencies,\n         // which also should never come up in practice.\n@@ -1134,8 +1134,11 @@ impl EncodeContext<'a, 'tcx> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n             record!(self.tables.mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n-            record!(self.tables.unused_generic_params[def_id.to_def_id()] <-\n-                    self.tcx.unused_generic_params(def_id));\n+\n+            let unused = self.tcx.unused_generic_params(def_id);\n+            if !unused.is_empty() {\n+                record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n+            }\n         }\n     }\n \n@@ -1607,7 +1610,7 @@ impl EncodeContext<'a, 'tcx> {\n             .into_iter()\n             .map(|(trait_def_id, mut impls)| {\n                 // Bring everything into deterministic order for hashing\n-                impls.sort_by_cached_key(|&index| {\n+                impls.sort_by_cached_key(|&(index, _)| {\n                     tcx.hir().definitions().def_path_hash(LocalDefId { local_def_index: index })\n                 });\n \n@@ -1849,15 +1852,21 @@ impl EncodeContext<'a, 'tcx> {\n \n struct ImplVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    impls: FxHashMap<DefId, Vec<DefIndex>>,\n+    impls: FxHashMap<DefId, Vec<(DefIndex, Option<ty::fast_reject::SimplifiedType>)>>,\n }\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id.to_def_id()) {\n-                self.impls.entry(trait_ref.def_id).or_default().push(impl_id.local_def_index);\n+                let simplified_self_ty =\n+                    ty::fast_reject::simplify_type(self.tcx, trait_ref.self_ty(), false);\n+\n+                self.impls\n+                    .entry(trait_ref.def_id)\n+                    .or_default()\n+                    .push((impl_id.local_def_index, simplified_self_ty));\n             }\n         }\n     }"}, {"sha": "1c287be9f6bbcc238f7b83c38b0858b3f77473f0", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def_id::{DefId, DefIndex};\n use rustc_hir::lang_items;\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::hir::exports::Export;\n-use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLib};\n+use rustc_middle::middle::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n@@ -226,14 +226,14 @@ crate struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n     pub host_hash: Option<Svh>,\n-    pub kind: DepKind,\n+    pub kind: CrateDepKind,\n     pub extra_filename: String,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct TraitImpls {\n     trait_id: (u32, DefIndex),\n-    impls: Lazy<[DefIndex]>,\n+    impls: Lazy<[(DefIndex, Option<ty::fast_reject::SimplifiedType>)]>,\n }\n \n /// Define `LazyTables` and `TableBuilders` at the same time.\n@@ -285,7 +285,7 @@ define_tables! {\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u64>>>,\n+    unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "03431cb5a885ed4310ac549a8ffe46387f4cc7b5", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -12,7 +12,6 @@ doctest = false\n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n bitflags = \"1.2.1\"\n-scoped-tls = \"1.0\"\n log = { package = \"tracing\", version = \"0.1\" }\n rustc-rayon-core = \"0.3.0\"\n polonius-engine = \"0.12.0\""}, {"sha": "a49287840e19e0eb255aa57b241037e89845c00d", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -55,8 +55,6 @@\n #[macro_use]\n extern crate bitflags;\n #[macro_use]\n-extern crate scoped_tls;\n-#[macro_use]\n extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_data_structures;"}, {"sha": "0a34c06adf063bae570f3c72b4b1c98d2bd15ddd", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -40,7 +40,7 @@ impl CrateSource {\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n #[derive(HashStable)]\n-pub enum DepKind {\n+pub enum CrateDepKind {\n     /// A dependency that is only used for its macros.\n     MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n@@ -51,11 +51,11 @@ pub enum DepKind {\n     Explicit,\n }\n \n-impl DepKind {\n+impl CrateDepKind {\n     pub fn macros_only(self) -> bool {\n         match self {\n-            DepKind::MacrosOnly => true,\n-            DepKind::Implicit | DepKind::Explicit => false,\n+            CrateDepKind::MacrosOnly => true,\n+            CrateDepKind::Implicit | CrateDepKind::Explicit => false,\n         }\n     }\n }"}, {"sha": "b913d7dd4ad0b62ba9a3c7c7583c9b4b48c72b0a", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -166,29 +166,31 @@ pub fn deprecation_in_effect(is_since_rustc_version: bool, since: Option<&str>)\n \n pub fn deprecation_suggestion(\n     diag: &mut DiagnosticBuilder<'_>,\n+    kind: &str,\n     suggestion: Option<Symbol>,\n     span: Span,\n ) {\n     if let Some(suggestion) = suggestion {\n         diag.span_suggestion(\n             span,\n-            \"replace the use of the deprecated item\",\n+            &format!(\"replace the use of the deprecated {}\", kind),\n             suggestion.to_string(),\n             Applicability::MachineApplicable,\n         );\n     }\n }\n \n-pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n+pub fn deprecation_message(depr: &Deprecation, kind: &str, path: &str) -> (String, &'static Lint) {\n     let (message, lint) = if deprecation_in_effect(\n         depr.is_since_rustc_version,\n         depr.since.map(Symbol::as_str).as_deref(),\n     ) {\n-        (format!(\"use of deprecated item '{}'\", path), DEPRECATED)\n+        (format!(\"use of deprecated {} `{}`\", kind, path), DEPRECATED)\n     } else {\n         (\n             format!(\n-                \"use of item '{}' that will be deprecated in future version {}\",\n+                \"use of {} `{}` that will be deprecated in future version {}\",\n+                kind,\n                 path,\n                 depr.since.unwrap()\n             ),\n@@ -224,6 +226,7 @@ fn late_report_deprecation(\n     lint: &'static Lint,\n     span: Span,\n     hir_id: HirId,\n+    def_id: DefId,\n ) {\n     if span.in_derive_expansion() {\n         return;\n@@ -232,7 +235,8 @@ fn late_report_deprecation(\n     tcx.struct_span_lint_hir(lint, hir_id, span, |lint| {\n         let mut diag = lint.build(message);\n         if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-            deprecation_suggestion(&mut diag, suggestion, span);\n+            let kind = tcx.def_kind(def_id).descr(def_id);\n+            deprecation_suggestion(&mut diag, kind, suggestion, span);\n         }\n         diag.emit()\n     });\n@@ -304,15 +308,17 @@ impl<'tcx> TyCtxt<'tcx> {\n                 // #[rustc_deprecated] however wants to emit down the whole\n                 // hierarchy.\n                 if !skip || depr_entry.attr.is_since_rustc_version {\n-                    let (message, lint) =\n-                        deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n+                    let path = &self.def_path_str(def_id);\n+                    let kind = self.def_kind(def_id).descr(def_id);\n+                    let (message, lint) = deprecation_message(&depr_entry.attr, kind, path);\n                     late_report_deprecation(\n                         self,\n                         &message,\n                         depr_entry.attr.suggestion,\n                         lint,\n                         span,\n                         id,\n+                        def_id,\n                     );\n                 }\n             };"}, {"sha": "6b1514da6441de474a19c738e3a9b92a7865105f", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -4,8 +4,11 @@\n pub mod count_code_region_args {\n     pub const FUNCTION_SOURCE_HASH: usize = 0;\n     pub const COUNTER_ID: usize = 1;\n-    pub const START_BYTE_POS: usize = 2;\n-    pub const END_BYTE_POS: usize = 3;\n+    pub const FILE_NAME: usize = 2;\n+    pub const START_LINE: usize = 3;\n+    pub const START_COL: usize = 4;\n+    pub const END_LINE: usize = 5;\n+    pub const END_COL: usize = 6;\n }\n \n /// Positional arguments to `libcore::coverage_counter_add()` and\n@@ -14,12 +17,18 @@ pub mod coverage_counter_expression_args {\n     pub const EXPRESSION_ID: usize = 0;\n     pub const LEFT_ID: usize = 1;\n     pub const RIGHT_ID: usize = 2;\n-    pub const START_BYTE_POS: usize = 3;\n-    pub const END_BYTE_POS: usize = 4;\n+    pub const FILE_NAME: usize = 3;\n+    pub const START_LINE: usize = 4;\n+    pub const START_COL: usize = 5;\n+    pub const END_LINE: usize = 6;\n+    pub const END_COL: usize = 7;\n }\n \n /// Positional arguments to `libcore::coverage_unreachable()`\n pub mod coverage_unreachable_args {\n-    pub const START_BYTE_POS: usize = 0;\n-    pub const END_BYTE_POS: usize = 1;\n+    pub const FILE_NAME: usize = 0;\n+    pub const START_LINE: usize = 1;\n+    pub const START_COL: usize = 2;\n+    pub const END_LINE: usize = 3;\n+    pub const END_COL: usize = 4;\n }"}, {"sha": "c904cd83a78bc2b0437ae557826858bebd173ee0", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -27,7 +27,7 @@ pub enum ErrorHandled {\n     TooGeneric,\n }\n \n-CloneTypeFoldableImpls! {\n+CloneTypeFoldableAndLiftImpls! {\n     ErrorHandled,\n }\n \n@@ -242,9 +242,9 @@ impl From<ErrorHandled> for InterpErrorInfo<'_> {\n \n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n-        let capture_backtrace = tls::with_context_opt(|ctxt| {\n-            if let Some(ctxt) = ctxt {\n-                *Lock::borrow(&ctxt.tcx.sess.ctfe_backtrace)\n+        let capture_backtrace = tls::with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                *Lock::borrow(&tcx.sess.ctfe_backtrace)\n             } else {\n                 CtfeBacktrace::Disabled\n             }"}, {"sha": "b4e7a5b98e33ba6296a957f4973a0ed8d53159f5", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -56,6 +56,15 @@ impl<'tcx> ConstValue<'tcx> {\n         }\n     }\n \n+    pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n+        if let ConstValue::Slice { data, start, end } = *self {\n+            ::std::str::from_utf8(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+                .ok()\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }"}, {"sha": "3b0c480f6d400458cb0f40b906fc9ceea216ab82", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n-use crate::mir::interpret::{GlobalAlloc, Scalar};\n+use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -1842,6 +1842,33 @@ impl<'tcx> Operand<'tcx> {\n         }\n     }\n \n+    /// Convenience helper to make a literal-like constant from a given `&str` slice.\n+    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n+    pub fn const_from_str(tcx: TyCtxt<'tcx>, val: &str, span: Span) -> Operand<'tcx> {\n+        let tcx = tcx;\n+        let allocation = Allocation::from_byte_aligned_bytes(val.as_bytes());\n+        let allocation = tcx.intern_const_alloc(allocation);\n+        let const_val = ConstValue::Slice { data: allocation, start: 0, end: val.len() };\n+        let ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.types.str_);\n+        Operand::Constant(box Constant {\n+            span,\n+            user_ty: None,\n+            literal: ty::Const::from_value(tcx, const_val, ty),\n+        })\n+    }\n+\n+    /// Convenience helper to make a `ConstValue` from the given `Operand`, assuming that `Operand`\n+    /// wraps a constant value (such as a `&str` slice). Panics if this is not the case.\n+    pub fn value_from_const(operand: &Operand<'tcx>) -> ConstValue<'tcx> {\n+        match operand {\n+            Operand::Constant(constant) => match constant.literal.val.try_to_value() {\n+                Some(const_value) => const_value,\n+                _ => panic!(\"{:?}: ConstValue expected\", constant.literal.val),\n+            },\n+            _ => panic!(\"{:?}: Constant expected\", operand),\n+        }\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),"}, {"sha": "a8f6723a35605c281d5bb964dffe0798708d05f3", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1125,11 +1125,11 @@ rustc_queries! {\n \n     TypeChecking {\n         query implementations_of_trait(_: (CrateNum, DefId))\n-            -> &'tcx [DefId] {\n+            -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n         query all_trait_implementations(_: CrateNum)\n-            -> &'tcx [DefId] {\n+            -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up all (?) trait implementations\" }\n         }\n     }\n@@ -1186,7 +1186,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query dep_kind(_: CrateNum) -> DepKind {\n+        query dep_kind(_: CrateNum) -> CrateDepKind {\n             eval_always\n             desc { \"fetching what a dependency looks like\" }\n         }\n@@ -1319,7 +1319,7 @@ rustc_queries! {\n         query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n             desc { \"codegen_unit\" }\n         }\n-        query unused_generic_params(key: DefId) -> FiniteBitSet<u64> {\n+        query unused_generic_params(key: DefId) -> FiniteBitSet<u32> {\n             cache_on_disk_if { key.is_local() }\n             desc {\n                 |tcx| \"determining which generic parameters are unused by `{}`\","}, {"sha": "585f29386a8e0e15c06f2595c2213dd72829c9a3", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -30,7 +30,6 @@ pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx\n \n pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n \n pub use self::chalk::{\n     ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustInterner as ChalkRustInterner,\n@@ -86,7 +85,7 @@ pub enum Reveal {\n ///\n /// We do not want to intern this as there are a lot of obligation causes which\n /// only live for a short period of time.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCause<'tcx> {\n     /// `None` for `ObligationCause::dummy`, `Some` otherwise.\n     data: Option<Rc<ObligationCauseData<'tcx>>>,\n@@ -111,7 +110,7 @@ impl Deref for ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCauseData<'tcx> {\n     pub span: Span,\n \n@@ -169,14 +168,14 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct UnifyReceiverContext<'tcx> {\n     pub assoc_item: ty::AssocItem,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n     MiscObligation,\n@@ -343,7 +342,7 @@ impl ObligationCauseCode<'_> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(ObligationCauseCode<'_>, 32);\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n     pub source: hir::MatchSource,\n@@ -359,7 +358,7 @@ pub struct IfExpressionCause {\n     pub semicolon: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -371,7 +370,7 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n }\n \n-#[derive(Clone, Debug, TypeFoldable)]\n+#[derive(Clone, Debug, TypeFoldable, Lift)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     OutputTypeParameterMismatch(\n@@ -427,7 +426,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `ImplSourceUserDefinedData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n     ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n@@ -558,14 +557,14 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -574,7 +573,7 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -583,18 +582,18 @@ pub struct ImplSourceClosureData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -607,17 +606,17 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ImplSourceDiscriminantKindData;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "6ad514c6be21b93dd79c3ef546ae2636ed980096", "filename": "src/librustc_middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 91, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fselect.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -6,29 +6,18 @@ use self::EvaluationResult::*;\n \n use super::{SelectionError, SelectionResult};\n \n-use crate::dep_graph::DepNodeIndex;\n-use crate::ty::{self, TyCtxt};\n+use crate::ty;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n use rustc_hir::def_id::DefId;\n+use rustc_query_system::cache::Cache;\n \n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n+pub type SelectionCache<'tcx> = Cache<\n+    ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+    SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n+>;\n \n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n+pub type EvaluationCache<'tcx> =\n+    Cache<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, EvaluationResult>;\n \n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation. Sometimes\n@@ -264,75 +253,3 @@ impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n         SelectionError::Overflow\n     }\n }\n-\n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n-impl<'tcx> EvaluationCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum IntercrateAmbiguityCause {\n-    DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n-    UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n-    ReservationImpl { message: String },\n-}\n-\n-impl IntercrateAmbiguityCause {\n-    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n-    /// See #23980 for details.\n-    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n-        err.note(&self.intercrate_ambiguity_hint());\n-    }\n-\n-    pub fn intercrate_ambiguity_hint(&self) -> String {\n-        match self {\n-            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n-                let self_desc = if let &Some(ref ty) = self_desc {\n-                    format!(\" for type `{}`\", ty)\n-                } else {\n-                    String::new()\n-                };\n-                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n-            }\n-            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n-                let self_desc = if let &Some(ref ty) = self_desc {\n-                    format!(\" for type `{}`\", ty)\n-                } else {\n-                    String::new()\n-                };\n-                format!(\n-                    \"upstream crates may add a new impl of trait `{}`{} \\\n-                     in future versions\",\n-                    trait_desc, self_desc\n-                )\n-            }\n-            &IntercrateAmbiguityCause::ReservationImpl { ref message } => message.clone(),\n-        }\n-    }\n-}"}, {"sha": "d73fc628ceb70af2ddfef6740c4ea6b7878e980a", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 220, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,6 @@\n use crate::traits;\n-use crate::ty::{Lift, TyCtxt};\n \n use std::fmt;\n-use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n@@ -107,222 +105,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n-            }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => {\n-                tcx.lift(&ty).and_then(|ty| tcx.lift(&r).map(|r| super::ObjectTypeBound(ty, r)))\n-            }\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::Coercion { source, target } => {\n-                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n-            }\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n-            super::ReturnType => Some(super::ReturnType),\n-            super::SizedArgumentType(sp) => Some(super::SizedArgumentType(sp)),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::InlineAsmSized => Some(super::InlineAsmSized),\n-            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n-            super::FieldSized { adt_kind, span, last } => {\n-                Some(super::FieldSized { adt_kind, span, last })\n-            }\n-            super::ConstSized => Some(super::ConstSized),\n-            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n-            }\n-            super::DerivedObligation(ref cause) => tcx.lift(cause).map(super::DerivedObligation),\n-            super::CompareImplConstObligation => Some(super::CompareImplConstObligation),\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n-                Some(super::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                arm_span,\n-                source,\n-                ref prior_arms,\n-                last_ty,\n-                scrut_hir_id,\n-            }) => tcx.lift(&last_ty).map(|last_ty| {\n-                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                    arm_span,\n-                    source,\n-                    prior_arms: prior_arms.clone(),\n-                    last_ty,\n-                    scrut_hir_id,\n-                })\n-            }),\n-            super::Pattern { span, root_ty, origin_expr } => {\n-                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n-            }\n-            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n-                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n-            }\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::UnifyReceiver(ref ctxt) => tcx.lift(ctxt).map(|ctxt| super::UnifyReceiver(ctxt)),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::UnifyReceiverContext<'a> {\n-    type Lifted = traits::UnifyReceiverContext<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.param_env).and_then(|param_env| {\n-            tcx.lift(&self.substs).map(|substs| traits::UnifyReceiverContext {\n-                assoc_item: self.assoc_item,\n-                param_env,\n-                substs,\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n-                parent_trait_ref: trait_ref,\n-                parent_code: Rc::new(code),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause::new(self.span, self.body_id, code))\n-    }\n-}\n-\n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::ImplSource<'a, ()> {\n-    type Lifted = traits::ImplSource<'tcx, ()>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n-                impl_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n-                    impl_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceAutoImpl(t) => Some(traits::ImplSourceAutoImpl(t)),\n-            traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n-                    generator_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceClosure(traits::ImplSourceClosureData {\n-                closure_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceClosure(traits::ImplSourceClosureData {\n-                    closure_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested })\n-                })\n-            }\n-            traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData) => {\n-                Some(traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData))\n-            }\n-            traits::ImplSourceParam(n) => Some(traits::ImplSourceParam(n)),\n-            traits::ImplSourceBuiltin(n) => Some(traits::ImplSourceBuiltin(n)),\n-            traits::ImplSourceObject(traits::ImplSourceObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::ImplSourceObject(traits::ImplSourceObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-        }\n-    }\n+CloneTypeFoldableAndLiftImpls! {\n+    super::IfExpressionCause,\n+    super::ImplSourceDiscriminantKindData,\n }"}, {"sha": "6cbf5db8373a074be799c098a1eea09b50b71fcb", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 10, "deletions": 49, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1632,7 +1632,6 @@ pub mod tls {\n     use crate::ty::query;\n     use rustc_data_structures::sync::{self, Lock};\n     use rustc_data_structures::thin_vec::ThinVec;\n-    use rustc_data_structures::OnDrop;\n     use rustc_errors::Diagnostic;\n     use std::mem;\n \n@@ -1649,8 +1648,7 @@ pub mod tls {\n     /// in this module.\n     #[derive(Clone)]\n     pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current `TyCtxt`. Initially created by `enter_global` and updated\n-        /// by `enter_local` with a new local interner.\n+        /// The current `TyCtxt`.\n         pub tcx: TyCtxt<'tcx>,\n \n         /// The current query job, if any. This is updated by `JobOwner::start` in\n@@ -1669,6 +1667,13 @@ pub mod tls {\n         pub task_deps: Option<&'a Lock<TaskDeps>>,\n     }\n \n+    impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n+        pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n+            let tcx = TyCtxt { gcx };\n+            ImplicitCtxt { tcx, query: None, diagnostics: None, layout_depth: 0, task_deps: None }\n+        }\n+    }\n+\n     /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n     /// This is used to set the pointer to the new `ImplicitCtxt`.\n@@ -1682,7 +1687,7 @@ pub mod tls {\n     /// This is used to get the pointer to the current `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n-    fn get_tlv() -> usize {\n+    pub fn get_tlv() -> usize {\n         rayon_core::tlv::get()\n     }\n \n@@ -1699,7 +1704,7 @@ pub mod tls {\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n-        let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n         TLV.with(|tlv| tlv.set(value));\n         f()\n     }\n@@ -1720,50 +1725,6 @@ pub mod tls {\n         set_tlv(context as *const _ as usize, || f(&context))\n     }\n \n-    /// Enters `GlobalCtxt` by setting up librustc_ast callbacks and\n-    /// creating a initial `TyCtxt` and `ImplicitCtxt`.\n-    /// This happens once per rustc session and `TyCtxt`s only exists\n-    /// inside the `f` function.\n-    pub fn enter_global<'tcx, F, R>(gcx: &'tcx GlobalCtxt<'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n-        // Update `GCX_PTR` to indicate there's a `GlobalCtxt` available.\n-        GCX_PTR.with(|lock| {\n-            *lock.lock() = gcx as *const _ as usize;\n-        });\n-        // Set `GCX_PTR` back to 0 when we exit.\n-        let _on_drop = OnDrop(move || {\n-            GCX_PTR.with(|lock| *lock.lock() = 0);\n-        });\n-\n-        let tcx = TyCtxt { gcx };\n-        let icx =\n-            ImplicitCtxt { tcx, query: None, diagnostics: None, layout_depth: 0, task_deps: None };\n-        enter_context(&icx, |_| f(tcx))\n-    }\n-\n-    scoped_thread_local! {\n-        /// Stores a pointer to the `GlobalCtxt` if one is available.\n-        /// This is used to access the `GlobalCtxt` in the deadlock handler given to Rayon.\n-        pub static GCX_PTR: Lock<usize>\n-    }\n-\n-    /// Creates a `TyCtxt` and `ImplicitCtxt` based on the `GCX_PTR` thread local.\n-    /// This is used in the deadlock handler.\n-    pub unsafe fn with_global<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n-        let gcx = GCX_PTR.with(|lock| *lock.lock());\n-        assert!(gcx != 0);\n-        let gcx = &*(gcx as *const GlobalCtxt<'_>);\n-        let tcx = TyCtxt { gcx };\n-        let icx =\n-            ImplicitCtxt { query: None, diagnostics: None, tcx, layout_depth: 0, task_deps: None };\n-        enter_context(&icx, |_| f(tcx))\n-    }\n-\n     /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n     #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R"}, {"sha": "1811d945a1d152fc26ed05b8f35d892458599e96", "filename": "src/librustc_middle/ty/query/job.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,18 +10,20 @@ use std::thread;\n pub unsafe fn handle_deadlock() {\n     let registry = rayon_core::Registry::current();\n \n-    let gcx_ptr = tls::GCX_PTR.with(|gcx_ptr| gcx_ptr as *const _);\n-    let gcx_ptr = &*gcx_ptr;\n+    let context = tls::get_tlv();\n+    assert!(context != 0);\n+    rustc_data_structures::sync::assert_sync::<tls::ImplicitCtxt<'_, '_>>();\n+    let icx: &tls::ImplicitCtxt<'_, '_> = &*(context as *const tls::ImplicitCtxt<'_, '_>);\n \n     let span_session_globals = rustc_span::SESSION_GLOBALS.with(|ssg| ssg as *const _);\n     let span_session_globals = &*span_session_globals;\n     let ast_session_globals = rustc_ast::attr::SESSION_GLOBALS.with(|asg| asg as *const _);\n     let ast_session_globals = &*ast_session_globals;\n     thread::spawn(move || {\n-        tls::GCX_PTR.set(gcx_ptr, || {\n+        tls::enter_context(icx, |_| {\n             rustc_ast::attr::SESSION_GLOBALS.set(ast_session_globals, || {\n                 rustc_span::SESSION_GLOBALS\n-                    .set(span_session_globals, || tls::with_global(|tcx| deadlock(tcx, &registry)))\n+                    .set(span_session_globals, || tls::with(|tcx| deadlock(tcx, &registry)))\n             });\n         })\n     });"}, {"sha": "b39c0b5190a6d951c59cae210ccbd49dcee06544", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,10 +1,10 @@\n-use crate::dep_graph::{self, DepNode, DepNodeParams};\n+use crate::dep_graph::{self, DepKind, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::cstore::{CrateSource, DepKind};\n+use crate::middle::cstore::{CrateDepKind, CrateSource};\n use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use crate::middle::lib_features::LibFeatures;\n@@ -161,7 +161,7 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n     debug_assert!(\n-        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n+        dep_node.kind != DepKind::codegen_unit,\n         \"calling force_from_dep_node() on DepKind::codegen_unit\"\n     );\n \n@@ -172,14 +172,14 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n-        crate::dep_graph::DepKind::CrateMetadata |\n+        DepKind::CrateMetadata |\n \n         // These are anonymous nodes.\n-        crate::dep_graph::DepKind::TraitSelect |\n+        DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n         // these.\n-        crate::dep_graph::DepKind::CompileCodegenUnit => {\n+        DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n     );"}, {"sha": "dfa9e38a466ebe2151005687d798b6ab70483a31", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -282,6 +282,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::rustc_hir::def::Res,\n     ::rustc_hir::def_id::DefId,\n     ::rustc_hir::def_id::LocalDefId,\n+    ::rustc_hir::HirId,\n     ::rustc_hir::LlvmInlineAsmInner,\n     ::rustc_hir::MatchSource,\n     ::rustc_hir::Mutability,\n@@ -298,6 +299,7 @@ CloneTypeFoldableAndLiftImpls! {\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n     crate::ty::BoundRegion,\n+    crate::ty::AssocItem,\n     crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,"}, {"sha": "866b529f35ec381d4e751e0d835942b167ba859a", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -425,8 +425,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n         substs: &[GenericArg<'tcx>],\n         span: Option<Span>,\n     ) -> T {\n-        let mut folder =\n-            SubstFolder { tcx, substs, span, root_ty: None, ty_stack_depth: 0, binders_passed: 0 };\n+        let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };\n         (*self).fold_with(&mut folder)\n     }\n }\n@@ -441,12 +440,6 @@ struct SubstFolder<'a, 'tcx> {\n     /// The location for which the substitution is performed, if available.\n     span: Option<Span>,\n \n-    /// The root type that is being substituted, if available.\n-    root_ty: Option<Ty<'tcx>>,\n-\n-    /// Depth of type stack\n-    ty_stack_depth: usize,\n-\n     /// Number of region binders we have passed through while doing the substitution\n     binders_passed: u32,\n }\n@@ -478,9 +471,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n                         let msg = format!(\n                             \"Region parameter out of range \\\n-                             when substituting in region {} (root type={:?}) \\\n-                             (index={})\",\n-                            data.name, self.root_ty, data.index\n+                             when substituting in region {} (index={})\",\n+                            data.name, data.index\n                         );\n                         span_bug!(span, \"{}\", msg);\n                     }\n@@ -495,25 +487,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             return t;\n         }\n \n-        // track the root type we were asked to substitute\n-        let depth = self.ty_stack_depth;\n-        if depth == 0 {\n-            self.root_ty = Some(t);\n-        }\n-        self.ty_stack_depth += 1;\n-\n-        let t1 = match t.kind {\n+        match t.kind {\n             ty::Param(p) => self.ty_for_param(p, t),\n             _ => t.super_fold_with(self),\n-        };\n-\n-        assert_eq!(depth + 1, self.ty_stack_depth);\n-        self.ty_stack_depth -= 1;\n-        if depth == 0 {\n-            self.root_ty = None;\n         }\n-\n-        t1\n     }\n \n     fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n@@ -540,12 +517,11 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n                 span_bug!(\n                     span,\n                     \"expected type for `{:?}` ({:?}/{}) but found {:?} \\\n-                     when substituting (root type={:?}) substs={:?}\",\n+                     when substituting, substs={:?}\",\n                     p,\n                     source_ty,\n                     p.index,\n                     kind,\n-                    self.root_ty,\n                     self.substs,\n                 );\n             }\n@@ -554,11 +530,10 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n                 span_bug!(\n                     span,\n                     \"type parameter `{:?}` ({:?}/{}) out of range \\\n-                     when substituting (root type={:?}) substs={:?}\",\n+                     when substituting, substs={:?}\",\n                     p,\n                     source_ty,\n                     p.index,\n-                    self.root_ty,\n                     self.substs,\n                 );\n             }"}, {"sha": "f93cce3f4da7f1b1f786f3d883a3a94fb2f12526", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -187,32 +187,38 @@ pub(super) fn all_local_trait_impls<'tcx>(\n pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> TraitImpls {\n     let mut impls = TraitImpls::default();\n \n-    {\n-        let mut add_impl = |impl_def_id: DefId| {\n-            let impl_self_ty = tcx.type_of(impl_def_id);\n-            if impl_def_id.is_local() && impl_self_ty.references_error() {\n-                return;\n-            }\n-\n-            if let Some(simplified_self_ty) = fast_reject::simplify_type(tcx, impl_self_ty, false) {\n-                impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n-            } else {\n-                impls.blanket_impls.push(impl_def_id);\n-            }\n-        };\n-\n-        // Traits defined in the current crate can't have impls in upstream\n-        // crates, so we don't bother querying the cstore.\n-        if !trait_id.is_local() {\n-            for &cnum in tcx.crates().iter() {\n-                for &def_id in tcx.implementations_of_trait((cnum, trait_id)).iter() {\n-                    add_impl(def_id);\n+    // Traits defined in the current crate can't have impls in upstream\n+    // crates, so we don't bother querying the cstore.\n+    if !trait_id.is_local() {\n+        for &cnum in tcx.crates().iter() {\n+            for &(impl_def_id, simplified_self_ty) in\n+                tcx.implementations_of_trait((cnum, trait_id)).iter()\n+            {\n+                if let Some(simplified_self_ty) = simplified_self_ty {\n+                    impls\n+                        .non_blanket_impls\n+                        .entry(simplified_self_ty)\n+                        .or_default()\n+                        .push(impl_def_id);\n+                } else {\n+                    impls.blanket_impls.push(impl_def_id);\n                 }\n             }\n         }\n+    }\n+\n+    for &hir_id in tcx.hir().trait_impls(trait_id) {\n+        let impl_def_id = tcx.hir().local_def_id(hir_id).to_def_id();\n+\n+        let impl_self_ty = tcx.type_of(impl_def_id);\n+        if impl_self_ty.references_error() {\n+            continue;\n+        }\n \n-        for &hir_id in tcx.hir().trait_impls(trait_id) {\n-            add_impl(tcx.hir().local_def_id(hir_id).to_def_id());\n+        if let Some(simplified_self_ty) = fast_reject::simplify_type(tcx, impl_self_ty, false) {\n+            impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n+        } else {\n+            impls.blanket_impls.push(impl_def_id);\n         }\n     }\n "}, {"sha": "07221082048fbc3603a8995e98d7f670e3e374e1", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -585,7 +585,7 @@ struct OpaqueTypeExpander<'tcx> {\n     found_recursion: bool,\n     /// Whether or not to check for recursive opaque types.\n     /// This is `true` when we're explicitly checking for opaque type\n-    /// recursion, and 'false' otherwise to avoid unecessary work.\n+    /// recursion, and 'false' otherwise to avoid unnecessary work.\n     check_recursion: bool,\n     tcx: TyCtxt<'tcx>,\n }"}, {"sha": "2113d40a594ebd3b237d7c79c155f847ae9491c7", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -339,7 +339,7 @@ impl RustcMirAttrs {\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {\n-            let attr_result = if attr.check_name(sym::borrowck_graphviz_postflow) {\n+            let attr_result = if attr.has_name(sym::borrowck_graphviz_postflow) {\n                 Self::set_field(&mut ret.basename_and_suffix, tcx, &attr, |s| {\n                     let path = PathBuf::from(s.to_string());\n                     match path.file_name() {\n@@ -350,7 +350,7 @@ impl RustcMirAttrs {\n                         }\n                     }\n                 })\n-            } else if attr.check_name(sym::borrowck_graphviz_format) {\n+            } else if attr.has_name(sym::borrowck_graphviz_format) {\n                 Self::set_field(&mut ret.formatter, tcx, &attr, |s| match s {\n                     sym::gen_kill | sym::two_phase => Ok(s),\n                     _ => {"}, {"sha": "8a9edb23a10ef45b2ccaeca6d8cb0c645848540d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {\n-                    Some(mi) if mi.check_name(name) => return Some(mi.clone()),\n+                    Some(mi) if mi.has_name(name) => return Some(mi.clone()),\n                     _ => continue,\n                 }\n             }"}, {"sha": "7dfa913fd08bd07b45daf49c22a829de9313f11d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -952,7 +952,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n-            // is marked as unititialized but we otherwise omit changing the byte representation which may\n+            // is marked as uninitialized but we otherwise omit changing the byte representation which may\n             // be arbitrary for uninitialized bytes.\n             // This also avoids writing to the target bytes so that the backing allocation is never\n             // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary"}, {"sha": "57c5fc59cc0b84aeecf88703d5e751ec6e062e59", "filename": "src/librustc_mir/interpret/util.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Futil.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -47,14 +47,26 @@ where\n                             unused_params.contains(index).map(|unused| !unused).unwrap_or(true);\n                         // Only recurse when generic parameters in fns, closures and generators\n                         // are used and require substitution.\n-                        if is_used && subst.needs_subst() {\n+                        match (is_used, subst.needs_subst()) {\n                             // Just in case there are closures or generators within this subst,\n                             // recurse.\n-                            if subst.super_visit_with(self) {\n+                            (true, true) if subst.super_visit_with(self) => {\n                                 // Only return when we find a parameter so the remaining substs\n                                 // are not skipped.\n                                 return true;\n                             }\n+                            // Confirm that polymorphization replaced the parameter with\n+                            // `ty::Param`/`ty::ConstKind::Param`.\n+                            (false, true) if cfg!(debug_assertions) => match subst.unpack() {\n+                                ty::subst::GenericArgKind::Type(ty) => {\n+                                    assert!(matches!(ty.kind, ty::Param(_)))\n+                                }\n+                                ty::subst::GenericArgKind::Const(ct) => {\n+                                    assert!(matches!(ct.val, ty::ConstKind::Param(_)))\n+                                }\n+                                ty::subst::GenericArgKind::Lifetime(..) => (),\n+                            },\n+                            _ => {}\n                         }\n                     }\n                     false"}, {"sha": "8fc1458f592054ee47064dbc4bc3fb63e8b74163", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -28,14 +28,21 @@ pub fn provide(providers: &mut Providers) {\n /// Determine which generic parameters are used by the function/method/closure represented by\n /// `def_id`. Returns a bitset where bits representing unused parameters are set (`is_empty`\n /// indicates all parameters are used).\n-fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u64> {\n+fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n     debug!(\"unused_generic_params({:?})\", def_id);\n \n     if !tcx.sess.opts.debugging_opts.polymorphize {\n         // If polymorphization disabled, then all parameters are used.\n         return FiniteBitSet::new_empty();\n     }\n \n+    // Polymorphization results are stored in cross-crate metadata only when there are unused\n+    // parameters, so assume that non-local items must have only used parameters (else this query\n+    // would not be invoked, and the cross-crate metadata used instead).\n+    if !def_id.is_local() {\n+        return FiniteBitSet::new_empty();\n+    }\n+\n     let generics = tcx.generics_of(def_id);\n     debug!(\"unused_generic_params: generics={:?}\", generics);\n \n@@ -53,7 +60,7 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u64> {\n     // Create a bitset with N rightmost ones for each parameter.\n     let generics_count: u32 =\n         generics.count().try_into().expect(\"more generic parameters than can fit into a `u32`\");\n-    let mut unused_parameters = FiniteBitSet::<u64>::new_empty();\n+    let mut unused_parameters = FiniteBitSet::<u32>::new_empty();\n     unused_parameters.set_range(0..generics_count);\n     debug!(\"unused_generic_params: (start) unused_parameters={:?}\", unused_parameters);\n     mark_used_by_default_parameters(tcx, def_id, generics, &mut unused_parameters);\n@@ -84,7 +91,7 @@ fn mark_used_by_default_parameters<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n-    unused_parameters: &mut FiniteBitSet<u64>,\n+    unused_parameters: &mut FiniteBitSet<u32>,\n ) {\n     if !tcx.is_trait(def_id) && (tcx.is_closure(def_id) || tcx.type_of(def_id).is_generator()) {\n         for param in &generics.params {\n@@ -110,11 +117,11 @@ fn mark_used_by_default_parameters<'tcx>(\n fn mark_used_by_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    unused_parameters: &mut FiniteBitSet<u64>,\n+    unused_parameters: &mut FiniteBitSet<u32>,\n ) {\n     let def_id = tcx.closure_base_def_id(def_id);\n \n-    let is_self_ty_used = |unused_parameters: &mut FiniteBitSet<u64>, self_ty: Ty<'tcx>| {\n+    let is_self_ty_used = |unused_parameters: &mut FiniteBitSet<u32>, self_ty: Ty<'tcx>| {\n         debug!(\"unused_generic_params: self_ty={:?}\", self_ty);\n         if let ty::Param(param) = self_ty.kind {\n             !unused_parameters.contains(param.index).unwrap_or(false)\n@@ -123,7 +130,7 @@ fn mark_used_by_predicates<'tcx>(\n         }\n     };\n \n-    let mark_ty = |unused_parameters: &mut FiniteBitSet<u64>, ty: Ty<'tcx>| {\n+    let mark_ty = |unused_parameters: &mut FiniteBitSet<u32>, ty: Ty<'tcx>| {\n         let mut vis = UsedGenericParametersVisitor { tcx, def_id, unused_parameters };\n         ty.visit_with(&mut vis);\n     };\n@@ -159,7 +166,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n-    unused_parameters: &FiniteBitSet<u64>,\n+    unused_parameters: &FiniteBitSet<u32>,\n ) {\n     debug!(\"emit_unused_generic_params_error: def_id={:?}\", def_id);\n     let base_def_id = tcx.closure_base_def_id(def_id);\n@@ -195,7 +202,7 @@ fn emit_unused_generic_params_error<'tcx>(\n struct UsedGenericParametersVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    unused_parameters: &'a mut FiniteBitSet<u64>,\n+    unused_parameters: &'a mut FiniteBitSet<u32>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {"}, {"sha": "5b2954dd5b0a3e08ebf228722ed6d056f35d9631", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,18 +5,19 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::mir;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::traversal;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo,\n-    SourceScope, StatementKind, Terminator, TerminatorKind,\n+    BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo, SourceScope,\n+    StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::FnDef;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{FnDef, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_span::{Pos, Span};\n+use rustc_span::{FileName, Pos, RealFileName, Span};\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n@@ -112,6 +113,7 @@ enum Op {\n struct InjectedCall<'tcx> {\n     func: Operand<'tcx>,\n     args: Vec<Operand<'tcx>>,\n+    span: Span,\n     inject_at: Span,\n }\n \n@@ -179,12 +181,11 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let _ignore = mir_body;\n         let id = self.next_counter();\n         let function_source_hash = self.function_source_hash();\n-        let code_region = body_span;\n         let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n         let is_cleanup = false;\n         let next_block = rustc_middle::mir::START_BLOCK;\n         self.inject_call(\n-            self.make_counter(id, function_source_hash, code_region),\n+            self.make_counter(id, function_source_hash, body_span),\n             scope,\n             is_cleanup,\n             next_block,\n@@ -201,28 +202,22 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             let op = if add { Op::Add } else { Op::Subtract };\n             let rhs = 2;\n \n-            let code_region = body_span;\n             let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n             let is_cleanup = false;\n             let next_block = rustc_middle::mir::START_BLOCK;\n \n             let id = self.next_expression();\n             self.inject_call(\n-                self.make_expression(id, code_region, lhs, op, rhs),\n+                self.make_expression(id, body_span, lhs, op, rhs),\n                 scope,\n                 is_cleanup,\n                 next_block,\n             );\n         }\n     }\n \n-    fn make_counter(\n-        &self,\n-        id: u32,\n-        function_source_hash: u64,\n-        code_region: Span,\n-    ) -> InjectedCall<'tcx> {\n-        let inject_at = code_region.shrink_to_lo();\n+    fn make_counter(&self, id: u32, function_source_hash: u64, span: Span) -> InjectedCall<'tcx> {\n+        let inject_at = span.shrink_to_lo();\n \n         let func = function_handle(\n             self.tcx,\n@@ -239,24 +234,18 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         debug_assert_eq!(COUNTER_ID, args.len());\n         args.push(self.const_u32(id, inject_at));\n \n-        debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n-\n-        debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n-\n-        InjectedCall { func, args, inject_at }\n+        InjectedCall { func, args, span, inject_at }\n     }\n \n     fn make_expression(\n         &self,\n         id: u32,\n-        code_region: Span,\n+        span: Span,\n         lhs: u32,\n         op: Op,\n         rhs: u32,\n     ) -> InjectedCall<'tcx> {\n-        let inject_at = code_region.shrink_to_lo();\n+        let inject_at = span.shrink_to_lo();\n \n         let func = function_handle(\n             self.tcx,\n@@ -282,13 +271,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         debug_assert_eq!(RIGHT_ID, args.len());\n         args.push(self.const_u32(rhs, inject_at));\n \n-        debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n-\n-        debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n-\n-        InjectedCall { func, args, inject_at }\n+        InjectedCall { func, args, span, inject_at }\n     }\n \n     fn inject_call(\n@@ -298,7 +281,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         is_cleanup: bool,\n         next_block: BasicBlock,\n     ) {\n-        let InjectedCall { func, args, inject_at } = call;\n+        let InjectedCall { func, mut args, span, inject_at } = call;\n         debug!(\n             \"  injecting {}call to {:?}({:?}) at: {:?}, scope: {:?}\",\n             if is_cleanup { \"cleanup \" } else { \"\" },\n@@ -310,6 +293,14 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         let mut patch = MirPatch::new(self.mir_body);\n \n+        let (file_name, start_line, start_col, end_line, end_col) = self.code_region(&span);\n+\n+        args.push(self.const_str(&file_name, inject_at));\n+        args.push(self.const_u32(start_line, inject_at));\n+        args.push(self.const_u32(start_col, inject_at));\n+        args.push(self.const_u32(end_line, inject_at));\n+        args.push(self.const_u32(end_col, inject_at));\n+\n         let temp = patch.new_temp(self.tcx.mk_unit(), inject_at);\n         let new_block = patch.new_block(placeholder_block(inject_at, scope, is_cleanup));\n         patch.patch_terminator(\n@@ -335,6 +326,43 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         self.mir_body.basic_blocks_mut().swap(next_block, new_block);\n     }\n \n+    /// Convert the Span into its file name, start line and column, and end line and column\n+    fn code_region(&self, span: &Span) -> (String, u32, u32, u32, u32) {\n+        let source_map = self.tcx.sess.source_map();\n+        let start = source_map.lookup_char_pos(span.lo());\n+        let end = if span.hi() == span.lo() {\n+            start.clone()\n+        } else {\n+            let end = source_map.lookup_char_pos(span.hi());\n+            debug_assert_eq!(\n+                start.file.name,\n+                end.file.name,\n+                \"Region start ({:?} -> {:?}) and end ({:?} -> {:?}) don't come from the same source file!\",\n+                span.lo(),\n+                start,\n+                span.hi(),\n+                end\n+            );\n+            end\n+        };\n+        match &start.file.name {\n+            FileName::Real(RealFileName::Named(path)) => (\n+                path.to_string_lossy().to_string(),\n+                start.line as u32,\n+                start.col.to_u32() + 1,\n+                end.line as u32,\n+                end.col.to_u32() + 1,\n+            ),\n+            _ => {\n+                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n+            }\n+        }\n+    }\n+\n+    fn const_str(&self, value: &str, span: Span) -> Operand<'tcx> {\n+        Operand::const_from_str(self.tcx, value, span)\n+    }\n+\n     fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n         Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n     }"}, {"sha": "f1a7338d11fd966180551bf5078984e23c5aae18", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -524,7 +524,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                         // The `is_empty` predicate is introduced to exclude the case\n                                         // where the projection operations are [ .field, * ].\n                                         // The reason is because promotion will be illegal if field\n-                                        // accesses preceed the dereferencing.\n+                                        // accesses precede the dereferencing.\n                                         // Discussion can be found at\n                                         // https://github.com/rust-lang/rust/pull/74945#discussion_r463063247\n                                         // There may be opportunity for generalization, but this needs to be"}, {"sha": "34fa840408f79a7d213bf4e25c40fccc7b975d4b", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -193,7 +193,15 @@ fn check_rvalue(\n             _,\n         ) => Err((span, \"function pointer casts are not allowed in const fn\".into())),\n         Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), op, cast_ty) => {\n-            let pointee_ty = cast_ty.builtin_deref(true).unwrap().ty;\n+            let pointee_ty = if let Some(deref_ty) = cast_ty.builtin_deref(true) {\n+                deref_ty.ty\n+            } else {\n+                // We cannot allow this for now.\n+                return Err((\n+                    span,\n+                    \"unsizing casts are only allowed for references right now\".into(),\n+                ));\n+            };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n             if let ty::Slice(_) | ty::Str = unsized_ty.kind {\n                 check_operand(tcx, op, span, def_id, body)?;"}, {"sha": "d8995e92abfcc7dbd780569f41dfbfebc7a35221", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -142,8 +142,6 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n                 }\n \n                 self.basic_blocks[bb].terminator = Some(terminator);\n-\n-                changed |= inner_changed;\n             }\n \n             if !changed {\n@@ -212,6 +210,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n                 Terminator { kind: TerminatorKind::Goto { ref mut target }, .. } => target,\n                 _ => unreachable!(),\n             };\n+            *changed |= *target != last;\n             *target = last;\n             debug!(\"collapsing goto chain from {:?} to {:?}\", current, target);\n \n@@ -223,7 +222,6 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n                 self.pred_count[*target] += 1;\n                 self.pred_count[current] -= 1;\n             }\n-            *changed = true;\n             self.basic_blocks[current].terminator = Some(terminator);\n         }\n     }"}, {"sha": "daff10eb194f83fa15c6003f8f34094ef4533f61", "filename": "src/librustc_mir_build/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -133,7 +133,7 @@ crate enum PatKind<'tcx> {\n         var: hir::HirId,\n         ty: Ty<'tcx>,\n         subpattern: Option<Pat<'tcx>>,\n-        /// Is this the leftmost occurance of the binding, i.e., is `var` the\n+        /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n         /// `HirId` of this pattern?\n         is_primary: bool,\n     },"}, {"sha": "25144bd610d3e11b3cce06a00cc1ec6b4565bc22", "filename": "src/librustc_parse/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2FCargo.toml?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -21,3 +21,4 @@ rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n unicode-normalization = \"0.1.11\"\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "3319ca44da467caa38ad8226e918fc5d4a767ed1", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 185, "deletions": 3, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -7,14 +7,16 @@\n #![feature(or_patterns)]\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, Nonterminal};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n-use rustc_span::{FileName, SourceFile, Span};\n+use rustc_span::{symbol::kw, FileName, SourceFile, Span, DUMMY_SP};\n \n+use smallvec::SmallVec;\n+use std::mem;\n use std::path::Path;\n use std::str;\n \n@@ -306,7 +308,7 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // modifications, including adding/removing typically non-semantic\n     // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n+        if tokenstream_probably_equal_for_proc_macro(&tokens, &tokens_for_real) {\n             return tokens;\n         }\n         info!(\n@@ -319,6 +321,186 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     tokens_for_real\n }\n \n+// See comments in `Nonterminal::to_tokenstream` for why we care about\n+// *probably* equal here rather than actual equality\n+//\n+// This is otherwise the same as `eq_unspanned`, only recursing with a\n+// different method.\n+pub fn tokenstream_probably_equal_for_proc_macro(first: &TokenStream, other: &TokenStream) -> bool {\n+    // When checking for `probably_eq`, we ignore certain tokens that aren't\n+    // preserved in the AST. Because they are not preserved, the pretty\n+    // printer arbitrarily adds or removes them when printing as token\n+    // streams, making a comparison between a token stream generated from an\n+    // AST and a token stream which was parsed into an AST more reliable.\n+    fn semantic_tree(tree: &TokenTree) -> bool {\n+        if let TokenTree::Token(token) = tree {\n+            if let\n+                // The pretty printer tends to add trailing commas to\n+                // everything, and in particular, after struct fields.\n+                | token::Comma\n+                // The pretty printer emits `NoDelim` as whitespace.\n+                | token::OpenDelim(DelimToken::NoDelim)\n+                | token::CloseDelim(DelimToken::NoDelim)\n+                // The pretty printer collapses many semicolons into one.\n+                | token::Semi\n+                // The pretty printer collapses whitespace arbitrarily and can\n+                // introduce whitespace from `NoDelim`.\n+                | token::Whitespace\n+                // The pretty printer can turn `$crate` into `::crate_name`\n+                | token::ModSep = token.kind {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n+    //\n+    // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n+    // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n+    // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n+    // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n+    // when determining if two `TokenStream`s are 'probably equal'.\n+    //\n+    // Therefore, we use `break_two_token_op` to convert all tokens\n+    // to the 'unglued' form (if it exists). This ensures that two\n+    // `TokenStream`s which differ only in how their tokens are glued\n+    // will be considered 'probably equal', which allows us to keep spans.\n+    //\n+    // This is important when the original `TokenStream` contained\n+    // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n+    // will be omitted when we pretty-print, which can cause the original\n+    // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n+    // leading to some tokens being 'glued' together in one stream but not\n+    // the other. See #68489 for more details.\n+    fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+        // In almost all cases, we should have either zero or one levels\n+        // of 'unglueing'. However, in some unusual cases, we may need\n+        // to iterate breaking tokens mutliple times. For example:\n+        // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+        let mut token_trees: SmallVec<[_; 2]>;\n+        if let TokenTree::Token(token) = &tree {\n+            let mut out = SmallVec::<[_; 2]>::new();\n+            out.push(token.clone());\n+            // Iterate to fixpoint:\n+            // * We start off with 'out' containing our initial token, and `temp` empty\n+            // * If we are able to break any tokens in `out`, then `out` will have\n+            //   at least one more element than 'temp', so we will try to break tokens\n+            //   again.\n+            // * If we cannot break any tokens in 'out', we are done\n+            loop {\n+                let mut temp = SmallVec::<[_; 2]>::new();\n+                let mut changed = false;\n+\n+                for token in out.into_iter() {\n+                    if let Some((first, second)) = token.kind.break_two_token_op() {\n+                        temp.push(Token::new(first, DUMMY_SP));\n+                        temp.push(Token::new(second, DUMMY_SP));\n+                        changed = true;\n+                    } else {\n+                        temp.push(token);\n+                    }\n+                }\n+                out = temp;\n+                if !changed {\n+                    break;\n+                }\n+            }\n+            token_trees = out.into_iter().map(TokenTree::Token).collect();\n+            if token_trees.len() != 1 {\n+                debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n+            }\n+        } else {\n+            token_trees = SmallVec::new();\n+            token_trees.push(tree);\n+        }\n+        token_trees.into_iter()\n+    }\n+\n+    let mut t1 = first.trees().filter(semantic_tree).flat_map(break_tokens);\n+    let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n+    for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+        if !tokentree_probably_equal_for_proc_macro(&t1, &t2) {\n+            return false;\n+        }\n+    }\n+    t1.next().is_none() && t2.next().is_none()\n+}\n+\n+// See comments in `Nonterminal::to_tokenstream` for why we care about\n+// *probably* equal here rather than actual equality\n+//\n+// This is otherwise the same as `eq_unspanned`, only recursing with a\n+// different method.\n+fn tokentree_probably_equal_for_proc_macro(first: &TokenTree, other: &TokenTree) -> bool {\n+    match (first, other) {\n+        (TokenTree::Token(token), TokenTree::Token(token2)) => {\n+            token_probably_equal_for_proc_macro(token, token2)\n+        }\n+        (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n+            delim == delim2 && tokenstream_probably_equal_for_proc_macro(&tts, &tts2)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+// See comments in `Nonterminal::to_tokenstream` for why we care about\n+// *probably* equal here rather than actual equality\n+fn token_probably_equal_for_proc_macro(first: &Token, other: &Token) -> bool {\n+    if mem::discriminant(&first.kind) != mem::discriminant(&other.kind) {\n+        return false;\n+    }\n+    use rustc_ast::token::TokenKind::*;\n+    match (&first.kind, &other.kind) {\n+        (&Eq, &Eq)\n+        | (&Lt, &Lt)\n+        | (&Le, &Le)\n+        | (&EqEq, &EqEq)\n+        | (&Ne, &Ne)\n+        | (&Ge, &Ge)\n+        | (&Gt, &Gt)\n+        | (&AndAnd, &AndAnd)\n+        | (&OrOr, &OrOr)\n+        | (&Not, &Not)\n+        | (&Tilde, &Tilde)\n+        | (&At, &At)\n+        | (&Dot, &Dot)\n+        | (&DotDot, &DotDot)\n+        | (&DotDotDot, &DotDotDot)\n+        | (&DotDotEq, &DotDotEq)\n+        | (&Comma, &Comma)\n+        | (&Semi, &Semi)\n+        | (&Colon, &Colon)\n+        | (&ModSep, &ModSep)\n+        | (&RArrow, &RArrow)\n+        | (&LArrow, &LArrow)\n+        | (&FatArrow, &FatArrow)\n+        | (&Pound, &Pound)\n+        | (&Dollar, &Dollar)\n+        | (&Question, &Question)\n+        | (&Whitespace, &Whitespace)\n+        | (&Comment, &Comment)\n+        | (&Eof, &Eof) => true,\n+\n+        (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n+\n+        (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n+\n+        (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n+\n+        (&Literal(a), &Literal(b)) => a == b,\n+\n+        (&Lifetime(a), &Lifetime(b)) => a == b,\n+        (&Ident(a, b), &Ident(c, d)) => {\n+            b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n+        }\n+\n+        (&Interpolated(..), &Interpolated(..)) => false,\n+\n+        _ => panic!(\"forgot to add a token?\"),\n+    }\n+}\n+\n fn prepend_attrs(\n     sess: &ParseSess,\n     attrs: &[ast::Attribute],"}, {"sha": "5e9411327cabdd6d7dc3ea71cac17274008019c4", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -333,6 +333,7 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable\n                     },\n                 );\n+                self.sess.type_ascription_path_suggestions.borrow_mut().insert(sp);\n             } else if op_pos.line != next_pos.line && maybe_expected_semicolon {\n                 err.span_suggestion(\n                     sp,"}, {"sha": "3aec300d86d4f5dcb6bb6cf386fb3b8c9d1d64e4", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1450,7 +1450,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     /// Keep this in sync with `Token::can_begin_literal_maybe_minus`.\n-    pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+    pub(super) fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         let lo = self.token.span;"}, {"sha": "2509a9792215d553379da4acdf0ce201045c94e1", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,16 +1,17 @@\n pub mod attr;\n+mod diagnostics;\n mod expr;\n+mod generics;\n mod item;\n+mod nonterminal;\n mod pat;\n mod path;\n-mod ty;\n-pub use path::PathStyle;\n-mod diagnostics;\n-mod generics;\n mod stmt;\n-use diagnostics::Error;\n+mod ty;\n \n use crate::lexer::UnmatchedBrace;\n+use diagnostics::Error;\n+pub use path::PathStyle;\n \n use log::debug;\n use rustc_ast::ast::DUMMY_NODE_ID;\n@@ -958,7 +959,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> TokenTree {\n+    pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n                 let frame = mem::replace(\n@@ -1017,7 +1018,7 @@ impl<'a> Parser<'a> {\n     /// If the following element can't be a tuple (i.e., it's a function definition), then\n     /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n     /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n+    pub(crate) fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));"}, {"sha": "12139771bbfdaa172c9d4cc9f0d7026fd59ab8a1", "filename": "src/librustc_parse/parser/nonterminal.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,163 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::token::{self, Nonterminal, NonterminalKind, Token};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::PResult;\n+use rustc_span::symbol::{kw, Ident};\n+\n+use crate::parser::{FollowedByType, Parser, PathStyle};\n+\n+impl<'a> Parser<'a> {\n+    /// Checks whether a non-terminal may begin with a particular token.\n+    ///\n+    /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n+    /// token. Be conservative (return true) if not sure.\n+    pub fn nonterminal_may_begin_with(kind: NonterminalKind, token: &Token) -> bool {\n+        /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n+        fn may_be_ident(nt: &token::Nonterminal) -> bool {\n+            match *nt {\n+                token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => {\n+                    false\n+                }\n+                _ => true,\n+            }\n+        }\n+\n+        match kind {\n+            NonterminalKind::Expr => {\n+                token.can_begin_expr()\n+                // This exception is here for backwards compatibility.\n+                && !token.is_keyword(kw::Let)\n+            }\n+            NonterminalKind::Ty => token.can_begin_type(),\n+            NonterminalKind::Ident => get_macro_ident(token).is_some(),\n+            NonterminalKind::Literal => token.can_begin_literal_maybe_minus(),\n+            NonterminalKind::Vis => match token.kind {\n+                // The follow-set of :vis + \"priv\" keyword + interpolated\n+                token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n+                _ => token.can_begin_type(),\n+            },\n+            NonterminalKind::Block => match token.kind {\n+                token::OpenDelim(token::Brace) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtItem(_)\n+                    | token::NtPat(_)\n+                    | token::NtTy(_)\n+                    | token::NtIdent(..)\n+                    | token::NtMeta(_)\n+                    | token::NtPath(_)\n+                    | token::NtVis(_) => false, // none of these may start with '{'.\n+                    _ => true,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n+                token::ModSep | token::Ident(..) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtPath(_) | token::NtMeta(_) => true,\n+                    _ => may_be_ident(&nt),\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Pat => match token.kind {\n+                token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n+                token::OpenDelim(token::Paren) |    // tuple pattern\n+                token::OpenDelim(token::Bracket) |  // slice pattern\n+                token::BinOp(token::And) |          // reference\n+                token::BinOp(token::Minus) |        // negative literal\n+                token::AndAnd |                     // double reference\n+                token::Literal(..) |                // literal\n+                token::DotDot |                     // range pattern (future compat)\n+                token::DotDotDot |                  // range pattern (future compat)\n+                token::ModSep |                     // path\n+                token::Lt |                         // path (UFCS constant)\n+                token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                token::Interpolated(ref nt) => may_be_ident(nt),\n+                _ => false,\n+            },\n+            NonterminalKind::Lifetime => match token.kind {\n+                token::Lifetime(_) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtLifetime(_) | token::NtTT(_) => true,\n+                    _ => false,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::TT | NonterminalKind::Item | NonterminalKind::Stmt => match token.kind\n+            {\n+                token::CloseDelim(_) => false,\n+                _ => true,\n+            },\n+        }\n+    }\n+\n+    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n+        // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n+        // needs to have them force-captured here.\n+        // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n+        // which requires having captured tokens available. Since we cannot determine\n+        // in advance whether or not a proc-macro will be (transitively) invoked,\n+        // we always capture tokens for any `Nonterminal` which needs them.\n+        Ok(match kind {\n+            NonterminalKind::Item => match self.collect_tokens(|this| this.parse_item())? {\n+                (Some(mut item), tokens) => {\n+                    // If we captured tokens during parsing (due to outer attributes),\n+                    // use those.\n+                    if item.tokens.is_none() {\n+                        item.tokens = Some(tokens);\n+                    }\n+                    token::NtItem(item)\n+                }\n+                (None, _) => {\n+                    return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n+                }\n+            },\n+            NonterminalKind::Block => token::NtBlock(self.parse_block()?),\n+            NonterminalKind::Stmt => match self.parse_stmt()? {\n+                Some(s) => token::NtStmt(s),\n+                None => return Err(self.struct_span_err(self.token.span, \"expected a statement\")),\n+            },\n+            NonterminalKind::Pat => token::NtPat(self.parse_pat(None)?),\n+            NonterminalKind::Expr => {\n+                let (mut expr, tokens) = self.collect_tokens(|this| this.parse_expr())?;\n+                // If we captured tokens during parsing (due to outer attributes),\n+                // use those.\n+                if expr.tokens.is_none() {\n+                    expr.tokens = Some(tokens);\n+                }\n+                token::NtExpr(expr)\n+            }\n+            NonterminalKind::Literal => token::NtLiteral(self.parse_literal_maybe_minus()?),\n+            NonterminalKind::Ty => token::NtTy(self.parse_ty()?),\n+            // this could be handled like a token, since it is one\n+            NonterminalKind::Ident => {\n+                if let Some((ident, is_raw)) = get_macro_ident(&self.token) {\n+                    self.bump();\n+                    token::NtIdent(ident, is_raw)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected ident, found {}\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+            NonterminalKind::Path => token::NtPath(self.parse_path(PathStyle::Type)?),\n+            NonterminalKind::Meta => token::NtMeta(P(self.parse_attr_item()?)),\n+            NonterminalKind::TT => token::NtTT(self.parse_token_tree()),\n+            NonterminalKind::Vis => token::NtVis(self.parse_visibility(FollowedByType::Yes)?),\n+            NonterminalKind::Lifetime => {\n+                if self.check_lifetime() {\n+                    token::NtLifetime(self.expect_lifetime().ident)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// The token is an identifier, but not `_`.\n+/// We prohibit passing `_` to macros expecting `ident` for now.\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n+    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n+}"}, {"sha": "d4e44c54b127405fdcdc4c11fe474dda129938f5", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+    pub(super) fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {"}, {"sha": "5c3a5e9987324c93f4c56aab60dbd88bc4797d86", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub(super) fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n@@ -247,7 +247,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. No inner attributes are allowed.\n-    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+    pub(super) fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         let (attrs, block) = self.parse_inner_attrs_and_block()?;\n         if let [.., last] = &*attrs {\n             self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);"}, {"sha": "cd66b917f232a016e9912d81c1e329dd3d784828", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -610,13 +610,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn check_lifetime(&mut self) -> bool {\n+    pub(super) fn check_lifetime(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Lifetime);\n         self.token.is_lifetime()\n     }\n \n     /// Parses a single lifetime `'a` or panics.\n-    pub fn expect_lifetime(&mut self) -> Lifetime {\n+    pub(super) fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n             self.bump();\n             Lifetime { ident, id: ast::DUMMY_NODE_ID }"}, {"sha": "1ff47ee038d3bf9703f098431122dbc7d64dc93c", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -222,7 +222,7 @@ impl CheckAttrVisitor<'tcx> {\n         if let Some(mi) = attr.meta() {\n             if let Some(list) = mi.meta_item_list() {\n                 for meta in list {\n-                    if meta.check_name(sym::alias) {\n+                    if meta.has_name(sym::alias) {\n                         if !meta.is_value_str()\n                             || meta\n                                 .value_str()"}, {"sha": "be3d3607728547c995dac174fdbb2b8c98db0921", "filename": "src/librustc_query_system/cache.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_query_system%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_query_system%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fcache.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,62 @@\n+//! Cache for candidate selection.\n+\n+use crate::dep_graph::DepNodeIndex;\n+use crate::query::QueryContext;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::HashMapExt;\n+use rustc_data_structures::sync::Lock;\n+\n+use std::hash::Hash;\n+\n+#[derive(Clone)]\n+pub struct Cache<Key, Value> {\n+    hashmap: Lock<FxHashMap<Key, WithDepNode<Value>>>,\n+}\n+\n+impl<Key, Value> Default for Cache<Key, Value> {\n+    fn default() -> Self {\n+        Self { hashmap: Default::default() }\n+    }\n+}\n+\n+impl<Key, Value> Cache<Key, Value> {\n+    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = Default::default();\n+    }\n+}\n+\n+impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n+    pub fn get<CTX: QueryContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+        Some(self.hashmap.borrow().get(key)?.get(tcx))\n+    }\n+\n+    pub fn insert(&self, key: Key, dep_node: DepNodeIndex, value: Value) {\n+        self.hashmap.borrow_mut().insert(key, WithDepNode::new(dep_node, value));\n+    }\n+\n+    pub fn insert_same(&self, key: Key, dep_node: DepNodeIndex, value: Value)\n+    where\n+        Value: Eq,\n+    {\n+        self.hashmap.borrow_mut().insert_same(key, WithDepNode::new(dep_node, value));\n+    }\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T,\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get<CTX: QueryContext>(&self, tcx: CTX) -> T {\n+        tcx.dep_graph().read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}, {"sha": "4bbba7befe93f00363e03a8b458cca79f19f6e0d", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -11,5 +11,6 @@ extern crate log;\n #[macro_use]\n extern crate rustc_data_structures;\n \n+pub mod cache;\n pub mod dep_graph;\n pub mod query;"}, {"sha": "44ff4209095418473d9f4a4d749cb9c7f3be9242", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1510,30 +1510,18 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         pat_src: PatternSource,\n         bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) {\n-        let is_tuple_struct_pat = matches!(pat.kind, PatKind::TupleStruct(_, _));\n-\n         // Visit all direct subpatterns of this pattern.\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.kind);\n             match pat.kind {\n                 PatKind::Ident(bmode, ident, ref sub) => {\n-                    if is_tuple_struct_pat && sub.as_ref().filter(|p| p.is_rest()).is_some() {\n-                        // In tuple struct patterns ignore the invalid `ident @ ...`.\n-                        // It will be handled as an error by the AST lowering.\n-                        self.r\n-                            .session\n-                            .delay_span_bug(ident.span, \"ident in tuple pattern is invalid\");\n-                    } else {\n-                        // First try to resolve the identifier as some existing entity,\n-                        // then fall back to a fresh binding.\n-                        let has_sub = sub.is_some();\n-                        let res = self\n-                            .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n-                            .unwrap_or_else(|| {\n-                                self.fresh_binding(ident, pat.id, pat_src, bindings)\n-                            });\n-                        self.r.record_partial_res(pat.id, PartialRes::new(res));\n-                    }\n+                    // First try to resolve the identifier as some existing entity,\n+                    // then fall back to a fresh binding.\n+                    let has_sub = sub.is_some();\n+                    let res = self\n+                        .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n+                    self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n                 PatKind::TupleStruct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct(pat.span));\n@@ -2241,8 +2229,15 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.resolve_expr(argument, None);\n                 }\n             }\n-            ExprKind::Type(ref type_expr, _) => {\n-                self.diagnostic_metadata.current_type_ascription.push(type_expr.span);\n+            ExprKind::Type(ref type_expr, ref ty) => {\n+                // `ParseSess::type_ascription_path_suggestions` keeps spans of colon tokens in\n+                // type ascription. Here we are trying to retrieve the span of the colon token as\n+                // well, but only if it's written without spaces `expr:Ty` and therefore confusable\n+                // with `expr::Ty`, only in this case it will match the span from\n+                // `type_ascription_path_suggestions`.\n+                self.diagnostic_metadata\n+                    .current_type_ascription\n+                    .push(type_expr.span.between(ty.span));\n                 visit::walk_expr(self, expr);\n                 self.diagnostic_metadata.current_type_ascription.pop();\n             }"}, {"sha": "ec6dbb070dfa8cdd1ae10fadfa884924a8b83ba6", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 117, "deletions": 78, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span};\n \n use log::debug;\n \n@@ -223,13 +223,31 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n             let enum_candidates =\n                 self.r.lookup_import_candidates(ident, ns, &self.parent_scope, is_enum_variant);\n-            let mut enum_candidates = enum_candidates\n-                .iter()\n-                .map(|suggestion| import_candidate_to_enum_paths(&suggestion))\n-                .collect::<Vec<_>>();\n-            enum_candidates.sort();\n \n             if !enum_candidates.is_empty() {\n+                if let (PathSource::Type, Some(span)) =\n+                    (source, self.diagnostic_metadata.current_type_ascription.last())\n+                {\n+                    if self\n+                        .r\n+                        .session\n+                        .parse_sess\n+                        .type_ascription_path_suggestions\n+                        .borrow()\n+                        .contains(span)\n+                    {\n+                        // Already reported this issue on the lhs of the type ascription.\n+                        err.delay_as_bug();\n+                        return (err, candidates);\n+                    }\n+                }\n+\n+                let mut enum_candidates = enum_candidates\n+                    .iter()\n+                    .map(|suggestion| import_candidate_to_enum_paths(&suggestion))\n+                    .collect::<Vec<_>>();\n+                enum_candidates.sort();\n+\n                 // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n                 // (that it's a variant) for E0573 \"expected type, found variant\".\n                 let preamble = if res.is_none() {\n@@ -484,10 +502,21 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n             match source {\n                 PathSource::Expr(Some(\n                     parent @ Expr { kind: ExprKind::Field(..) | ExprKind::MethodCall(..), .. },\n-                )) => {\n-                    path_sep(err, &parent);\n-                }\n-                PathSource::Expr(None) if followed_by_brace => {\n+                )) if path_sep(err, &parent) => {}\n+                PathSource::Expr(\n+                    None\n+                    | Some(Expr {\n+                        kind:\n+                            ExprKind::Path(..)\n+                            | ExprKind::Binary(..)\n+                            | ExprKind::Unary(..)\n+                            | ExprKind::If(..)\n+                            | ExprKind::While(..)\n+                            | ExprKind::ForLoop(..)\n+                            | ExprKind::Match(..),\n+                        ..\n+                    }),\n+                ) if followed_by_brace => {\n                     if let Some(sp) = closing_brace {\n                         err.multipart_suggestion(\n                             \"surround the struct literal with parentheses\",\n@@ -508,11 +537,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         );\n                     }\n                 }\n-                PathSource::Expr(\n-                    None | Some(Expr { kind: ExprKind::Call(..) | ExprKind::Path(..), .. }),\n-                )\n-                | PathSource::TupleStruct(_)\n-                | PathSource::Pat => {\n+                PathSource::Expr(_) | PathSource::TupleStruct(_) | PathSource::Pat => {\n                     let span = match &source {\n                         PathSource::Expr(Some(Expr {\n                             span, kind: ExprKind::Call(_, _), ..\n@@ -593,6 +618,24 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 Res::Def(DefKind::Enum, def_id),\n                 PathSource::TupleStruct(_) | PathSource::Expr(..),\n             ) => {\n+                if self\n+                    .diagnostic_metadata\n+                    .current_type_ascription\n+                    .last()\n+                    .map(|sp| {\n+                        self.r\n+                            .session\n+                            .parse_sess\n+                            .type_ascription_path_suggestions\n+                            .borrow()\n+                            .contains(&sp)\n+                    })\n+                    .unwrap_or(false)\n+                {\n+                    err.delay_as_bug();\n+                    // We already suggested changing `:` into `::` during parsing.\n+                    return false;\n+                }\n                 if let Some(variants) = self.collect_enum_variants(def_id) {\n                     if !variants.is_empty() {\n                         let msg = if variants.len() == 1 {\n@@ -609,7 +652,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         );\n                     }\n                 } else {\n-                    err.note(\"did you mean to use one of the enum's variants?\");\n+                    err.note(\"you might have meant to use one of the enum's variants\");\n                 }\n             }\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n@@ -829,77 +872,73 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n     fn type_ascription_suggestion(&self, err: &mut DiagnosticBuilder<'_>, base_span: Span) {\n         let sm = self.r.session.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n-        if let Some(sp) = self.diagnostic_metadata.current_type_ascription.last() {\n-            let mut sp = *sp;\n-            loop {\n-                // Try to find the `:`; bail on first non-':' / non-whitespace.\n-                sp = sm.next_point(sp);\n-                if let Ok(snippet) = sm.span_to_snippet(sp.to(sm.next_point(sp))) {\n-                    let line_sp = sm.lookup_char_pos(sp.hi()).line;\n-                    let line_base_sp = sm.lookup_char_pos(base_span.lo()).line;\n-                    if snippet == \":\" {\n-                        let mut show_label = true;\n-                        if line_sp != line_base_sp {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"did you mean to use `;` here instead?\",\n-                                \";\".to_string(),\n+        if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n+            if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                let len = snippet.trim_end().len() as u32;\n+                if snippet.trim() == \":\" {\n+                    let colon_sp =\n+                        sp.with_lo(sp.lo() + BytePos(len - 1)).with_hi(sp.lo() + BytePos(len));\n+                    let mut show_label = true;\n+                    if sm.is_multiline(sp) {\n+                        err.span_suggestion_short(\n+                            colon_sp,\n+                            \"maybe you meant to write `;` here\",\n+                            \";\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        let after_colon_sp =\n+                            self.get_colon_suggestion_span(colon_sp.shrink_to_hi());\n+                        if snippet.len() == 1 {\n+                            // `foo:bar`\n+                            err.span_suggestion(\n+                                colon_sp,\n+                                \"maybe you meant to write a path separator here\",\n+                                \"::\".to_string(),\n                                 Applicability::MaybeIncorrect,\n                             );\n-                        } else {\n-                            let colon_sp = self.get_colon_suggestion_span(sp);\n-                            let after_colon_sp =\n-                                self.get_colon_suggestion_span(colon_sp.shrink_to_hi());\n-                            if !sm\n-                                .span_to_snippet(after_colon_sp)\n-                                .map(|s| s == \" \")\n-                                .unwrap_or(false)\n+                            show_label = false;\n+                            if !self\n+                                .r\n+                                .session\n+                                .parse_sess\n+                                .type_ascription_path_suggestions\n+                                .borrow_mut()\n+                                .insert(colon_sp)\n                             {\n-                                err.span_suggestion(\n-                                    colon_sp,\n-                                    \"maybe you meant to write a path separator here\",\n-                                    \"::\".to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                show_label = false;\n+                                err.delay_as_bug();\n                             }\n-                            if let Ok(base_snippet) = base_snippet {\n-                                let mut sp = after_colon_sp;\n-                                for _ in 0..100 {\n-                                    // Try to find an assignment\n-                                    sp = sm.next_point(sp);\n-                                    let snippet = sm.span_to_snippet(sp.to(sm.next_point(sp)));\n-                                    match snippet {\n-                                        Ok(ref x) if x.as_str() == \"=\" => {\n-                                            err.span_suggestion(\n-                                                base_span,\n-                                                \"maybe you meant to write an assignment here\",\n-                                                format!(\"let {}\", base_snippet),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                            show_label = false;\n-                                            break;\n-                                        }\n-                                        Ok(ref x) if x.as_str() == \"\\n\" => break,\n-                                        Err(_) => break,\n-                                        Ok(_) => {}\n+                        }\n+                        if let Ok(base_snippet) = base_snippet {\n+                            let mut sp = after_colon_sp;\n+                            for _ in 0..100 {\n+                                // Try to find an assignment\n+                                sp = sm.next_point(sp);\n+                                let snippet = sm.span_to_snippet(sp.to(sm.next_point(sp)));\n+                                match snippet {\n+                                    Ok(ref x) if x.as_str() == \"=\" => {\n+                                        err.span_suggestion(\n+                                            base_span,\n+                                            \"maybe you meant to write an assignment here\",\n+                                            format!(\"let {}\", base_snippet),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                        show_label = false;\n+                                        break;\n                                     }\n+                                    Ok(ref x) if x.as_str() == \"\\n\" => break,\n+                                    Err(_) => break,\n+                                    Ok(_) => {}\n                                 }\n                             }\n                         }\n-                        if show_label {\n-                            err.span_label(\n-                                base_span,\n-                                \"expecting a type here because of type ascription\",\n-                            );\n-                        }\n-                        break;\n-                    } else if !snippet.trim().is_empty() {\n-                        debug!(\"tried to find type ascription `:` token, couldn't find it\");\n-                        break;\n                     }\n-                } else {\n-                    break;\n+                    if show_label {\n+                        err.span_label(\n+                            base_span,\n+                            \"expecting a type here because of type ascription\",\n+                        );\n+                    }\n                 }\n             }\n         }"}, {"sha": "ccc7e16ae4cf667059a7e3c192d059311ce06de7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1020,7 +1020,7 @@ impl<'a> Resolver<'a> {\n         }\n         if let Some(depr) = &ext.deprecation {\n             let path = pprust::path_to_string(&path);\n-            let (message, lint) = stability::deprecation_message(depr, &path);\n+            let (message, lint) = stability::deprecation_message(depr, \"macro\", &path);\n             stability::early_report_deprecation(\n                 &mut self.lint_buffer,\n                 &message,"}, {"sha": "8e379a3510038d916c88f34705ac5797fcb77710", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -832,10 +832,10 @@ impl<'tcx> SaveContext<'tcx> {\n                 if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list\n                         .into_iter()\n-                        .filter(|it| it.check_name(sym::include))\n+                        .filter(|it| it.has_name(sym::include))\n                         .filter_map(|it| it.meta_item_list().map(|l| l.to_owned()))\n                         .flat_map(|it| it)\n-                        .filter(|meta| meta.check_name(sym::contents))\n+                        .filter(|meta| meta.has_name(sym::contents))\n                         .filter_map(|meta| meta.value_str())\n                         .for_each(|val| {\n                             result.push_str(&val.as_str());"}, {"sha": "9fcdd46539c46f15aee8c50306f9f58af128ea18", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1717,7 +1717,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n \n         // `-Z instrument-coverage` implies:\n-        //   * `-Z symbol-mangling-version=v0` - to ensure consistent and reversable name mangling.\n+        //   * `-Z symbol-mangling-version=v0` - to ensure consistent and reversible name mangling.\n         //     Note, LLVM coverage tools can analyze coverage over multiple runs, including some\n         //     changes to source code; so mangled names must be consistent across compilations.\n         //   * `-C link-dead-code` - so unexecuted code is still counted as zero, rather than be"}, {"sha": "9cdb7e966fef860d41608cca0e6a46e594cda302", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -63,7 +63,7 @@ impl GatedSpans {\n \n #[derive(Default)]\n pub struct SymbolGallery {\n-    /// All symbols occurred and their first occurrance span.\n+    /// All symbols occurred and their first occurrence span.\n     pub symbols: Lock<BTreeMap<Symbol, Span>>,\n }\n \n@@ -138,6 +138,8 @@ pub struct ParseSess {\n     pub reached_eof: Lock<bool>,\n     /// Environment variables accessed during the build and their values when they exist.\n     pub env_depinfo: Lock<FxHashSet<(Symbol, Option<Symbol>)>>,\n+    /// All the type ascriptions expressions that have had a suggestion for likely path typo.\n+    pub type_ascription_path_suggestions: Lock<FxHashSet<Span>>,\n }\n \n impl ParseSess {\n@@ -164,6 +166,7 @@ impl ParseSess {\n             symbol_gallery: SymbolGallery::default(),\n             reached_eof: Lock::new(false),\n             env_depinfo: Default::default(),\n+            type_ascription_path_suggestions: Default::default(),\n         }\n     }\n "}, {"sha": "a03ac4e1fdba1638c7f5adff9bcb76f2094db332", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -891,7 +891,7 @@ impl UseSpecializedDecodable for ExpnId {}\n \n #[derive(Default)]\n pub struct HygieneEncodeContext {\n-    /// All `SyntaxContexts` for which we have writen `SyntaxContextData` into crate metadata.\n+    /// All `SyntaxContexts` for which we have written `SyntaxContextData` into crate metadata.\n     /// This is `None` after we finish encoding `SyntaxContexts`, to ensure\n     /// that we don't accidentally try to encode any more `SyntaxContexts`\n     serialized_ctxts: Lock<FxHashSet<SyntaxContext>>,\n@@ -961,7 +961,7 @@ pub struct HygieneDecodeContext {\n     // Maps serialized `SyntaxContext` ids to a `SyntaxContext` in the current\n     // global `HygieneData`. When we deserialize a `SyntaxContext`, we need to create\n     // a new id in the global `HygieneData`. This map tracks the ID we end up picking,\n-    // so that multiple occurences of the same serialized id are decoded to the same\n+    // so that multiple occurrences of the same serialized id are decoded to the same\n     // `SyntaxContext`\n     remapped_ctxts: Lock<Vec<Option<SyntaxContext>>>,\n     // The same as `remapepd_ctxts`, but for `ExpnId`s"}, {"sha": "62fc8f06183b727d62f1c467ebe92c96d88aa5ba", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,13 +10,6 @@ pub fn options() -> TargetOptions {\n         clang_args.push(format!(\"-Wl,{}\", arg));\n     };\n \n-    // There have been reports in the wild (rustwasm/wasm-bindgen#119) of\n-    // using threads causing weird hangs and bugs. Disable it entirely as\n-    // this isn't yet the bottleneck of compilation at all anyway.\n-    //\n-    // FIXME: we should file an upstream issue with LLD about this\n-    arg(\"--no-threads\");\n-\n     // By default LLD only gives us one page of stack (64k) which is a\n     // little small. Default to a larger stack closer to other PC platforms\n     // (1MB) and users can always inject their own link-args to override this."}, {"sha": "446d5a489df48a6101c7547d638de1aabcea2dff", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -95,27 +95,27 @@ impl<'tcx> OnUnimplementedDirective {\n         };\n \n         for item in item_iter {\n-            if item.check_name(sym::message) && message.is_none() {\n+            if item.has_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = parse_value(message_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::label) && label.is_none() {\n+            } else if item.has_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = parse_value(label_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::note) && note.is_none() {\n+            } else if item.has_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = parse_value(note_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::enclosing_scope) && enclosing_scope.is_none() {\n+            } else if item.has_name(sym::enclosing_scope) && enclosing_scope.is_none() {\n                 if let Some(enclosing_scope_) = item.value_str() {\n                     enclosing_scope = parse_value(enclosing_scope_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::on)\n+            } else if item.has_name(sym::on)\n                 && is_root\n                 && message.is_none()\n                 && label.is_none()"}, {"sha": "75e11619924308ae39053483c9cd144d7ef3bd59", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -51,6 +51,47 @@ pub use rustc_middle::traits::select::*;\n mod candidate_assembly;\n mod confirmation;\n \n+#[derive(Clone, Debug)]\n+pub enum IntercrateAmbiguityCause {\n+    DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n+    UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n+    ReservationImpl { message: String },\n+}\n+\n+impl IntercrateAmbiguityCause {\n+    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n+    /// See #23980 for details.\n+    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n+        err.note(&self.intercrate_ambiguity_hint());\n+    }\n+\n+    pub fn intercrate_ambiguity_hint(&self) -> String {\n+        match self {\n+            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else {\n+                    String::new()\n+                };\n+                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n+            }\n+            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else {\n+                    String::new()\n+                };\n+                format!(\n+                    \"upstream crates may add a new impl of trait `{}`{} \\\n+                     in future versions\",\n+                    trait_desc, self_desc\n+                )\n+            }\n+            &IntercrateAmbiguityCause::ReservationImpl { ref message } => message.clone(),\n+        }\n+    }\n+}\n+\n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n@@ -833,17 +874,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Option<EvaluationResult> {\n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            let cache = tcx.evaluation_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&param_env.and(trait_ref)) {\n-                return Some(cached.get(tcx));\n+            if let Some(res) = tcx.evaluation_cache.get(&param_env.and(trait_ref), tcx) {\n+                return Some(res);\n             }\n         }\n-        self.infcx\n-            .evaluation_cache\n-            .hashmap\n-            .borrow()\n-            .get(&param_env.and(trait_ref))\n-            .map(|v| v.get(tcx))\n+        self.infcx.evaluation_cache.get(&param_env.and(trait_ref), tcx)\n     }\n \n     fn insert_evaluation_cache(\n@@ -869,21 +904,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // FIXME: Due to #50507 this overwrites the different values\n                 // This should be changed to use HashMapExt::insert_same\n                 // when that is fixed\n-                self.tcx()\n-                    .evaluation_cache\n-                    .hashmap\n-                    .borrow_mut()\n-                    .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n+                self.tcx().evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n                 return;\n             }\n         }\n \n         debug!(\"insert_evaluation_cache(trait_ref={:?}, candidate={:?})\", trait_ref, result,);\n-        self.infcx\n-            .evaluation_cache\n-            .hashmap\n-            .borrow_mut()\n-            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n+        self.infcx.evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n     }\n \n     /// For various reasons, it's possible for a subobligation\n@@ -1180,17 +1207,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let cache = tcx.selection_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&param_env.and(*trait_ref)) {\n-                return Some(cached.get(tcx));\n+            if let Some(res) = tcx.selection_cache.get(&param_env.and(*trait_ref), tcx) {\n+                return Some(res);\n             }\n         }\n-        self.infcx\n-            .selection_cache\n-            .hashmap\n-            .borrow()\n-            .get(&param_env.and(*trait_ref))\n-            .map(|v| v.get(tcx))\n+        self.infcx.selection_cache.get(&param_env.and(*trait_ref), tcx)\n     }\n \n     /// Determines whether can we safely cache the result\n@@ -1248,10 +1269,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         trait_ref, candidate,\n                     );\n                     // This may overwrite the cache with the same value.\n-                    tcx.selection_cache\n-                        .hashmap\n-                        .borrow_mut()\n-                        .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n+                    tcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n                     return;\n                 }\n             }\n@@ -1261,11 +1279,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) local\",\n             trait_ref, candidate,\n         );\n-        self.infcx\n-            .selection_cache\n-            .hashmap\n-            .borrow_mut()\n-            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n+        self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n     }\n \n     fn match_projection_obligation_against_definition_bounds("}, {"sha": "db8cdfc5b20d65ea7160c9b6f3bcc3637d38762f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -456,7 +456,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         //\n         // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n         //\n-        // We can take advantage of this fact to avoid performing unecessary work.\n+        // We can take advantage of this fact to avoid performing unnecessary work.\n         // If either `source` or `target` is a type variable, then any applicable impl\n         // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n         // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for"}, {"sha": "b3287caa0bfc879ed32249a4be2db575a34dc71f", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -379,17 +379,46 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n-            sym::count_code_region => {\n-                (0, vec![tcx.types.u64, tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n-            }\n+            sym::count_code_region => (\n+                0,\n+                vec![\n+                    tcx.types.u64,\n+                    tcx.types.u32,\n+                    tcx.mk_static_str(),\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                ],\n+                tcx.mk_unit(),\n+            ),\n \n             sym::coverage_counter_add | sym::coverage_counter_subtract => (\n                 0,\n-                vec![tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32],\n+                vec![\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.mk_static_str(),\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                ],\n                 tcx.mk_unit(),\n             ),\n \n-            sym::coverage_unreachable => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n+            sym::coverage_unreachable => (\n+                0,\n+                vec![\n+                    tcx.mk_static_str(),\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                    tcx.types.u32,\n+                ],\n+                tcx.mk_unit(),\n+            ),\n \n             other => {\n                 struct_span_err!("}, {"sha": "97df065500a1666885a4a0446705649ff9716893", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2231,7 +2231,7 @@ fn from_target_feature(\n     let rust_features = tcx.features();\n     for item in list {\n         // Only `enable = ...` is accepted in the meta-item list.\n-        if !item.check_name(sym::enable) {\n+        if !item.has_name(sym::enable) {\n             bad_item(item.span());\n             continue;\n         }\n@@ -2483,11 +2483,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             no_sanitize_span = Some(attr.span);\n             if let Some(list) = attr.meta_item_list() {\n                 for item in list.iter() {\n-                    if item.check_name(sym::address) {\n+                    if item.has_name(sym::address) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n-                    } else if item.check_name(sym::memory) {\n+                    } else if item.has_name(sym::memory) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.check_name(sym::thread) {\n+                    } else if item.has_name(sym::thread) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n                     } else {\n                         tcx.sess"}, {"sha": "e203d51f612aa5a8d93ce2f2d0a2eb7431088202", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -100,7 +100,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util;\n use rustc_session::config::EntryFnType;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -194,6 +194,23 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n                         .emit();\n                         error = true;\n                     }\n+\n+                    for attr in it.attrs {\n+                        if attr.check_name(sym::track_caller) {\n+                            tcx.sess\n+                                .struct_span_err(\n+                                    attr.span,\n+                                    \"`main` function is not allowed to be `#[track_caller]`\",\n+                                )\n+                                .span_label(\n+                                    main_span,\n+                                    \"`main` function is not allowed to be `#[track_caller]`\",\n+                                )\n+                                .emit();\n+                            error = true;\n+                        }\n+                    }\n+\n                     if error {\n                         return;\n                     }\n@@ -268,12 +285,29 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                             tcx.sess,\n                             span,\n                             E0752,\n-                            \"start is not allowed to be `async`\"\n+                            \"`start` is not allowed to be `async`\"\n                         )\n-                        .span_label(span, \"start is not allowed to be `async`\")\n+                        .span_label(span, \"`start` is not allowed to be `async`\")\n                         .emit();\n                         error = true;\n                     }\n+\n+                    for attr in it.attrs {\n+                        if attr.check_name(sym::track_caller) {\n+                            tcx.sess\n+                                .struct_span_err(\n+                                    attr.span,\n+                                    \"`start` is not allowed to be `#[track_caller]`\",\n+                                )\n+                                .span_label(\n+                                    start_span,\n+                                    \"`start` is not allowed to be `#[track_caller]`\",\n+                                )\n+                                .emit();\n+                            error = true;\n+                        }\n+                    }\n+\n                     if error {\n                         return;\n                     }"}, {"sha": "2a090d6efa5fd38a5bed05e08c4480e6d9bab3bb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -113,7 +113,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let mut prim = None;\n                 for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(sym::primitive) {\n+                        if attr.has_name(sym::primitive) {\n                             prim = PrimitiveType::from_symbol(v);\n                             if prim.is_some() {\n                                 break;\n@@ -168,7 +168,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let mut keyword = None;\n                 for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(sym::keyword) {\n+                        if attr.has_name(sym::keyword) {\n                             if v.is_doc_keyword() {\n                                 keyword = Some(v.to_string());\n                                 break;\n@@ -2157,7 +2157,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let please_inline = self.vis.node.is_pub()\n             && self.attrs.iter().any(|a| {\n-                a.check_name(sym::doc)\n+                a.has_name(sym::doc)\n                     && match a.meta_item_list() {\n                         Some(l) => attr::list_contains_name(&l, sym::inline),\n                         None => false,\n@@ -2197,7 +2197,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub()\n             || self.attrs.iter().any(|a| {\n-                a.check_name(sym::doc)\n+                a.has_name(sym::doc)\n                     && match a.meta_item_list() {\n                         Some(l) => {\n                             attr::list_contains_name(&l, sym::no_inline)"}, {"sha": "1bea41b658532f2d29e9e6d973713e7fef8e8cdb", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -210,7 +210,7 @@ impl Item {\n     }\n \n     pub fn is_non_exhaustive(&self) -> bool {\n-        self.attrs.other_attrs.iter().any(|a| a.check_name(sym::non_exhaustive))\n+        self.attrs.other_attrs.iter().any(|a| a.has_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -309,7 +309,7 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n \n         for attr in &mut self.attrs {\n             if let Some(list) = attr.meta_item_list() {\n-                if attr.check_name(self.name) {\n+                if attr.has_name(self.name) {\n                     self.current_list = list.into_iter();\n                     if let Some(nested) = self.current_list.next() {\n                         return Some(nested);\n@@ -345,7 +345,7 @@ pub trait NestedAttributesExt {\n \n impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n     fn has_word(self, word: Symbol) -> bool {\n-        self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n+        self.into_iter().any(|attr| attr.is_word() && attr.has_name(word))\n     }\n }\n \n@@ -425,7 +425,7 @@ impl Attributes {\n         if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n             if nmis.len() == 1 {\n                 if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.check_name(sym::cfg) {\n+                    if cfg_mi.has_name(sym::cfg) {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.kind {\n                             if cfg_nmis.len() == 1 {\n                                 if let MetaItem(ref content_mi) = cfg_nmis[0] {\n@@ -447,7 +447,7 @@ impl Attributes {\n     pub fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n-                if meta.check_name(sym::include) {\n+                if meta.has_name(sym::include) {\n                     // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n                     // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n                     // look for that instead\n@@ -456,11 +456,11 @@ impl Attributes {\n                         let mut contents: Option<String> = None;\n \n                         for it in list {\n-                            if it.check_name(sym::file) {\n+                            if it.has_name(sym::file) {\n                                 if let Some(name) = it.value_str() {\n                                     filename = Some(name.to_string());\n                                 }\n-                            } else if it.check_name(sym::contents) {\n+                            } else if it.has_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n                                     contents = Some(docs.to_string());\n                                 }\n@@ -482,12 +482,12 @@ impl Attributes {\n \n     pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n-            if !attr.check_name(sym::doc) {\n+            if !attr.has_name(sym::doc) {\n                 continue;\n             }\n \n             if let Some(items) = attr.meta_item_list() {\n-                if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n+                if items.iter().filter_map(|i| i.meta_item()).any(|it| it.has_name(flag)) {\n                     return true;\n                 }\n             }\n@@ -521,7 +521,7 @@ impl Attributes {\n                     }\n                     None\n                 } else {\n-                    if attr.check_name(sym::doc) {\n+                    if attr.has_name(sym::doc) {\n                         if let Some(mi) = attr.meta() {\n                             if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n                                 // Extracted #[doc(cfg(...))]\n@@ -548,7 +548,7 @@ impl Attributes {\n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n         // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n         for attr in attrs.lists(sym::target_feature) {\n-            if attr.check_name(sym::enable) {\n+            if attr.has_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(\n                         Ident::with_dummy_span(sym::target_feature),\n@@ -648,7 +648,7 @@ impl Attributes {\n     pub fn get_doc_aliases(&self) -> FxHashSet<String> {\n         self.other_attrs\n             .lists(sym::doc)\n-            .filter(|a| a.check_name(sym::alias))\n+            .filter(|a| a.has_name(sym::alias))\n             .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n             .filter(|v| !v.is_empty())\n             .collect::<FxHashSet<_>>()"}, {"sha": "5a9e9dda6771ecb7854a6346768bb3c841f0f6b0", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -48,7 +48,7 @@ pub fn extern_location(\n     // external crate\n     e.attrs\n         .lists(sym::doc)\n-        .filter(|a| a.check_name(sym::html_root_url))\n+        .filter(|a| a.has_name(sym::html_root_url))\n         .filter_map(|a| a.value_str())\n         .map(|url| {\n             let mut url = url.to_string();"}, {"sha": "d5f7ddcbdfbde6d7547aa280b0e272ed6feca84f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -43,13 +43,13 @@ extern crate rustc_trait_selection;\n extern crate rustc_typeck;\n extern crate test as testing;\n #[macro_use]\n-extern crate log;\n+extern crate tracing;\n \n use std::default::Default;\n use std::env;\n-use std::panic;\n use std::process;\n \n+use rustc_errors::ErrorReported;\n use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGroup};\n use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n@@ -82,22 +82,14 @@ struct Output {\n }\n \n pub fn main() {\n-    let thread_stack_size: usize = if cfg!(target_os = \"haiku\") {\n-        16_000_000 // 16MB on Haiku\n-    } else {\n-        32_000_000 // 32MB on other platforms\n-    };\n     rustc_driver::set_sigpipe_handler();\n     rustc_driver::install_ice_hook();\n     rustc_driver::init_env_logger(\"RUSTDOC_LOG\");\n-\n-    let res = std::thread::Builder::new()\n-        .stack_size(thread_stack_size)\n-        .spawn(move || get_args().map(|args| main_args(&args)).unwrap_or(1))\n-        .unwrap()\n-        .join()\n-        .unwrap_or(rustc_driver::EXIT_FAILURE);\n-    process::exit(res);\n+    let exit_code = rustc_driver::catch_with_exit_code(|| match get_args() {\n+        Some(args) => main_args(&args),\n+        _ => Err(ErrorReported),\n+    });\n+    process::exit(exit_code);\n }\n \n fn get_args() -> Option<Vec<String>> {\n@@ -418,7 +410,10 @@ fn usage(argv0: &str) {\n     println!(\"{}\", options.usage(&format!(\"{} [options] <input>\", argv0)));\n }\n \n-fn main_args(args: &[String]) -> i32 {\n+/// A result type used by several functions under `main()`.\n+type MainResult = Result<(), ErrorReported>;\n+\n+fn main_args(args: &[String]) -> MainResult {\n     let mut options = getopts::Options::new();\n     for option in opts() {\n         (option.apply)(&mut options);\n@@ -429,24 +424,27 @@ fn main_args(args: &[String]) -> i32 {\n             early_error(ErrorOutputType::default(), &err.to_string());\n         }\n     };\n+\n+    // Note that we discard any distinction between different non-zero exit\n+    // codes from `from_matches` here.\n     let options = match config::Options::from_matches(&matches) {\n         Ok(opts) => opts,\n-        Err(code) => return code,\n+        Err(code) => return if code == 0 { Ok(()) } else { Err(ErrorReported) },\n     };\n-    rustc_interface::interface::setup_callbacks_and_run_in_default_thread_pool_with_globals(\n+    rustc_interface::util::setup_callbacks_and_run_in_thread_pool_with_globals(\n         options.edition,\n+        1, // this runs single-threaded, even in a parallel compiler\n+        &None,\n         move || main_options(options),\n     )\n }\n \n-fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> i32 {\n+fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> MainResult {\n     match res {\n-        Ok(()) => 0,\n+        Ok(()) => Ok(()),\n         Err(err) => {\n-            if !err.is_empty() {\n-                diag.struct_err(&err).emit();\n-            }\n-            1\n+            diag.struct_err(&err).emit();\n+            Err(ErrorReported)\n         }\n     }\n }\n@@ -457,9 +455,9 @@ fn run_renderer<T: formats::FormatRenderer>(\n     render_info: config::RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: rustc_span::edition::Edition,\n-) -> i32 {\n+) -> MainResult {\n     match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition) {\n-        Ok(_) => rustc_driver::EXIT_SUCCESS,\n+        Ok(_) => Ok(()),\n         Err(e) => {\n             let mut msg = diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n             let file = e.file.display().to_string();\n@@ -468,17 +466,17 @@ fn run_renderer<T: formats::FormatRenderer>(\n             } else {\n                 msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file)).emit()\n             }\n-            rustc_driver::EXIT_FAILURE\n+            Err(ErrorReported)\n         }\n     }\n }\n \n-fn main_options(options: config::Options) -> i32 {\n+fn main_options(options: config::Options) -> MainResult {\n     let diag = core::new_handler(options.error_format, None, &options.debugging_options);\n \n     match (options.should_test, options.markdown_input()) {\n         (true, true) => return wrap_return(&diag, markdown::test(options)),\n-        (true, false) => return wrap_return(&diag, test::run(options)),\n+        (true, false) => return test::run(options),\n         (false, true) => {\n             return wrap_return(\n                 &diag,\n@@ -500,44 +498,37 @@ fn main_options(options: config::Options) -> i32 {\n     // compiler all the way through the analysis passes. The rustdoc output is\n     // then generated from the cleaned AST of the crate. This runs all the\n     // plug/cleaning passes.\n-    let result = rustc_driver::catch_fatal_errors(move || {\n-        let crate_name = options.crate_name.clone();\n-        let crate_version = options.crate_version.clone();\n-        let output_format = options.output_format;\n-        let (mut krate, renderinfo, renderopts) = core::run_core(options);\n+    let crate_name = options.crate_name.clone();\n+    let crate_version = options.crate_version.clone();\n+    let output_format = options.output_format;\n+    let (mut krate, renderinfo, renderopts) = core::run_core(options);\n \n-        info!(\"finished with rustc\");\n+    info!(\"finished with rustc\");\n \n-        if let Some(name) = crate_name {\n-            krate.name = name\n-        }\n+    if let Some(name) = crate_name {\n+        krate.name = name\n+    }\n \n-        krate.version = crate_version;\n+    krate.version = crate_version;\n \n-        let out = Output { krate, renderinfo, renderopts };\n+    let out = Output { krate, renderinfo, renderopts };\n \n-        if show_coverage {\n-            // if we ran coverage, bail early, we don't need to also generate docs at this point\n-            // (also we didn't load in any of the useful passes)\n-            return rustc_driver::EXIT_SUCCESS;\n-        }\n+    if show_coverage {\n+        // if we ran coverage, bail early, we don't need to also generate docs at this point\n+        // (also we didn't load in any of the useful passes)\n+        return Ok(());\n+    }\n \n-        let Output { krate, renderinfo, renderopts } = out;\n-        info!(\"going to format\");\n-        let (error_format, edition, debugging_options) = diag_opts;\n-        let diag = core::new_handler(error_format, None, &debugging_options);\n-        match output_format {\n-            None | Some(config::OutputFormat::Html) => {\n-                run_renderer::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n-            }\n-            Some(config::OutputFormat::Json) => {\n-                run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition)\n-            }\n+    let Output { krate, renderinfo, renderopts } = out;\n+    info!(\"going to format\");\n+    let (error_format, edition, debugging_options) = diag_opts;\n+    let diag = core::new_handler(error_format, None, &debugging_options);\n+    match output_format {\n+        None | Some(config::OutputFormat::Html) => {\n+            run_renderer::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n+        }\n+        Some(config::OutputFormat::Json) => {\n+            run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition)\n         }\n-    });\n-\n-    match result {\n-        Ok(output) => output,\n-        Err(_) => panic::resume_unwind(Box::new(rustc_errors::FatalErrorMarker)),\n     }\n }"}, {"sha": "3000afde0c25d6172fd91d4ce669fd5657c9a538", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -28,7 +28,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut new_items = Vec::new();\n \n     for &cnum in cx.tcx.crates().iter() {\n-        for &did in cx.tcx.all_trait_implementations(cnum).iter() {\n+        for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n             inline::build_impl(cx, did, None, &mut new_items);\n         }\n     }"}, {"sha": "b86a105ff7664b22b0daca867544ad71236896bb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -42,7 +42,7 @@ pub struct TestOptions {\n     pub attrs: Vec<String>,\n }\n \n-pub fn run(options: Options) -> Result<(), String> {\n+pub fn run(options: Options) -> Result<(), ErrorReported> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -150,7 +150,7 @@ pub fn run(options: Options) -> Result<(), String> {\n     });\n     let tests = match tests {\n         Ok(tests) => tests,\n-        Err(ErrorReported) => return Err(String::new()),\n+        Err(ErrorReported) => return Err(ErrorReported),\n     };\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n@@ -175,17 +175,17 @@ fn scrape_test_config(krate: &::rustc_hir::Crate<'_>) -> TestOptions {\n         .item\n         .attrs\n         .iter()\n-        .filter(|a| a.check_name(sym::doc))\n+        .filter(|a| a.has_name(sym::doc))\n         .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n-        .filter(|a| a.check_name(sym::test))\n+        .filter(|a| a.has_name(sym::test))\n         .collect();\n     let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n \n     for attr in attrs {\n-        if attr.check_name(sym::no_crate_inject) {\n+        if attr.has_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.check_name(sym::attr) {\n+        if attr.has_name(sym::attr) {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n                     opts.attrs.push(pprust::meta_list_item_to_string(item));"}, {"sha": "cf57ffd0b4b305532d41bcda67bd6942a4ed0e9b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -165,11 +165,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) {\n         debug!(\"visiting fn\");\n         let macro_kind = item.attrs.iter().find_map(|a| {\n-            if a.check_name(sym::proc_macro) {\n+            if a.has_name(sym::proc_macro) {\n                 Some(MacroKind::Bang)\n-            } else if a.check_name(sym::proc_macro_derive) {\n+            } else if a.has_name(sym::proc_macro_derive) {\n                 Some(MacroKind::Derive)\n-            } else if a.check_name(sym::proc_macro_attribute) {\n+            } else if a.has_name(sym::proc_macro_attribute) {\n                 Some(MacroKind::Attr)\n             } else {\n                 None\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 let mut helpers = Vec::new();\n                 for mi in item.attrs.lists(sym::proc_macro_derive) {\n-                    if !mi.check_name(sym::attributes) {\n+                    if !mi.has_name(sym::attributes) {\n                         continue;\n                     }\n \n@@ -419,8 +419,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // anything as it will probably be stripped anyway.\n                 if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| match item.meta_item_list() {\n-                        Some(ref list) if item.check_name(sym::doc) => {\n-                            list.iter().any(|i| i.check_name(sym::inline))\n+                        Some(ref list) if item.has_name(sym::doc) => {\n+                            list.iter().any(|i| i.has_name(sym::inline))\n                         }\n                         _ => false,\n                     });"}, {"sha": "150997ee807da21abb5527548edaa0fe87111e5d", "filename": "src/test/assembly/asm/aarch64-modifiers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Faarch64-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Faarch64-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Faarch64-modifiers.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,6 +2,7 @@\n // assembly-output: emit-asm\n // compile-flags: -O\n // compile-flags: --target aarch64-unknown-linux-gnu\n+// needs-llvm-components: aarch64\n \n #![feature(no_core, lang_items, rustc_attrs)]\n #![crate_type = \"rlib\"]"}, {"sha": "b78a8cbb559b4f93cf750959d2d3b0b511938d54", "filename": "src/test/assembly/asm/aarch64-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,6 +1,7 @@\n // no-system-llvm\n // assembly-output: emit-asm\n // compile-flags: --target aarch64-unknown-linux-gnu\n+// needs-llvm-components: aarch64\n \n #![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n #![crate_type = \"rlib\"]"}, {"sha": "ad4ab63f265a73958be28c45a0742bdeac4a809f", "filename": "src/test/assembly/asm/arm-modifiers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Farm-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Farm-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Farm-modifiers.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -3,6 +3,7 @@\n // compile-flags: -O\n // compile-flags: --target armv7-unknown-linux-gnueabihf\n // compile-flags: -C target-feature=+neon\n+// needs-llvm-components: arm\n \n #![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n #![crate_type = \"rlib\"]"}, {"sha": "07e25a38e458321e45704c8fb13cc2b8e9a8ccb1", "filename": "src/test/assembly/asm/arm-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Farm-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Farm-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Farm-types.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,6 +2,7 @@\n // assembly-output: emit-asm\n // compile-flags: --target armv7-unknown-linux-gnueabihf\n // compile-flags: -C target-feature=+neon\n+// needs-llvm-components: arm\n \n #![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n #![crate_type = \"rlib\"]"}, {"sha": "b6b3b54cd710125ff104d9145b83c521d02cc8f2", "filename": "src/test/assembly/asm/hexagon-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,6 +1,7 @@\n // no-system-llvm\n // assembly-output: emit-asm\n // compile-flags: --target hexagon-unknown-linux-musl\n+// needs-llvm-components: hexagon\n \n #![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n #![crate_type = \"rlib\"]"}, {"sha": "77fd5141357e259216ff24496cf0916b7e1ae4c1", "filename": "src/test/assembly/asm/nvptx-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,6 +2,7 @@\n // assembly-output: emit-asm\n // compile-flags: --target nvptx64-nvidia-cuda\n // compile-flags: --crate-type cdylib\n+// needs-llvm-components: nvptx\n \n #![feature(no_core, lang_items, rustc_attrs)]\n #![no_core]"}, {"sha": "b6735153b5dcf7e25939acb100ee8273a7a803fb", "filename": "src/test/assembly/asm/riscv-modifiers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Friscv-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Friscv-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Friscv-modifiers.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -3,6 +3,7 @@\n // compile-flags: -O\n // compile-flags: --target riscv64gc-unknown-linux-gnu\n // compile-flags: -C target-feature=+f\n+// needs-llvm-components: riscv\n \n #![feature(no_core, lang_items, rustc_attrs)]\n #![crate_type = \"rlib\"]"}, {"sha": "0ff0bf1f94982162ced5ef181d4856eb85d8f1e2", "filename": "src/test/assembly/asm/riscv-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Friscv-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fassembly%2Fasm%2Friscv-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Friscv-types.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -4,6 +4,7 @@\n //[riscv64] compile-flags: --target riscv64imac-unknown-none-elf\n //[riscv32] compile-flags: --target riscv32imac-unknown-none-elf\n // compile-flags: -C target-feature=+d\n+// needs-llvm-components: riscv\n \n #![feature(no_core, lang_items, rustc_attrs)]\n #![crate_type = \"rlib\"]"}, {"sha": "1c0b77ad9c72727dc998da104d9edb9ba3958476", "filename": "src/test/codegen/abi-efiapi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,12 +1,14 @@\n // Checks if the correct annotation for the efiapi ABI is passed to llvm.\n \n-// revisions:x86_64 i686 arm\n-\n+// revisions:x86_64 i686 aarch64 arm riscv\n // min-llvm-version: 9.0\n+// needs-llvm-components: aarch64 arm riscv\n \n //[x86_64] compile-flags: --target x86_64-unknown-uefi\n //[i686] compile-flags: --target i686-unknown-linux-musl\n+//[aarch64] compile-flags: --target aarch64-unknown-none\n //[arm] compile-flags: --target armv7r-none-eabi\n+//[riscv] compile-flags: --target riscv64gc-unknown-none-elf\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n@@ -22,6 +24,8 @@ trait Copy { }\n \n //x86_64: define win64cc void @has_efiapi\n //i686: define void @has_efiapi\n+//aarch64: define void @has_efiapi\n //arm: define void @has_efiapi\n+//riscv: define void @has_efiapi\n #[no_mangle]\n pub extern \"efiapi\" fn has_efiapi() {}"}, {"sha": "6d25ca56f1488340855427af287ed4f724e0f2da", "filename": "src/test/codegen/avr/avr-func-addrspace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,5 @@\n // compile-flags: -O --target=avr-unknown-unknown --crate-type=rlib\n+// needs-llvm-components: avr\n \n // This test validates that function pointers can be stored in global variables\n // and called upon. It ensures that Rust emits function pointers in the correct"}, {"sha": "ed51faa7be12f7978eb9246d53fdfdf9332144e9", "filename": "src/test/codegen/wasm_casts_trapping.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,72 +5,72 @@\n // CHECK-LABEL: @cast_f64_i64\n #[no_mangle]\n pub fn cast_f64_i64(a: f64) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptosi double {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f64_i32\n #[no_mangle]\n pub fn cast_f64_i32(a: f64) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptosi double {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_i64\n #[no_mangle]\n pub fn cast_f32_i64(a: f32) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptosi float {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_i32\n #[no_mangle]\n pub fn cast_f32_i32(a: f32) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptosi float {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f64_u64\n #[no_mangle]\n pub fn cast_f64_u64(a: f64) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptoui double {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f64_u32\n #[no_mangle]\n pub fn cast_f64_u32(a: f64) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptoui double {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_u64\n #[no_mangle]\n pub fn cast_f32_u64(a: f32) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i64\n-    // CHECK-NEXT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK-NOT: fptoui float {{.*}} to i64\n+    // CHECK-NOT: select i1 {{.*}}, i64 {{.*}}, i64 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n \n // CHECK-LABEL: @cast_f32_u32\n #[no_mangle]\n pub fn cast_f32_u32(a: f32) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i32\n-    // CHECK-NEXT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK-NOT: fptoui float {{.*}} to i32\n+    // CHECK-NOT: select i1 {{.*}}, i32 {{.*}}, i32 {{.*}}\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n     a as _\n }\n "}, {"sha": "87bc79ea794377a6f5e77768a15501e3340f8319", "filename": "src/test/debuginfo/rc_arc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fdebuginfo%2Frc_arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fdebuginfo%2Frc_arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frc_arc.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,3 +1,4 @@\n+// ignore-windows pretty-printers are not loaded\n // compile-flags:-g\n \n // min-gdb-version: 8.1"}, {"sha": "9ca6f93c9bc08d21aeb506fe6e8fd795a346f67b", "filename": "src/test/mir-opt/instrument_coverage.bar.InstrumentCoverage.diff", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,58 +2,76 @@\n + // MIR for `bar` after InstrumentCoverage\n   \n   fn bar() -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n-+     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n+      let mut _0: bool;                    // return place in scope 0 at /the/src/instrument_coverage.rs:19:13: 19:17\n++     let mut _1: ();                      // in scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n   \n       bb0: {\n-+         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n-+         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const 529_u32, const 541_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n++         StorageLive(_1);                 // scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n++         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const \"/the/src/instrument_coverage.rs\", const 19_u32, const 18_u32, const 21_u32, const 2_u32) -> bb2; // scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u64\n +                                          // + val: Value(Scalar(0x8dabe565aaa2aefd))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n +                                          // + literal: Const { ty: u64, val: Value(Scalar(0x8dabe565aaa2aefd)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n++                                          // + ty: &str\n++                                          // + val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000013))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000013)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000012))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000012)) }\n++                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x00000211))\n++                                          // + val: Value(Scalar(0x00000015))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000211)) }\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000015)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x0000021d))\n++                                          // + val: Value(Scalar(0x00000002))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000021d)) }\n++                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000002)) }\n +     }\n + \n +     bb1 (cleanup): {\n-+         resume;                          // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         resume;                          // scope 0 at /the/src/instrument_coverage.rs:19:1: 21:2\n +     }\n + \n +     bb2: {\n-+         StorageDead(_1);                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n-          _0 = const true;                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n++         StorageDead(_1);                 // scope 0 at /the/src/instrument_coverage.rs:20:5: 20:9\n+          _0 = const true;                 // scope 0 at /the/src/instrument_coverage.rs:20:5: 20:9\n                                            // ty::Const\n                                            // + ty: bool\n                                            // + val: Value(Scalar(0x01))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // + span: /the/src/instrument_coverage.rs:20:5: 20:9\n                                            // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n-          return;                          // scope 0 at $DIR/instrument_coverage.rs:20:2: 20:2\n+          return;                          // scope 0 at /the/src/instrument_coverage.rs:21:2: 21:2\n       }\n   }\n   "}, {"sha": "3f47aa13bf91fdc225b64ce624fe8a961e8dba22", "filename": "src/test/mir-opt/instrument_coverage.main.InstrumentCoverage.diff", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -2,99 +2,117 @@\n + // MIR for `main` after InstrumentCoverage\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n-      let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n-      let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n-      let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n-+     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+      let mut _0: ();                      // return place in scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n+      let mut _1: ();                      // in scope 0 at /the/src/instrument_coverage.rs:10:1: 16:2\n+      let mut _2: bool;                    // in scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n+      let mut _3: !;                       // in scope 0 at /the/src/instrument_coverage.rs:12:18: 14:10\n++     let mut _4: ();                      // in scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n   \n       bb0: {\n--         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n-+         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n-+         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const 425_u32, const 493_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+-         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n++         StorageLive(_4);                 // scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n++         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const \"/the/src/instrument_coverage.rs\", const 10_u32, const 11_u32, const 16_u32, const 2_u32) -> bb7; // scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u64\n +                                          // + val: Value(Scalar(0xde1b3f75a72fc7f7))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n +                                          // + literal: Const { ty: u64, val: Value(Scalar(0xde1b3f75a72fc7f7)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n++                                          // + ty: &str\n++                                          // + val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x0000000a))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000000a)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x0000000b))\n++                                          // mir::Constant\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000000b)) }\n++                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x000001a9))\n++                                          // + val: Value(Scalar(0x00000010))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001a9)) }\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000010)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x000001ed))\n++                                          // + val: Value(Scalar(0x00000002))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001ed)) }\n++                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000002)) }\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n-          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          StorageLive(_2);                 // scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n+          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n                                            // ty::Const\n                                            // + ty: fn() -> bool {bar}\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:11:12: 11:15\n+                                           // + span: /the/src/instrument_coverage.rs:12:12: 12:15\n                                            // + literal: Const { ty: fn() -> bool {bar}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb2 (cleanup): {\n-          resume;                          // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+          resume;                          // scope 0 at /the/src/instrument_coverage.rs:10:1: 16:2\n       }\n   \n       bb3: {\n-          FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n-          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+          FakeRead(ForMatchedPlace, _2);   // scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n+          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at /the/src/instrument_coverage.rs:12:9: 14:10\n       }\n   \n       bb4: {\n-          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at /the/src/instrument_coverage.rs:12:9: 14:10\n       }\n   \n       bb5: {\n-          _1 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+          _1 = const ();                   // scope 0 at /the/src/instrument_coverage.rs:12:9: 14:10\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // + span: /the/src/instrument_coverage.rs:12:9: 14:10\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n-          goto -> bb0;                     // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+          StorageDead(_2);                 // scope 0 at /the/src/instrument_coverage.rs:15:5: 15:6\n+          goto -> bb0;                     // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n       }\n   \n       bb6: {\n-          _0 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:12:13: 12:18\n+          _0 = const ();                   // scope 0 at /the/src/instrument_coverage.rs:13:13: 13:18\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // + span: /the/src/instrument_coverage.rs:13:13: 13:18\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n-          return;                          // scope 0 at $DIR/instrument_coverage.rs:15:2: 15:2\n+          StorageDead(_2);                 // scope 0 at /the/src/instrument_coverage.rs:15:5: 15:6\n+          return;                          // scope 0 at /the/src/instrument_coverage.rs:16:2: 16:2\n +     }\n + \n +     bb7: {\n-+         StorageDead(_4);                 // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n-+         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         StorageDead(_4);                 // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n++         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n       }\n   }\n   "}, {"sha": "430573c7c05f474ee8692292a0e66ce2da5b966b", "filename": "src/test/mir-opt/instrument_coverage.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -3,7 +3,8 @@\n // intrinsics, during codegen.\n \n // needs-profiler-support\n-// compile-flags: -Zinstrument-coverage\n+// ignore-windows\n+// compile-flags: -Zinstrument-coverage --remap-path-prefix={{src-base}}=/the/src\n // EMIT_MIR instrument_coverage.main.InstrumentCoverage.diff\n // EMIT_MIR instrument_coverage.bar.InstrumentCoverage.diff\n fn main() {\n@@ -18,3 +19,18 @@ fn main() {\n fn bar() -> bool {\n     true\n }\n+\n+// Note that the MIR with injected coverage intrinsics includes references to source locations,\n+// including the source file absolute path. Typically, MIR pretty print output with file\n+// references are safe because the file prefixes are substituted with `$DIR`, but in this case\n+// the file references are encoded as function arguments, with an `Operand` type representation\n+// (`Slice` `Allocation` interned byte array) that cannot be normalized by simple substitution.\n+//\n+// The first workaround is to use the `SourceMap`-supported `--remap-path-prefix` option; however,\n+// the implementation of the `--remap-path-prefix` option currently joins the new prefix and the\n+// remaining source path with an OS-specific path separator (`\\` on Windows). This difference still\n+// shows up in the byte array representation of the path, causing Windows tests to fail to match\n+// blessed results baselined with a `/` path separator.\n+//\n+// Since this `mir-opt` test does not have any significant platform dependencies, other than the\n+// path separator differences, the final workaround is to disable testing on Windows."}, {"sha": "2bfcdd75e15cff94d54007075bcacc3d586c6238", "filename": "src/test/pretty/block-comment-wchar.pp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -73,15 +73,13 @@\n     */\n \n \n-\n     /* */\n \n     /*\n       Hello from offset 6\n       Space 6+2:                     compare A\n       Ogham Space Mark 6+2: compare B\n     */\n-\n     /*\u1680*/\n \n     /*"}, {"sha": "e255cd6caa8654c97021d22dc427cffe23172960", "filename": "src/test/pretty/issue-74745.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fpretty%2Fissue-74745.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fpretty%2Fissue-74745.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-74745.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,5 @@\n+// ignore-tidy-trailing-newlines\n+// pretty-compare-only\n+\n+/*\n+*/\n\\ No newline at end of file"}, {"sha": "a6c2317c73669efeee0467bc1ad91cfcf1070e1d", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -4,10 +4,11 @@\n // no-prefer-dynamic\n \n #![feature(allocator_api)]\n+#![feature(slice_ptr_get)]\n \n extern crate helper;\n \n-use std::alloc::{self, AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{self, AllocRef, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n static HITS: AtomicUsize = AtomicUsize::new(0);\n@@ -37,10 +38,10 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n-        helper::work_with(&memory.ptr);\n+        let memory = Global.alloc(layout.clone()).unwrap();\n+        helper::work_with(&memory);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.ptr, layout);\n+        Global.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);\n@@ -49,10 +50,10 @@ fn main() {\n         drop(s);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n \n-        let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = System.alloc(layout.clone()).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n-        helper::work_with(&memory.ptr);\n-        System.dealloc(memory.ptr, layout);\n+        helper::work_with(&memory);\n+        System.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n     }\n }"}, {"sha": "a1446b3664d4b3c442ceed2771381203a0e22406", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,11 +5,12 @@\n // no-prefer-dynamic\n \n #![feature(allocator_api)]\n+#![feature(slice_ptr_get)]\n \n extern crate custom;\n extern crate helper;\n \n-use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{AllocRef, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n #[global_allocator]\n@@ -20,16 +21,16 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n-        helper::work_with(&memory.ptr);\n+        let memory = Global.alloc(layout.clone()).unwrap();\n+        helper::work_with(&memory);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.ptr, layout);\n+        Global.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n-        let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = System.alloc(layout.clone()).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n-        helper::work_with(&memory.ptr);\n-        System.dealloc(memory.ptr, layout);\n+        helper::work_with(&memory);\n+        System.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n     }\n }"}, {"sha": "2ced88a16cc45976ed2867dec511e25e219b0f3e", "filename": "src/test/ui/async-await/issue-68523-start.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -4,6 +4,6 @@\n \n #[start]\n pub async fn start(_: isize, _: *const *const u8) -> isize {\n-//~^ ERROR start is not allowed to be `async`\n+//~^ ERROR `start` is not allowed to be `async`\n     0\n }"}, {"sha": "3a0a3b5dece10916742a8a1d64fb339db416cc43", "filename": "src/test/ui/async-await/issue-68523-start.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,8 @@\n-error[E0752]: start is not allowed to be `async`\n+error[E0752]: `start` is not allowed to be `async`\n   --> $DIR/issue-68523-start.rs:6:1\n    |\n LL | pub async fn start(_: isize, _: *const *const u8) -> isize {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ start is not allowed to be `async`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `start` is not allowed to be `async`\n \n error: aborting due to previous error\n "}, {"sha": "876d8b079a16c1c1fda5d5e5c242a3e70e34e035", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-true.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -9,13 +9,13 @@\n #[cfg_attr(all(), deprecated, must_use)]\n struct MustUseDeprecated {}\n \n-impl MustUseDeprecated { //~ warning: use of deprecated item\n-    fn new() -> MustUseDeprecated { //~ warning: use of deprecated item\n-        MustUseDeprecated {} //~ warning: use of deprecated item\n+impl MustUseDeprecated { //~ warning: use of deprecated\n+    fn new() -> MustUseDeprecated { //~ warning: use of deprecated\n+        MustUseDeprecated {} //~ warning: use of deprecated\n     }\n }\n \n fn main() {\n-    MustUseDeprecated::new(); //~ warning: use of deprecated item\n+    MustUseDeprecated::new(); //~ warning: use of deprecated\n     //~| warning: unused `MustUseDeprecated` that must be used\n }"}, {"sha": "21b3a6f1f33b6a855c68aaefa31717a11e5ad69b", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-true.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,24 +1,24 @@\n-warning: use of deprecated item 'MustUseDeprecated'\n+warning: use of deprecated struct `MustUseDeprecated`\n   --> $DIR/cfg-attr-multi-true.rs:12:6\n    |\n LL | impl MustUseDeprecated {\n    |      ^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n-warning: use of deprecated item 'MustUseDeprecated'\n+warning: use of deprecated struct `MustUseDeprecated`\n   --> $DIR/cfg-attr-multi-true.rs:19:5\n    |\n LL |     MustUseDeprecated::new();\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'MustUseDeprecated'\n+warning: use of deprecated struct `MustUseDeprecated`\n   --> $DIR/cfg-attr-multi-true.rs:13:17\n    |\n LL |     fn new() -> MustUseDeprecated {\n    |                 ^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'MustUseDeprecated'\n+warning: use of deprecated struct `MustUseDeprecated`\n   --> $DIR/cfg-attr-multi-true.rs:14:9\n    |\n LL |         MustUseDeprecated {}"}, {"sha": "4c755530b997901d42afbe3c15099c43af56b494", "filename": "src/test/ui/const-generics/issues/issue-64494.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,19 @@\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+trait Foo {\n+    const VAL: usize;\n+}\n+\n+trait MyTrait {}\n+\n+trait True {}\n+struct Is<const T: bool>;\n+impl True for Is<{true}> {}\n+\n+impl<T: Foo> MyTrait for T where Is<{T::VAL == 5}>: True {}\n+//~^ ERROR constant expression depends on a generic parameter\n+impl<T: Foo> MyTrait for T where Is<{T::VAL == 6}>: True {}\n+//~^ ERROR constant expression depends on a generic parameter\n+\n+fn main() {}"}, {"sha": "30dca16964317ed9a891a09ed6bf698cf260b6e0", "filename": "src/test/ui/const-generics/issues/issue-64494.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,18 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-64494.rs:14:53\n+   |\n+LL | impl<T: Foo> MyTrait for T where Is<{T::VAL == 5}>: True {}\n+   |                                                     ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-64494.rs:16:53\n+   |\n+LL | impl<T: Foo> MyTrait for T where Is<{T::VAL == 6}>: True {}\n+   |                                                     ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a368c226ec3382453d7b6f9394f2b3be9fc8d41c", "filename": "src/test/ui/const-generics/issues/issue-72787.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,32 @@\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+pub struct IsLessOrEqual<const LHS: u32, const RHS: u32>;\n+pub struct Condition<const CONDITION: bool>;\n+pub trait True {}\n+\n+impl<const LHS: u32, const RHS: u32> True for IsLessOrEqual<LHS, RHS> where\n+    Condition<{ LHS <= RHS }>: True\n+//~^ Error constant expression depends on a generic parameter\n+{\n+}\n+impl True for Condition<true> {}\n+\n+struct S<const I: u32, const J: u32>;\n+impl<const I: u32, const J: u32> S<I, J>\n+where\n+    IsLessOrEqual<I, 8>: True,\n+    IsLessOrEqual<J, 8>: True,\n+    IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+//~^ Error constant expression depends on a generic parameter\n+//~| Error constant expression depends on a generic parameter\n+//~| Error constant expression depends on a generic parameter\n+//~| Error constant expression depends on a generic parameter\n+    // Condition<{ 8 - I <= 8 - J }>: True,\n+{\n+    fn print() {\n+        println!(\"I {} J {}\", I, J);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ed892e46bbbedf463cf4a6bef678b62e6997a92f", "filename": "src/test/ui/const-generics/issues/issue-72787.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,42 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-72787.rs:9:32\n+   |\n+LL |     Condition<{ LHS <= RHS }>: True\n+   |                                ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-72787.rs:20:42\n+   |\n+LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+   |                                          ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-72787.rs:20:42\n+   |\n+LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+   |                                          ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-72787.rs:20:42\n+   |\n+LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+   |                                          ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-72787.rs:20:42\n+   |\n+LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n+   |                                          ^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "51e1af359cdcc6d42839b57679f671b40681d1d4", "filename": "src/test/ui/consts/const_in_pattern/warn_corner_cases.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,7 +10,7 @@\n // const-evaluator computes a value that *does* meet the conditions for\n // structural-match, but the const expression itself has abstractions (like\n // calls to const functions) that may fit better with a type-based analysis\n-// rather than a committment to a specific value.\n+// rather than a commitment to a specific value.\n \n #![warn(indirect_structural_match)]\n "}, {"sha": "b3d8610ff51730d9ef791c8fdfdff4255cdc8a7e", "filename": "src/test/ui/consts/issue-73976-polymorphic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n // This test is from #73976. We previously did not check if a type is monomorphized\n-// before calculating its type id, which leads to the bizzare behaviour below that\n+// before calculating its type id, which leads to the bizarre behaviour below that\n // TypeId of a generic type does not match itself.\n //\n // This test case should either run-pass or be rejected at compile time."}, {"sha": "67d9f6baca5b447a440c09036d63474d3c5beb5e", "filename": "src/test/ui/consts/unsizing-cast-non-null.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for #75118.\n+\n+use std::ptr::NonNull;\n+\n+pub const fn dangling_slice<T>() -> NonNull<[T]> {\n+    NonNull::<[T; 0]>::dangling()\n+    //~^ ERROR: unsizing casts are only allowed for references right now\n+}\n+\n+fn main() {}"}, {"sha": "6575355daadd7fb34a83abb08529854ae9beeefd", "filename": "src/test/ui/consts/unsizing-cast-non-null.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funsizing-cast-non-null.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,12 @@\n+error[E0723]: unsizing casts are only allowed for references right now\n+  --> $DIR/unsizing-cast-non-null.rs:6:5\n+   |\n+LL |     NonNull::<[T; 0]>::dangling()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "4fb0aeeb573e0d64354eae92f55708a631b4c7d8", "filename": "src/test/ui/deprecation/atomic_initializers.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -6,6 +6,6 @@ use std::sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT};\n \n #[allow(dead_code)]\n static FOO: AtomicIsize = AtomicIsize::new(0);\n-//~^ WARN use of deprecated item\n+//~^ WARN use of deprecated constant\n \n fn main() {}"}, {"sha": "1dcfd36d7d57593e1c1698956aa946162c0434a7", "filename": "src/test/ui/deprecation/atomic_initializers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -6,6 +6,6 @@ use std::sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT};\n \n #[allow(dead_code)]\n static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n-//~^ WARN use of deprecated item\n+//~^ WARN use of deprecated constant\n \n fn main() {}"}, {"sha": "eaf5c61b440bdca2ceabf81dc106ed86dadcf8d1", "filename": "src/test/ui/deprecation/atomic_initializers.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,8 @@\n-warning: use of deprecated item 'std::sync::atomic::ATOMIC_ISIZE_INIT': the `new` function is now preferred\n+warning: use of deprecated constant `std::sync::atomic::ATOMIC_ISIZE_INIT`: the `new` function is now preferred\n   --> $DIR/atomic_initializers.rs:8:27\n    |\n LL | static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n-   |                           ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated item: `AtomicIsize::new(0)`\n+   |                           ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated constant: `AtomicIsize::new(0)`\n    |\n    = note: `#[warn(deprecated)]` on by default\n "}, {"sha": "53826183d06dab5f8405d03a56ec8821cdcfe4a6", "filename": "src/test/ui/deprecation/deprecation-in-future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -7,7 +7,7 @@ pub fn deprecated_future() {}\n \n fn test() {\n     deprecated_future(); // ok; deprecated_in_future only applies to rustc_deprecated\n-    //~^ WARNING use of deprecated item 'deprecated_future': text [deprecated]\n+    //~^ WARNING use of deprecated function `deprecated_future`: text [deprecated]\n }\n \n fn main() {}"}, {"sha": "6561ec74349e8938afb6babb4cee53a33c095a04", "filename": "src/test/ui/deprecation/deprecation-in-future.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-warning: use of deprecated item 'deprecated_future': text\n+warning: use of deprecated function `deprecated_future`: text\n   --> $DIR/deprecation-in-future.rs:9:5\n    |\n LL |     deprecated_future(); // ok; deprecated_in_future only applies to rustc_deprecated"}, {"sha": "16ed6d4ecd6ebf4433b84add55fd4df73dde94fa", "filename": "src/test/ui/deprecation/deprecation-lint-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n // aux-build:deprecation-lint.rs\n-// error-pattern: use of deprecated item\n+// error-pattern: use of deprecated function\n \n #![deny(deprecated)]\n "}, {"sha": "b81d4bf402a57590eef3962276cfcf7a52c10f53", "filename": "src/test/ui/deprecation/deprecation-lint-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'deprecation_lint::deprecated': text\n+error: use of deprecated function `deprecation_lint::deprecated`: text\n   --> $DIR/deprecation-lint-2.rs:12:5\n    |\n LL |     macro_test!();"}, {"sha": "e6e1587daeb4683808a75852ccb44bf5deb11d09", "filename": "src/test/ui/deprecation/deprecation-lint-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n // aux-build:deprecation-lint.rs\n-// error-pattern: use of deprecated item\n+// error-pattern: use of deprecated function\n \n #![deny(deprecated)]\n #![allow(warnings)]"}, {"sha": "6f7cd9be2dd7bc063429741bf72719cd3586bbf7", "filename": "src/test/ui/deprecation/deprecation-lint-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'deprecation_lint::deprecated_text': text\n+error: use of deprecated function `deprecation_lint::deprecated_text`: text\n   --> $DIR/deprecation-lint-3.rs:13:5\n    |\n LL |     macro_test_arg_nested!(deprecated_text);"}, {"sha": "589522cdbdf485a30dbb1ae24c6f0a4202e6db7b", "filename": "src/test/ui/deprecation/deprecation-lint-nested.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-nested.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -52,19 +52,19 @@ mod loud {\n     #[deprecated]\n     const DEPRECATED_CONST: u8 = 1;\n \n-    struct Foo(DeprecatedType); //~ ERROR use of deprecated item\n+    struct Foo(DeprecatedType); //~ ERROR use of deprecated type alias\n \n-    impl DeprecatedTrait for Foo {} //~ ERROR use of deprecated item\n+    impl DeprecatedTrait for Foo {} //~ ERROR use of deprecated trait\n \n     impl Foo {\n-        fn bar<T: DeprecatedTrait>() { //~ ERROR use of deprecated item\n-            deprecated_fn(); //~ ERROR use of deprecated item\n+        fn bar<T: DeprecatedTrait>() { //~ ERROR use of deprecated trait\n+            deprecated_fn(); //~ ERROR use of deprecated function\n         }\n     }\n \n     fn foo() -> u8 {\n-        DEPRECATED_STATIC + //~ ERROR use of deprecated item\n-        DEPRECATED_CONST //~ ERROR use of deprecated item\n+        DEPRECATED_STATIC + //~ ERROR use of deprecated static\n+        DEPRECATED_CONST //~ ERROR use of deprecated const\n     }\n }\n "}, {"sha": "47607b8cc7c18d44d2273d318fc4dcf1b65badf3", "filename": "src/test/ui/deprecation/deprecation-lint-nested.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-nested.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'loud::DeprecatedType'\n+error: use of deprecated type alias `loud::DeprecatedType`\n   --> $DIR/deprecation-lint-nested.rs:55:16\n    |\n LL |     struct Foo(DeprecatedType);\n@@ -10,31 +10,31 @@ note: the lint level is defined here\n LL | #![deny(deprecated)]\n    |         ^^^^^^^^^^\n \n-error: use of deprecated item 'loud::DeprecatedTrait'\n+error: use of deprecated trait `loud::DeprecatedTrait`\n   --> $DIR/deprecation-lint-nested.rs:57:10\n    |\n LL |     impl DeprecatedTrait for Foo {}\n    |          ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'loud::DEPRECATED_STATIC'\n+error: use of deprecated static `loud::DEPRECATED_STATIC`\n   --> $DIR/deprecation-lint-nested.rs:66:9\n    |\n LL |         DEPRECATED_STATIC +\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'loud::DEPRECATED_CONST'\n+error: use of deprecated constant `loud::DEPRECATED_CONST`\n   --> $DIR/deprecation-lint-nested.rs:67:9\n    |\n LL |         DEPRECATED_CONST\n    |         ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'loud::DeprecatedTrait'\n+error: use of deprecated trait `loud::DeprecatedTrait`\n   --> $DIR/deprecation-lint-nested.rs:60:19\n    |\n LL |         fn bar<T: DeprecatedTrait>() {\n    |                   ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'loud::deprecated_fn'\n+error: use of deprecated function `loud::deprecated_fn`\n   --> $DIR/deprecation-lint-nested.rs:61:13\n    |\n LL |             deprecated_fn();"}, {"sha": "1932344fc5723268d9f9aeedd4e2613a7845f14c", "filename": "src/test/ui/deprecation/deprecation-lint.rs", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -14,143 +14,143 @@ mod cross_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item 'deprecation_lint::deprecated'\n-        foo.method_deprecated(); //~ ERROR use of deprecated item 'deprecation_lint::MethodTester::method_deprecated'\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::MethodTester::method_deprecated'\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::MethodTester::method_deprecated'\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-\n-        deprecated_text(); //~ ERROR use of deprecated item 'deprecation_lint::deprecated_text': text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item 'deprecation_lint::MethodTester::method_deprecated_text': text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::MethodTester::method_deprecated_text': text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::MethodTester::method_deprecated_text': text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-\n-        let _ = DeprecatedStruct { //~ ERROR use of deprecated item 'deprecation_lint::DeprecatedStruct': text\n-            i: 0 //~ ERROR use of deprecated item 'deprecation_lint::DeprecatedStruct::i': text\n+        deprecated(); //~ ERROR use of deprecated function `deprecation_lint::deprecated`\n+        foo.method_deprecated(); //~ ERROR use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated`\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated`\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated`\n+        foo.trait_deprecated(); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+\n+        deprecated_text(); //~ ERROR use of deprecated function `deprecation_lint::deprecated_text`: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated_text`: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated_text`: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated_text`: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+\n+        let _ = DeprecatedStruct { //~ ERROR use of deprecated struct `deprecation_lint::DeprecatedStruct`: text\n+            i: 0 //~ ERROR use of deprecated field `deprecation_lint::DeprecatedStruct::i`: text\n         };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item 'deprecation_lint::DeprecatedUnitStruct': text\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated struct `deprecation_lint::DeprecatedUnitStruct`: text\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item 'deprecation_lint::Enum::DeprecatedVariant': text\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated variant `deprecation_lint::Enum::DeprecatedVariant`: text\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item 'deprecation_lint::DeprecatedTupleStruct': text\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated struct `deprecation_lint::DeprecatedTupleStruct`: text\n \n-        let _ = nested::DeprecatedStruct { //~ ERROR use of deprecated item 'deprecation_lint::nested::DeprecatedStruct': text\n-            i: 0 //~ ERROR use of deprecated item 'deprecation_lint::nested::DeprecatedStruct::i': text\n+        let _ = nested::DeprecatedStruct { //~ ERROR use of deprecated struct `deprecation_lint::nested::DeprecatedStruct`: text\n+            i: 0 //~ ERROR use of deprecated field `deprecation_lint::nested::DeprecatedStruct::i`: text\n         };\n \n-        let _ = nested::DeprecatedUnitStruct; //~ ERROR use of deprecated item 'deprecation_lint::nested::DeprecatedUnitStruct': text\n+        let _ = nested::DeprecatedUnitStruct; //~ ERROR use of deprecated struct `deprecation_lint::nested::DeprecatedUnitStruct`: text\n \n-        let _ = nested::Enum::DeprecatedVariant; //~ ERROR use of deprecated item 'deprecation_lint::nested::Enum::DeprecatedVariant': text\n+        let _ = nested::Enum::DeprecatedVariant; //~ ERROR use of deprecated variant `deprecation_lint::nested::Enum::DeprecatedVariant`: text\n \n-        let _ = nested::DeprecatedTupleStruct (1); //~ ERROR use of deprecated item 'deprecation_lint::nested::DeprecatedTupleStruct': text\n+        let _ = nested::DeprecatedTupleStruct (1); //~ ERROR use of deprecated struct `deprecation_lint::nested::DeprecatedTupleStruct`: text\n \n         // At the moment, the lint checker only checks stability in\n         // in the arguments of macros.\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item 'deprecation_lint::deprecated_text': text\n-        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item 'deprecation_lint::deprecated_text': text\n+        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated function `deprecation_lint::deprecated_text`: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated function `deprecation_lint::deprecated_text`: text\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+        foo.trait_deprecated(); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+        foo.trait_deprecated(); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n     }\n \n     struct S;\n \n-    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item 'deprecation_lint::DeprecatedTrait': text\n-    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item 'deprecation_lint::DeprecatedTrait': text\n+    impl DeprecatedTrait for S {} //~ ERROR use of deprecated trait `deprecation_lint::DeprecatedTrait`: text\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated trait `deprecation_lint::DeprecatedTrait`: text\n \n     pub fn foo() {\n         let x = Stable {\n             override2: 3,\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Stable::override2': text\n+            //~^ ERROR use of deprecated field `deprecation_lint::Stable::override2`: text\n         };\n \n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Stable::override2': text\n+        //~^ ERROR use of deprecated field `deprecation_lint::Stable::override2`: text\n \n         let Stable {\n             override2: _\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Stable::override2': text\n+            //~^ ERROR use of deprecated field `deprecation_lint::Stable::override2`: text\n         } = x;\n         // all fine\n         let Stable { .. } = x;\n \n         let x = Stable2(1, 2, 3);\n \n         let _ = x.2;\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Stable2::2': text\n+        //~^ ERROR use of deprecated field `deprecation_lint::Stable2::2`: text\n \n         let Stable2(_,\n                    _,\n                    _)\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Stable2::2': text\n+            //~^ ERROR use of deprecated field `deprecation_lint::Stable2::2`: text\n             = x;\n         // all fine\n         let Stable2(..) = x;\n \n         let x = Deprecated {\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated': text\n+            //~^ ERROR use of deprecated struct `deprecation_lint::Deprecated`: text\n             inherit: 1,\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated::inherit': text\n+            //~^ ERROR use of deprecated field `deprecation_lint::Deprecated::inherit`: text\n         };\n \n         let _ = x.inherit;\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated::inherit': text\n+        //~^ ERROR use of deprecated field `deprecation_lint::Deprecated::inherit`: text\n \n         let Deprecated {\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated': text\n+            //~^ ERROR use of deprecated struct `deprecation_lint::Deprecated`: text\n             inherit: _,\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated::inherit': text\n+            //~^ ERROR use of deprecated field `deprecation_lint::Deprecated::inherit`: text\n         } = x;\n \n         let Deprecated\n-            //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated': text\n+            //~^ ERROR use of deprecated struct `deprecation_lint::Deprecated`: text\n             { .. } = x;\n \n         let x = Deprecated2(1, 2, 3);\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2': text\n+        //~^ ERROR use of deprecated struct `deprecation_lint::Deprecated2`: text\n \n         let _ = x.0;\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2::0': text\n+        //~^ ERROR use of deprecated field `deprecation_lint::Deprecated2::0`: text\n         let _ = x.1;\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2::1': text\n+        //~^ ERROR use of deprecated field `deprecation_lint::Deprecated2::1`: text\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2::2': text\n+        //~^ ERROR use of deprecated field `deprecation_lint::Deprecated2::2`: text\n \n         let Deprecated2\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2': text\n+        //~^ ERROR use of deprecated struct `deprecation_lint::Deprecated2`: text\n             (_,\n-             //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2::0': text\n+             //~^ ERROR use of deprecated field `deprecation_lint::Deprecated2::0`: text\n              _,\n-             //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2::1': text\n+             //~^ ERROR use of deprecated field `deprecation_lint::Deprecated2::1`: text\n              _)\n-             //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2::2': text\n+             //~^ ERROR use of deprecated field `deprecation_lint::Deprecated2::2`: text\n             = x;\n         let Deprecated2\n-        //~^ ERROR use of deprecated item 'deprecation_lint::Deprecated2': text\n+        //~^ ERROR use of deprecated struct `deprecation_lint::Deprecated2`: text\n             // the patterns are all fine:\n             (..) = x;\n     }\n@@ -160,7 +160,7 @@ mod inheritance {\n     use deprecation_lint::*;\n \n     fn test_inheritance() {\n-        deprecated_mod::deprecated(); //~ ERROR use of deprecated item 'deprecation_lint::deprecated_mod::deprecated': text\n+        deprecated_mod::deprecated(); //~ ERROR use of deprecated function `deprecation_lint::deprecated_mod::deprecated`: text\n     }\n }\n \n@@ -243,65 +243,65 @@ mod this_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item 'this_crate::deprecated'\n-        foo.method_deprecated(); //~ ERROR use of deprecated item 'this_crate::MethodTester::method_deprecated'\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::MethodTester::method_deprecated'\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::MethodTester::method_deprecated'\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-\n-        deprecated_text(); //~ ERROR use of deprecated item 'this_crate::deprecated_text': text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+        deprecated(); //~ ERROR use of deprecated function `this_crate::deprecated`\n+        foo.method_deprecated(); //~ ERROR use of deprecated associated function `this_crate::MethodTester::method_deprecated`\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::MethodTester::method_deprecated`\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::MethodTester::method_deprecated`\n+        foo.trait_deprecated(); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+\n+        deprecated_text(); //~ ERROR use of deprecated function `this_crate::deprecated_text`: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n \n         // Future deprecations are only permitted for rustc_deprecated.\n-        deprecated_future(); //~ ERROR use of deprecated item\n-        deprecated_future_text(); //~ ERROR use of deprecated item\n+        deprecated_future(); //~ ERROR use of deprecated function\n+        deprecated_future_text(); //~ ERROR use of deprecated function\n \n         let _ = DeprecatedStruct {\n-            //~^ ERROR use of deprecated item 'this_crate::DeprecatedStruct': text\n-            i: 0 //~ ERROR use of deprecated item 'this_crate::DeprecatedStruct::i': text\n+            //~^ ERROR use of deprecated struct `this_crate::DeprecatedStruct`: text\n+            i: 0 //~ ERROR use of deprecated field `this_crate::DeprecatedStruct::i`: text\n         };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item 'this_crate::DeprecatedUnitStruct': text\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated unit struct `this_crate::DeprecatedUnitStruct`: text\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item 'this_crate::Enum::DeprecatedVariant': text\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated unit variant `this_crate::Enum::DeprecatedVariant`: text\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item 'this_crate::DeprecatedTupleStruct': text\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated tuple struct `this_crate::DeprecatedTupleStruct`: text\n \n         let _ = nested::DeprecatedStruct {\n-            //~^ ERROR use of deprecated item 'this_crate::nested::DeprecatedStruct': text\n-            i: 0 //~ ERROR use of deprecated item 'this_crate::nested::DeprecatedStruct::i': text\n+            //~^ ERROR use of deprecated struct `this_crate::nested::DeprecatedStruct`: text\n+            i: 0 //~ ERROR use of deprecated field `this_crate::nested::DeprecatedStruct::i`: text\n         };\n \n-        let _ = nested::DeprecatedUnitStruct; //~ ERROR use of deprecated item 'this_crate::nested::DeprecatedUnitStruct': text\n+        let _ = nested::DeprecatedUnitStruct; //~ ERROR use of deprecated unit struct `this_crate::nested::DeprecatedUnitStruct`: text\n \n-        let _ = nested::Enum::DeprecatedVariant; //~ ERROR use of deprecated item 'this_crate::nested::Enum::DeprecatedVariant': text\n+        let _ = nested::Enum::DeprecatedVariant; //~ ERROR use of deprecated unit variant `this_crate::nested::Enum::DeprecatedVariant`: text\n \n-        let _ = nested::DeprecatedTupleStruct (1); //~ ERROR use of deprecated item 'this_crate::nested::DeprecatedTupleStruct': text\n+        let _ = nested::DeprecatedTupleStruct (1); //~ ERROR use of deprecated tuple struct `this_crate::nested::DeprecatedTupleStruct`: text\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+        foo.trait_deprecated(); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+        foo.trait_deprecated(); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n     }\n \n     #[deprecated(since = \"1.0.0\", note = \"text\")]\n@@ -314,7 +314,7 @@ mod this_crate {\n         let _ = || {\n             #[deprecated]\n             fn bar() { }\n-            bar(); //~ ERROR use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}#0::bar'\n+            bar(); //~ ERROR use of deprecated function `this_crate::test_fn_closure_body::{{closure}}#0::bar`\n         };\n     }\n \n@@ -333,9 +333,9 @@ mod this_crate {\n \n     struct S;\n \n-    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item 'this_crate::DeprecatedTrait': text\n+    impl DeprecatedTrait for S { } //~ ERROR use of deprecated trait `this_crate::DeprecatedTrait`: text\n \n-    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item 'this_crate::DeprecatedTrait': text\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated trait `this_crate::DeprecatedTrait`: text\n }\n \n mod this_crate2 {\n@@ -361,73 +361,73 @@ mod this_crate2 {\n     pub fn foo() {\n         let x = Stable {\n             override2: 3,\n-            //~^ ERROR use of deprecated item 'this_crate2::Stable::override2': text\n+            //~^ ERROR use of deprecated field `this_crate2::Stable::override2`: text\n         };\n \n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item 'this_crate2::Stable::override2': text\n+        //~^ ERROR use of deprecated field `this_crate2::Stable::override2`: text\n \n         let Stable {\n             override2: _\n-            //~^ ERROR use of deprecated item 'this_crate2::Stable::override2': text\n+            //~^ ERROR use of deprecated field `this_crate2::Stable::override2`: text\n         } = x;\n         // all fine\n         let Stable { .. } = x;\n \n         let x = Stable2(1, 2, 3);\n \n         let _ = x.2;\n-        //~^ ERROR use of deprecated item 'this_crate2::Stable2::2': text\n+        //~^ ERROR use of deprecated field `this_crate2::Stable2::2`: text\n \n         let Stable2(_,\n                    _,\n                    _)\n-            //~^ ERROR use of deprecated item 'this_crate2::Stable2::2': text\n+            //~^ ERROR use of deprecated field `this_crate2::Stable2::2`: text\n             = x;\n         // all fine\n         let Stable2(..) = x;\n \n         let x = Deprecated {\n-            //~^ ERROR use of deprecated item 'this_crate2::Deprecated': text\n+            //~^ ERROR use of deprecated struct `this_crate2::Deprecated`: text\n             inherit: 1,\n-            //~^ ERROR use of deprecated item 'this_crate2::Deprecated::inherit': text\n+            //~^ ERROR use of deprecated field `this_crate2::Deprecated::inherit`: text\n         };\n \n         let _ = x.inherit;\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated::inherit': text\n+        //~^ ERROR use of deprecated field `this_crate2::Deprecated::inherit`: text\n \n         let Deprecated {\n-            //~^ ERROR use of deprecated item 'this_crate2::Deprecated': text\n+            //~^ ERROR use of deprecated struct `this_crate2::Deprecated`: text\n             inherit: _,\n-            //~^ ERROR use of deprecated item 'this_crate2::Deprecated::inherit': text\n+            //~^ ERROR use of deprecated field `this_crate2::Deprecated::inherit`: text\n         } = x;\n \n         let Deprecated\n-            //~^ ERROR use of deprecated item 'this_crate2::Deprecated': text\n+            //~^ ERROR use of deprecated struct `this_crate2::Deprecated`: text\n             // the patterns are all fine:\n             { .. } = x;\n \n         let x = Deprecated2(1, 2, 3);\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated2': text\n+        //~^ ERROR use of deprecated tuple struct `this_crate2::Deprecated2`: text\n \n         let _ = x.0;\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated2::0': text\n+        //~^ ERROR use of deprecated field `this_crate2::Deprecated2::0`: text\n         let _ = x.1;\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated2::1': text\n+        //~^ ERROR use of deprecated field `this_crate2::Deprecated2::1`: text\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated2::2': text\n+        //~^ ERROR use of deprecated field `this_crate2::Deprecated2::2`: text\n \n         let Deprecated2\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated2': text\n+        //~^ ERROR use of deprecated tuple struct `this_crate2::Deprecated2`: text\n             (_,\n-             //~^ ERROR use of deprecated item 'this_crate2::Deprecated2::0': text\n+             //~^ ERROR use of deprecated field `this_crate2::Deprecated2::0`: text\n              _,\n-             //~^ ERROR use of deprecated item 'this_crate2::Deprecated2::1': text\n+             //~^ ERROR use of deprecated field `this_crate2::Deprecated2::1`: text\n              _)\n-            //~^ ERROR use of deprecated item 'this_crate2::Deprecated2::2': text\n+            //~^ ERROR use of deprecated field `this_crate2::Deprecated2::2`: text\n             = x;\n         let Deprecated2\n-        //~^ ERROR use of deprecated item 'this_crate2::Deprecated2': text\n+        //~^ ERROR use of deprecated tuple struct `this_crate2::Deprecated2`: text\n             // the patterns are all fine:\n             (..) = x;\n     }"}, {"sha": "03a2ec7edc91634dc1927db561524db8558ce67c", "filename": "src/test/ui/deprecation/deprecation-lint.stderr", "status": "modified", "additions": 158, "deletions": 158, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'deprecation_lint::deprecated': text\n+error: use of deprecated function `deprecation_lint::deprecated`: text\n   --> $DIR/deprecation-lint.rs:17:9\n    |\n LL |         deprecated();\n@@ -10,727 +10,727 @@ note: the lint level is defined here\n LL | #![deny(deprecated)]\n    |         ^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:22:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:24:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::deprecated_text': text\n+error: use of deprecated function `deprecation_lint::deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:26:9\n    |\n LL |         deprecated_text();\n    |         ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:31:9\n    |\n-LL |         Trait::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Trait::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:33:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::DeprecatedStruct': text\n+error: use of deprecated struct `deprecation_lint::DeprecatedStruct`: text\n   --> $DIR/deprecation-lint.rs:35:17\n    |\n LL |         let _ = DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::DeprecatedUnitStruct': text\n+error: use of deprecated struct `deprecation_lint::DeprecatedUnitStruct`: text\n   --> $DIR/deprecation-lint.rs:39:17\n    |\n LL |         let _ = DeprecatedUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Enum::DeprecatedVariant': text\n+error: use of deprecated variant `deprecation_lint::Enum::DeprecatedVariant`: text\n   --> $DIR/deprecation-lint.rs:41:17\n    |\n LL |         let _ = Enum::DeprecatedVariant;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::DeprecatedTupleStruct': text\n+error: use of deprecated struct `deprecation_lint::DeprecatedTupleStruct`: text\n   --> $DIR/deprecation-lint.rs:43:17\n    |\n LL |         let _ = DeprecatedTupleStruct (1);\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::nested::DeprecatedStruct': text\n+error: use of deprecated struct `deprecation_lint::nested::DeprecatedStruct`: text\n   --> $DIR/deprecation-lint.rs:45:17\n    |\n LL |         let _ = nested::DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::nested::DeprecatedUnitStruct': text\n+error: use of deprecated struct `deprecation_lint::nested::DeprecatedUnitStruct`: text\n   --> $DIR/deprecation-lint.rs:49:17\n    |\n LL |         let _ = nested::DeprecatedUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::nested::Enum::DeprecatedVariant': text\n+error: use of deprecated variant `deprecation_lint::nested::Enum::DeprecatedVariant`: text\n   --> $DIR/deprecation-lint.rs:51:17\n    |\n-LL |         let _ = nested::Enum::DeprecatedVariant;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   let _ = nested::Enum::DeprecatedVariant;\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::nested::DeprecatedTupleStruct': text\n+error: use of deprecated struct `deprecation_lint::nested::DeprecatedTupleStruct`: text\n   --> $DIR/deprecation-lint.rs:53:17\n    |\n-LL |         let _ = nested::DeprecatedTupleStruct (1);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   let _ = nested::DeprecatedTupleStruct (1);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::deprecated_text': text\n+error: use of deprecated function `deprecation_lint::deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:60:25\n    |\n LL |         macro_test_arg!(deprecated_text());\n    |                         ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::deprecated_text': text\n+error: use of deprecated function `deprecation_lint::deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:61:41\n    |\n LL |         macro_test_arg!(macro_test_arg!(deprecated_text()));\n    |                                         ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:66:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:68:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:70:9\n    |\n-LL |         Trait::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Trait::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:72:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::DeprecatedTrait': text\n+error: use of deprecated trait `deprecation_lint::DeprecatedTrait`: text\n   --> $DIR/deprecation-lint.rs:82:10\n    |\n LL |     impl DeprecatedTrait for S {}\n    |          ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::DeprecatedTrait': text\n+error: use of deprecated trait `deprecation_lint::DeprecatedTrait`: text\n   --> $DIR/deprecation-lint.rs:83:24\n    |\n LL |     trait LocalTrait : DeprecatedTrait { }\n    |                        ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated': text\n+error: use of deprecated struct `deprecation_lint::Deprecated`: text\n   --> $DIR/deprecation-lint.rs:114:17\n    |\n LL |         let x = Deprecated {\n    |                 ^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated': text\n+error: use of deprecated struct `deprecation_lint::Deprecated`: text\n   --> $DIR/deprecation-lint.rs:123:13\n    |\n LL |         let Deprecated {\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated': text\n+error: use of deprecated struct `deprecation_lint::Deprecated`: text\n   --> $DIR/deprecation-lint.rs:129:13\n    |\n LL |         let Deprecated\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2': text\n+error: use of deprecated struct `deprecation_lint::Deprecated2`: text\n   --> $DIR/deprecation-lint.rs:133:17\n    |\n LL |         let x = Deprecated2(1, 2, 3);\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2': text\n+error: use of deprecated struct `deprecation_lint::Deprecated2`: text\n   --> $DIR/deprecation-lint.rs:143:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2': text\n+error: use of deprecated struct `deprecation_lint::Deprecated2`: text\n   --> $DIR/deprecation-lint.rs:152:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::deprecated_mod::deprecated': text\n+error: use of deprecated function `deprecation_lint::deprecated_mod::deprecated`: text\n   --> $DIR/deprecation-lint.rs:163:9\n    |\n LL |         deprecated_mod::deprecated();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::deprecated': text\n+error: use of deprecated function `this_crate::deprecated`: text\n   --> $DIR/deprecation-lint.rs:246:9\n    |\n LL |         deprecated();\n    |         ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:251:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:253:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::deprecated_text': text\n+error: use of deprecated function `this_crate::deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:255:9\n    |\n LL |         deprecated_text();\n    |         ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:260:9\n    |\n LL |         Trait::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:262:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::deprecated_future': text\n+error: use of deprecated function `this_crate::deprecated_future`: text\n   --> $DIR/deprecation-lint.rs:265:9\n    |\n LL |         deprecated_future();\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::deprecated_future_text': text\n+error: use of deprecated function `this_crate::deprecated_future_text`: text\n   --> $DIR/deprecation-lint.rs:266:9\n    |\n LL |         deprecated_future_text();\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::DeprecatedStruct': text\n+error: use of deprecated struct `this_crate::DeprecatedStruct`: text\n   --> $DIR/deprecation-lint.rs:268:17\n    |\n LL |         let _ = DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::DeprecatedUnitStruct': text\n+error: use of deprecated unit struct `this_crate::DeprecatedUnitStruct`: text\n   --> $DIR/deprecation-lint.rs:273:17\n    |\n LL |         let _ = DeprecatedUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Enum::DeprecatedVariant': text\n+error: use of deprecated unit variant `this_crate::Enum::DeprecatedVariant`: text\n   --> $DIR/deprecation-lint.rs:275:17\n    |\n LL |         let _ = Enum::DeprecatedVariant;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::DeprecatedTupleStruct': text\n+error: use of deprecated tuple struct `this_crate::DeprecatedTupleStruct`: text\n   --> $DIR/deprecation-lint.rs:277:17\n    |\n LL |         let _ = DeprecatedTupleStruct (1);\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::nested::DeprecatedStruct': text\n+error: use of deprecated struct `this_crate::nested::DeprecatedStruct`: text\n   --> $DIR/deprecation-lint.rs:279:17\n    |\n LL |         let _ = nested::DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::nested::DeprecatedUnitStruct': text\n+error: use of deprecated unit struct `this_crate::nested::DeprecatedUnitStruct`: text\n   --> $DIR/deprecation-lint.rs:284:17\n    |\n LL |         let _ = nested::DeprecatedUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::nested::Enum::DeprecatedVariant': text\n+error: use of deprecated unit variant `this_crate::nested::Enum::DeprecatedVariant`: text\n   --> $DIR/deprecation-lint.rs:286:17\n    |\n-LL |         let _ = nested::Enum::DeprecatedVariant;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   let _ = nested::Enum::DeprecatedVariant;\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::nested::DeprecatedTupleStruct': text\n+error: use of deprecated tuple struct `this_crate::nested::DeprecatedTupleStruct`: text\n   --> $DIR/deprecation-lint.rs:288:17\n    |\n-LL |         let _ = nested::DeprecatedTupleStruct (1);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   let _ = nested::DeprecatedTupleStruct (1);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:293:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:295:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:297:9\n    |\n LL |         Trait::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:299:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}#0::bar'\n+error: use of deprecated function `this_crate::test_fn_closure_body::{{closure}}#0::bar`\n   --> $DIR/deprecation-lint.rs:317:13\n    |\n LL |             bar();\n    |             ^^^\n \n-error: use of deprecated item 'this_crate::DeprecatedTrait': text\n+error: use of deprecated trait `this_crate::DeprecatedTrait`: text\n   --> $DIR/deprecation-lint.rs:336:10\n    |\n LL |     impl DeprecatedTrait for S { }\n    |          ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::DeprecatedTrait': text\n+error: use of deprecated trait `this_crate::DeprecatedTrait`: text\n   --> $DIR/deprecation-lint.rs:338:24\n    |\n LL |     trait LocalTrait : DeprecatedTrait { }\n    |                        ^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated': text\n+error: use of deprecated struct `this_crate2::Deprecated`: text\n   --> $DIR/deprecation-lint.rs:390:17\n    |\n LL |         let x = Deprecated {\n    |                 ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated': text\n+error: use of deprecated struct `this_crate2::Deprecated`: text\n   --> $DIR/deprecation-lint.rs:399:13\n    |\n LL |         let Deprecated {\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated': text\n+error: use of deprecated struct `this_crate2::Deprecated`: text\n   --> $DIR/deprecation-lint.rs:405:13\n    |\n LL |         let Deprecated\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2': text\n+error: use of deprecated tuple struct `this_crate2::Deprecated2`: text\n   --> $DIR/deprecation-lint.rs:410:17\n    |\n LL |         let x = Deprecated2(1, 2, 3);\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2': text\n+error: use of deprecated tuple struct `this_crate2::Deprecated2`: text\n   --> $DIR/deprecation-lint.rs:420:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2': text\n+error: use of deprecated tuple struct `this_crate2::Deprecated2`: text\n   --> $DIR/deprecation-lint.rs:429:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::MethodTester::method_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated`: text\n   --> $DIR/deprecation-lint.rs:18:13\n    |\n LL |         foo.method_deprecated();\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::MethodTester::method_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated`: text\n   --> $DIR/deprecation-lint.rs:19:9\n    |\n LL |         Foo::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::MethodTester::method_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated`: text\n   --> $DIR/deprecation-lint.rs:20:9\n    |\n LL |         <Foo>::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:21:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:23:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::MethodTester::method_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:27:13\n    |\n-LL |         foo.method_deprecated_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.method_deprecated_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::MethodTester::method_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:28:9\n    |\n-LL |         Foo::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Foo::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::MethodTester::method_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::MethodTester::method_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:29:9\n    |\n-LL |         <Foo>::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:30:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:32:9\n    |\n-LL |         <Foo>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::DeprecatedStruct::i': text\n+error: use of deprecated field `deprecation_lint::DeprecatedStruct::i`: text\n   --> $DIR/deprecation-lint.rs:36:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-error: use of deprecated item 'deprecation_lint::nested::DeprecatedStruct::i': text\n+error: use of deprecated field `deprecation_lint::nested::DeprecatedStruct::i`: text\n   --> $DIR/deprecation-lint.rs:46:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:65:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:67:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:69:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:71:9\n    |\n-LL |         <Foo>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:76:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `deprecation_lint::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:77:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Stable::override2': text\n+error: use of deprecated field `deprecation_lint::Stable::override2`: text\n   --> $DIR/deprecation-lint.rs:87:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Stable::override2': text\n+error: use of deprecated field `deprecation_lint::Stable::override2`: text\n   --> $DIR/deprecation-lint.rs:91:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Stable::override2': text\n+error: use of deprecated field `deprecation_lint::Stable::override2`: text\n   --> $DIR/deprecation-lint.rs:95:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Stable2::2': text\n+error: use of deprecated field `deprecation_lint::Stable2::2`: text\n   --> $DIR/deprecation-lint.rs:103:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'deprecation_lint::Stable2::2': text\n+error: use of deprecated field `deprecation_lint::Stable2::2`: text\n   --> $DIR/deprecation-lint.rs:108:20\n    |\n LL |                    _)\n    |                    ^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated::inherit': text\n+error: use of deprecated field `deprecation_lint::Deprecated::inherit`: text\n   --> $DIR/deprecation-lint.rs:116:13\n    |\n LL |             inherit: 1,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated::inherit': text\n+error: use of deprecated field `deprecation_lint::Deprecated::inherit`: text\n   --> $DIR/deprecation-lint.rs:120:17\n    |\n LL |         let _ = x.inherit;\n    |                 ^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated::inherit': text\n+error: use of deprecated field `deprecation_lint::Deprecated::inherit`: text\n   --> $DIR/deprecation-lint.rs:125:13\n    |\n LL |             inherit: _,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2::0': text\n+error: use of deprecated field `deprecation_lint::Deprecated2::0`: text\n   --> $DIR/deprecation-lint.rs:136:17\n    |\n LL |         let _ = x.0;\n    |                 ^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2::1': text\n+error: use of deprecated field `deprecation_lint::Deprecated2::1`: text\n   --> $DIR/deprecation-lint.rs:138:17\n    |\n LL |         let _ = x.1;\n    |                 ^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2::2': text\n+error: use of deprecated field `deprecation_lint::Deprecated2::2`: text\n   --> $DIR/deprecation-lint.rs:140:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2::0': text\n+error: use of deprecated field `deprecation_lint::Deprecated2::0`: text\n   --> $DIR/deprecation-lint.rs:145:14\n    |\n LL |             (_,\n    |              ^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2::1': text\n+error: use of deprecated field `deprecation_lint::Deprecated2::1`: text\n   --> $DIR/deprecation-lint.rs:147:14\n    |\n LL |              _,\n    |              ^\n \n-error: use of deprecated item 'deprecation_lint::Deprecated2::2': text\n+error: use of deprecated field `deprecation_lint::Deprecated2::2`: text\n   --> $DIR/deprecation-lint.rs:149:14\n    |\n LL |              _)\n    |              ^\n \n-error: use of deprecated item 'this_crate::MethodTester::method_deprecated': text\n+error: use of deprecated associated function `this_crate::MethodTester::method_deprecated`: text\n   --> $DIR/deprecation-lint.rs:247:13\n    |\n LL |         foo.method_deprecated();\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::MethodTester::method_deprecated': text\n+error: use of deprecated associated function `this_crate::MethodTester::method_deprecated`: text\n   --> $DIR/deprecation-lint.rs:248:9\n    |\n LL |         Foo::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::MethodTester::method_deprecated': text\n+error: use of deprecated associated function `this_crate::MethodTester::method_deprecated`: text\n   --> $DIR/deprecation-lint.rs:249:9\n    |\n LL |         <Foo>::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:250:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:252:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n+error: use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:256:13\n    |\n-LL |         foo.method_deprecated_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.method_deprecated_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n+error: use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:257:9\n    |\n-LL |         Foo::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Foo::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n+error: use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:258:9\n    |\n-LL |         <Foo>::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:259:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:261:9\n    |\n LL |         <Foo>::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::DeprecatedStruct::i': text\n+error: use of deprecated field `this_crate::DeprecatedStruct::i`: text\n   --> $DIR/deprecation-lint.rs:270:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-error: use of deprecated item 'this_crate::nested::DeprecatedStruct::i': text\n+error: use of deprecated field `this_crate::nested::DeprecatedStruct::i`: text\n   --> $DIR/deprecation-lint.rs:281:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:292:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:294:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:296:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:298:9\n    |\n LL |         <Foo>::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/deprecation-lint.rs:303:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+error: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/deprecation-lint.rs:304:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Stable::override2': text\n+error: use of deprecated field `this_crate2::Stable::override2`: text\n   --> $DIR/deprecation-lint.rs:363:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Stable::override2': text\n+error: use of deprecated field `this_crate2::Stable::override2`: text\n   --> $DIR/deprecation-lint.rs:367:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Stable::override2': text\n+error: use of deprecated field `this_crate2::Stable::override2`: text\n   --> $DIR/deprecation-lint.rs:371:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Stable2::2': text\n+error: use of deprecated field `this_crate2::Stable2::2`: text\n   --> $DIR/deprecation-lint.rs:379:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate2::Stable2::2': text\n+error: use of deprecated field `this_crate2::Stable2::2`: text\n   --> $DIR/deprecation-lint.rs:384:20\n    |\n LL |                    _)\n    |                    ^\n \n-error: use of deprecated item 'this_crate2::Deprecated::inherit': text\n+error: use of deprecated field `this_crate2::Deprecated::inherit`: text\n   --> $DIR/deprecation-lint.rs:392:13\n    |\n LL |             inherit: 1,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated::inherit': text\n+error: use of deprecated field `this_crate2::Deprecated::inherit`: text\n   --> $DIR/deprecation-lint.rs:396:17\n    |\n LL |         let _ = x.inherit;\n    |                 ^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated::inherit': text\n+error: use of deprecated field `this_crate2::Deprecated::inherit`: text\n   --> $DIR/deprecation-lint.rs:401:13\n    |\n LL |             inherit: _,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2::0': text\n+error: use of deprecated field `this_crate2::Deprecated2::0`: text\n   --> $DIR/deprecation-lint.rs:413:17\n    |\n LL |         let _ = x.0;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2::1': text\n+error: use of deprecated field `this_crate2::Deprecated2::1`: text\n   --> $DIR/deprecation-lint.rs:415:17\n    |\n LL |         let _ = x.1;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2::2': text\n+error: use of deprecated field `this_crate2::Deprecated2::2`: text\n   --> $DIR/deprecation-lint.rs:417:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate2::Deprecated2::0': text\n+error: use of deprecated field `this_crate2::Deprecated2::0`: text\n   --> $DIR/deprecation-lint.rs:422:14\n    |\n LL |             (_,\n    |              ^\n \n-error: use of deprecated item 'this_crate2::Deprecated2::1': text\n+error: use of deprecated field `this_crate2::Deprecated2::1`: text\n   --> $DIR/deprecation-lint.rs:424:14\n    |\n LL |              _,\n    |              ^\n \n-error: use of deprecated item 'this_crate2::Deprecated2::2': text\n+error: use of deprecated field `this_crate2::Deprecated2::2`: text\n   --> $DIR/deprecation-lint.rs:426:14\n    |\n LL |              _)"}, {"sha": "6a619bcc49c2d841bb6603bf316065e1ef461f98", "filename": "src/test/ui/deprecation/rustc_deprecation-in-future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -11,5 +11,5 @@\n pub struct S;\n \n fn main() {\n-    let _ = S; //~ ERROR use of item 'S' that will be deprecated in future version 99.99.99: effectively never\n+    let _ = S; //~ ERROR use of unit struct `S` that will be deprecated in future version 99.99.99: effectively never\n }"}, {"sha": "e4f50d10dadd231841e29d2342c0e5fbd2017ce0", "filename": "src/test/ui/deprecation/rustc_deprecation-in-future.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of item 'S' that will be deprecated in future version 99.99.99: effectively never\n+error: use of unit struct `S` that will be deprecated in future version 99.99.99: effectively never\n   --> $DIR/rustc_deprecation-in-future.rs:14:13\n    |\n LL |     let _ = S;"}, {"sha": "8a7cb1def909e3a818d6d2ca588e3dc018456dc9", "filename": "src/test/ui/deprecation/suggestion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,8 @@\n-error: use of deprecated item 'Foo::deprecated': replaced by `replacement`\n+error: use of deprecated associated function `Foo::deprecated`: replaced by `replacement`\n   --> $DIR/suggestion.rs:27:9\n    |\n LL |     foo.deprecated();\n-   |         ^^^^^^^^^^ help: replace the use of the deprecated item: `replacement`\n+   |         ^^^^^^^^^^ help: replace the use of the deprecated associated function: `replacement`\n    |\n note: the lint level is defined here\n   --> $DIR/suggestion.rs:7:9"}, {"sha": "3fd81401e00fd57d15679c5aea99f0180ddbcff2", "filename": "src/test/ui/issues/issue-17337.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-17337.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-17337.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17337.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -13,5 +13,5 @@ impl Foo {\n \n fn main() {\n     Foo\n-    .foo(); //~ ERROR use of deprecated item\n+    .foo(); //~ ERROR use of deprecated\n }"}, {"sha": "34c2eb05fff8b2ade6f3a0657867f720e438eec7", "filename": "src/test/ui/issues/issue-17337.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-17337.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-17337.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17337.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'Foo::foo': text\n+error: use of deprecated associated function `Foo::foo`: text\n   --> $DIR/issue-17337.rs:16:6\n    |\n LL |     .foo();"}, {"sha": "ac2d1d1ed8b733cc6cc402aef47926ec0039642a", "filename": "src/test/ui/issues/issue-37131.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-37131.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-37131.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37131.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -3,6 +3,7 @@\n \n // compile-flags: --target=thumbv6m-none-eabi\n // ignore-arm\n+// needs-llvm-components: arm\n \n // error-pattern:target may not be installed\n fn main() { }"}, {"sha": "ddb070ddf9fae8838ac1df8fcdeeedb1a0877a4b", "filename": "src/test/ui/issues/issue-49851/compiler-builtins-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-49851%2Fcompiler-builtins-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-49851%2Fcompiler-builtins-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49851%2Fcompiler-builtins-error.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,6 +1,7 @@\n //~ ERROR 1:1: 1:1: can't find crate for `core` [E0463]\n \n // compile-flags: --target thumbv7em-none-eabihf\n+// needs-llvm-components: arm\n #![deny(unsafe_code)]\n #![deny(warnings)]\n #![no_std]"}, {"sha": "f713dee507f5b0adec5ec33d019b46eb9c9a17f6", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,3 @@\n-#![feature(inner_deref)]\n-\n fn main() {\n     let _result = &Ok(42).as_deref();\n //~^ ERROR no method named `as_deref` found"}, {"sha": "96524c3095999b2758e948194e74d99e75b519e1", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: no method named `as_deref` found for enum `std::result::Result<{integer}, _>` in the current scope\n-  --> $DIR/result-as_deref.rs:4:27\n+  --> $DIR/result-as_deref.rs:2:27\n    |\n LL |     let _result = &Ok(42).as_deref();\n    |                           ^^^^^^^^ help: there is an associated function with a similar name: `as_ref`"}, {"sha": "104aa3bcadff2e5ea2678333119d5b3a54b98bd7", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_err.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.rs?ref=fdfbd89946ca34d12eec658d111ce9a85cd23df0", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &Err(41).as_deref_err();\n-//~^ ERROR no method named `as_deref_err` found\n-}"}, {"sha": "68ebfab95c47e79fddfd6632558ff62aad0e225e", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_err.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr?ref=fdfbd89946ca34d12eec658d111ce9a85cd23df0", "patch": "@@ -1,13 +0,0 @@\n-error[E0599]: no method named `as_deref_err` found for enum `std::result::Result<_, {integer}>` in the current scope\n-  --> $DIR/result-as_deref_err.rs:4:28\n-   |\n-LL |     let _result = &Err(41).as_deref_err();\n-   |                            ^^^^^^^^^^^^ help: there is an associated function with a similar name: `as_deref_mut`\n-   |\n-   = note: the method `as_deref_err` exists but the following trait bounds were not satisfied:\n-           `{integer}: std::ops::Deref`\n-           `<{integer} as std::ops::Deref>::Target = _`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "3af7033dd5dd36e2ca8351b1f276b7e81fa7062e", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,3 @@\n-#![feature(inner_deref)]\n-\n fn main() {\n     let _result = &mut Ok(42).as_deref_mut();\n //~^ ERROR no method named `as_deref_mut` found"}, {"sha": "73266bc7f687bc399045b44076eff3990d32f538", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,8 @@\n error[E0599]: no method named `as_deref_mut` found for enum `std::result::Result<{integer}, _>` in the current scope\n-  --> $DIR/result-as_deref_mut.rs:4:31\n+  --> $DIR/result-as_deref_mut.rs:2:31\n    |\n LL |     let _result = &mut Ok(42).as_deref_mut();\n-   |                               ^^^^^^^^^^^^ help: there is an associated function with a similar name: `as_deref_err`\n+   |                               ^^^^^^^^^^^^ method not found in `std::result::Result<{integer}, _>`\n    |\n    = note: the method `as_deref_mut` exists but the following trait bounds were not satisfied:\n            `{integer}: std::ops::DerefMut`"}, {"sha": "b7849ecb6d2422e3355784baca290883c612252d", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_err.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.rs?ref=fdfbd89946ca34d12eec658d111ce9a85cd23df0", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &mut Err(41).as_deref_mut_err();\n-//~^ ERROR no method named `as_deref_mut_err` found\n-}"}, {"sha": "d724ae5c74bdefbc7ea94435c381d0db709e8f35", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_err.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr?ref=fdfbd89946ca34d12eec658d111ce9a85cd23df0", "patch": "@@ -1,13 +0,0 @@\n-error[E0599]: no method named `as_deref_mut_err` found for enum `std::result::Result<_, {integer}>` in the current scope\n-  --> $DIR/result-as_deref_mut_err.rs:4:32\n-   |\n-LL |     let _result = &mut Err(41).as_deref_mut_err();\n-   |                                ^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `as_deref_mut`\n-   |\n-   = note: the method `as_deref_mut_err` exists but the following trait bounds were not satisfied:\n-           `{integer}: std::ops::DerefMut`\n-           `<{integer} as std::ops::Deref>::Target = _`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "e6a9451a060cdfdcb741dd017e788d1331263bd0", "filename": "src/test/ui/issues/issue-50993.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50993.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-50993.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50993.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,5 @@\n // compile-flags: --crate-type dylib --target thumbv7em-none-eabihf\n+// needs-llvm-components: arm\n // build-pass\n // error-pattern: dropping unsupported crate type `dylib` for target `thumbv7em-none-eabihf`\n "}, {"sha": "1b80a21793a0aa42b8b89813a783e3069073a454", "filename": "src/test/ui/issues/issue-72574-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -6,3 +6,5 @@ fn main() {\n     }\n }\n //~^^^^ ERROR `_x @` is not allowed in a tuple\n+//~| ERROR: `..` patterns are not allowed here\n+//~| ERROR: mismatched types"}, {"sha": "92ebb45e88d4b71b6e26215fe9c37b1ef51fa5b8", "filename": "src/test/ui/issues/issue-72574-1.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,5 +10,25 @@ help: if you don't need to use the contents of _x, discard the tuple's remaining\n LL |         (_a, ..) => {}\n    |              ^^\n \n-error: aborting due to previous error\n+error: `..` patterns are not allowed here\n+  --> $DIR/issue-72574-1.rs:4:19\n+   |\n+LL |         (_a, _x @ ..) => {}\n+   |                   ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-72574-1.rs:4:9\n+   |\n+LL |     match x {\n+   |           - this expression has type `({integer}, {integer}, {integer})`\n+LL |         (_a, _x @ ..) => {}\n+   |         ^^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 2 elements\n+   |\n+   = note: expected tuple `({integer}, {integer}, {integer})`\n+              found tuple `(_, _)`\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0ad2db848b2811c46479f8eaa243cf93e77d677a", "filename": "src/test/ui/issues/issue-72574-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -8,3 +8,5 @@ fn main() {\n     }\n }\n //~^^^^ ERROR `_x @` is not allowed in a tuple struct\n+//~| ERROR: `..` patterns are not allowed here\n+//~| ERROR: this pattern has 2 fields, but the corresponding tuple struct has 3 fields"}, {"sha": "0a9c868af7af8cdc63e553c2e4520b4ba023ce46", "filename": "src/test/ui/issues/issue-72574-2.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -10,5 +10,23 @@ help: if you don't need to use the contents of _x, discard the tuple's remaining\n LL |         Binder(_a, ..) => {}\n    |                    ^^\n \n-error: aborting due to previous error\n+error: `..` patterns are not allowed here\n+  --> $DIR/issue-72574-2.rs:6:25\n+   |\n+LL |         Binder(_a, _x @ ..) => {}\n+   |                         ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error[E0023]: this pattern has 2 fields, but the corresponding tuple struct has 3 fields\n+  --> $DIR/issue-72574-2.rs:6:9\n+   |\n+LL | struct Binder(i32, i32, i32);\n+   | ----------------------------- tuple struct defined here\n+...\n+LL |         Binder(_a, _x @ ..) => {}\n+   |         ^^^^^^^^^^^^^^^^^^^ expected 3 fields, found 2\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0023`."}, {"sha": "75632d11c1df0d65d00272b69db73c9d63442a20", "filename": "src/test/ui/issues/issue-74539.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-74539.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-74539.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74539.rs?ref=fdfbd89946ca34d12eec658d111ce9a85cd23df0", "patch": "@@ -1,12 +0,0 @@\n-enum E {\n-    A(u8, u8),\n-}\n-\n-fn main() {\n-    let e = E::A(2, 3);\n-    match e {\n-        E::A(x @ ..) => {  //~ ERROR `x @` is not allowed in a tuple\n-            x //~ ERROR cannot find value `x` in this scope\n-        }\n-    };\n-}"}, {"sha": "94526dcd7cb3971223bcfa3bd263b9fb1d09bb59", "filename": "src/test/ui/issues/issue-74539.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-74539.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfbd89946ca34d12eec658d111ce9a85cd23df0/src%2Ftest%2Fui%2Fissues%2Fissue-74539.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74539.stderr?ref=fdfbd89946ca34d12eec658d111ce9a85cd23df0", "patch": "@@ -1,21 +0,0 @@\n-error[E0425]: cannot find value `x` in this scope\n-  --> $DIR/issue-74539.rs:9:13\n-   |\n-LL |             x\n-   |             ^ help: a local variable with a similar name exists: `e`\n-\n-error: `x @` is not allowed in a tuple struct\n-  --> $DIR/issue-74539.rs:8:14\n-   |\n-LL |         E::A(x @ ..) => {\n-   |              ^^^^^^ this is only allowed in slice patterns\n-   |\n-   = help: remove this and bind each tuple field independently\n-help: if you don't need to use the contents of x, discard the tuple's remaining fields\n-   |\n-LL |         E::A(..) => {\n-   |              ^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "aed7ddbcb8c9cd801b3e0390b1c3e6fca86c4241", "filename": "src/test/ui/issues/issue-75704.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-75704.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fissues%2Fissue-75704.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75704.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,7 @@\n+// Caused an infinite loop during SimlifyCfg MIR transform previously.\n+//\n+// build-pass\n+\n+fn main() {\n+    loop { continue; }\n+}"}, {"sha": "8064c3a88d1d98c1ff2d84d1b71b1cd64c1a4600", "filename": "src/test/ui/lint/issue-74883-unused-paren-baren-yield.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Fissue-74883-unused-paren-baren-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Fissue-74883-unused-paren-baren-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-74883-unused-paren-baren-yield.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,26 @@\n+#![feature(generator_trait)]\n+#![feature(generators)]\n+#![deny(unused_braces, unused_parens)]\n+\n+use std::ops::Generator;\n+use std::pin::Pin;\n+\n+fn main() {\n+    let mut x = |_| {\n+        while let Some(_) = (yield) {}\n+        while let Some(_) = {yield} {}\n+\n+        // Only warn these cases\n+        while let Some(_) = ({yield}) {} //~ ERROR: unnecessary parentheses\n+        while let Some(_) = ((yield)) {} //~ ERROR: unnecessary parentheses\n+        {{yield}}; //~ ERROR: unnecessary braces\n+        {( yield )}; //~ ERROR: unnecessary parentheses\n+        while let Some(_) = {(yield)} {} //~ ERROR: unnecessary parentheses\n+        while let Some(_) = {{yield}} {} //~ ERROR: unnecessary braces\n+\n+        // FIXME: It'd be great if we could also warn them.\n+        ((yield));\n+        ({ yield });\n+    };\n+    let _ = Pin::new(&mut x).resume(Some(5));\n+}"}, {"sha": "3f6260dc6e19e29211f9207c03d0f306857a0a80", "filename": "src/test/ui/lint/issue-74883-unused-paren-baren-yield.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Fissue-74883-unused-paren-baren-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Fissue-74883-unused-paren-baren-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-74883-unused-paren-baren-yield.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,50 @@\n+error: unnecessary parentheses around `let` scrutinee expression\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:14:29\n+   |\n+LL |         while let Some(_) = ({yield}) {}\n+   |                             ^^^^^^^^^ help: remove these parentheses\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:3:24\n+   |\n+LL | #![deny(unused_braces, unused_parens)]\n+   |                        ^^^^^^^^^^^^^\n+\n+error: unnecessary parentheses around `let` scrutinee expression\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:15:29\n+   |\n+LL |         while let Some(_) = ((yield)) {}\n+   |                             ^^^^^^^^^ help: remove these parentheses\n+\n+error: unnecessary braces around block return value\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:16:10\n+   |\n+LL |         {{yield}};\n+   |          ^^^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:3:9\n+   |\n+LL | #![deny(unused_braces, unused_parens)]\n+   |         ^^^^^^^^^^^^^\n+\n+error: unnecessary parentheses around block return value\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:17:10\n+   |\n+LL |         {( yield )};\n+   |          ^^^^^^^^^ help: remove these parentheses\n+\n+error: unnecessary parentheses around block return value\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:18:30\n+   |\n+LL |         while let Some(_) = {(yield)} {}\n+   |                              ^^^^^^^ help: remove these parentheses\n+\n+error: unnecessary braces around block return value\n+  --> $DIR/issue-74883-unused-paren-baren-yield.rs:19:30\n+   |\n+LL |         while let Some(_) = {{yield}} {}\n+   |                              ^^^^^^^ help: remove these braces\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "034499145b78051dc57619c7732dce70d79692b9", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -23,7 +23,7 @@ struct _\u30d2b;\n struct __\u03c7a;\n //~^ ERROR type `__\u03c7a` should have an upper camel case name\n \n-// Besides this, we cannot have two continous underscores in the middle.\n+// Besides this, we cannot have two continuous underscores in the middle.\n \n struct \u5bf9__\u5426;\n //~^ ERROR type `\u5bf9__\u5426` should have an upper camel case name"}, {"sha": "0b52a5fde35dc8bb96108c89aad2cb7962a04f90", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -18,7 +18,7 @@ fn \u7f16\u7a0b() {}\n fn \u0426() {}\n //~^ ERROR function `\u0426` should have a snake case name\n \n-// besides this, you cannot use continous underscores in the middle\n+// besides this, you cannot use continuous underscores in the middle\n \n fn \u5206__\u9694() {}\n //~^ ERROR function `\u5206__\u9694` should have a snake case name"}, {"sha": "985166e095dfcb19194b7a799a99cda648bcae7d", "filename": "src/test/ui/lint/lint-output-format-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-output-format-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-output-format-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-output-format-2.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,11 +5,11 @@\n \n extern crate lint_output_format;\n use lint_output_format::{foo, bar};\n-//~^ WARNING use of deprecated item 'lint_output_format::foo': text\n+//~^ WARNING use of deprecated function `lint_output_format::foo`: text\n \n \n fn main() {\n     let _x = foo();\n-    //~^ WARNING use of deprecated item 'lint_output_format::foo': text\n+    //~^ WARNING use of deprecated function `lint_output_format::foo`: text\n     let _y = bar();\n }"}, {"sha": "a36dbd61fdcea12781d5354ee8152192bea09a9e", "filename": "src/test/ui/lint/lint-output-format-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-output-format-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-output-format-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-output-format-2.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,12 +1,12 @@\n-warning: use of deprecated item 'lint_output_format::foo': text\n+warning: use of deprecated function `lint_output_format::foo`: text\n   --> $DIR/lint-output-format-2.rs:7:26\n    |\n LL | use lint_output_format::{foo, bar};\n    |                          ^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n-warning: use of deprecated item 'lint_output_format::foo': text\n+warning: use of deprecated function `lint_output_format::foo`: text\n   --> $DIR/lint-output-format-2.rs:12:14\n    |\n LL |     let _x = foo();"}, {"sha": "a6fde11495c5aa2a816349b33aafe15ceeaf4247", "filename": "src/test/ui/lint/lint-stability-deprecated.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -22,41 +22,41 @@ mod cross_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ WARN use of deprecated item 'lint_stability::deprecated'\n-        foo.method_deprecated(); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated'\n-        Foo::method_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated'\n-        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated'\n-        foo.trait_deprecated(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-\n-        deprecated_text(); //~ WARN use of deprecated item 'lint_stability::deprecated_text': text\n-        foo.method_deprecated_text(); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_text': text\n-        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_text': text\n-        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_text': text\n-        foo.trait_deprecated_text(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-\n-        deprecated_unstable(); //~ WARN use of deprecated item 'lint_stability::deprecated_unstable'\n-        foo.method_deprecated_unstable(); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable'\n-        Foo::method_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable'\n-        <Foo>::method_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable'\n-        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-\n-        deprecated_unstable_text(); //~ WARN use of deprecated item 'lint_stability::deprecated_unstable_text': text\n-        foo.method_deprecated_unstable_text(); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable_text': text\n-        Foo::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable_text': text\n-        <Foo>::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable_text': text\n-        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n-        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+        deprecated(); //~ WARN use of deprecated function `lint_stability::deprecated`\n+        foo.method_deprecated(); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated`\n+        Foo::method_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated`\n+        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated`\n+        foo.trait_deprecated(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+\n+        deprecated_text(); //~ WARN use of deprecated function `lint_stability::deprecated_text`: text\n+        foo.method_deprecated_text(); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_text`: text\n+        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_text`: text\n+        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_text`: text\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+\n+        deprecated_unstable(); //~ WARN use of deprecated function `lint_stability::deprecated_unstable`\n+        foo.method_deprecated_unstable(); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable`\n+        Foo::method_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable`\n+        <Foo>::method_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable`\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+\n+        deprecated_unstable_text(); //~ WARN use of deprecated function `lint_stability::deprecated_unstable_text`: text\n+        foo.method_deprecated_unstable_text(); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable_text`: text\n+        Foo::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable_text`: text\n+        <Foo>::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable_text`: text\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n \n         unstable();\n         foo.method_unstable();\n@@ -96,38 +96,38 @@ mod cross_crate {\n \n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n-        //~^ WARN use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n-        //~| WARN use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n+        //~^ WARN use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n+        //~| WARN use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n         type A = dyn TraitWithAssociatedTypes<\n             TypeUnstable = u8,\n             TypeDeprecated = u16,\n-            //~^ WARN use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated'\n-            //~| WARN use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated'\n-            //~| WARN use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated'\n+            //~^ WARN use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`\n+            //~| WARN use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`\n+            //~| WARN use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`\n         >;\n \n-        let _ = DeprecatedStruct { //~ WARN use of deprecated item 'lint_stability::DeprecatedStruct'\n-            i: 0 //~ WARN use of deprecated item 'lint_stability::DeprecatedStruct::i'\n+        let _ = DeprecatedStruct { //~ WARN use of deprecated struct `lint_stability::DeprecatedStruct`\n+            i: 0 //~ WARN use of deprecated field `lint_stability::DeprecatedStruct::i`\n         };\n         let _ = DeprecatedUnstableStruct {\n-            //~^ WARN use of deprecated item 'lint_stability::DeprecatedUnstableStruct'\n-            i: 0 //~ WARN use of deprecated item 'lint_stability::DeprecatedUnstableStruct::i'\n+            //~^ WARN use of deprecated struct `lint_stability::DeprecatedUnstableStruct`\n+            i: 0 //~ WARN use of deprecated field `lint_stability::DeprecatedUnstableStruct::i`\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated item 'lint_stability::DeprecatedUnitStruct'\n-        let _ = DeprecatedUnstableUnitStruct; //~ WARN use of deprecated item 'lint_stability::DeprecatedUnstableUnitStruct'\n+        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated struct `lint_stability::DeprecatedUnitStruct`\n+        let _ = DeprecatedUnstableUnitStruct; //~ WARN use of deprecated struct `lint_stability::DeprecatedUnstableUnitStruct`\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated item 'lint_stability::Enum::DeprecatedVariant'\n-        let _ = Enum::DeprecatedUnstableVariant; //~ WARN use of deprecated item 'lint_stability::Enum::DeprecatedUnstableVariant'\n+        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated variant `lint_stability::Enum::DeprecatedVariant`\n+        let _ = Enum::DeprecatedUnstableVariant; //~ WARN use of deprecated variant `lint_stability::Enum::DeprecatedUnstableVariant`\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated item 'lint_stability::DeprecatedTupleStruct'\n-        let _ = DeprecatedUnstableTupleStruct (1); //~ WARN use of deprecated item 'lint_stability::DeprecatedUnstableTupleStruct'\n+        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated struct `lint_stability::DeprecatedTupleStruct`\n+        let _ = DeprecatedUnstableTupleStruct (1); //~ WARN use of deprecated struct `lint_stability::DeprecatedUnstableTupleStruct`\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n \n@@ -136,28 +136,28 @@ mod cross_crate {\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test_arg!(deprecated_text()); //~ WARN use of deprecated item 'lint_stability::deprecated_text': text\n-        macro_test_arg!(deprecated_unstable_text()); //~ WARN use of deprecated item 'lint_stability::deprecated_unstable_text': text\n-        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ WARN use of deprecated item 'lint_stability::deprecated_text': text\n+        macro_test_arg!(deprecated_text()); //~ WARN use of deprecated function `lint_stability::deprecated_text`: text\n+        macro_test_arg!(deprecated_unstable_text()); //~ WARN use of deprecated function `lint_stability::deprecated_unstable_text`: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ WARN use of deprecated function `lint_stability::deprecated_text`: text\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n-        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+        foo.trait_deprecated(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -173,10 +173,10 @@ mod cross_crate {\n     }\n \n     fn test_method_object(foo: &dyn Trait) {\n-        foo.trait_deprecated(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n-        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable'\n-        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+        foo.trait_deprecated(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -185,9 +185,9 @@ mod cross_crate {\n     struct S;\n \n     impl UnstableTrait for S { }\n-    impl DeprecatedTrait for S {} //~ WARN use of deprecated item 'lint_stability::DeprecatedTrait': text\n+    impl DeprecatedTrait for S {} //~ WARN use of deprecated trait `lint_stability::DeprecatedTrait`: text\n     trait LocalTrait : UnstableTrait { }\n-    trait LocalTrait2 : DeprecatedTrait { } //~ WARN use of deprecated item 'lint_stability::DeprecatedTrait': text\n+    trait LocalTrait2 : DeprecatedTrait { } //~ WARN use of deprecated trait `lint_stability::DeprecatedTrait`: text\n \n     impl Trait for S {\n         fn trait_stable(&self) {}\n@@ -206,7 +206,7 @@ mod inheritance {\n         stable_mod::unstable();\n         stable_mod::stable();\n \n-        unstable_mod::deprecated(); //~ WARN use of deprecated item 'inheritance::inherited_stability::unstable_mod::deprecated': text\n+        unstable_mod::deprecated(); //~ WARN use of deprecated function `inheritance::inherited_stability::unstable_mod::deprecated`: text\n         unstable_mod::unstable();\n \n         let _ = Unstable::UnstableVariant;\n@@ -328,23 +328,23 @@ mod this_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ WARN use of deprecated item 'this_crate::deprecated'\n-        foo.method_deprecated(); //~ WARN use of deprecated item 'this_crate::MethodTester::method_deprecated'\n-        Foo::method_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::MethodTester::method_deprecated'\n-        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::MethodTester::method_deprecated'\n-        foo.trait_deprecated(); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-\n-        deprecated_text(); //~ WARN use of deprecated item 'this_crate::deprecated_text': text\n-        foo.method_deprecated_text(); //~ WARN use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n-        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n-        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n-        foo.trait_deprecated_text(); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+        deprecated(); //~ WARN use of deprecated function `this_crate::deprecated`\n+        foo.method_deprecated(); //~ WARN use of deprecated associated function `this_crate::MethodTester::method_deprecated`\n+        Foo::method_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::MethodTester::method_deprecated`\n+        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::MethodTester::method_deprecated`\n+        foo.trait_deprecated(); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+\n+        deprecated_text(); //~ WARN use of deprecated function `this_crate::deprecated_text`: text\n+        foo.method_deprecated_text(); //~ WARN use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n+        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n+        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n \n         unstable();\n         foo.method_unstable();\n@@ -383,34 +383,34 @@ mod this_crate {\n         <Foo as Trait>::trait_stable_text(&foo);\n \n         let _ = DeprecatedStruct {\n-            //~^ WARN use of deprecated item 'this_crate::DeprecatedStruct'\n-            i: 0 //~ WARN use of deprecated item 'this_crate::DeprecatedStruct::i'\n+            //~^ WARN use of deprecated struct `this_crate::DeprecatedStruct`\n+            i: 0 //~ WARN use of deprecated field `this_crate::DeprecatedStruct::i`\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated item 'this_crate::DeprecatedUnitStruct'\n+        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated unit struct `this_crate::DeprecatedUnitStruct`\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated item 'this_crate::Enum::DeprecatedVariant'\n+        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated unit variant `this_crate::Enum::DeprecatedVariant`\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated item 'this_crate::DeprecatedTupleStruct'\n+        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated tuple struct `this_crate::DeprecatedTupleStruct`\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+        foo.trait_deprecated(); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -426,8 +426,8 @@ mod this_crate {\n     }\n \n     fn test_method_object(foo: &dyn Trait) {\n-        foo.trait_deprecated(); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated'\n-        foo.trait_deprecated_text(); //~ WARN use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+        foo.trait_deprecated(); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated`\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -437,15 +437,15 @@ mod this_crate {\n     #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn test_fn_body() {\n         fn fn_in_body() {}\n-        fn_in_body(); //~ WARN use of deprecated item 'this_crate::test_fn_body::fn_in_body': text\n+        fn_in_body(); //~ WARN use of deprecated function `this_crate::test_fn_body::fn_in_body`: text\n     }\n \n     impl MethodTester {\n         #[unstable(feature = \"unstable_test_feature\", issue = \"none\")]\n         #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n         fn test_method_body(&self) {\n             fn fn_in_body() {}\n-            fn_in_body(); //~ WARN use of deprecated item 'this_crate::MethodTester::test_method_body::fn_in_body': text\n+            fn_in_body(); //~ WARN use of deprecated function `this_crate::MethodTester::test_method_body::fn_in_body`: text\n         }\n     }\n \n@@ -457,9 +457,9 @@ mod this_crate {\n \n     struct S;\n \n-    impl DeprecatedTrait for S { } //~ WARN use of deprecated item 'this_crate::DeprecatedTrait'\n+    impl DeprecatedTrait for S { } //~ WARN use of deprecated trait `this_crate::DeprecatedTrait`\n \n-    trait LocalTrait : DeprecatedTrait { } //~ WARN use of deprecated item 'this_crate::DeprecatedTrait'\n+    trait LocalTrait : DeprecatedTrait { } //~ WARN use of deprecated trait `this_crate::DeprecatedTrait`\n }\n \n fn main() {}"}, {"sha": "d8dd83b0d06bdd67200dd082e679afd70153daa2", "filename": "src/test/ui/lint/lint-stability-deprecated.stderr", "status": "modified", "additions": 160, "deletions": 160, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-warning: use of deprecated item 'lint_stability::deprecated': text\n+warning: use of deprecated function `lint_stability::deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:25:9\n    |\n LL |         deprecated();\n@@ -10,643 +10,643 @@ note: the lint level is defined here\n LL | #![warn(deprecated)]\n    |         ^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:30:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:32:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::deprecated_text': text\n+warning: use of deprecated function `lint_stability::deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:34:9\n    |\n LL |         deprecated_text();\n    |         ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:39:9\n    |\n-LL |         Trait::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Trait::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:41:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::deprecated_unstable': text\n+warning: use of deprecated function `lint_stability::deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:43:9\n    |\n LL |         deprecated_unstable();\n    |         ^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:48:9\n    |\n-LL |         Trait::trait_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Trait::trait_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:50:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::deprecated_unstable_text': text\n+warning: use of deprecated function `lint_stability::deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:52:9\n    |\n LL |         deprecated_unstable_text();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:57:9\n    |\n LL | ...   Trait::trait_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:59:9\n    |\n LL | ...   <Foo as Trait>::trait_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedStruct': text\n+warning: use of deprecated struct `lint_stability::DeprecatedStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:109:17\n    |\n LL |         let _ = DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedUnstableStruct': text\n+warning: use of deprecated struct `lint_stability::DeprecatedUnstableStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:112:17\n    |\n LL |         let _ = DeprecatedUnstableStruct {\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedUnitStruct': text\n+warning: use of deprecated struct `lint_stability::DeprecatedUnitStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:119:17\n    |\n LL |         let _ = DeprecatedUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedUnstableUnitStruct': text\n+warning: use of deprecated struct `lint_stability::DeprecatedUnstableUnitStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:120:17\n    |\n LL |         let _ = DeprecatedUnstableUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Enum::DeprecatedVariant': text\n+warning: use of deprecated variant `lint_stability::Enum::DeprecatedVariant`: text\n   --> $DIR/lint-stability-deprecated.rs:124:17\n    |\n LL |         let _ = Enum::DeprecatedVariant;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Enum::DeprecatedUnstableVariant': text\n+warning: use of deprecated variant `lint_stability::Enum::DeprecatedUnstableVariant`: text\n   --> $DIR/lint-stability-deprecated.rs:125:17\n    |\n LL |         let _ = Enum::DeprecatedUnstableVariant;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedTupleStruct': text\n+warning: use of deprecated struct `lint_stability::DeprecatedTupleStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:129:17\n    |\n LL |         let _ = DeprecatedTupleStruct (1);\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedUnstableTupleStruct': text\n+warning: use of deprecated struct `lint_stability::DeprecatedUnstableTupleStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:130:17\n    |\n LL |         let _ = DeprecatedUnstableTupleStruct (1);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::deprecated_text': text\n+warning: use of deprecated function `lint_stability::deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:139:25\n    |\n LL |         macro_test_arg!(deprecated_text());\n    |                         ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::deprecated_unstable_text': text\n+warning: use of deprecated function `lint_stability::deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:140:25\n    |\n LL |         macro_test_arg!(deprecated_unstable_text());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::deprecated_text': text\n+warning: use of deprecated function `lint_stability::deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:141:41\n    |\n LL |         macro_test_arg!(macro_test_arg!(deprecated_text()));\n    |                                         ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:146:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:148:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:150:9\n    |\n-LL |         Trait::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Trait::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:152:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:154:9\n    |\n-LL |         Trait::trait_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Trait::trait_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:156:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:158:9\n    |\n LL | ...   Trait::trait_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:160:9\n    |\n LL | ...   <Foo as Trait>::trait_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedTrait': text\n+warning: use of deprecated trait `lint_stability::DeprecatedTrait`: text\n   --> $DIR/lint-stability-deprecated.rs:188:10\n    |\n LL |     impl DeprecatedTrait for S {}\n    |          ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedTrait': text\n+warning: use of deprecated trait `lint_stability::DeprecatedTrait`: text\n   --> $DIR/lint-stability-deprecated.rs:190:25\n    |\n LL |     trait LocalTrait2 : DeprecatedTrait { }\n    |                         ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'inheritance::inherited_stability::unstable_mod::deprecated': text\n+warning: use of deprecated function `inheritance::inherited_stability::unstable_mod::deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:209:9\n    |\n LL |         unstable_mod::deprecated();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::deprecated': text\n+warning: use of deprecated function `this_crate::deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:331:9\n    |\n LL |         deprecated();\n    |         ^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:336:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:338:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::deprecated_text': text\n+warning: use of deprecated function `this_crate::deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:340:9\n    |\n LL |         deprecated_text();\n    |         ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:345:9\n    |\n LL |         Trait::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:347:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::DeprecatedStruct': text\n+warning: use of deprecated struct `this_crate::DeprecatedStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:385:17\n    |\n LL |         let _ = DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::DeprecatedUnitStruct': text\n+warning: use of deprecated unit struct `this_crate::DeprecatedUnitStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:392:17\n    |\n LL |         let _ = DeprecatedUnitStruct;\n    |                 ^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Enum::DeprecatedVariant': text\n+warning: use of deprecated unit variant `this_crate::Enum::DeprecatedVariant`: text\n   --> $DIR/lint-stability-deprecated.rs:396:17\n    |\n LL |         let _ = Enum::DeprecatedVariant;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::DeprecatedTupleStruct': text\n+warning: use of deprecated tuple struct `this_crate::DeprecatedTupleStruct`: text\n   --> $DIR/lint-stability-deprecated.rs:400:17\n    |\n LL |         let _ = DeprecatedTupleStruct (1);\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:407:9\n    |\n LL |         Trait::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:409:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:411:9\n    |\n LL |         Trait::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:413:9\n    |\n-LL |         <Foo as Trait>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo as Trait>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::test_fn_body::fn_in_body': text\n+warning: use of deprecated function `this_crate::test_fn_body::fn_in_body`: text\n   --> $DIR/lint-stability-deprecated.rs:440:9\n    |\n LL |         fn_in_body();\n    |         ^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::DeprecatedTrait': text\n+warning: use of deprecated trait `this_crate::DeprecatedTrait`: text\n   --> $DIR/lint-stability-deprecated.rs:460:10\n    |\n LL |     impl DeprecatedTrait for S { }\n    |          ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::DeprecatedTrait': text\n+warning: use of deprecated trait `this_crate::DeprecatedTrait`: text\n   --> $DIR/lint-stability-deprecated.rs:462:24\n    |\n LL |     trait LocalTrait : DeprecatedTrait { }\n    |                        ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::test_method_body::fn_in_body': text\n+warning: use of deprecated function `this_crate::MethodTester::test_method_body::fn_in_body`: text\n   --> $DIR/lint-stability-deprecated.rs:448:13\n    |\n LL |             fn_in_body();\n    |             ^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n+warning: use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:98:48\n    |\n LL |         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n    |                                                ^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n+warning: use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:103:13\n    |\n LL |             TypeDeprecated = u16,\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:26:13\n    |\n LL |         foo.method_deprecated();\n    |             ^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:27:9\n    |\n LL |         Foo::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:28:9\n    |\n LL |         <Foo>::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:29:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:31:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:35:13\n    |\n-LL |         foo.method_deprecated_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.method_deprecated_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:36:9\n    |\n-LL |         Foo::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Foo::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:37:9\n    |\n-LL |         <Foo>::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:38:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:40:9\n    |\n-LL |         <Foo>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:44:13\n    |\n-LL |         foo.method_deprecated_unstable();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.method_deprecated_unstable();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:45:9\n    |\n-LL |         Foo::method_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Foo::method_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:46:9\n    |\n-LL |         <Foo>::method_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::method_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:47:13\n    |\n LL |         foo.trait_deprecated_unstable();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:49:9\n    |\n-LL |         <Foo>::trait_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::trait_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:53:13\n    |\n LL | ...   foo.method_deprecated_unstable_text();\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:54:9\n    |\n LL | ...   Foo::method_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::MethodTester::method_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::MethodTester::method_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:55:9\n    |\n LL | ...   <Foo>::method_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:56:13\n    |\n-LL |         foo.trait_deprecated_unstable_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.trait_deprecated_unstable_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:58:9\n    |\n LL | ...   <Foo>::trait_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedStruct::i': text\n+warning: use of deprecated field `lint_stability::DeprecatedStruct::i`: text\n   --> $DIR/lint-stability-deprecated.rs:110:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-warning: use of deprecated item 'lint_stability::DeprecatedUnstableStruct::i': text\n+warning: use of deprecated field `lint_stability::DeprecatedUnstableStruct::i`: text\n   --> $DIR/lint-stability-deprecated.rs:114:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:145:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:147:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:149:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:151:9\n    |\n-LL |         <Foo>::trait_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::trait_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:153:13\n    |\n LL |         foo.trait_deprecated_unstable();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:155:9\n    |\n-LL |         <Foo>::trait_deprecated_unstable(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::trait_deprecated_unstable(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:157:13\n    |\n-LL |         foo.trait_deprecated_unstable_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.trait_deprecated_unstable_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:159:9\n    |\n LL | ...   <Foo>::trait_deprecated_unstable_text(&foo);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:176:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:177:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable`: text\n   --> $DIR/lint-stability-deprecated.rs:178:13\n    |\n LL |         foo.trait_deprecated_unstable();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::Trait::trait_deprecated_unstable_text': text\n+warning: use of deprecated associated function `lint_stability::Trait::trait_deprecated_unstable_text`: text\n   --> $DIR/lint-stability-deprecated.rs:179:13\n    |\n-LL |         foo.trait_deprecated_unstable_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.trait_deprecated_unstable_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::method_deprecated': text\n+warning: use of deprecated associated function `this_crate::MethodTester::method_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:332:13\n    |\n LL |         foo.method_deprecated();\n    |             ^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::method_deprecated': text\n+warning: use of deprecated associated function `this_crate::MethodTester::method_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:333:9\n    |\n LL |         Foo::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::method_deprecated': text\n+warning: use of deprecated associated function `this_crate::MethodTester::method_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:334:9\n    |\n LL |         <Foo>::method_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:335:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:337:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:341:13\n    |\n-LL |         foo.method_deprecated_text();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   foo.method_deprecated_text();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:342:9\n    |\n-LL |         Foo::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   Foo::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::MethodTester::method_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::MethodTester::method_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:343:9\n    |\n-LL |         <Foo>::method_deprecated_text(&foo);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | ...   <Foo>::method_deprecated_text(&foo);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:344:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:346:9\n    |\n LL |         <Foo>::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::DeprecatedStruct::i': text\n+warning: use of deprecated field `this_crate::DeprecatedStruct::i`: text\n   --> $DIR/lint-stability-deprecated.rs:387:13\n    |\n LL |             i: 0\n    |             ^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:406:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:408:9\n    |\n LL |         <Foo>::trait_deprecated(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:410:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:412:9\n    |\n LL |         <Foo>::trait_deprecated_text(&foo);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:429:13\n    |\n LL |         foo.trait_deprecated();\n    |             ^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n+warning: use of deprecated associated function `this_crate::Trait::trait_deprecated_text`: text\n   --> $DIR/lint-stability-deprecated.rs:430:13\n    |\n LL |         foo.trait_deprecated_text();\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n+warning: use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:98:48\n    |\n LL |         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n    |                                                ^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n+warning: use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:103:13\n    |\n LL |             TypeDeprecated = u16,\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-warning: use of deprecated item 'lint_stability::TraitWithAssociatedTypes::TypeDeprecated': text\n+warning: use of deprecated associated type `lint_stability::TraitWithAssociatedTypes::TypeDeprecated`: text\n   --> $DIR/lint-stability-deprecated.rs:103:13\n    |\n LL |             TypeDeprecated = u16,"}, {"sha": "14c6383806fb803192f266443ca851de407accac", "filename": "src/test/ui/lint/lint-stability-fields-deprecated.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-fields-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-fields-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability-fields-deprecated.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -16,19 +16,19 @@ mod cross_crate {\n             inherit: 1,\n             override1: 2,\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1;\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Stable {\n             inherit: _,\n             override1: _,\n             override2: _\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         } = x;\n         // all fine\n         let Stable { .. } = x;\n@@ -38,12 +38,12 @@ mod cross_crate {\n         let _ = x.0;\n         let _ = x.1;\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Stable2(_,\n                    _,\n                    _)\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             = x;\n         // all fine\n         let Stable2(..) = x;\n@@ -53,19 +53,19 @@ mod cross_crate {\n             inherit: 1,\n             override1: 2,\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1;\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Unstable {\n             inherit: _,\n             override1: _,\n             override2: _\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         } = x;\n \n         let Unstable\n@@ -78,72 +78,72 @@ mod cross_crate {\n         let _ = x.0;\n         let _ = x.1;\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Unstable2\n             (_,\n              _,\n              _)\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             = x;\n         let Unstable2\n             // the patterns are all fine:\n             (..) = x;\n \n \n         let x = Deprecated {\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated struct\n             inherit: 1,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override1: 2,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         };\n \n         let _ = x.inherit;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.override1;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Deprecated {\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated struct\n             inherit: _,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override1: _,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override2: _\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         } = x;\n \n         let Deprecated\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated struct\n             // the patterns are all fine:\n             { .. } = x;\n \n         let x = Deprecated2(1, 2, 3);\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated struct\n \n         let _ = x.0;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.1;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Deprecated2\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated struct\n             (_,\n-             //~^ ERROR use of deprecated item\n+             //~^ ERROR use of deprecated field\n              _,\n-             //~^ ERROR use of deprecated item\n+             //~^ ERROR use of deprecated field\n              _)\n-             //~^ ERROR use of deprecated item\n+             //~^ ERROR use of deprecated field\n             = x;\n         let Deprecated2\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated struct\n             // the patterns are all fine:\n             (..) = x;\n     }\n@@ -203,19 +203,19 @@ mod this_crate {\n             inherit: 1,\n             override1: 2,\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1;\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Stable {\n             inherit: _,\n             override1: _,\n             override2: _\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         } = x;\n         // all fine\n         let Stable { .. } = x;\n@@ -225,12 +225,12 @@ mod this_crate {\n         let _ = x.0;\n         let _ = x.1;\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Stable2(_,\n                    _,\n                    _)\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             = x;\n         // all fine\n         let Stable2(..) = x;\n@@ -240,19 +240,19 @@ mod this_crate {\n             inherit: 1,\n             override1: 2,\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1;\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Unstable {\n             inherit: _,\n             override1: _,\n             override2: _\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         } = x;\n \n         let Unstable\n@@ -265,72 +265,72 @@ mod this_crate {\n         let _ = x.0;\n         let _ = x.1;\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Unstable2\n             (_,\n              _,\n              _)\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             = x;\n         let Unstable2\n             // the patterns are all fine:\n             (..) = x;\n \n \n         let x = Deprecated {\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated struct\n             inherit: 1,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override1: 2,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         };\n \n         let _ = x.inherit;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.override1;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Deprecated {\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated struct\n             inherit: _,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override1: _,\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             override2: _\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n         } = x;\n \n         let Deprecated\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated struct\n             // the patterns are all fine:\n             { .. } = x;\n \n         let x = Deprecated2(1, 2, 3);\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated tuple struct\n \n         let _ = x.0;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.1;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated field\n \n         let Deprecated2\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated tuple struct\n             (_,\n-             //~^ ERROR use of deprecated item\n+             //~^ ERROR use of deprecated field\n              _,\n-             //~^ ERROR use of deprecated item\n+             //~^ ERROR use of deprecated field\n              _)\n-            //~^ ERROR use of deprecated item\n+            //~^ ERROR use of deprecated field\n             = x;\n         let Deprecated2\n-        //~^ ERROR use of deprecated item\n+        //~^ ERROR use of deprecated tuple struct\n             // the patterns are all fine:\n             (..) = x;\n     }"}, {"sha": "ec786786023b9fad6a2737e82910cfb1bccfe82e", "filename": "src/test/ui/lint/lint-stability-fields-deprecated.stderr", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-fields-deprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability-fields-deprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability-fields-deprecated.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated': text\n+error: use of deprecated struct `cross_crate::lint_stability_fields::Deprecated`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:94:17\n    |\n LL |         let x = Deprecated {\n@@ -10,367 +10,367 @@ note: the lint level is defined here\n LL | #![deny(deprecated)]\n    |         ^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated': text\n+error: use of deprecated struct `cross_crate::lint_stability_fields::Deprecated`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:111:13\n    |\n LL |         let Deprecated {\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated': text\n+error: use of deprecated struct `cross_crate::lint_stability_fields::Deprecated`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:121:13\n    |\n LL |         let Deprecated\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2': text\n+error: use of deprecated struct `cross_crate::lint_stability_fields::Deprecated2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:126:17\n    |\n LL |         let x = Deprecated2(1, 2, 3);\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2': text\n+error: use of deprecated struct `cross_crate::lint_stability_fields::Deprecated2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:136:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2': text\n+error: use of deprecated struct `cross_crate::lint_stability_fields::Deprecated2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:145:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated': text\n+error: use of deprecated struct `this_crate::Deprecated`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:281:17\n    |\n LL |         let x = Deprecated {\n    |                 ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated': text\n+error: use of deprecated struct `this_crate::Deprecated`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:298:13\n    |\n LL |         let Deprecated {\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated': text\n+error: use of deprecated struct `this_crate::Deprecated`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:308:13\n    |\n LL |         let Deprecated\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2': text\n+error: use of deprecated tuple struct `this_crate::Deprecated2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:313:17\n    |\n LL |         let x = Deprecated2(1, 2, 3);\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2': text\n+error: use of deprecated tuple struct `this_crate::Deprecated2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:323:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2': text\n+error: use of deprecated tuple struct `this_crate::Deprecated2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:332:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Stable::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Stable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:18:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Stable::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Stable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:24:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Stable::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Stable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:30:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Stable2::2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Stable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:40:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Stable2::2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Stable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:45:20\n    |\n LL |                    _)\n    |                    ^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Unstable::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Unstable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:55:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Unstable::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Unstable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:61:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Unstable::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Unstable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:67:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Unstable2::2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Unstable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:80:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Unstable2::2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Unstable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:86:14\n    |\n LL |              _)\n    |              ^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::inherit': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::inherit`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:96:13\n    |\n LL |             inherit: 1,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::override1': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::override1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:98:13\n    |\n LL |             override1: 2,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:100:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::inherit': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::inherit`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:104:17\n    |\n LL |         let _ = x.inherit;\n    |                 ^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::override1': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::override1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:106:17\n    |\n LL |         let _ = x.override1;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:108:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::inherit': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::inherit`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:113:13\n    |\n LL |             inherit: _,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::override1': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::override1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:115:13\n    |\n LL |             override1: _,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated::override2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:117:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2::0': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated2::0`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:129:17\n    |\n LL |         let _ = x.0;\n    |                 ^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2::1': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated2::1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:131:17\n    |\n LL |         let _ = x.1;\n    |                 ^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2::2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:133:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2::0': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated2::0`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:138:14\n    |\n LL |             (_,\n    |              ^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2::1': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated2::1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:140:14\n    |\n LL |              _,\n    |              ^\n \n-error: use of deprecated item 'cross_crate::lint_stability_fields::Deprecated2::2': text\n+error: use of deprecated field `cross_crate::lint_stability_fields::Deprecated2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:142:14\n    |\n LL |              _)\n    |              ^\n \n-error: use of deprecated item 'this_crate::Stable::override2': text\n+error: use of deprecated field `this_crate::Stable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:205:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Stable::override2': text\n+error: use of deprecated field `this_crate::Stable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:211:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Stable::override2': text\n+error: use of deprecated field `this_crate::Stable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:217:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Stable2::2': text\n+error: use of deprecated field `this_crate::Stable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:227:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate::Stable2::2': text\n+error: use of deprecated field `this_crate::Stable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:232:20\n    |\n LL |                    _)\n    |                    ^\n \n-error: use of deprecated item 'this_crate::Unstable::override2': text\n+error: use of deprecated field `this_crate::Unstable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:242:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Unstable::override2': text\n+error: use of deprecated field `this_crate::Unstable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:248:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Unstable::override2': text\n+error: use of deprecated field `this_crate::Unstable::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:254:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Unstable2::2': text\n+error: use of deprecated field `this_crate::Unstable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:267:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate::Unstable2::2': text\n+error: use of deprecated field `this_crate::Unstable2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:273:14\n    |\n LL |              _)\n    |              ^\n \n-error: use of deprecated item 'this_crate::Deprecated::inherit': text\n+error: use of deprecated field `this_crate::Deprecated::inherit`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:283:13\n    |\n LL |             inherit: 1,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::override1': text\n+error: use of deprecated field `this_crate::Deprecated::override1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:285:13\n    |\n LL |             override1: 2,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::override2': text\n+error: use of deprecated field `this_crate::Deprecated::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:287:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::inherit': text\n+error: use of deprecated field `this_crate::Deprecated::inherit`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:291:17\n    |\n LL |         let _ = x.inherit;\n    |                 ^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::override1': text\n+error: use of deprecated field `this_crate::Deprecated::override1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:293:17\n    |\n LL |         let _ = x.override1;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::override2': text\n+error: use of deprecated field `this_crate::Deprecated::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:295:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::inherit': text\n+error: use of deprecated field `this_crate::Deprecated::inherit`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:300:13\n    |\n LL |             inherit: _,\n    |             ^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::override1': text\n+error: use of deprecated field `this_crate::Deprecated::override1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:302:13\n    |\n LL |             override1: _,\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated::override2': text\n+error: use of deprecated field `this_crate::Deprecated::override2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:304:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2::0': text\n+error: use of deprecated field `this_crate::Deprecated2::0`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:316:17\n    |\n LL |         let _ = x.0;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2::1': text\n+error: use of deprecated field `this_crate::Deprecated2::1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:318:17\n    |\n LL |         let _ = x.1;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2::2': text\n+error: use of deprecated field `this_crate::Deprecated2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:320:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n-error: use of deprecated item 'this_crate::Deprecated2::0': text\n+error: use of deprecated field `this_crate::Deprecated2::0`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:325:14\n    |\n LL |             (_,\n    |              ^\n \n-error: use of deprecated item 'this_crate::Deprecated2::1': text\n+error: use of deprecated field `this_crate::Deprecated2::1`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:327:14\n    |\n LL |              _,\n    |              ^\n \n-error: use of deprecated item 'this_crate::Deprecated2::2': text\n+error: use of deprecated field `this_crate::Deprecated2::2`: text\n   --> $DIR/lint-stability-fields-deprecated.rs:329:14\n    |\n LL |              _)"}, {"sha": "9ae23dac61beffaa2146dfec738669b206653a2e", "filename": "src/test/ui/lint/lint-stability2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability2.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n // aux-build:lint_stability.rs\n-// error-pattern: use of deprecated item\n+// error-pattern: use of deprecated function\n \n #![deny(deprecated)]\n "}, {"sha": "036304d25f9bf9adf71a5ea821429ed3ecd5d51a", "filename": "src/test/ui/lint/lint-stability2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability2.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'lint_stability::deprecated': text\n+error: use of deprecated function `lint_stability::deprecated`: text\n   --> $DIR/lint-stability2.rs:12:5\n    |\n LL |     macro_test!();"}, {"sha": "4452846ec0a961e5f9a13853ff1c041bd565eedc", "filename": "src/test/ui/lint/lint-stability3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability3.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n // aux-build:lint_stability.rs\n-// error-pattern: use of deprecated item\n+// error-pattern: use of deprecated function\n \n #![deny(deprecated)]\n #![allow(warnings)]"}, {"sha": "b89a7df493877640a190577ce8d5df500540d785", "filename": "src/test/ui/lint/lint-stability3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Flint-stability3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability3.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-error: use of deprecated item 'lint_stability::deprecated_text': text\n+error: use of deprecated function `lint_stability::deprecated_text`: text\n   --> $DIR/lint-stability3.rs:13:5\n    |\n LL |     macro_test_arg_nested!(deprecated_text);"}, {"sha": "ac547293c583a4bc67d6865deb6f9e5c6fbc6e4e", "filename": "src/test/ui/lint/unused-braces-while-let-with-mutable-value.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Funused-braces-while-let-with-mutable-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Flint%2Funused-braces-while-let-with-mutable-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused-braces-while-let-with-mutable-value.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![deny(unused_braces)]\n+\n+fn main() {\n+    let mut a = Some(3);\n+    // Shouldn't warn below `a`.\n+    while let Some(ref mut v) = {a} {\n+        a.as_mut().map(|a| std::mem::swap(a, v));\n+        break;\n+    }\n+}"}, {"sha": "4d8a8edf4c9eae503c8d9bca3dcfe16c9a4a60dd", "filename": "src/test/ui/macro_backtrace/main.-Zmacro-backtrace.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacro_backtrace%2Fmain.-Zmacro-backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacro_backtrace%2Fmain.-Zmacro-backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro_backtrace%2Fmain.-Zmacro-backtrace.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -17,20 +17,20 @@ LL | /  macro_rules! pong {\n LL | |      () => { syntax error };\n    | |                     ^^^^^ expected one of 8 possible tokens\n LL | |  }\n-   | |__- in this expansion of `pong!`\n+   | |__- in this expansion of `pong!` (#2)\n ...\n LL |        ping!();\n-   |        -------- in this macro invocation\n+   |        -------- in this macro invocation (#1)\n    | \n   ::: $DIR/auxiliary/ping.rs:5:1\n    |\n LL |  / macro_rules! ping {\n LL |  |     () => {\n LL |  |         pong!();\n-   |  |         -------- in this macro invocation\n+   |  |         -------- in this macro invocation (#2)\n LL |  |     }\n LL |  | }\n-   |  |_- in this expansion of `ping!`\n+   |  |_- in this expansion of `ping!` (#1)\n \n error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `error`\n   --> $DIR/main.rs:10:20"}, {"sha": "a7f327cf53b1e1f811a350f419f485a0a6178d50", "filename": "src/test/ui/macros/macro-deprecation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -8,6 +8,6 @@\n macro_rules! local_deprecated{ () => () }\n \n fn main() {\n-    local_deprecated!(); //~ WARN use of deprecated item 'local_deprecated': local deprecation note\n-    deprecated_macro!(); //~ WARN use of deprecated item 'deprecated_macro': deprecation note\n+    local_deprecated!(); //~ WARN use of deprecated macro `local_deprecated`: local deprecation note\n+    deprecated_macro!(); //~ WARN use of deprecated macro `deprecated_macro`: deprecation note\n }"}, {"sha": "07849d7ce5778353f306065830a891fd74d7c170", "filename": "src/test/ui/macros/macro-deprecation.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,12 +1,12 @@\n-warning: use of deprecated item 'local_deprecated': local deprecation note\n+warning: use of deprecated macro `local_deprecated`: local deprecation note\n   --> $DIR/macro-deprecation.rs:11:5\n    |\n LL |     local_deprecated!();\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n-warning: use of deprecated item 'deprecated_macro': deprecation note\n+warning: use of deprecated macro `deprecated_macro`: deprecation note\n   --> $DIR/macro-deprecation.rs:12:5\n    |\n LL |     deprecated_macro!();"}, {"sha": "e2eff7c1c2d6c83f6081bb1d4dac3b1195677a68", "filename": "src/test/ui/macros/macro-stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     // unstable_macro_modern!(); // ERROR use of unstable library feature 'unstable_macros'\n \n     deprecated_macro!();\n-    //~^ WARN use of deprecated item 'deprecated_macro': deprecation reason\n+    //~^ WARN use of deprecated macro `deprecated_macro`: deprecation reason\n     local_deprecated!();\n-    //~^ WARN use of deprecated item 'local_deprecated': local deprecation reason\n+    //~^ WARN use of deprecated macro `local_deprecated`: local deprecation reason\n }"}, {"sha": "34b62b4b1c3fdf051a0571568960f9b8ed38de51", "filename": "src/test/ui/macros/macro-stability.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -22,15 +22,15 @@ LL |     unstable_macro!();\n    |\n    = help: add `#![feature(unstable_macros)]` to the crate attributes to enable\n \n-warning: use of deprecated item 'deprecated_macro': deprecation reason\n+warning: use of deprecated macro `deprecated_macro`: deprecation reason\n   --> $DIR/macro-stability.rs:24:5\n    |\n LL |     deprecated_macro!();\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n-warning: use of deprecated item 'local_deprecated': local deprecation reason\n+warning: use of deprecated macro `local_deprecated`: local deprecation reason\n   --> $DIR/macro-stability.rs:26:5\n    |\n LL |     local_deprecated!();"}, {"sha": "0b25f87ec5340d6792fd7d4784ce8ceaf47f1b0a", "filename": "src/test/ui/pattern/issue-74539.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,15 @@\n+enum E {\n+    A(u8, u8),\n+}\n+\n+fn main() {\n+    let e = E::A(2, 3);\n+    match e {\n+        E::A(x @ ..) => {\n+            //~^ ERROR: `x @` is not allowed in a tuple struct\n+            //~| ERROR: `..` patterns are not allowed here\n+            //~| ERROR: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+            x\n+        }\n+    };\n+}"}, {"sha": "cbc90b5397d8b058f3fdc4abcf9a25fcd663f84f", "filename": "src/test/ui/pattern/issue-74539.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-74539.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,32 @@\n+error: `x @` is not allowed in a tuple struct\n+  --> $DIR/issue-74539.rs:8:14\n+   |\n+LL |         E::A(x @ ..) => {\n+   |              ^^^^^^ this is only allowed in slice patterns\n+   |\n+   = help: remove this and bind each tuple field independently\n+help: if you don't need to use the contents of x, discard the tuple's remaining fields\n+   |\n+LL |         E::A(..) => {\n+   |              ^^\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/issue-74539.rs:8:18\n+   |\n+LL |         E::A(x @ ..) => {\n+   |                  ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+  --> $DIR/issue-74539.rs:8:9\n+   |\n+LL |     A(u8, u8),\n+   |     --------- tuple variant defined here\n+...\n+LL |         E::A(x @ ..) => {\n+   |         ^^^^^^^^^^^^ expected 2 fields, found 1\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0023`."}, {"sha": "0aeb3b217a26ff8771c9fb67a4943eaf9a1b4ea1", "filename": "src/test/ui/pattern/issue-74702.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-74702.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let (foo @ ..,) = (0, 0);\n+    //~^ ERROR: `foo @` is not allowed in a tuple\n+    //~| ERROR: `..` patterns are not allowed here\n+    //~| ERROR: mismatched types\n+    dbg!(foo);\n+}"}, {"sha": "aca5c9aed96247a0d14c49100b608da6a1428b52", "filename": "src/test/ui/pattern/issue-74702.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74702.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74702.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-74702.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,34 @@\n+error: `foo @` is not allowed in a tuple\n+  --> $DIR/issue-74702.rs:2:10\n+   |\n+LL |     let (foo @ ..,) = (0, 0);\n+   |          ^^^^^^^^ this is only allowed in slice patterns\n+   |\n+   = help: remove this and bind each tuple field independently\n+help: if you don't need to use the contents of foo, discard the tuple's remaining fields\n+   |\n+LL |     let (..,) = (0, 0);\n+   |          ^^\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/issue-74702.rs:2:16\n+   |\n+LL |     let (foo @ ..,) = (0, 0);\n+   |                ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-74702.rs:2:9\n+   |\n+LL |     let (foo @ ..,) = (0, 0);\n+   |         ^^^^^^^^^^^   ------ this expression has type `({integer}, {integer})`\n+   |         |\n+   |         expected a tuple with 2 elements, found one with 1 element\n+   |\n+   = note: expected tuple `({integer}, {integer})`\n+              found tuple `(_,)`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "269ec3c7abe93c48e20c2d6ad33388749b1d355a", "filename": "src/test/ui/pattern/issue-74954.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fpattern%2Fissue-74954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-74954.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+fn main() {\n+    if let Some([b'@', filename @ ..]) = Some(b\"@abc123\") {\n+        println!(\"filename {:?}\", filename);\n+    }\n+}"}, {"sha": "c0733c8b416beef1d76911331f017d46a4a6e56f", "filename": "src/test/ui/proc-macro/attributes-on-definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -6,7 +6,7 @@\n extern crate attributes_on_definitions;\n \n attributes_on_definitions::with_attrs!();\n-//~^ WARN use of deprecated item\n+//~^ WARN use of deprecated\n // No errors about the use of unstable and unsafe code inside the macro.\n \n fn main() {}"}, {"sha": "c63dd00119aca52d97e42adbf8f69b6c61c9997c", "filename": "src/test/ui/proc-macro/attributes-on-definitions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattributes-on-definitions.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-warning: use of deprecated item 'attributes_on_definitions::with_attrs': test\n+warning: use of deprecated macro `attributes_on_definitions::with_attrs`: test\n   --> $DIR/attributes-on-definitions.rs:8:1\n    |\n LL | attributes_on_definitions::with_attrs!();"}, {"sha": "9daee21aa17d458aea9794d9eac5a09d57baadb0", "filename": "src/test/ui/proc-macro/auxiliary/raw-ident.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fraw-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fraw-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fraw-ident.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,35 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::{TokenStream, TokenTree, Ident, Punct, Spacing, Span};\n+\n+#[proc_macro]\n+pub fn make_struct(input: TokenStream) -> TokenStream {\n+    match input.into_iter().next().unwrap() {\n+        TokenTree::Ident(ident) => {\n+            vec![\n+                TokenTree::Ident(Ident::new(\"struct\", Span::call_site())),\n+                TokenTree::Ident(Ident::new_raw(&ident.to_string(), Span::call_site())),\n+                TokenTree::Punct(Punct::new(';', Spacing::Alone))\n+            ].into_iter().collect()\n+        }\n+        _ => panic!()\n+    }\n+}\n+\n+#[proc_macro]\n+pub fn make_bad_struct(input: TokenStream) -> TokenStream {\n+    match input.into_iter().next().unwrap() {\n+        TokenTree::Ident(ident) => {\n+            vec![\n+                TokenTree::Ident(Ident::new_raw(\"struct\", Span::call_site())),\n+                TokenTree::Ident(Ident::new(&ident.to_string(), Span::call_site())),\n+                TokenTree::Punct(Punct::new(';', Spacing::Alone))\n+            ].into_iter().collect()\n+        }\n+        _ => panic!()\n+    }\n+}"}, {"sha": "4f11f81b00bfab4b294036b46f8a720824a7907a", "filename": "src/test/ui/proc-macro/crt-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fcrt-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fcrt-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcrt-static.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,4 @@\n-// Test proc-macro crate can be built without addtional RUSTFLAGS\n+// Test proc-macro crate can be built without additional RUSTFLAGS\n // on musl target\n // override -Ctarget-feature=-crt-static from compiletest\n // compile-flags: -Ctarget-feature="}, {"sha": "03cb4571496e90318056b03a11b63c7e9f0b127d", "filename": "src/test/ui/proc-macro/raw-ident.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fraw-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fraw-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fraw-ident.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:raw-ident.rs\n+\n+#[macro_use] extern crate raw_ident;\n+\n+fn main() {\n+    make_struct!(fn);\n+    make_struct!(Foo);\n+    make_struct!(await);\n+\n+    r#fn;\n+    r#Foo;\n+    Foo;\n+    r#await;\n+\n+    make_bad_struct!(S); //~ ERROR expected one of\n+}"}, {"sha": "e82a1226b5aef4be18bb0e1162297bc102641418", "filename": "src/test/ui/proc-macro/raw-ident.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fraw-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fproc-macro%2Fraw-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fraw-ident.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,10 @@\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `S`\n+  --> $DIR/raw-ident.rs:15:5\n+   |\n+LL |     make_bad_struct!(S);\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "bdcd47a7260d30f22664b0ba720117a9bea2110b", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -5,8 +5,9 @@\n // well enough to reproduce (and illustrate) the bug from #16687.\n \n #![feature(allocator_api)]\n+#![feature(slice_ptr_get)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout, ReallocPlacement};\n+use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use std::ptr::{self, NonNull};\n \n fn main() {\n@@ -41,15 +42,13 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let memory = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n-            println!(\"allocate({:?}) = {:?}\", layout, memory.ptr);\n+            println!(\"allocate({:?}) = {:?}\", layout, ptr);\n         }\n \n-        memory.ptr.cast().as_ptr()\n+        ptr.as_non_null_ptr().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n@@ -70,21 +69,19 @@ unsafe fn test_triangle() -> bool {\n                 NonNull::new_unchecked(ptr),\n                 old,\n                 new.size(),\n-                ReallocPlacement::MayMove,\n-                AllocInit::Uninitialized,\n             )\n         } else {\n-            Global.shrink(NonNull::new_unchecked(ptr), old, new.size(), ReallocPlacement::MayMove)\n+            Global.shrink(NonNull::new_unchecked(ptr), old, new.size())\n         };\n \n-        let memory = memory.unwrap_or_else(|_| {\n+        let ptr = memory.unwrap_or_else(|_| {\n             handle_alloc_error(Layout::from_size_align_unchecked(new.size(), old.align()))\n         });\n \n         if PRINT {\n-            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, memory.ptr);\n+            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, ptr);\n         }\n-        memory.ptr.cast().as_ptr()\n+        ptr.as_non_null_ptr().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize {"}, {"sha": "ad4b9c352aefd278e8f3ec97664261b8b9f3a26c", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use std::ptr::NonNull;\n \n struct arena(());\n@@ -25,10 +25,8 @@ struct Ccx {\n fn alloc(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let memory = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n-        &*(memory.ptr.as_ptr() as *const _)\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        &*(ptr.as_ptr() as *const _)\n     }\n }\n "}, {"sha": "b2ea31bb5178b48493c49aaa089644bfb2fd95d0", "filename": "src/test/ui/rfc-2091-track-caller/error-with-main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,4 @@\n+#[track_caller] //~ ERROR `main` function is not allowed to be\n+fn main() {\n+    panic!(\"{}: oh no\", std::panic::Location::caller());\n+}"}, {"sha": "f05f88e7d71eace9825dc8ea4ebafad59431d44d", "filename": "src/test/ui/rfc-2091-track-caller/error-with-main.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,12 @@\n+error: `main` function is not allowed to be `#[track_caller]`\n+  --> $DIR/error-with-main.rs:1:1\n+   |\n+LL |   #[track_caller]\n+   |   ^^^^^^^^^^^^^^^\n+LL | / fn main() {\n+LL | |     panic!(\"{}: oh no\", std::panic::Location::caller());\n+LL | | }\n+   | |_- `main` function is not allowed to be `#[track_caller]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "0cab47170631bab4b66d0058d2721fb95214b137", "filename": "src/test/ui/rfc-2091-track-caller/error-with-start.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-start.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,7 @@\n+#![feature(start)]\n+\n+#[start]\n+#[track_caller] //~ ERROR `start` is not allowed to be `#[track_caller]`\n+fn start(_argc: isize, _argv: *const *const u8) -> isize {\n+    panic!(\"{}: oh no\", std::panic::Location::caller());\n+}"}, {"sha": "1a1f3e0449136d118ab25bc1a3832c5a8104d902", "filename": "src/test/ui/rfc-2091-track-caller/error-with-start.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-start.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,12 @@\n+error: `start` is not allowed to be `#[track_caller]`\n+  --> $DIR/error-with-start.rs:4:1\n+   |\n+LL |   #[track_caller]\n+   |   ^^^^^^^^^^^^^^^\n+LL | / fn start(_argc: isize, _argv: *const *const u8) -> isize {\n+LL | |     panic!(\"{}: oh no\", std::panic::Location::caller());\n+LL | | }\n+   | |_- `start` is not allowed to be `#[track_caller]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "d6a3a760b3ee273c5372d45b6b4f71b088d40814", "filename": "src/test/ui/rfc-2091-track-caller/std-panic-locations.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -7,8 +7,10 @@\n //! Test that panic locations for `#[track_caller]` functions in std have the correct\n //! location reported.\n \n+use std::cell::RefCell;\n use std::collections::{BTreeMap, HashMap, VecDeque};\n use std::ops::{Index, IndexMut};\n+use std::panic::{AssertUnwindSafe, UnwindSafe};\n \n fn main() {\n     // inspect the `PanicInfo` we receive to ensure the right file is the source\n@@ -20,7 +22,7 @@ fn main() {\n         }\n     }));\n \n-    fn assert_panicked(f: impl FnOnce() + std::panic::UnwindSafe) {\n+    fn assert_panicked(f: impl FnOnce() + UnwindSafe) {\n         std::panic::catch_unwind(f).unwrap_err();\n     }\n \n@@ -57,4 +59,9 @@ fn main() {\n     let weirdo: VecDeque<()> = Default::default();\n     assert_panicked(|| { weirdo.index(1); });\n     assert_panicked(|| { weirdo[1]; });\n+\n+    let refcell: RefCell<()> = Default::default();\n+    let _conflicting = refcell.borrow_mut();\n+    assert_panicked(AssertUnwindSafe(|| { refcell.borrow(); }));\n+    assert_panicked(AssertUnwindSafe(|| { refcell.borrow_mut(); }));\n }"}, {"sha": "6e9d74344bc832d82713f2e32aaa7ec1bbf17321", "filename": "src/test/ui/suggestions/issue-61226.fixed", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+struct X {}\n+fn main() {\n+    let _ = vec![X {}]; //\u2026\n+    //~^ ERROR expected value, found struct `X`\n+}"}, {"sha": "695fe73418a4660bab605d597137130d9279843e", "filename": "src/test/ui/suggestions/issue-61226.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,6 @@\n+// run-rustfix\n struct X {}\n fn main() {\n-    vec![X]; //\u2026\n+    let _ = vec![X]; //\u2026\n     //~^ ERROR expected value, found struct `X`\n }"}, {"sha": "cda962a904530277108a4cae7f45bbe0d1cad383", "filename": "src/test/ui/suggestions/issue-61226.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61226.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,11 +1,11 @@\n error[E0423]: expected value, found struct `X`\n-  --> $DIR/issue-61226.rs:3:10\n+  --> $DIR/issue-61226.rs:4:18\n    |\n LL | struct X {}\n    | ----------- `X` defined here\n LL | fn main() {\n-LL |     vec![X]; //\u2026\n-   |          ^ help: use struct literal syntax instead: `X {}`\n+LL |     let _ = vec![X]; //\u2026\n+   |                  ^ help: use struct literal syntax instead: `X {}`\n \n error: aborting due to previous error\n "}, {"sha": "56b740b0d5ca0ff27d323d3ff0d6473ef87746cf", "filename": "src/test/ui/suggestions/type-ascription-instead-of-method.fixed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let _ = Box::new(\"foo\".to_string());\n+    //~^ ERROR expected type, found\n+}"}, {"sha": "a603e09e7e8390b8322079d9628d85b1f83b6bf4", "filename": "src/test/ui/suggestions/type-ascription-instead-of-method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,4 +1,5 @@\n+// run-rustfix\n fn main() {\n-    Box:new(\"foo\".to_string())\n+    let _ = Box:new(\"foo\".to_string());\n     //~^ ERROR expected type, found\n }"}, {"sha": "83bc33f410ad0800d69b61c25ecd3729b36a84e1", "filename": "src/test/ui/suggestions/type-ascription-instead-of-method.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,10 +1,10 @@\n error: expected type, found `\"foo\"`\n-  --> $DIR/type-ascription-instead-of-method.rs:2:13\n+  --> $DIR/type-ascription-instead-of-method.rs:3:21\n    |\n-LL |     Box:new(\"foo\".to_string())\n-   |        -    ^^^^^ expected type\n-   |        |\n-   |        help: maybe write a path separator here: `::`\n+LL |     let _ = Box:new(\"foo\".to_string());\n+   |                -    ^^^^^ expected type\n+   |                |\n+   |                help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n "}, {"sha": "787fcc1208e1bd4a3cb490dbafab7db2b65bbdc0", "filename": "src/test/ui/suggestions/type-ascription-instead-of-path-2.fixed", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+fn main() -> Result<(), ()> {\n+    let _ = vec![Ok(2)].into_iter().collect::<Result<Vec<_>,_>>()?;\n+    //~^ ERROR expected `::`, found `(`\n+    Ok(())\n+}"}, {"sha": "934016b3b811f9e4b3510884ef88ac92788915fa", "filename": "src/test/ui/suggestions/type-ascription-instead-of-path-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,6 @@\n+// run-rustfix\n fn main() -> Result<(), ()> {\n-    vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n+    let _ = vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n     //~^ ERROR expected `::`, found `(`\n     Ok(())\n }"}, {"sha": "970b220b7371220701bf39a0fc71e9d3975eded7", "filename": "src/test/ui/suggestions/type-ascription-instead-of-path-2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,10 +1,10 @@\n error: expected `::`, found `(`\n-  --> $DIR/type-ascription-instead-of-path-2.rs:2:55\n+  --> $DIR/type-ascription-instead-of-path-2.rs:3:63\n    |\n-LL |     vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n-   |                                    -                  ^ expected `::`\n-   |                                    |\n-   |                                    help: maybe write a path separator here: `::`\n+LL |     let _ = vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n+   |                                            -                  ^ expected `::`\n+   |                                            |\n+   |                                            help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n "}, {"sha": "b3247e1287d9989e07d7d61f16c7fa2dae9cc6d4", "filename": "src/test/ui/suggestions/type-ascription-instead-of-variant.fixed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let _ = Option::Some(\"\");\n+    //~^ ERROR expected type, found\n+}"}, {"sha": "6fd2c19541cdb9ad8331de76bc2cea5dc1da7c21", "filename": "src/test/ui/suggestions/type-ascription-instead-of-variant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn main() {\n     let _ = Option:Some(\"\");\n     //~^ ERROR expected type, found"}, {"sha": "f59ba78d4d38a9c8bfdebaa5cbad952f66220a5a", "filename": "src/test/ui/suggestions/type-ascription-instead-of-variant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n error: expected type, found `\"\"`\n-  --> $DIR/type-ascription-instead-of-variant.rs:2:25\n+  --> $DIR/type-ascription-instead-of-variant.rs:3:25\n    |\n LL |     let _ = Option:Some(\"\");\n    |                   -     ^^ expected type"}, {"sha": "c4db747551e5202b21ada7a939385f407f4c4e9b", "filename": "src/test/ui/type/ascription/issue-47666.fixed", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,4 @@\n+// run-rustfix\n+fn main() {\n+    let _ = Option::Some(vec![0, 1]); //~ ERROR expected type, found\n+}"}, {"sha": "c67202e2157f024993993e2ea8fedfca9c6339fd", "filename": "src/test/ui/type/ascription/issue-47666.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,7 +1,4 @@\n+// run-rustfix\n fn main() {\n     let _ = Option:Some(vec![0, 1]); //~ ERROR expected type, found\n-    //~^ ERROR expected value, found enum `Option`\n-    //~| ERROR expected type, found variant `Some`\n }\n-\n-// This case isn't currently being handled gracefully due to the macro invocation."}, {"sha": "ba393ff1a208e2fd3f67d05f8915dd162f11d899", "filename": "src/test/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n error: expected type, found reserved keyword `box`\n-  --> $DIR/issue-47666.rs:2:25\n+  --> $DIR/issue-47666.rs:3:25\n    |\n LL |     let _ = Option:Some(vec![0, 1]);\n    |                   -     ^^^^^^^^^^\n@@ -12,35 +12,5 @@ LL |     let _ = Option:Some(vec![0, 1]);\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0423]: expected value, found enum `Option`\n-  --> $DIR/issue-47666.rs:2:13\n-   |\n-LL |     let _ = Option:Some(vec![0, 1]);\n-   |             ^^^^^^\n-   |\n-help: try using one of the enum's variants\n-   |\n-LL |     let _ = std::option::Option::None:Some(vec![0, 1]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |     let _ = std::option::Option::Some:Some(vec![0, 1]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0573]: expected type, found variant `Some`\n-  --> $DIR/issue-47666.rs:2:20\n-   |\n-LL |     let _ = Option:Some(vec![0, 1]);\n-   |                    ^^^^^^^^^^^^^^^^ not a type\n-   |\n-help: try using the variant's enum\n-   |\n-LL |     let _ = Option:std::option::Option;\n-   |                    ^^^^^^^^^^^^^^^^^^^\n-help: maybe you meant to write a path separator here\n-   |\n-LL |     let _ = Option::Some(vec![0, 1]);\n-   |                   ^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0423, E0573.\n-For more information about an error, try `rustc --explain E0423`."}, {"sha": "181637b97bb6a2c82e83709f98787a9f09e3db6d", "filename": "src/test/ui/type/ascription/issue-54516.fixed", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,7 @@\n+// run-rustfix\n+use std::collections::BTreeMap;\n+\n+fn main() {\n+    println!(\"{}\", std::mem::size_of::<BTreeMap<u32, u32>>());\n+    //~^ ERROR casts cannot be followed by a function call\n+}"}, {"sha": "f09ddd487d8954b24ac4a509636a6ad536f9e86a", "filename": "src/test/ui/type/ascription/issue-54516.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,7 @@\n+// run-rustfix\n use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n     //~^ ERROR casts cannot be followed by a function call\n-    //~| ERROR expected value, found module `std::mem` [E0423]\n-    //~| ERROR cannot find type `size_of` in this scope [E0412]\n }"}, {"sha": "2c7ff6bdc48661b36ba2bf8afe3e89dccfba5813", "filename": "src/test/ui/type/ascription/issue-54516.stderr", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,5 +1,5 @@\n error: casts cannot be followed by a function call\n-  --> $DIR/issue-54516.rs:4:20\n+  --> $DIR/issue-54516.rs:5:20\n    |\n LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n    |                    ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,23 +8,5 @@ LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n \n-error[E0423]: expected value, found module `std::mem`\n-  --> $DIR/issue-54516.rs:4:20\n-   |\n-LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-   |                    ^^^^^^^^- help: maybe you meant to write a path separator here: `::`\n-   |                    |\n-   |                    not a value\n-\n-error[E0412]: cannot find type `size_of` in this scope\n-  --> $DIR/issue-54516.rs:4:29\n-   |\n-LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-   |                            -^^^^^^^ not found in this scope\n-   |                            |\n-   |                            help: maybe you meant to write a path separator here: `::`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0412, E0423.\n-For more information about an error, try `rustc --explain E0412`."}, {"sha": "ac9f6a07031fc0b60616cc2cdfe8379430af6624", "filename": "src/test/ui/type/ascription/issue-60933.fixed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let _: usize = std::mem::size_of::<u32>();\n+    //~^ ERROR casts cannot be followed by a function call\n+}"}, {"sha": "cb093735efa581ea029ca81273a83e4839962b2d", "filename": "src/test/ui/type/ascription/issue-60933.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,6 +1,5 @@\n+// run-rustfix\n fn main() {\n-    let u: usize = std::mem:size_of::<u32>();\n+    let _: usize = std::mem:size_of::<u32>();\n     //~^ ERROR casts cannot be followed by a function call\n-    //~| ERROR expected value, found module `std::mem` [E0423]\n-    //~| ERROR cannot find type `size_of` in this scope [E0412]\n }"}, {"sha": "5c35de88e14d60348cc6fa455a2a174e932ab747", "filename": "src/test/ui/type/ascription/issue-60933.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,30 +1,12 @@\n error: casts cannot be followed by a function call\n-  --> $DIR/issue-60933.rs:2:20\n+  --> $DIR/issue-60933.rs:3:20\n    |\n-LL |     let u: usize = std::mem:size_of::<u32>();\n+LL |     let _: usize = std::mem:size_of::<u32>();\n    |                    ^^^^^^^^-^^^^^^^^^^^^^^\n    |                            |\n    |                            help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n \n-error[E0423]: expected value, found module `std::mem`\n-  --> $DIR/issue-60933.rs:2:20\n-   |\n-LL |     let u: usize = std::mem:size_of::<u32>();\n-   |                    ^^^^^^^^- help: maybe you meant to write a path separator here: `::`\n-   |                    |\n-   |                    not a value\n-\n-error[E0412]: cannot find type `size_of` in this scope\n-  --> $DIR/issue-60933.rs:2:29\n-   |\n-LL |     let u: usize = std::mem:size_of::<u32>();\n-   |                            -^^^^^^^ not found in this scope\n-   |                            |\n-   |                            help: maybe you meant to write a path separator here: `::`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0412, E0423.\n-For more information about an error, try `rustc --explain E0412`."}, {"sha": "6d96c4303c357f707e7883a9a028d95b25ed7be1", "filename": "src/test/ui/type/type-ascription-with-fn-call.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+#![feature(type_ascription)]\n+\n+fn main() {\n+    f()  ;\n+    f(); //~ ERROR expected type, found function\n+}\n+\n+fn f() {}"}, {"sha": "ed4f7c9041c3a7e1ce2e865f887c737297220214", "filename": "src/test/ui/type/type-ascription-with-fn-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n #![feature(type_ascription)]\n \n fn main() {"}, {"sha": "5f74724b59e52ced1686a3707d9b732124157ed9", "filename": "src/test/ui/type/type-ascription-with-fn-call.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,8 +1,8 @@\n error[E0573]: expected type, found function `f`\n-  --> $DIR/type-ascription-with-fn-call.rs:5:5\n+  --> $DIR/type-ascription-with-fn-call.rs:6:5\n    |\n LL |     f()  :\n-   |          - help: did you mean to use `;` here instead?\n+   |          - help: maybe you meant to write `;` here\n LL |     f();\n    |     ^^^\n    |     |"}, {"sha": "2435be623f310312c7fbdac55161fc0f1454dd6b", "filename": "src/test/ui/warn-path-statement.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fwarn-path-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fwarn-path-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwarn-path-statement.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,6 +1,17 @@\n // compile-flags: -D path-statements\n-fn main() {\n+struct Droppy;\n+\n+impl Drop for Droppy {\n+    fn drop(&mut self) {}\n+}\n \n+fn main() {\n     let x = 10;\n     x; //~ ERROR path statement with no effect\n+\n+    let y = Droppy;\n+    y; //~ ERROR path statement drops value\n+\n+    let z = (Droppy,);\n+    z; //~ ERROR path statement drops value\n }"}, {"sha": "248d2ef299be38925b96cc0bd2c4bac429dc08eb", "filename": "src/test/ui/warn-path-statement.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fwarn-path-statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftest%2Fui%2Fwarn-path-statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwarn-path-statement.stderr?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1,10 +1,22 @@\n error: path statement with no effect\n-  --> $DIR/warn-path-statement.rs:5:5\n+  --> $DIR/warn-path-statement.rs:10:5\n    |\n LL |     x;\n    |     ^^\n    |\n    = note: requested on the command line with `-D path-statements`\n \n-error: aborting due to previous error\n+error: path statement drops value\n+  --> $DIR/warn-path-statement.rs:13:5\n+   |\n+LL |     y;\n+   |     ^^ help: use `drop` to clarify the intent: `drop(y);`\n+\n+error: path statement drops value\n+  --> $DIR/warn-path-statement.rs:16:5\n+   |\n+LL |     z;\n+   |     ^^ help: use `drop` to clarify the intent: `drop(z);`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "5dede95a85823d63734eb9a4f28850b533ef02c0", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -156,6 +156,7 @@ static DOCS_TARGETS: &[&str] = &[\n     \"x86_64-pc-windows-gnu\",\n     \"x86_64-pc-windows-msvc\",\n     \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-linux-musl\",\n ];\n \n static MINGW: &[&str] = &[\"i686-pc-windows-gnu\", \"x86_64-pc-windows-gnu\"];"}, {"sha": "1653f354644834073d6d2541e27fae94588e685e", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -1 +1 @@\n-Subproject commit 2d5c2381e4e50484bf281fc1bfe19743aa9eb37a\n+Subproject commit 1653f354644834073d6d2541e27fae94588e685e"}, {"sha": "40af6bb3d7bcff06c605c0bd4a04238a3fc583e2", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -286,14 +286,14 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                     },\n                     _ => {},\n                 }\n-                if items.is_empty() || !attr.check_name(sym!(deprecated)) {\n+                if items.is_empty() || !attr.has_name(sym!(deprecated)) {\n                     return;\n                 }\n                 for item in items {\n                     if_chain! {\n                         if let NestedMetaItem::MetaItem(mi) = &item;\n                         if let MetaItemKind::NameValue(lit) = &mi.kind;\n-                        if mi.check_name(sym!(since));\n+                        if mi.has_name(sym!(since));\n                         then {\n                             check_semver(cx, item.span(), lit);\n                         }\n@@ -309,7 +309,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n         }\n         match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(sym!(macro_use)));\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym!(macro_use)));\n \n                 for attr in item.attrs {\n                     if in_external_macro(cx.sess(), attr.span) {\n@@ -524,7 +524,7 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Name, attrs: &[Attribute]\n \n     for attr in attrs {\n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || !attr.check_name(sym!(inline)) {\n+            if values.len() != 1 || !attr.has_name(sym!(inline)) {\n                 continue;\n             }\n             if is_word(&values[0], sym!(always)) {\n@@ -558,7 +558,7 @@ fn check_semver(cx: &LateContext<'_>, span: Span, lit: &Lit) {\n \n fn is_word(nmi: &NestedMetaItem, expected: Symbol) -> bool {\n     if let NestedMetaItem::MetaItem(mi) = &nmi {\n-        mi.is_word() && mi.check_name(expected)\n+        mi.is_word() && mi.has_name(expected)\n     } else {\n         false\n     }\n@@ -618,15 +618,15 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::as\n fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n     if_chain! {\n         // check cfg_attr\n-        if attr.check_name(sym!(cfg_attr));\n+        if attr.has_name(sym!(cfg_attr));\n         if let Some(items) = attr.meta_item_list();\n         if items.len() == 2;\n         // check for `rustfmt`\n         if let Some(feature_item) = items[0].meta_item();\n-        if feature_item.check_name(sym!(rustfmt));\n+        if feature_item.has_name(sym!(rustfmt));\n         // check for `rustfmt_skip` and `rustfmt::skip`\n         if let Some(skip_item) = &items[1].meta_item();\n-        if skip_item.check_name(sym!(rustfmt_skip)) ||\n+        if skip_item.has_name(sym!(rustfmt_skip)) ||\n             skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == sym!(skip);\n         // Only lint outer attributes, because custom inner attributes are unstable\n         // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n@@ -685,7 +685,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n     }\n \n     if_chain! {\n-        if attr.check_name(sym!(cfg));\n+        if attr.has_name(sym!(cfg));\n         if let Some(list) = attr.meta_item_list();\n         let mismatched = find_mismatched_target_os(&list);\n         if !mismatched.is_empty();"}, {"sha": "e87c33d1b09dd42d6e688b0e079a7760817b4a36", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac939edcf2137f625cfd7b56dfa4aa7b814868f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=bac939edcf2137f625cfd7b56dfa4aa7b814868f", "patch": "@@ -323,7 +323,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n             let (comment, current_spans) = strip_doc_comment_decoration(&comment, attr.span);\n             spans.extend_from_slice(&current_spans);\n             doc.push_str(&comment);\n-        } else if attr.check_name(sym!(doc)) {\n+        } else if attr.has_name(sym!(doc)) {\n             // ignore mix of sugared and non-sugared doc\n             // don't trigger the safety or errors check\n             return DocHeaders {"}]}