{"sha": "18a366990335748d6020e306327048de9e4340c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YTM2Njk5MDMzNTc0OGQ2MDIwZTMwNjMyNzA0OGRlOWU0MzQwYzM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-12-20T23:53:41Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-31T22:58:29Z"}, "message": "Revert parts of #66405.\n\nBecause it caused major performance regressions in some cases.\n\nThat PR had five commits, two of which affected performance, and three\nof which were refactorings. This change undoes the performance-affecting\nchanges, while keeping the refactorings in place.\n\nFixes #67454.", "tree": {"sha": "98bdc41809bd000f911bcb3986b943a239416a61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98bdc41809bd000f911bcb3986b943a239416a61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18a366990335748d6020e306327048de9e4340c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18a366990335748d6020e306327048de9e4340c3", "html_url": "https://github.com/rust-lang/rust/commit/18a366990335748d6020e306327048de9e4340c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18a366990335748d6020e306327048de9e4340c3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71bb0ff33e3759ee71ea19c230492c11e5e32b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bb0ff33e3759ee71ea19c230492c11e5e32b87", "html_url": "https://github.com/rust-lang/rust/commit/71bb0ff33e3759ee71ea19c230492c11e5e32b87"}], "stats": {"total": 191, "additions": 80, "deletions": 111}, "files": [{"sha": "974d9dcfae40819d444f5c7ad77ab42c9e5935b1", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 80, "deletions": 111, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/18a366990335748d6020e306327048de9e4340c3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a366990335748d6020e306327048de9e4340c3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=18a366990335748d6020e306327048de9e4340c3", "patch": "@@ -129,18 +129,14 @@ type ObligationTreeIdGenerator =\n \n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to `process_obligations`,\n-    /// this list only contains nodes in the `Pending` or `Success` state.\n+    /// this list only contains nodes in the `Pending` or `Waiting` state.\n     ///\n     /// `usize` indices are used here and throughout this module, rather than\n     /// `rustc_index::newtype_index!` indices, because this code is hot enough\n     /// that the `u32`-to-`usize` conversions that would be required are\n     /// significant, and space considerations are not important.\n     nodes: Vec<Node<O>>,\n \n-    /// The process generation is 1 on the first call to `process_obligations`,\n-    /// 2 on the second call, etc.\n-    gen: u32,\n-\n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n \n@@ -196,9 +192,9 @@ impl<O> Node<O> {\n     }\n }\n \n-/// The state of one node in some tree within the forest. This\n-/// represents the current state of processing for the obligation (of\n-/// type `O`) associated with this node.\n+/// The state of one node in some tree within the forest. This represents the\n+/// current state of processing for the obligation (of type `O`) associated\n+/// with this node.\n ///\n /// The non-`Error` state transitions are as follows.\n /// ```\n@@ -210,51 +206,47 @@ impl<O> Node<O> {\n ///  |\n ///  |     process_obligations()\n ///  v\n-/// Success(not_waiting())\n-///  |  |\n-///  |  |  mark_still_waiting_nodes()\n+/// Success\n+///  |  ^\n+///  |  |  mark_successes()\n ///  |  v\n-///  | Success(still_waiting())\n-///  |  |\n-///  |  |  compress()\n-///  v  v\n+///  |  Waiting\n+///  |\n+///  |     process_cycles()\n+///  v\n+/// Done\n+///  |\n+///  |     compress()\n+///  v\n /// (Removed)\n /// ```\n /// The `Error` state can be introduced in several places, via `error_at()`.\n ///\n /// Outside of `ObligationForest` methods, nodes should be either `Pending` or\n-/// `Success`.\n+/// `Waiting`.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum NodeState {\n     /// This obligation has not yet been selected successfully. Cannot have\n     /// subobligations.\n     Pending,\n \n-    /// This obligation was selected successfully, but it may be waiting on one\n-    /// or more pending subobligations, as indicated by the `WaitingState`.\n-    Success(WaitingState),\n+    /// This obligation was selected successfully, but may or may not have\n+    /// subobligations.\n+    Success,\n+\n+    /// This obligation was selected successfully, but it has a pending\n+    /// subobligation.\n+    Waiting,\n+\n+    /// This obligation, along with its subobligations, are complete, and will\n+    /// be removed in the next collection.\n+    Done,\n \n     /// This obligation was resolved to an error. It will be removed by the\n     /// next compression step.\n     Error,\n }\n \n-/// Indicates when a `Success` node was last (if ever) waiting on one or more\n-/// `Pending` nodes. The notion of \"when\" comes from `ObligationForest::gen`.\n-/// - 0: \"Not waiting\". This is a special value, set by `process_obligation`,\n-///   and usable because generation counting starts at 1.\n-/// - 1..ObligationForest::gen: \"Was waiting\" in a previous generation, but\n-///   waiting no longer. In other words, finished.\n-/// - ObligationForest::gen: \"Still waiting\" in this generation.\n-///\n-/// Things to note about this encoding:\n-/// - Every time `ObligationForest::gen` is incremented, all the \"still\n-///   waiting\" nodes automatically become \"was waiting\".\n-/// - `ObligationForest::is_still_waiting` is very cheap.\n-///\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd)]\n-struct WaitingState(u32);\n-\n #[derive(Debug)]\n pub struct Outcome<O, E> {\n     /// Obligations that were completely evaluated, including all\n@@ -291,7 +283,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n-            gen: 0,\n             done_cache: Default::default(),\n             active_cache: Default::default(),\n             node_rewrites: RefCell::new(vec![]),\n@@ -392,18 +383,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .insert(node.obligation.as_predicate().clone());\n     }\n \n-    fn not_waiting() -> WaitingState {\n-        WaitingState(0)\n-    }\n-\n-    fn still_waiting(&self) -> WaitingState {\n-        WaitingState(self.gen)\n-    }\n-\n-    fn is_still_waiting(&self, waiting: WaitingState) -> bool {\n-        waiting.0 == self.gen\n-    }\n-\n     /// Performs a pass through the obligation list. This must\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n@@ -416,8 +395,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     where\n         P: ObligationProcessor<Obligation = O>,\n     {\n-        self.gen += 1;\n-\n         let mut errors = vec![];\n         let mut stalled = true;\n \n@@ -450,7 +427,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    node.state.set(NodeState::Success(Self::not_waiting()));\n+                    node.state.set(NodeState::Success);\n \n                     for child in children {\n                         let st = self.register_obligation_at(child, Some(index));\n@@ -479,7 +456,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             };\n         }\n \n-        self.mark_still_waiting_nodes();\n+        self.mark_successes();\n         self.process_cycles(processor);\n         let completed = self.compress(do_completed);\n \n@@ -519,41 +496,50 @@ impl<O: ForestObligation> ObligationForest<O> {\n         trace\n     }\n \n-    /// Mark all `Success` nodes that depend on a pending node as still\n-    /// waiting. Upon completion, any `Success` nodes that aren't still waiting\n-    /// can be removed by `compress`.\n-    fn mark_still_waiting_nodes(&self) {\n+    /// Mark all `Waiting` nodes as `Success`, except those that depend on a\n+    /// pending node.\n+    fn mark_successes(&self) {\n+        // Convert all `Waiting` nodes to `Success`.\n+        for node in &self.nodes {\n+            if node.state.get() == NodeState::Waiting {\n+                node.state.set(NodeState::Success);\n+            }\n+        }\n+\n+        // Convert `Success` nodes that depend on a pending node back to\n+        // `Waiting`.\n         for node in &self.nodes {\n             if node.state.get() == NodeState::Pending {\n                 // This call site is hot.\n-                self.inlined_mark_dependents_as_still_waiting(node);\n+                self.inlined_mark_dependents_as_waiting(node);\n             }\n         }\n     }\n \n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n-    fn inlined_mark_dependents_as_still_waiting(&self, node: &Node<O>) {\n+    fn inlined_mark_dependents_as_waiting(&self, node: &Node<O>) {\n         for &index in node.dependents.iter() {\n             let node = &self.nodes[index];\n-            if let NodeState::Success(waiting) = node.state.get() {\n-                if !self.is_still_waiting(waiting) {\n-                    node.state.set(NodeState::Success(self.still_waiting()));\n-                    // This call site is cold.\n-                    self.uninlined_mark_dependents_as_still_waiting(node);\n-                }\n+            let state = node.state.get();\n+            if state == NodeState::Success {\n+                node.state.set(NodeState::Waiting);\n+                // This call site is cold.\n+                self.uninlined_mark_dependents_as_waiting(node);\n+            } else {\n+                debug_assert!(state == NodeState::Waiting || state == NodeState::Error)\n             }\n         }\n     }\n \n     // This never-inlined function is for the cold call site.\n     #[inline(never)]\n-    fn uninlined_mark_dependents_as_still_waiting(&self, node: &Node<O>) {\n-        self.inlined_mark_dependents_as_still_waiting(node)\n+    fn uninlined_mark_dependents_as_waiting(&self, node: &Node<O>) {\n+        self.inlined_mark_dependents_as_waiting(node)\n     }\n \n-    /// Report cycles between all `Success` nodes that aren't still waiting.\n-    /// This must be called after `mark_still_waiting_nodes`.\n+    /// Report cycles between all `Success` nodes, and convert all `Success`\n+    /// nodes to `Done`. This must be called after `mark_successes`.\n     fn process_cycles<P>(&self, processor: &mut P)\n     where\n         P: ObligationProcessor<Obligation = O>,\n@@ -564,63 +550,51 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // For some benchmarks this state test is extremely hot. It's a win\n             // to handle the no-op cases immediately to avoid the cost of the\n             // function call.\n-            if let NodeState::Success(waiting) = node.state.get() {\n-                if !self.is_still_waiting(waiting) {\n-                    self.find_cycles_from_node(&mut stack, processor, index, index);\n-                }\n+            if node.state.get() == NodeState::Success {\n+                self.find_cycles_from_node(&mut stack, processor, index);\n             }\n         }\n \n         debug_assert!(stack.is_empty());\n     }\n \n-    fn find_cycles_from_node<P>(\n-        &self,\n-        stack: &mut Vec<usize>,\n-        processor: &mut P,\n-        min_index: usize,\n-        index: usize,\n-    ) where\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n+    where\n         P: ObligationProcessor<Obligation = O>,\n     {\n         let node = &self.nodes[index];\n-        if let NodeState::Success(waiting) = node.state.get() {\n-            if !self.is_still_waiting(waiting) {\n-                match stack.iter().rposition(|&n| n == index) {\n-                    None => {\n-                        stack.push(index);\n-                        for &dep_index in node.dependents.iter() {\n-                            // The index check avoids re-considering a node.\n-                            if dep_index >= min_index {\n-                                self.find_cycles_from_node(stack, processor, min_index, dep_index);\n-                            }\n-                        }\n-                        stack.pop();\n-                    }\n-                    Some(rpos) => {\n-                        // Cycle detected.\n-                        processor.process_backedge(\n-                            stack[rpos..].iter().map(GetObligation(&self.nodes)),\n-                            PhantomData,\n-                        );\n+        if node.state.get() == NodeState::Success {\n+            match stack.iter().rposition(|&n| n == index) {\n+                None => {\n+                    stack.push(index);\n+                    for &dep_index in node.dependents.iter() {\n+                        self.find_cycles_from_node(stack, processor, dep_index);\n                     }\n+                    stack.pop();\n+                    node.state.set(NodeState::Done);\n+                }\n+                Some(rpos) => {\n+                    // Cycle detected.\n+                    processor.process_backedge(\n+                        stack[rpos..].iter().map(GetObligation(&self.nodes)),\n+                        PhantomData,\n+                    );\n                 }\n             }\n         }\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts the\n     /// indices and hence invalidates any outstanding indices. `process_cycles`\n-    /// must be run beforehand to remove any cycles on not-still-waiting\n-    /// `Success` nodes.\n+    /// must be run beforehand to remove any cycles on `Success` nodes.\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let orig_nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.node_rewrites.replace(vec![]);\n         debug_assert!(node_rewrites.is_empty());\n         node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n-        let mut removed_success_obligations: Vec<O> = vec![];\n+        let mut removed_done_obligations: Vec<O> = vec![];\n \n         // Move removable nodes to the end, preserving the order of the\n         // remaining nodes.\n@@ -632,19 +606,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n         for index in 0..orig_nodes_len {\n             let node = &self.nodes[index];\n             match node.state.get() {\n-                NodeState::Pending => {\n-                    if dead_nodes > 0 {\n-                        self.nodes.swap(index, index - dead_nodes);\n-                        node_rewrites[index] -= dead_nodes;\n-                    }\n-                }\n-                NodeState::Success(waiting) if self.is_still_waiting(waiting) => {\n+                NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n                         self.nodes.swap(index, index - dead_nodes);\n                         node_rewrites[index] -= dead_nodes;\n                     }\n                 }\n-                NodeState::Success(_) => {\n+                NodeState::Done => {\n                     // This lookup can fail because the contents of\n                     // `self.active_cache` are not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n@@ -658,7 +626,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                     if do_completed == DoCompleted::Yes {\n                         // Extract the success stories.\n-                        removed_success_obligations.push(node.obligation.clone());\n+                        removed_done_obligations.push(node.obligation.clone());\n                     }\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n@@ -672,6 +640,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n+                NodeState::Success => unreachable!(),\n             }\n         }\n \n@@ -684,7 +653,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         node_rewrites.truncate(0);\n         self.node_rewrites.replace(node_rewrites);\n \n-        if do_completed == DoCompleted::Yes { Some(removed_success_obligations) } else { None }\n+        if do_completed == DoCompleted::Yes { Some(removed_done_obligations) } else { None }\n     }\n \n     fn apply_rewrites(&mut self, node_rewrites: &[usize]) {"}]}