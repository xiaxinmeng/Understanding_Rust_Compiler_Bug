{"sha": "d6de1e9714b58298a688026470aeeffcf3645314", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZGUxZTk3MTRiNTgyOThhNjg4MDI2NDcwYWVlZmZjZjM2NDUzMTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-25T10:42:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-25T10:42:31Z"}, "message": "Rollup merge of #58727 - taiki-e:deny-rust_2018_idioms-bootstrap, r=Centril\n\nbootstrap: deny(rust_2018_idioms)\n\nAs part of the Rust 2018 transition, apply `#![deny(rust_2018_idioms)]` to `bootstrap`.\n\nr? @Centril", "tree": {"sha": "2c7b768fbdd02447625350e6d53fd8f7910a5003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c7b768fbdd02447625350e6d53fd8f7910a5003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6de1e9714b58298a688026470aeeffcf3645314", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcc8aYCRBK7hj4Ov3rIwAAdHIIAKx0SGXcbWos3cu+7cwr3hZO\nqn+cmfEtSQJchiLcEO3pYurb/qAZeWvHGzZzHOfGk+HLM1jUaMNkMzT8ThkZKcGq\nQkERz5WTvw1GCTmHLj9l/H1p+eQqrsYgN4MPkmp+kjlV+eoDXGBNN/iIEllUfKtd\nKtbF6QeeXsuHjH3VTxzJvUFCdJET7XKH0z3NCwiFSg262wneE2Zkj33BhM6xY705\n17Qu/+km/DAILFtZqgfbRxYNUhSBoRFudwdhi/svYWhgkO2+be5dKZYH5NEZD6/Y\nkPYBRvkv/8gA37Wqr+KNQ7MigvITeKrcrbbKJcWnmjuliH+CyQUD6tHynGBFLd0=\n=ChyZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 2c7b768fbdd02447625350e6d53fd8f7910a5003\nparent e53fbf8bf21a250ae1dcf39629edb9eaaea066eb\nparent 6343d6bc0da7ebeadb008f9184f9171fa6d8b900\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1551091351 +0100\ncommitter GitHub <noreply@github.com> 1551091351 +0100\n\nRollup merge of #58727 - taiki-e:deny-rust_2018_idioms-bootstrap, r=Centril\n\nbootstrap: deny(rust_2018_idioms)\n\nAs part of the Rust 2018 transition, apply `#![deny(rust_2018_idioms)]` to `bootstrap`.\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6de1e9714b58298a688026470aeeffcf3645314", "html_url": "https://github.com/rust-lang/rust/commit/d6de1e9714b58298a688026470aeeffcf3645314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6de1e9714b58298a688026470aeeffcf3645314/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e53fbf8bf21a250ae1dcf39629edb9eaaea066eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e53fbf8bf21a250ae1dcf39629edb9eaaea066eb", "html_url": "https://github.com/rust-lang/rust/commit/e53fbf8bf21a250ae1dcf39629edb9eaaea066eb"}, {"sha": "6343d6bc0da7ebeadb008f9184f9171fa6d8b900", "url": "https://api.github.com/repos/rust-lang/rust/commits/6343d6bc0da7ebeadb008f9184f9171fa6d8b900", "html_url": "https://github.com/rust-lang/rust/commit/6343d6bc0da7ebeadb008f9184f9171fa6d8b900"}], "stats": {"total": 667, "additions": 352, "deletions": 315}, "files": [{"sha": "7e6c0a9f52aa21bb1d6f28edd335ff34203f81c5", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -62,21 +62,21 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n     /// Primary function to execute this rule. Can call `builder.ensure()`\n     /// with other steps to run those.\n-    fn run(self, builder: &Builder) -> Self::Output;\n+    fn run(self, builder: &Builder<'_>) -> Self::Output;\n \n     /// When bootstrap is passed a set of paths, this controls whether this rule\n     /// will execute. However, it does not get called in a \"default\" context\n     /// when we are not passed any paths; in that case, `make_run` is called\n     /// directly.\n-    fn should_run(run: ShouldRun) -> ShouldRun;\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_>;\n \n     /// Builds up a \"root\" rule, either as a default rule or from a path passed\n     /// to us.\n     ///\n     /// When path is `None`, we are executing in a context where no paths were\n     /// passed. When `./x.py build` is run, for example, this rule could get\n     /// called if it is in the correct list below with a path of `None`.\n-    fn make_run(_run: RunConfig) {\n+    fn make_run(_run: RunConfig<'_>) {\n         // It is reasonable to not have an implementation of make_run for rules\n         // who do not want to get called from the root context. This means that\n         // they are likely dependencies (e.g., sysroot creation) or similar, and\n@@ -95,8 +95,8 @@ pub struct RunConfig<'a> {\n struct StepDescription {\n     default: bool,\n     only_hosts: bool,\n-    should_run: fn(ShouldRun) -> ShouldRun,\n-    make_run: fn(RunConfig),\n+    should_run: fn(ShouldRun<'_>) -> ShouldRun<'_>,\n+    make_run: fn(RunConfig<'_>),\n     name: &'static str,\n }\n \n@@ -124,7 +124,7 @@ impl PathSet {\n         }\n     }\n \n-    fn path(&self, builder: &Builder) -> PathBuf {\n+    fn path(&self, builder: &Builder<'_>) -> PathBuf {\n         match self {\n             PathSet::Set(set) => set\n                 .iter()\n@@ -147,7 +147,7 @@ impl StepDescription {\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder, pathset: &PathSet) {\n+    fn maybe_run(&self, builder: &Builder<'_>, pathset: &PathSet) {\n         if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n             eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n             return;\n@@ -183,7 +183,7 @@ impl StepDescription {\n         }\n     }\n \n-    fn run(v: &[StepDescription], builder: &Builder, paths: &[PathBuf]) {\n+    fn run(v: &[StepDescription], builder: &Builder<'_>, paths: &[PathBuf]) {\n         let should_runs = v\n             .iter()\n             .map(|desc| (desc.should_run)(ShouldRun::new(builder)))\n@@ -245,7 +245,7 @@ pub struct ShouldRun<'a> {\n }\n \n impl<'a> ShouldRun<'a> {\n-    fn new(builder: &'a Builder) -> ShouldRun<'a> {\n+    fn new(builder: &'a Builder<'_>) -> ShouldRun<'a> {\n         ShouldRun {\n             builder,\n             paths: BTreeSet::new(),\n@@ -511,7 +511,7 @@ impl<'a> Builder<'a> {\n         Some(help)\n     }\n \n-    pub fn new(build: &Build) -> Builder {\n+    pub fn new(build: &Build) -> Builder<'_> {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n@@ -591,11 +591,11 @@ impl<'a> Builder<'a> {\n         impl Step for Libdir {\n             type Output = Interned<PathBuf>;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.never()\n             }\n \n-            fn run(self, builder: &Builder) -> Interned<PathBuf> {\n+            fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n                 let compiler = self.compiler;\n                 let config = &builder.build.config;\n                 let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {"}, {"sha": "239959682cb005771bccfd074bd5c9d4d2e0ecb1", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -68,20 +68,20 @@ unsafe impl<T> Send for Interned<T> {}\n unsafe impl<T> Sync for Interned<T> {}\n \n impl fmt::Display for Interned<String> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let s: &str = &*self;\n         f.write_str(s)\n     }\n }\n \n impl fmt::Debug for Interned<String> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let s: &str = &*self;\n         f.write_fmt(format_args!(\"{:?}\", s))\n     }\n }\n impl fmt::Debug for Interned<PathBuf> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let s: &Path = &*self;\n         f.write_fmt(format_args!(\"{:?}\", s))\n     }"}, {"sha": "dfc243b7054abf6caf660bf6610828cf537308c7", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -27,7 +27,6 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::output;\n-use cc;\n \n use crate::{Build, GitRepo};\n use crate::config::Target;\n@@ -157,7 +156,7 @@ fn set_compiler(cfg: &mut cc::Build,\n                 None => return,\n             };\n             match output[i + 3..].chars().next().unwrap() {\n-                '0' ... '6' => {}\n+                '0' ..= '6' => {}\n                 _ => return,\n             }\n             let alternative = format!(\"e{}\", gnu_compiler);"}, {"sha": "20370372082b94ef009ab1408ad143ff28423799", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -17,17 +17,17 @@ impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"std\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = builder.compiler(0, builder.config.build);\n \n@@ -56,11 +56,11 @@ impl Step for Rustc {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc-main\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             target: run.target,\n         });\n@@ -71,7 +71,7 @@ impl Step for Rustc {\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n@@ -103,11 +103,11 @@ impl Step for CodegenBackend {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let backend = run.builder.config.rust_codegen_backends.get(0);\n         let backend = backend.cloned().unwrap_or_else(|| {\n             INTERNER.intern_str(\"llvm\")\n@@ -118,7 +118,7 @@ impl Step for CodegenBackend {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n         let backend = self.backend;\n@@ -148,17 +148,17 @@ impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"test\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Test {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n@@ -189,17 +189,17 @@ impl Step for Rustdoc {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustdoc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n@@ -229,25 +229,37 @@ impl Step for Rustdoc {\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libstd_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libtest_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn librustc_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n \n /// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n-fn codegen_backend_stamp(builder: &Builder,\n+fn codegen_backend_stamp(builder: &Builder<'_>,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n@@ -257,7 +269,11 @@ fn codegen_backend_stamp(builder: &Builder,\n \n /// Cargo's output path for rustdoc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn rustdoc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn rustdoc_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::ToolRustc, target)\n         .join(\".rustdoc-check.stamp\")\n }"}, {"sha": "249a18318904831ff362d09da4ed8854858b4d5f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -37,11 +37,11 @@ impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"std\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -53,7 +53,7 @@ impl Step for Std {\n     /// This will build the standard library for a particular stage of the build\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = self.compiler;\n \n@@ -111,7 +111,7 @@ impl Step for Std {\n }\n \n /// Copies third pary objects needed by various targets.\n-fn copy_third_party_objects(builder: &Builder, compiler: &Compiler, target: Interned<String>) {\n+fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>) {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n \n     // Copies the crt(1,i,n).o startup objects\n@@ -145,7 +145,7 @@ fn copy_third_party_objects(builder: &Builder, compiler: &Compiler, target: Inte\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder,\n+pub fn std_cargo(builder: &Builder<'_>,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n@@ -201,7 +201,7 @@ struct StdLink {\n impl Step for StdLink {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -213,7 +213,7 @@ impl Step for StdLink {\n     /// Note that this assumes that `compiler` has already generated the libstd\n     /// libraries for `target`, and this method will find them in the relevant\n     /// output directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n@@ -237,7 +237,12 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(builder: &Builder, native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(\n+    builder: &Builder<'_>,\n+    native_dir: &Path,\n+    platform: &str,\n+    into: &Path,\n+) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"lib__rustc__clang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n@@ -258,11 +263,11 @@ pub struct StartupObjects {\n impl Step for StartupObjects {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(StartupObjects {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -275,7 +280,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"pc-windows-gnu\") {\n@@ -323,11 +328,11 @@ impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"test\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Test {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -339,7 +344,7 @@ impl Step for Test {\n     /// This will build libtest and supporting libraries for a particular stage of\n     /// the build using the `compiler` targeting the `target` architecture. The\n     /// artifacts created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = self.compiler;\n \n@@ -390,7 +395,7 @@ impl Step for Test {\n }\n \n /// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(builder: &Builder,\n+pub fn test_cargo(builder: &Builder<'_>,\n                   _compiler: &Compiler,\n                   _target: Interned<String>,\n                   cargo: &mut Command) {\n@@ -411,12 +416,12 @@ pub struct TestLink {\n impl Step for TestLink {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Same as `std_link`, only for libtest\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n@@ -444,11 +449,11 @@ impl Step for Rustc {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc-main\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -460,7 +465,7 @@ impl Step for Rustc {\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -516,14 +521,14 @@ impl Step for Rustc {\n     }\n }\n \n-pub fn rustc_cargo(builder: &Builder, cargo: &mut Command) {\n+pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Command) {\n     cargo.arg(\"--features\").arg(builder.rustc_features())\n          .arg(\"--manifest-path\")\n          .arg(builder.src.join(\"src/rustc/Cargo.toml\"));\n     rustc_cargo_env(builder, cargo);\n }\n \n-pub fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n+pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Command) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo.env(\"CFG_RELEASE\", builder.rust_release())\n@@ -572,12 +577,12 @@ struct RustcLink {\n impl Step for RustcLink {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Same as `std_link`, only for librustc\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n@@ -605,11 +610,11 @@ impl Step for CodegenBackend {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let backend = run.builder.config.rust_codegen_backends.get(0);\n         let backend = backend.cloned().unwrap_or_else(|| {\n             INTERNER.intern_str(\"llvm\")\n@@ -621,7 +626,7 @@ impl Step for CodegenBackend {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let backend = self.backend;\n@@ -684,7 +689,7 @@ impl Step for CodegenBackend {\n     }\n }\n \n-pub fn build_codegen_backend(builder: &Builder,\n+pub fn build_codegen_backend(builder: &Builder<'_>,\n                              cargo: &mut Command,\n                              compiler: &Compiler,\n                              target: Interned<String>,\n@@ -753,7 +758,7 @@ pub fn build_codegen_backend(builder: &Builder,\n /// This will take the codegen artifacts produced by `compiler` and link them\n /// into an appropriate location for `target_compiler` to be a functional\n /// compiler.\n-fn copy_codegen_backends_to_sysroot(builder: &Builder,\n+fn copy_codegen_backends_to_sysroot(builder: &Builder<'_>,\n                                     compiler: Compiler,\n                                     target_compiler: Compiler) {\n     let target = target_compiler.host;\n@@ -791,7 +796,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     }\n }\n \n-fn copy_lld_to_sysroot(builder: &Builder,\n+fn copy_lld_to_sysroot(builder: &Builder<'_>,\n                        target_compiler: Compiler,\n                        lld_install_root: &Path) {\n     let target = target_compiler.host;\n@@ -811,36 +816,50 @@ fn copy_lld_to_sysroot(builder: &Builder,\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libstd_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libtest_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn librustc_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n }\n \n /// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n-fn codegen_backend_stamp(builder: &Builder,\n+fn codegen_backend_stamp(builder: &Builder<'_>,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Codegen, target)\n         .join(format!(\".librustc_codegen_llvm-{}.stamp\", backend))\n }\n \n-pub fn compiler_file(builder: &Builder,\n-                 compiler: &Path,\n-                 target: Interned<String>,\n-                 file: &str) -> PathBuf {\n+pub fn compiler_file(\n+    builder: &Builder<'_>,\n+    compiler: &Path,\n+    target: Interned<String>,\n+    file: &str,\n+) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n     cmd.args(builder.cflags(target, GitRepo::Rustc));\n     cmd.arg(format!(\"-print-file-name={}\", file));\n@@ -856,7 +875,7 @@ pub struct Sysroot {\n impl Step for Sysroot {\n     type Output = Interned<PathBuf>;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -866,7 +885,7 @@ impl Step for Sysroot {\n     /// That is, the sysroot for the stage0 compiler is not what the compiler\n     /// thinks it is by default, but it's the same as the default for stages\n     /// 1-3.\n-    fn run(self, builder: &Builder) -> Interned<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n             builder.out.join(&compiler.host).join(\"stage0-sysroot\")\n@@ -891,7 +910,7 @@ pub struct Assemble {\n impl Step for Assemble {\n     type Output = Compiler;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -900,7 +919,7 @@ impl Step for Assemble {\n     /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n     /// must have been previously produced by the `stage - 1` builder.build\n     /// compiler.\n-    fn run(self, builder: &Builder) -> Compiler {\n+    fn run(self, builder: &Builder<'_>) -> Compiler {\n         let target_compiler = self.target_compiler;\n \n         if target_compiler.stage == 0 {\n@@ -996,14 +1015,14 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(builder: &Builder, sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(builder: &Builder<'_>, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     for path in builder.read_stamp_file(stamp) {\n         builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n-pub fn run_cargo(builder: &Builder,\n+pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: &mut Command,\n                  stamp: &Path,\n                  is_check: bool)\n@@ -1150,9 +1169,9 @@ pub fn run_cargo(builder: &Builder,\n }\n \n pub fn stream_cargo(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     cargo: &mut Command,\n-    cb: &mut dyn FnMut(CargoMessage),\n+    cb: &mut dyn FnMut(CargoMessage<'_>),\n ) -> bool {\n     if builder.config.dry_run {\n         return true;\n@@ -1174,7 +1193,7 @@ pub fn stream_cargo(\n     let stdout = BufReader::new(child.stdout.take().unwrap());\n     for line in stdout.lines() {\n         let line = t!(line);\n-        match serde_json::from_str::<CargoMessage>(&line) {\n+        match serde_json::from_str::<CargoMessage<'_>>(&line) {\n             Ok(msg) => cb(msg),\n             // If this was informational, just print it out and continue\n             Err(_) => println!(\"{}\", line)"}, {"sha": "2dae3f9135d8448a2d9a598b0adc430aa825cb4d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -25,7 +25,7 @@ use crate::tool::{self, Tool};\n use crate::cache::{INTERNER, Interned};\n use time::{self, Timespec};\n \n-pub fn pkgname(builder: &Builder, component: &str) -> String {\n+pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n     if component == \"cargo\" {\n         format!(\"{}-{}\", component, builder.cargo_package_vers())\n     } else if component == \"rls\" {\n@@ -46,15 +46,15 @@ pub fn pkgname(builder: &Builder, component: &str) -> String {\n     }\n }\n \n-fn distdir(builder: &Builder) -> PathBuf {\n+fn distdir(builder: &Builder<'_>) -> PathBuf {\n     builder.out.join(\"dist\")\n }\n \n-pub fn tmpdir(builder: &Builder) -> PathBuf {\n+pub fn tmpdir(builder: &Builder<'_>) -> PathBuf {\n     builder.out.join(\"tmp/dist\")\n }\n \n-fn rust_installer(builder: &Builder) -> Command {\n+fn rust_installer(builder: &Builder<'_>) -> Command {\n     builder.tool_cmd(Tool::RustInstaller)\n }\n \n@@ -76,19 +76,19 @@ impl Step for Docs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/doc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Docs {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Builds the `rust-docs` installer component.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let host = self.host;\n \n         let name = pkgname(builder, \"rust-docs\");\n@@ -138,19 +138,19 @@ impl Step for RustcDocs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/librustc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcDocs {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Builds the `rustc-docs` installer component.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let host = self.host;\n \n         let name = pkgname(builder, \"rustc-docs\");\n@@ -210,7 +210,7 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n }\n \n fn make_win_dist(\n-    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder\n+    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder<'_>\n ) {\n     //Ask gcc where it keeps its stuff\n     let mut cmd = Command::new(builder.cc(target_triple));\n@@ -334,19 +334,19 @@ impl Step for Mingw {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Mingw { host: run.target });\n     }\n \n     /// Builds the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let host = self.host;\n \n         if !host.contains(\"pc-windows-gnu\") {\n@@ -392,18 +392,18 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/librustc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             compiler: run.builder.compiler(run.builder.top_stage, run.target),\n         });\n     }\n \n     /// Creates the `rustc` installer component.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n@@ -470,7 +470,7 @@ impl Step for Rustc {\n \n         return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n \n-        fn prepare_image(builder: &Builder, compiler: Compiler, image: &Path) {\n+        fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n             let src = builder.sysroot(compiler);\n             let libdir = libdir(&host);\n@@ -580,19 +580,19 @@ pub struct DebuggerScripts {\n impl Step for DebuggerScripts {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/lldb_batchmode.py\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(DebuggerScripts {\n             sysroot: run.builder.sysroot(run.builder.compiler(run.builder.top_stage, run.host)),\n             host: run.target,\n         });\n     }\n \n     /// Copies debugger scripts for `target` into the `sysroot` specified.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let host = self.host;\n         let sysroot = self.sysroot;\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n@@ -639,18 +639,18 @@ impl Step for Std {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/libstd\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -728,20 +728,20 @@ impl Step for Analysis {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"analysis\").default_condition(builder.config.extended)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Analysis {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -791,7 +791,7 @@ impl Step for Analysis {\n     }\n }\n \n-fn copy_src_dirs(builder: &Builder, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n+fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n     fn filter_fn(exclude_dirs: &[&str], dir: &str, path: &Path) -> bool {\n         let spath = match path.to_str() {\n             Some(path) => path,\n@@ -861,16 +861,16 @@ impl Step for Src {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Src);\n     }\n \n     /// Creates the `rust-src` installer component\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         builder.info(\"Dist src\");\n \n         let name = pkgname(builder, \"rust-src\");\n@@ -941,17 +941,17 @@ impl Step for PlainSourceTarball {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src\").default_condition(builder.config.rust_dist_src)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(PlainSourceTarball);\n     }\n \n     /// Creates the plain source tarball\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         builder.info(\"Create plain source tarball\");\n \n         // Make sure that the root folder of tarball has the correct name\n@@ -1069,18 +1069,18 @@ impl Step for Cargo {\n     type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"cargo\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let stage = self.stage;\n         let target = self.target;\n \n@@ -1155,18 +1155,18 @@ impl Step for Rls {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"rls\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1234,18 +1234,18 @@ impl Step for Clippy {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"clippy\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1318,18 +1318,18 @@ impl Step for Miri {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"miri\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1402,18 +1402,18 @@ impl Step for Rustfmt {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"rustfmt\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n \n@@ -1485,12 +1485,12 @@ impl Step for Extended {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"extended\").default_condition(builder.config.extended)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n             host: run.builder.config.build,\n@@ -1499,7 +1499,7 @@ impl Step for Extended {\n     }\n \n     /// Creates a combined installer for the specified target in the provided stage.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n \n@@ -1949,7 +1949,7 @@ impl Step for Extended {\n     }\n }\n \n-fn add_env(builder: &Builder, cmd: &mut Command, target: Interned<String>) {\n+fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n     cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n@@ -1985,15 +1985,15 @@ impl Step for HashSign {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"hash-and-sign\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(HashSign);\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         if builder.config.dry_run {\n             return;\n@@ -2037,7 +2037,7 @@ impl Step for HashSign {\n // LLVM tools are linked dynamically.\n // Note: This function does no yet support Windows but we also don't support\n //       linking LLVM tools dynamically on Windows yet.\n-pub fn maybe_install_llvm_dylib(builder: &Builder,\n+pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n                                 target: Interned<String>,\n                                 sysroot: &Path) {\n     let src_libdir = builder\n@@ -2079,18 +2079,18 @@ impl Step for LlvmTools {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"llvm-tools\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(LlvmTools {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -2163,17 +2163,17 @@ impl Step for Lldb {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/llvm-project/lldb\").path(\"src/tools/lldb\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Lldb {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let target = self.target;\n \n         if builder.config.dry_run {"}, {"sha": "40f0e5ede8bd7ce41a90d8265024d237ae383910", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -34,18 +34,18 @@ macro_rules! book {\n             type Output = ();\n             const DEFAULT: bool = true;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n                 run.path($path).default_condition(builder.config.docs)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     target: run.target,\n                 });\n             }\n \n-            fn run(self, builder: &Builder) {\n+            fn run(self, builder: &Builder<'_>) {\n                 builder.ensure(Rustbook {\n                     target: self.target,\n                     name: INTERNER.intern_str($book_name),\n@@ -87,15 +87,15 @@ impl Step for Rustbook {\n \n     // rustbook is never directly called, and only serves as a shim for the nomicon and the\n     // reference.\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Invoke `rustbook` for `target` for the doc book `name`.\n     ///\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let src = builder.src.join(\"src/doc\");\n         builder.ensure(RustbookSrc {\n             target: self.target,\n@@ -115,18 +115,18 @@ impl Step for UnstableBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/doc/unstable-book\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(UnstableBook {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(UnstableBookGen {\n             target: self.target,\n         });\n@@ -149,19 +149,19 @@ impl Step for CargoBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(CargoBook {\n             target: run.target,\n             name: INTERNER.intern_str(\"cargo\"),\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let name = self.name;\n         let src = builder.src.join(\"src/tools/cargo/src/doc\");\n@@ -194,15 +194,15 @@ struct RustbookSrc {\n impl Step for RustbookSrc {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n     ///\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let name = self.name;\n         let src = self.src;\n@@ -246,12 +246,12 @@ impl Step for TheBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/doc/book\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(TheBook {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n@@ -268,7 +268,7 @@ impl Step for TheBook {\n     /// * Version info and CSS\n     /// * Index page\n     /// * Redirect pages\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let name = self.name;\n@@ -321,7 +321,12 @@ impl Step for TheBook {\n     }\n }\n \n-fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String>, markdown: &str) {\n+fn invoke_rustdoc(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    markdown: &str,\n+) {\n     let out = builder.doc_out(target);\n \n     let path = builder.src.join(\"src/doc\").join(markdown);\n@@ -358,12 +363,12 @@ impl Step for Standalone {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/doc\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Standalone {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n@@ -378,7 +383,7 @@ impl Step for Standalone {\n     /// `STAMP` along with providing the various header/footer HTML we've customized.\n     ///\n     /// In the end, this is just a glorified wrapper around rustdoc!\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = self.compiler;\n         builder.info(&format!(\"Documenting standalone ({})\", target));\n@@ -452,12 +457,12 @@ impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.all_krates(\"std\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             stage: run.builder.top_stage,\n             target: run.target\n@@ -468,7 +473,7 @@ impl Step for Std {\n     ///\n     /// This will generate all documentation for the standard library and its\n     /// dependencies. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n@@ -539,12 +544,12 @@ impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.krate(\"test\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Test {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -555,7 +560,7 @@ impl Step for Test {\n     ///\n     /// This will generate all documentation for libtest and its dependencies. This\n     /// is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n@@ -602,12 +607,12 @@ impl Step for WhitelistedRustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(WhitelistedRustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -623,7 +628,7 @@ impl Step for WhitelistedRustc {\n     /// documentation. We don't build other compiler documentation\n     /// here as we want to be able to keep it separate from the standard\n     /// documentation. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n@@ -674,12 +679,12 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -692,7 +697,7 @@ impl Step for Rustc {\n     /// Compiler documentation is distributed separately, so we make sure\n     /// we do not merge it with the other documentation from std, test and\n     /// proc_macros. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n@@ -750,7 +755,7 @@ impl Step for Rustc {\n }\n \n fn find_compiler_crates(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     name: &Interned<String>,\n     crates: &mut HashSet<Interned<String>>\n ) {\n@@ -776,11 +781,11 @@ impl Step for Rustdoc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.krate(\"rustdoc-tool\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -793,7 +798,7 @@ impl Step for Rustdoc {\n     /// Compiler documentation is distributed separately, so we make sure\n     /// we do not merge it with the other documentation from std, test and\n     /// proc_macros. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} rustdoc ({})\", stage, target));\n@@ -859,20 +864,20 @@ impl Step for ErrorIndex {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/error_index_generator\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(ErrorIndex {\n             target: run.target,\n         });\n     }\n \n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n \n         builder.info(&format!(\"Documenting error index ({})\", target));\n@@ -900,18 +905,18 @@ impl Step for UnstableBookGen {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/unstable-book-gen\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(UnstableBookGen {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n \n         builder.ensure(compile::Std {"}, {"sha": "2d040d60e5fd7d2aa7e3af14e70b3f57c05cb4ff", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -14,45 +14,45 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n use crate::config::Config;\n \n-pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_docs(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n }\n \n-pub fn install_std(builder: &Builder, stage: u32, target: Interned<String>) {\n+pub fn install_std(builder: &Builder<'_>, stage: u32, target: Interned<String>) {\n     install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n }\n \n-pub fn install_cargo(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n }\n \n-pub fn install_rls(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_rls(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n-pub fn install_clippy(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n }\n-pub fn install_miri(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_miri(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"miri\", \"miri\", stage, Some(host));\n }\n \n-pub fn install_rustfmt(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n }\n \n-pub fn install_analysis(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n }\n \n-pub fn install_src(builder: &Builder, stage: u32) {\n+pub fn install_src(builder: &Builder<'_>, stage: u32) {\n     install_sh(builder, \"src\", \"rust-src\", stage, None);\n }\n-pub fn install_rustc(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n }\n \n fn install_sh(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     package: &str,\n     name: &str,\n     stage: u32,\n@@ -155,7 +155,7 @@ macro_rules! install {\n             }\n \n             #[allow(dead_code)]\n-            fn should_install(builder: &Builder) -> bool {\n+            fn should_install(builder: &Builder<'_>) -> bool {\n                 builder.config.tools.as_ref().map_or(false, |t| t.contains($path))\n             }\n         }\n@@ -166,20 +166,20 @@ macro_rules! install {\n             const ONLY_HOSTS: bool = $only_hosts;\n             $(const $c: bool = true;)*\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let $_config = &run.builder.config;\n                 run.path($path).default_condition($default_cond)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     stage: run.builder.top_stage,\n                     target: run.target,\n                     host: run.builder.config.build,\n                 });\n             }\n \n-            fn run($sel, $builder: &Builder) {\n+            fn run($sel, $builder: &Builder<'_>) {\n                 $run_item\n             }\n         })+\n@@ -262,20 +262,20 @@ impl Step for Src {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let config = &run.builder.config;\n         let cond = config.extended &&\n             config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n         run.path(\"src\").default_condition(cond)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Src {\n             stage: run.builder.top_stage,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(dist::Src);\n         install_src(builder, self.stage);\n     }"}, {"sha": "84e2c5aab54a33bfb4926c865512eb3d36e95f60", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -103,7 +103,7 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(bare_trait_objects)]\n+#![deny(rust_2018_idioms)]\n #![deny(warnings)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n@@ -164,8 +164,6 @@ mod job;\n \n #[cfg(all(unix, not(target_os = \"haiku\")))]\n mod job {\n-    use libc;\n-\n     pub unsafe fn setup(build: &mut crate::Build) {\n         if build.config.low_priority {\n             libc::setpriority(libc::PRIO_PGRP as _, 0, 10);"}, {"sha": "192b1cd1fbb756bd68b726c56132f2363d73d149", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -35,14 +35,14 @@ impl Step for Llvm {\n \n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/llvm-project\")\n             .path(\"src/llvm-project/llvm\")\n             .path(\"src/llvm\")\n             .path(\"src/llvm-emscripten\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n@@ -51,7 +51,7 @@ impl Step for Llvm {\n     }\n \n     /// Compile LLVM for `target`.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n         let emscripten = self.emscripten;\n \n@@ -261,7 +261,7 @@ impl Step for Llvm {\n     }\n }\n \n-fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n+fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     if !builder.config.llvm_version_check {\n         return\n     }\n@@ -282,7 +282,7 @@ fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=6.0\\n\\n\", version)\n }\n \n-fn configure_cmake(builder: &Builder,\n+fn configure_cmake(builder: &Builder<'_>,\n                    target: Interned<String>,\n                    cfg: &mut cmake::Config) {\n     if builder.config.ninja {\n@@ -417,16 +417,16 @@ impl Step for Lld {\n     type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/llvm-project/lld\").path(\"src/tools/lld\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Lld { target: run.target });\n     }\n \n     /// Compile LLVM for `target`.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         if builder.config.dry_run {\n             return PathBuf::from(\"lld-out-dir-test-gen\");\n         }\n@@ -489,17 +489,17 @@ pub struct TestHelpers {\n impl Step for TestHelpers {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/test/auxiliary/rust_test_helpers.c\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(TestHelpers { target: run.target })\n     }\n \n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         if builder.config.dry_run {\n             return;\n         }"}, {"sha": "51412f79c3d0c85789ac2dddffc172339c716338", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -57,15 +57,15 @@ impl TestKind {\n }\n \n impl fmt::Display for TestKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(match *self {\n             TestKind::Test => \"Testing\",\n             TestKind::Bench => \"Benchmarking\",\n         })\n     }\n }\n \n-fn try_run(builder: &Builder, cmd: &mut Command) -> bool {\n+fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     if !builder.fail_fast {\n         if !builder.try_run(cmd) {\n             let mut failures = builder.delayed_failures.borrow_mut();\n@@ -78,7 +78,7 @@ fn try_run(builder: &Builder, cmd: &mut Command) -> bool {\n     true\n }\n \n-fn try_run_quiet(builder: &Builder, cmd: &mut Command) -> bool {\n+fn try_run_quiet(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     if !builder.fail_fast {\n         if !builder.try_run_quiet(cmd) {\n             let mut failures = builder.delayed_failures.borrow_mut();\n@@ -105,7 +105,7 @@ impl Step for Linkcheck {\n     ///\n     /// This tool in `src/tools` will verify the validity of all our links in the\n     /// documentation to ensure we don't have a bunch of dead ones.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let host = self.host;\n \n         builder.info(&format!(\"Linkcheck ({})\", host));\n@@ -121,13 +121,13 @@ impl Step for Linkcheck {\n         );\n     }\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/linkchecker\")\n             .default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Linkcheck { host: run.target });\n     }\n }\n@@ -142,11 +142,11 @@ impl Step for Cargotest {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/cargotest\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargotest {\n             stage: run.builder.top_stage,\n             host: run.target,\n@@ -157,7 +157,7 @@ impl Step for Cargotest {\n     ///\n     /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n     /// test` to ensure that we don't regress the test suites there.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc {\n             compiler,\n@@ -192,19 +192,19 @@ impl Step for Cargo {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/cargo\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for `cargo` packaged with Rust.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n \n         builder.ensure(tool::Cargo {\n@@ -247,19 +247,19 @@ impl Step for Rls {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rls\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for the rls.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -303,19 +303,19 @@ impl Step for Rustfmt {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustfmt\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for rustfmt.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -362,20 +362,20 @@ impl Step for Miri {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let test_miri = run.builder.config.test_miri;\n         run.path(\"src/tools/miri\").default_condition(test_miri)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for miri.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -421,19 +421,19 @@ pub struct CompiletestTest {\n impl Step for CompiletestTest {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/compiletest\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(CompiletestTest {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for compiletest.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -462,19 +462,19 @@ impl Step for Clippy {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = false;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/clippy\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for clippy.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -516,7 +516,7 @@ impl Step for Clippy {\n     }\n }\n \n-fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n+fn path_for_cargo(builder: &Builder<'_>, compiler: Compiler) -> OsString {\n     // Configure PATH to find the right rustc. NB. we have to use PATH\n     // and not RUSTC because the Cargo test suite has tests that will\n     // fail if rustc is not spelled `rustc`.\n@@ -535,17 +535,17 @@ impl Step for RustdocTheme {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustdoc-themes\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n         run.builder.ensure(RustdocTheme { compiler });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n         let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n         cmd.arg(rustdoc.to_str().unwrap())\n@@ -584,18 +584,18 @@ impl Step for RustdocJS {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/test/rustdoc-js\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustdocJS {\n             host: run.host,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n             command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n@@ -624,11 +624,11 @@ impl Step for RustdocUi {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/test/rustdoc-ui\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n         run.builder.ensure(RustdocUi {\n             host: run.host,\n@@ -637,7 +637,7 @@ impl Step for RustdocUi {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Compiletest {\n             compiler: self.compiler,\n             target: self.target,\n@@ -662,7 +662,7 @@ impl Step for Tidy {\n     /// This tool in `src/tools` checks up on various bits and pieces of style and\n     /// otherwise just implements a few lint-like checks that are specific to the\n     /// compiler itself.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(&builder.initial_cargo);\n@@ -678,16 +678,16 @@ impl Step for Tidy {\n         try_run(builder, &mut cmd);\n     }\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/tidy\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Tidy);\n     }\n }\n \n-fn testdir(builder: &Builder, host: Interned<String>) -> PathBuf {\n+fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n     builder.out.join(host).join(\"test\")\n }\n \n@@ -747,11 +747,11 @@ macro_rules! test_definitions {\n             const DEFAULT: bool = $default;\n             const ONLY_HOSTS: bool = $host;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.suite_path($path)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n                 run.builder.ensure($name {\n@@ -760,7 +760,7 @@ macro_rules! test_definitions {\n                 });\n             }\n \n-            fn run(self, builder: &Builder) {\n+            fn run(self, builder: &Builder<'_>) {\n                 builder.ensure(Compiletest {\n                     compiler: self.compiler,\n                     target: self.target,\n@@ -908,7 +908,7 @@ struct Compiletest {\n impl Step for Compiletest {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -917,7 +917,7 @@ impl Step for Compiletest {\n     /// Compiles all tests with `compiler` for `target` with the specified\n     /// compiletest `mode` and `suite` arguments. For example `mode` can be\n     /// \"run-pass\" or `suite` can be something like `debuginfo`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n@@ -1284,7 +1284,7 @@ impl Step for DocTest {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -1293,7 +1293,7 @@ impl Step for DocTest {\n     /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n     /// `compiler`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Test {\n@@ -1354,17 +1354,17 @@ macro_rules! test_book {\n                 const DEFAULT: bool = $default;\n                 const ONLY_HOSTS: bool = true;\n \n-                fn should_run(run: ShouldRun) -> ShouldRun {\n+                fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                     run.path($path)\n                 }\n \n-                fn make_run(run: RunConfig) {\n+                fn make_run(run: RunConfig<'_>) {\n                     run.builder.ensure($name {\n                         compiler: run.builder.compiler(run.builder.top_stage, run.host),\n                     });\n                 }\n \n-                fn run(self, builder: &Builder) {\n+                fn run(self, builder: &Builder<'_>) {\n                     builder.ensure(DocTest {\n                         compiler: self.compiler,\n                         path: $path,\n@@ -1398,11 +1398,11 @@ impl Step for ErrorIndex {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/error_index_generator\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(ErrorIndex {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n         });\n@@ -1414,7 +1414,7 @@ impl Step for ErrorIndex {\n     /// The `error_index_generator` tool lives in `src/tools` and is used to\n     /// generate a markdown file from the error indexes of the code base which is\n     /// then passed to `rustdoc --test`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Std {\n@@ -1440,7 +1440,7 @@ impl Step for ErrorIndex {\n     }\n }\n \n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n+fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) -> bool {\n     match fs::read_to_string(markdown) {\n         Ok(contents) => {\n             if !contents.contains(\"```\") {\n@@ -1480,11 +1480,11 @@ impl Step for CrateLibrustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.krate(\"rustc-main\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n@@ -1502,7 +1502,7 @@ impl Step for CrateLibrustc {\n         }\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n@@ -1524,14 +1524,14 @@ pub struct CrateNotDefault {\n impl Step for CrateNotDefault {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/librustc_asan\")\n             .path(\"src/librustc_lsan\")\n             .path(\"src/librustc_msan\")\n             .path(\"src/librustc_tsan\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n@@ -1551,7 +1551,7 @@ impl Step for CrateNotDefault {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n@@ -1575,7 +1575,7 @@ impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run = run.krate(\"test\");\n         for krate in run.builder.in_tree_crates(\"std\") {\n@@ -1586,7 +1586,7 @@ impl Step for Crate {\n         run\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n@@ -1622,7 +1622,7 @@ impl Step for Crate {\n     ///\n     /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n     /// arguments, and those arguments are discovered from `cargo metadata`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n@@ -1763,11 +1763,11 @@ impl Step for CrateRustdoc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.paths(&[\"src/librustdoc\", \"src/tools/rustdoc\"])\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n \n         let test_kind = builder.kind.into();\n@@ -1778,7 +1778,7 @@ impl Step for CrateRustdoc {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let test_kind = self.test_kind;\n \n         let compiler = builder.compiler(builder.top_stage, self.host);\n@@ -1846,11 +1846,11 @@ pub struct RemoteCopyLibs {\n impl Step for RemoteCopyLibs {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         if !builder.remote_tested(target) {\n@@ -1896,16 +1896,16 @@ pub struct Distcheck;\n impl Step for Distcheck {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"distcheck\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Distcheck);\n     }\n \n     /// Runs \"distcheck\", a 'make check' from a tarball\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.info(\"Distcheck\");\n         let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n@@ -1966,7 +1966,7 @@ impl Step for Bootstrap {\n     const ONLY_HOSTS: bool = true;\n \n     /// Tests the build system itself.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")\n             .current_dir(builder.src.join(\"src/bootstrap\"))\n@@ -1990,11 +1990,11 @@ impl Step for Bootstrap {\n         try_run(builder, &mut cmd);\n     }\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/bootstrap\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Bootstrap);\n     }\n }"}, {"sha": "fc1a17d54667540c7c5681f8866124721dd76720", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -36,15 +36,15 @@ struct ToolBuild {\n impl Step for ToolBuild {\n     type Output = Option<PathBuf>;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Builds a tool in `src/tools`\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let compiler = self.compiler;\n         let target = self.target;\n         let tool = self.tool;\n@@ -192,7 +192,7 @@ impl Step for ToolBuild {\n }\n \n pub fn prepare_tool_cargo(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     compiler: Compiler,\n     mode: Mode,\n     target: Interned<String>,\n@@ -315,18 +315,18 @@ macro_rules! tool {\n         impl Step for $name {\n             type Output = PathBuf;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.path($path)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n                 });\n             }\n \n-            fn run(self, builder: &Builder) -> PathBuf {\n+            fn run(self, builder: &Builder<'_>) -> PathBuf {\n                 builder.ensure(ToolBuild {\n                     compiler: self.compiler,\n                     target: self.target,\n@@ -371,18 +371,18 @@ pub struct RemoteTestServer {\n impl Step for RemoteTestServer {\n     type Output = PathBuf;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/remote-test-server\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RemoteTestServer {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -406,17 +406,17 @@ impl Step for Rustdoc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustdoc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n             host: run.host,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target_compiler = builder.compiler(builder.top_stage, self.host);\n         if target_compiler.stage == 0 {\n             if !target_compiler.is_snapshot(builder) {\n@@ -490,19 +490,19 @@ impl Step for Cargo {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/cargo\").default_condition(builder.config.extended)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         // Cargo depends on procedural macros, which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n@@ -542,12 +542,12 @@ macro_rules! tool_extended {\n             const DEFAULT: bool = true;\n             const ONLY_HOSTS: bool = true;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n                 run.path($path).default_condition(builder.config.extended)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n@@ -556,7 +556,7 @@ macro_rules! tool_extended {\n             }\n \n             #[allow(unused_mut)]\n-            fn run(mut $sel, $builder: &Builder) -> Option<PathBuf> {\n+            fn run(mut $sel, $builder: &Builder<'_>) -> Option<PathBuf> {\n                 $extra_deps\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,"}, {"sha": "bda1e56e1e73b124788dab30944f6cacc9a011d0", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6de1e9714b58298a688026470aeeffcf3645314/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=d6de1e9714b58298a688026470aeeffcf3645314", "patch": "@@ -95,7 +95,7 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit(builder: &Builder) -> TimeIt {\n+pub fn timeit(builder: &Builder<'_>) -> TimeIt {\n     TimeIt(builder.config.dry_run, Instant::now())\n }\n "}]}