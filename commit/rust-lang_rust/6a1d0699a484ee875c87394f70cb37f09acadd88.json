{"sha": "6a1d0699a484ee875c87394f70cb37f09acadd88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMWQwNjk5YTQ4NGVlODc1Yzg3Mzk0ZjcwY2IzN2YwOWFjYWRkODg=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-26T05:05:18Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-10T03:33:33Z"}, "message": "Use Places for captures in MIR\n\n- Use closure_min_capture maps to capture precise paths\n- PlaceBuilder now searches for ancestors in min_capture list\n- Add API to `Ty` to allow access to the n-th element in a\n  tuple in O(1) time.\n\nCo-authored-by: Roxane Fruytier <roxane.fruytier@hotmail.com>", "tree": {"sha": "51c29b866e99e8877bca36ed16ba33ba6a0bf8e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c29b866e99e8877bca36ed16ba33ba6a0bf8e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a1d0699a484ee875c87394f70cb37f09acadd88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1d0699a484ee875c87394f70cb37f09acadd88", "html_url": "https://github.com/rust-lang/rust/commit/6a1d0699a484ee875c87394f70cb37f09acadd88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a1d0699a484ee875c87394f70cb37f09acadd88/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "html_url": "https://github.com/rust-lang/rust/commit/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7"}], "stats": {"total": 159, "additions": 137, "deletions": 22}, "files": [{"sha": "a90807de99d3e34b462c96ae9c3c108cceba9da5", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a1d0699a484ee875c87394f70cb37f09acadd88/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1d0699a484ee875c87394f70cb37f09acadd88/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6a1d0699a484ee875c87394f70cb37f09acadd88", "patch": "@@ -2174,6 +2174,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Get the `i`-th element of a tuple.\n+    /// Panics when called on anything but a tuple.\n+    pub fn tuple_element_ty(&self, i: usize) -> Option<Ty<'tcx>> {\n+        match self.kind() {\n+            Tuple(substs) => substs.iter().nth(i).map(|field| field.expect_ty()),\n+            _ => bug!(\"tuple_fields called on non-tuple\"),\n+        }\n+    }\n+\n     /// If the type contains variants, returns the valid range of variant indices.\n     //\n     // FIXME: This requires the optimized MIR in the case of generators."}, {"sha": "b3957fa7222766ece9a4c00a0420fee75939aea5", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 128, "deletions": 22, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6a1d0699a484ee875c87394f70cb37f09acadd88/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1d0699a484ee875c87394f70cb37f09acadd88/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=6a1d0699a484ee875c87394f70cb37f09acadd88", "patch": "@@ -7,10 +7,12 @@ use crate::thir::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::middle::region;\n+use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n@@ -70,28 +72,129 @@ struct PlaceBuilder<'tcx> {\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n-fn capture_matching_projections<'a, 'tcx>(\n+/// Given a list of MIR projections, convert them to list of HIR ProjectionKind.\n+/// The projections are truncated to represent a path that might be captured by a\n+/// closure/generator. This implies the vector returned from this function doesn't contain\n+/// ProjectionElems `Downcast`, `ConstantIndex`, `Index`, or `Subslice` because those will never be\n+/// part of a path that is captued by a closure. We stop applying projections once we see the first\n+/// projection that isn't captured by a closure.\n+fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n+    mir_projections: &Vec<PlaceElem<'tcx>>,\n+) -> Vec<HirProjectionKind> {\n+\n+    let mut hir_projections  = Vec::new();\n+\n+    for mir_projection in mir_projections {\n+        let hir_projection = match mir_projection {\n+            ProjectionElem::Deref => HirProjectionKind::Deref,\n+            ProjectionElem::Field(field, _) => {\n+                // We will never encouter this for multivariant enums,\n+                // read the comment for `Downcast`.\n+                HirProjectionKind::Field(field.index() as u32, VariantIdx::new(0))\n+            },\n+            ProjectionElem::Downcast(..) => {\n+                // This projections exist only for enums that have\n+                // multiple variants. Since such enums that are captured\n+                // completely, we can stop here.\n+                break\n+            },\n+            ProjectionElem::Index(..)\n+            | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. } => {\n+                // We don't capture array-access projections.\n+                // We can stop here as arrays are captured completely.\n+                break\n+            },\n+        };\n+\n+        hir_projections.push(hir_projection);\n+    }\n+\n+    hir_projections\n+}\n+\n+/// Return true if the `proj_possible_ancestor` represents an ancestor path\n+/// to `proj_capture` or `proj_possible_ancestor` is same as `proj_capture`,\n+/// assuming they both start off of the same root variable.\n+///\n+/// **Note:** It's the caller's responsibility to ensure that both lists of projections\n+///           start off of the same root variable.\n+///\n+/// Eg: 1. `foo.x` which is represented using `projections=[Field(x)]` is an ancestor of\n+///        `foo.x.y` which is represented using `projections=[Field(x), Field(y)]`.\n+///        Note both `foo.x` and `foo.x.y` start off of the same root variable `foo`.\n+///     2. Since we only look at the projections here function will return `bar.x` as an a valid\n+///        ancestor of `foo.x.y`. It's the caller's responsibility to ensure that both projections\n+///        list are being applied to the same root variable.\n+fn is_ancestor_or_same_capture(\n+    proj_possible_ancestor: &Vec<HirProjectionKind>,\n+    proj_capture: &Vec<HirProjectionKind>,\n+) -> bool {\n+    // We want to make sure `is_ancestor_or_same_capture(\"x.0.0\", \"x.0\")` to return false.\n+    // Therefore we can't just check if all projections are same in the zipped iterator below.\n+    if proj_possible_ancestor.len() > proj_capture.len() {\n+        return false;\n+    }\n+\n+    proj_possible_ancestor.iter().zip(proj_capture).all(|(a, b)| a == b)\n+}\n+\n+/// Computes the index of a capture within the desugared closure provided the closure's\n+/// `closure_min_captures` and the capture's index of the capture in the\n+/// `ty::MinCaptureList` of the root variable `var_hir_id`.\n+fn compute_capture_idx<'tcx>(\n+    closure_min_captures: &ty::RootVariableMinCaptureList<'tcx>,\n+    var_hir_id: HirId,\n+    root_var_idx: usize,\n+) -> usize {\n+    let mut res = 0;\n+    for (var_id, capture_list) in closure_min_captures {\n+        if *var_id == var_hir_id {\n+            res += root_var_idx;\n+            break;\n+        } else {\n+            res += capture_list.len();\n+        }\n+    }\n+\n+    res\n+}\n+\n+/// Given a closure, returns the index of a capture within the desugared closure struct and the\n+/// `ty::CapturedPlace` which is the ancestor of the Place represented using the `var_hir_id`\n+/// and `projection`.\n+///\n+/// Note there will be at most one ancestor for any given Place.\n+///\n+/// Returns None, when the ancestor is not found.\n+fn find_capture_matching_projections<'a, 'tcx>(\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     var_hir_id: HirId,\n     closure_def_id: DefId,\n-    _projections: &Vec<PlaceElem<'tcx>>,\n-) -> Option<(usize, ty::UpvarCapture<'tcx>)> {\n-    typeck_results\n-    .closure_captures\n-    .get(&closure_def_id)\n-    .and_then(|captures| captures.get_full(&var_hir_id))\n-    .and_then(|(capture_index, _, _)|{\n-        let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n-        let capture_kind = typeck_results.upvar_capture(upvar_id);\n-        Some((capture_index, capture_kind))\n-    })\n+    projections: &Vec<PlaceElem<'tcx>>,\n+) -> Option<(usize, &'a ty::CapturedPlace<'tcx>)> {\n+    let closure_min_captures = typeck_results.closure_min_captures.get(&closure_def_id)?;\n+    let root_variable_min_captures = closure_min_captures.get(&var_hir_id)?;\n+\n+    let hir_projections = convert_to_hir_projections_and_truncate_for_capture(projections);\n+\n+    // If an ancestor is found, `idx` is the index within the list of captured places\n+    // for root variable `var_hir_id` and `capture` is the `ty::CapturedPlace` itself.\n+    let (idx, capture) = root_variable_min_captures.iter().enumerate().find(|(_, capture)| {\n+            let possible_ancestor_proj_kinds =\n+                capture.place.projections.iter().map(|proj| proj.kind).collect();\n+            is_ancestor_or_same_capture(&possible_ancestor_proj_kinds, &hir_projections)\n+    })?;\n+\n+    // Convert index to be from the presepective of the entire closure_min_captures map\n+    // instead of just the root variable capture list\n+    Some((compute_capture_idx(closure_min_captures, var_hir_id, idx), capture))\n }\n \n-/// Takes a PlaceBuilder and resolves the upvar (if any) within it,\n-/// so that the PlaceBuilder now starts from PlaceBase::Local.\n+/// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n+/// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n-/// Returns a Result with the error being the HirId of the\n-/// Upvar that was not found.\n+/// Returns a Result with the error being the HirId of the Upvar that was not found.\n fn to_upvars_resolved_place_builder<'a, 'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n@@ -110,8 +213,8 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                 ty::ClosureKind::FnOnce => {}\n             }\n \n-            let (capture_index, capture_kind) =\n-                if let Some(capture_details) = capture_matching_projections(\n+            let (capture_index, capture) =\n+                if let Some(capture_details) = find_capture_matching_projections(\n                     typeck_results,\n                     var_hir_id,\n                     closure_def_id,\n@@ -149,21 +252,24 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             // Access the capture by accessing the field within the Closure struct.\n             //\n             // We must have inferred the capture types since we are building MIR, therefore\n-            // it's safe to call `upvar_tys` and we can unwrap here because\n+            // it's safe to call `tuple_element_ty` and we can unwrap here because\n             // we know that the capture exists and is the `capture_index`-th capture.\n-            let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n+            let var_ty = substs.tupled_upvars_ty().tuple_element_ty(capture_index).unwrap();\n \n             upvar_resolved_place_builder = upvar_resolved_place_builder.field(Field::new(capture_index), var_ty);\n \n             // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n             // we need to deref it\n-            upvar_resolved_place_builder = match capture_kind {\n+            upvar_resolved_place_builder = match capture.info.capture_kind {\n                 ty::UpvarCapture::ByRef(_) => upvar_resolved_place_builder.deref(),\n                 ty::UpvarCapture::ByValue(_) => upvar_resolved_place_builder,\n             };\n \n-            let next_projection = 0;\n+            let next_projection = capture.place.projections.len();\n             let mut curr_projections = from_builder.projection;\n+\n+            // We used some of the projections to build the capture itself,\n+            // now we apply the remaining to the upvar resolved place.\n             upvar_resolved_place_builder.projection.extend(\n                 curr_projections.drain(next_projection..));\n "}]}