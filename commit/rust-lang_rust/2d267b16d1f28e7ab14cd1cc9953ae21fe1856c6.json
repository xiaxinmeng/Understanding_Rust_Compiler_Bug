{"sha": "2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjY3YjE2ZDFmMjhlN2FiMTRjZDFjYzk5NTNhZTIxZmUxODU2YzY=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-18T15:56:13Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-22T20:30:01Z"}, "message": "Deal with floating links in chains", "tree": {"sha": "c7ead21407cabf5f8d90522045f6cbd69b8a1f9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7ead21407cabf5f8d90522045f6cbd69b8a1f9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "html_url": "https://github.com/rust-lang/rust/commit/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e2547b6bcdbac2cadfafe0d8f2795bf9fa1c4da", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e2547b6bcdbac2cadfafe0d8f2795bf9fa1c4da", "html_url": "https://github.com/rust-lang/rust/commit/8e2547b6bcdbac2cadfafe0d8f2795bf9fa1c4da"}], "stats": {"total": 221, "additions": 211, "deletions": 10}, "files": [{"sha": "4b6824a9073380d1353c8ccd38fd2b4883f5f56b", "filename": "src/chains.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "patch": "@@ -23,6 +23,7 @@ use Indent;\n use rewrite::{Rewrite, RewriteContext};\n use utils::first_line_width;\n use expr::rewrite_call;\n+use config::BlockIndentStyle;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n@@ -41,17 +42,24 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n         expr = subexpr;\n     }\n \n+    let parent_block_indent = match context.config.chain_base_indent {\n+        BlockIndentStyle::Visual => offset,\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+    };\n+    let parent_context = &RewriteContext { block_indent: parent_block_indent, ..*context };\n     let parent = subexpr_list.pop().unwrap();\n-    let parent_rewrite = try_opt!(expr.rewrite(context, width, offset));\n-    let (extra_indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n-                                    parent_rewrite.len() <= context.config.tab_spaces {\n-        (Indent::new(0, parent_rewrite.len()), true)\n+    let parent_rewrite = try_opt!(expr.rewrite(parent_context, width, offset));\n+    let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n+                              parent_rewrite.len() <= context.config.tab_spaces {\n+        (offset + Indent::new(0, parent_rewrite.len()), true)\n+    } else if is_block_expr(parent, &parent_rewrite) {\n+        (parent_block_indent, false)\n     } else {\n-        (Indent::new(context.config.tab_spaces, 0), false)\n+        (offset + Indent::new(context.config.tab_spaces, 0), false)\n     };\n-    let indent = offset + extra_indent;\n \n-    let max_width = try_opt!(width.checked_sub(extra_indent.width()));\n+    let max_width = try_opt!((width + offset.width()).checked_sub(indent.width()));\n     let mut rewrites = try_opt!(subexpr_list.iter()\n                                             .rev()\n                                             .map(|e| {\n@@ -114,7 +122,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n         _ => total_width <= width && rewrites.iter().all(|s| !s.contains('\\n')),\n     };\n \n-    let connector = if fits_single_line {\n+    let connector = if fits_single_line && !parent_rewrite.contains('\\n') {\n         String::new()\n     } else {\n         format!(\"\\n{}\", indent.to_string(context.config))\n@@ -132,6 +140,27 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n                  rewrites.join(&connector)))\n }\n \n+// States whether an expression's last line exclusively consists of closing\n+// parens, braces and brackets in its idiomatic formatting.\n+fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n+    match expr.node {\n+        ast::Expr_::ExprStruct(..) |\n+        ast::Expr_::ExprWhile(..) |\n+        ast::Expr_::ExprWhileLet(..) |\n+        ast::Expr_::ExprIf(..) |\n+        ast::Expr_::ExprIfLet(..) |\n+        ast::Expr_::ExprBlock(..) |\n+        ast::Expr_::ExprLoop(..) |\n+        ast::Expr_::ExprForLoop(..) |\n+        ast::Expr_::ExprMatch(..) => repr.contains('\\n'),\n+        ast::Expr_::ExprParen(ref expr) |\n+        ast::Expr_::ExprBinary(_, _, ref expr) |\n+        ast::Expr_::ExprIndex(_, ref expr) |\n+        ast::Expr_::ExprUnary(_, ref expr) => is_block_expr(expr, repr),\n+        _ => false,\n+    }\n+}\n+\n fn pop_expr_chain<'a>(expr: &'a ast::Expr) -> Option<&'a ast::Expr> {\n     match expr.node {\n         ast::Expr_::ExprMethodCall(_, _, ref expressions) => {"}, {"sha": "d788b17cfe706a4a4f43645797b006689bc726ff", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "patch": "@@ -290,9 +290,10 @@ create_config! {\n         \"Multiline style on literal structs\";\n     enum_trailing_comma: bool, true, \"Put a trailing comma on enum declarations\";\n     report_todo: ReportTactic, ReportTactic::Always,\n-        \"Report all occurrences of TODO in source file comments\";\n+        \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n     report_fixme: ReportTactic, ReportTactic::Never,\n-        \"Report all occurrences of FIXME in source file comments\";\n+        \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n+    chain_base_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on chain base\";\n     // Alphabetically, case sensitive.\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n     single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";"}, {"sha": "05459dc69735da87985e06b0789b0ec7d72a1fed", "filename": "tests/source/chains-block-indented-base.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Fsource%2Fchains-block-indented-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Fsource%2Fchains-block-indented-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-block-indented-base.rs?ref=2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "patch": "@@ -0,0 +1,30 @@\n+// rustfmt-chain_base_indent: Inherit\n+// Test chain formatting with block indented base\n+\n+fn floaters() {\n+    let x = Foo {\n+                field1: val1,\n+                field2: val2,\n+            }\n+            .method_call().method_call();\n+\n+    let y = if cond {\n+                val1\n+            } else {\n+                val2\n+            }\n+                .method_call();\n+\n+    {\n+        match x {\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                                            Some(d) => d as usize - 1,\n+                                            None => return Err(\"bad param number\".to_owned()),\n+                                        }]\n+                               .clone());\n+            }\n+        }\n+    }\n+}"}, {"sha": "a50a9c5125337b0c8bcb13e66eb7de13785a81b6", "filename": "tests/source/chains.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "patch": "@@ -55,3 +55,49 @@ fn main() {\n                          x\n                      }).filter(some_mod::some_filter)\n }\n+\n+fn floaters() {\n+    let z = Foo {\n+        field1: val1,\n+        field2: val2,\n+    };\n+\n+    let x = Foo {\n+        field1: val1,\n+        field2: val2,\n+    }.method_call().method_call();\n+\n+    let y = if cond {\n+                val1\n+            } else {\n+                val2\n+            }\n+                .method_call();\n+\n+    {\n+        match x {\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                    Some(d) => d as usize - 1,\n+                    None => return Err(\"bad param number\".to_owned()),\n+                }]\n+                               .clone());\n+            }\n+        }\n+    }\n+\n+    if cond { some(); } else { none(); }\n+        .bar()\n+        .baz();\n+\n+    Foo { x: val } .baz(|| { /*force multiline    */    }) .quux(); \n+\n+    Foo { y: i_am_multi_line, z: ok }\n+        .baz(|| {\n+            // force multiline\n+        })\n+        .quux(); \n+\n+    a + match x { true => \"yay!\", false => \"boo!\" }.bar()\n+}"}, {"sha": "5b9863689de36f77e8c1c1251171d00dee9c1423", "filename": "tests/target/chains-block-indented-base.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Ftarget%2Fchains-block-indented-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Ftarget%2Fchains-block-indented-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-block-indented-base.rs?ref=2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "patch": "@@ -0,0 +1,31 @@\n+// rustfmt-chain_base_indent: Inherit\n+// Test chain formatting with block indented base\n+\n+fn floaters() {\n+    let x = Foo {\n+        field1: val1,\n+        field2: val2,\n+    }\n+    .method_call()\n+    .method_call();\n+\n+    let y = if cond {\n+        val1\n+    } else {\n+        val2\n+    }\n+    .method_call();\n+\n+    {\n+        match x {\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                    Some(d) => d as usize - 1,\n+                    None => return Err(\"bad param number\".to_owned()),\n+                }]\n+                .clone());\n+            }\n+        }\n+    }\n+}"}, {"sha": "9e195b42d6ed1d285234614325535f5d44962cc1", "filename": "tests/target/chains.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=2d267b16d1f28e7ab14cd1cc9953ae21fe1856c6", "patch": "@@ -62,3 +62,67 @@ fn main() {\n                     })\n                     .filter(some_mod::some_filter)\n }\n+\n+fn floaters() {\n+    let z = Foo {\n+        field1: val1,\n+        field2: val2,\n+    };\n+\n+    let x = Foo {\n+                field1: val1,\n+                field2: val2,\n+            }\n+            .method_call()\n+            .method_call();\n+\n+    let y = if cond {\n+                val1\n+            } else {\n+                val2\n+            }\n+            .method_call();\n+\n+    {\n+        match x {\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                               Some(d) => d as usize - 1,\n+                               None => return Err(\"bad param number\".to_owned()),\n+                           }]\n+                           .clone());\n+            }\n+        }\n+    }\n+\n+    if cond {\n+        some();\n+    } else {\n+        none();\n+    }\n+    .bar()\n+    .baz();\n+\n+    Foo { x: val }\n+        .baz(|| {\n+            // force multiline\n+        })\n+        .quux();\n+\n+    Foo {\n+        y: i_am_multi_line,\n+        z: ok,\n+    }\n+    .baz(|| {\n+        // force multiline\n+    })\n+    .quux();\n+\n+    a +\n+    match x {\n+        true => \"yay!\",\n+        false => \"boo!\",\n+    }\n+    .bar()\n+}"}]}