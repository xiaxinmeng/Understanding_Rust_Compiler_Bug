{"sha": "fd85239119ffba1c57a493603d63deed9be60521", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODUyMzkxMTlmZmJhMWM1N2E0OTM2MDNkNjNkZWVkOWJlNjA1MjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T05:09:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T05:09:27Z"}, "message": "syntax: Remove several deep copies that were happening due to misuse of parse_seq", "tree": {"sha": "b2aef04cf54cac8d4598bd0bd63c6621c4d9010d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2aef04cf54cac8d4598bd0bd63c6621c4d9010d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd85239119ffba1c57a493603d63deed9be60521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd85239119ffba1c57a493603d63deed9be60521", "html_url": "https://github.com/rust-lang/rust/commit/fd85239119ffba1c57a493603d63deed9be60521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd85239119ffba1c57a493603d63deed9be60521/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26faa37305f59e2b09a92b089b78abc4f01da8e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/26faa37305f59e2b09a92b089b78abc4f01da8e8", "html_url": "https://github.com/rust-lang/rust/commit/26faa37305f59e2b09a92b089b78abc4f01da8e8"}], "stats": {"total": 166, "additions": 90, "deletions": 76}, "files": [{"sha": "0c2718c3b4b5850a4615d2092c75699ab3fe2cc5", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd85239119ffba1c57a493603d63deed9be60521/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd85239119ffba1c57a493603d63deed9be60521/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=fd85239119ffba1c57a493603d63deed9be60521", "patch": "@@ -209,9 +209,16 @@ impl parser_common for parser {\n         ret v;\n     }\n \n-    // FIXME: A lot of callers go through here, only to copy out the T and\n-    // discard the spanned<> wrapper. I feel as though there should be a\n-    // version of this that does not return a spanned result.\n+    fn parse_unspanned_seq<T: copy>(bra: token::token, ket: token::token,\n+                                    sep: seq_sep, f: fn(parser) -> T) -> [T] {\n+        self.expect(bra);\n+        let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n+        self.bump();\n+        ret result;\n+    }\n+\n+    // NB: Do not use this function unless you actually plan to place the\n+    // spanned list in the AST.\n     fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n                           f: fn(parser) -> T) -> spanned<[T]> {\n         let lo = self.span.lo;"}, {"sha": "df27b2388e07337939d1fc078fe33dad18422b12", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/fd85239119ffba1c57a493603d63deed9be60521/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd85239119ffba1c57a493603d63deed9be60521/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fd85239119ffba1c57a493603d63deed9be60521", "patch": "@@ -150,8 +150,8 @@ class parser {\n \n     fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n         let inputs =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA)) { |p|\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA)) { |p|\n             let mode = p.parse_arg_mode();\n             let name = if is_plain_ident(p.token)\n                 && p.look_ahead(1u) == token::COLON {\n@@ -170,13 +170,14 @@ class parser {\n         // story on constrained types.\n         let constrs: [@constr] = [];\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        ret {inputs: inputs.node, output: ret_ty,\n+        ret {inputs: inputs, output: ret_ty,\n              purity: purity, cf: ret_style,\n              constraints: constrs};\n     }\n \n     fn parse_ty_methods() -> [ty_method] {\n-        (self.parse_seq(token::LBRACE, token::RBRACE, seq_sep_none()) { |p|\n+        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+                                 seq_sep_none()) { |p|\n             let attrs = p.parse_outer_attributes();\n             let flo = p.span.lo;\n             let pur = p.parse_fn_purity();\n@@ -186,7 +187,7 @@ class parser {\n             self.expect(token::SEMI);\n             {ident: ident, attrs: attrs, decl: {purity: pur with d}, tps: tps,\n              span: mk_sp(flo, fhi)}\n-        }).node\n+        }\n     }\n \n     fn parse_mt() -> mt {\n@@ -241,21 +242,21 @@ class parser {\n     fn parse_ty_constr(fn_args: [arg]) -> @constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args: {node: [@constr_arg], span: span} =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA),\n-                           {|p| p.parse_constr_arg(fn_args)});\n-        ret @spanned(lo, args.span.hi,\n-                     {path: path, args: args.node, id: self.get_id()});\n+        let args =\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA),\n+                                     {|p| p.parse_constr_arg(fn_args)});\n+        ret @spanned(lo, self.span.hi,\n+                     {path: path, args: args, id: self.get_id()});\n     }\n \n     fn parse_constr_in_type() -> @ty_constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n         let args: [@ty_constr_arg] =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA),\n-                           {|p| p.parse_type_constr_arg()}).node;\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA),\n+                                     {|p| p.parse_type_constr_arg()});\n         let hi = self.span.lo;\n         let tc: ty_constr_ = {path: path, args: args, id: self.get_id()};\n         ret @spanned(lo, hi, tc);\n@@ -370,15 +371,15 @@ class parser {\n             self.bump();\n             ty_ptr(self.parse_mt())\n         } else if self.token == token::LBRACE {\n-            let elems = self.parse_seq(token::LBRACE, token::RBRACE,\n-                                       seq_sep_opt(token::COMMA),\n-                                       {|p| p.parse_ty_field()});\n-            if vec::len(elems.node) == 0u {\n+            let elems = self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+                                                 seq_sep_opt(token::COMMA),\n+                                                 {|p| p.parse_ty_field()});\n+            if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n-            let hi = elems.span.hi;\n+            let hi = self.span.hi;\n \n-            let t = ty_rec(elems.node);\n+            let t = ty_rec(elems);\n             if self.token == token::COLON {\n                 self.bump();\n                 ty_constr(@{id: self.get_id(),\n@@ -813,11 +814,11 @@ class parser {\n             ex = ex_ext.node;\n         } else if self.eat_keyword(\"bind\") {\n             let e = self.parse_expr_res(RESTRICT_NO_CALL_EXPRS);\n-            let es = self.parse_seq(token::LPAREN, token::RPAREN,\n-                                    seq_sep(token::COMMA),\n-                                    {|p| p.parse_expr_or_hole()});\n-            hi = es.span.hi;\n-            ex = expr_bind(e, es.node);\n+            let es = self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                              seq_sep(token::COMMA),\n+                                              {|p| p.parse_expr_or_hole()});\n+            hi = self.span.hi;\n+            ex = expr_bind(e, es);\n         } else if self.eat_keyword(\"fail\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n@@ -920,37 +921,37 @@ class parser {\n         let sep = seq_sep(token::COMMA);\n         let mut e = none;\n         if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n+            let lo = self.span.lo;\n             let es =\n                 if self.token == token::LPAREN {\n-                self.parse_seq(token::LPAREN, token::RPAREN,\n-                               sep, {|p| p.parse_expr()})\n-        } else {\n-            self.parse_seq(token::LBRACKET, token::RBRACKET,\n-                           sep, {|p| p.parse_expr()})\n-        };\n-        let hi = es.span.hi;\n-        e = some(self.mk_expr(es.span.lo, hi,\n-                              expr_vec(es.node, m_imm)));\n-    }\n-    let mut b = none;\n-    if self.token == token::LBRACE {\n-        self.bump();\n-        let lo = self.span.lo;\n-        let mut depth = 1u;\n-        while (depth > 0u) {\n-            alt (self.token) {\n-              token::LBRACE {depth += 1u;}\n-              token::RBRACE {depth -= 1u;}\n-              token::EOF {self.fatal(\"unexpected EOF in macro body\");}\n-              _ {}\n-            }\n+                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                             sep, {|p| p.parse_expr()})\n+                } else {\n+                    self.parse_unspanned_seq(token::LBRACKET, token::RBRACKET,\n+                                             sep, {|p| p.parse_expr()})\n+                };\n+            let hi = self.span.hi;\n+            e = some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n+        }\n+        let mut b = none;\n+        if self.token == token::LBRACE {\n             self.bump();\n+            let lo = self.span.lo;\n+            let mut depth = 1u;\n+            while (depth > 0u) {\n+                alt (self.token) {\n+                  token::LBRACE {depth += 1u;}\n+                  token::RBRACE {depth -= 1u;}\n+                  token::EOF {self.fatal(\"unexpected EOF in macro body\");}\n+                  _ {}\n+                }\n+                self.bump();\n+            }\n+            let hi = self.last_span.lo;\n+            b = some({span: mk_sp(lo,hi)});\n         }\n-        let hi = self.last_span.lo;\n-        b = some({span: mk_sp(lo,hi)});\n+        ret self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n     }\n-    ret self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n-}\n \n     fn parse_dot_or_call_expr() -> pexpr {\n         let b = self.parse_bottom_expr();\n@@ -989,16 +990,17 @@ class parser {\n             alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n-                let es_opt = self.parse_seq(token::LPAREN, token::RPAREN,\n-                                            seq_sep(token::COMMA),\n-                                            {|p| p.parse_expr_or_hole()});\n-                hi = es_opt.span.hi;\n+                let es_opt =\n+                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                             seq_sep(token::COMMA),\n+                                             {|p| p.parse_expr_or_hole()});\n+                hi = self.span.hi;\n \n                 let nd =\n-                    if vec::any(es_opt.node, {|e| option::is_none(e) }) {\n-                    expr_bind(self.to_expr(e), es_opt.node)\n+                    if vec::any(es_opt, {|e| option::is_none(e) }) {\n+                    expr_bind(self.to_expr(e), es_opt)\n             } else {\n-                let es = vec::map(es_opt.node) {|e| option::get(e) };\n+                let es = vec::map(es_opt) {|e| option::get(e) };\n                 expr_call(self.to_expr(e), es, false)\n             };\n             e = self.mk_pexpr(lo, hi, nd);\n@@ -1458,11 +1460,12 @@ class parser {\n                         self.expect(token::RPAREN);\n                       }\n                       _ {\n-                        let a = self.parse_seq(token::LPAREN, token::RPAREN,\n-                                               seq_sep(token::COMMA),\n-                                               {|p| p.parse_pat()});\n-                        args = a.node;\n-                        hi = a.span.hi;\n+                        args =\n+                            self.parse_unspanned_seq(token::LPAREN,\n+                                                     token::RPAREN,\n+                                                     seq_sep(token::COMMA),\n+                                                     {|p| p.parse_pat()});\n+                        hi = self.span.hi;\n                       }\n                     }\n                   }\n@@ -1761,8 +1764,8 @@ class parser {\n         -> (fn_decl, capture_clause) {\n \n         let args_or_capture_items: [arg_or_capture_item] =\n-            self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA), parse_arg_fn).node;\n+            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                     seq_sep(token::COMMA), parse_arg_fn);\n \n         let inputs = either::lefts(args_or_capture_items);\n         let capture_clause = @either::rights(args_or_capture_items);\n@@ -1788,9 +1791,10 @@ class parser {\n             if self.eat(token::OROR) {\n                 []\n             } else {\n-                self.parse_seq(token::BINOP(token::OR),\n-                               token::BINOP(token::OR), seq_sep(token::COMMA),\n-                               {|p| p.parse_fn_block_arg()}).node\n+                self.parse_unspanned_seq(token::BINOP(token::OR),\n+                                         token::BINOP(token::OR),\n+                                         seq_sep(token::COMMA),\n+                                         {|p| p.parse_fn_block_arg()})\n             }\n         };\n         let output = if self.eat(token::RARROW) {\n@@ -2242,10 +2246,12 @@ class parser {\n             let mut args = [], disr_expr = none;\n             if self.token == token::LPAREN {\n                 all_nullary = false;\n-                let arg_tys = self.parse_seq(token::LPAREN, token::RPAREN,\n+                let arg_tys =\n+                    self.parse_unspanned_seq(token::LPAREN,\n+                                             token::RPAREN,\n                                              seq_sep(token::COMMA),\n                                              {|p| p.parse_ty(false)});\n-                for arg_tys.node.each {|ty|\n+                for arg_tys.each {|ty|\n                     args += [{ty: ty, id: self.get_id()}];\n                 }\n             } else if self.eat(token::EQ) {\n@@ -2385,9 +2391,10 @@ class parser {\n                   // foo::bar::{a,b,c}\n                   token::LBRACE {\n                     let idents =\n-                        self.parse_seq(token::LBRACE, token::RBRACE,\n-                                       seq_sep(token::COMMA),\n-                                       {|p| p.parse_path_list_ident()}).node;\n+                        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n+                                                 seq_sep(token::COMMA),\n+                                                 {|p|\n+                                                  p.parse_path_list_ident()});\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: []};"}]}