{"sha": "9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNjdiZDQyYjdjYmY5N2Y3MmQwMzlhZmNiYTAyZjUxNzdkMGQ2OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-01T17:24:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-01T17:24:11Z"}, "message": "Auto merge of #60435 - Centril:rollup-aa5lmuw, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #60287 (Use references for variances_of)\n - #60327 (Search for incompatible universes in borrow errors)\n - #60330 (Suggest using an inclusive range instead of an exclusive range when the endpoint overflows by 1)\n - #60366 (build-gcc: Create missing cc symlink)\n - #60369 (Support ZSTs in DispatchFromDyn)\n - #60404 (Implement `BorrowMut<str>` for `String`)\n - #60417 (Rename hir::ExprKind::Use to ::DropTemps and improve docs.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b2bf473a8d54ef27fbf5b390e0fd4f411e792c9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2bf473a8d54ef27fbf5b390e0fd4f411e792c9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "html_url": "https://github.com/rust-lang/rust/commit/9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cc24f26036b28fb3366de86efe3da6c4464057a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc24f26036b28fb3366de86efe3da6c4464057a", "html_url": "https://github.com/rust-lang/rust/commit/6cc24f26036b28fb3366de86efe3da6c4464057a"}, {"sha": "e5b69978c1137f05bf8b469875503d5f7fa7f747", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5b69978c1137f05bf8b469875503d5f7fa7f747", "html_url": "https://github.com/rust-lang/rust/commit/e5b69978c1137f05bf8b469875503d5f7fa7f747"}], "stats": {"total": 1221, "additions": 759, "deletions": 462}, "files": [{"sha": "ddc2066537cefa7f69d0b6599695a7da8defa5df", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -32,6 +32,7 @@ hide_output ../gcc-$GCC/configure \\\n     --enable-languages=c,c++\n hide_output make -j10\n hide_output make install\n+ln -s gcc /rustroot/bin/cc\n \n cd ..\n rm -rf gcc-build"}, {"sha": "f66ff894ae865c486cf48a4987602c2eaa1e7f55", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -28,7 +28,7 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![allow(unused_imports)]\n \n-use core::borrow::Borrow;\n+use core::borrow::{Borrow, BorrowMut};\n use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n@@ -190,6 +190,14 @@ impl Borrow<str> for String {\n     }\n }\n \n+#[stable(feature = \"string_borrow_mut\", since = \"1.36.0\")]\n+impl BorrowMut<str> for String {\n+    #[inline]\n+    fn borrow_mut(&mut self) -> &mut str {\n+        &mut self[..]\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for str {\n     type Owned = String;"}, {"sha": "b48d81f2ef8f4731623fb7ffe50747ab64954529", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -144,6 +144,14 @@ impl<'tcx> Arena<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn alloc_slice<T: Copy>(&self, value: &[T]) -> &mut [T] {\n+        if value.len() == 0 {\n+            return &mut []\n+        }\n+        self.dropless.alloc_slice(value)\n+    }\n+\n     pub fn alloc_from_iter<\n         T: ArenaAllocatable,\n         I: IntoIterator<Item = T>"}, {"sha": "2592af7d4ad5a7045367d25b67becfe7dc7dcb83", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -369,7 +369,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprKind::AddrOf(_, ref e) |\n             hir::ExprKind::Cast(ref e, _) |\n             hir::ExprKind::Type(ref e, _) |\n-            hir::ExprKind::Use(ref e) |\n+            hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Field(ref e, _) |\n             hir::ExprKind::Yield(ref e) |"}, {"sha": "0c73d97394fdac00152e20b3321cd1b7cc4c6442", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1029,7 +1029,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Use(ref subexpression) => {\n+        ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n         ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {"}, {"sha": "f4209a39c83a789daebe837b8bcb21d775308dbd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -4671,7 +4671,7 @@ impl<'a> LoweringContext<'a> {\n                 // The construct was introduced in #21984.\n                 // FIXME(60253): Is this still necessary?\n                 // Also, add the attributes to the outer returned expr node.\n-                return self.expr_use(head_sp, match_expr, e.attrs.clone())\n+                return self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n             }\n \n             // Desugar `ExprKind::Try`\n@@ -5030,15 +5030,19 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    /// Wrap the given `expr` in `hir::ExprKind::Use`.\n+    /// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.\n     ///\n-    /// In terms of drop order, it has the same effect as\n-    /// wrapping `expr` in `{ let _t = $expr; _t }` but\n-    /// should provide better compile-time performance.\n+    /// In terms of drop order, it has the same effect as wrapping `expr` in\n+    /// `{ let _t = $expr; _t }` but should provide better compile-time performance.\n     ///\n     /// The drop order can be important in e.g. `if expr { .. }`.\n-    fn expr_use(&mut self, span: Span, expr: P<hir::Expr>, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::Use(expr), attrs)\n+    fn expr_drop_temps(\n+        &mut self,\n+        span: Span,\n+        expr: P<hir::Expr>,\n+        attrs: ThinVec<Attribute>\n+    ) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n     }\n \n     fn expr_match(\n@@ -5400,3 +5404,65 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n+\n+/// Checks if the specified expression is a built-in range literal.\n+/// (See: `LoweringContext::lower_expr()`).\n+pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n+    use hir::{Path, QPath, ExprKind, TyKind};\n+\n+    // Returns whether the given path represents a (desugared) range,\n+    // either in std or core, i.e. has either a `::std::ops::Range` or\n+    // `::core::ops::Range` prefix.\n+    fn is_range_path(path: &Path) -> bool {\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.as_str().to_string()).collect();\n+        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n+\n+        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n+            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Check whether a span corresponding to a range expression is a\n+    // range literal, rather than an explicit struct or `new()` call.\n+    fn is_lit(sess: &Session, span: &Span) -> bool {\n+        let source_map = sess.source_map();\n+        let end_point = source_map.end_point(*span);\n+\n+        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n+            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+        } else {\n+            false\n+        }\n+    };\n+\n+    match expr.node {\n+        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n+        ExprKind::Struct(ref qpath, _, _) => {\n+            if let QPath::Resolved(None, ref path) = **qpath {\n+                return is_range_path(&path) && is_lit(sess, &expr.span);\n+            }\n+        }\n+\n+        // `..` desugars to its struct path.\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n+            return is_range_path(&path) && is_lit(sess, &expr.span);\n+        }\n+\n+        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n+        ExprKind::Call(ref func, _) => {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n+                    let new_call = segment.ident.as_str() == \"new\";\n+                    return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    false\n+}"}, {"sha": "5a2807ac93d85b93ed46280c7af7da8bb8890f6c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1366,7 +1366,7 @@ impl Expr {\n             ExprKind::Unary(..) => ExprPrecedence::Unary,\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n-            ExprKind::Use(ref expr, ..) => expr.precedence(),\n+            ExprKind::DropTemps(ref expr, ..) => expr.precedence(),\n             ExprKind::If(..) => ExprPrecedence::If,\n             ExprKind::While(..) => ExprPrecedence::While,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n@@ -1438,7 +1438,7 @@ impl Expr {\n             ExprKind::Binary(..) |\n             ExprKind::Yield(..) |\n             ExprKind::Cast(..) |\n-            ExprKind::Use(..) |\n+            ExprKind::DropTemps(..) |\n             ExprKind::Err => {\n                 false\n             }\n@@ -1488,10 +1488,12 @@ pub enum ExprKind {\n     Cast(P<Expr>, P<Ty>),\n     /// A type reference (e.g., `Foo`).\n     Type(P<Expr>, P<Ty>),\n-    /// Semantically equivalent to `{ let _t = expr; _t }`.\n-    /// Maps directly to `hair::ExprKind::Use`.\n-    /// Only exists to tweak the drop order in HIR.\n-    Use(P<Expr>),\n+    /// Wraps the expression in a terminating scope.\n+    /// This makes it semantically equivalent to `{ let _t = expr; _t }`.\n+    ///\n+    /// This construct only exists to tweak the drop order in HIR lowering.\n+    /// An example of that is the desugaring of `for` loops.\n+    DropTemps(P<Expr>),\n     /// An `if` block, with an optional else block.\n     ///\n     /// I.e., `if <expr> { <expr> } else { <expr> }`."}, {"sha": "54816316f0bf5dcae0b7734bf0d29ad486140cde", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1388,7 +1388,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n-            hir::ExprKind::Use(ref init) => {\n+            hir::ExprKind::DropTemps(ref init) => {\n                 // Print `{`:\n                 self.cbox(indent_unit)?;\n                 self.ibox(0)?;"}, {"sha": "3b9af75bd0ab8ba8381b73f84473f62350c0847b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -520,7 +520,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprKind::Use(ref expr) => {\n+            hir::ExprKind::DropTemps(ref expr) => {\n                 self.consume_expr(&expr);\n             }\n "}, {"sha": "2ae53a5df3a866ec20d2e326d2d1a723f463b9a3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -521,7 +521,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprKind::Binary(..) |\n       hir::ExprKind::AddrOf(..) |\n       hir::ExprKind::Cast(..) |\n-      hir::ExprKind::Use(..) |\n+      hir::ExprKind::DropTemps(..) |\n       hir::ExprKind::Unary(..) |\n       hir::ExprKind::Break(..) |\n       hir::ExprKind::Continue(_) |\n@@ -1222,7 +1222,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::AddrOf(_, ref e) |\n             hir::ExprKind::Cast(ref e, _) |\n             hir::ExprKind::Type(ref e, _) |\n-            hir::ExprKind::Use(ref e) |\n+            hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Yield(ref e) |\n             hir::ExprKind::Repeat(ref e, _) => {\n@@ -1526,7 +1526,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n         hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n         hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n-        hir::ExprKind::Cast(..) | hir::ExprKind::Use(..) | hir::ExprKind::Unary(..) |\n+        hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) | hir::ExprKind::Unary(..) |\n         hir::ExprKind::Ret(..) | hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) |\n         hir::ExprKind::Lit(_) | hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n         hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |"}, {"sha": "34b44234279f2ba62590e96cad156b629306b96c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -677,7 +677,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n             hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n             hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n-            hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::Use(..) |\n+            hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) |\n             hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n             hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n             hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |"}, {"sha": "2b88f273adce42936d989a1e7c5138231808d3c4", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -908,8 +908,8 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n \n-            hir::ExprKind::Use(ref expr) => {\n-                // `Use(expr)` does not denote a conditional scope.\n+            hir::ExprKind::DropTemps(ref expr) => {\n+                // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n                 terminating(expr.hir_id.local_id);\n             }"}, {"sha": "b96ef1b7a869bd0a8711ba804348ece050263342", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -245,13 +245,13 @@ rustc_queries! {\n \n         /// Get a map with the variance of every item; use `item_variance`\n         /// instead.\n-        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap> {\n+        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap<'tcx>> {\n             desc { \"computing the variances for items in this crate\" }\n         }\n \n         /// Maps from def-id of a type or region parameter to its\n         /// (inferred) variance.\n-        query variances_of(_: DefId) -> Lrc<Vec<ty::Variance>> {}\n+        query variances_of(_: DefId) -> &'tcx [ty::Variance] {}\n     }\n \n     TypeChecking {"}, {"sha": "6b938ea2fccdc62e4e37673ed0f423778306827a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -332,15 +332,11 @@ pub enum Variance {\n /// `tcx.variances_of()` to get the variance for a *particular*\n /// item.\n #[derive(HashStable)]\n-pub struct CrateVariancesMap {\n+pub struct CrateVariancesMap<'tcx> {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n-    pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n-\n-    /// An empty vector, useful for cloning.\n-    #[stable_hasher(ignore)]\n-    pub empty_variance: Lrc<Vec<ty::Variance>>,\n+    pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n }\n \n impl Variance {"}, {"sha": "2638a1c7c8808e065c69d3a063e569e5fa8b8128", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -60,7 +60,7 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n                b_subst);\n \n         let opt_variances = self.tcx().variances_of(item_def_id);\n-        relate_substs(self, Some(&opt_variances), a_subst, b_subst)\n+        relate_substs(self, Some(opt_variances), a_subst, b_subst)\n     }\n \n     /// Switch variance for the purpose of relating `a` and `b`.\n@@ -122,7 +122,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                        variances: Option<&Vec<ty::Variance>>,\n+                                        variances: Option<&[ty::Variance]>,\n                                         a_subst: SubstsRef<'tcx>,\n                                         b_subst: SubstsRef<'tcx>)\n                                         -> RelateResult<'tcx, SubstsRef<'tcx>>"}, {"sha": "f4ebfd79fe1db41f1bfee121dd045a1be2de7569", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 345, "deletions": 250, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,6 +1,7 @@\n #![allow(non_snake_case)]\n \n-use rustc::hir::Node;\n+use rustc::hir::{ExprKind, Node};\n+use rustc::hir::lowering::is_range_literal;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx};\n@@ -57,6 +58,347 @@ impl TypeLimits {\n     }\n }\n \n+/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n+/// Returns `true` iff the lint was overridden.\n+fn lint_overflowing_range_endpoint<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    lit: &ast::Lit,\n+    lit_val: u128,\n+    max: u128,\n+    expr: &'tcx hir::Expr,\n+    parent_expr: &'tcx hir::Expr,\n+    ty: impl std::fmt::Debug,\n+) -> bool {\n+    // We only want to handle exclusive (`..`) ranges,\n+    // which are represented as `ExprKind::Struct`.\n+    if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n+        debug_assert_eq!(eps.len(), 2);\n+        // We can suggest using an inclusive range\n+        // (`..=`) instead only if it is the `end` that is\n+        // overflowing and only by 1.\n+        if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n+            let mut err = cx.struct_span_lint(\n+                OVERFLOWING_LITERALS,\n+                parent_expr.span,\n+                &format!(\"range endpoint is out of range for `{:?}`\", ty),\n+            );\n+            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                use ast::{LitKind, LitIntType};\n+                // We need to preserve the literal's suffix,\n+                // as it may determine typing information.\n+                let suffix = match lit.node {\n+                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n+                    _ => bug!(),\n+                };\n+                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                err.span_suggestion(\n+                    parent_expr.span,\n+                    &\"use an inclusive range instead\",\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+// For `isize` & `usize`, be conservative with the warnings, so that the\n+// warnings are consistent between 32- and 64-bit platforms.\n+fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n+    match int_ty {\n+        ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n+        ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n+        ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n+        ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n+        ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+        ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n+    }\n+}\n+\n+fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n+    match uint_ty {\n+        ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n+        ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n+        ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n+        ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n+        ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n+        ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n+    }\n+}\n+\n+fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n+    let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n+    let firstch = src.chars().next()?;\n+\n+    if firstch == '0' {\n+        match src.chars().nth(1) {\n+            Some('x') | Some('b') => return Some(src),\n+            _ => return None,\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn report_bin_hex_error(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr,\n+    ty: attr::IntType,\n+    repr_str: String,\n+    val: u128,\n+    negative: bool,\n+) {\n+    let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n+    let (t, actually) = match ty {\n+        attr::IntType::SignedInt(t) => {\n+            let actually = sign_extend(val, size) as i128;\n+            (format!(\"{:?}\", t), actually.to_string())\n+        }\n+        attr::IntType::UnsignedInt(t) => {\n+            let actually = truncate(val, size);\n+            (format!(\"{:?}\", t), actually.to_string())\n+        }\n+    };\n+    let mut err = cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        &format!(\"literal out of range for {}\", t),\n+    );\n+    err.note(&format!(\n+        \"the literal `{}` (decimal `{}`) does not fit into \\\n+            an `{}` and will become `{}{}`\",\n+        repr_str, val, t, actually, t\n+    ));\n+    if let Some(sugg_ty) =\n+        get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n+    {\n+        if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+            let (sans_suffix, _) = repr_str.split_at(pos);\n+            err.span_suggestion(\n+                expr.span,\n+                &format!(\"consider using `{}` instead\", sugg_ty),\n+                format!(\"{}{}\", sans_suffix, sugg_ty),\n+                Applicability::MachineApplicable\n+            );\n+        } else {\n+            err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+        }\n+    }\n+\n+    err.emit();\n+}\n+\n+// This function finds the next fitting type and generates a suggestion string.\n+// It searches for fitting types in the following way (`X < Y`):\n+//  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n+//  - `-iX` => `iY`\n+//  - `uX` => `uY`\n+//\n+// No suggestion for: `isize`, `usize`.\n+fn get_type_suggestion<'a>(\n+    t: Ty<'_>,\n+    val: u128,\n+    negative: bool,\n+) -> Option<String> {\n+    use syntax::ast::IntTy::*;\n+    use syntax::ast::UintTy::*;\n+    macro_rules! find_fit {\n+        ($ty:expr, $val:expr, $negative:expr,\n+         $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n+            {\n+                let _neg = if negative { 1 } else { 0 };\n+                match $ty {\n+                    $($type => {\n+                        $(if !negative && val <= uint_ty_range($utypes).1 {\n+                            return Some(format!(\"{:?}\", $utypes))\n+                        })*\n+                        $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n+                            return Some(format!(\"{:?}\", $itypes))\n+                        })*\n+                        None\n+                    },)*\n+                    _ => None\n+                }\n+            }\n+        }\n+    }\n+    match t.sty {\n+        ty::Int(i) => find_fit!(i, val, negative,\n+                      I8 => [U8] => [I16, I32, I64, I128],\n+                      I16 => [U16] => [I32, I64, I128],\n+                      I32 => [U32] => [I64, I128],\n+                      I64 => [U64] => [I128],\n+                      I128 => [U128] => []),\n+        ty::Uint(u) => find_fit!(u, val, negative,\n+                      U8 => [U8, U16, U32, U64, U128] => [],\n+                      U16 => [U16, U32, U64, U128] => [],\n+                      U32 => [U32, U64, U128] => [],\n+                      U64 => [U64, U128] => [],\n+                      U128 => [U128] => []),\n+        _ => None,\n+    }\n+}\n+\n+fn lint_int_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    type_limits: &TypeLimits,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+    t: ast::IntTy,\n+    v: u128,\n+) {\n+    let int_type = if let ast::IntTy::Isize = t {\n+        cx.sess().target.isize_ty\n+    } else {\n+        t\n+    };\n+\n+    let (_, max) = int_ty_range(int_type);\n+    let max = max as u128;\n+    let negative = type_limits.negated_expr_id == e.hir_id;\n+\n+    // Detect literal value out of range [min, max] inclusive\n+    // avoiding use of -min to prevent overflow/panic\n+    if (negative && v > max + 1) || (!negative && v > max) {\n+        if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+            report_bin_hex_error(\n+                cx,\n+                e,\n+                attr::IntType::SignedInt(t),\n+                repr_str,\n+                v,\n+                negative,\n+            );\n+            return;\n+        }\n+\n+        let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(par_id) {\n+            if let hir::ExprKind::Struct(..) = par_e.node {\n+                if is_range_literal(cx.sess(), par_e)\n+                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n+                {\n+                    // The overflowing literal lint was overridden.\n+                    return;\n+                }\n+            }\n+        }\n+\n+        cx.span_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            &format!(\"literal out of range for `{:?}`\", t),\n+        );\n+    }\n+}\n+\n+fn lint_uint_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+    t: ast::UintTy,\n+) {\n+    let uint_type = if let ast::UintTy::Usize = t {\n+        cx.sess().target.usize_ty\n+    } else {\n+        t\n+    };\n+    let (min, max) = uint_ty_range(uint_type);\n+    let lit_val: u128 = match lit.node {\n+        // _v is u8, within range by definition\n+        ast::LitKind::Byte(_v) => return,\n+        ast::LitKind::Int(v, _) => v,\n+        _ => bug!(),\n+    };\n+    if lit_val < min || lit_val > max {\n+        let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(parent_id) {\n+            match par_e.node {\n+                hir::ExprKind::Cast(..) => {\n+                    if let ty::Char = cx.tables.expr_ty(par_e).sty {\n+                        let mut err = cx.struct_span_lint(\n+                            OVERFLOWING_LITERALS,\n+                            par_e.span,\n+                            \"only `u8` can be cast into `char`\",\n+                        );\n+                        err.span_suggestion(\n+                            par_e.span,\n+                            &\"use a `char` literal instead\",\n+                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                        return;\n+                    }\n+                }\n+                hir::ExprKind::Struct(..)\n+                    if is_range_literal(cx.sess(), par_e) => {\n+                        if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n+                            // The overflowing literal lint was overridden.\n+                            return;\n+                        }\n+                    }\n+                _ => {}\n+            }\n+        }\n+        if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+            report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n+            return;\n+        }\n+        cx.span_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            &format!(\"literal out of range for `{:?}`\", t),\n+        );\n+    }\n+}\n+\n+fn lint_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    type_limits: &TypeLimits,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+) {\n+    match cx.tables.node_type(e.hir_id).sty {\n+        ty::Int(t) => {\n+            match lit.node {\n+                ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n+                    lint_int_literal(cx, type_limits, e, lit, t, v)\n+                }\n+                _ => bug!(),\n+            };\n+        }\n+        ty::Uint(t) => {\n+            lint_uint_literal(cx, e, lit, t)\n+        }\n+        ty::Float(t) => {\n+            let is_infinite = match lit.node {\n+                ast::LitKind::Float(v, _) |\n+                ast::LitKind::FloatUnsuffixed(v) => {\n+                    match t {\n+                        ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n+                        ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n+                    }\n+                }\n+                _ => bug!(),\n+            };\n+            if is_infinite == Ok(true) {\n+                cx.span_lint(OVERFLOWING_LITERALS,\n+                             e.span,\n+                             &format!(\"literal out of range for `{:?}`\", t));\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n@@ -73,118 +415,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                  \"comparison is useless due to type limits\");\n                 }\n             }\n-            hir::ExprKind::Lit(ref lit) => {\n-                match cx.tables.node_type(e.hir_id).sty {\n-                    ty::Int(t) => {\n-                        match lit.node {\n-                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n-                                let int_type = if let ast::IntTy::Isize = t {\n-                                    cx.sess().target.isize_ty\n-                                } else {\n-                                    t\n-                                };\n-                                let (_, max) = int_ty_range(int_type);\n-                                let max = max as u128;\n-                                let negative = self.negated_expr_id == e.hir_id;\n-\n-                                // Detect literal value out of range [min, max] inclusive\n-                                // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max + 1) || (!negative && v > max) {\n-                                    if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-                                        report_bin_hex_error(\n-                                            cx,\n-                                            e,\n-                                            attr::IntType::SignedInt(t),\n-                                            repr_str,\n-                                            v,\n-                                            negative,\n-                                        );\n-                                        return;\n-                                    }\n-                                    cx.span_lint(\n-                                        OVERFLOWING_LITERALS,\n-                                        e.span,\n-                                        &format!(\"literal out of range for {:?}\", t),\n-                                    );\n-                                    return;\n-                                }\n-                            }\n-                            _ => bug!(),\n-                        };\n-                    }\n-                    ty::Uint(t) => {\n-                        let uint_type = if let ast::UintTy::Usize = t {\n-                            cx.sess().target.usize_ty\n-                        } else {\n-                            t\n-                        };\n-                        let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u128 = match lit.node {\n-                            // _v is u8, within range by definition\n-                            ast::LitKind::Byte(_v) => return,\n-                            ast::LitKind::Int(v, _) => v,\n-                            _ => bug!(),\n-                        };\n-                        if lit_val < min || lit_val > max {\n-                            let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n-                            if let Node::Expr(parent_expr) = cx.tcx.hir().get_by_hir_id(parent_id) {\n-                                if let hir::ExprKind::Cast(..) = parent_expr.node {\n-                                    if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n-                                        let mut err = cx.struct_span_lint(\n-                                                             OVERFLOWING_LITERALS,\n-                                                             parent_expr.span,\n-                                                             \"only u8 can be cast into char\");\n-                                        err.span_suggestion(\n-                                            parent_expr.span,\n-                                            &\"use a char literal instead\",\n-                                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                        err.emit();\n-                                        return\n-                                    }\n-                                }\n-                            }\n-                            if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-                                report_bin_hex_error(\n-                                    cx,\n-                                    e,\n-                                    attr::IntType::UnsignedInt(t),\n-                                    repr_str,\n-                                    lit_val,\n-                                    false,\n-                                );\n-                                return;\n-                            }\n-                            cx.span_lint(\n-                                OVERFLOWING_LITERALS,\n-                                e.span,\n-                                &format!(\"literal out of range for {:?}\", t),\n-                            );\n-                        }\n-                    }\n-                    ty::Float(t) => {\n-                        let is_infinite = match lit.node {\n-                            ast::LitKind::Float(v, _) |\n-                            ast::LitKind::FloatUnsuffixed(v) => {\n-                                match t {\n-                                    ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n-                                    ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n-                                }\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        if is_infinite == Ok(true) {\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for {:?}\", t));\n-                        }\n-                    }\n-                    _ => (),\n-                };\n-            }\n-            _ => (),\n+            hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n+            _ => {}\n         };\n \n         fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n@@ -209,30 +441,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             })\n         }\n \n-        // for isize & usize, be conservative with the warnings, so that the\n-        // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n-            match int_ty {\n-                ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n-                ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n-                ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n-                ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n-                ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n-                ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n-            }\n-        }\n-\n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n-            match uint_ty {\n-                ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n-                ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n-                ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n-                ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n-                ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n-                ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n-            }\n-        }\n-\n         fn check_limits(cx: &LateContext<'_, '_>,\n                         binop: hir::BinOp,\n                         l: &hir::Expr,\n@@ -289,119 +497,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n-\n-        fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n-            let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n-            let firstch = src.chars().next()?;\n-\n-            if firstch == '0' {\n-                match src.chars().nth(1) {\n-                    Some('x') | Some('b') => return Some(src),\n-                    _ => return None,\n-                }\n-            }\n-\n-            None\n-        }\n-\n-        // This function finds the next fitting type and generates a suggestion string.\n-        // It searches for fitting types in the following way (`X < Y`):\n-        //  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n-        //  - `-iX` => `iY`\n-        //  - `uX` => `uY`\n-        //\n-        // No suggestion for: `isize`, `usize`.\n-        fn get_type_suggestion<'a>(\n-            t: Ty<'_>,\n-            val: u128,\n-            negative: bool,\n-        ) -> Option<String> {\n-            use syntax::ast::IntTy::*;\n-            use syntax::ast::UintTy::*;\n-            macro_rules! find_fit {\n-                ($ty:expr, $val:expr, $negative:expr,\n-                 $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n-                    {\n-                        let _neg = if negative { 1 } else { 0 };\n-                        match $ty {\n-                            $($type => {\n-                                $(if !negative && val <= uint_ty_range($utypes).1 {\n-                                    return Some(format!(\"{:?}\", $utypes))\n-                                })*\n-                                $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n-                                    return Some(format!(\"{:?}\", $itypes))\n-                                })*\n-                                None\n-                            },)*\n-                            _ => None\n-                        }\n-                    }\n-                }\n-            }\n-            match t.sty {\n-                ty::Int(i) => find_fit!(i, val, negative,\n-                              I8 => [U8] => [I16, I32, I64, I128],\n-                              I16 => [U16] => [I32, I64, I128],\n-                              I32 => [U32] => [I64, I128],\n-                              I64 => [U64] => [I128],\n-                              I128 => [U128] => []),\n-                ty::Uint(u) => find_fit!(u, val, negative,\n-                              U8 => [U8, U16, U32, U64, U128] => [],\n-                              U16 => [U16, U32, U64, U128] => [],\n-                              U32 => [U32, U64, U128] => [],\n-                              U64 => [U64, U128] => [],\n-                              U128 => [U128] => []),\n-                _ => None,\n-            }\n-        }\n-\n-        fn report_bin_hex_error(\n-            cx: &LateContext<'_, '_>,\n-            expr: &hir::Expr,\n-            ty: attr::IntType,\n-            repr_str: String,\n-            val: u128,\n-            negative: bool,\n-        ) {\n-            let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n-            let (t, actually) = match ty {\n-                attr::IntType::SignedInt(t) => {\n-                    let actually = sign_extend(val, size) as i128;\n-                    (format!(\"{:?}\", t), actually.to_string())\n-                }\n-                attr::IntType::UnsignedInt(t) => {\n-                    let actually = truncate(val, size);\n-                    (format!(\"{:?}\", t), actually.to_string())\n-                }\n-            };\n-            let mut err = cx.struct_span_lint(\n-                OVERFLOWING_LITERALS,\n-                expr.span,\n-                &format!(\"literal out of range for {}\", t),\n-            );\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 an `{}` and will become `{}{}`\",\n-                repr_str, val, t, actually, t\n-            ));\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n-            {\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    err.span_suggestion(\n-                        expr.span,\n-                        &format!(\"consider using `{}` instead\", sugg_ty),\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable\n-                    );\n-                } else {\n-                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n-                }\n-            }\n-\n-            err.emit();\n-        }\n     }\n }\n "}, {"sha": "b3439e4c9708f069a3b4624bc78e449fbf3aafcd", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -106,7 +106,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n     }\n-    variances_of => { Lrc::new(cdata.get_item_variances(def_id.index)) }\n+    variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n         let mut result = vec![];\n         cdata.each_child_of_item(def_id.index,"}, {"sha": "00e81ee049183f255efe2ea4c0f910269a6b6d77", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -674,8 +674,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) =\n-            self.best_blame_constraint(mir, borrow_region, |r| r == outlived_region);\n+        let (category, from_closure, span) = self.best_blame_constraint(\n+            mir,\n+            borrow_region,\n+            |r| self.provides_universal_region(r, borrow_region, outlived_region)\n+        );\n         let outlived_fr_name =\n             self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)"}, {"sha": "6e11f1dae9b061838564298b4e2c69c1b6fe2dbf", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -759,7 +759,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 }\n             }\n         }\n-        hir::ExprKind::Use(ref source) => {\n+        hir::ExprKind::DropTemps(ref source) => {\n             ExprKind::Use { source: source.to_ref() }\n         }\n         hir::ExprKind::Box(ref value) => {"}, {"sha": "881f63e994d59e908a413c62098104f494d06a6c", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -437,7 +437,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::AddrOf(_, ref expr) |\n         hir::ExprKind::Repeat(ref expr, _) |\n         hir::ExprKind::Type(ref expr, _) |\n-        hir::ExprKind::Use(ref expr) => {\n+        hir::ExprKind::DropTemps(ref expr) => {\n             v.check_expr(&expr)\n         }\n "}, {"sha": "8ae66a96c763a8e26dff828a22be9852d1c82423", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -7,7 +7,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::Node;\n-use rustc::hir::print;\n+use rustc::hir::{print, lowering::is_range_literal};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{Applicability, DiagnosticBuilder};\n@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::ExprKind::Cast(_, _) |\n                             hir::ExprKind::Binary(_, _, _) => true,\n                             // parenthesize borrows of range literals (Issue #54505)\n-                            _ if self.is_range_literal(expr) => true,\n+                            _ if is_range_literal(self.tcx.sess, expr) => true,\n                             _ => false,\n                         };\n                         let sugg_expr = if needs_parens {\n@@ -479,70 +479,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    /// This function checks if the specified expression is a built-in range literal.\n-    /// (See: `LoweringContext::lower_expr()` in `src/librustc/hir/lowering.rs`).\n-    fn is_range_literal(&self, expr: &hir::Expr) -> bool {\n-        use hir::{Path, QPath, ExprKind, TyKind};\n-\n-        // We support `::std::ops::Range` and `::core::ops::Range` prefixes\n-        let is_range_path = |path: &Path| {\n-            let mut segs = path.segments.iter()\n-                .map(|seg| seg.ident.as_str());\n-\n-            if let (Some(root), Some(std_core), Some(ops), Some(range), None) =\n-                (segs.next(), segs.next(), segs.next(), segs.next(), segs.next())\n-            {\n-                // \"{{root}}\" is the equivalent of `::` prefix in Path\n-                root == \"{{root}}\" && (std_core == \"std\" || std_core == \"core\")\n-                    && ops == \"ops\" && range.starts_with(\"Range\")\n-            } else {\n-                false\n-            }\n-        };\n-\n-        let span_is_range_literal = |span: &Span| {\n-            // Check whether a span corresponding to a range expression\n-            // is a range literal, rather than an explicit struct or `new()` call.\n-            let source_map = self.tcx.sess.source_map();\n-            let end_point = source_map.end_point(*span);\n-\n-            if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n-                !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n-            } else {\n-                false\n-            }\n-        };\n-\n-        match expr.node {\n-            // All built-in range literals but `..=` and `..` desugar to Structs\n-            ExprKind::Struct(ref qpath, _, _) => {\n-                if let QPath::Resolved(None, ref path) = **qpath {\n-                    return is_range_path(&path) && span_is_range_literal(&expr.span);\n-                }\n-            }\n-            // `..` desugars to its struct path\n-            ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-                return is_range_path(&path) && span_is_range_literal(&expr.span);\n-            }\n-\n-            // `..=` desugars into `::std::ops::RangeInclusive::new(...)`\n-            ExprKind::Call(ref func, _) => {\n-                if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n-                    if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n-                        let call_to_new = segment.ident.as_str() == \"new\";\n-\n-                        return is_range_path(&path) && span_is_range_literal(&expr.span)\n-                            && call_to_new;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n     pub fn check_for_cast(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,"}, {"sha": "d2d486b52b3f86bc950290d08a77204084f89872", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -4538,7 +4538,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n-            ExprKind::Use(ref e) => {\n+            ExprKind::DropTemps(ref e) => {\n                 self.check_expr_with_expectation(e, expected)\n             }\n             ExprKind::Array(ref args) => {"}, {"sha": "1be0248727d0110fc4924a97f0d353f45bcb9357", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -223,19 +223,22 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n                     let fields = &def_a.non_enum_variant().fields;\n \n                     let coerced_fields = fields.iter().filter_map(|field| {\n-                        if tcx.type_of(field.did).is_phantom_data() {\n-                            // ignore PhantomData fields\n-                            return None\n-                        }\n-\n                         let ty_a = field.ty(tcx, substs_a);\n                         let ty_b = field.ty(tcx, substs_b);\n+\n+                        if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n+                            if layout.is_zst() && layout.details.align.abi.bytes() == 1 {\n+                                // ignore ZST fields with alignment of 1 byte\n+                                return None;\n+                            }\n+                        }\n+\n                         if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n                             if ok.obligations.is_empty() {\n                                 create_err(\n                                     \"the trait `DispatchFromDyn` may only be implemented \\\n                                      for structs containing the field being coerced, \\\n-                                     `PhantomData` fields, and nothing else\"\n+                                     ZST fields with 1 byte alignment, and nothing else\"\n                                 ).note(\n                                     &format!(\n                                         \"extra field `{}` of type `{}` is not allowed\","}, {"sha": "88ee1d79f5435dd165bc30e1402a1c191f5915fa", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -36,7 +36,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n-                             -> Lrc<CrateVariancesMap> {\n+                             -> Lrc<CrateVariancesMap<'tcx>> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n@@ -45,7 +45,7 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n }\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n-                          -> Lrc<Vec<ty::Variance>> {\n+                          -> &'tcx [ty::Variance] {\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant.\n@@ -88,6 +88,6 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n \n     let crate_map = tcx.crate_variances(LOCAL_CRATE);\n     crate_map.variances.get(&item_def_id)\n-                       .unwrap_or(&crate_map.empty_variance)\n-                       .clone()\n+                       .map(|p| *p)\n+                       .unwrap_or(&[])\n }"}, {"sha": "8edf3c52ccc221807d34fdeb65cf6f04f63b11ae", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -8,7 +8,6 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n \n use super::constraints::*;\n use super::terms::*;\n@@ -23,7 +22,9 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext<'_, '_>) -> ty::CrateVariancesMap {\n+pub fn solve_constraints<'tcx>(\n+    constraints_cx: ConstraintContext<'_, 'tcx>\n+) -> ty::CrateVariancesMap<'tcx> {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n@@ -41,9 +42,8 @@ pub fn solve_constraints(constraints_cx: ConstraintContext<'_, '_>) -> ty::Crate\n     };\n     solutions_cx.solve();\n     let variances = solutions_cx.create_map();\n-    let empty_variance = Lrc::new(Vec::new());\n \n-    ty::CrateVariancesMap { variances, empty_variance }\n+    ty::CrateVariancesMap { variances }\n }\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_const_invariance(&self, generics: &ty::Generics, variances: &mut Vec<ty::Variance>) {\n+    fn enforce_const_invariance(&self, generics: &ty::Generics, variances: &mut [ty::Variance]) {\n         let tcx = self.terms_cx.tcx;\n \n         // Make all const parameters invariant.\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn create_map(&self) -> FxHashMap<DefId, Lrc<Vec<ty::Variance>>> {\n+    fn create_map(&self) -> FxHashMap<DefId, &'tcx [ty::Variance]> {\n         let tcx = self.terms_cx.tcx;\n \n         let solutions = &self.solutions;\n@@ -103,22 +103,21 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             let generics = tcx.generics_of(def_id);\n             let count = generics.count();\n \n-            let mut variances = solutions[start..(start + count)].to_vec();\n-            debug!(\"id={} variances={:?}\", id, variances);\n+            let variances = tcx.arena.alloc_slice(&solutions[start..(start + count)]);\n \n             // Const parameters are always invariant.\n-            self.enforce_const_invariance(generics, &mut variances);\n+            self.enforce_const_invariance(generics, variances);\n \n             // Functions are permitted to have unused generic parameters: make those invariant.\n             if let ty::FnDef(..) = tcx.type_of(def_id).sty {\n-                for variance in &mut variances {\n+                for variance in variances.iter_mut() {\n                     if *variance == ty::Bivariant {\n                         *variance = ty::Invariant;\n                     }\n                 }\n             }\n \n-            (def_id, Lrc::new(variances))\n+            (def_id, &*variances)\n         }).collect()\n     }\n "}, {"sha": "a2181336e00f518d9332b1369217790008e7c53a", "filename": "src/test/run-pass/dispatch_from_dyn_zst.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Frun-pass%2Fdispatch_from_dyn_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Frun-pass%2Fdispatch_from_dyn_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdispatch_from_dyn_zst.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -0,0 +1,49 @@\n+#![feature(unsize, dispatch_from_dyn, never_type)]\n+\n+#![allow(dead_code)]\n+\n+use std::{\n+    ops::DispatchFromDyn,\n+    marker::{Unsize, PhantomData},\n+};\n+\n+struct Zst;\n+struct NestedZst(PhantomData<()>, Zst);\n+\n+\n+struct WithUnit<T: ?Sized>(Box<T>, ());\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<WithUnit<U>> for WithUnit<T>\n+    where T: Unsize<U> {}\n+\n+struct WithPhantom<T: ?Sized>(Box<T>, PhantomData<()>);\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<WithPhantom<U>> for WithPhantom<T>\n+    where T: Unsize<U> {}\n+\n+struct WithNever<T: ?Sized>(Box<T>, !);\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<WithNever<U>> for WithNever<T>\n+    where T: Unsize<U> {}\n+\n+struct WithZst<T: ?Sized>(Box<T>, Zst);\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<WithZst<U>> for WithZst<T>\n+    where T: Unsize<U> {}\n+\n+struct WithNestedZst<T: ?Sized>(Box<T>, NestedZst);\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<WithNestedZst<U>> for WithNestedZst<T>\n+    where T: Unsize<U> {}\n+\n+\n+struct Generic<T: ?Sized, A>(Box<T>, A);\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Generic<U, ()>> for Generic<T, ()>\n+    where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Generic<U, PhantomData<()>>>\n+    for Generic<T, PhantomData<()>>\n+    where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Generic<U, !>> for Generic<T, !>\n+    where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Generic<U, Zst>> for Generic<T, Zst>\n+    where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Generic<U, NestedZst>> for Generic<T, NestedZst>\n+    where T: Unsize<U> {}\n+\n+\n+fn main() {}"}, {"sha": "9634ed56f7b723149d93903a91dc287886a2f2cd", "filename": "src/test/ui/cast_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fcast_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fcast_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -2,9 +2,9 @@\n \n fn main() {\n     const XYZ: char = 0x1F888 as char;\n-    //~^ ERROR only u8 can be cast into char\n+    //~^ ERROR only `u8` can be cast into `char`\n     const XY: char = 129160 as char;\n-    //~^ ERROR only u8 can be cast into char\n+    //~^ ERROR only `u8` can be cast into `char`\n     const ZYX: char = '\\u{01F888}';\n     println!(\"{}\", XYZ);\n }"}, {"sha": "37ef98bcb5067c8fd45ac3638a634d0b675257a9", "filename": "src/test/ui/cast_char.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fcast_char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fcast_char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,20 +1,20 @@\n-error: only u8 can be cast into char\n+error: only `u8` can be cast into `char`\n   --> $DIR/cast_char.rs:4:23\n    |\n LL |     const XYZ: char = 0x1F888 as char;\n-   |                       ^^^^^^^^^^^^^^^ help: use a char literal instead: `'\\u{1F888}'`\n+   |                       ^^^^^^^^^^^^^^^ help: use a `char` literal instead: `'\\u{1F888}'`\n    |\n note: lint level defined here\n   --> $DIR/cast_char.rs:1:9\n    |\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: only u8 can be cast into char\n+error: only `u8` can be cast into `char`\n   --> $DIR/cast_char.rs:6:22\n    |\n LL |     const XY: char = 129160 as char;\n-   |                      ^^^^^^^^^^^^^^ help: use a char literal instead: `'\\u{1F888}'`\n+   |                      ^^^^^^^^^^^^^^ help: use a `char` literal instead: `'\\u{1F888}'`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "85cd73d6f0855e09ba9714472c0d5abf9ae3ae69", "filename": "src/test/ui/enum/enum-discrim-too-small2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -5,28 +5,28 @@\n enum Ei8 {\n     Ai8 = 23,\n     Bi8 = -23,\n-    Ci8 = 223, //~ ERROR literal out of range for i8\n+    Ci8 = 223, //~ ERROR literal out of range for `i8`\n }\n \n #[repr(i16)]\n enum Ei16 {\n     Ai16 = 23,\n     Bi16 = -22333,\n-    Ci16 = 55555, //~ ERROR literal out of range for i16\n+    Ci16 = 55555, //~ ERROR literal out of range for `i16`\n }\n \n #[repr(i32)]\n enum Ei32 {\n     Ai32 = 23,\n     Bi32 = -2_000_000_000,\n-    Ci32 = 3_000_000_000, //~ ERROR literal out of range for i32\n+    Ci32 = 3_000_000_000, //~ ERROR literal out of range for `i32`\n }\n \n #[repr(i64)]\n enum Ei64 {\n     Ai64 = 23,\n     Bi64 = -9223372036854775808,\n-    Ci64 = 9223372036854775809, //~ ERROR literal out of range for i64\n+    Ci64 = 9223372036854775809, //~ ERROR literal out of range for `i64`\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "f7220044ba42dcf422a53e77f47e8896099dddc7", "filename": "src/test/ui/enum/enum-discrim-too-small2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-too-small2.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,4 +1,4 @@\n-error: literal out of range for i8\n+error: literal out of range for `i8`\n   --> $DIR/enum-discrim-too-small2.rs:8:11\n    |\n LL |     Ci8 = 223,\n@@ -10,19 +10,19 @@ note: lint level defined here\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i16\n+error: literal out of range for `i16`\n   --> $DIR/enum-discrim-too-small2.rs:15:12\n    |\n LL |     Ci16 = 55555,\n    |            ^^^^^\n \n-error: literal out of range for i32\n+error: literal out of range for `i32`\n   --> $DIR/enum-discrim-too-small2.rs:22:12\n    |\n LL |     Ci32 = 3_000_000_000,\n    |            ^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n+error: literal out of range for `i64`\n   --> $DIR/enum-discrim-too-small2.rs:29:12\n    |\n LL |     Ci64 = 9223372036854775809,"}, {"sha": "b7bc766fbe020c84174fe48a4e4241a237d4ecb4", "filename": "src/test/ui/invalid_dispatch_from_dyn_impls.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -39,4 +39,13 @@ where\n     T: Unsize<U>,\n {} //~^^^ ERROR [E0378]\n \n+#[repr(align(64))]\n+struct OverAlignedZst;\n+struct OverAligned<T: ?Sized>(Box<T>, OverAlignedZst);\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<OverAligned<U>> for OverAligned<T>\n+    where\n+        T: Unsize<U>,\n+{} //~^^^ ERROR [E0378]\n+\n fn main() {}"}, {"sha": "6d62d4fd0711ddaa6e3042634bbbc18d9dbfd7b8", "filename": "src/test/ui/invalid_dispatch_from_dyn_impls.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,4 +1,4 @@\n-error[E0378]: the trait `DispatchFromDyn` may only be implemented for structs containing the field being coerced, `PhantomData` fields, and nothing else\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for structs containing the field being coerced, ZST fields with 1 byte alignment, and nothing else\n   --> $DIR/invalid_dispatch_from_dyn_impls.rs:10:1\n    |\n LL | / impl<T, U> DispatchFromDyn<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n@@ -36,6 +36,17 @@ LL | |     T: Unsize<U>,\n LL | | {}\n    | |__^\n \n-error: aborting due to 4 previous errors\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for structs containing the field being coerced, ZST fields with 1 byte alignment, and nothing else\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:46:1\n+   |\n+LL | / impl<T: ?Sized, U: ?Sized> DispatchFromDyn<OverAligned<U>> for OverAligned<T>\n+LL | |     where\n+LL | |         T: Unsize<U>,\n+LL | | {}\n+   | |__^\n+   |\n+   = note: extra field `1` of type `OverAlignedZst` is not allowed\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0378`."}, {"sha": "b887f66e94bd6ceff6787c4d30546a3f80eff7c1", "filename": "src/test/ui/lint/deny-overflowing-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x: u8 = 256;\n-    //~^ error: literal out of range for u8\n+    //~^ error: literal out of range for `u8`\n }"}, {"sha": "1263a7bb7fd1b364b2c5799386840ddcc80701c1", "filename": "src/test/ui/lint/deny-overflowing-literals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,4 +1,4 @@\n-error: literal out of range for u8\n+error: literal out of range for `u8`\n   --> $DIR/deny-overflowing-literals.rs:2:17\n    |\n LL |     let x: u8 = 256;"}, {"sha": "7034d56aa5d8350a1c315f1be1927d95901d0492", "filename": "src/test/ui/lint/lint-range-endpoint-overflow.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -0,0 +1,17 @@\n+#![deny(overflowing_literals)]\n+\n+fn main() {\n+    let range_a = 0..256; //~ ERROR range endpoint is out of range for `u8`\n+    let range_b = 0..=255; // ok\n+    let range_c = 0..=256; //~ ERROR literal out of range for `u8`\n+    let range_d = 256..5; //~ ERROR literal out of range for `u8`\n+    let range_e = 0..257; //~ ERROR literal out of range for `u8`\n+    let _range_f = 0..256u8;  //~ ERROR range endpoint is out of range for `u8`\n+    let _range_g = 0..128i8;  //~ ERROR range endpoint is out of range for `i8`\n+\n+    range_a.collect::<Vec<u8>>();\n+    range_b.collect::<Vec<u8>>();\n+    range_c.collect::<Vec<u8>>();\n+    range_d.collect::<Vec<u8>>();\n+    range_e.collect::<Vec<u8>>();\n+}"}, {"sha": "939451d6bc022edd6446e76b6e08f73f251e0d5a", "filename": "src/test/ui/lint/lint-range-endpoint-overflow.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -0,0 +1,44 @@\n+error: range endpoint is out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:4:19\n+   |\n+LL |     let range_a = 0..256;\n+   |                   ^^^^^^ help: use an inclusive range instead: `0..=255`\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-range-endpoint-overflow.rs:1:9\n+   |\n+LL | #![deny(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:6:23\n+   |\n+LL |     let range_c = 0..=256;\n+   |                       ^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:7:19\n+   |\n+LL |     let range_d = 256..5;\n+   |                   ^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:8:22\n+   |\n+LL |     let range_e = 0..257;\n+   |                      ^^^\n+\n+error: range endpoint is out of range for `u8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:9:20\n+   |\n+LL |     let _range_f = 0..256u8;\n+   |                    ^^^^^^^^ help: use an inclusive range instead: `0..=255u8`\n+\n+error: range endpoint is out of range for `i8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:10:20\n+   |\n+LL |     let _range_g = 0..128i8;\n+   |                    ^^^^^^^^ help: use an inclusive range instead: `0..=127i8`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "3f90119cd89543d8d39ba015a3802be2c8c485cf", "filename": "src/test/ui/lint/lint-type-limits2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -11,5 +11,5 @@ fn bar() -> i8 {\n \n fn baz() -> bool {\n     128 > bar() //~ ERROR comparison is useless due to type limits\n-                //~| WARN literal out of range for i8\n+                //~| WARN literal out of range for `i8`\n }"}, {"sha": "0b3d292856707cf3097980f1899903b147fc0409", "filename": "src/test/ui/lint/lint-type-limits2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -6,7 +6,7 @@ LL |     128 > bar()\n    |\n    = note: requested on the command line with `-D unused-comparisons`\n \n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/lint-type-limits2.rs:13:5\n    |\n LL |     128 > bar()"}, {"sha": "ceecf9ab30bb8f0b82cdf4d50115dc0069ac7d64", "filename": "src/test/ui/lint/lint-type-limits3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -7,7 +7,7 @@ fn main() { }\n fn qux() {\n     let mut i = 1i8;\n     while 200 != i { //~ ERROR comparison is useless due to type limits\n-                     //~| WARN literal out of range for i8\n+                     //~| WARN literal out of range for `i8`\n         i += 1;\n     }\n }"}, {"sha": "70cd9c859ecf30d9d248080267b89ddba6b700d9", "filename": "src/test/ui/lint/lint-type-limits3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -6,7 +6,7 @@ LL |     while 200 != i {\n    |\n    = note: requested on the command line with `-D unused-comparisons`\n \n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/lint-type-limits3.rs:9:11\n    |\n LL |     while 200 != i {"}, {"sha": "9672da6d3586cdac57cc37b40e0f8db8a4f3d49c", "filename": "src/test/ui/lint/lint-type-overflow.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,5 +1,3 @@\n-//\n-\n #![deny(overflowing_literals)]\n \n fn test(x: i8) {\n@@ -9,39 +7,39 @@ fn test(x: i8) {\n #[allow(unused_variables)]\n fn main() {\n     let x1: u8 = 255; // should be OK\n-    let x1: u8 = 256; //~ error: literal out of range for u8\n+    let x1: u8 = 256; //~ error: literal out of range for `u8`\n \n     let x1 = 255_u8; // should be OK\n-    let x1 = 256_u8; //~ error: literal out of range for u8\n+    let x1 = 256_u8; //~ error: literal out of range for `u8`\n \n     let x2: i8 = -128; // should be OK\n-    let x1: i8 = 128; //~ error: literal out of range for i8\n+    let x1: i8 = 128; //~ error: literal out of range for `i8`\n \n-    let x3: i8 = -129; //~ error: literal out of range for i8\n-    let x3: i8 = -(129); //~ error: literal out of range for i8\n-    let x3: i8 = -{129}; //~ error: literal out of range for i8\n+    let x3: i8 = -129; //~ error: literal out of range for `i8`\n+    let x3: i8 = -(129); //~ error: literal out of range for `i8`\n+    let x3: i8 = -{129}; //~ error: literal out of range for `i8`\n \n-    test(1000); //~ error: literal out of range for i8\n+    test(1000); //~ error: literal out of range for `i8`\n \n-    let x = 128_i8; //~ error: literal out of range for i8\n+    let x = 128_i8; //~ error: literal out of range for `i8`\n     let x = 127_i8;\n     let x = -128_i8;\n     let x = -(128_i8);\n-    let x = -129_i8; //~ error: literal out of range for i8\n+    let x = -129_i8; //~ error: literal out of range for `i8`\n \n     let x: i32 = 2147483647; // should be OK\n     let x = 2147483647_i32; // should be OK\n-    let x: i32 = 2147483648; //~ error: literal out of range for i32\n-    let x = 2147483648_i32; //~ error: literal out of range for i32\n+    let x: i32 = 2147483648; //~ error: literal out of range for `i32`\n+    let x = 2147483648_i32; //~ error: literal out of range for `i32`\n     let x: i32 = -2147483648; // should be OK\n     let x = -2147483648_i32; // should be OK\n-    let x: i32 = -2147483649; //~ error: literal out of range for i32\n-    let x = -2147483649_i32; //~ error: literal out of range for i32\n-    let x = 2147483648; //~ error: literal out of range for i32\n+    let x: i32 = -2147483649; //~ error: literal out of range for `i32`\n+    let x = -2147483649_i32; //~ error: literal out of range for `i32`\n+    let x = 2147483648; //~ error: literal out of range for `i32`\n \n-    let x = 9223372036854775808_i64; //~ error: literal out of range for i64\n+    let x = 9223372036854775808_i64; //~ error: literal out of range for `i64`\n     let x = -9223372036854775808_i64; // should be OK\n-    let x = 18446744073709551615_i64; //~ error: literal out of range for i64\n-    let x: i64 = -9223372036854775809; //~ error: literal out of range for i64\n-    let x = -9223372036854775809_i64; //~ error: literal out of range for i64\n+    let x = 18446744073709551615_i64; //~ error: literal out of range for `i64`\n+    let x: i64 = -9223372036854775809; //~ error: literal out of range for `i64`\n+    let x = -9223372036854775809_i64; //~ error: literal out of range for `i64`\n }"}, {"sha": "6fcd9b58b2dc766665996364f72f749a0693d712", "filename": "src/test/ui/lint/lint-type-overflow.stderr", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,113 +1,113 @@\n-error: literal out of range for u8\n-  --> $DIR/lint-type-overflow.rs:12:18\n+error: literal out of range for `u8`\n+  --> $DIR/lint-type-overflow.rs:10:18\n    |\n LL |     let x1: u8 = 256;\n    |                  ^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-type-overflow.rs:3:9\n+  --> $DIR/lint-type-overflow.rs:1:9\n    |\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for u8\n-  --> $DIR/lint-type-overflow.rs:15:14\n+error: literal out of range for `u8`\n+  --> $DIR/lint-type-overflow.rs:13:14\n    |\n LL |     let x1 = 256_u8;\n    |              ^^^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:18:18\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:16:18\n    |\n LL |     let x1: i8 = 128;\n    |                  ^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:20:19\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:18:19\n    |\n LL |     let x3: i8 = -129;\n    |                   ^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:21:19\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:19:19\n    |\n LL |     let x3: i8 = -(129);\n    |                   ^^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:22:20\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:20:20\n    |\n LL |     let x3: i8 = -{129};\n    |                    ^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:24:10\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:22:10\n    |\n LL |     test(1000);\n    |          ^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:26:13\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:24:13\n    |\n LL |     let x = 128_i8;\n    |             ^^^^^^\n \n-error: literal out of range for i8\n-  --> $DIR/lint-type-overflow.rs:30:14\n+error: literal out of range for `i8`\n+  --> $DIR/lint-type-overflow.rs:28:14\n    |\n LL |     let x = -129_i8;\n    |              ^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:34:18\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:32:18\n    |\n LL |     let x: i32 = 2147483648;\n    |                  ^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:35:13\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:33:13\n    |\n LL |     let x = 2147483648_i32;\n    |             ^^^^^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:38:19\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:36:19\n    |\n LL |     let x: i32 = -2147483649;\n    |                   ^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:39:14\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:37:14\n    |\n LL |     let x = -2147483649_i32;\n    |              ^^^^^^^^^^^^^^\n \n-error: literal out of range for i32\n-  --> $DIR/lint-type-overflow.rs:40:13\n+error: literal out of range for `i32`\n+  --> $DIR/lint-type-overflow.rs:38:13\n    |\n LL |     let x = 2147483648;\n    |             ^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:42:13\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:40:13\n    |\n LL |     let x = 9223372036854775808_i64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:44:13\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:42:13\n    |\n LL |     let x = 18446744073709551615_i64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:45:19\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:43:19\n    |\n LL |     let x: i64 = -9223372036854775809;\n    |                   ^^^^^^^^^^^^^^^^^^^\n \n-error: literal out of range for i64\n-  --> $DIR/lint-type-overflow.rs:46:14\n+error: literal out of range for `i64`\n+  --> $DIR/lint-type-overflow.rs:44:14\n    |\n LL |     let x = -9223372036854775809_i64;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c76e9e25d5a93207b554e968db811c186d326f38", "filename": "src/test/ui/lint/lint-type-overflow2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-overflow2.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,4 +1,4 @@\n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/lint-type-overflow2.rs:9:20\n    |\n LL |     let x2: i8 = --128;\n@@ -10,25 +10,25 @@ note: lint level defined here\n LL | #![warn(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f32\n+warning: literal out of range for `f32`\n   --> $DIR/lint-type-overflow2.rs:11:14\n    |\n LL |     let x = -3.40282357e+38_f32;\n    |              ^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f32\n+warning: literal out of range for `f32`\n   --> $DIR/lint-type-overflow2.rs:12:14\n    |\n LL |     let x =  3.40282357e+38_f32;\n    |              ^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f64\n+warning: literal out of range for `f64`\n   --> $DIR/lint-type-overflow2.rs:13:14\n    |\n LL |     let x = -1.7976931348623159e+308_f64;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: literal out of range for f64\n+warning: literal out of range for `f64`\n   --> $DIR/lint-type-overflow2.rs:14:14\n    |\n LL |     let x =  1.7976931348623159e+308_f64;"}, {"sha": "dabfb876fbb924b53b262bd487114bb0b3b85f6e", "filename": "src/test/ui/lint/type-overflow.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -1,4 +1,4 @@\n-warning: literal out of range for i8\n+warning: literal out of range for `i8`\n   --> $DIR/type-overflow.rs:5:17\n    |\n LL |     let error = 255i8;"}, {"sha": "5f1f9b3a7f2299ce9d12133785edfe5583a61802", "filename": "src/test/ui/nll/local-outlives-static-via-hrtb.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.rs?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -0,0 +1,26 @@\n+// Test that we handle the case when a local variable is borrowed for `'static`\n+// due to an outlives constraint involving a region in an incompatible universe\n+\n+pub trait Outlives<'this> {}\n+\n+impl<'this, T> Outlives<'this> for T where T: 'this {}\n+trait Reference {\n+    type AssociatedType;\n+}\n+\n+impl<'a, T: 'a> Reference for &'a T {\n+    type AssociatedType = &'a ();\n+}\n+\n+fn assert_static_via_hrtb<G>(_: G) where for<'a> G: Outlives<'a> {}\n+\n+fn assert_static_via_hrtb_with_assoc_type<T>(_: &'_ T)\n+where\n+    for<'a> &'a T: Reference<AssociatedType = &'a ()>,\n+{}\n+\n+fn main() {\n+    let local = 0;\n+    assert_static_via_hrtb(&local); //~ ERROR `local` does not live long enough\n+    assert_static_via_hrtb_with_assoc_type(&&local); //~ ERROR `local` does not live long enough\n+}"}, {"sha": "61009da49ffed8d5b5f0019b6f45c7865913a715", "filename": "src/test/ui/nll/local-outlives-static-via-hrtb.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b67bd42b7cbf97f72d039afcba02f5177d0d68c/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr?ref=9b67bd42b7cbf97f72d039afcba02f5177d0d68c", "patch": "@@ -0,0 +1,26 @@\n+error[E0597]: `local` does not live long enough\n+  --> $DIR/local-outlives-static-via-hrtb.rs:24:28\n+   |\n+LL |     assert_static_via_hrtb(&local);\n+   |     -----------------------^^^^^^-\n+   |     |                      |\n+   |     |                      borrowed value does not live long enough\n+   |     argument requires that `local` is borrowed for `'static`\n+LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n+LL | }\n+   | - `local` dropped here while still borrowed\n+\n+error[E0597]: `local` does not live long enough\n+  --> $DIR/local-outlives-static-via-hrtb.rs:25:45\n+   |\n+LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n+   |     ----------------------------------------^^^^^^-\n+   |     |                                       |\n+   |     |                                       borrowed value does not live long enough\n+   |     argument requires that `local` is borrowed for `'static`\n+LL | }\n+   | - `local` dropped here while still borrowed\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}