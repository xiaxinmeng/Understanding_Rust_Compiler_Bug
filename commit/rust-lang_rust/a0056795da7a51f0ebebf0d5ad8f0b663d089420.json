{"sha": "a0056795da7a51f0ebebf0d5ad8f0b663d089420", "node_id": "C_kwDOAAsO6NoAKGEwMDU2Nzk1ZGE3YTUxZjBlYmViZjBkNWFkOGYwYjY2M2QwODk0MjA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-03T05:03:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-03T05:03:05Z"}, "message": "Rollup merge of #100928 - CleanCut:rustc_metadata_diagnostics, r=davidtwco\n\nMigrate rustc_metadata to SessionDiagnostics\n\nMigrate rustc_metadata to SessionDiagnostics.\n\nPart of https://github.com/rust-lang/rust/issues/100717", "tree": {"sha": "fcbeee4805d8b23bdbbe9b39425d28a45446ff2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcbeee4805d8b23bdbbe9b39425d28a45446ff2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0056795da7a51f0ebebf0d5ad8f0b663d089420", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjEuAJCRBK7hj4Ov3rIwAAGIEIAARiJYL1RchzmzeRdeb4Qrr+\n1G3EkCpY+nrSPlGHXtWO8XRluTCC4GkvfOrwqA9v3q6xVx0iZkVug6CVlrpg0ZTi\nDnkPwEfUGP3EuT/5VBy5sLCIpENjAtvU7J9fwJ8ZVTCNtR6tuYzgnDiPiiyBglLe\nn7SjJxRfufMZKtUve52w5vK04XJspf5F7RyQxrsjFzeP09ThoRU9hQJdvtGxcPB8\n3B8k+plvHZUpDpfBfaAUijcy6h0lEWBQoET/SONlw6IKiXY/IDYACguN8QMuHyzM\n57rbmipoglTaMVvGiggGIvjNSHjjTo9FElTEo8FlA9txPPToa/g650EiRUaUkW4=\n=pnrj\n-----END PGP SIGNATURE-----\n", "payload": "tree fcbeee4805d8b23bdbbe9b39425d28a45446ff2a\nparent 2ed716a81d36c0779bb132031fc9ef0b9e7f4212\nparent 30adfd6a17bd0d7c4d1302cc4a0f92962577de4a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1662181385 +0530\ncommitter GitHub <noreply@github.com> 1662181385 +0530\n\nRollup merge of #100928 - CleanCut:rustc_metadata_diagnostics, r=davidtwco\n\nMigrate rustc_metadata to SessionDiagnostics\n\nMigrate rustc_metadata to SessionDiagnostics.\n\nPart of https://github.com/rust-lang/rust/issues/100717\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0056795da7a51f0ebebf0d5ad8f0b663d089420", "html_url": "https://github.com/rust-lang/rust/commit/a0056795da7a51f0ebebf0d5ad8f0b663d089420", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0056795da7a51f0ebebf0d5ad8f0b663d089420/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed716a81d36c0779bb132031fc9ef0b9e7f4212", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed716a81d36c0779bb132031fc9ef0b9e7f4212", "html_url": "https://github.com/rust-lang/rust/commit/2ed716a81d36c0779bb132031fc9ef0b9e7f4212"}, {"sha": "30adfd6a17bd0d7c4d1302cc4a0f92962577de4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/30adfd6a17bd0d7c4d1302cc4a0f92962577de4a", "html_url": "https://github.com/rust-lang/rust/commit/30adfd6a17bd0d7c4d1302cc4a0f92962577de4a"}], "stats": {"total": 1648, "additions": 1195, "deletions": 453}, "files": [{"sha": "2d143025241ee92051483a16dfb74464c99339bf", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -3509,6 +3509,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"rustc_target\",\n  \"serde\",\n  \"serde_json\",\n  \"termcolor\","}, {"sha": "00067a1bf6ad72362cffabacaa9b5804c8703f70", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -0,0 +1,272 @@\n+metadata_rlib_required =\n+    crate `{$crate_name}` required to be available in rlib format, but was not found in this form\n+\n+metadata_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+\n+metadata_crate_dep_multiple =\n+    cannot satisfy dependencies so `{$crate_name}` only shows up once\n+    .help = having upstream crates all available in one format will likely make this go away\n+\n+metadata_two_panic_runtimes =\n+    cannot link together two panic runtimes: {$prev_name} and {$cur_name}\n+\n+metadata_bad_panic_strategy =\n+    the linked panic runtime `{$runtime}` is not compiled with this crate's panic strategy `{$strategy}`\n+\n+metadata_required_panic_strategy =\n+    the crate `{$crate_name}` requires panic strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_incompatible_panic_in_drop_strategy =\n+    the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_multiple_names_in_link =\n+    multiple `name` arguments in a single `#[link]` attribute\n+\n+metadata_multiple_kinds_in_link =\n+    multiple `kind` arguments in a single `#[link]` attribute\n+\n+metadata_link_name_form =\n+    link name must be of the form `name = \"string\"`\n+\n+metadata_link_kind_form =\n+    link kind must be of the form `kind = \"string\"`\n+\n+metadata_link_modifiers_form =\n+    link modifiers must be of the form `modifiers = \"string\"`\n+\n+metadata_link_cfg_form =\n+    link cfg must be of the form `cfg(/* predicate */)`\n+\n+metadata_wasm_import_form =\n+    wasm import module must be of the form `wasm_import_module = \"string\"`\n+\n+metadata_empty_link_name =\n+    link name must not be empty\n+    .label = empty link name\n+\n+metadata_link_framework_apple =\n+    link kind `framework` is only supported on Apple targets\n+\n+metadata_framework_only_windows =\n+    link kind `raw-dylib` is only supported on Windows targets\n+\n+metadata_unknown_link_kind =\n+    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n+    .label = unknown link kind\n+\n+metadata_multiple_link_modifiers =\n+    multiple `modifiers` arguments in a single `#[link]` attribute\n+\n+metadata_multiple_cfgs =\n+    multiple `cfg` arguments in a single `#[link]` attribute\n+\n+metadata_link_cfg_single_predicate =\n+    link cfg must have a single predicate argument\n+\n+metadata_multiple_wasm_import =\n+    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n+\n+metadata_unexpected_link_arg =\n+    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n+\n+metadata_invalid_link_modifier =\n+    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n+\n+metadata_multiple_modifiers =\n+    multiple `{$modifier}` modifiers in a single `modifiers` argument\n+\n+metadata_bundle_needs_static =\n+    linking modifier `bundle` is only compatible with `static` linking kind\n+\n+metadata_whole_archive_needs_static =\n+    linking modifier `whole-archive` is only compatible with `static` linking kind\n+\n+metadata_as_needed_compatibility =\n+    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n+\n+metadata_unknown_link_modifier =\n+    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n+\n+metadata_incompatible_wasm_link =\n+    `wasm_import_module` is incompatible with other arguments in `#[link]` attributes\n+\n+metadata_link_requires_name =\n+    `#[link]` attribute requires a `name = \"string\"` argument\n+    .label = missing `name` argument\n+\n+metadata_raw_dylib_no_nul =\n+    link name must not contain NUL characters if link kind is `raw-dylib`\n+\n+metadata_link_ordinal_raw_dylib =\n+    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n+\n+metadata_lib_framework_apple =\n+    library kind `framework` is only supported on Apple targets\n+\n+metadata_empty_renaming_target =\n+    an empty renaming target was specified for library `{$lib_name}`\n+\n+metadata_renaming_no_link =\n+    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n+\n+metadata_multiple_renamings =\n+    multiple renamings were specified for library `{$lib_name}`\n+\n+metadata_no_link_mod_override =\n+    overriding linking modifiers from command line is not supported\n+\n+metadata_unsupported_abi_i686 =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n+\n+metadata_unsupported_abi =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\n+\n+metadata_fail_create_file_encoder =\n+    failed to create file encoder: {$err}\n+\n+metadata_fail_seek_file =\n+    failed to seek the file: {$err}\n+\n+metadata_fail_write_file =\n+    failed to write to the file: {$err}\n+\n+metadata_crate_not_panic_runtime =\n+    the crate `{$crate_name}` is not a panic runtime\n+\n+metadata_no_panic_strategy =\n+    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n+\n+metadata_profiler_builtins_needs_core =\n+    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n+\n+metadata_not_profiler_runtime =\n+    the crate `{$crate_name}` is not a profiler runtime\n+\n+metadata_no_multiple_global_alloc =\n+    cannot define multiple global allocators\n+    .label = cannot define a new global allocator\n+\n+metadata_prev_global_alloc =\n+    previous global allocator defined here\n+\n+metadata_conflicting_global_alloc =\n+    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n+\n+metadata_global_alloc_required =\n+    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+\n+metadata_no_transitive_needs_dep =\n+    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n+\n+metadata_failed_write_error =\n+    failed to write {$filename}: {$err}\n+\n+metadata_failed_create_tempdir =\n+    couldn't create a temp dir: {$err}\n+\n+metadata_failed_create_file =\n+    failed to create the file {$filename}: {$err}\n+\n+metadata_failed_create_encoded_metadata =\n+    failed to create encoded metadata from file: {$err}\n+\n+metadata_non_ascii_name =\n+    cannot load a crate with a non-ascii name `{$crate_name}`\n+\n+metadata_extern_location_not_exist =\n+    extern location for {$crate_name} does not exist: {$location}\n+\n+metadata_extern_location_not_file =\n+    extern location for {$crate_name} is not a file: {$location}\n+\n+metadata_multiple_candidates =\n+    multiple {$flavor} candidates for `{$crate_name}` found\n+\n+metadata_multiple_matching_crates =\n+    multiple matching crates for `{$crate_name}`\n+    .note = candidates:{$candidates}\n+\n+metadata_symbol_conflicts_current =\n+    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n+\n+metadata_symbol_conflicts_others =\n+    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n+\n+metadata_stable_crate_id_collision =\n+    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n+\n+metadata_dl_error =\n+    {$err}\n+\n+metadata_newer_crate_version =\n+    found possibly newer version of crate `{$crate_name}`{$add_info}\n+    .note = perhaps that crate needs to be recompiled?\n+\n+metadata_found_crate_versions =\n+    the following crate versions were found:{$found_crates}\n+\n+metadata_no_crate_with_triple =\n+    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n+\n+metadata_found_staticlib =\n+    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n+    .help = please recompile that crate using --crate-type lib\n+\n+metadata_incompatible_rustc =\n+    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n+    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n+\n+metadata_invalid_meta_files =\n+    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+\n+metadata_cannot_find_crate =\n+    can't find crate for `{$crate_name}`{$add_info}\n+\n+metadata_no_dylib_plugin =\n+    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n+\n+metadata_target_not_installed =\n+    the `{$locator_triple}` target may not be installed\n+\n+metadata_target_no_std_support =\n+    the `{$locator_triple}` target may not support the standard library\n+\n+metadata_consider_downloading_target =\n+    consider downloading the target with `rustup target add {$locator_triple}`\n+\n+metadata_std_required =\n+    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n+\n+metadata_consider_building_std =\n+    consider building the standard library from source with `cargo build -Zbuild-std`\n+\n+metadata_compiler_missing_profiler =\n+    the compiler may have been built without the profiler runtime\n+\n+metadata_install_missing_components =\n+    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n+\n+metadata_cant_find_crate =\n+    can't find crate\n+\n+metadata_crate_location_unknown_type =\n+    extern location for {$crate_name} is of an unknown type: {$path}\n+\n+metadata_lib_filename_form =\n+    file name should be lib*.rlib or {dll_prefix}*.{dll_suffix}\n+\n+metadata_multiple_import_name_type =\n+    multiple `import_name_type` arguments in a single `#[link]` attribute\n+\n+metadata_import_name_type_form =\n+    import name type must be of the form `import_name_type = \"string\"`\n+\n+metadata_import_name_type_x86 =\n+    import name type is only supported on x86\n+\n+metadata_unknown_import_name_type =\n+    unknown import name type `{$import_name_type}`, expected one of: decorated, noprefix, undecorated\n+\n+metadata_import_name_type_raw =\n+    import name type can only be used with link kind `raw-dylib`"}, {"sha": "5281a287b0dbe81f22398144636bbe1cb65d1d94", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -48,6 +48,7 @@ fluent_messages! {\n     infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n+    metadata => \"../locales/en-US/metadata.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\","}, {"sha": "4d207fd17fb2dfb9b2f16d3e9a9fa9f8a2a023f4", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -15,13 +15,14 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+rustc_target = { path = \"../rustc_target\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.9\"\n termize = \"0.1.1\"\n-serde = { version = \"1.0.125\", features = [\"derive\"] }\n+serde = { version = \"1.0.125\", features = [ \"derive\" ] }\n serde_json = \"1.0.59\"\n \n [target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"handleapi\", \"synchapi\", \"winbase\"] }\n+winapi = { version = \"0.3\", features = [ \"handleapi\", \"synchapi\", \"winbase\" ] }"}, {"sha": "a052aaee047567610702f244baf0a1910f193464", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -10,6 +10,7 @@ use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::{edition::Edition, Span, DUMMY_SP};\n+use rustc_target::spec::PanicStrategy;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n@@ -144,6 +145,12 @@ impl IntoDiagnosticArg for usize {\n     }\n }\n \n+impl IntoDiagnosticArg for PanicStrategy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.desc().to_string()))\n+    }\n+}\n+\n impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     fn into(self) -> FluentValue<'source> {\n         match self {"}, {"sha": "cfcceecbef40ee911e04d62d958d4d31076b4169", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -1,5 +1,9 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n+use crate::errors::{\n+    ConflictingGlobalAlloc, CrateNotPanicRuntime, GlobalAllocRequired, NoMultipleGlobalAlloc,\n+    NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n+};\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n@@ -745,15 +749,10 @@ impl<'a> CrateLoader<'a> {\n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n         if !data.is_panic_runtime() {\n-            self.sess.err(&format!(\"the crate `{}` is not a panic runtime\", name));\n+            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name });\n         }\n         if data.required_panic_strategy() != Some(desired_strategy) {\n-            self.sess.err(&format!(\n-                \"the crate `{}` does not have the panic \\\n-                                    strategy `{}`\",\n-                name,\n-                desired_strategy.desc()\n-            ));\n+            self.sess.emit_err(NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n@@ -773,29 +772,22 @@ impl<'a> CrateLoader<'a> {\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n         if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n-            self.sess.err(\n-                \"`profiler_builtins` crate (required by compiler options) \\\n-                        is not compatible with crate attribute `#![no_core]`\",\n-            );\n+            self.sess.emit_err(ProfilerBuiltinsNeedsCore);\n         }\n \n         let Some(cnum) = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit) else { return; };\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n         if !data.is_profiler_runtime() {\n-            self.sess.err(&format!(\"the crate `{}` is not a profiler runtime\", name));\n+            self.sess.emit_err(NotProfilerRuntime { crate_name: name });\n         }\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n         self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess\n-                    .struct_span_err(*span2, \"cannot define multiple global allocators\")\n-                    .span_label(*span2, \"cannot define a new global allocator\")\n-                    .span_label(*span1, \"previous global allocator defined here\")\n-                    .emit();\n+                self.sess.emit_err(NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n@@ -831,11 +823,10 @@ impl<'a> CrateLoader<'a> {\n             if data.has_global_allocator() {\n                 match global_allocator {\n                     Some(other_crate) => {\n-                        self.sess.err(&format!(\n-                        \"the `#[global_allocator]` in {} conflicts with global allocator in: {}\",\n-                        other_crate,\n-                        data.name()\n-                    ));\n+                        self.sess.emit_err(ConflictingGlobalAlloc {\n+                            crate_name: data.name(),\n+                            other_crate_name: other_crate,\n+                        });\n                     }\n                     None => global_allocator = Some(data.name()),\n                 }\n@@ -854,10 +845,7 @@ impl<'a> CrateLoader<'a> {\n         if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n             && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n         {\n-            self.sess.err(\n-                \"no global memory allocator found but one is required; link to std or add \\\n-                 `#[global_allocator]` to a static item that implements the GlobalAlloc trait\",\n-            );\n+            self.sess.emit_err(GlobalAllocRequired);\n         }\n         self.cstore.allocator_kind = Some(AllocatorKind::Default);\n     }\n@@ -881,14 +869,11 @@ impl<'a> CrateLoader<'a> {\n         for dep in self.cstore.crate_dependencies_in_reverse_postorder(krate) {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n-                self.sess.err(&format!(\n-                    \"the crate `{}` cannot depend \\\n-                                        on a crate that needs {}, but \\\n-                                        it depends on `{}`\",\n-                    self.cstore.get_crate_data(krate).name(),\n-                    what,\n-                    data.name()\n-                ));\n+                self.sess.emit_err(NoTransitiveNeedsDep {\n+                    crate_name: self.cstore.get_crate_data(krate).name(),\n+                    needs_crate_name: what,\n+                    deps_crate_name: data.name(),\n+                });\n             }\n         }\n "}, {"sha": "6112ec9e4e948b6b8d01068f57336c7f83d84067", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 21, "deletions": 52, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -52,6 +52,10 @@\n //! than finding a number of solutions (there are normally quite a few).\n \n use crate::creader::CStore;\n+use crate::errors::{\n+    BadPanicStrategy, CrateDepMultiple, IncompatiblePanicInDropStrategy, LibRequired,\n+    RequiredPanicStrategy, RlibRequired, TwoPanicRuntimes,\n+};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::CrateNum;\n@@ -136,11 +140,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n                 if src.rlib.is_some() {\n                     continue;\n                 }\n-                sess.err(&format!(\n-                    \"crate `{}` required to be available in rlib format, \\\n-                                   but was not found in this form\",\n-                    tcx.crate_name(cnum)\n-                ));\n+                sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n             }\n             return Vec::new();\n         }\n@@ -224,12 +224,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                sess.err(&format!(\n-                    \"crate `{}` required to be available in {} format, \\\n-                                   but was not found in this form\",\n-                    tcx.crate_name(cnum),\n-                    kind\n-                ));\n+                sess.emit_err(LibRequired { crate_name: tcx.crate_name(cnum), kind: kind });\n             }\n         }\n     }\n@@ -253,17 +248,7 @@ fn add_library(\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                tcx.sess\n-                    .struct_err(&format!(\n-                        \"cannot satisfy dependencies so `{}` only \\\n-                                              shows up once\",\n-                        tcx.crate_name(cnum)\n-                    ))\n-                    .help(\n-                        \"having upstream crates all available in one format \\\n-                           will likely make this go away\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(CrateDepMultiple { crate_name: tcx.crate_name(cnum) });\n             }\n         }\n         None => {\n@@ -360,11 +345,7 @@ fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n             if let Some((prev, _)) = panic_runtime {\n                 let prev_name = tcx.crate_name(prev);\n                 let cur_name = tcx.crate_name(cnum);\n-                sess.err(&format!(\n-                    \"cannot link together two \\\n-                                   panic runtimes: {} and {}\",\n-                    prev_name, cur_name\n-                ));\n+                sess.emit_err(TwoPanicRuntimes { prev_name, cur_name });\n             }\n             panic_runtime = Some((\n                 cnum,\n@@ -384,13 +365,10 @@ fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n         // First up, validate that our selected panic runtime is indeed exactly\n         // our same strategy.\n         if found_strategy != desired_strategy {\n-            sess.err(&format!(\n-                \"the linked panic runtime `{}` is \\\n-                               not compiled with this crate's \\\n-                               panic strategy `{}`\",\n-                tcx.crate_name(runtime_cnum),\n-                desired_strategy.desc()\n-            ));\n+            sess.emit_err(BadPanicStrategy {\n+                runtime: tcx.crate_name(runtime_cnum),\n+                strategy: desired_strategy,\n+            });\n         }\n \n         // Next up, verify that all other crates are compatible with this panic\n@@ -407,28 +385,19 @@ fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n             }\n \n             if let Some(found_strategy) = tcx.required_panic_strategy(cnum) && desired_strategy != found_strategy {\n-                sess.err(&format!(\n-                    \"the crate `{}` requires \\\n-                               panic strategy `{}` which is \\\n-                               incompatible with this crate's \\\n-                               strategy of `{}`\",\n-                    tcx.crate_name(cnum),\n-                    found_strategy.desc(),\n-                    desired_strategy.desc()\n-                ));\n+                sess.emit_err(RequiredPanicStrategy {\n+                    crate_name: tcx.crate_name(cnum),\n+                    found_strategy,\n+                    desired_strategy});\n             }\n \n             let found_drop_strategy = tcx.panic_in_drop_strategy(cnum);\n             if tcx.sess.opts.unstable_opts.panic_in_drop != found_drop_strategy {\n-                sess.err(&format!(\n-                    \"the crate `{}` is compiled with the \\\n-                               panic-in-drop strategy `{}` which is \\\n-                               incompatible with this crate's \\\n-                               strategy of `{}`\",\n-                    tcx.crate_name(cnum),\n-                    found_drop_strategy.desc(),\n-                    tcx.sess.opts.unstable_opts.panic_in_drop.desc()\n-                ));\n+                sess.emit_err(IncompatiblePanicInDropStrategy {\n+                    crate_name: tcx.crate_name(cnum),\n+                    found_strategy: found_drop_strategy,\n+                    desired_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n+                });\n             }\n         }\n     }"}, {"sha": "18d0248333a510ad7861e4307a95429cc22b2968", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -0,0 +1,672 @@\n+use std::{\n+    io::Error,\n+    path::{Path, PathBuf},\n+};\n+\n+use rustc_errors::{error_code, ErrorGuaranteed};\n+use rustc_macros::SessionDiagnostic;\n+use rustc_session::{config, SessionDiagnostic};\n+use rustc_span::{sym, Span, Symbol};\n+use rustc_target::spec::{PanicStrategy, TargetTriple};\n+\n+use crate::locator::CrateFlavor;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::rlib_required)]\n+pub struct RlibRequired {\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::lib_required)]\n+pub struct LibRequired<'a> {\n+    pub crate_name: Symbol,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::crate_dep_multiple)]\n+#[help]\n+pub struct CrateDepMultiple {\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::two_panic_runtimes)]\n+pub struct TwoPanicRuntimes {\n+    pub prev_name: Symbol,\n+    pub cur_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::bad_panic_strategy)]\n+pub struct BadPanicStrategy {\n+    pub runtime: Symbol,\n+    pub strategy: PanicStrategy,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::required_panic_strategy)]\n+pub struct RequiredPanicStrategy {\n+    pub crate_name: Symbol,\n+    pub found_strategy: PanicStrategy,\n+    pub desired_strategy: PanicStrategy,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::incompatible_panic_in_drop_strategy)]\n+pub struct IncompatiblePanicInDropStrategy {\n+    pub crate_name: Symbol,\n+    pub found_strategy: PanicStrategy,\n+    pub desired_strategy: PanicStrategy,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_names_in_link)]\n+pub struct MultipleNamesInLink {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_kinds_in_link)]\n+pub struct MultipleKindsInLink {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_name_form)]\n+pub struct LinkNameForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_kind_form)]\n+pub struct LinkKindForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_modifiers_form)]\n+pub struct LinkModifiersForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_cfg_form)]\n+pub struct LinkCfgForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::wasm_import_form)]\n+pub struct WasmImportForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::empty_link_name, code = \"E0454\")]\n+pub struct EmptyLinkName {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_framework_apple, code = \"E0455\")]\n+pub struct LinkFrameworkApple {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::framework_only_windows, code = \"E0455\")]\n+pub struct FrameworkOnlyWindows {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unknown_link_kind, code = \"E0458\")]\n+pub struct UnknownLinkKind<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_link_modifiers)]\n+pub struct MultipleLinkModifiers {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_cfgs)]\n+pub struct MultipleCfgs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_cfg_single_predicate)]\n+pub struct LinkCfgSinglePredicate {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_wasm_import)]\n+pub struct MultipleWasmImport {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unexpected_link_arg)]\n+pub struct UnexpectedLinkArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::invalid_link_modifier)]\n+pub struct InvalidLinkModifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_modifiers)]\n+pub struct MultipleModifiers<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub modifier: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::bundle_needs_static)]\n+pub struct BundleNeedsStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::whole_archive_needs_static)]\n+pub struct WholeArchiveNeedsStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::as_needed_compatibility)]\n+pub struct AsNeededCompatibility {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unknown_link_modifier)]\n+pub struct UnknownLinkModifier<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub modifier: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::incompatible_wasm_link)]\n+pub struct IncompatibleWasmLink {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_requires_name, code = \"E0459\")]\n+pub struct LinkRequiresName {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::raw_dylib_no_nul)]\n+pub struct RawDylibNoNul {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_ordinal_raw_dylib)]\n+pub struct LinkOrdinalRawDylib {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::lib_framework_apple)]\n+pub struct LibFrameworkApple;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::empty_renaming_target)]\n+pub struct EmptyRenamingTarget<'a> {\n+    pub lib_name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::renaming_no_link)]\n+pub struct RenamingNoLink<'a> {\n+    pub lib_name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_renamings)]\n+pub struct MultipleRenamings<'a> {\n+    pub lib_name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_link_mod_override)]\n+pub struct NoLinkModOverride {\n+    #[primary_span]\n+    pub span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unsupported_abi_i686)]\n+pub struct UnsupportedAbiI686 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unsupported_abi)]\n+pub struct UnsupportedAbi {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::fail_create_file_encoder)]\n+pub struct FailCreateFileEncoder {\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::fail_seek_file)]\n+pub struct FailSeekFile {\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::fail_write_file)]\n+pub struct FailWriteFile {\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::crate_not_panic_runtime)]\n+pub struct CrateNotPanicRuntime {\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_panic_strategy)]\n+pub struct NoPanicStrategy {\n+    pub crate_name: Symbol,\n+    pub strategy: PanicStrategy,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::profiler_builtins_needs_core)]\n+pub struct ProfilerBuiltinsNeedsCore;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::not_profiler_runtime)]\n+pub struct NotProfilerRuntime {\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_multiple_global_alloc)]\n+pub struct NoMultipleGlobalAlloc {\n+    #[primary_span]\n+    #[label]\n+    pub span2: Span,\n+    #[label(metadata::prev_global_alloc)]\n+    pub span1: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::conflicting_global_alloc)]\n+pub struct ConflictingGlobalAlloc {\n+    pub crate_name: Symbol,\n+    pub other_crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::global_alloc_required)]\n+pub struct GlobalAllocRequired;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_transitive_needs_dep)]\n+pub struct NoTransitiveNeedsDep<'a> {\n+    pub crate_name: Symbol,\n+    pub needs_crate_name: &'a str,\n+    pub deps_crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::failed_write_error)]\n+pub struct FailedWriteError {\n+    pub filename: PathBuf,\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::failed_create_tempdir)]\n+pub struct FailedCreateTempdir {\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::failed_create_file)]\n+pub struct FailedCreateFile<'a> {\n+    pub filename: &'a Path,\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::failed_create_encoded_metadata)]\n+pub struct FailedCreateEncodedMetadata {\n+    pub err: Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::non_ascii_name)]\n+pub struct NonAsciiName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::extern_location_not_exist)]\n+pub struct ExternLocationNotExist<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub location: &'a Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::extern_location_not_file)]\n+pub struct ExternLocationNotFile<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub location: &'a Path,\n+}\n+\n+pub(crate) struct MultipleCandidates {\n+    pub span: Span,\n+    pub flavor: CrateFlavor,\n+    pub crate_name: Symbol,\n+    pub candidates: Vec<PathBuf>,\n+}\n+\n+impl SessionDiagnostic<'_> for MultipleCandidates {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"flavor\", self.flavor);\n+        diag.code(error_code!(E0465));\n+        diag.set_span(self.span);\n+        for (i, candidate) in self.candidates.iter().enumerate() {\n+            diag.span_note(self.span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_matching_crates, code = \"E0464\")]\n+#[note]\n+pub struct MultipleMatchingCrates {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub candidates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::symbol_conflicts_current, code = \"E0519\")]\n+pub struct SymbolConflictsCurrent {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::symbol_conflicts_others, code = \"E0523\")]\n+pub struct SymbolConflictsOthers {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::stable_crate_id_collision)]\n+pub struct StableCrateIdCollision {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name0: Symbol,\n+    pub crate_name1: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::dl_error)]\n+pub struct DlError {\n+    #[primary_span]\n+    pub span: Span,\n+    pub err: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::newer_crate_version, code = \"E0460\")]\n+#[note]\n+#[note(metadata::found_crate_versions)]\n+pub struct NewerCrateVersion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub add_info: String,\n+    pub found_crates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_crate_with_triple, code = \"E0461\")]\n+#[note(metadata::found_crate_versions)]\n+pub struct NoCrateWithTriple<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub locator_triple: &'a str,\n+    pub add_info: String,\n+    pub found_crates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::found_staticlib, code = \"E0462\")]\n+#[note(metadata::found_crate_versions)]\n+#[help]\n+pub struct FoundStaticlib {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub add_info: String,\n+    pub found_crates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::incompatible_rustc, code = \"E0514\")]\n+#[note(metadata::found_crate_versions)]\n+#[help]\n+pub struct IncompatibleRustc {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub add_info: String,\n+    pub found_crates: String,\n+    pub rustc_version: String,\n+}\n+\n+pub struct InvalidMetadataFiles {\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub add_info: String,\n+    pub crate_rejections: Vec<String>,\n+}\n+\n+impl SessionDiagnostic<'_> for InvalidMetadataFiles {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"add_info\", self.add_info);\n+        diag.code(error_code!(E0786));\n+        diag.set_span(self.span);\n+        for crate_rejection in self.crate_rejections {\n+            diag.note(crate_rejection);\n+        }\n+        diag\n+    }\n+}\n+\n+pub struct CannotFindCrate {\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+    pub add_info: String,\n+    pub missing_core: bool,\n+    pub current_crate: String,\n+    pub is_nightly_build: bool,\n+    pub profiler_runtime: Symbol,\n+    pub locator_triple: TargetTriple,\n+}\n+\n+impl SessionDiagnostic<'_> for CannotFindCrate {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"add_info\", self.add_info);\n+        diag.set_arg(\"locator_triple\", self.locator_triple.triple());\n+        diag.code(error_code!(E0463));\n+        diag.set_span(self.span);\n+        if (self.crate_name == sym::std || self.crate_name == sym::core)\n+            && self.locator_triple != TargetTriple::from_triple(config::host_triple())\n+        {\n+            if self.missing_core {\n+                diag.note(rustc_errors::fluent::metadata::target_not_installed);\n+            } else {\n+                diag.note(rustc_errors::fluent::metadata::target_no_std_support);\n+            }\n+            // NOTE: this suggests using rustup, even though the user may not have it installed.\n+            // That's because they could choose to install it; or this may give them a hint which\n+            // target they need to install from their distro.\n+            if self.missing_core {\n+                diag.help(rustc_errors::fluent::metadata::consider_downloading_target);\n+            }\n+            // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n+            // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n+            // If it's not a dummy, that means someone added `extern crate std` explicitly and\n+            // `#![no_std]` won't help.\n+            if !self.missing_core && self.span.is_dummy() {\n+                diag.note(rustc_errors::fluent::metadata::std_required);\n+            }\n+            if self.is_nightly_build {\n+                diag.help(rustc_errors::fluent::metadata::consider_building_std);\n+            }\n+        } else if self.crate_name == self.profiler_runtime {\n+            diag.note(rustc_errors::fluent::metadata::compiler_missing_profiler);\n+        } else if self.crate_name.as_str().starts_with(\"rustc_\") {\n+            diag.help(rustc_errors::fluent::metadata::install_missing_components);\n+        }\n+        diag.span_label(self.span, rustc_errors::fluent::metadata::cant_find_crate);\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_dylib_plugin, code = \"E0457\")]\n+pub struct NoDylibPlugin {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::crate_location_unknown_type)]\n+pub struct CrateLocationUnknownType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path: &'a Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::lib_filename_form)]\n+pub struct LibFilenameForm<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dll_prefix: &'a str,\n+    pub dll_suffix: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_import_name_type)]\n+pub struct MultipleImportNameType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::import_name_type_form)]\n+pub struct ImportNameTypeForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::import_name_type_x86)]\n+pub struct ImportNameTypeX86 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unknown_import_name_type)]\n+pub struct UnknownImportNameType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub import_name_type: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::import_name_type_raw)]\n+pub struct ImportNameTypeRaw {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "f360a586476e70bf4a2e9da3bd4426351d834880", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -1,3 +1,6 @@\n+use crate::errors::{\n+    FailedCreateEncodedMetadata, FailedCreateFile, FailedCreateTempdir, FailedWriteError,\n+};\n use crate::{encode_metadata, EncodedMetadata};\n \n use rustc_data_structures::temp_dir::MaybeTempDir;\n@@ -23,8 +26,8 @@ pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) ->\n     let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, metadata);\n \n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    if let Err(err) = result {\n+        sess.emit_fatal(FailedWriteError { filename: out_filename, err });\n     }\n \n     out_filename\n@@ -65,20 +68,16 @@ pub fn encode_and_write_metadata(\n     let metadata_tmpdir = TempFileBuilder::new()\n         .prefix(\"rmeta\")\n         .tempdir_in(out_filename.parent().unwrap_or_else(|| Path::new(\"\")))\n-        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailedCreateTempdir { err }));\n     let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n     let metadata_filename = metadata_tmpdir.as_ref().join(METADATA_FILENAME);\n \n     // Always create a file at `metadata_filename`, even if we have nothing to write to it.\n     // This simplifies the creation of the output `out_filename` when requested.\n     match metadata_kind {\n         MetadataKind::None => {\n-            std::fs::File::create(&metadata_filename).unwrap_or_else(|e| {\n-                tcx.sess.fatal(&format!(\n-                    \"failed to create the file {}: {}\",\n-                    metadata_filename.display(),\n-                    e\n-                ))\n+            std::fs::File::create(&metadata_filename).unwrap_or_else(|err| {\n+                tcx.sess.emit_fatal(FailedCreateFile { filename: &metadata_filename, err });\n             });\n         }\n         MetadataKind::Uncompressed | MetadataKind::Compressed => {\n@@ -93,8 +92,8 @@ pub fn encode_and_write_metadata(\n     // this file always exists.\n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     let (metadata_filename, metadata_tmpdir) = if need_metadata_file {\n-        if let Err(e) = non_durable_rename(&metadata_filename, &out_filename) {\n-            tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+        if let Err(err) = non_durable_rename(&metadata_filename, &out_filename) {\n+            tcx.sess.emit_fatal(FailedWriteError { filename: out_filename, err });\n         }\n         if tcx.sess.opts.json_artifact_notifications {\n             tcx.sess\n@@ -109,8 +108,8 @@ pub fn encode_and_write_metadata(\n \n     // Load metadata back to memory: codegen may need to include it in object files.\n     let metadata =\n-        EncodedMetadata::from_path(metadata_filename, metadata_tmpdir).unwrap_or_else(|e| {\n-            tcx.sess.fatal(&format!(\"failed to create encoded metadata from file: {}\", e))\n+        EncodedMetadata::from_path(metadata_filename, metadata_tmpdir).unwrap_or_else(|err| {\n+            tcx.sess.emit_fatal(FailedCreateEncodedMetadata { err });\n         });\n \n     let need_metadata_module = metadata_kind == MetadataKind::Compressed;"}, {"sha": "8e0291fc3ad18291ada2d7e141762bb242142bb1", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -16,6 +16,8 @@\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n extern crate proc_macro;\n \n@@ -37,6 +39,7 @@ mod native_libs;\n mod rmeta;\n \n pub mod creader;\n+pub mod errors;\n pub mod fs;\n pub mod locator;\n "}, {"sha": "35f9ef92a1c425fb74eb8b4866ee187df9b27957", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 122, "deletions": 206, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -213,25 +213,33 @@\n //! metadata::locator or metadata::creader for all the juicy details!\n \n use crate::creader::Library;\n+use crate::errors::{\n+    CannotFindCrate, CrateLocationUnknownType, DlError, ExternLocationNotExist,\n+    ExternLocationNotFile, FoundStaticlib, IncompatibleRustc, InvalidMetadataFiles,\n+    LibFilenameForm, MultipleCandidates, MultipleMatchingCrates, NewerCrateVersion,\n+    NoCrateWithTriple, NoDylibPlugin, NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent,\n+    SymbolConflictsOthers,\n+};\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_errors::{struct_span_err, FatalError};\n+use rustc_errors::{DiagnosticArgValue, FatalError, IntoDiagnosticArg};\n use rustc_session::config::{self, CrateType};\n use rustc_session::cstore::{CrateSource, MetadataLoader};\n use rustc_session::filesearch::FileSearch;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::CanonicalizedPath;\n use rustc_session::Session;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n \n use snap::read::FrameDecoder;\n+use std::borrow::Cow;\n use std::fmt::Write as _;\n use std::io::{Read, Result as IoResult, Write};\n use std::path::{Path, PathBuf};\n@@ -287,6 +295,16 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n+impl IntoDiagnosticArg for CrateFlavor {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        match self {\n+            CrateFlavor::Rlib => DiagnosticArgValue::Str(Cow::Borrowed(\"rlib\")),\n+            CrateFlavor::Rmeta => DiagnosticArgValue::Str(Cow::Borrowed(\"rmeta\")),\n+            CrateFlavor::Dylib => DiagnosticArgValue::Str(Cow::Borrowed(\"dylib\")),\n+        }\n+    }\n+}\n+\n impl<'a> CrateLocator<'a> {\n     pub(crate) fn new(\n         sess: &'a Session,\n@@ -937,41 +955,20 @@ impl fmt::Display for MetadataError<'_> {\n \n impl CrateError {\n     pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n-        let mut diag = match self {\n-            CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n-                span,\n-                &format!(\"cannot load a crate with a non-ascii name `{}`\", crate_name),\n-            ),\n-            CrateError::ExternLocationNotExist(crate_name, loc) => sess.struct_span_err(\n-                span,\n-                &format!(\"extern location for {} does not exist: {}\", crate_name, loc.display()),\n-            ),\n-            CrateError::ExternLocationNotFile(crate_name, loc) => sess.struct_span_err(\n-                span,\n-                &format!(\"extern location for {} is not a file: {}\", crate_name, loc.display()),\n-            ),\n+        match self {\n+            CrateError::NonAsciiName(crate_name) => {\n+                sess.emit_err(NonAsciiName { span, crate_name });\n+            }\n+            CrateError::ExternLocationNotExist(crate_name, loc) => {\n+                sess.emit_err(ExternLocationNotExist { span, crate_name, location: &loc });\n+            }\n+            CrateError::ExternLocationNotFile(crate_name, loc) => {\n+                sess.emit_err(ExternLocationNotFile { span, crate_name, location: &loc });\n+            }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                let mut err = struct_span_err!(\n-                    sess,\n-                    span,\n-                    E0465,\n-                    \"multiple {} candidates for `{}` found\",\n-                    flavor,\n-                    crate_name,\n-                );\n-                for (i, candidate) in candidates.iter().enumerate() {\n-                    err.span_note(span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n-                }\n-                err\n+                sess.emit_err(MultipleCandidates { span, flavor: flavor, crate_name, candidates });\n             }\n             CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n-                let mut err = struct_span_err!(\n-                    sess,\n-                    span,\n-                    E0464,\n-                    \"multiple matching crates for `{}`\",\n-                    crate_name\n-                );\n                 let mut libraries: Vec<_> = libraries.into_values().collect();\n                 // Make ordering of candidates deterministic.\n                 // This has to `clone()` to work around lifetime restrictions with `sort_by_key()`.\n@@ -999,223 +996,142 @@ impl CrateError {\n                         s\n                     })\n                     .collect::<String>();\n-                err.note(&format!(\"candidates:{}\", candidates));\n-                err\n+                sess.emit_err(MultipleMatchingCrates { span, crate_name, candidates });\n+            }\n+            CrateError::SymbolConflictsCurrent(root_name) => {\n+                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name });\n+            }\n+            CrateError::SymbolConflictsOthers(root_name) => {\n+                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n             }\n-            CrateError::SymbolConflictsCurrent(root_name) => struct_span_err!(\n-                sess,\n-                span,\n-                E0519,\n-                \"the current crate is indistinguishable from one of its dependencies: it has the \\\n-                 same crate-name `{}` and was compiled with the same `-C metadata` arguments. \\\n-                 This will result in symbol conflicts between the two.\",\n-                root_name,\n-            ),\n-            CrateError::SymbolConflictsOthers(root_name) => struct_span_err!(\n-                sess,\n-                span,\n-                E0523,\n-                \"found two different crates with name `{}` that are not distinguished by differing \\\n-                 `-C metadata`. This will result in symbol conflicts between the two.\",\n-                root_name,\n-            ),\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                let msg = format!(\n-                    \"found crates (`{}` and `{}`) with colliding StableCrateId values.\",\n-                    crate_name0, crate_name1\n-                );\n-                sess.struct_span_err(span, &msg)\n+                sess.emit_err(StableCrateIdCollision {\n+                    span,\n+                    crate_name0: crate_name0,\n+                    crate_name1: crate_name1,\n+                });\n+            }\n+            CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n+                sess.emit_err(DlError { span, err: s });\n             }\n-            CrateError::DlOpen(s) | CrateError::DlSym(s) => sess.struct_span_err(span, &s),\n             CrateError::LocatorCombined(locator) => {\n                 let crate_name = locator.crate_name;\n-                let add = match &locator.root {\n+                let add_info = match &locator.root {\n                     None => String::new(),\n                     Some(r) => format!(\" which `{}` depends on\", r.name),\n                 };\n-                let mut msg = \"the following crate versions were found:\".to_string();\n-                let mut err = if !locator.crate_rejections.via_hash.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n-                        span,\n-                        E0460,\n-                        \"found possibly newer version of crate `{}`{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-                    err.note(\"perhaps that crate needs to be recompiled?\");\n+                // FIXME: There are no tests for CrateLocationUnknownType or LibFilenameForm\n+                if !locator.crate_rejections.via_filename.is_empty() {\n+                    let mismatches = locator.crate_rejections.via_filename.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        sess.emit_err(CrateLocationUnknownType { span, path: &path });\n+                        sess.emit_err(LibFilenameForm {\n+                            span,\n+                            dll_prefix: &locator.dll_prefix,\n+                            dll_suffix: &locator.dll_suffix,\n+                        });\n+                    }\n+                }\n+                let mut found_crates = String::new();\n+                if !locator.crate_rejections.via_hash.is_empty() {\n                     let mismatches = locator.crate_rejections.via_hash.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                        found_crates.push_str(&format!(\n+                            \"\\ncrate `{}`: {}\",\n+                            crate_name,\n+                            path.display()\n+                        ));\n                     }\n                     if let Some(r) = locator.root {\n                         for path in r.source.paths() {\n-                            msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n+                            found_crates.push_str(&format!(\n+                                \"\\ncrate `{}`: {}\",\n+                                r.name,\n+                                path.display()\n+                            ));\n                         }\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_triple.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(NewerCrateVersion {\n                         span,\n-                        E0461,\n-                        \"couldn't find crate `{}` with expected target triple {}{}\",\n-                        crate_name,\n-                        locator.triple,\n-                        add,\n-                    );\n+                        crate_name: crate_name,\n+                        add_info,\n+                        found_crates,\n+                    });\n+                } else if !locator.crate_rejections.via_triple.is_empty() {\n                     let mismatches = locator.crate_rejections.via_triple.iter();\n                     for CrateMismatch { path, got } in mismatches {\n-                        msg.push_str(&format!(\n+                        found_crates.push_str(&format!(\n                             \"\\ncrate `{}`, target triple {}: {}\",\n                             crate_name,\n                             got,\n                             path.display(),\n                         ));\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_kind.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(NoCrateWithTriple {\n                         span,\n-                        E0462,\n-                        \"found staticlib `{}` instead of rlib or dylib{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-                    err.help(\"please recompile that crate using --crate-type lib\");\n+                        crate_name: crate_name,\n+                        locator_triple: locator.triple.triple(),\n+                        add_info,\n+                        found_crates,\n+                    });\n+                } else if !locator.crate_rejections.via_kind.is_empty() {\n                     let mismatches = locator.crate_rejections.via_kind.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                        found_crates.push_str(&format!(\n+                            \"\\ncrate `{}`: {}\",\n+                            crate_name,\n+                            path.display()\n+                        ));\n                     }\n-                    err.note(&msg);\n-                    err\n+                    sess.emit_err(FoundStaticlib { span, crate_name, add_info, found_crates });\n                 } else if !locator.crate_rejections.via_version.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n-                        span,\n-                        E0514,\n-                        \"found crate `{}` compiled by an incompatible version of rustc{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-                    err.help(&format!(\n-                        \"please recompile that crate using this compiler ({}) \\\n-                         (consider running `cargo clean` first)\",\n-                        rustc_version(),\n-                    ));\n                     let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n-                        msg.push_str(&format!(\n+                        found_crates.push_str(&format!(\n                             \"\\ncrate `{}` compiled by {}: {}\",\n                             crate_name,\n                             got,\n                             path.display(),\n                         ));\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_invalid.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(IncompatibleRustc {\n                         span,\n-                        E0786,\n-                        \"found invalid metadata files for crate `{}`{}\",\n                         crate_name,\n-                        add,\n-                    );\n+                        add_info,\n+                        found_crates,\n+                        rustc_version: rustc_version(),\n+                    });\n+                } else if !locator.crate_rejections.via_invalid.is_empty() {\n+                    let mut crate_rejections = Vec::new();\n                     for CrateMismatch { path: _, got } in locator.crate_rejections.via_invalid {\n-                        err.note(&got);\n+                        crate_rejections.push(got);\n                     }\n-                    err\n+                    sess.emit_err(InvalidMetadataFiles {\n+                        span,\n+                        crate_name,\n+                        add_info,\n+                        crate_rejections,\n+                    });\n                 } else {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(CannotFindCrate {\n                         span,\n-                        E0463,\n-                        \"can't find crate for `{}`{}\",\n                         crate_name,\n-                        add,\n-                    );\n-\n-                    if (crate_name == sym::std || crate_name == sym::core)\n-                        && locator.triple != TargetTriple::from_triple(config::host_triple())\n-                    {\n-                        if missing_core {\n-                            err.note(&format!(\n-                                \"the `{}` target may not be installed\",\n-                                locator.triple\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"the `{}` target may not support the standard library\",\n-                                locator.triple\n-                            ));\n-                        }\n-                        // NOTE: this suggests using rustup, even though the user may not have it installed.\n-                        // That's because they could choose to install it; or this may give them a hint which\n-                        // target they need to install from their distro.\n-                        if missing_core {\n-                            err.help(&format!(\n-                                \"consider downloading the target with `rustup target add {}`\",\n-                                locator.triple\n-                            ));\n-                        }\n-                        // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n-                        // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n-                        // If it's not a dummy, that means someone added `extern crate std` explicitly and `#![no_std]` won't help.\n-                        if !missing_core && span.is_dummy() {\n-                            let current_crate =\n-                                sess.opts.crate_name.as_deref().unwrap_or(\"<unknown>\");\n-                            err.note(&format!(\n-                                \"`std` is required by `{}` because it does not declare `#![no_std]`\",\n-                                current_crate\n-                            ));\n-                        }\n-                        if sess.is_nightly_build() {\n-                            err.help(\"consider building the standard library from source with `cargo build -Zbuild-std`\");\n-                        }\n-                    } else if crate_name\n-                        == Symbol::intern(&sess.opts.unstable_opts.profiler_runtime)\n-                    {\n-                        err.note(\"the compiler may have been built without the profiler runtime\");\n-                    } else if crate_name.as_str().starts_with(\"rustc_\") {\n-                        err.help(\n-                            \"maybe you need to install the missing components with: \\\n-                             `rustup component add rust-src rustc-dev llvm-tools-preview`\",\n-                        );\n-                    }\n-                    err.span_label(span, \"can't find crate\");\n-                    err\n-                };\n-\n-                if !locator.crate_rejections.via_filename.is_empty() {\n-                    let mismatches = locator.crate_rejections.via_filename.iter();\n-                    for CrateMismatch { path, .. } in mismatches {\n-                        err.note(&format!(\n-                            \"extern location for {} is of an unknown type: {}\",\n-                            crate_name,\n-                            path.display(),\n-                        ))\n-                        .help(&format!(\n-                            \"file name should be lib*.rlib or {}*.{}\",\n-                            locator.dll_prefix, locator.dll_suffix\n-                        ));\n-                    }\n+                        add_info,\n+                        missing_core,\n+                        current_crate: sess\n+                            .opts\n+                            .crate_name\n+                            .clone()\n+                            .unwrap_or(\"<unknown>\".to_string()),\n+                        is_nightly_build: sess.is_nightly_build(),\n+                        profiler_runtime: Symbol::intern(&sess.opts.unstable_opts.profiler_runtime),\n+                        locator_triple: locator.triple,\n+                    });\n                 }\n-                err\n             }\n-            CrateError::NonDylibPlugin(crate_name) => struct_span_err!(\n-                sess,\n-                span,\n-                E0457,\n-                \"plugin `{}` only found in rlib format, but must be available in dylib format\",\n-                crate_name,\n-            ),\n-        };\n-\n-        diag.emit();\n+            CrateError::NonDylibPlugin(crate_name) => {\n+                sess.emit_err(NoDylibPlugin { span, crate_name });\n+            }\n+        }\n     }\n }"}, {"sha": "87b5e750f1cb14fba7110775e572e53af2aa34ae", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 58, "deletions": 143, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -1,7 +1,6 @@\n use rustc_ast::{NestedMetaItem, CRATE_NODE_ID};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_middle::ty::{List, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n@@ -12,6 +11,18 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n+use crate::errors::{\n+    AsNeededCompatibility, BundleNeedsStatic, EmptyLinkName, EmptyRenamingTarget,\n+    FrameworkOnlyWindows, ImportNameTypeForm, ImportNameTypeRaw, ImportNameTypeX86,\n+    IncompatibleWasmLink, InvalidLinkModifier, LibFrameworkApple, LinkCfgForm,\n+    LinkCfgSinglePredicate, LinkFrameworkApple, LinkKindForm, LinkModifiersForm, LinkNameForm,\n+    LinkOrdinalRawDylib, LinkRequiresName, MultipleCfgs, MultipleImportNameType,\n+    MultipleKindsInLink, MultipleLinkModifiers, MultipleModifiers, MultipleNamesInLink,\n+    MultipleRenamings, MultipleWasmImport, NoLinkModOverride, RawDylibNoNul, RenamingNoLink,\n+    UnexpectedLinkArg, UnknownImportNameType, UnknownLinkKind, UnknownLinkModifier, UnsupportedAbi,\n+    UnsupportedAbiI686, WasmImportForm, WholeArchiveNeedsStatic,\n+};\n+\n pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n     for id in tcx.hir().items() {\n@@ -66,32 +77,26 @@ impl<'tcx> Collector<'tcx> {\n                 match item.name_or_empty() {\n                     sym::name => {\n                         if name.is_some() {\n-                            let msg = \"multiple `name` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleNamesInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_name) = item.value_str() else {\n-                            let msg = \"link name must be of the form `name = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkNameForm { span: item.span() });\n                             continue;\n                         };\n                         let span = item.name_value_literal_span().unwrap();\n                         if link_name.is_empty() {\n-                            struct_span_err!(sess, span, E0454, \"link name must not be empty\")\n-                                .span_label(span, \"empty link name\")\n-                                .emit();\n+                            sess.emit_err(EmptyLinkName { span });\n                         }\n                         name = Some((link_name, span));\n                     }\n                     sym::kind => {\n                         if kind.is_some() {\n-                            let msg = \"multiple `kind` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleKindsInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_kind) = item.value_str() else {\n-                            let msg = \"link kind must be of the form `kind = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkKindForm { span: item.span() });\n                             continue;\n                         };\n \n@@ -101,25 +106,13 @@ impl<'tcx> Collector<'tcx> {\n                             \"dylib\" => NativeLibKind::Dylib { as_needed: None },\n                             \"framework\" => {\n                                 if !sess.target.is_like_osx {\n-                                    struct_span_err!(\n-                                        sess,\n-                                        span,\n-                                        E0455,\n-                                        \"link kind `framework` is only supported on Apple targets\"\n-                                    )\n-                                    .emit();\n+                                    sess.emit_err(LinkFrameworkApple { span });\n                                 }\n                                 NativeLibKind::Framework { as_needed: None }\n                             }\n                             \"raw-dylib\" => {\n                                 if !sess.target.is_like_windows {\n-                                    struct_span_err!(\n-                                        sess,\n-                                        span,\n-                                        E0455,\n-                                        \"link kind `raw-dylib` is only supported on Windows targets\"\n-                                    )\n-                                    .emit();\n+                                    sess.emit_err(FrameworkOnlyWindows { span });\n                                 } else if !features.raw_dylib {\n                                     feature_err(\n                                         &sess.parse_sess,\n@@ -132,46 +125,34 @@ impl<'tcx> Collector<'tcx> {\n                                 NativeLibKind::RawDylib\n                             }\n                             kind => {\n-                                let msg = format!(\n-                                    \"unknown link kind `{kind}`, expected one of: \\\n-                                     static, dylib, framework, raw-dylib\"\n-                                );\n-                                struct_span_err!(sess, span, E0458, \"{}\", msg)\n-                                    .span_label(span, \"unknown link kind\")\n-                                    .emit();\n+                                sess.emit_err(UnknownLinkKind { span, kind });\n                                 continue;\n                             }\n                         };\n                         kind = Some(link_kind);\n                     }\n                     sym::modifiers => {\n                         if modifiers.is_some() {\n-                            let msg =\n-                                \"multiple `modifiers` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleLinkModifiers { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_modifiers) = item.value_str() else {\n-                            let msg = \"link modifiers must be of the form `modifiers = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkModifiersForm { span: item.span() });\n                             continue;\n                         };\n                         modifiers = Some((link_modifiers, item.name_value_literal_span().unwrap()));\n                     }\n                     sym::cfg => {\n                         if cfg.is_some() {\n-                            let msg = \"multiple `cfg` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleCfgs { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_cfg) = item.meta_item_list() else {\n-                            let msg = \"link cfg must be of the form `cfg(/* predicate */)`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkCfgForm { span: item.span() });\n                             continue;\n                         };\n                         let [NestedMetaItem::MetaItem(link_cfg)] = link_cfg else {\n-                            let msg = \"link cfg must have a single predicate argument\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkCfgSinglePredicate { span: item.span() });\n                             continue;\n                         };\n                         if !features.link_cfg {\n@@ -187,33 +168,26 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     sym::wasm_import_module => {\n                         if wasm_import_module.is_some() {\n-                            let msg = \"multiple `wasm_import_module` arguments \\\n-                                       in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleWasmImport { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_wasm_import_module) = item.value_str() else {\n-                            let msg = \"wasm import module must be of the form \\\n-                                       `wasm_import_module = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(WasmImportForm { span: item.span() });\n                             continue;\n                         };\n                         wasm_import_module = Some((link_wasm_import_module, item.span()));\n                     }\n                     sym::import_name_type => {\n                         if import_name_type.is_some() {\n-                            let msg = \"multiple `import_name_type` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleImportNameType { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_import_name_type) = item.value_str() else {\n-                            let msg = \"import name type must be of the form `import_name_type = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(ImportNameTypeForm { span: item.span() });\n                             continue;\n                         };\n                         if self.tcx.sess.target.arch != \"x86\" {\n-                            let msg = \"import name type is only supported on x86\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(ImportNameTypeX86 { span: item.span() });\n                             continue;\n                         }\n \n@@ -222,11 +196,10 @@ impl<'tcx> Collector<'tcx> {\n                             \"noprefix\" => PeImportNameType::NoPrefix,\n                             \"undecorated\" => PeImportNameType::Undecorated,\n                             import_name_type => {\n-                                let msg = format!(\n-                                    \"unknown import name type `{import_name_type}`, expected one of: \\\n-                                     decorated, noprefix, undecorated\"\n-                                );\n-                                sess.span_err(item.span(), msg);\n+                                sess.emit_err(UnknownImportNameType {\n+                                    span: item.span(),\n+                                    import_name_type,\n+                                });\n                                 continue;\n                             }\n                         };\n@@ -243,9 +216,7 @@ impl<'tcx> Collector<'tcx> {\n                         import_name_type = Some((link_import_name_type, item.span()));\n                     }\n                     _ => {\n-                        let msg = \"unexpected `#[link]` argument, expected one of: \\\n-                                   name, kind, modifiers, cfg, wasm_import_module, import_name_type\";\n-                        sess.span_err(item.span(), msg);\n+                        sess.emit_err(UnexpectedLinkArg { span: item.span() });\n                     }\n                 }\n             }\n@@ -257,11 +228,7 @@ impl<'tcx> Collector<'tcx> {\n                     let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n                         Some(m) => (m, modifier.starts_with('+')),\n                         None => {\n-                            sess.span_err(\n-                                span,\n-                                \"invalid linking modifier syntax, expected '+' or '-' prefix \\\n-                                before one of: bundle, verbatim, whole-archive, as-needed\",\n-                            );\n+                            sess.emit_err(InvalidLinkModifier { span });\n                             continue;\n                         }\n                     };\n@@ -279,10 +246,7 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     let assign_modifier = |dst: &mut Option<bool>| {\n                         if dst.is_some() {\n-                            let msg = format!(\n-                                \"multiple `{modifier}` modifiers in a single `modifiers` argument\"\n-                            );\n-                            sess.span_err(span, &msg);\n+                            sess.emit_err(MultipleModifiers { span, modifier });\n                         } else {\n                             *dst = Some(value);\n                         }\n@@ -292,11 +256,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(bundle)\n                         }\n                         (\"bundle\", _) => {\n-                            sess.span_err(\n-                                span,\n-                                \"linking modifier `bundle` is only compatible with \\\n-                                 `static` linking kind\",\n-                            );\n+                            sess.emit_err(BundleNeedsStatic { span });\n                         }\n \n                         (\"verbatim\", _) => {\n@@ -308,11 +268,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(whole_archive)\n                         }\n                         (\"whole-archive\", _) => {\n-                            sess.span_err(\n-                                span,\n-                                \"linking modifier `whole-archive` is only compatible with \\\n-                                 `static` linking kind\",\n-                            );\n+                            sess.emit_err(WholeArchiveNeedsStatic { span });\n                         }\n \n                         (\"as-needed\", Some(NativeLibKind::Dylib { as_needed }))\n@@ -321,58 +277,35 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(as_needed)\n                         }\n                         (\"as-needed\", _) => {\n-                            sess.span_err(\n-                                span,\n-                                \"linking modifier `as-needed` is only compatible with \\\n-                                 `dylib` and `framework` linking kinds\",\n-                            );\n+                            sess.emit_err(AsNeededCompatibility { span });\n                         }\n \n                         _ => {\n-                            sess.span_err(\n-                                span,\n-                                format!(\n-                                    \"unknown linking modifier `{modifier}`, expected one of: \\\n-                                     bundle, verbatim, whole-archive, as-needed\"\n-                                ),\n-                            );\n+                            sess.emit_err(UnknownLinkModifier { span, modifier });\n                         }\n                     }\n                 }\n             }\n \n             if let Some((_, span)) = wasm_import_module {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n-                    let msg = \"`wasm_import_module` is incompatible with \\\n-                               other arguments in `#[link]` attributes\";\n-                    sess.span_err(span, msg);\n+                    sess.emit_err(IncompatibleWasmLink { span });\n                 }\n             } else if name.is_none() {\n-                struct_span_err!(\n-                    sess,\n-                    m.span,\n-                    E0459,\n-                    \"`#[link]` attribute requires a `name = \\\"string\\\"` argument\"\n-                )\n-                .span_label(m.span, \"missing `name` argument\")\n-                .emit();\n+                sess.emit_err(LinkRequiresName { span: m.span });\n             }\n \n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n-                    let msg = \"import name type can only be used with link kind `raw-dylib`\";\n-                    sess.span_err(span, msg);\n+                    sess.emit_err(ImportNameTypeRaw { span });\n                 }\n             }\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n                     if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.span_err(\n-                            span,\n-                            \"link name must not contain NUL characters if link kind is `raw-dylib`\",\n-                        );\n+                        sess.emit_err(RawDylibNoNul { span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -401,10 +334,7 @@ impl<'tcx> Collector<'tcx> {\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n-                            sess.span_err(\n-                                link_ordinal_attr.span,\n-                                \"`#[link_ordinal]` is only supported if link kind is `raw-dylib`\",\n-                            );\n+                            sess.emit_err(LinkOrdinalRawDylib { span: link_ordinal_attr.span });\n                         }\n                     }\n \n@@ -430,7 +360,7 @@ impl<'tcx> Collector<'tcx> {\n         for lib in &self.tcx.sess.opts.libs {\n             if let NativeLibKind::Framework { .. } = lib.kind && !self.tcx.sess.target.is_like_osx {\n                 // Cannot check this when parsing options because the target is not yet available.\n-                self.tcx.sess.err(\"library kind `framework` is only supported on Apple targets\");\n+                self.tcx.sess.emit_err(LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n                 let any_duplicate = self\n@@ -439,23 +369,11 @@ impl<'tcx> Collector<'tcx> {\n                     .filter_map(|lib| lib.name.as_ref())\n                     .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n-                    self.tcx.sess.err(format!(\n-                        \"an empty renaming target was specified for library `{}`\",\n-                        lib.name\n-                    ));\n+                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n-                    self.tcx.sess.err(format!(\n-                        \"renaming of the library `{}` was specified, \\\n-                                                however this crate contains no `#[link(...)]` \\\n-                                                attributes referencing this library\",\n-                        lib.name\n-                    ));\n+                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: &lib.name });\n                 } else if !renames.insert(&lib.name) {\n-                    self.tcx.sess.err(format!(\n-                        \"multiple renamings were \\\n-                                                specified for library `{}`\",\n-                        lib.name\n-                    ));\n+                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: &lib.name });\n                 }\n             }\n         }\n@@ -480,10 +398,13 @@ impl<'tcx> Collector<'tcx> {\n                             // involved or not, library reordering and kind overriding without\n                             // explicit `:rename` in particular.\n                             if lib.has_modifiers() || passed_lib.has_modifiers() {\n-                                let msg = \"overriding linking modifiers from command line is not supported\";\n                                 match lib.foreign_module {\n-                                    Some(def_id) => self.tcx.sess.span_err(self.tcx.def_span(def_id), msg),\n-                                    None => self.tcx.sess.err(msg),\n+                                    Some(def_id) => self.tcx.sess.emit_err(NoLinkModOverride {\n+                                        span: Some(self.tcx.def_span(def_id)),\n+                                    }),\n+                                    None => {\n+                                        self.tcx.sess.emit_err(NoLinkModOverride { span: None })\n+                                    }\n                                 };\n                             }\n                             if passed_lib.kind != NativeLibKind::Unspecified {\n@@ -562,20 +483,14 @@ impl<'tcx> Collector<'tcx> {\n                     DllCallingConvention::Vectorcall(self.i686_arg_list_size(item))\n                 }\n                 _ => {\n-                    self.tcx.sess.span_fatal(\n-                        item.span,\n-                        r#\"ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\"#,\n-                    );\n+                    self.tcx.sess.emit_fatal(UnsupportedAbiI686 { span: item.span });\n                 }\n             }\n         } else {\n             match abi {\n                 Abi::C { .. } | Abi::Win64 { .. } | Abi::System { .. } => DllCallingConvention::C,\n                 _ => {\n-                    self.tcx.sess.span_fatal(\n-                        item.span,\n-                        r#\"ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\"#,\n-                    );\n+                    self.tcx.sess.emit_fatal(UnsupportedAbi { span: item.span });\n                 }\n             }\n         };"}, {"sha": "8dc5ed2db7e494190f9a51952dc1b32516798160", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0056795da7a51f0ebebf0d5ad8f0b663d089420/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a0056795da7a51f0ebebf0d5ad8f0b663d089420", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::{FailCreateFileEncoder, FailSeekFile, FailWriteFile};\n use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n@@ -2195,7 +2196,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>, path: &Path) {\n \n fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n     let mut encoder = opaque::FileEncoder::new(path)\n-        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to create file encoder: {}\", err)));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailCreateFileEncoder { err }));\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n@@ -2240,10 +2241,10 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n     file.seek(std::io::SeekFrom::Start(header as u64))\n-        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to seek the file: {}\", err)));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailSeekFile { err }));\n     let pos = root.position.get();\n     file.write_all(&[(pos >> 24) as u8, (pos >> 16) as u8, (pos >> 8) as u8, (pos >> 0) as u8])\n-        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to write to the file: {}\", err)));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailWriteFile { err }));\n \n     // Return to the position where we are before writing the root position.\n     file.seek(std::io::SeekFrom::Start(pos_before_seek)).unwrap();"}]}