{"sha": "06f362aeb3c6956bb471fe44de72185dd831eb48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZjM2MmFlYjNjNjk1NmJiNDcxZmU0NGRlNzIxODVkZDgzMWViNDg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-20T06:17:05Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:16:01Z"}, "message": "rustc_resolve: don't handle impl items as if they were modules.", "tree": {"sha": "2c8559632d78fbbd95f085c829310347957bb3e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c8559632d78fbbd95f085c829310347957bb3e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06f362aeb3c6956bb471fe44de72185dd831eb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06f362aeb3c6956bb471fe44de72185dd831eb48", "html_url": "https://github.com/rust-lang/rust/commit/06f362aeb3c6956bb471fe44de72185dd831eb48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06f362aeb3c6956bb471fe44de72185dd831eb48/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6700166442cb88c813e5d3bd39dba3b5f1abc1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6700166442cb88c813e5d3bd39dba3b5f1abc1b0", "html_url": "https://github.com/rust-lang/rust/commit/6700166442cb88c813e5d3bd39dba3b5f1abc1b0"}], "stats": {"total": 540, "additions": 156, "deletions": 384}, "files": [{"sha": "7dcdeaf16d2e80614414596f41b22ae292fe6263", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -51,6 +51,7 @@ use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n use middle::mem_categorization as mc;\n+use middle::privacy::LastPrivateMap;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n@@ -683,6 +684,7 @@ pub struct ctxt<'tcx> {\n     pub sess: Session,\n     pub def_map: DefMap,\n     pub partial_def_map: PartialDefMap,\n+    pub last_private_map: RefCell<LastPrivateMap>,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n@@ -2426,6 +2428,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      arenas: &'tcx CtxtArenas<'tcx>,\n                      def_map: DefMap,\n                      partial_def_map: PartialDefMap,\n+                     last_private_map: LastPrivateMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n@@ -2449,6 +2452,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         sess: s,\n         def_map: def_map,\n         partial_def_map: partial_def_map,\n+        last_private_map: RefCell::new(last_private_map),\n         region_maps: region_maps,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),"}, {"sha": "aafa4dec0de94efee7ec788bfbfdd1e091e6001d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -609,6 +609,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             arenas,\n                             def_map,\n                             partial_def_map,\n+                            last_private_map,\n                             named_region_map,\n                             ast_map,\n                             freevars,\n@@ -622,10 +623,9 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"const checking\", (), |_|\n          middle::check_const::check_crate(&ty_cx));\n \n-    let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n-            time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 rustc_privacy::check_crate(&ty_cx, &export_map, a, b));\n+            time(time_passes, \"privacy checking\", (), |_|\n+                 rustc_privacy::check_crate(&ty_cx, &export_map, external_exports));\n \n     // Do not move this check past lint\n     time(time_passes, \"stability index\", (), |_|"}, {"sha": "1452c44ca71441db61cf72f9b610b3b4683b6e08", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -38,8 +38,7 @@ use rustc::middle::def;\n use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n-use rustc::middle::privacy::{ExportedItems, PublicItems, LastPrivateMap};\n-use rustc::middle::privacy::{ExternalExports};\n+use rustc::middle::privacy::{ExternalExports, ExportedItems, PublicItems};\n use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n use rustc::middle::ty::{MethodStaticClosure, MethodObject};\n@@ -379,7 +378,6 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     in_foreign: bool,\n     parents: NodeMap<ast::NodeId>,\n     external_exports: ExternalExports,\n-    last_private_map: LastPrivateMap,\n }\n \n enum PrivacyResult {\n@@ -730,7 +728,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                    &format!(\"{} `{}`\", tyname, name))\n             };\n \n-            match self.last_private_map[path_id] {\n+            match self.tcx.last_private_map.borrow()[path_id] {\n                 LastMod(AllPublic) => {},\n                 LastMod(DependsOn(def)) => {\n                     self.report_error(ck_public(def));\n@@ -1500,8 +1498,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    export_map: &def::ExportMap,\n-                   external_exports: ExternalExports,\n-                   last_private_map: LastPrivateMap)\n+                   external_exports: ExternalExports)\n                    -> (ExportedItems, PublicItems) {\n     let krate = tcx.map.krate();\n \n@@ -1519,7 +1516,6 @@ pub fn check_crate(tcx: &ty::ctxt,\n         tcx: tcx,\n         parents: visitor.parents,\n         external_exports: external_exports,\n-        last_private_map: last_private_map,\n     };\n     visit::walk_crate(&mut visitor, krate);\n "}, {"sha": "e4612d6c8b9b396c14d8aeec885b401bdf484b95", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 228, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -39,18 +39,16 @@ use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n+use syntax::ast::{Name, NamedField, NodeId};\n use syntax::ast::{PathListIdent, PathListMod, Public};\n use syntax::ast::StmtDecl;\n use syntax::ast::StructVariantKind;\n use syntax::ast::TupleVariantKind;\n-use syntax::ast::TyObjectSum;\n-use syntax::ast::{TypeImplItem, UnnamedField};\n+use syntax::ast::UnnamedField;\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n-use syntax::ast::TyPath;\n use syntax::ast;\n-use syntax::ast_util::{self, PostExpansionMethod, local_def};\n+use syntax::ast_util::{self, local_def};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::{self, special_idents};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -177,12 +175,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         Some(TypeNS)\n                     }\n                     ForbidDuplicateTypesAndModules => {\n-                        match child.def_for_namespace(TypeNS) {\n-                            None => {}\n-                            Some(_) if child.get_module_if_available()\n-                                            .map(|m| m.kind.get()) ==\n-                                       Some(ImplModuleKind) => {}\n-                            Some(_) => duplicate_type = TypeError\n+                        if child.defined_in_namespace(TypeNS) {\n+                            duplicate_type = TypeError;\n                         }\n                         Some(TypeNS)\n                     }\n@@ -461,9 +455,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 name_bindings.define_type(DefTy(local_def(item.id), true), sp, modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n-                // We want to make sure the module type is EnumModuleKind\n-                // even if there's already an ImplModuleKind module defined,\n-                // since that's how we prevent duplicate enum definitions\n                 name_bindings.set_module_kind(parent_link,\n                                               Some(local_def(item.id)),\n                                               EnumModuleKind,\n@@ -513,133 +504,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 parent.clone()\n             }\n \n-            ItemImpl(_, _, _, None, ref ty, ref impl_items) => {\n-                // If this implements an anonymous trait, then add all the\n-                // methods within to a new module, if the type was defined\n-                // within this module.\n-\n-                let mod_name = match ty.node {\n-                    TyPath(ref path) if path.segments.len() == 1 => {\n-                        // FIXME(18446) we should distinguish between the name of\n-                        // a trait and the name of an impl of that trait.\n-                        Some(path.segments.last().unwrap().identifier.name)\n-                    }\n-                    TyObjectSum(ref lhs_ty, _) => {\n-                        match lhs_ty.node {\n-                            TyPath(ref path) if path.segments.len() == 1 => {\n-                                Some(path.segments.last().unwrap().identifier.name)\n-                            }\n-                            _ => {\n-                                None\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        None\n-                    }\n-                };\n-\n-                let mod_name = match mod_name {\n-                    Some(mod_name) => mod_name,\n-                    None => {\n-                        self.resolve_error(ty.span,\n-                                           \"inherent implementations may \\\n-                                            only be implemented in the same \\\n-                                            module as the type they are \\\n-                                            implemented for\");\n-                        return parent.clone();\n-                    }\n-                };\n-                // Create the module and add all methods.\n-                let child_opt = parent.children.borrow().get(&mod_name)\n-                                       .and_then(|m| m.get_module_if_available());\n-                let new_parent = match child_opt {\n-                    // It already exists\n-                    Some(ref child) if (child.kind.get() == ImplModuleKind ||\n-                                        child.kind.get() == TraitModuleKind) => {\n-                        child.clone()\n-                    }\n-                    Some(ref child) if child.kind.get() == EnumModuleKind ||\n-                                       child.kind.get() == TypeModuleKind => {\n-                        child.clone()\n-                    }\n-                    // Create the module\n-                    _ => {\n-                        let name_bindings =\n-                            self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n-\n-                        let parent_link = self.get_parent_link(parent, name);\n-                        let def_id = local_def(item.id);\n-                        let ns = TypeNS;\n-                        let is_public =\n-                            !name_bindings.defined_in_namespace(ns) ||\n-                            name_bindings.defined_in_public_namespace(ns);\n-\n-                        name_bindings.define_module(parent_link,\n-                                                    Some(def_id),\n-                                                    ImplModuleKind,\n-                                                    false,\n-                                                    is_public,\n-                                                    sp);\n-\n-                        name_bindings.get_module()\n-                    }\n-                };\n-\n-                // For each implementation item...\n-                for impl_item in impl_items {\n-                    match *impl_item {\n-                        MethodImplItem(ref method) => {\n-                            // Add the method to the module.\n-                            let name = method.pe_ident().name;\n-                            let method_name_bindings =\n-                                self.add_child(name,\n-                                               &new_parent,\n-                                               ForbidDuplicateValues,\n-                                               method.span);\n-                            let def = DefMethod(local_def(method.id),\n-                                                FromImpl(local_def(item.id)));\n-\n-                            // NB: not IMPORTABLE\n-                            let modifiers = if method.pe_vis() == ast::Public {\n-                                PUBLIC\n-                            } else {\n-                                DefModifiers::empty()\n-                            };\n-                            method_name_bindings.define_value(\n-                                def,\n-                                method.span,\n-                                modifiers);\n-                        }\n-                        TypeImplItem(ref typedef) => {\n-                            // Add the typedef to the module.\n-                            let name = typedef.ident.name;\n-                            let typedef_name_bindings =\n-                                self.add_child(\n-                                    name,\n-                                    &new_parent,\n-                                    ForbidDuplicateTypesAndModules,\n-                                    typedef.span);\n-                            let def = DefAssociatedTy(local_def(item.id),\n-                                                      local_def(typedef.id));\n-                            // NB: not IMPORTABLE\n-                            let modifiers = if typedef.vis == ast::Public {\n-                                PUBLIC\n-                            } else {\n-                                DefModifiers::empty()\n-                            };\n-                            typedef_name_bindings.define_type(\n-                                def,\n-                                typedef.span,\n-                                modifiers);\n-                        }\n-                    }\n-                }\n-                parent.clone()\n-            }\n-\n+            ItemImpl(..) => parent.clone(),\n             ItemDefaultImpl(_, _) |\n-            ItemImpl(_, _, _, Some(_), _, _) => parent.clone(),\n \n             ItemTrait(_, _, _, ref items) => {\n                 let name_bindings =\n@@ -805,8 +671,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let kind = match def {\n             DefTy(_, true) => EnumModuleKind,\n-            DefTy(_, false) => TypeModuleKind,\n-            DefStruct(..) => ImplModuleKind,\n+            DefTy(_, false) | DefStruct(..) => TypeModuleKind,\n             _ => NormalModuleKind\n         };\n \n@@ -980,92 +845,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 }\n             }\n-            DlImpl(def) => {\n-                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n-                    None => {}\n-                    Some(final_name) => {\n-                        let methods_opt =\n-                            csearch::get_methods_if_impl(&self.session.cstore, def);\n-                        match methods_opt {\n-                            Some(ref methods) if\n-                                methods.len() >= 1 => {\n-                                debug!(\"(building reduced graph for \\\n-                                        external crate) processing \\\n-                                        static methods for type name {}\",\n-                                        token::get_name(final_name));\n-\n-                                let child_name_bindings =\n-                                    self.add_child(\n-                                        final_name,\n-                                        root,\n-                                        OverwriteDuplicates,\n-                                        DUMMY_SP);\n-\n-                                // Process the static methods. First,\n-                                // create the module.\n-                                let type_module;\n-                                let type_def = child_name_bindings.type_def.borrow().clone();\n-                                match type_def {\n-                                    Some(TypeNsDef {\n-                                        module_def: Some(module_def),\n-                                        ..\n-                                    }) => {\n-                                        // We already have a module. This\n-                                        // is OK.\n-                                        type_module = module_def;\n-\n-                                        // Mark it as an impl module if\n-                                        // necessary.\n-                                        type_module.kind.set(ImplModuleKind);\n-                                    }\n-                                    Some(_) | None => {\n-                                        let parent_link =\n-                                            self.get_parent_link(root, final_name);\n-                                        child_name_bindings.define_module(\n-                                            parent_link,\n-                                            Some(def),\n-                                            ImplModuleKind,\n-                                            true,\n-                                            true,\n-                                            DUMMY_SP);\n-                                        type_module =\n-                                            child_name_bindings.\n-                                                get_module();\n-                                    }\n-                                }\n-\n-                                // Add each static method to the module.\n-                                let new_parent = type_module;\n-                                for method_info in methods {\n-                                    let name = method_info.name;\n-                                    debug!(\"(building reduced graph for \\\n-                                             external crate) creating \\\n-                                             static method '{}'\",\n-                                           token::get_name(name));\n-\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       &new_parent,\n-                                                       OverwriteDuplicates,\n-                                                       DUMMY_SP);\n-                                    let def = DefFn(method_info.def_id, false);\n-\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if method_info.vis == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def, DUMMY_SP, modifiers);\n-                                }\n-                            }\n-\n-                            // Otherwise, do nothing.\n-                            Some(_) | None => {}\n-                        }\n-                    }\n-                }\n+            DlImpl(_) => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        ignoring impl\");\n             }\n             DlField => {\n                 debug!(\"(building reduced graph for external crate) \\"}, {"sha": "6b05a648746546fdf16af5d5eab44dab7e51756b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -514,7 +514,6 @@ enum ParentLink {\n enum ModuleKind {\n     NormalModuleKind,\n     TraitModuleKind,\n-    ImplModuleKind,\n     EnumModuleKind,\n     TypeModuleKind,\n     AnonymousModuleKind,\n@@ -1863,13 +1862,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match import_resolution.value_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n-                    let msg = format!(\"import `{}` conflicts with value \\\n-                                       in this module\",\n-                                      &token::get_name(name));\n-                    span_err!(self.session, import_span, E0255, \"{}\", &msg[..]);\n+                    span_err!(self.session, import_span, E0255,\n+                              \"import `{}` conflicts with value in this module\",\n+                              &token::get_name(name));\n                     if let Some(span) = value.value_span {\n-                        self.session.span_note(span,\n-                                               \"conflicting value here\");\n+                        self.session.span_note(span, \"conflicting value here\");\n                     }\n                 }\n             }\n@@ -1879,41 +1876,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match import_resolution.type_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_def.borrow() {\n-                    match ty.module_def {\n-                        None => {\n-                            let msg = format!(\"import `{}` conflicts with type in \\\n-                                               this module\",\n-                                              &token::get_name(name));\n-                            span_err!(self.session, import_span, E0256, \"{}\", &msg[..]);\n-                            if let Some(span) = ty.type_span {\n-                                self.session.span_note(span,\n-                                                       \"note conflicting type here\")\n-                            }\n-                        }\n-                        Some(ref module_def) => {\n-                            match module_def.kind.get() {\n-                                ImplModuleKind => {\n-                                    if let Some(span) = ty.type_span {\n-                                        let msg = format!(\"inherent implementations \\\n-                                                           are only allowed on types \\\n-                                                           defined in the current module\");\n-                                        span_err!(self.session, span, E0257, \"{}\", &msg[..]);\n-                                        self.session.span_note(import_span,\n-                                                               \"import from other module here\")\n-                                    }\n-                                }\n-                                _ => {\n-                                    let msg = format!(\"import `{}` conflicts with existing \\\n-                                                       submodule\",\n-                                                      &token::get_name(name));\n-                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[..]);\n-                                    if let Some(span) = ty.type_span {\n-                                        self.session.span_note(span,\n-                                                               \"note conflicting module here\")\n-                                    }\n-                                }\n-                            }\n-                        }\n+                    let (what, note) = if ty.module_def.is_some() {\n+                        (\"existing submodule\", \"note conflicting module here\")\n+                    } else {\n+                        (\"type in this module\", \"note conflicting type here\")\n+                    };\n+                    span_err!(self.session, import_span, E0256,\n+                              \"import `{}` conflicts with {}\",\n+                              &token::get_name(name), what);\n+                    if let Some(span) = ty.type_span {\n+                        self.session.span_note(span, note);\n                     }\n                 }\n             }\n@@ -2267,7 +2239,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             return Failed(None);\n                         }\n                         TraitModuleKind |\n-                        ImplModuleKind |\n                         EnumModuleKind |\n                         TypeModuleKind |\n                         AnonymousModuleKind => {\n@@ -2365,7 +2336,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match new_module.kind.get() {\n                         NormalModuleKind => return Some(new_module),\n                         TraitModuleKind |\n-                        ImplModuleKind |\n                         EnumModuleKind |\n                         TypeModuleKind |\n                         AnonymousModuleKind => module_ = new_module,\n@@ -2382,7 +2352,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_.kind.get() {\n             NormalModuleKind => return module_,\n             TraitModuleKind |\n-            ImplModuleKind |\n             EnumModuleKind |\n             TypeModuleKind |\n             AnonymousModuleKind => {"}, {"sha": "7ef2db2c28d883f59c4f36a2fd34120aad269704", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -15,6 +15,7 @@ use check::{FnCtxt};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n use middle::def;\n+use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::*;\n@@ -309,16 +310,22 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               method_name: ast::Name,\n                               self_ty: Ty<'tcx>,\n                               expr_id: ast::NodeId)\n-                              -> Result<def::Def, MethodError>\n+                              -> Result<(def::Def, LastPrivate), MethodError>\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n     let def_id = pick.method_ty.def_id;\n+    let mut lp = LastMod(AllPublic);\n     let provenance = match pick.kind {\n-        probe::InherentImplPick(impl_def_id) => def::FromImpl(impl_def_id),\n+        probe::InherentImplPick(impl_def_id) => {\n+            if pick.method_ty.vis != ast::Public {\n+                lp = LastMod(DependsOn(def_id));\n+            }\n+            def::FromImpl(impl_def_id)\n+        }\n         _ => def::FromTrait(pick.method_ty.container.id())\n     };\n-    Ok(def::DefMethod(def_id, provenance))\n+    Ok((def::DefMethod(def_id, provenance), lp))\n }\n \n "}, {"sha": "f24da78bc7d3974ea304f5c8f38f9d1f80a237ec", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -281,6 +281,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             ty::ty_closure(did, _, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n+            ty::ty_uniq(_) => {\n+                if let Some(box_did) = self.tcx().lang_items.owned_box() {\n+                    self.assemble_inherent_impl_candidates_for_type(box_did);\n+                }\n+            }\n             ty::ty_param(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }"}, {"sha": "9832fe1cb6eacd35ebf8ac3723829c28a68a129b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -33,7 +33,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n                               method_name: ast::Name,\n-                              callee_expr: &ast::Expr,\n+                              rcvr_expr: Option<&ast::Expr>,\n                               error: MethodError)\n {\n     // avoid suggestions when we don't know what's going on.\n@@ -46,16 +46,6 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let cx = fcx.tcx();\n             let method_ustring = method_name.user_string(cx);\n \n-            // True if the type is a struct and contains a field with\n-            // the same name as the not-found method\n-            let is_field = match rcvr_ty.sty {\n-                ty::ty_struct(did, _) =>\n-                    ty::lookup_struct_fields(cx, did)\n-                        .iter()\n-                        .any(|f| f.name.user_string(cx) == method_ustring),\n-                _ => false\n-            };\n-\n             fcx.type_error_message(\n                 span,\n                 |actual| {\n@@ -68,10 +58,13 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None);\n \n             // If the method has the name of a field, give a help note\n-            if is_field {\n-                cx.sess.span_note(span,\n-                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring));\n+            if let (&ty::ty_struct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n+                let fields = ty::lookup_struct_fields(cx, did);\n+                if fields.iter().any(|f| f.name == method_name) {\n+                    cx.sess.span_note(span,\n+                        &format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                                 function stored in the `{0}` field\", method_ustring));\n+                }\n             }\n \n             if static_sources.len() > 0 {\n@@ -82,7 +75,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 report_candidates(fcx, span, method_name, static_sources);\n             }\n \n-            suggest_traits_to_import(fcx, span, rcvr_ty, method_name, out_of_scope_traits)\n+            suggest_traits_to_import(fcx, span, rcvr_ty, method_name,\n+                                     rcvr_expr, out_of_scope_traits)\n         }\n \n         MethodError::Ambiguity(sources) => {\n@@ -93,15 +87,18 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         MethodError::ClosureAmbiguity(trait_def_id) => {\n-            fcx.sess().span_err(\n-                span,\n-                &*format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n-                           invoked on this closure as we have not yet inferred what \\\n-                           kind of closure it is; use overloaded call notation instead \\\n-                           (e.g., `{}()`)\",\n-                          method_name.user_string(fcx.tcx()),\n-                          ty::item_path_str(fcx.tcx(), trait_def_id),\n-                          pprust::expr_to_string(callee_expr)));\n+            let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n+                               invoked on this closure as we have not yet inferred what \\\n+                               kind of closure it is\",\n+                               method_name.user_string(fcx.tcx()),\n+                               ty::item_path_str(fcx.tcx(), trait_def_id));\n+            let msg = if let Some(callee) = rcvr_expr {\n+                format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n+                        msg, pprust::expr_to_string(callee))\n+            } else {\n+                msg\n+            };\n+            fcx.sess().span_err(span, &msg);\n         }\n     }\n \n@@ -156,6 +153,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       rcvr_ty: Ty<'tcx>,\n                                       method_name: ast::Name,\n+                                      rcvr_expr: Option<&ast::Expr>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n@@ -184,7 +182,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         return\n     }\n \n-    let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty);\n+    let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty, rcvr_expr);\n \n     // there's no implemented traits, so lets suggest some traits to\n     // implement, by finding ones that have the method name, and are\n@@ -233,33 +231,39 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// autoderefs of `rcvr_ty`.\n fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   span: Span,\n-                                  rcvr_ty: Ty<'tcx>) -> bool {\n-    check::autoderef(fcx, span, rcvr_ty, None,\n-                     check::UnresolvedTypeAction::Ignore, check::NoPreference,\n-                     |&: ty, _| {\n-        let is_local = match ty.sty {\n+                                  rcvr_ty: Ty<'tcx>,\n+                                  rcvr_expr: Option<&ast::Expr>) -> bool {\n+    fn is_local(ty: Ty) -> bool {\n+        match ty.sty {\n             ty::ty_enum(did, _) | ty::ty_struct(did, _) => ast_util::is_local(did),\n \n             ty::ty_trait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n \n             ty::ty_param(_) => true,\n \n-            // the user cannot implement traits for unboxed closures, so\n-            // there's no point suggesting anything at all, local or not.\n-            ty::ty_closure(..) => return Some(false),\n-\n             // everything else (primitive types etc.) is effectively\n             // non-local (there are \"edge\" cases, e.g. (LocalType,), but\n             // the noise from these sort of types is usually just really\n             // annoying, rather than any sort of help).\n             _ => false\n-        };\n-        if is_local {\n-            Some(true)\n+        }\n+    }\n+\n+    // This occurs for UFCS desugaring of `T::method`, where there is no\n+    // receiver expression for the method call, and thus no autoderef.\n+    if rcvr_expr.is_none() {\n+        return is_local(fcx.resolve_type_vars_if_possible(rcvr_ty));\n+    }\n+\n+    check::autoderef(fcx, span, rcvr_ty, None,\n+                     check::UnresolvedTypeAction::Ignore, check::NoPreference,\n+                     |ty, _| {\n+        if is_local(ty) {\n+            Some(())\n         } else {\n             None\n         }\n-    }).2.unwrap_or(false)\n+    }).2.is_some()\n }\n \n #[derive(Copy)]"}, {"sha": "068e03dab120bf6142ea153e30ed79794fc8a616", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -91,6 +91,7 @@ use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n+use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n@@ -2687,7 +2688,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             Err(error) => {\n                 method::report_error(fcx, method_name.span, expr_t,\n-                                     method_name.node.name, rcvr, error);\n+                                     method_name.node.name, Some(rcvr), error);\n                 fcx.write_error(expr.id);\n                 fcx.tcx().types.err\n             }\n@@ -3598,8 +3599,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           };\n \n           // Helpers to avoid keeping the RefCell borrow for too long.\n-          let get_def = |&:| tcx.def_map.borrow().get(&id).cloned();\n-          let get_partial_def = |&:| tcx.partial_def_map.borrow().get(&id).cloned();\n+          let get_def = || tcx.def_map.borrow().get(&id).cloned();\n+          let get_partial_def = || tcx.partial_def_map.borrow().get(&id).cloned();\n \n           if let Some(def) = get_def() {\n               let (scheme, predicates) =\n@@ -3621,10 +3622,16 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               let method_segment = path.segments.last().unwrap();\n               let method_name = method_segment.identifier.name;\n               match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n-                  Ok(def) => {\n+                  Ok((def, lp)) => {\n                       // Write back the new resolution.\n                       tcx.def_map.borrow_mut().insert(id, def);\n \n+                      if let LastMod(AllPublic) = lp {\n+                          // Public method, don't change the last private entry.\n+                      } else {\n+                          tcx.last_private_map.borrow_mut().insert(id, lp);\n+                      }\n+\n                       let (scheme, predicates) =\n                           type_scheme_and_predicates_for_def(fcx, expr.span, def);\n                       instantiate_path(fcx, slice::ref_slice(method_segment),\n@@ -3633,7 +3640,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   }\n                   Err(error) => {\n                       method::report_error(fcx, expr.span, ty,\n-                                           method_name, expr, error);\n+                                           method_name, None, error);\n                       fcx.write_error(id);\n                   }\n               }\n@@ -4842,9 +4849,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n     if let Some(self_ty) = opt_self_ty {\n-        // `<T as Trait>::foo` shouldn't have resolved to a `Self`-less item.\n-        assert_eq!(type_defs.len(subst::SelfSpace), 1);\n-        substs.types.push(subst::SelfSpace, self_ty);\n+        if type_defs.len(subst::SelfSpace) == 1 {\n+            substs.types.push(subst::SelfSpace, self_ty);\n+        }\n     }\n \n     // Now we have to compare the types that the user *actually*"}, {"sha": "34fadc70af8b7548f8982ea5e29ad7f2a1c3fc5d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -15,8 +15,8 @@ use middle::traits;\n use middle::ty;\n use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_util;\n-use syntax::codemap::Span;\n use syntax::visit;\n use util::ppaux::{Repr, UserString};\n \n@@ -30,9 +30,9 @@ struct OrphanChecker<'cx, 'tcx:'cx> {\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n-    fn check_def_id(&self, span: Span, def_id: ast::DefId) {\n+    fn check_def_id(&self, item: &ast::Item, def_id: ast::DefId) {\n         if def_id.krate != ast::LOCAL_CRATE {\n-            span_err!(self.tcx.sess, span, E0116,\n+            span_err!(self.tcx.sess, item.span, E0116,\n                       \"cannot associate methods with a type outside the \\\n                        crate the type is defined in; define and implement \\\n                        a trait or new type instead\");\n@@ -41,7 +41,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &'v ast::Item) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         let def_id = ast_util::local_def(item.id);\n         match item.node {\n             ast::ItemImpl(_, _, _, None, _, _) => {\n@@ -52,15 +52,13 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 match self_ty.sty {\n                     ty::ty_enum(def_id, _) |\n                     ty::ty_struct(def_id, _) => {\n-                        self.check_def_id(item.span, def_id);\n+                        self.check_def_id(item, def_id);\n                     }\n                     ty::ty_trait(ref data) => {\n-                        self.check_def_id(item.span, data.principal_def_id());\n+                        self.check_def_id(item, data.principal_def_id());\n                     }\n                     ty::ty_uniq(..) => {\n-                        self.check_def_id(item.span,\n-                                          self.tcx.lang_items.owned_box()\n-                                              .unwrap());\n+                        self.check_def_id(item, self.tcx.lang_items.owned_box().unwrap());\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,"}, {"sha": "7b43a9fef06dcd36d604f5b42425fd42b3cecf72", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -80,6 +80,7 @@ register_diagnostics! {\n     E0120,\n     E0121,\n     E0122,\n+    E0123,\n     E0124,\n     E0127,\n     E0128,"}, {"sha": "7a7406115d39365a5735d7f24a735eaa43c91941", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -43,7 +43,7 @@ fn foo<'a>() {\n     //~^ ERROR too many type parameters provided\n \n     let _ = S::<'a,isize>::new::<f64>(1, 1.0);\n-    //~^ ERROR too many lifetime parameters provided\n+    //~^ ERROR wrong number of lifetime parameters\n \n     let _: S2 = Trait::new::<isize,f64>(1, 1.0);\n     //~^ ERROR too many type parameters provided"}, {"sha": "5fa429445a35e66fc5d68df606e872227e308adf", "filename": "src/test/compile-fail/generic-impl-less-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -19,5 +19,5 @@ impl<A, B, C = (A, B)> Foo<A, B, C> {\n \n fn main() {\n     Foo::<isize>::new();\n-    //~^ ERROR too few type parameters provided\n+    //~^ ERROR wrong number of type arguments\n }"}, {"sha": "d3babb8982ddca652bdd9c16e113d89ea74f445a", "filename": "src/test/compile-fail/generic-impl-more-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -21,5 +21,5 @@ impl<T, A = Heap> Vec<T, A> {\n \n fn main() {\n     Vec::<isize, Heap, bool>::new();\n-    //~^ ERROR too many type parameters provided\n+    //~^ ERROR wrong number of type arguments\n }"}, {"sha": "c0c951dd8b10835c990421bfc3a26ddfa2a9f055", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR error: duplicate definition of value `orange`\n+    fn orange(&self){}   //~ ERROR error: duplicate method in trait impl\n }\n \n fn main() {}"}, {"sha": "ce5fa1f1fe1a5e66e4fc4cb9fc54f8d4de85c873", "filename": "src/test/compile-fail/issue-14254.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -29,7 +29,7 @@ impl Foo for *const BarTy {\n         baz();\n         //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n         a;\n-        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        //~^ ERROR: unresolved name `a`\n     }\n }\n \n@@ -42,11 +42,11 @@ impl<'a> Foo for &'a BarTy {\n         y;\n         //~^ ERROR: unresolved name `y`. Did you mean `self.y`?\n         a;\n-        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        //~^ ERROR: unresolved name `a`\n         bah;\n         //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n         b;\n-        //~^ ERROR: unresolved name `b`. Did you mean to call `self.b`?\n+        //~^ ERROR: unresolved name `b`\n     }\n }\n \n@@ -59,11 +59,11 @@ impl<'a> Foo for &'a mut BarTy {\n         y;\n         //~^ ERROR: unresolved name `y`. Did you mean `self.y`?\n         a;\n-        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        //~^ ERROR: unresolved name `a`\n         bah;\n         //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n         b;\n-        //~^ ERROR: unresolved name `b`. Did you mean to call `self.b`?\n+        //~^ ERROR: unresolved name `b`\n     }\n }\n "}, {"sha": "05485008e51fddabce97136adf959f142d0fb3cf", "filename": "src/test/compile-fail/issue-21202.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-21202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-21202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21202.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -18,7 +18,7 @@ mod B {\n     use crate1::A::Foo;\n     fn bar(f: Foo) {\n         Foo::foo(&f);\n-        //~^ ERROR: function `foo` is private\n+        //~^ ERROR: method `foo` is private\n     }\n }\n "}, {"sha": "48cc27e228940b74f93d71640562f64224e88f59", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -36,7 +36,7 @@ impl Groom for cat {\n     shave(4);\n     //~^ ERROR: unresolved name `shave`. Did you mean to call `Groom::shave`?\n     purr();\n-    //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+    //~^ ERROR: unresolved name `purr`\n   }\n }\n \n@@ -45,13 +45,13 @@ impl cat {\n \n     fn purr_louder() {\n         static_method();\n-        //~^ ERROR: unresolved name `static_method`. Did you mean to call `cat::static_method`\n+        //~^ ERROR: unresolved name `static_method`\n         purr();\n-        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        //~^ ERROR: unresolved name `purr`\n         purr();\n-        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        //~^ ERROR: unresolved name `purr`\n         purr();\n-        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        //~^ ERROR: unresolved name `purr`\n     }\n }\n \n@@ -65,7 +65,7 @@ impl cat {\n \n   fn purr(&self) {\n     grow_older();\n-    //~^ ERROR: unresolved name `grow_older`. Did you mean to call `cat::grow_older`\n+    //~^ ERROR: unresolved name `grow_older`\n     shave();\n     //~^ ERROR: unresolved name `shave`\n   }\n@@ -79,7 +79,7 @@ impl cat {\n     whiskers = 4;\n     //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n     purr_louder();\n-    //~^ ERROR: unresolved name `purr_louder`. Did you mean to call `cat::purr_louder`\n+    //~^ ERROR: unresolved name `purr_louder`\n   }\n }\n "}, {"sha": "ab18e0bcddcf08ef7005c27a814343b131404578", "filename": "src/test/compile-fail/issue-4265.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -17,7 +17,7 @@ impl Foo {\n         Foo { baz: 0 }.bar();\n     }\n \n-    fn bar() { //~ ERROR duplicate definition of value `bar`\n+    fn bar() { //~ ERROR duplicate method in trait impl\n     }\n }\n "}, {"sha": "c9ef2df8e1326f01f26bb275f40bde1ce2f4d29d", "filename": "src/test/compile-fail/method-macro-backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -29,7 +29,7 @@ impl S {\n \n     // Cause an error. It shouldn't have any macro backtrace frames.\n     fn bar(&self) { }\n-    fn bar(&self) { } //~ ERROR duplicate definition\n+    fn bar(&self) { } //~ ERROR duplicate method\n }\n \n fn main() { }"}, {"sha": "3aec23a55b8118e9f4766c28ed7c5d2c9e02e5d5", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(eddyb/UFCS) This should have a nicer error, but that's not possible just yet.\n-impl<T> Option<T> { //~ ERROR use of undeclared type name `Option`\n+impl<T> Option<T> {\n+//~^ ERROR cannot associate methods with a type outside the crate the type is defined in\n     pub fn foo(&self) { }\n }\n "}, {"sha": "49d8622976bb2dfd43159d1ee1ce01c9d764591b", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -11,7 +11,7 @@\n use Trait::foo;\n //~^ ERROR `foo` is not directly importable\n use Foo::new;\n-//~^ ERROR `new` is not directly importable\n+//~^ ERROR unresolved import `Foo::new`. Not a module `Foo`\n \n pub trait Trait {\n     fn foo();"}, {"sha": "c1dc68b245655b2c521be9d7fa012e50e12169a9", "filename": "src/test/run-pass/impl-not-adjacent-to-type.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Frun-pass%2Fimpl-not-adjacent-to-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Frun-pass%2Fimpl-not-adjacent-to-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-not-adjacent-to-type.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test calling methods on an impl for a bare trait. This test checks trait impls\n-// must be in the same module as the trait.\n-\n-mod Foo {\n-    trait T {}\n+mod foo {\n+    pub struct Point {\n+        pub x: i32,\n+        pub y: i32,\n+    }\n }\n \n-mod Bar {\n-    impl<'a> ::Foo::T+'a { //~ERROR: inherent implementations may only be implemented in the same\n-        fn foo(&self) {}\n-    }\n+impl foo::Point {\n+    fn x(&self) -> i32 { self.x }\n }\n \n-fn main() {}\n+fn main() {\n+    assert_eq!((foo::Point { x: 1, y: 3}).x(), 1);\n+}", "previous_filename": "src/test/compile-fail/trait-impl-2.rs"}, {"sha": "727c33d6ce56f3ee9a5ae3fa5afe5e72673f0600", "filename": "src/test/run-pass/trait-impl-2.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Frun-pass%2Ftrait-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06f362aeb3c6956bb471fe44de72185dd831eb48/src%2Ftest%2Frun-pass%2Ftrait-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-impl-2.rs?ref=06f362aeb3c6956bb471fe44de72185dd831eb48", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-mod foo {\n-    pub struct Foo {\n-        x: isize,\n-        y: isize,\n+mod Foo {\n+    trait Trait {\n+        fn foo(&self);\n     }\n }\n \n-impl foo::Foo {\n-//~^ ERROR implementations may only be implemented in the same module\n-    fn bar() {}\n+mod Bar {\n+    impl<'a> ::Foo::Trait+'a {\n+        fn bar(&self) { self.foo() }\n+    }\n }\n \n fn main() {}\n-", "previous_filename": "src/test/compile-fail/impl-not-adjacent-to-type.rs"}]}