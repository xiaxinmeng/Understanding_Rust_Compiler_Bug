{"sha": "797095a686bdc821143e52ed1db2b98db9d0f3eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NzA5NWE2ODZiZGM4MjExNDNlNTJlZDFkYjJiOThkYjlkMGYzZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-21T01:29:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-21T01:29:12Z"}, "message": "Auto merge of #88149 - Mark-Simulacrum:prep-never-type, r=jackh726\n\nRefactor fallback code to prepare for never type\n\nThis PR contains cherry-picks of some of `@nikomatsakis's` work from #79366, and shouldn't (AFAICT) represent any change in behavior. However, the refactoring is good regardless of the never type work being landed, and will reduce the size of those eventual PR(s) (and rebase pain).\n\nI am not personally an expert on this code, and the commits are essentially 100% `@nikomatsakis's,` but they do seem reasonable to me by my understanding. Happy to edit with review, of course. Commits are best reviewed in sequence rather than all together.\n\nr? `@jackh726` perhaps?", "tree": {"sha": "d8477eb9119e98ebb3f6fe68d1fabb7d132edd90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8477eb9119e98ebb3f6fe68d1fabb7d132edd90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/797095a686bdc821143e52ed1db2b98db9d0f3eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/797095a686bdc821143e52ed1db2b98db9d0f3eb", "html_url": "https://github.com/rust-lang/rust/commit/797095a686bdc821143e52ed1db2b98db9d0f3eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/797095a686bdc821143e52ed1db2b98db9d0f3eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e3d632f8f921d03ccc5b71d97decf980df7dbe4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3d632f8f921d03ccc5b71d97decf980df7dbe4", "html_url": "https://github.com/rust-lang/rust/commit/1e3d632f8f921d03ccc5b71d97decf980df7dbe4"}, {"sha": "60cc00f540658cb82bccf88275f9cf409215a6b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/60cc00f540658cb82bccf88275f9cf409215a6b8", "html_url": "https://github.com/rust-lang/rust/commit/60cc00f540658cb82bccf88275f9cf409215a6b8"}], "stats": {"total": 680, "additions": 470, "deletions": 210}, "files": [{"sha": "01d84e287bc9fbf788446269c646562b3cf8086a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -22,14 +22,14 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n-use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::unify_key::replace_if_possible;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use super::{equate::Equate, type_variable::Diverging};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n@@ -643,8 +643,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 .inner\n                                 .borrow_mut()\n                                 .type_variables()\n-                                .new_var(self.for_universe, false, origin);\n+                                .new_var(self.for_universe, Diverging::NotDiverging, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n+\n+                            // Record that we replaced `vid` with `new_var_id` as part of a generalization\n+                            // operation. This is needed to detect cyclic types. To see why, see the\n+                            // docs in the `type_variables` module.\n+                            self.infcx.inner.borrow_mut().type_variables().sub(vid, new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n                         }\n@@ -881,7 +886,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                             *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n                         let new_var_id = self.infcx.inner.borrow_mut().type_variables().new_var(\n                             self.for_universe,\n-                            false,\n+                            Diverging::NotDiverging,\n                             origin,\n                         );\n                         let u = self.tcx().mk_ty_var(new_var_id);"}, {"sha": "80f1a0d325466be9686b934d130f53b147d4924d", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 78, "deletions": 46, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::EvalToConstValueResult;\n use rustc_middle::traits::select;\n-use rustc_middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n@@ -46,7 +46,7 @@ use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, Veri\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n-use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use self::type_variable::{Diverging, TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n pub mod canonical;\n@@ -679,10 +679,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.freshener())\n     }\n \n-    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n+    /// Returns whether `ty` is a diverging type variable or not.\n+    /// (If `ty` is not a type variable at all, returns not diverging.)\n+    ///\n+    /// No attempt is made to resolve `ty`.\n+    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> Diverging {\n         match *ty.kind() {\n             ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n-            _ => false,\n+            _ => Diverging::NotDiverging,\n+        }\n+    }\n+\n+    /// Returns the origin of the type variable identified by `vid`, or `None`\n+    /// if this is not a type variable.\n+    ///\n+    /// No attempt is made to resolve `ty`.\n+    pub fn type_var_origin(&'a self, ty: Ty<'tcx>) -> Option<TypeVariableOrigin> {\n+        match *ty.kind() {\n+            ty::Infer(ty::TyVar(vid)) => {\n+                Some(*self.inner.borrow_mut().type_variables().var_origin(vid))\n+            }\n+            _ => None,\n         }\n     }\n \n@@ -695,28 +712,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         freshen::TypeFreshener::new(self, true)\n     }\n \n-    pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-        match *ty.kind() {\n-            ty::Infer(ty::IntVar(vid)) => {\n-                if self.inner.borrow_mut().int_unification_table().probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedInt\n-                }\n-            }\n-            ty::Infer(ty::FloatVar(vid)) => {\n-                if self.inner.borrow_mut().float_unification_table().probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedFloat\n-                }\n-            }\n-            _ => Neither,\n-        }\n-    }\n-\n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n         let mut inner = self.inner.borrow_mut();\n         let mut vars: Vec<Ty<'_>> = inner\n@@ -969,29 +964,62 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n     }\n \n+    /// Processes a `Coerce` predicate from the fulfillment context.\n+    /// This is NOT the preferred way to handle coercion, which is to\n+    /// invoke `FnCtxt::coerce` or a similar method (see `coercion.rs`).\n+    ///\n+    /// This method here is actually a fallback that winds up being\n+    /// invoked when `FnCtxt::coerce` encounters unresolved type variables\n+    /// and records a coercion predicate. Presently, this method is equivalent\n+    /// to `subtype_predicate` -- that is, \"coercing\" `a` to `b` winds up\n+    /// actually requiring `a <: b`. This is of course a valid coercion,\n+    /// but it's not as flexible as `FnCtxt::coerce` would be.\n+    ///\n+    /// (We may refactor this in the future, but there are a number of\n+    /// practical obstacles. Among other things, `FnCtxt::coerce` presently\n+    /// records adjustments that are required on the HIR in order to perform\n+    /// the coercion, and we don't currently have a way to manage that.)\n+    pub fn coerce_predicate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::PolyCoercePredicate<'tcx>,\n+    ) -> Option<InferResult<'tcx, ()>> {\n+        let subtype_predicate = predicate.map_bound(|p| ty::SubtypePredicate {\n+            a_is_expected: false, // when coercing from `a` to `b`, `b` is expected\n+            a: p.a,\n+            b: p.b,\n+        });\n+        self.subtype_predicate(cause, param_env, subtype_predicate)\n+    }\n+\n     pub fn subtype_predicate(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         predicate: ty::PolySubtypePredicate<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n-        // Subtle: it's ok to skip the binder here and resolve because\n-        // `shallow_resolve` just ignores anything that is not a type\n-        // variable, and because type variable's can't (at present, at\n+        // Check for two unresolved inference variables, in which case we can\n+        // make no progress. This is partly a micro-optimization, but it's\n+        // also an opportunity to \"sub-unify\" the variables. This isn't\n+        // *necessary* to prevent cycles, because they would eventually be sub-unified\n+        // anyhow during generalization, but it helps with diagnostics (we can detect\n+        // earlier that they are sub-unified).\n+        //\n+        // Note that we can just skip the binders here because\n+        // type variables can't (at present, at\n         // least) capture any of the things bound by this binder.\n         //\n-        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a micro-optimization.\n-        // Naturally I could not resist.\n-        let two_unbound_type_vars = {\n-            let a = self.shallow_resolve(predicate.skip_binder().a);\n-            let b = self.shallow_resolve(predicate.skip_binder().b);\n-            a.is_ty_var() && b.is_ty_var()\n-        };\n-\n-        if two_unbound_type_vars {\n-            // Two unbound type variables? Can't make progress.\n-            return None;\n+        // Note that this sub here is not just for diagnostics - it has semantic\n+        // effects as well.\n+        let r_a = self.shallow_resolve(predicate.skip_binder().a);\n+        let r_b = self.shallow_resolve(predicate.skip_binder().b);\n+        match (r_a.kind(), r_b.kind()) {\n+            (&ty::Infer(ty::TyVar(a_vid)), &ty::Infer(ty::TyVar(b_vid))) => {\n+                self.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n+                return None;\n+            }\n+            _ => {}\n         }\n \n         Some(self.commit_if_ok(|_snapshot| {\n@@ -1020,25 +1048,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: Diverging, origin: TypeVariableOrigin) -> TyVid {\n         self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::NotDiverging, origin))\n     }\n \n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables().new_var(\n+            universe,\n+            Diverging::NotDiverging,\n+            origin,\n+        );\n         self.tcx.mk_ty_var(vid)\n     }\n \n     pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::Diverges, origin))\n     }\n \n     pub fn next_const_var(\n@@ -1152,7 +1184,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // as the substitutions for the default, `(T, U)`.\n                 let ty_var_id = self.inner.borrow_mut().type_variables().new_var(\n                     self.universe(),\n-                    false,\n+                    Diverging::NotDiverging,\n                     TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(\n                             param.name,"}, {"sha": "261c3471a9829bb7d8f8b69c1140171700047165", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -22,6 +22,7 @@\n //!   constituents)\n \n use crate::infer::combine::ConstEquateRelation;\n+use crate::infer::type_variable::Diverging;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use rustc_data_structures::fx::FxHashMap;\n@@ -920,7 +921,8 @@ where\n                             // Replacing with a new variable in the universe `self.universe`,\n                             // it will be unified later with the original type variable in\n                             // the universe `_universe`.\n-                            let new_var_id = variables.new_var(self.universe, false, origin);\n+                            let new_var_id =\n+                                variables.new_var(self.universe, Diverging::NotDiverging, origin);\n \n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);"}, {"sha": "4dd5e8ba545005dfc21113d5f048622f990d1645", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -19,6 +19,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .filter_map(move |kind| match kind {\n             ty::PredicateKind::Projection(..)\n             | ty::PredicateKind::Trait(..)\n+            | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "1692d8ee526d0519474eed4c1016d6715a30130b", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -85,19 +85,15 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n         match (a.kind(), b.kind()) {\n-            (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n+            (&ty::Infer(TyVar(_)), &ty::Infer(TyVar(_))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n                 assert!(!a.has_escaping_bound_vars());\n                 assert!(!b.has_escaping_bound_vars());\n \n                 // can't make progress on `A <: B` if both A and B are\n-                // type variables, so record an obligation. We also\n-                // have to record in the `type_variables` tracker that\n-                // the two variables are equal modulo subtyping, which\n-                // is important to the occurs check later on.\n-                infcx.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n+                // type variables, so record an obligation.\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,"}, {"sha": "d2b0bdaf9780292ae613391470556199ca775968", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -75,14 +75,30 @@ pub struct TypeVariableStorage<'tcx> {\n     ///     ?1 <: ?3\n     ///     Box<?3> <: ?1\n     ///\n-    /// This works because `?1` and `?3` are unified in the\n-    /// `sub_relations` relation (not in `eq_relations`). Then when we\n-    /// process the `Box<?3> <: ?1` constraint, we do an occurs check\n-    /// on `Box<?3>` and find a potential cycle.\n+    /// Without this second table, what would happen in a case like\n+    /// this is that we would instantiate `?1` with a generalized\n+    /// type like `Box<?6>`. We would then relate `Box<?3> <: Box<?6>`\n+    /// and infer that `?3 <: ?6`. Next, since `?1` was instantiated,\n+    /// we would process `?1 <: ?3`, generalize `?1 = Box<?6>` to `Box<?9>`,\n+    /// and instantiate `?3` with `Box<?9>`. Finally, we would relate\n+    /// `?6 <: ?9`. But now that we instantiated `?3`, we can process\n+    /// `?3 <: ?6`, which gives us `Box<?9> <: ?6`... and the cycle\n+    /// continues. (This is `occurs-check-2.rs`.)\n+    ///\n+    /// What prevents this cycle is that when we generalize\n+    /// `Box<?3>` to `Box<?6>`, we also sub-unify `?3` and `?6`\n+    /// (in the generalizer). When we then process `Box<?6> <: ?3`,\n+    /// the occurs check then fails because `?6` and `?3` are sub-unified,\n+    /// and hence generalization fails.\n     ///\n     /// This is reasonable because, in Rust, subtypes have the same\n     /// \"skeleton\" and hence there is no possible type such that\n     /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n+    ///\n+    /// In practice, we sometimes sub-unify variables in other spots, such\n+    /// as when processing subtype predicates. This is not necessary but is\n+    /// done to aid diagnostics, as it allows us to be more effective when\n+    /// we guide the user towards where they should insert type hints.\n     sub_relations: ut::UnificationTableStorage<ty::TyVid>,\n }\n \n@@ -119,7 +135,13 @@ pub enum TypeVariableOriginKind {\n \n pub(crate) struct TypeVariableData {\n     origin: TypeVariableOrigin,\n-    diverging: bool,\n+    diverging: Diverging,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Diverging {\n+    NotDiverging,\n+    Diverges,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -173,7 +195,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n-    pub fn var_diverges(&self, vid: ty::TyVid) -> bool {\n+    pub fn var_diverges(&self, vid: ty::TyVid) -> Diverging {\n         self.storage.values.get(vid.index as usize).diverging\n     }\n \n@@ -238,7 +260,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     pub fn new_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n-        diverging: bool,\n+        diverging: Diverging,\n         origin: TypeVariableOrigin,\n     ) -> ty::TyVid {\n         let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });"}, {"sha": "3a25cb66896d510c751911d94efaba2d1ff6cb91", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -158,6 +158,10 @@ impl Elaborator<'tcx> {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n+            ty::PredicateKind::Coerce(..) => {\n+                // Currently, we do not \"elaborate\" predicates like `X -> Y`,\n+                // though conceivably we might.\n+            }\n             ty::PredicateKind::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }"}, {"sha": "5a72db7752d6338597d354efc687c84d69f1424a", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -1652,6 +1652,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     ObjectSafe(..) |\n                     ClosureKind(..) |\n                     Subtype(..) |\n+                    Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n                     TypeWellFormedFromEnv(..) => continue,"}, {"sha": "1aa6c84dbc414586ed0b28d8ee00e11b3545cd2b", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -71,12 +71,6 @@ pub enum TypeError<'tcx> {\n     TargetFeatureCast(DefId),\n }\n \n-pub enum UnconstrainedNumeric {\n-    UnconstrainedFloat,\n-    UnconstrainedInt,\n-    Neither,\n-}\n-\n /// Explains the source of a type err in a short, human readable way. This is meant to be placed\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related"}, {"sha": "04df706d908423256a82fef9f1d06343b2de35fa", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -231,6 +231,10 @@ impl FlagComputation {\n                 self.add_ty(a);\n                 self.add_ty(b);\n             }\n+            ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) => {\n+                self.add_ty(a);\n+                self.add_ty(b);\n+            }\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 self.add_projection_ty(projection_ty);\n                 self.add_ty(ty);"}, {"sha": "9fcf35b7320778bcecdf39f7355ff94656355981", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -485,8 +485,22 @@ pub enum PredicateKind<'tcx> {\n     ClosureKind(DefId, SubstsRef<'tcx>, ClosureKind),\n \n     /// `T1 <: T2`\n+    ///\n+    /// This obligation is created most often when we have two\n+    /// unresolved type variables and hence don't have enough\n+    /// information to process the subtyping obligation yet.\n     Subtype(SubtypePredicate<'tcx>),\n \n+    /// `T1` coerced to `T2`\n+    ///\n+    /// Like a subtyping obligation, this is created most often\n+    /// when we have two unresolved type variables and hence\n+    /// don't have enough information to process the coercion\n+    /// obligation yet. At the moment, we actually process coercions\n+    /// very much like subtyping and don't handle the full coercion\n+    /// logic.\n+    Coerce(CoercePredicate<'tcx>),\n+\n     /// Constant initializer must evaluate successfully.\n     ConstEvaluatable(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n \n@@ -655,6 +669,9 @@ pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'t\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<'tcx, TypeOutlivesPredicate<'tcx>>;\n \n+/// Encodes that `a` must be a subtype of `b`. The `a_is_expected` flag indicates\n+/// whether the `a` type is the type that we should label as \"expected\" when\n+/// presenting user diagnostics.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct SubtypePredicate<'tcx> {\n@@ -664,6 +681,15 @@ pub struct SubtypePredicate<'tcx> {\n }\n pub type PolySubtypePredicate<'tcx> = ty::Binder<'tcx, SubtypePredicate<'tcx>>;\n \n+/// Encodes that we have to coerce *from* the `a` type to the `b` type.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(HashStable, TypeFoldable)]\n+pub struct CoercePredicate<'tcx> {\n+    pub a: Ty<'tcx>,\n+    pub b: Ty<'tcx>,\n+}\n+pub type PolyCoercePredicate<'tcx> = ty::Binder<'tcx, CoercePredicate<'tcx>>;\n+\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n@@ -806,6 +832,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n             PredicateKind::Projection(..)\n             | PredicateKind::Subtype(..)\n+            | PredicateKind::Coerce(..)\n             | PredicateKind::RegionOutlives(..)\n             | PredicateKind::WellFormed(..)\n             | PredicateKind::ObjectSafe(..)\n@@ -824,6 +851,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Trait(..)\n             | PredicateKind::Projection(..)\n             | PredicateKind::Subtype(..)\n+            | PredicateKind::Coerce(..)\n             | PredicateKind::RegionOutlives(..)\n             | PredicateKind::WellFormed(..)\n             | PredicateKind::ObjectSafe(..)"}, {"sha": "8558d6bb00e724a79dbf9cde7985a7a3aac5e538", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -2236,6 +2236,10 @@ define_print_and_forward_display! {\n         p!(print(self.a), \" <: \", print(self.b))\n     }\n \n+    ty::CoercePredicate<'tcx> {\n+        p!(print(self.a), \" -> \", print(self.b))\n+    }\n+\n     ty::TraitPredicate<'tcx> {\n         p!(print(self.trait_ref.self_ty()), \": \",\n            print(self.trait_ref.print_only_trait_path()))\n@@ -2268,6 +2272,7 @@ define_print_and_forward_display! {\n                 p!(print(data))\n             }\n             ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::Coerce(predicate) => p!(print(predicate)),\n             ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateKind::Projection(predicate) => p!(print(predicate)),"}, {"sha": "a46cac1e7f7f55e55348909df62e8c6716d64dab", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -179,6 +179,7 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n         match *self {\n             ty::PredicateKind::Trait(ref a) => a.fmt(f),\n             ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::Coerce(ref pair) => pair.fmt(f),\n             ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n@@ -380,6 +381,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::CoercePredicate<'a> {\n+    type Lifted = ty::CoercePredicate<'tcx>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::CoercePredicate<'tcx>> {\n+        tcx.lift((self.a, self.b)).map(|(a, b)| ty::CoercePredicate { a, b })\n+    }\n+}\n+\n impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -420,6 +428,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n         match self {\n             ty::PredicateKind::Trait(data) => tcx.lift(data).map(ty::PredicateKind::Trait),\n             ty::PredicateKind::Subtype(data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n+            ty::PredicateKind::Coerce(data) => tcx.lift(data).map(ty::PredicateKind::Coerce),\n             ty::PredicateKind::RegionOutlives(data) => {\n                 tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n             }"}, {"sha": "09e908e675731e5be10295be1dc02e1e36073e0c", "filename": "compiler/rustc_mir/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -420,8 +420,8 @@ impl Checker<'mir, 'tcx> {\n                     ty::PredicateKind::ClosureKind(..) => {\n                         bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                     }\n-                    ty::PredicateKind::Subtype(_) => {\n-                        bug!(\"subtype predicate on function: {:#?}\", predicate)\n+                    ty::PredicateKind::Subtype(_) | ty::PredicateKind::Coerce(_) => {\n+                        bug!(\"subtype/coerce predicate on function: {:#?}\", predicate)\n                     }\n                     ty::PredicateKind::Trait(pred) => {\n                         if Some(pred.def_id()) == tcx.lang_items().sized_trait() {"}, {"sha": "e6686b8cc7070666b89827db9135c443a8968101", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -1119,6 +1119,7 @@ crate fn required_region_bounds(\n                 ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)"}, {"sha": "2c09c551b656fac19efc42007ee335fc5f152bb1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -565,6 +565,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n+                    ty::PredicateKind::Coerce(predicate) => {\n+                        // Errors for Coerce predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"coerce requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n                     ty::PredicateKind::RegionOutlives(predicate) => {\n                         let predicate = bound_predicate.rebind(predicate);\n                         let predicate = self.resolve_vars_if_possible(predicate);"}, {"sha": "a2095907c7a2d4399a07edeca6090d06cba48903", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -402,6 +402,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::Coerce(_)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => {\n                     let pred = infcx.replace_bound_vars_with_placeholders(binder);\n@@ -517,6 +518,31 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     }\n                 }\n \n+                ty::PredicateKind::Coerce(coerce) => {\n+                    match self.selcx.infcx().coerce_predicate(\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                        Binder::dummy(coerce),\n+                    ) {\n+                        None => {\n+                            // None means that both are unresolved.\n+                            pending_obligation.stalled_on = vec![\n+                                TyOrConstInferVar::maybe_from_ty(coerce.a).unwrap(),\n+                                TyOrConstInferVar::maybe_from_ty(coerce.b).unwrap(),\n+                            ];\n+                            ProcessResult::Unchanged\n+                        }\n+                        Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                        Some(Err(err)) => {\n+                            let expected_found = ExpectedFound::new(false, coerce.a, coerce.b);\n+                            ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n+                                expected_found,\n+                                err,\n+                            ))\n+                        }\n+                    }\n+                }\n+\n                 ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.selcx.infcx(),"}, {"sha": "02b43de0d1606c0e425106fe1ff66d2294f51774", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -308,6 +308,7 @@ fn predicate_references_self(\n         | ty::PredicateKind::RegionOutlives(..)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n@@ -336,6 +337,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             }\n             ty::PredicateKind::Projection(..)\n             | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::RegionOutlives(..)\n             | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "c9bcc44fab6347bb80b2d623cb27cfd6364de2b0", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -512,6 +512,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n+                ty::PredicateKind::Coerce(p) => {\n+                    let p = bound_predicate.rebind(p);\n+                    // Does this code ever run?\n+                    match self.infcx.coerce_predicate(&obligation.cause, obligation.param_env, p) {\n+                        Some(Ok(InferOk { mut obligations, .. })) => {\n+                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+                            self.evaluate_predicates_recursively(\n+                                previous_stack,\n+                                obligations.into_iter(),\n+                            )\n+                        }\n+                        Some(Err(_)) => Ok(EvaluatedToErr),\n+                        None => Ok(EvaluatedToAmbig),\n+                    }\n+                }\n+\n                 ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n                     self.infcx,\n                     obligation.param_env,"}, {"sha": "afef784b4c6cce4986254954e84ec281b2e105ea", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -128,6 +128,10 @@ pub fn predicate_obligations<'a, 'tcx>(\n             wf.compute(a.into());\n             wf.compute(b.into());\n         }\n+        ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) => {\n+            wf.compute(a.into());\n+            wf.compute(b.into());\n+        }\n         ty::PredicateKind::ConstEvaluatable(def, substs) => {\n             let obligations = wf.nominal_obligations(def.did, substs);\n             wf.out.extend(obligations);"}, {"sha": "330fd497fa1f83eea5105c4cd705dea4ed38626c", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -109,6 +109,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n@@ -193,6 +194,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             // some of these in terms of chalk operations.\n             ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n@@ -592,6 +594,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -719,6 +722,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {"}, {"sha": "1d10d06849062f4e307434c41a59d0a7c1eb0f83", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -99,6 +99,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 Some(pred) => match pred {\n                     ty::PredicateKind::Trait(..)\n                     | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::Projection(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "61ab5e28b6796151eabdf015a72abfc247aa0a41", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -65,6 +65,7 @@ fn not_outlives_predicate(p: &ty::Predicate<'tcx>) -> bool {\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,"}, {"sha": "0b4df8e6d3cdd5d55bef2c4f4ebfcaf9cd14342b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -42,6 +42,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -50,7 +51,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TypeAndMut};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TypeAndMut};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, Span};\n@@ -146,14 +147,17 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        // First, remove any resolved type variables (at the top level, at least):\n         let a = self.shallow_resolve(a);\n+        let b = self.shallow_resolve(b);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n             return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n         }\n \n+        // Coercing from `!` to any type is allowed:\n         if a.is_never() {\n             // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n             // type variable, we want `?T` to fallback to `!` if not\n@@ -162,20 +166,26 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             //     let _: Option<?T> = Some({ return; });\n             //\n             // here, we would coerce from `!` to `?T`.\n-            let b = self.shallow_resolve(b);\n-            return if self.shallow_resolve(b).is_ty_var() {\n+            return if b.is_ty_var() {\n                 // Micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::AdjustmentType,\n                     span: self.cause.span,\n                 });\n-                self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n+                self.coerce_from_inference_variable(diverging_ty, b, simple(Adjust::NeverToAny))\n             } else {\n                 success(simple(Adjust::NeverToAny)(b), b, vec![])\n             };\n         }\n \n+        // Coercing *from* an unresolved inference variable means that\n+        // we have no information about the source type. This will always\n+        // ultimately fall back to some form of subtyping.\n+        if a.is_ty_var() {\n+            return self.coerce_from_inference_variable(a, b, identity);\n+        }\n+\n         // Consider coercing the subtype to a DST\n         //\n         // NOTE: this is wrapped in a `commit_if_ok` because it creates\n@@ -196,9 +206,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         debug!(\"coerce: unsize failed\");\n \n         // Examine the supertype and consider auto-borrowing.\n-        //\n-        // Note: does not attempt to resolve type variables we encounter.\n-        // See above for details.\n         match *b.kind() {\n             ty::RawPtr(mt_b) => {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n@@ -236,6 +243,58 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n+    /// Coercing *from* an inference variable. In this case, we have no information\n+    /// about the source type, so we can't really do a true coercion and we always\n+    /// fall back to subtyping (`unify_and`).\n+    fn coerce_from_inference_variable(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        make_adjustments: impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n+    ) -> CoerceResult<'tcx> {\n+        debug!(\"coerce_from_inference_variable(a={:?}, b={:?})\", a, b);\n+        assert!(a.is_ty_var() && self.infcx.shallow_resolve(a) == a);\n+        assert!(self.infcx.shallow_resolve(b) == b);\n+\n+        if b.is_ty_var() {\n+            // Two unresolved type variables: create a `Coerce` predicate.\n+            let target_ty = if self.use_lub {\n+                self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::LatticeVariable,\n+                    span: self.cause.span,\n+                })\n+            } else {\n+                b\n+            };\n+\n+            let mut obligations = Vec::with_capacity(2);\n+            for &source_ty in &[a, b] {\n+                if source_ty != target_ty {\n+                    obligations.push(Obligation::new(\n+                        self.cause.clone(),\n+                        self.param_env,\n+                        ty::PredicateKind::Coerce(ty::CoercePredicate {\n+                            a: source_ty,\n+                            b: target_ty,\n+                        })\n+                        .to_predicate(self.tcx()),\n+                    ));\n+                }\n+            }\n+\n+            debug!(\n+                \"coerce_from_inference_variable: two inference variables, target_ty={:?}, obligations={:?}\",\n+                target_ty, obligations\n+            );\n+            let adjustments = make_adjustments(target_ty);\n+            InferResult::Ok(InferOk { value: (adjustments, target_ty), obligations })\n+        } else {\n+            // One unresolved type variable: just apply subtyping, we may be able\n+            // to do something useful.\n+            self.unify_and(a, b, make_adjustments)\n+        }\n+    }\n+\n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary."}, {"sha": "69a8970ae094e8c4cdca183a83eb0fe7e08677f8", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -0,0 +1,157 @@\n+use crate::check::FnCtxt;\n+use rustc_infer::infer::type_variable::Diverging;\n+use rustc_middle::ty::{self, Ty};\n+\n+impl<'tcx> FnCtxt<'_, 'tcx> {\n+    pub(super) fn type_inference_fallback(&self) {\n+        // All type checking constraints were added, try to fallback unsolved variables.\n+        self.select_obligations_where_possible(false, |_| {});\n+        let mut fallback_has_occurred = false;\n+\n+        // We do fallback in two passes, to try to generate\n+        // better error messages.\n+        // The first time, we do *not* replace opaque types.\n+        for ty in &self.unsolved_variables() {\n+            debug!(\"unsolved_variable = {:?}\", ty);\n+            fallback_has_occurred |= self.fallback_if_possible(ty);\n+        }\n+\n+        // We now see if we can make progress. This might\n+        // cause us to unify inference variables for opaque types,\n+        // since we may have unified some other type variables\n+        // during the first phase of fallback.\n+        // This means that we only replace inference variables with their underlying\n+        // opaque types as a last resort.\n+        //\n+        // In code like this:\n+        //\n+        // ```rust\n+        // type MyType = impl Copy;\n+        // fn produce() -> MyType { true }\n+        // fn bad_produce() -> MyType { panic!() }\n+        // ```\n+        //\n+        // we want to unify the opaque inference variable in `bad_produce`\n+        // with the diverging fallback for `panic!` (e.g. `()` or `!`).\n+        // This will produce a nice error message about conflicting concrete\n+        // types for `MyType`.\n+        //\n+        // If we had tried to fallback the opaque inference variable to `MyType`,\n+        // we will generate a confusing type-check error that does not explicitly\n+        // refer to opaque types.\n+        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n+        // We now run fallback again, but this time we allow it to replace\n+        // unconstrained opaque type variables, in addition to performing\n+        // other kinds of fallback.\n+        for ty in &self.unsolved_variables() {\n+            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n+        }\n+\n+        // See if we can make any more progress.\n+        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+    }\n+\n+    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n+    //\n+    // - Unconstrained ints are replaced with `i32`.\n+    //\n+    // - Unconstrained floats are replaced with with `f64`.\n+    //\n+    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n+    //   is enabled. Otherwise, they are replaced with `()`.\n+    //\n+    // Fallback becomes very dubious if we have encountered type-checking errors.\n+    // In that case, fallback to Error.\n+    // The return value indicates whether fallback has occurred.\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+        // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n+        // is an unsolved variable, and we determine its fallback based\n+        // solely on how it was created, not what other type variables\n+        // it may have been unified with since then.\n+        //\n+        // The reason this matters is that other attempts at fallback may\n+        // (in principle) conflict with this fallback, and we wish to generate\n+        // a type error in that case. (However, this actually isn't true right now,\n+        // because we're only using the builtin fallback rules. This would be\n+        // true if we were using user-supplied fallbacks. But it's still useful\n+        // to write the code to detect bugs.)\n+        //\n+        // (Note though that if we have a general type variable `?T` that is then unified\n+        // with an integer type variable `?I` that ultimately never gets\n+        // resolved to a special integral type, `?T` is not considered unsolved,\n+        // but `?I` is. The same is true for float variables.)\n+        let fallback = match ty.kind() {\n+            _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n+            ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n+            _ => match self.type_var_diverges(ty) {\n+                Diverging::Diverges => self.tcx.mk_diverging_default(),\n+                Diverging::NotDiverging => return false,\n+            },\n+        };\n+        debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n+\n+        let span = self\n+            .infcx\n+            .type_var_origin(ty)\n+            .map(|origin| origin.span)\n+            .unwrap_or(rustc_span::DUMMY_SP);\n+        self.demand_eqtype(span, ty, fallback);\n+        true\n+    }\n+\n+    /// Second round of fallback: Unconstrained type variables\n+    /// created from the instantiation of an opaque\n+    /// type fall back to the opaque type itself. This is a\n+    /// somewhat incomplete attempt to manage \"identity passthrough\"\n+    /// for `impl Trait` types.\n+    ///\n+    /// For example, in this code:\n+    ///\n+    ///```\n+    /// type MyType = impl Copy;\n+    /// fn defining_use() -> MyType { true }\n+    /// fn other_use() -> MyType { defining_use() }\n+    /// ```\n+    ///\n+    /// `defining_use` will constrain the instantiated inference\n+    /// variable to `bool`, while `other_use` will constrain\n+    /// the instantiated inference variable to `MyType`.\n+    ///\n+    /// When we process opaque types during writeback, we\n+    /// will handle cases like `other_use`, and not count\n+    /// them as defining usages\n+    ///\n+    /// However, we also need to handle cases like this:\n+    ///\n+    /// ```rust\n+    /// pub type Foo = impl Copy;\n+    /// fn produce() -> Option<Foo> {\n+    ///     None\n+    ///  }\n+    ///  ```\n+    ///\n+    /// In the above snippet, the inference variable created by\n+    /// instantiating `Option<Foo>` will be completely unconstrained.\n+    /// We treat this as a non-defining use by making the inference\n+    /// variable fall back to the opaque type itself.\n+    fn fallback_opaque_type_vars(&self, ty: Ty<'tcx>) -> bool {\n+        let span = self\n+            .infcx\n+            .type_var_origin(ty)\n+            .map(|origin| origin.span)\n+            .unwrap_or(rustc_span::DUMMY_SP);\n+        let oty = self.inner.borrow().opaque_types_vars.get(ty).map(|v| *v);\n+        if let Some(opaque_ty) = oty {\n+            debug!(\n+                \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\",\n+                ty, opaque_ty\n+            );\n+            self.demand_eqtype(span, ty, opaque_ty);\n+            true\n+        } else {\n+            return false;\n+        }\n+    }\n+}"}, {"sha": "bb80f0879a4aa4bff7c88ec3524234296c91051b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 78, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -4,7 +4,7 @@ use crate::astconv::{\n };\n use crate::check::callee::{self, DeferredCallResolution};\n use crate::check::method::{self, MethodCallee, SelfSource};\n-use crate::check::{BreakableCtxt, Diverges, Expectation, FallbackMode, FnCtxt, LocalTy};\n+use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n \n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::captures::Captures;\n@@ -635,83 +635,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n-    //\n-    // - Unconstrained ints are replaced with `i32`.\n-    //\n-    // - Unconstrained floats are replaced with with `f64`.\n-    //\n-    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n-    //   is enabled. Otherwise, they are replaced with `()`.\n-    //\n-    // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to Error.\n-    // The return value indicates whether fallback has occurred.\n-    pub(in super::super) fn fallback_if_possible(&self, ty: Ty<'tcx>, mode: FallbackMode) -> bool {\n-        use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-\n-        assert!(ty.is_ty_infer());\n-        let fallback = match self.type_is_unconstrained_numeric(ty) {\n-            _ if self.is_tainted_by_errors() => self.tcx().ty_error(),\n-            UnconstrainedInt => self.tcx.types.i32,\n-            UnconstrainedFloat => self.tcx.types.f64,\n-            Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n-            Neither => {\n-                // This type variable was created from the instantiation of an opaque\n-                // type. The fact that we're attempting to perform fallback for it\n-                // means that the function neither constrained it to a concrete\n-                // type, nor to the opaque type itself.\n-                //\n-                // For example, in this code:\n-                //\n-                //```\n-                // type MyType = impl Copy;\n-                // fn defining_use() -> MyType { true }\n-                // fn other_use() -> MyType { defining_use() }\n-                // ```\n-                //\n-                // `defining_use` will constrain the instantiated inference\n-                // variable to `bool`, while `other_use` will constrain\n-                // the instantiated inference variable to `MyType`.\n-                //\n-                // When we process opaque types during writeback, we\n-                // will handle cases like `other_use`, and not count\n-                // them as defining usages\n-                //\n-                // However, we also need to handle cases like this:\n-                //\n-                // ```rust\n-                // pub type Foo = impl Copy;\n-                // fn produce() -> Option<Foo> {\n-                //     None\n-                //  }\n-                //  ```\n-                //\n-                // In the above snippet, the inference variable created by\n-                // instantiating `Option<Foo>` will be completely unconstrained.\n-                // We treat this as a non-defining use by making the inference\n-                // variable fall back to the opaque type itself.\n-                if let FallbackMode::All = mode {\n-                    if let Some(opaque_ty) = self.infcx.inner.borrow().opaque_types_vars.get(ty) {\n-                        debug!(\n-                            \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n-                            ty, opaque_ty\n-                        );\n-                        *opaque_ty\n-                    } else {\n-                        return false;\n-                    }\n-                } else {\n-                    return false;\n-                }\n-            }\n-        };\n-        debug!(\"fallback_if_possible: defaulting `{:?}` to `{:?}`\", ty, fallback);\n-        self.demand_eqtype(rustc_span::DUMMY_SP, ty, fallback);\n-        true\n-    }\n-\n     pub(in super::super) fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n         if let Err(errors) = self\n@@ -807,6 +730,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }\n                     ty::PredicateKind::Subtype(..) => None,\n+                    ty::PredicateKind::Coerce(..) => None,\n                     ty::PredicateKind::RegionOutlives(..) => None,\n                     ty::PredicateKind::TypeOutlives(..) => None,\n                     ty::PredicateKind::WellFormed(..) => None,"}, {"sha": "486e4d15d6580de4f251e985fe46496b16072965", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -841,6 +841,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     }\n                 }\n                 ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::WellFormed(..)"}, {"sha": "ad7e96e2833b84b65fb00e28fa918532d8740e43", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -75,6 +75,7 @@ mod diverges;\n pub mod dropck;\n mod expectation;\n mod expr;\n+mod fallback;\n mod fn_ctxt;\n mod gather_locals;\n mod generator_interior;\n@@ -445,50 +446,7 @@ fn typeck_with_fallback<'tcx>(\n             fcx\n         };\n \n-        // All type checking constraints were added, try to fallback unsolved variables.\n-        fcx.select_obligations_where_possible(false, |_| {});\n-        let mut fallback_has_occurred = false;\n-\n-        // We do fallback in two passes, to try to generate\n-        // better error messages.\n-        // The first time, we do *not* replace opaque types.\n-        for ty in &fcx.unsolved_variables() {\n-            fallback_has_occurred |= fcx.fallback_if_possible(ty, FallbackMode::NoOpaque);\n-        }\n-        // We now see if we can make progress. This might\n-        // cause us to unify inference variables for opaque types,\n-        // since we may have unified some other type variables\n-        // during the first phase of fallback.\n-        // This means that we only replace inference variables with their underlying\n-        // opaque types as a last resort.\n-        //\n-        // In code like this:\n-        //\n-        // ```rust\n-        // type MyType = impl Copy;\n-        // fn produce() -> MyType { true }\n-        // fn bad_produce() -> MyType { panic!() }\n-        // ```\n-        //\n-        // we want to unify the opaque inference variable in `bad_produce`\n-        // with the diverging fallback for `panic!` (e.g. `()` or `!`).\n-        // This will produce a nice error message about conflicting concrete\n-        // types for `MyType`.\n-        //\n-        // If we had tried to fallback the opaque inference variable to `MyType`,\n-        // we will generate a confusing type-check error that does not explicitly\n-        // refer to opaque types.\n-        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n-        // We now run fallback again, but this time we allow it to replace\n-        // unconstrained opaque type variables, in addition to performing\n-        // other kinds of fallback.\n-        for ty in &fcx.unsolved_variables() {\n-            fallback_has_occurred |= fcx.fallback_if_possible(ty, FallbackMode::All);\n-        }\n-\n-        // See if we can make any more progress.\n-        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+        fcx.type_inference_fallback();\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n@@ -914,16 +872,6 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-/// Controls how we perform fallback for unconstrained\n-/// type variables.\n-enum FallbackMode {\n-    /// Do not fallback type variables to opaque types.\n-    NoOpaque,\n-    /// Perform all possible kinds of fallback, including\n-    /// turning type variables to opaque types.\n-    All,\n-}\n-\n /// A wrapper for `InferCtxt`'s `in_progress_typeck_results` field.\n #[derive(Copy, Clone)]\n struct MaybeInProgressTables<'a, 'tcx> {"}, {"sha": "e148370a03610f3389e6716b7d7b67e5e32ea1a3", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -407,6 +407,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::Projection(_)\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)\n+        | ty::PredicateKind::Coerce(_)\n         | ty::PredicateKind::ObjectSafe(_)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)"}, {"sha": "2ac1a18cffaf1caa6455fd2e45fbf2b4357ff4c2", "filename": "compiler/rustc_typeck/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -56,6 +56,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),"}, {"sha": "b6ff3890c584edf4268078af879d13d6d75627d7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -332,6 +332,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n             ty::PredicateKind::ConstEvaluatable(..) => None,\n \n             ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)"}, {"sha": "8e544f580665ee23d7e3d6a1322aa32b7f0f4026", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/797095a686bdc821143e52ed1db2b98db9d0f3eb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/797095a686bdc821143e52ed1db2b98db9d0f3eb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=797095a686bdc821143e52ed1db2b98db9d0f3eb", "patch": "@@ -36,6 +36,9 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::Coerce(_) => {\n+                    panic!(\"coerce predicate on function: {:#?}\", predicate)\n+                },\n                 ty::PredicateKind::Trait(pred) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;"}]}