{"sha": "5f5dc20d85dead5fbd51d163451f796255c9faea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNWRjMjBkODVkZWFkNWZiZDUxZDE2MzQ1MWY3OTYyNTVjOWZhZWE=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-10T15:03:15Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-14T12:52:57Z"}, "message": "Try implementing integer type inference (WIP)", "tree": {"sha": "2027553e671ee8c94dd1b6e5045868fd479cd682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2027553e671ee8c94dd1b6e5045868fd479cd682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f5dc20d85dead5fbd51d163451f796255c9faea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f5dc20d85dead5fbd51d163451f796255c9faea", "html_url": "https://github.com/rust-lang/rust/commit/5f5dc20d85dead5fbd51d163451f796255c9faea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f5dc20d85dead5fbd51d163451f796255c9faea/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "html_url": "https://github.com/rust-lang/rust/commit/a6146d35b1615cf5fb908b29f34e58bfde3bf96d"}], "stats": {"total": 175, "additions": 129, "deletions": 46}, "files": [{"sha": "bc8515836d09e3e8d3c8a94eaceab36317de6eb6", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -11,6 +11,7 @@ use ra_syntax::{\n };\n \n use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n+use crate::ty::primitive::{UintTy, IntTy, FloatTy, UncertainIntTy, UncertainFloatTy};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n@@ -112,9 +113,8 @@ pub enum Literal {\n     ByteString(Vec<u8>),\n     Char(char),\n     Bool(bool),\n-    Byte(u8),\n-    Int, // this and float need additional information\n-    Float,\n+    Int(u64, UncertainIntTy),\n+    Float(u64, UncertainFloatTy), // FIXME: f64 is not Eq\n     Tuple { values: Vec<ExprId> },\n     Array { values: Vec<ExprId> },\n }\n@@ -328,13 +328,7 @@ impl Expr {\n                         f(val);\n                     }\n                 }\n-                Literal::String(..)\n-                | Literal::ByteString(..)\n-                | Literal::Byte(..)\n-                | Literal::Bool(..)\n-                | Literal::Char(..)\n-                | Literal::Int\n-                | Literal::Float => {}\n+                _ => {}\n             },\n         }\n     }\n@@ -669,8 +663,43 @@ impl ExprCollector {\n \n                 if let Some(c) = child {\n                     let lit = match c.kind() {\n-                        SyntaxKind::INT_NUMBER => Literal::Int,\n-                        SyntaxKind::FLOAT_NUMBER => Literal::Float,\n+                        SyntaxKind::INT_NUMBER => {\n+                            let text = c.text().to_string();\n+\n+                            // FIXME: don't do it like this. maybe use something like\n+                            // the IntTy::from_name functions\n+                            let ty = if text.ends_with(\"isize\") {\n+                                UncertainIntTy::Signed(IntTy::Isize)\n+                            } else if text.ends_with(\"i128\") {\n+                                UncertainIntTy::Signed(IntTy::I128)\n+                            } else if text.ends_with(\"i64\") {\n+                                UncertainIntTy::Signed(IntTy::I64)\n+                            } else if text.ends_with(\"i32\") {\n+                                UncertainIntTy::Signed(IntTy::I32)\n+                            } else if text.ends_with(\"i16\") {\n+                                UncertainIntTy::Signed(IntTy::I16)\n+                            } else if text.ends_with(\"i8\") {\n+                                UncertainIntTy::Signed(IntTy::I8)\n+                            } else if text.ends_with(\"usize\") {\n+                                UncertainIntTy::Unsigned(UintTy::Usize)\n+                            } else if text.ends_with(\"u128\") {\n+                                UncertainIntTy::Unsigned(UintTy::U128)\n+                            } else if text.ends_with(\"u64\") {\n+                                UncertainIntTy::Unsigned(UintTy::U64)\n+                            } else if text.ends_with(\"u32\") {\n+                                UncertainIntTy::Unsigned(UintTy::U32)\n+                            } else if text.ends_with(\"u16\") {\n+                                UncertainIntTy::Unsigned(UintTy::U16)\n+                            } else if text.ends_with(\"u8\") {\n+                                UncertainIntTy::Unsigned(UintTy::U8)\n+                            } else {\n+                                UncertainIntTy::Unknown\n+                            };\n+\n+                            // TODO: actually parse integer\n+                            Literal::Int(0u64, ty)\n+                        }\n+                        SyntaxKind::FLOAT_NUMBER => Literal::Float(0, UncertainFloatTy::Unknown),\n                         SyntaxKind::STRING => {\n                             // FIXME: this likely includes the \" characters\n                             let text = c.text().to_string();\n@@ -698,7 +727,10 @@ impl ExprCollector {\n                         }\n                         SyntaxKind::BYTE => {\n                             let character = c.text().char_at(1).unwrap_or('X');\n-                            Literal::Byte(character as u8)\n+                            Literal::Int(\n+                                character as u8 as u64,\n+                                UncertainIntTy::Unsigned(UintTy::U8),\n+                            )\n                         }\n                         _ => return self.alloc_expr(Expr::Missing, syntax_ptr),\n                     };"}, {"sha": "13a1c2907710d91d106f1a44d139e89c95c3255c", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -14,7 +14,7 @@\n //! rustc.\n \n mod autoderef;\n-mod primitive;\n+pub(crate) mod primitive;\n #[cfg(test)]\n mod tests;\n pub(crate) mod method_resolution;\n@@ -151,14 +151,13 @@ pub enum Ty {\n     /// (a non-surrogate code point). Written as `char`.\n     Char,\n \n-    /// A primitive signed integer type. For example, `i32`.\n-    Int(primitive::IntTy),\n-\n-    /// A primitive unsigned integer type. For example, `u32`.\n-    Uint(primitive::UintTy),\n+    /// A primitive integer type. For example, `i32`.\n+    Int(primitive::UncertainIntTy),\n \n+    // /// A primitive unsigned integer type. For example, `u32`.\n+    // Uint(primitive::UintTy),\n     /// A primitive floating-point type. For example, `f64`.\n-    Float(primitive::FloatTy),\n+    Float(primitive::UncertainFloatTy),\n \n     /// Structures, enumerations and unions.\n     Adt {\n@@ -318,11 +317,9 @@ impl Ty {\n                 return Ok(Ty::Char);\n             } else if let Some(KnownName::Str) = name.as_known_name() {\n                 return Ok(Ty::Str);\n-            } else if let Some(int_ty) = primitive::IntTy::from_name(name) {\n+            } else if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n                 return Ok(Ty::Int(int_ty));\n-            } else if let Some(uint_ty) = primitive::UintTy::from_name(name) {\n-                return Ok(Ty::Uint(uint_ty));\n-            } else if let Some(float_ty) = primitive::FloatTy::from_name(name) {\n+            } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n                 return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n@@ -392,7 +389,6 @@ impl fmt::Display for Ty {\n             Ty::Bool => write!(f, \"bool\"),\n             Ty::Char => write!(f, \"char\"),\n             Ty::Int(t) => write!(f, \"{}\", t.ty_to_string()),\n-            Ty::Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n             Ty::Float(t) => write!(f, \"{}\", t.ty_to_string()),\n             Ty::Str => write!(f, \"str\"),\n             Ty::Slice(t) => write!(f, \"[{}]\", t),\n@@ -587,7 +583,7 @@ fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseAnd\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match rhs_ty {\n-            Ty::Uint(..) | Ty::Int(..) | Ty::Float(..) => rhs_ty,\n+            Ty::Int(..) | Ty::Float(..) => rhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::RangeRightOpen | BinaryOp::RangeRightClosed => Ty::Unknown,\n@@ -598,7 +594,7 @@ fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n         BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::Bool,\n         BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n-            Ty::Uint(..) | Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n+            Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::LesserEqualTest\n@@ -625,7 +621,7 @@ fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseAnd\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match lhs_ty {\n-            Ty::Uint(..) | Ty::Int(..) | Ty::Float(..) => lhs_ty,\n+            Ty::Int(..) | Ty::Float(..) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         _ => Ty::Unknown,\n@@ -695,13 +691,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match (&*ty1, &*ty2) {\n             (Ty::Unknown, ..) => true,\n             (.., Ty::Unknown) => true,\n-            (Ty::Bool, _)\n-            | (Ty::Str, _)\n-            | (Ty::Never, _)\n-            | (Ty::Char, _)\n-            | (Ty::Int(..), Ty::Int(..))\n-            | (Ty::Uint(..), Ty::Uint(..))\n-            | (Ty::Float(..), Ty::Float(..)) => ty1 == ty2,\n+            (Ty::Int(t1), Ty::Int(t2)) => match (t1, t2) {\n+                (primitive::UncertainIntTy::Unknown, _)\n+                | (_, primitive::UncertainIntTy::Unknown) => true,\n+                _ => t1 == t2,\n+            },\n+            (Ty::Float(t1), Ty::Float(t2)) => match (t1, t2) {\n+                (primitive::UncertainFloatTy::Unknown, _)\n+                | (_, primitive::UncertainFloatTy::Unknown) => true,\n+                _ => t1 == t2,\n+            },\n+            (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n             (\n                 Ty::Adt {\n                     def_id: def_id1, ..\n@@ -1071,11 +1071,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Literal::Bool(..) => Ty::Bool,\n                 Literal::String(..) => Ty::Ref(Arc::new(Ty::Str), Mutability::Shared),\n                 Literal::ByteString(..) => {\n-                    let byte_type = Arc::new(Ty::Uint(primitive::UintTy::U8));\n+                    let byte_type = Arc::new(Ty::Int(primitive::UncertainIntTy::Unsigned(\n+                        primitive::UintTy::U8,\n+                    )));\n                     let slice_type = Arc::new(Ty::Slice(byte_type));\n                     Ty::Ref(slice_type, Mutability::Shared)\n                 }\n-                Literal::Byte(..) => Ty::Uint(primitive::UintTy::U8),\n                 Literal::Char(..) => Ty::Char,\n                 Literal::Tuple { values } => {\n                     let mut inner_tys = Vec::new();\n@@ -1095,8 +1096,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     // available\n                     Ty::Slice(Arc::new(inner_ty))\n                 }\n-                // TODO\n-                Literal::Int | Literal::Float => Ty::Unknown,\n+                Literal::Int(_v, ty) => Ty::Int(*ty),\n+                Literal::Float(_v, ty) => Ty::Float(*ty),\n             },\n         };\n         // use a new type variable if we got Ty::Unknown here"}, {"sha": "5741ca90d3763ad397ddb4dd018be7bb70714655", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -2,6 +2,56 @@ use std::fmt;\n \n use crate::{Name, KnownName};\n \n+#[derive(Debug, Clone, Eq, PartialEq, Hash, Copy)]\n+pub enum UncertainIntTy {\n+    Unknown,\n+    Unsigned(UintTy),\n+    Signed(IntTy),\n+}\n+\n+impl UncertainIntTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            UncertainIntTy::Unknown => \"{integer}\",\n+            UncertainIntTy::Signed(ty) => ty.ty_to_string(),\n+            UncertainIntTy::Unsigned(ty) => ty.ty_to_string(),\n+        }\n+    }\n+\n+    pub fn from_name(name: &Name) -> Option<UncertainIntTy> {\n+        if let Some(ty) = IntTy::from_name(name) {\n+            Some(UncertainIntTy::Signed(ty))\n+        } else if let Some(ty) = UintTy::from_name(name) {\n+            Some(UncertainIntTy::Unsigned(ty))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq, Hash, Copy)]\n+pub enum UncertainFloatTy {\n+    Unknown,\n+    Known(FloatTy),\n+}\n+\n+impl UncertainFloatTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            UncertainFloatTy::Unknown => \"{float}\",\n+            UncertainFloatTy::Known(ty) => ty.ty_to_string(),\n+        }\n+    }\n+\n+    pub fn from_name(name: &Name) -> Option<UncertainFloatTy> {\n+        if let Some(ty) = FloatTy::from_name(name) {\n+            Some(UncertainFloatTy::Known(ty))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub enum IntTy {\n     Isize,"}, {"sha": "4a3b69b7e20a7fdeea6d3245f1540c9d16ec5812", "filename": "crates/ra_hir/src/ty/tests/data/basics.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -7,7 +7,7 @@\n [55; 56) 'b': isize\n [62; 63) 'c': !\n [69; 70) 'd': &str\n-[76; 82) '1usize': [unknown]\n-[88; 94) '1isize': [unknown]\n+[76; 82) '1usize': usize\n+[88; 94) '1isize': isize\n [100; 106) '\"test\"': &str\n [112; 118) '1.0f32': [unknown]"}, {"sha": "7fdb8a9004c76ed0ff4b2b23892f83212109aada", "filename": "crates/ra_hir/src/ty/tests/data/binary_op.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -16,7 +16,7 @@\n [112; 113) 'y': bool\n [123; 134) 'minus_forty': isize\n [144; 152) '-40isize': isize\n-[145; 152) '40isize': [unknown]\n+[145; 152) '40isize': isize\n [162; 163) 'h': bool\n [166; 177) 'minus_forty': isize\n [166; 188) 'minus_...ONST_2': bool"}, {"sha": "8815dba411b2de3772f05cecf52777b8418d553d", "filename": "crates/ra_hir/src/ty/tests/data/let.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -1,6 +1,6 @@\n [11; 71) '{     ...= b; }': ()\n-[21; 22) 'a': [unknown]\n-[25; 31) '1isize': [unknown]\n+[21; 22) 'a': isize\n+[25; 31) '1isize': isize\n [41; 42) 'b': usize\n [52; 53) '1': usize\n [63; 64) 'c': usize"}, {"sha": "e139d57a8a04ddbb975dc1fd875d2b3cc17f62af", "filename": "crates/ra_hir/src/ty/tests/data/literals.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -1,5 +1,5 @@\n [11; 135) '{     ...lse] }': ()\n-[17; 21) '5i32': [unknown]\n+[17; 21) '5i32': i32\n [27; 34) '\"hello\"': &str\n [40; 48) 'b\"bytes\"': &[u8]\n [54; 57) ''c'': char"}, {"sha": "9b93945ccd21e9d710da1c7ae3066663a4fb117b", "filename": "crates/ra_syntax/src/yellow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f5dc20d85dead5fbd51d163451f796255c9faea/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow.rs?ref=5f5dc20d85dead5fbd51d163451f796255c9faea", "patch": "@@ -128,7 +128,7 @@ impl SyntaxNode {\n     pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n         self.0.root_data()\n     }\n-    \n+\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n         self.0.replace_self(replacement)\n     }"}]}