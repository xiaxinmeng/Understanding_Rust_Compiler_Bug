{"sha": "c9e146515ba391410069a6fe3e55a4a1935bc5ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZTE0NjUxNWJhMzkxNDEwMDY5YTZmZTNlNTVhNGExOTM1YmM1YWU=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-05-07T14:56:17Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-05-08T04:54:34Z"}, "message": "checking on either interior or upvar", "tree": {"sha": "f7eb740df60a49b82d3665990e49e9b97105b38a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7eb740df60a49b82d3665990e49e9b97105b38a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9e146515ba391410069a6fe3e55a4a1935bc5ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e146515ba391410069a6fe3e55a4a1935bc5ae", "html_url": "https://github.com/rust-lang/rust/commit/c9e146515ba391410069a6fe3e55a4a1935bc5ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9e146515ba391410069a6fe3e55a4a1935bc5ae/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2e5a8e2e966df119021e3db6f6d4c2e189865cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e5a8e2e966df119021e3db6f6d4c2e189865cd", "html_url": "https://github.com/rust-lang/rust/commit/d2e5a8e2e966df119021e3db6f6d4c2e189865cd"}], "stats": {"total": 258, "additions": 135, "deletions": 123}, "files": [{"sha": "e43eb01ad96f7edae3fe096a87831fb56985830b", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=c9e146515ba391410069a6fe3e55a4a1935bc5ae", "patch": "@@ -305,7 +305,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n     /// Span of the scope of the captured binding.\n     pub scope_span: Option<Span>,\n     /// Span of `.await` or `yield` expression.\n-    pub yield_span: Option<Span>,\n+    pub yield_span: Span,\n     /// Expr which the type evaluated from.\n     pub expr: Option<hir::HirId>,\n }"}, {"sha": "de6131f065866cd5f25b890032b95639ab4b6d2f", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 132, "deletions": 119, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c9e146515ba391410069a6fe3e55a4a1935bc5ae", "patch": "@@ -22,6 +22,14 @@ use std::fmt;\n use super::InferCtxtPrivExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n+#[derive(Debug)]\n+pub enum GeneratorInteriorOrUpvar {\n+    // span of interior type\n+    Interior(Span),\n+    // span of upvar\n+    Upvar(Span),\n+}\n+\n // This trait is public to expose the diagnostics methods to clippy.\n pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n@@ -125,8 +133,8 @@ pub trait InferCtxtExt<'tcx> {\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        interior: Option<(Span, Option<Span>, Option<Span>, Option<hir::HirId>, Option<Span>)>,\n-        upvar: Option<(Ty<'tcx>, Span)>,\n+        interior_or_upvar_span: GeneratorInteriorOrUpvar,\n+        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n@@ -1280,7 +1288,23 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             );\n             eq\n         };\n-        let interior = tables\n+\n+        let mut interior_or_upvar_span = None;\n+        let mut interior_extra_info = None;\n+\n+        if let Some(upvars) = self.tcx.upvars(generator_did) {\n+            interior_or_upvar_span = upvars.iter().find_map(|(upvar_id, upvar)| {\n+                let upvar_ty = tables.node_type(*upvar_id);\n+                let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);\n+                if ty_matches(&upvar_ty) {\n+                    Some(GeneratorInteriorOrUpvar::Upvar(upvar.span))\n+                } else {\n+                    None\n+                }\n+            });\n+        };\n+\n+        tables\n             .generator_interior_types\n             .iter()\n             .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n@@ -1301,29 +1325,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .map(|expr| expr.span);\n                 let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } =\n                     cause;\n-                (*span, *scope_span, *yield_span, *expr, from_awaited_ty)\n-            });\n \n-        let upvar = if let Some(upvars) = self.tcx.upvars(generator_did) {\n-            upvars.iter().find_map(|(upvar_id, upvar)| {\n-                let upvar_ty = tables.node_type(*upvar_id);\n-                let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);\n-                if ty_matches(&upvar_ty) { Some((upvar_ty, upvar.span)) } else { None }\n-            })\n-        } else {\n-            None\n-        };\n+                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(*span));\n+                interior_extra_info = Some((*scope_span, *yield_span, *expr, from_awaited_ty));\n+            });\n \n         debug!(\n-            \"maybe_note_obligation_cause_for_async_await: interior={:?} \\\n-                generator_interior_types={:?} upvar: {:?}\",\n-            interior, tables.generator_interior_types, upvar\n+            \"maybe_note_obligation_cause_for_async_await: interior_or_upvar={:?} \\\n+                generator_interior_types={:?}\",\n+            interior_or_upvar_span, tables.generator_interior_types\n         );\n-        if interior.is_some() || upvar.is_some() {\n+        if let Some(interior_or_upvar_span) = interior_or_upvar_span {\n             self.note_obligation_cause_for_async_await(\n                 err,\n-                interior,\n-                upvar,\n+                interior_or_upvar_span,\n+                interior_extra_info,\n                 generator_body,\n                 outer_generator,\n                 trait_ref,\n@@ -1343,8 +1359,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        interior: Option<(Span, Option<Span>, Option<Span>, Option<hir::HirId>, Option<Span>)>,\n-        upvar: Option<(Ty<'tcx>, Span)>,\n+        interior_or_upvar_span: GeneratorInteriorOrUpvar,\n+        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n@@ -1412,121 +1428,118 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n         };\n \n-        if let Some((target_span, scope_span, yield_span, expr, from_awaited_ty)) = interior {\n-            if let Some(await_span) = from_awaited_ty {\n-                // The type causing this obligation is one being awaited at await_span.\n-                let mut span = MultiSpan::from_span(await_span);\n-\n+        let mut explain_yield = |interior_span: Span,\n+                                 yield_span: Span,\n+                                 scope_span: Option<Span>| {\n+            let mut span = MultiSpan::from_span(yield_span);\n+            if let Ok(snippet) = source_map.span_to_snippet(interior_span) {\n                 span.push_span_label(\n-                    await_span,\n-                    format!(\n-                        \"await occurs here on type `{}`, which {}\",\n-                        target_ty, trait_explanation\n-                    ),\n-                );\n-\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"future {not_trait} as it awaits another future which {not_trait}\",\n-                        not_trait = trait_explanation\n-                    ),\n-                );\n-            } else {\n-                // Look at the last interior type to get a span for the `.await`.\n-                debug!(\n-                    \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n-                    tables.generator_interior_types\n+                    yield_span,\n+                    format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n                 );\n+                // If available, use the scope span to annotate the drop location.\n+                if let Some(scope_span) = scope_span {\n+                    span.push_span_label(\n+                        source_map.end_point(scope_span),\n+                        format!(\"`{}` is later dropped here\", snippet),\n+                    );\n+                }\n+            }\n+            span.push_span_label(\n+                interior_span,\n+                format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+            );\n \n-                if let Some(yield_span) = yield_span {\n-                    let mut span = MultiSpan::from_span(yield_span);\n-                    if let Ok(snippet) = source_map.span_to_snippet(target_span) {\n+            err.span_note(\n+                span,\n+                &format!(\n+                    \"{} {} as this value is used across {}\",\n+                    future_or_generator, trait_explanation, an_await_or_yield\n+                ),\n+            );\n+        };\n+        match interior_or_upvar_span {\n+            GeneratorInteriorOrUpvar::Interior(interior_span) => {\n+                if let Some((scope_span, yield_span, expr, from_awaited_ty)) = interior_extra_info {\n+                    if let Some(await_span) = from_awaited_ty {\n+                        // The type causing this obligation is one being awaited at await_span.\n+                        let mut span = MultiSpan::from_span(await_span);\n                         span.push_span_label(\n-                            yield_span,\n+                            await_span,\n                             format!(\n-                                \"{} occurs here, with `{}` maybe used later\",\n-                                await_or_yield, snippet\n+                                \"await occurs here on type `{}`, which {}\",\n+                                target_ty, trait_explanation\n                             ),\n                         );\n-                        // If available, use the scope span to annotate the drop location.\n-                        if let Some(scope_span) = scope_span {\n-                            span.push_span_label(\n-                                source_map.end_point(scope_span),\n-                                format!(\"`{}` is later dropped here\", snippet),\n-                            );\n-                        }\n+                        err.span_note(\n+                            span,\n+                            &format!(\n+                                \"future {not_trait} as it awaits another future which {not_trait}\",\n+                                not_trait = trait_explanation\n+                            ),\n+                        );\n+                    } else {\n+                        // Look at the last interior type to get a span for the `.await`.\n+                        debug!(\n+                            \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n+                            tables.generator_interior_types\n+                        );\n+                        explain_yield(interior_span, yield_span, scope_span);\n                     }\n-                    span.push_span_label(\n-                        target_span,\n-                        format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n-                    );\n \n-                    err.span_note(\n-                        span,\n-                        &format!(\n-                            \"{} {} as this value is used across {}\",\n-                            future_or_generator, trait_explanation, an_await_or_yield\n-                        ),\n-                    );\n-                }\n-            }\n-            if let Some((_, upvar_span)) = upvar {\n-                let mut span = MultiSpan::from_span(upvar_span);\n-                span.push_span_label(\n-                    upvar_span,\n-                    format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n-                );\n-            }\n-            if let Some(expr_id) = expr {\n-                let expr = hir.expect_expr(expr_id);\n-                debug!(\"target_ty evaluated from {:?}\", expr);\n-\n-                let parent = hir.get_parent_node(expr_id);\n-                if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n-                    let parent_span = hir.span(parent);\n-                    let parent_did = parent.owner.to_def_id();\n-                    // ```rust\n-                    // impl T {\n-                    //     fn foo(&self) -> i32 {}\n-                    // }\n-                    // T.foo();\n-                    // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n-                    // ```\n-                    //\n-                    let is_region_borrow =\n-                        tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n-\n-                    // ```rust\n-                    // struct Foo(*const u8);\n-                    // bar(Foo(std::ptr::null())).await;\n-                    //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n-                    // ```\n-                    debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n-                    let is_raw_borrow_inside_fn_like_call = match self.tcx.def_kind(parent_did) {\n-                        DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n-                        _ => false,\n-                    };\n-\n-                    if (tables.is_method_call(e) && is_region_borrow)\n-                        || is_raw_borrow_inside_fn_like_call\n-                    {\n-                        err.span_help(\n-                            parent_span,\n-                            \"consider moving this into a `let` \\\n+                    if let Some(expr_id) = expr {\n+                        let expr = hir.expect_expr(expr_id);\n+                        debug!(\"target_ty evaluated from {:?}\", expr);\n+\n+                        let parent = hir.get_parent_node(expr_id);\n+                        if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n+                            let parent_span = hir.span(parent);\n+                            let parent_did = parent.owner.to_def_id();\n+                            // ```rust\n+                            // impl T {\n+                            //     fn foo(&self) -> i32 {}\n+                            // }\n+                            // T.foo();\n+                            // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n+                            // ```\n+                            //\n+                            let is_region_borrow = tables\n+                                .expr_adjustments(expr)\n+                                .iter()\n+                                .any(|adj| adj.is_region_borrow());\n+\n+                            // ```rust\n+                            // struct Foo(*const u8);\n+                            // bar(Foo(std::ptr::null())).await;\n+                            //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n+                            // ```\n+                            debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n+                            let is_raw_borrow_inside_fn_like_call =\n+                                match self.tcx.def_kind(parent_did) {\n+                                    DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n+                                    _ => false,\n+                                };\n+\n+                            if (tables.is_method_call(e) && is_region_borrow)\n+                                || is_raw_borrow_inside_fn_like_call\n+                            {\n+                                err.span_help(\n+                                    parent_span,\n+                                    \"consider moving this into a `let` \\\n                         binding to create a shorter lived borrow\",\n-                        );\n+                                );\n+                            }\n+                        }\n                     }\n                 }\n             }\n-        } else {\n-            if let Some((_, upvar_span)) = upvar {\n+            GeneratorInteriorOrUpvar::Upvar(upvar_span) => {\n                 let mut span = MultiSpan::from_span(upvar_span);\n                 span.push_span_label(\n                     upvar_span,\n                     format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n                 );\n-                err.span_note(span, &format!(\"captured outer value {}\", trait_explanation));\n+                err.span_note(span, &format!(\"captured value {}\", trait_explanation));\n             }\n         }\n "}, {"sha": "ce376a08ea60486ddf2c8f60705e9e2ad3b16f64", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=c9e146515ba391410069a6fe3e55a4a1935bc5ae", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                         span: source_span,\n                         ty: &ty,\n                         scope_span,\n-                        yield_span: Some(yield_data.span),\n+                        yield_span: yield_data.span,\n                         expr: expr.map(|e| e.hir_id),\n                     })\n                     .or_insert(entries);\n@@ -130,7 +130,6 @@ pub fn resolve_interior<'a, 'tcx>(\n     kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n-\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap::default(),"}, {"sha": "5fb772fa10acbdb46a1707233bfc12204b50735f", "filename": "src/test/ui/async-await/issue-70818.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9e146515ba391410069a6fe3e55a4a1935bc5ae/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr?ref=c9e146515ba391410069a6fe3e55a4a1935bc5ae", "patch": "@@ -8,7 +8,7 @@ LL |     async { (ty, ty1) }\n    |     ------------------- this returned value is of type `impl std::future::Future`\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `U`\n-note: captured outer value is not `Send`\n+note: captured value is not `Send`\n   --> $DIR/issue-70818.rs:6:18\n    |\n LL |     async { (ty, ty1) }"}]}