{"sha": "104fe1c4db24f860b890dfd25577f23ee111279a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNGZlMWM0ZGIyNGY4NjBiODkwZGZkMjU1NzdmMjNlZTExMTI3OWE=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-05-11T21:42:18Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-05-12T23:39:19Z"}, "message": "Updating a few more errors with labels", "tree": {"sha": "1586466bd66316d59d7be6fa1cdc5ef3c3bc1d8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1586466bd66316d59d7be6fa1cdc5ef3c3bc1d8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/104fe1c4db24f860b890dfd25577f23ee111279a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/104fe1c4db24f860b890dfd25577f23ee111279a", "html_url": "https://github.com/rust-lang/rust/commit/104fe1c4db24f860b890dfd25577f23ee111279a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/104fe1c4db24f860b890dfd25577f23ee111279a/comments", "author": null, "committer": null, "parents": [{"sha": "f3054ce18ca747b8354137f07230bd2251d7985c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3054ce18ca747b8354137f07230bd2251d7985c", "html_url": "https://github.com/rust-lang/rust/commit/f3054ce18ca747b8354137f07230bd2251d7985c"}], "stats": {"total": 72, "additions": 46, "deletions": 26}, "files": [{"sha": "947c1e689e81a484809868c41464ca47bdf137c7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/104fe1c4db24f860b890dfd25577f23ee111279a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104fe1c4db24f860b890dfd25577f23ee111279a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=104fe1c4db24f860b890dfd25577f23ee111279a", "patch": "@@ -200,11 +200,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n \n     match resolution_error {\n         ResolutionError::TypeParametersFromOuterFunction => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0401,\n-                             \"can't use type parameters from outer function; try using a local \\\n-                              type parameter instead\")\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0401,\n+                                           \"can't use type parameters from outer function; \\\n+                                           try using a local type parameter instead\");\n+            err = err.span_label(span, &format!(\"use of type variable from outer function\"));\n+            err\n         }\n         ResolutionError::OuterTypeParameterContext => {\n             struct_span_err!(resolver.session,\n@@ -230,6 +232,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                                            \"trait `{}` is not in scope\",\n                                            name);\n             show_candidates(&mut err, &candidates);\n+            err = err.span_label(span, &format!(\"`{}` is not in scope\", name));\n             err\n         }\n         ResolutionError::UndeclaredAssociatedType => {\n@@ -278,10 +281,12 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              pattern_number)\n         }\n         ResolutionError::SelfUsedOutsideImplOrTrait => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0411,\n-                             \"use of `Self` outside of an impl or trait\")\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0411,\n+                                           \"use of `Self` outside of an impl or trait\");\n+            err = err.span_label(span, &format!(\"Used outside of impl or trait\"));\n+            err\n         }\n         ResolutionError::UseOfUndeclared(kind, name, candidates) => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -291,54 +296,63 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                                            kind,\n                                            name);\n             show_candidates(&mut err, &candidates);\n+            err = err.span_label(span, &format!(\"undefined or not in scope\"));\n             err\n         }\n         ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n-            struct_span_err!(resolver.session,\n+            let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0413,\n-                             \"declaration of `{}` shadows an enum variant \\\n+                             \"`{}` cannot be named the same as an enum variant \\\n                               or unit-like struct in scope\",\n-                             name)\n+                             name);\n+            err = err.span_label(span,\n+                &format!(\"has same name as enum variant or unit-like struct\"));\n+            err\n         }\n         ResolutionError::ConstantForIrrefutableBinding(name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0414,\n-                                           \"variable bindings cannot shadow constants\");\n-            err.span_note(span,\n-                          \"there already is a constant in scope sharing the same \\\n-                           name as this pattern\");\n+                                       \"let variables cannot be named the same as const variables\");\n+            err = err.span_label(span,\n+                             &format!(\"cannot be named the same as a const variable\"));\n             if let Some(binding) = resolver.current_module\n                                            .resolve_name_in_lexical_scope(name, ValueNS) {\n                 let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                err.span_note(binding.span, &format!(\"constant {} here\", participle));\n+                err = err.span_label(binding.span, &format!(\"a constant `{}` is {} here\",\n+                    name, participle));\n             }\n             err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n-            struct_span_err!(resolver.session,\n+            let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0415,\n                              \"identifier `{}` is bound more than once in this parameter list\",\n-                             identifier)\n+                             identifier);\n+            err = err.span_label(span, &format!(\"used as parameter more than once\"));\n+            err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n-            struct_span_err!(resolver.session,\n+            let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0416,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n-                             identifier)\n+                             identifier);\n+            err = err.span_label(span, &format!(\"used in a pattern more than once\"));\n+            err\n         }\n         ResolutionError::StaticVariableReference(binding) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0417,\n                                            \"static variables cannot be referenced in a \\\n                                             pattern, use a `const` instead\");\n+            err = err.span_label(span, &format!(\"static variable used in pattern\"));\n             if binding.span != codemap::DUMMY_SP {\n                 let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                err.span_note(binding.span, &format!(\"static variable {} here\", participle));\n+                err = err.span_label(binding.span, &format!(\"static variable {} here\", participle));\n             }\n             err\n         }\n@@ -1804,7 +1818,9 @@ impl<'a> Resolver<'a> {\n \n                 // If it's a typedef, give a note\n                 if let Def::TyAlias(..) = path_res.base_def {\n-                    err.note(\"`type` aliases cannot be used for traits\");\n+                    let trait_name = trait_path.segments.last().unwrap().identifier.name;\n+                    err = err.span_label(trait_path.span,\n+                        &format!(\"`{}` is not a trait\", trait_name));\n \n                     let definition_site = {\n                         let segments = &trait_path.segments;\n@@ -1816,7 +1832,8 @@ impl<'a> Resolver<'a> {\n                     };\n \n                     if definition_site != codemap::DUMMY_SP {\n-                        err.span_note(definition_site, \"type defined here\");\n+                        err = err.span_label(definition_site,\n+                            &format!(\"note: type aliases cannot be used for traits\"));\n                     }\n                 }\n                 err.emit();\n@@ -3462,12 +3479,15 @@ impl<'a> Resolver<'a> {\n             _ => match (old_binding.is_import(), binding.is_import()) {\n                 (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n                 (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+                _ => {\n+                    let e = struct_span_err!(self.session, span, E0255, \"{}\", msg);\n+                    e.span_label(span, &format!(\"`{}` was already imported\", name))\n+                }\n             },\n         };\n \n         if old_binding.span != codemap::DUMMY_SP {\n-            err.span_note(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n+            err = err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n         }\n         err.emit();\n     }"}]}