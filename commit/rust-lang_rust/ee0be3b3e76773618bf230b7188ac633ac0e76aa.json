{"sha": "ee0be3b3e76773618bf230b7188ac633ac0e76aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMGJlM2IzZTc2NzczNjE4YmYyMzBiNzE4OGFjNjMzYWMwZTc2YWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-28T18:55:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-28T18:55:24Z"}, "message": "Auto merge of #21698 - Manishearth:rollup, r=alexcrichton\n\nThis should work now.", "tree": {"sha": "9567cea197e37b96607f471b18dd1c77908c8965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9567cea197e37b96607f471b18dd1c77908c8965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee0be3b3e76773618bf230b7188ac633ac0e76aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0be3b3e76773618bf230b7188ac633ac0e76aa", "html_url": "https://github.com/rust-lang/rust/commit/ee0be3b3e76773618bf230b7188ac633ac0e76aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee0be3b3e76773618bf230b7188ac633ac0e76aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a45e117733b866302fa99390553d1c548508dcca", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45e117733b866302fa99390553d1c548508dcca", "html_url": "https://github.com/rust-lang/rust/commit/a45e117733b866302fa99390553d1c548508dcca"}, {"sha": "c709ed2faf4ea28df1395a924453b5298b87fa57", "url": "https://api.github.com/repos/rust-lang/rust/commits/c709ed2faf4ea28df1395a924453b5298b87fa57", "html_url": "https://github.com/rust-lang/rust/commit/c709ed2faf4ea28df1395a924453b5298b87fa57"}], "stats": {"total": 2371, "additions": 1204, "deletions": 1167}, "files": [{"sha": "40e123e5323d8315ad93b7da1499fc6fb28402be", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,7 +13,7 @@ use std::fmt;\n use std::str::FromStr;\n \n #[cfg(stage0)] // NOTE: remove impl after snapshot\n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Show)]\n pub enum Mode {\n     CompileFail,\n     RunFail,\n@@ -26,7 +26,7 @@ pub enum Mode {\n }\n \n #[cfg(not(stage0))] // NOTE: remove cfg after snapshot\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n     CompileFail,\n     RunFail,\n@@ -38,9 +38,6 @@ pub enum Mode {\n     Codegen\n }\n \n-\n-impl Copy for Mode {}\n-\n impl FromStr for Mode {\n     fn from_str(s: &str) -> Option<Mode> {\n         match s {"}, {"sha": "59ac173f97a29d73ca50cb37f7ba8b66497517aa", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -1680,8 +1680,8 @@ specific type.\n Implementations are defined with the keyword `impl`.\n \n ```\n+# #[derive(Copy)]\n # struct Point {x: f64, y: f64};\n-# impl Copy for Point {}\n # type Surface = i32;\n # struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n # trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }\n@@ -2219,7 +2219,7 @@ For any lint check `C`:\n \n The lint checks supported by the compiler can be found via `rustc -W help`,\n along with their default settings.  [Compiler\n-plugins](book/plugin.html#lint-plugins) can provide additional lint checks.\n+plugins](book/plugins.html#lint-plugins) can provide additional lint checks.\n \n ```{.ignore}\n mod m1 {\n@@ -4163,4 +4163,4 @@ that have since been removed):\n   pattern syntax\n \n [ffi]: book/ffi.html\n-[plugin]: book/plugin.html\n+[plugin]: book/plugins.html"}, {"sha": "b4669b0819f9d73b4cf6a3bd66ebb2329c9e87db", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -279,5 +279,5 @@ Many more bytes than graphemes!\n \n # Other Documentation\n \n-* [the `&str` API documentation](std/str/index.html)\n-* [the `String` API documentation](std/string/index.html)\n+* [the `&str` API documentation](../std/str/index.html)\n+* [the `String` API documentation](../std/string/index.html)"}, {"sha": "9e3a3f12d1d213f164003bba7b5b65f1bbb3ff59", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -533,6 +533,7 @@ fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n fn get_str() -> &str; // ILLEGAL, no inputs\n \n fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n+fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n \n fn get_mut(&mut self) -> &mut T; // elided\n fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded"}, {"sha": "917e1970a36c068928d1ca6695b5be099c210ec5", "filename": "src/etc/check-summary.py", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fcheck-summary.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fcheck-summary.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-summary.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,6 +15,7 @@\n \n if __name__ == '__main__':\n     summaries = []\n+\n     def summarise(fname):\n         summary = {}\n         with open(fname) as fd:\n@@ -27,12 +28,14 @@ def summarise(fname):\n                 # track bench runs\n                 if splitline[1] == 'ns/iter':\n                     status = 'bench'\n-                if not summary.has_key(status):\n+                if status not in summary:\n                     summary[status] = []\n                 summary[status].append(test)\n             summaries.append((fname, summary))\n+\n     def count(t):\n         return sum(map(lambda (f, s): len(s.get(t, [])), summaries))\n+\n     logfiles = sys.argv[1:]\n     for files in map(glob.glob, logfiles):\n         map(summarise, files)\n@@ -41,8 +44,9 @@ def count(t):\n     ignored = count('ignored')\n     measured = count('bench')\n     print \"summary of %d test runs: %d passed; %d failed; %d ignored; %d measured\" % \\\n-            (len(logfiles), ok, failed, ignored, measured)\n+          (len(logfiles), ok, failed, ignored, measured)\n     print \"\"\n+\n     if failed > 0:\n         print \"failed tests:\"\n         for f, s in summaries:"}, {"sha": "c940359abc118d8e0ef570c82fec5ccbab1572f7", "filename": "src/etc/errorck.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,7 +11,9 @@\n # Digs error codes out of files named 'diagnostics.rs' across\n # the tree, and ensures thare are no duplicates.\n \n-import sys, os, re\n+import sys\n+import os\n+import re\n \n src_dir = sys.argv[1]\n errcode_map = {}"}, {"sha": "a12c3298cb35b93b057ed019f97ea208d4665f9d", "filename": "src/etc/extract_grammar.py", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fextract_grammar.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fextract_grammar.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract_grammar.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,11 +14,11 @@\n \n import fileinput\n \n-collections = { \"gram\": [],\n-                \"keyword\": [],\n-                \"reserved\": [],\n-                \"binop\": [],\n-                \"unop\": [] }\n+collections = {\"gram\": [],\n+               \"keyword\": [],\n+               \"reserved\": [],\n+               \"binop\": [],\n+               \"unop\": []}\n \n \n in_coll = False\n@@ -47,66 +47,66 @@\n # Define operator symbol-names here\n \n tokens = [\"non_star\", \"non_slash\", \"non_eol\",\n-          \"non_single_quote\", \"non_double_quote\", \"ident\" ]\n+          \"non_single_quote\", \"non_double_quote\", \"ident\"]\n \n symnames = {\n-\".\": \"dot\",\n-\"+\": \"plus\",\n-\"-\": \"minus\",\n-\"/\": \"slash\",\n-\"*\": \"star\",\n-\"%\": \"percent\",\n-\n-\"~\": \"tilde\",\n-\"@\": \"at\",\n-\n-\"!\": \"not\",\n-\"&\": \"and\",\n-\"|\": \"or\",\n-\"^\": \"xor\",\n-\n-\"<<\": \"lsl\",\n-\">>\": \"lsr\",\n-\">>>\": \"asr\",\n-\n-\"&&\": \"andand\",\n-\"||\": \"oror\",\n-\n-\"<\" : \"lt\",\n-\"<=\" : \"le\",\n-\"==\" : \"eqeq\",\n-\">=\" : \"ge\",\n-\">\" : \"gt\",\n-\n-\"=\": \"eq\",\n-\n-\"+=\": \"plusequal\",\n-\"-=\": \"minusequal\",\n-\"/=\": \"divequal\",\n-\"*=\": \"starequal\",\n-\"%=\": \"percentequal\",\n-\n-\"&=\": \"andequal\",\n-\"|=\": \"orequal\",\n-\"^=\": \"xorequal\",\n-\n-\">>=\": \"lsrequal\",\n-\">>>=\": \"asrequal\",\n-\"<<=\": \"lslequal\",\n-\n-\"::\": \"coloncolon\",\n-\n-\"->\": \"rightarrow\",\n-\"<-\": \"leftarrow\",\n-\"<->\": \"swaparrow\",\n-\n-\"//\": \"linecomment\",\n-\"/*\": \"openblockcomment\",\n-\"*/\": \"closeblockcomment\",\n-\"macro_rules\": \"macro_rules\",\n-\"=>\" : \"eg\",\n-\"..\" : \"dotdot\",\n-\",\"  : \"comma\"\n+    \".\": \"dot\",\n+    \"+\": \"plus\",\n+    \"-\": \"minus\",\n+    \"/\": \"slash\",\n+    \"*\": \"star\",\n+    \"%\": \"percent\",\n+\n+    \"~\": \"tilde\",\n+    \"@\": \"at\",\n+\n+    \"!\": \"not\",\n+    \"&\": \"and\",\n+    \"|\": \"or\",\n+    \"^\": \"xor\",\n+\n+    \"<<\": \"lsl\",\n+    \">>\": \"lsr\",\n+    \">>>\": \"asr\",\n+\n+    \"&&\": \"andand\",\n+    \"||\": \"oror\",\n+\n+    \"<\": \"lt\",\n+    \"<=\": \"le\",\n+    \"==\": \"eqeq\",\n+    \">=\": \"ge\",\n+    \">\": \"gt\",\n+\n+    \"=\": \"eq\",\n+\n+    \"+=\": \"plusequal\",\n+    \"-=\": \"minusequal\",\n+    \"/=\": \"divequal\",\n+    \"*=\": \"starequal\",\n+    \"%=\": \"percentequal\",\n+\n+    \"&=\": \"andequal\",\n+    \"|=\": \"orequal\",\n+    \"^=\": \"xorequal\",\n+\n+    \">>=\": \"lsrequal\",\n+    \">>>=\": \"asrequal\",\n+    \"<<=\": \"lslequal\",\n+\n+    \"::\": \"coloncolon\",\n+\n+    \"->\": \"rightarrow\",\n+    \"<-\": \"leftarrow\",\n+    \"<->\": \"swaparrow\",\n+\n+    \"//\": \"linecomment\",\n+    \"/*\": \"openblockcomment\",\n+    \"*/\": \"closeblockcomment\",\n+    \"macro_rules\": \"macro_rules\",\n+    \"=>\": \"eg\",\n+    \"..\": \"dotdot\",\n+    \",\": \"comma\"\n }\n \n lines = []\n@@ -126,8 +126,8 @@\n                                         + word)\n                 if word not in tokens:\n                     if (word in collections[\"keyword\"] or\n-                        word in collections[\"reserved\"]):\n-                       tokens.append(word)\n+                            word in collections[\"reserved\"]):\n+                        tokens.append(word)\n                     else:\n                         raise Exception(\"unknown keyword/reserved word: \"\n                                         + word)\n@@ -149,8 +149,8 @@\n print(\"%start parser, token;\")\n print(\"%%token %s ;\" % (\"\\n\\t, \".join(tokens)))\n for coll in [\"keyword\", \"reserved\"]:\n-    print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join(collections[coll])));\n+    print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join(collections[coll])))\n for coll in [\"binop\", \"unop\"]:\n     print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join([symnames[x]\n-                                              for x in collections[coll]])));\n-print(\"\\n\".join(lines));\n+                                              for x in collections[coll]])))\n+print(\"\\n\".join(lines))"}, {"sha": "c5587bb10d1dacf3840b35dc5350055e1b61cbec", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 188, "deletions": 176, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,181 +14,189 @@\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n \n+\n def register_printers(objfile):\n-  \"Registers Rust pretty printers for the given objfile\"\n-  objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+    \"Registers Rust pretty printers for the given objfile\"\n+    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+\n \n def rust_pretty_printer_lookup_function(val):\n-  \"Returns the correct Rust pretty printer for the given value if there is one\"\n-  type_code = val.type.code\n-\n-  if type_code == gdb.TYPE_CODE_STRUCT:\n-    struct_kind = classify_struct(val.type)\n-\n-    if struct_kind == STRUCT_KIND_STR_SLICE:\n-      return RustStringSlicePrinter(val)\n-\n-    if struct_kind == STRUCT_KIND_TUPLE:\n-      return RustTuplePrinter(val)\n-\n-    if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n-      return RustTupleStructPrinter(val, False)\n-\n-    if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n-      return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n-\n-    if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n-      return RustTupleStructPrinter(val, True)\n-\n-    if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n-      return RustStructPrinter(val, True)\n-\n-    return RustStructPrinter(val, False)\n-\n-  # Enum handling\n-  if type_code == gdb.TYPE_CODE_UNION:\n-    enum_members = list(val.type.fields())\n-    enum_member_count = len(enum_members)\n-\n-    if enum_member_count == 0:\n-      return RustStructPrinter(val, False)\n-\n-    if enum_member_count == 1:\n-      first_variant_name = enum_members[0].name\n-      if first_variant_name == None:\n-        # This is a singleton enum\n-        return rust_pretty_printer_lookup_function(val[enum_members[0]])\n-      else:\n-        assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n-        # This is a space-optimized enum.\n-        # This means this enum has only two states, and Rust uses one of the\n-        # fields somewhere in the struct to determine which of the two states\n-        # it's in. The location of the field is encoded in the name as something\n-        # like RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n-        last_separator_index = first_variant_name.rfind(\"$\")\n-        start_index = len(\"RUST$ENCODED$ENUM$\")\n-        disr_field_indices = first_variant_name[start_index :\n-                                              last_separator_index].split(\"$\")\n-        disr_field_indices = [int(index) for index in disr_field_indices]\n-\n-        sole_variant_val = val[enum_members[0]]\n-        discriminant = sole_variant_val\n-        for disr_field_index in disr_field_indices:\n-          disr_field = get_field_at_index(discriminant, disr_field_index)\n-          discriminant = discriminant[disr_field]\n-\n-        # If the discriminant field is a fat pointer we have to consider the\n-        # first word as the true discriminant\n-        if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n-          discriminant = discriminant[get_field_at_index(discriminant, 0)]\n-\n-        if discriminant == 0:\n-          null_variant_name = first_variant_name[last_separator_index + 1:]\n-          return IdentityPrinter(null_variant_name)\n-\n-        return rust_pretty_printer_lookup_function(sole_variant_val)\n-\n-    # This is a regular enum, extract the discriminant\n-    discriminant_name, discriminant_val = extract_discriminant_value(val)\n-    return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n-\n-  # No pretty printer has been found\n-  return None\n+    \"Returns the correct Rust pretty printer for the given value if there is one\"\n+    type_code = val.type.code\n+\n+    if type_code == gdb.TYPE_CODE_STRUCT:\n+        struct_kind = classify_struct(val.type)\n+\n+        if struct_kind == STRUCT_KIND_STR_SLICE:\n+            return RustStringSlicePrinter(val)\n+\n+        if struct_kind == STRUCT_KIND_TUPLE:\n+            return RustTuplePrinter(val)\n+\n+        if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n+            return RustTupleStructPrinter(val, False)\n+\n+        if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n+            return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n+\n+        if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n+            return RustTupleStructPrinter(val, True)\n+\n+        if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n+            return RustStructPrinter(val, True)\n+\n+        return RustStructPrinter(val, False)\n+\n+    # Enum handling\n+    if type_code == gdb.TYPE_CODE_UNION:\n+        enum_members = list(val.type.fields())\n+        enum_member_count = len(enum_members)\n+\n+        if enum_member_count == 0:\n+            return RustStructPrinter(val, False)\n+\n+        if enum_member_count == 1:\n+            first_variant_name = enum_members[0].name\n+            if first_variant_name is None:\n+                # This is a singleton enum\n+                return rust_pretty_printer_lookup_function(val[enum_members[0]])\n+            else:\n+                assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n+                # This is a space-optimized enum.\n+                # This means this enum has only two states, and Rust uses one\n+                # of the fields somewhere in the struct to determine which of\n+                # the two states it's in. The location of the field is encoded\n+                # in the name as something like\n+                # RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n+                last_separator_index = first_variant_name.rfind(\"$\")\n+                start_index = len(\"RUST$ENCODED$ENUM$\")\n+                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n+                disr_field_indices = [int(index) for index in disr_field_indices]\n+\n+                sole_variant_val = val[enum_members[0]]\n+                discriminant = sole_variant_val\n+                for disr_field_index in disr_field_indices:\n+                    disr_field = get_field_at_index(discriminant, disr_field_index)\n+                    discriminant = discriminant[disr_field]\n+\n+                # If the discriminant field is a fat pointer we have to consider the\n+                # first word as the true discriminant\n+                if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n+                    discriminant = discriminant[get_field_at_index(discriminant, 0)]\n+\n+                if discriminant == 0:\n+                    null_variant_name = first_variant_name[last_separator_index + 1:]\n+                    return IdentityPrinter(null_variant_name)\n+\n+                return rust_pretty_printer_lookup_function(sole_variant_val)\n+\n+        # This is a regular enum, extract the discriminant\n+        discriminant_name, discriminant_val = extract_discriminant_value(val)\n+        return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n+\n+    # No pretty printer has been found\n+    return None\n \n #=------------------------------------------------------------------------------\n # Pretty Printer Classes\n #=------------------------------------------------------------------------------\n \n+\n class RustStructPrinter:\n-  def __init__(self, val, hide_first_field):\n-    self.val = val\n-    self.hide_first_field = hide_first_field\n-\n-  def to_string(self):\n-    return self.val.type.tag\n-\n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      field_name = field.name\n-      # Normally the field name is used as a key to access the field value,\n-      # because that's also supported in older versions of GDB...\n-      field_key = field_name\n-      if field_name == None:\n-        field_name = \"\"\n-        # ... but for fields without a name (as in tuples), we have to fall back\n-        # to the newer method of using the field object directly as key. In\n-        # older versions of GDB, this will just fail.\n-        field_key = field\n-      name_value_tuple = ( field_name, self.val[field_key] )\n-      cs.append( name_value_tuple )\n-\n-    if self.hide_first_field:\n-      cs = cs[1:]\n-\n-    return cs\n+    def __init__(self, val, hide_first_field):\n+        self.val = val\n+        self.hide_first_field = hide_first_field\n+\n+    def to_string(self):\n+        return self.val.type.tag\n+\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            field_name = field.name\n+            # Normally the field name is used as a key to access the field\n+            # value, because that's also supported in older versions of GDB...\n+            field_key = field_name\n+            if field_name is None:\n+                field_name = \"\"\n+                # ... but for fields without a name (as in tuples), we have to\n+                # fall back to the newer method of using the field object\n+                # directly as key. In older versions of GDB, this will just\n+                # fail.\n+                field_key = field\n+            name_value_tuple = (field_name, self.val[field_key])\n+            cs.append(name_value_tuple)\n+\n+        if self.hide_first_field:\n+            cs = cs[1:]\n+\n+        return cs\n+\n \n class RustTuplePrinter:\n-  def __init__(self, val):\n-    self.val = val\n+    def __init__(self, val):\n+        self.val = val\n \n-  def to_string(self):\n-    return None\n+    def to_string(self):\n+        return None\n+\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            cs.append((\"\", self.val[field]))\n \n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      cs.append( (\"\", self.val[field]) )\n+        return cs\n \n-    return cs\n+    def display_hint(self):\n+        return \"array\"\n \n-  def display_hint(self):\n-    return \"array\"\n \n class RustTupleStructPrinter:\n-  def __init__(self, val, hide_first_field):\n-    self.val = val\n-    self.hide_first_field = hide_first_field\n+    def __init__(self, val, hide_first_field):\n+        self.val = val\n+        self.hide_first_field = hide_first_field\n \n-  def to_string(self):\n-    return self.val.type.tag\n+    def to_string(self):\n+        return self.val.type.tag\n \n-  def children(self):\n-    cs = []\n-    for field in self.val.type.fields():\n-      cs.append( (\"\", self.val[field]) )\n+    def children(self):\n+        cs = []\n+        for field in self.val.type.fields():\n+            cs.append((\"\", self.val[field]))\n \n-    if self.hide_first_field:\n-      cs = cs[1:]\n+        if self.hide_first_field:\n+            cs = cs[1:]\n \n-    return cs\n+        return cs\n+\n+    def display_hint(self):\n+        return \"array\"\n \n-  def display_hint(self):\n-    return \"array\"\n \n class RustStringSlicePrinter:\n-  def __init__(self, val):\n-    self.val = val\n+    def __init__(self, val):\n+        self.val = val\n+\n+    def to_string(self):\n+        slice_byte_len = self.val[\"length\"]\n+        return '\"%s\"' % self.val[\"data_ptr\"].string(encoding=\"utf-8\", length=slice_byte_len)\n \n-  def to_string(self):\n-    slice_byte_len = self.val[\"length\"]\n-    return '\"%s\"' % self.val[\"data_ptr\"].string(encoding = \"utf-8\",\n-                                                length = slice_byte_len)\n \n class RustCStyleEnumPrinter:\n-  def __init__(self, val):\n-    assert val.type.code == gdb.TYPE_CODE_ENUM\n-    self.val = val\n+    def __init__(self, val):\n+        assert val.type.code == gdb.TYPE_CODE_ENUM\n+        self.val = val\n+\n+    def to_string(self):\n+        return str(self.val)\n \n-  def to_string(self):\n-    return str(self.val)\n \n class IdentityPrinter:\n-  def __init__(self, string):\n-    self.string = string\n+    def __init__(self, string):\n+        self.string = string\n \n-  def to_string(self):\n-    return self.string\n+    def to_string(self):\n+        return self.string\n \n STRUCT_KIND_REGULAR_STRUCT  = 0\n STRUCT_KIND_TUPLE_STRUCT    = 1\n@@ -198,47 +206,51 @@ def to_string(self):\n STRUCT_KIND_CSTYLE_VARIANT  = 5\n STRUCT_KIND_STR_SLICE       = 6\n \n+\n def classify_struct(type):\n-  if type.tag == \"&str\":\n-    return STRUCT_KIND_STR_SLICE\n+    if type.tag == \"&str\":\n+        return STRUCT_KIND_STR_SLICE\n \n-  fields = list(type.fields())\n-  field_count = len(fields)\n+    fields = list(type.fields())\n+    field_count = len(fields)\n \n-  if field_count == 0:\n-    return STRUCT_KIND_REGULAR_STRUCT\n+    if field_count == 0:\n+        return STRUCT_KIND_REGULAR_STRUCT\n+\n+    if fields[0].name == \"RUST$ENUM$DISR\":\n+        if field_count == 1:\n+            return STRUCT_KIND_CSTYLE_VARIANT\n+        elif fields[1].name is None:\n+            return STRUCT_KIND_TUPLE_VARIANT\n+        else:\n+            return STRUCT_KIND_STRUCT_VARIANT\n \n-  if fields[0].name == \"RUST$ENUM$DISR\":\n-    if field_count == 1:\n-      return STRUCT_KIND_CSTYLE_VARIANT\n-    elif fields[1].name == None:\n-      return STRUCT_KIND_TUPLE_VARIANT\n-    else:\n-      return STRUCT_KIND_STRUCT_VARIANT\n+    if fields[0].name is None:\n+        if type.tag.startswith(\"(\"):\n+            return STRUCT_KIND_TUPLE\n+        else:\n+            return STRUCT_KIND_TUPLE_STRUCT\n \n-  if fields[0].name == None:\n-    if type.tag.startswith(\"(\"):\n-      return STRUCT_KIND_TUPLE\n-    else:\n-      return STRUCT_KIND_TUPLE_STRUCT\n+    return STRUCT_KIND_REGULAR_STRUCT\n \n-  return STRUCT_KIND_REGULAR_STRUCT\n \n def extract_discriminant_value(enum_val):\n-  assert enum_val.type.code == gdb.TYPE_CODE_UNION\n-  for variant_descriptor in enum_val.type.fields():\n-    variant_val = enum_val[variant_descriptor]\n-    for field in variant_val.type.fields():\n-      return (field.name, int(variant_val[field]))\n+    assert enum_val.type.code == gdb.TYPE_CODE_UNION\n+    for variant_descriptor in enum_val.type.fields():\n+        variant_val = enum_val[variant_descriptor]\n+        for field in variant_val.type.fields():\n+            return (field.name, int(variant_val[field]))\n+\n \n def first_field(val):\n-  for field in val.type.fields():\n-    return field\n+    for field in val.type.fields():\n+        return field\n+\n \n def get_field_at_index(val, index):\n-  i = 0\n-  for field in val.type.fields():\n-    if i == index:\n-      return field\n-    i += 1\n-  return None\n+    i = 0\n+    for field in val.type.fields():\n+        if i == index:\n+            return field\n+        i += 1\n+    return None"}, {"sha": "937c231a473e9916bfb31fe7954c7eb927a2b4ce", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -56,4 +56,4 @@\n         f.write(template % (datetime.datetime.now().year, kw, kw))\n \n     # mark file read-only\n-    os.chmod(test_file, stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH)\n+    os.chmod(test_file, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)"}, {"sha": "26246bd2c32a33b159355658be7ff87d64b7f5bf", "filename": "src/etc/get-snapshot.py", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fget-snapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fget-snapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fget-snapshot.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,36 +10,40 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import os, tarfile, re, shutil, sys\n+import os\n+import tarfile\n+import shutil\n+import sys\n from snapshot import *\n \n+\n def unpack_snapshot(triple, dl_path):\n-  print(\"opening snapshot \" + dl_path)\n-  tar = tarfile.open(dl_path)\n-  kernel = get_kernel(triple)\n-\n-  stagep = os.path.join(triple, \"stage0\")\n-\n-  # Remove files from prior unpackings, since snapshot rustc may not\n-  # be able to disambiguate between multiple candidate libraries.\n-  # (Leave dirs in place since extracting step still needs them.)\n-  for root, _, files in os.walk(stagep):\n-    for f in files:\n-      print(\"removing \" + os.path.join(root, f))\n-      os.unlink(os.path.join(root, f))\n-\n-  for p in tar.getnames():\n-    name = p.replace(\"rust-stage0/\", \"\", 1);\n-\n-    fp = os.path.join(stagep, name)\n-    print(\"extracting \" + p)\n-    tar.extract(p, download_unpack_base)\n-    tp = os.path.join(download_unpack_base, p)\n-    if os.path.isdir(tp) and os.path.exists(fp):\n-        continue\n-    shutil.move(tp, fp)\n-  tar.close()\n-  shutil.rmtree(download_unpack_base)\n+    print(\"opening snapshot \" + dl_path)\n+    tar = tarfile.open(dl_path)\n+    kernel = get_kernel(triple)\n+\n+    stagep = os.path.join(triple, \"stage0\")\n+\n+    # Remove files from prior unpackings, since snapshot rustc may not\n+    # be able to disambiguate between multiple candidate libraries.\n+    # (Leave dirs in place since extracting step still needs them.)\n+    for root, _, files in os.walk(stagep):\n+        for f in files:\n+            print(\"removing \" + os.path.join(root, f))\n+            os.unlink(os.path.join(root, f))\n+\n+    for p in tar.getnames():\n+        name = p.replace(\"rust-stage0/\", \"\", 1)\n+\n+        fp = os.path.join(stagep, name)\n+        print(\"extracting \" + p)\n+        tar.extract(p, download_unpack_base)\n+        tp = os.path.join(download_unpack_base, p)\n+        if os.path.isdir(tp) and os.path.exists(fp):\n+            continue\n+        shutil.move(tp, fp)\n+    tar.close()\n+    shutil.rmtree(download_unpack_base)\n \n \n # Main\n@@ -48,23 +52,27 @@ def unpack_snapshot(triple, dl_path):\n # The first is the O/S triple.\n # The second is an optional path to the snapshot to use.\n \n-triple = sys.argv[1]\n-if len(sys.argv) == 3:\n-  dl_path = sys.argv[2]\n-else:\n-  snap = determine_curr_snapshot(triple)\n-  dl = os.path.join(download_dir_base, snap)\n-  url = download_url_base + \"/\" + snap\n-  print(\"determined most recent snapshot: \" + snap)\n+def main(argv):\n+    triple = argv[1]\n+    if len(argv) == 3:\n+        dl_path = argv[2]\n+    else:\n+        snap = determine_curr_snapshot(triple)\n+        dl = os.path.join(download_dir_base, snap)\n+        url = download_url_base + \"/\" + snap\n+        print(\"determined most recent snapshot: \" + snap)\n+\n+        if (not os.path.exists(dl)):\n+            get_url_to_file(url, dl)\n \n-  if (not os.path.exists(dl)):\n-    get_url_to_file(url, dl)\n+        if (snap_filename_hash_part(snap) == hash_file(dl)):\n+            print(\"got download with ok hash\")\n+        else:\n+            raise Exception(\"bad hash on download\")\n \n-  if (snap_filename_hash_part(snap) == hash_file(dl)):\n-    print(\"got download with ok hash\")\n-  else:\n-    raise Exception(\"bad hash on download\")\n+        dl_path = os.path.join(download_dir_base, snap)\n \n-  dl_path = os.path.join(download_dir_base, snap)\n+    unpack_snapshot(triple, dl_path)\n \n-unpack_snapshot(triple, dl_path)\n+if __name__ == '__main__':\n+    main(sys.argv)"}, {"sha": "22792ff76355149b4ee8eb006fba37618b094caf", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -118,40 +118,54 @@\n VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n                      'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'])\n \n-# simplified HTML parser.\n-# this is possible because we are dealing with very regular HTML from rustdoc;\n-# we only have to deal with i) void elements and ii) empty attributes.\n+\n class CustomHTMLParser(HTMLParser):\n+    \"\"\"simplified HTML parser.\n+\n+    this is possible because we are dealing with very regular HTML from\n+    rustdoc; we only have to deal with i) void elements and ii) empty\n+    attributes.\"\"\"\n     def __init__(self, target=None):\n         HTMLParser.__init__(self)\n         self.__builder = target or ET.TreeBuilder()\n+\n     def handle_starttag(self, tag, attrs):\n         attrs = dict((k, v or '') for k, v in attrs)\n         self.__builder.start(tag, attrs)\n-        if tag in VOID_ELEMENTS: self.__builder.end(tag)\n+        if tag in VOID_ELEMENTS:\n+            self.__builder.end(tag)\n+\n     def handle_endtag(self, tag):\n         self.__builder.end(tag)\n+\n     def handle_startendtag(self, tag, attrs):\n         attrs = dict((k, v or '') for k, v in attrs)\n         self.__builder.start(tag, attrs)\n         self.__builder.end(tag)\n+\n     def handle_data(self, data):\n         self.__builder.data(data)\n+\n     def handle_entityref(self, name):\n         self.__builder.data(entitydefs[name])\n+\n     def handle_charref(self, name):\n         code = int(name[1:], 16) if name.startswith(('x', 'X')) else int(name, 10)\n         self.__builder.data(unichr(code).encode('utf-8'))\n+\n     def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n Command = namedtuple('Command', 'negated cmd args lineno')\n \n-# returns a generator out of the file object, which\n-# - removes `\\\\` then `\\n` then a shared prefix with the previous line then optional whitespace;\n-# - keeps a line number (starting from 0) of the first line being concatenated.\n+\n def concat_multi_lines(f):\n+    \"\"\"returns a generator out of the file object, which\n+    - removes `\\\\` then `\\n` then a shared prefix with the previous line then\n+      optional whitespace;\n+    - keeps a line number (starting from 0) of the first line being\n+      concatenated.\"\"\"\n     lastline = None # set to the last line when the last line has a backslash\n     firstlineno = None\n     catenated = ''\n@@ -162,7 +176,8 @@ def concat_multi_lines(f):\n         if lastline is not None:\n             maxprefix = 0\n             for i in xrange(min(len(line), len(lastline))):\n-                if line[i] != lastline[i]: break\n+                if line[i] != lastline[i]:\n+                    break\n                 maxprefix += 1\n             line = line[maxprefix:].lstrip()\n \n@@ -184,11 +199,14 @@ def concat_multi_lines(f):\n     (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n     (?P<args>.*)$\n ''', re.X)\n+\n+\n def get_commands(template):\n     with open(template, 'rUb') as f:\n         for lineno, line in concat_multi_lines(f):\n             m = LINE_PATTERN.search(line)\n-            if not m: continue\n+            if not m:\n+                continue\n \n             negated = (m.group('negated') == '!')\n             cmd = m.group('cmd')\n@@ -198,17 +216,22 @@ def get_commands(template):\n             args = shlex.split(args)\n             yield Command(negated=negated, cmd=cmd, args=args, lineno=lineno+1)\n \n+\n def _flatten(node, acc):\n-    if node.text: acc.append(node.text)\n+    if node.text:\n+        acc.append(node.text)\n     for e in node:\n         _flatten(e, acc)\n-        if e.tail: acc.append(e.tail)\n+        if e.tail:\n+            acc.append(e.tail)\n+\n \n def flatten(node):\n     acc = []\n     _flatten(node, acc)\n     return ''.join(acc)\n \n+\n def normalize_xpath(path):\n     if path.startswith('//'):\n         return '.' + path # avoid warnings\n@@ -218,6 +241,7 @@ def normalize_xpath(path):\n         raise RuntimeError('Non-absolute XPath is not supported due to \\\n                             the implementation issue.')\n \n+\n class CachedFiles(object):\n     def __init__(self, root):\n         self.root = root\n@@ -267,6 +291,7 @@ def get_tree(self, path):\n                 self.trees[path] = tree\n                 return self.trees[path]\n \n+\n def check_string(data, pat, regexp):\n     if not pat:\n         return True # special case a presence testing\n@@ -277,6 +302,7 @@ def check_string(data, pat, regexp):\n         pat = ' '.join(pat.split())\n         return pat in data\n \n+\n def check_tree_attr(tree, path, attr, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n@@ -287,9 +313,11 @@ def check_tree_attr(tree, path, attr, pat, regexp):\n             continue\n         else:\n             ret = check_string(value, pat, regexp)\n-            if ret: break\n+            if ret:\n+                break\n     return ret\n \n+\n def check_tree_text(tree, path, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n@@ -300,9 +328,11 @@ def check_tree_text(tree, path, pat, regexp):\n             continue\n         else:\n             ret = check_string(value, pat, regexp)\n-            if ret: break\n+            if ret:\n+                break\n     return ret\n \n+\n def check(target, commands):\n     cache = CachedFiles(target)\n     for c in commands:\n@@ -323,7 +353,8 @@ def check(target, commands):\n                     ret = check_tree_attr(cache.get_tree(c.args[0]), pat, attr, c.args[2], regexp)\n                 else: # normalized text\n                     pat = c.args[1]\n-                    if pat.endswith('/text()'): pat = pat[:-7]\n+                    if pat.endswith('/text()'):\n+                        pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n                 raise RuntimeError('Invalid number of @{} arguments \\\n@@ -348,4 +379,3 @@ def check(target, commands):\n         raise SystemExit(1)\n     else:\n         check(sys.argv[1], get_commands(sys.argv[2]))\n-"}, {"sha": "6c93bf23f900fc2db196172243ea5711c9206e65", "filename": "src/etc/latest-unix-snaps.py", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Flatest-unix-snaps.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Flatest-unix-snaps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flatest-unix-snaps.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,7 +10,8 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import os, tarfile, hashlib, re, shutil, sys\n+import os\n+import re\n from snapshot import *\n \n f = open(snapshotfile)\n@@ -26,7 +27,8 @@\n for line in f.readlines():\n     i += 1\n     parsed = parse_line(i, line)\n-    if (not parsed): continue\n+    if not parsed:\n+        continue\n \n     if parsed[\"type\"] == \"snapshot\":\n         if (len(newestSet) == 0 or parsed[\"date\"] > newestSet[\"date\"]):\n@@ -37,16 +39,16 @@\n         else:\n             addingMode = False\n \n-    elif addingMode == True and parsed[\"type\"] == \"file\":\n+    elif addingMode is True and parsed[\"type\"] == \"file\":\n         tux = re.compile(\"linux\", re.IGNORECASE)\n-        if (tux.match(parsed[\"platform\"]) != None):\n-           ff = {}\n-           ff[\"platform\"] = parsed[\"platform\"]\n-           ff[\"hash\"] = parsed[\"hash\"]\n-           newestSet[\"files\"] += [ff]\n+        if (tux.match(parsed[\"platform\"]) is not None):\n+            ff = {}\n+            ff[\"platform\"] = parsed[\"platform\"]\n+            ff[\"hash\"] = parsed[\"hash\"]\n+            newestSet[\"files\"] += [ff]\n \n \n-def download_new_file (date, rev, platform, hsh):\n+def download_new_file(date, rev, platform, hsh):\n         snap = full_snapshot_name(date, rev, platform, hsh)\n         dl = os.path.join(download_dir_base, snap)\n         url = download_url_base + \"/\" + snap\n@@ -59,5 +61,5 @@ def download_new_file (date, rev, platform, hsh):\n             raise Exception(\"bad hash on download\")\n \n for ff in newestSet[\"files\"]:\n-   download_new_file (newestSet[\"date\"], newestSet[\"rev\"],\n+    download_new_file(newestSet[\"date\"], newestSet[\"rev\"],\n                       ff[\"platform\"], ff[\"hash\"])"}, {"sha": "b1506285b3ac1a9e47fc44b7a794d11183fb9d50", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 112, "deletions": 106, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -30,36 +30,35 @@\n import threading\n import thread\n import re\n-import atexit\n import time\n \n # Set this to True for additional output\n DEBUG_OUTPUT = False\n \n+\n def print_debug(s):\n-  \"Print something if DEBUG_OUTPUT is True\"\n-  global DEBUG_OUTPUT\n-  if DEBUG_OUTPUT:\n-    print(\"DEBUG: \" + str(s))\n+    \"Print something if DEBUG_OUTPUT is True\"\n+    global DEBUG_OUTPUT\n+    if DEBUG_OUTPUT:\n+        print(\"DEBUG: \" + str(s))\n \n \n def normalize_whitespace(s):\n-  \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n-  return re.sub(\"\\s+\", \" \", s)\n+    \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n+    return re.sub(\"\\s+\", \" \", s)\n \n \n-# This callback is registered with every breakpoint and makes sure that the frame containing the\n-# breakpoint location is selected\n def breakpoint_callback(frame, bp_loc, dict):\n-  \"Called whenever a breakpoint is hit\"\n-  print(\"Hit breakpoint \" + str(bp_loc))\n+    \"\"\"This callback is registered with every breakpoint and makes sure that the\n+    frame containing the breakpoint location is selected\"\"\"\n+    print(\"Hit breakpoint \" + str(bp_loc))\n \n-  # Select the frame and the thread containing it\n-  frame.thread.process.SetSelectedThread(frame.thread)\n-  frame.thread.SetSelectedFrame(frame.idx)\n+    # Select the frame and the thread containing it\n+    frame.thread.process.SetSelectedThread(frame.thread)\n+    frame.thread.SetSelectedFrame(frame.idx)\n \n-  # Returning True means that we actually want to stop at this breakpoint\n-  return True\n+    # Returning True means that we actually want to stop at this breakpoint\n+    return True\n \n \n # This is a list of breakpoints that are not registered with the breakpoint callback. The list is\n@@ -70,91 +69,99 @@ def breakpoint_callback(frame, bp_loc, dict):\n # used to avoid hooking callbacks into breakpoints more than once\n registered_breakpoints = set()\n \n+\n def execute_command(command_interpreter, command):\n-  \"Executes a single CLI command\"\n-  global new_breakpoints\n-  global registered_breakpoints\n-\n-  res = lldb.SBCommandReturnObject()\n-  print(command)\n-  command_interpreter.HandleCommand(command, res)\n-\n-  if res.Succeeded():\n-      if res.HasResult():\n-          print(normalize_whitespace(res.GetOutput()), end = '\\n')\n-\n-      # If the command introduced any breakpoints, make sure to register them with the breakpoint\n-      # callback\n-      while len(new_breakpoints) > 0:\n-        res.Clear()\n-        breakpoint_id = new_breakpoints.pop()\n-\n-        if breakpoint_id in registered_breakpoints:\n-          print_debug(\"breakpoint with id %s is already registered. Ignoring.\" % str(breakpoint_id))\n-        else:\n-          print_debug(\"registering breakpoint callback, id = \" + str(breakpoint_id))\n-          callback_command = \"breakpoint command add -F breakpoint_callback \" + str(breakpoint_id)\n-          command_interpreter.HandleCommand(callback_command, res)\n-          if res.Succeeded():\n-            print_debug(\"successfully registered breakpoint callback, id = \" + str(breakpoint_id))\n-            registered_breakpoints.add(breakpoint_id)\n-          else:\n-            print(\"Error while trying to register breakpoint callback, id = \" + str(breakpoint_id))\n-  else:\n-      print(res.GetError())\n+    \"Executes a single CLI command\"\n+    global new_breakpoints\n+    global registered_breakpoints\n+\n+    res = lldb.SBCommandReturnObject()\n+    print(command)\n+    command_interpreter.HandleCommand(command, res)\n+\n+    if res.Succeeded():\n+        if res.HasResult():\n+            print(normalize_whitespace(res.GetOutput()), end='\\n')\n+\n+        # If the command introduced any breakpoints, make sure to register\n+        # them with the breakpoint\n+        # callback\n+        while len(new_breakpoints) > 0:\n+            res.Clear()\n+            breakpoint_id = new_breakpoints.pop()\n+\n+            if breakpoint_id in registered_breakpoints:\n+                print_debug(\"breakpoint with id %s is already registered. Ignoring.\" %\n+                            str(breakpoint_id))\n+            else:\n+                print_debug(\"registering breakpoint callback, id = \" + str(breakpoint_id))\n+                callback_command = (\"breakpoint command add -F breakpoint_callback \" +\n+                                    str(breakpoint_id))\n+                command_interpreter.HandleCommand(callback_command, res)\n+                if res.Succeeded():\n+                    print_debug(\"successfully registered breakpoint callback, id = \" +\n+                                str(breakpoint_id))\n+                    registered_breakpoints.add(breakpoint_id)\n+                else:\n+                    print(\"Error while trying to register breakpoint callback, id = \" +\n+                          str(breakpoint_id))\n+    else:\n+        print(res.GetError())\n \n \n def start_breakpoint_listener(target):\n-  \"Listens for breakpoints being added and adds new ones to the callback registration list\"\n-  listener = lldb.SBListener(\"breakpoint listener\")\n-\n-  def listen():\n-    event = lldb.SBEvent()\n-    try:\n-      while True:\n-        if listener.WaitForEvent(120, event):\n-          if lldb.SBBreakpoint.EventIsBreakpointEvent(event) and \\\n-             lldb.SBBreakpoint.GetBreakpointEventTypeFromEvent(event) == \\\n-             lldb.eBreakpointEventTypeAdded:\n-            global new_breakpoints\n-            breakpoint = lldb.SBBreakpoint.GetBreakpointFromEvent(event)\n-            print_debug(\"breakpoint added, id = \" + str(breakpoint.id))\n-            new_breakpoints.append(breakpoint.id)\n-    except:\n-      print_debug(\"breakpoint listener shutting down\")\n-\n-  # Start the listener and let it run as a daemon\n-  listener_thread = threading.Thread(target = listen)\n-  listener_thread.daemon = True\n-  listener_thread.start()\n-\n-  # Register the listener with the target\n-  target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n+    \"\"\"Listens for breakpoints being added and adds new ones to the callback\n+    registration list\"\"\"\n+    listener = lldb.SBListener(\"breakpoint listener\")\n+\n+    def listen():\n+        event = lldb.SBEvent()\n+        try:\n+            while True:\n+                if listener.WaitForEvent(120, event):\n+                    if lldb.SBBreakpoint.EventIsBreakpointEvent(event) and \\\n+                            lldb.SBBreakpoint.GetBreakpointEventTypeFromEvent(event) == \\\n+                            lldb.eBreakpointEventTypeAdded:\n+                        global new_breakpoints\n+                        breakpoint = lldb.SBBreakpoint.GetBreakpointFromEvent(event)\n+                        print_debug(\"breakpoint added, id = \" + str(breakpoint.id))\n+                        new_breakpoints.append(breakpoint.id)\n+        except:\n+            print_debug(\"breakpoint listener shutting down\")\n+\n+    # Start the listener and let it run as a daemon\n+    listener_thread = threading.Thread(target=listen)\n+    listener_thread.daemon = True\n+    listener_thread.start()\n+\n+    # Register the listener with the target\n+    target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n \n \n def start_watchdog():\n-  \"Starts a watchdog thread that will terminate the process after a certain period of time\"\n-  watchdog_start_time = time.clock()\n-  watchdog_max_time = watchdog_start_time + 30\n-\n-  def watchdog():\n-    while time.clock() < watchdog_max_time:\n-      time.sleep(1)\n-    print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n-    thread.interrupt_main()\n-\n-  # Start the listener and let it run as a daemon\n-  watchdog_thread = threading.Thread(target = watchdog)\n-  watchdog_thread.daemon = True\n-  watchdog_thread.start()\n+    \"\"\"Starts a watchdog thread that will terminate the process after a certain\n+    period of time\"\"\"\n+    watchdog_start_time = time.clock()\n+    watchdog_max_time = watchdog_start_time + 30\n+\n+    def watchdog():\n+        while time.clock() < watchdog_max_time:\n+            time.sleep(1)\n+        print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n+        thread.interrupt_main()\n+\n+    # Start the listener and let it run as a daemon\n+    watchdog_thread = threading.Thread(target=watchdog)\n+    watchdog_thread.daemon = True\n+    watchdog_thread.start()\n \n ####################################################################################################\n # ~main\n ####################################################################################################\n \n if len(sys.argv) != 3:\n-  print(\"usage: python lldb_batchmode.py target-path script-path\")\n-  sys.exit(1)\n+    print(\"usage: python lldb_batchmode.py target-path script-path\")\n+    sys.exit(1)\n \n target_path = sys.argv[1]\n script_path = sys.argv[2]\n@@ -181,9 +188,9 @@ def watchdog():\n target = debugger.CreateTarget(target_path, None, None, True, target_error)\n \n if not target:\n-  print(\"Could not create debugging target '\" + target_path + \"': \" + str(target_error) +\n-        \". Aborting.\", file=sys.stderr)\n-  sys.exit(1)\n+    print(\"Could not create debugging target '\" + target_path + \"': \" +\n+          str(target_error) + \". Aborting.\", file=sys.stderr)\n+    sys.exit(1)\n \n \n # Register the breakpoint callback for every breakpoint\n@@ -192,22 +199,21 @@ def watchdog():\n command_interpreter = debugger.GetCommandInterpreter()\n \n try:\n-  script_file = open(script_path, 'r')\n+    script_file = open(script_path, 'r')\n \n-  for line in script_file:\n-    command = line.strip()\n-    if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n-      # Before starting to run the program, let the thread sleep a bit, so all\n-      # breakpoint added events can be processed\n-      time.sleep(0.5)\n-    if command != '':\n-      execute_command(command_interpreter, command)\n+    for line in script_file:\n+        command = line.strip()\n+        if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n+            # Before starting to run the program, let the thread sleep a bit, so all\n+            # breakpoint added events can be processed\n+            time.sleep(0.5)\n+        if command != '':\n+            execute_command(command_interpreter, command)\n \n except IOError as e:\n-  print(\"Could not read debugging script '%s'.\" % script_path, file = sys.stderr)\n-  print(e, file = sys.stderr)\n-  print(\"Aborting.\", file = sys.stderr)\n-  sys.exit(1)\n+    print(\"Could not read debugging script '%s'.\" % script_path, file=sys.stderr)\n+    print(e, file=sys.stderr)\n+    print(\"Aborting.\", file=sys.stderr)\n+    sys.exit(1)\n finally:\n-  script_file.close()\n-\n+    script_file.close()"}, {"sha": "42c83b6a42ed6f6df6ad7ec765fa5eb5e809b897", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 171, "deletions": 169, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,186 +10,189 @@\n \n import lldb\n \n+\n def print_val(val, internal_dict):\n-  '''Prints the given value with Rust syntax'''\n-  type_class = val.GetType().GetTypeClass()\n+    '''Prints the given value with Rust syntax'''\n+    type_class = val.GetType().GetTypeClass()\n \n-  if type_class == lldb.eTypeClassStruct:\n-    return print_struct_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassStruct:\n+        return print_struct_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassUnion:\n-    return print_enum_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassUnion:\n+        return print_enum_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassPointer:\n-    return print_pointer_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassPointer:\n+        return print_pointer_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassArray:\n-    return print_fixed_size_vec_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassArray:\n+        return print_fixed_size_vec_val(val, internal_dict)\n \n-  return val.GetValue()\n+    return val.GetValue()\n \n \n #=--------------------------------------------------------------------------------------------------\n # Type-Specialized Printing Functions\n #=--------------------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict):\n-  '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+    '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+\n+    if is_vec_slice(val):\n+        return print_vec_slice_val(val, internal_dict)\n+    else:\n+        return print_struct_val_starting_from(0, val, internal_dict)\n \n-  if is_vec_slice(val):\n-    return print_vec_slice_val(val, internal_dict)\n-  else:\n-    return print_struct_val_starting_from(0, val, internal_dict)\n \n def print_vec_slice_val(val, internal_dict):\n-  length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n+    length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n \n-  data_ptr_val = val.GetChildAtIndex(0)\n-  data_ptr_type = data_ptr_val.GetType()\n-  assert data_ptr_type.IsPointerType()\n+    data_ptr_val = val.GetChildAtIndex(0)\n+    data_ptr_type = data_ptr_val.GetType()\n+    assert data_ptr_type.IsPointerType()\n \n-  element_type = data_ptr_type.GetPointeeType()\n-  element_type_size = element_type.GetByteSize()\n+    element_type = data_ptr_type.GetPointeeType()\n+    element_type_size = element_type.GetByteSize()\n \n-  start_address = data_ptr_val.GetValueAsUnsigned()\n+    start_address = data_ptr_val.GetValueAsUnsigned()\n \n-  def render_element(i):\n-    address = start_address + i * element_type_size\n-    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type)\n-    return print_val(element_val, internal_dict)\n+    def render_element(i):\n+        address = start_address + i * element_type_size\n+        element_val = val.CreateValueFromAddress(val.GetName() +\n+                                                 (\"[%s]\" % i), address, element_type)\n+        return print_val(element_val, internal_dict)\n \n-  return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n+    return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n \n-def print_struct_val_starting_from(field_start_index, val, internal_dict):\n-  '''\n-  Prints a struct, tuple, or tuple struct value with Rust syntax.\n-  Ignores any fields before field_start_index.\n-  '''\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n-\n-  t = val.GetType()\n-  type_name = extract_type_name(t.GetName())\n-  num_children = val.num_children\n-\n-  if (num_children - field_start_index) == 0:\n-    # The only field of this struct is the enum discriminant\n-    return type_name\n-\n-  has_field_names = type_has_field_names(t)\n-\n-  if has_field_names:\n-    template = \"%(type_name)s {\\n%(body)s\\n}\"\n-    separator = \", \\n\"\n-  else:\n-    template = \"%(type_name)s(%(body)s)\"\n-    separator = \", \"\n-\n-  if type_name.startswith(\"(\"):\n-    # this is a tuple, so don't print the type name\n-    type_name = \"\"\n-\n-  def render_child(child_index):\n-    this = \"\"\n-    if has_field_names:\n-      field_name = t.GetFieldAtIndex(child_index).GetName()\n-      this += field_name + \": \"\n \n-    field_val = val.GetChildAtIndex(child_index)\n-    return this + print_val(field_val, internal_dict)\n+def print_struct_val_starting_from(field_start_index, val, internal_dict):\n+    '''\n+    Prints a struct, tuple, or tuple struct value with Rust syntax.\n+    Ignores any fields before field_start_index.\n+    '''\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n \n-  body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+    t = val.GetType()\n+    type_name = extract_type_name(t.GetName())\n+    num_children = val.num_children\n \n-  return template % {\"type_name\": type_name,\n-                     \"body\": body}\n+    if (num_children - field_start_index) == 0:\n+        # The only field of this struct is the enum discriminant\n+        return type_name\n \n+    has_field_names = type_has_field_names(t)\n \n-def print_enum_val(val, internal_dict):\n-  '''Prints an enum value with Rust syntax'''\n-\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n-\n-  if val.num_children == 1:\n-    # This is either an enum with just one variant, or it is an Option-like enum\n-    # where the discriminant is encoded in a non-nullable pointer field. We find\n-    # out which one it is by looking at the member name of the sole union\n-    # variant. If it starts with \"RUST$ENCODED$ENUM$\" then we have an\n-    # Option-like enum.\n-    first_variant_name = val.GetChildAtIndex(0).GetName()\n-    if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n-\n-      # This is an Option-like enum. The position of the discriminator field is\n-      # encoded in the name which has the format:\n-      #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n-      last_separator_index = first_variant_name.rfind(\"$\")\n-      if last_separator_index == -1:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-      start_index = len(\"RUST$ENCODED$ENUM$\")\n-\n-      # Extract indices of the discriminator field\n-      try:\n-        disr_field_indices = first_variant_name[start_index :\n-                                              last_separator_index].split(\"$\")\n-        disr_field_indices = [int(index) for index in disr_field_indices]\n-      except:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-      # Read the discriminant\n-      disr_val = val.GetChildAtIndex(0)\n-      for index in disr_field_indices:\n-        disr_val = disr_val.GetChildAtIndex(index)\n-\n-      # If the discriminant field is a fat pointer we have to consider the\n-      # first word as the true discriminant\n-      if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n-        disr_val = disr_val.GetChildAtIndex(0)\n-\n-      if disr_val.GetValueAsUnsigned() == 0:\n-        # Null case: Print the name of the null-variant\n-        null_variant_name = first_variant_name[last_separator_index + 1:]\n-        return null_variant_name\n-      else:\n-        # Non-null case: Interpret the data as a value of the non-null variant type\n-        return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+    if has_field_names:\n+        template = \"%(type_name)s {\\n%(body)s\\n}\"\n+        separator = \", \\n\"\n     else:\n-      # This is just a regular uni-variant enum without discriminator field\n-      return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+        template = \"%(type_name)s(%(body)s)\"\n+        separator = \", \"\n+\n+    if type_name.startswith(\"(\"):\n+        # this is a tuple, so don't print the type name\n+        type_name = \"\"\n \n-  # If we are here, this is a regular enum with more than one variant\n-  disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n-  disr_type = disr_val.GetType()\n+    def render_child(child_index):\n+        this = \"\"\n+        if has_field_names:\n+            field_name = t.GetFieldAtIndex(child_index).GetName()\n+            this += field_name + \": \"\n \n-  if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n-    return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+        field_val = val.GetChildAtIndex(child_index)\n+        return this + print_val(field_val, internal_dict)\n \n-  variant_index = disr_val.GetValueAsUnsigned()\n-  return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n+    body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+\n+    return template % {\"type_name\": type_name,\n+                       \"body\": body}\n+\n+\n+def print_enum_val(val, internal_dict):\n+    '''Prints an enum value with Rust syntax'''\n+\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n+\n+    if val.num_children == 1:\n+        # This is either an enum with just one variant, or it is an Option-like\n+        # enum where the discriminant is encoded in a non-nullable pointer\n+        # field. We find out which one it is by looking at the member name of\n+        # the sole union variant. If it starts with \"RUST$ENCODED$ENUM$\" then\n+        # we have an Option-like enum.\n+        first_variant_name = val.GetChildAtIndex(0).GetName()\n+        if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n+\n+            # This is an Option-like enum. The position of the discriminator field is\n+            # encoded in the name which has the format:\n+            #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n+            last_separator_index = first_variant_name.rfind(\"$\")\n+            if last_separator_index == -1:\n+                return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+            start_index = len(\"RUST$ENCODED$ENUM$\")\n+\n+            # Extract indices of the discriminator field\n+            try:\n+                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n+                disr_field_indices = [int(index) for index in disr_field_indices]\n+            except:\n+                return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+            # Read the discriminant\n+            disr_val = val.GetChildAtIndex(0)\n+            for index in disr_field_indices:\n+                disr_val = disr_val.GetChildAtIndex(index)\n+\n+            # If the discriminant field is a fat pointer we have to consider the\n+            # first word as the true discriminant\n+            if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n+                disr_val = disr_val.GetChildAtIndex(0)\n+\n+            if disr_val.GetValueAsUnsigned() == 0:\n+                # Null case: Print the name of the null-variant\n+                null_variant_name = first_variant_name[last_separator_index + 1:]\n+                return null_variant_name\n+            else:\n+                # Non-null case: Interpret the data as a value of the non-null variant type\n+                return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+        else:\n+            # This is just a regular uni-variant enum without discriminator field\n+            return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+\n+    # If we are here, this is a regular enum with more than one variant\n+    disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n+    disr_type = disr_val.GetType()\n+\n+    if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n+        return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+\n+    variant_index = disr_val.GetValueAsUnsigned()\n+    return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n \n \n def print_pointer_val(val, internal_dict):\n-  '''Prints a pointer value with Rust syntax'''\n-  assert val.GetType().IsPointerType()\n-  sigil = \"&\"\n-  type_name = extract_type_name(val.GetType().GetName())\n-  if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n-    sigil = type_name[0:1]\n+    '''Prints a pointer value with Rust syntax'''\n+    assert val.GetType().IsPointerType()\n+    sigil = \"&\"\n+    type_name = extract_type_name(val.GetType().GetName())\n+    if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n+        sigil = type_name[0:1]\n \n-  return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n+    return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n \n \n def print_fixed_size_vec_val(val, internal_dict):\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n \n-  output = \"[\"\n+    output = \"[\"\n \n-  for i in range(val.num_children):\n-    output += print_val(val.GetChildAtIndex(i), internal_dict)\n-    if i != val.num_children - 1:\n-      output += \", \"\n+    for i in range(val.num_children):\n+        output += print_val(val.GetChildAtIndex(i), internal_dict)\n+        if i != val.num_children - 1:\n+            output += \", \"\n \n-  output += \"]\"\n-  return output\n+    output += \"]\"\n+    return output\n \n \n #=--------------------------------------------------------------------------------------------------\n@@ -198,46 +201,45 @@ def print_fixed_size_vec_val(val, internal_dict):\n \n unqualified_type_markers = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n+\n def extract_type_name(qualified_type_name):\n-  '''Extracts the type name from a fully qualified path'''\n-  if qualified_type_name[0] in unqualified_type_markers:\n-    return qualified_type_name\n+    '''Extracts the type name from a fully qualified path'''\n+    if qualified_type_name[0] in unqualified_type_markers:\n+        return qualified_type_name\n \n-  end_of_search = qualified_type_name.find(\"<\")\n-  if end_of_search < 0:\n-    end_of_search = len(qualified_type_name)\n+    end_of_search = qualified_type_name.find(\"<\")\n+    if end_of_search < 0:\n+        end_of_search = len(qualified_type_name)\n \n-  index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n-  if index < 0:\n-    return qualified_type_name\n-  else:\n-    return qualified_type_name[index + 2:]\n+    index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n+    if index < 0:\n+        return qualified_type_name\n+    else:\n+        return qualified_type_name[index + 2:]\n \n \n def type_has_field_names(ty):\n-  '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n-  # This may also be an enum variant where the first field doesn't have a name but the rest has\n-  if ty.GetNumberOfFields() > 1:\n-    return ty.GetFieldAtIndex(1).GetName() != None\n-  else:\n-    return ty.GetFieldAtIndex(0).GetName() != None\n+    '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n+    # This may also be an enum variant where the first field doesn't have a name but the rest has\n+    if ty.GetNumberOfFields() > 1:\n+        return ty.GetFieldAtIndex(1).GetName() is not None\n+    else:\n+        return ty.GetFieldAtIndex(0).GetName() is not None\n \n \n def is_vec_slice(val):\n-  ty = val.GetType()\n-  if ty.GetTypeClass() != lldb.eTypeClassStruct:\n-    return False\n-\n-  if ty.GetNumberOfFields() != 2:\n-    return False\n+    ty = val.GetType()\n+    if ty.GetTypeClass() != lldb.eTypeClassStruct:\n+        return False\n \n-  if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n-    return False\n+    if ty.GetNumberOfFields() != 2:\n+        return False\n \n-  if ty.GetFieldAtIndex(1).GetName() != \"length\":\n-    return False\n+    if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n+        return False\n \n-  type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n-  return type_name.startswith(\"&[\") and type_name.endswith(\"]\")\n+    if ty.GetFieldAtIndex(1).GetName() != \"length\":\n+        return False\n \n-# vi: sw=2:ts=2\n+    type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n+    return type_name.startswith(\"&[\") and type_name.endswith(\"]\")"}, {"sha": "13d051350248871d19e2f0268685af5050e6cb1e", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,7 +14,11 @@\n #     argv[3] = target triple\n # The first two correspond to the two installable components defined in the setup script.\n \n-import sys, os, shutil, subprocess\n+import sys\n+import os\n+import shutil\n+import subprocess\n+\n \n def find_files(files, path):\n     found = []\n@@ -28,6 +32,7 @@ def find_files(files, path):\n             raise Exception(\"Could not find '%s' in %s\" % (fname, path))\n     return found\n \n+\n def make_win_dist(rust_root, gcc_root, target_triple):\n     # Ask gcc where it keeps its stuff\n     gcc_out = subprocess.check_output([\"gcc.exe\", \"-print-search-dirs\"])\n@@ -114,5 +119,5 @@ def make_win_dist(rust_root, gcc_root, target_triple):\n     for src in target_libs:\n         shutil.copy(src, target_lib_dir)\n \n-if __name__==\"__main__\":\n+if __name__ == \"__main__\":\n     make_win_dist(sys.argv[1], sys.argv[2], sys.argv[3])"}, {"sha": "f500de5e15d00c623784a62c8662c3ca0c2ab982", "filename": "src/etc/maketest.py", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmaketest.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmaketest.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmaketest.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -12,13 +12,14 @@\n import os\n import sys\n \n-# msys1/msys2 automatically converts `/abs/path1:/abs/path2` into\n-# `c:\\real\\abs\\path1;c:\\real\\abs\\path2` (semicolons) if shell thinks\n-# the value is list of paths.\n-# (if there is only one path, it becomes `c:/real/abs/path`.)\n-# this causes great confusion and error: shell and Makefile doesn't like\n-# windows paths so it is really error-prone. revert it for peace.\n+\n def normalize_path(v):\n+    \"\"\"msys1/msys2 automatically converts `/abs/path1:/abs/path2` into\n+    `c:\\real\\abs\\path1;c:\\real\\abs\\path2` (semicolons) if shell thinks\n+    the value is list of paths.\n+    (if there is only one path, it becomes `c:/real/abs/path`.)\n+    this causes great confusion and error: shell and Makefile doesn't like\n+    windows paths so it is really error-prone. revert it for peace.\"\"\"\n     v = v.replace('\\\\', '/')\n     # c:/path -> /c/path\n     if ':/' in v:\n@@ -31,6 +32,7 @@ def putenv(name, value):\n         value = normalize_path(value)\n     os.putenv(name, value)\n \n+\n def convert_path_spec(name, value):\n     if os.name == 'nt' and name != 'PATH':\n         value = \":\".join(normalize_path(v) for v in value.split(\";\"))\n@@ -42,14 +44,14 @@ def convert_path_spec(name, value):\n putenv('CC', sys.argv[5])\n putenv('RUSTDOC', os.path.abspath(sys.argv[6]))\n filt = sys.argv[7]\n-putenv('LD_LIB_PATH_ENVVAR', sys.argv[8]);\n-putenv('HOST_RPATH_DIR', os.path.abspath(sys.argv[9]));\n-putenv('TARGET_RPATH_DIR', os.path.abspath(sys.argv[10]));\n+putenv('LD_LIB_PATH_ENVVAR', sys.argv[8])\n+putenv('HOST_RPATH_DIR', os.path.abspath(sys.argv[9]))\n+putenv('TARGET_RPATH_DIR', os.path.abspath(sys.argv[10]))\n putenv('RUST_BUILD_STAGE', sys.argv[11])\n putenv('S', os.path.abspath(sys.argv[12]))\n putenv('PYTHON', sys.executable)\n \n-if not filt in sys.argv[1]:\n+if filt not in sys.argv[1]:\n     sys.exit(0)\n print('maketest: ' + os.path.basename(os.path.dirname(sys.argv[1])))\n \n@@ -63,19 +65,19 @@ def convert_path_spec(name, value):\n     path = path[:-1]\n \n proc = subprocess.Popen([make, '-C', path],\n-                        stdout = subprocess.PIPE,\n-                        stderr = subprocess.PIPE)\n+                        stdout=subprocess.PIPE,\n+                        stderr=subprocess.PIPE)\n out, err = proc.communicate()\n i = proc.wait()\n \n if i != 0:\n-\n-    print '----- ' + sys.argv[1] + \"\"\" --------------------\n+    print \"\"\"\\\n+----- %s --------------------\n ------ stdout ---------------------------------------------\n-\"\"\" + out + \"\"\"\n+%s\n ------ stderr ---------------------------------------------\n-\"\"\" + err + \"\"\"\n+%s\n ------        ---------------------------------------------\n-\"\"\"\n-    sys.exit(i)\n+\"\"\" % (sys.argv[1], out, err)\n \n+    sys.exit(i)"}, {"sha": "cd77f882140fef67446d2798c3927fb9b8148bb5", "filename": "src/etc/mirror-all-snapshots.py", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmirror-all-snapshots.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmirror-all-snapshots.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmirror-all-snapshots.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,7 +10,7 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import os, tarfile, hashlib, re, shutil\n+import os\n from snapshot import *\n \n f = open(snapshotfile)\n@@ -23,13 +23,14 @@\n for line in f.readlines():\n     i += 1\n     parsed = parse_line(i, line)\n-    if (not parsed): continue\n+    if not parsed:\n+        continue\n \n     if parsed[\"type\"] == \"snapshot\":\n         date = parsed[\"date\"]\n         rev = parsed[\"rev\"]\n \n-    elif rev != None and parsed[\"type\"] == \"file\":\n+    elif rev is not None and parsed[\"type\"] == \"file\":\n         platform = parsed[\"platform\"]\n         hsh = parsed[\"hash\"]\n         snap = full_snapshot_name(date, rev, platform, hsh)"}, {"sha": "a4234159cb81c9ee624df8b7e4b10aab01aa0788", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,8 +11,6 @@\n import os\n import sys\n import subprocess\n-import itertools\n-from os import path\n \n f = open(sys.argv[1], 'wb')\n \n@@ -35,6 +33,7 @@\n //          take a look at src/etc/mklldeps.py if you're interested\n \"\"\")\n \n+\n def run(args):\n     proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n     out, err = proc.communicate()"}, {"sha": "698c3a551e2a0736fd7d6550557e033fb0ab9a3a", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 153, "deletions": 132, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,79 +8,90 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import re, os, sys, glob, tarfile, shutil, subprocess, tempfile, distutils.spawn\n+import re\n+import os\n+import sys\n+import glob\n+import tarfile\n+import shutil\n+import subprocess\n+import distutils.spawn\n \n try:\n-  import hashlib\n-  sha_func = hashlib.sha1\n+    import hashlib\n+    sha_func = hashlib.sha1\n except ImportError:\n-  import sha\n-  sha_func = sha.new\n+    import sha\n+    sha_func = sha.new\n+\n \n def scrub(b):\n-  if sys.version_info >= (3,) and type(b) == bytes:\n-    return b.decode('ascii')\n-  else:\n-    return b\n+    if sys.version_info >= (3,) and type(b) == bytes:\n+        return b.decode('ascii')\n+    else:\n+        return b\n \n src_dir = scrub(os.getenv(\"CFG_SRC_DIR\"))\n if not src_dir:\n-  raise Exception(\"missing env var CFG_SRC_DIR\")\n+    raise Exception(\"missing env var CFG_SRC_DIR\")\n \n snapshotfile = os.path.join(src_dir, \"src\", \"snapshots.txt\")\n download_url_base = \"https://static.rust-lang.org/stage0-snapshots\"\n download_dir_base = \"dl\"\n download_unpack_base = os.path.join(download_dir_base, \"unpack\")\n \n snapshot_files = {\n-    \"linux\": [\"bin/rustc\"],\n-    \"macos\": [\"bin/rustc\"],\n-    \"winnt\": [\"bin/rustc.exe\"],\n-    \"freebsd\": [\"bin/rustc\"],\n-    \"dragonfly\": [\"bin/rustc\"],\n-    }\n-\n-winnt_runtime_deps_32 = [\"libgcc_s_dw2-1.dll\",\n-                         \"libstdc++-6.dll\"]\n-winnt_runtime_deps_64 = [\"libgcc_s_seh-1.dll\",\n-                         \"libstdc++-6.dll\"]\n+        \"linux\": [\"bin/rustc\"],\n+        \"macos\": [\"bin/rustc\"],\n+        \"winnt\": [\"bin/rustc.exe\"],\n+        \"freebsd\": [\"bin/rustc\"],\n+        \"dragonfly\": [\"bin/rustc\"],\n+        }\n+\n+winnt_runtime_deps_32 = [\"libgcc_s_dw2-1.dll\", \"libstdc++-6.dll\"]\n+winnt_runtime_deps_64 = [\"libgcc_s_seh-1.dll\", \"libstdc++-6.dll\"]\n+\n \n def parse_line(n, line):\n-  global snapshotfile\n+    global snapshotfile\n \n-  if re.match(r\"\\s*$\", line): return None\n+    if re.match(r\"\\s*$\", line):\n+        return None\n \n-  if re.match(r\"^T\\s*$\", line): return None\n+    if re.match(r\"^T\\s*$\", line):\n+        return None\n \n-  match = re.match(r\"\\s+([\\w_-]+) ([a-fA-F\\d]{40})\\s*$\", line)\n-  if match:\n-    return { \"type\": \"file\",\n-             \"platform\": match.group(1),\n-             \"hash\": match.group(2).lower() }\n+    match = re.match(r\"\\s+([\\w_-]+) ([a-fA-F\\d]{40})\\s*$\", line)\n+    if match:\n+        return {\"type\": \"file\",\n+                \"platform\": match.group(1),\n+                \"hash\": match.group(2).lower()}\n \n-  match = re.match(r\"([ST]) (\\d{4}-\\d{2}-\\d{2}) ([a-fA-F\\d]+)\\s*$\", line);\n-  if (not match):\n-    raise Exception(\"%s:%d:E syntax error: \" % (snapshotfile, n))\n-  return {\"type\": \"snapshot\",\n-          \"date\": match.group(2),\n-          \"rev\": match.group(3)}\n+    match = re.match(r\"([ST]) (\\d{4}-\\d{2}-\\d{2}) ([a-fA-F\\d]+)\\s*$\", line)\n+    if not match:\n+        raise Exception(\"%s:%d:E syntax error: \" % (snapshotfile, n))\n+    return {\"type\": \"snapshot\",\n+            \"date\": match.group(2),\n+            \"rev\": match.group(3)}\n \n \n def partial_snapshot_name(date, rev, platform):\n-  return (\"rust-stage0-%s-%s-%s.tar.bz2\"\n-          % (date, rev, platform))\n+    return (\"rust-stage0-%s-%s-%s.tar.bz2\" %\n+            (date, rev, platform))\n+\n \n def full_snapshot_name(date, rev, platform, hsh):\n-  return (\"rust-stage0-%s-%s-%s-%s.tar.bz2\"\n-          % (date, rev, platform, hsh))\n+    return (\"rust-stage0-%s-%s-%s-%s.tar.bz2\" %\n+            (date, rev, platform, hsh))\n \n \n def get_kernel(triple):\n     t = triple.split('-')\n     if len(t) == 2:\n-      os_name = t[1]\n+        os_name = t[1]\n     else:\n-      os_name = t[2]\n+        os_name = t[2]\n+\n     if os_name == \"windows\":\n         return \"winnt\"\n     if os_name == \"darwin\":\n@@ -91,19 +102,20 @@ def get_kernel(triple):\n         return \"dragonfly\"\n     return \"linux\"\n \n+\n def get_cpu(triple):\n     arch = triple.split('-')[0]\n     if arch == \"i686\":\n-      return \"i386\"\n+        return \"i386\"\n     return arch\n \n+\n def get_platform(triple):\n-  return \"%s-%s\" % (get_kernel(triple), get_cpu(triple))\n+    return \"%s-%s\" % (get_kernel(triple), get_cpu(triple))\n \n \n def cmd_out(cmdline):\n-    p = subprocess.Popen(cmdline,\n-                         stdout=subprocess.PIPE)\n+    p = subprocess.Popen(cmdline, stdout=subprocess.PIPE)\n     return scrub(p.communicate()[0].strip())\n \n \n@@ -124,7 +136,8 @@ def local_rev_short_sha():\n def local_rev_committer_date():\n     return local_rev_info(\"ci\")\n \n-def get_url_to_file(u,f):\n+\n+def get_url_to_file(u, f):\n     # no security issue, just to stop partial download leaving a stale file\n     tmpf = f + '.tmp'\n \n@@ -137,40 +150,44 @@ def get_url_to_file(u,f):\n     if returncode != 0:\n         try:\n             os.unlink(tmpf)\n-        except OSError as e:\n+        except OSError:\n             pass\n         raise Exception(\"failed to fetch url\")\n     os.rename(tmpf, f)\n \n+\n def snap_filename_hash_part(snap):\n-  match = re.match(r\".*([a-fA-F\\d]{40}).tar.bz2$\", snap)\n-  if not match:\n-    raise Exception(\"unable to find hash in filename: \" + snap)\n-  return match.group(1)\n+    match = re.match(r\".*([a-fA-F\\d]{40}).tar.bz2$\", snap)\n+    if not match:\n+        raise Exception(\"unable to find hash in filename: \" + snap)\n+    return match.group(1)\n+\n \n def hash_file(x):\n     h = sha_func()\n     h.update(open(x, \"rb\").read())\n     return scrub(h.hexdigest())\n \n-# Returns a list of paths of Rust's system runtime dependencies\n+\n def get_winnt_runtime_deps(platform):\n+    \"\"\"Returns a list of paths of Rust's system runtime dependencies\"\"\"\n     if platform == \"winnt-x86_64\":\n-      deps = winnt_runtime_deps_64\n+        deps = winnt_runtime_deps_64\n     else:\n-      deps = winnt_runtime_deps_32\n+        deps = winnt_runtime_deps_32\n     runtime_deps = []\n     path_dirs = os.environ[\"PATH\"].split(os.pathsep)\n     for name in deps:\n-      for dir in path_dirs:\n-        filepath = os.path.join(dir, name)\n-        if os.path.isfile(filepath):\n-          runtime_deps.append(filepath)\n-          break\n-      else:\n-        raise Exception(\"Could not find runtime dependency: %s\" % name)\n+        for dir in path_dirs:\n+            filepath = os.path.join(dir, name)\n+            if os.path.isfile(filepath):\n+                runtime_deps.append(filepath)\n+                break\n+        else:\n+            raise Exception(\"Could not find runtime dependency: %s\" % name)\n     return runtime_deps\n \n+\n def make_snapshot(stage, triple):\n     kernel = get_kernel(triple)\n     platform = get_platform(triple)\n@@ -180,31 +197,31 @@ def make_snapshot(stage, triple):\n     file0 = partial_snapshot_name(date, rev, platform)\n \n     def in_tar_name(fn):\n-      cs = re.split(r\"[\\\\/]\", fn)\n-      if len(cs) >= 2:\n-        return os.sep.join(cs[-2:])\n+        cs = re.split(r\"[\\\\/]\", fn)\n+        if len(cs) >= 2:\n+            return os.sep.join(cs[-2:])\n \n     tar = tarfile.open(file0, \"w:bz2\")\n \n     for name in snapshot_files[kernel]:\n-      dir = stage\n-      if stage == \"stage1\" and re.match(r\"^lib/(lib)?std.*\", name):\n-        dir = \"stage0\"\n-      fn_glob = os.path.join(triple, dir, name)\n-      matches = glob.glob(fn_glob)\n-      if not matches:\n-        raise Exception(\"Not found file with name like \" + fn_glob)\n-      if len(matches) == 1:\n-        tar.add(matches[0], \"rust-stage0/\" + in_tar_name(matches[0]))\n-      else:\n-        raise Exception(\"Found stale files: \\n  %s\\n\"\n-                        \"Please make a clean build.\" % \"\\n  \".join(matches))\n-\n-    if kernel==\"winnt\":\n-      for path in get_winnt_runtime_deps(platform):\n-        tar.add(path, \"rust-stage0/bin/\" + os.path.basename(path))\n-      tar.add(os.path.join(os.path.dirname(__file__), \"third-party\"),\n-              \"rust-stage0/bin/third-party\")\n+        dir = stage\n+        if stage == \"stage1\" and re.match(r\"^lib/(lib)?std.*\", name):\n+            dir = \"stage0\"\n+        fn_glob = os.path.join(triple, dir, name)\n+        matches = glob.glob(fn_glob)\n+        if not matches:\n+            raise Exception(\"Not found file with name like \" + fn_glob)\n+        if len(matches) == 1:\n+            tar.add(matches[0], \"rust-stage0/\" + in_tar_name(matches[0]))\n+        else:\n+            raise Exception(\"Found stale files: \\n  %s\\n\"\n+                            \"Please make a clean build.\" % \"\\n  \".join(matches))\n+\n+    if kernel == \"winnt\":\n+        for path in get_winnt_runtime_deps(platform):\n+            tar.add(path, \"rust-stage0/bin/\" + os.path.basename(path))\n+        tar.add(os.path.join(os.path.dirname(__file__), \"third-party\"),\n+                \"rust-stage0/bin/third-party\")\n \n     tar.close()\n \n@@ -215,60 +232,64 @@ def in_tar_name(fn):\n \n     return file1\n \n+\n def curr_snapshot_rev():\n-  i = 0\n-  found_snap = False\n-  date = None\n-  rev = None\n+    i = 0\n+    found_snap = False\n+    date = None\n+    rev = None\n+\n+    f = open(snapshotfile)\n+    for line in f.readlines():\n+        i += 1\n+        parsed = parse_line(i, line)\n+        if not parsed:\n+            continue\n \n-  f = open(snapshotfile)\n-  for line in f.readlines():\n-    i += 1\n-    parsed = parse_line(i, line)\n-    if (not parsed): continue\n+        if parsed[\"type\"] == \"snapshot\":\n+            date = parsed[\"date\"]\n+            rev = parsed[\"rev\"]\n+            found_snap = True\n+            break\n \n-    if parsed[\"type\"] == \"snapshot\":\n-      date = parsed[\"date\"]\n-      rev = parsed[\"rev\"]\n-      found_snap = True\n-      break\n+    if not found_snap:\n+        raise Exception(\"no snapshot entries in file\")\n \n-  if not found_snap:\n-    raise Exception(\"no snapshot entries in file\")\n+    return (date, rev)\n \n-  return (date, rev)\n \n def determine_curr_snapshot(triple):\n-  i = 0\n-  platform = get_platform(triple)\n-\n-  found_file = False\n-  found_snap = False\n-  hsh = None\n-  date = None\n-  rev = None\n-\n-  f = open(snapshotfile)\n-  for line in f.readlines():\n-    i += 1\n-    parsed = parse_line(i, line)\n-    if (not parsed): continue\n-\n-    if found_snap and parsed[\"type\"] == \"file\":\n-      if parsed[\"platform\"] == platform:\n-        hsh = parsed[\"hash\"]\n-        found_file = True\n-        break;\n-    elif parsed[\"type\"] == \"snapshot\":\n-      date = parsed[\"date\"]\n-      rev = parsed[\"rev\"]\n-      found_snap = True\n-\n-  if not found_snap:\n-    raise Exception(\"no snapshot entries in file\")\n-\n-  if not found_file:\n-    raise Exception(\"no snapshot file found for platform %s, rev %s\" %\n-                    (platform, rev))\n-\n-  return full_snapshot_name(date, rev, platform, hsh)\n+    i = 0\n+    platform = get_platform(triple)\n+\n+    found_file = False\n+    found_snap = False\n+    hsh = None\n+    date = None\n+    rev = None\n+\n+    f = open(snapshotfile)\n+    for line in f.readlines():\n+        i += 1\n+        parsed = parse_line(i, line)\n+        if not parsed:\n+            continue\n+\n+        if found_snap and parsed[\"type\"] == \"file\":\n+            if parsed[\"platform\"] == platform:\n+                hsh = parsed[\"hash\"]\n+                found_file = True\n+                break\n+        elif parsed[\"type\"] == \"snapshot\":\n+            date = parsed[\"date\"]\n+            rev = parsed[\"rev\"]\n+            found_snap = True\n+\n+    if not found_snap:\n+        raise Exception(\"no snapshot entries in file\")\n+\n+    if not found_file:\n+        raise Exception(\"no snapshot file found for platform %s, rev %s\" %\n+                        (platform, rev))\n+\n+    return full_snapshot_name(date, rev, platform, hsh)"}, {"sha": "62870f3ed4787c722e6f0d1f565222079cdbcc19", "filename": "src/etc/sugarise-doc-comments.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,7 +17,10 @@\n # it sugarises all .rs/.rc files underneath the working directory\n #\n \n-import sys, os, fnmatch, re\n+import sys\n+import os\n+import fnmatch\n+import re\n \n \n DOC_PATTERN = '^(?P<indent>[\\\\t ]*)#\\\\[(\\\\s*)doc(\\\\s*)=' + \\\n@@ -85,7 +88,6 @@ def sugarise_file(path):\n     if s != ns:\n         open(path, 'w').write(ns)\n \n-\n for (dirpath, dirnames, filenames) in os.walk('.'):\n     for name in fnmatch.filter(filenames, '*.r[sc]'):\n         sugarise_file(os.path.join(dirpath, name))"}, {"sha": "f5172feb5b60f1cb288973ae9459597cebaeea02", "filename": "src/etc/tidy.py", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,37 +8,45 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-import sys, fileinput, subprocess, re, os\n+import sys\n+import fileinput\n+import subprocess\n+import re\n+import os\n from licenseck import *\n import snapshot\n \n-err=0\n-cols=100\n-cr_flag=\"ignore-tidy-cr\"\n-tab_flag=\"ignore-tidy-tab\"\n-linelength_flag=\"ignore-tidy-linelength\"\n+err = 0\n+cols = 100\n+cr_flag = \"ignore-tidy-cr\"\n+tab_flag = \"ignore-tidy-tab\"\n+linelength_flag = \"ignore-tidy-linelength\"\n \n # Be careful to support Python 2.4, 2.6, and 3.x here!\n-config_proc=subprocess.Popen([ \"git\", \"config\", \"core.autocrlf\" ],\n-                             stdout=subprocess.PIPE)\n-result=config_proc.communicate()[0]\n+config_proc = subprocess.Popen([\"git\", \"config\", \"core.autocrlf\"],\n+                               stdout=subprocess.PIPE)\n+result = config_proc.communicate()[0]\n+\n+true = \"true\".encode('utf8')\n+autocrlf = result.strip() == true if result is not None else False\n \n-true=\"true\".encode('utf8')\n-autocrlf=result.strip() == true if result is not None else False\n \n def report_error_name_no(name, no, s):\n     global err\n     print(\"%s:%d: %s\" % (name, no, s))\n-    err=1\n+    err = 1\n+\n \n def report_err(s):\n     report_error_name_no(fileinput.filename(), fileinput.filelineno(), s)\n \n+\n def report_warn(s):\n     print(\"%s:%d: %s\" % (fileinput.filename(),\n                          fileinput.filelineno(),\n                          s))\n \n+\n def do_license_check(name, contents):\n     if not check_license(name, contents):\n         report_error_name_no(name, 1, \"incorrect license\")\n@@ -81,13 +89,13 @@ def do_license_check(name, contents):\n                 date, rev = snapshot.curr_snapshot_rev()\n                 if not hsh.startswith(rev):\n                     report_err(\"snapshot out of date (\" + date\n-                      + \"): \" + line)\n+                               + \"): \" + line)\n             else:\n                 if \"SNAP\" in line:\n                     report_warn(\"unmatched SNAP line: \" + line)\n \n         if check_tab and ('\\t' in line and\n-            \"Makefile\" not in fileinput.filename()):\n+                          \"Makefile\" not in fileinput.filename()):\n             report_err(\"tab character\")\n         if check_cr and not autocrlf and '\\r' in line:\n             report_err(\"CR character\")"}, {"sha": "4952b99ab464ef4e872b57f7602c5fbd0d60f365", "filename": "src/etc/unicode.py", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -392,15 +392,13 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n     use core::slice;\n \n     #[allow(non_camel_case_types)]\n-    #[derive(Clone)]\n+    #[derive(Clone, Copy)]\n     pub enum GraphemeCat {\n \"\"\")\n     for cat in grapheme_cats + [\"Any\"]:\n         f.write(\"        GC_\" + cat + \",\\n\")\n     f.write(\"\"\"    }\n \n-    impl Copy for GraphemeCat {}\n-\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n         match r.binary_search(|&(lo, hi, _)| {"}, {"sha": "5d196086168df91b84be9fa2de07ad878f5ea804", "filename": "src/etc/vim/syntax_checkers/rust/rustc.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,7 +14,7 @@ let s:save_cpo = &cpo\n set cpo&vim\n \n function! SyntaxCheckers_rust_rustc_GetLocList() dict\n-    let makeprg = self.makeprgBuild({ 'args': '--parse-only' })\n+    let makeprg = self.makeprgBuild({ 'args': '-Zparse-only' })\n \n     let errorformat  =\n         \\ '%E%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}error:%.%\\{-} %m,'   ."}, {"sha": "b3bf55be46b6a8327a4817b74448cb3258b444b5", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 105, "deletions": 4, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -179,7 +179,7 @@ pub trait SliceExt {\n     /// Deprecated: use `&s[start..]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] isntead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Deprecated: use `&s[..end]` notation instead.\n@@ -195,22 +195,55 @@ pub trait SliceExt {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 50];\n+    /// let (v1, v2) = v.split_at(2);\n+    /// assert_eq!([10, 40], v1);\n+    /// assert_eq!([30, 20, 50], v2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n-    /// Returns an iterator over the slice\n+    /// Returns an iterator over the slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20]`, `[50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.split(|num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20, 60, 50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.splitn(1, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n@@ -219,6 +252,18 @@ pub trait SliceExt {\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once, starting from the end, by numbers divisible\n+    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.rsplitn(1, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n@@ -270,10 +315,28 @@ pub trait SliceExt {\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&40), v.get(1));\n+    /// assert_eq!(None, v.get(3));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&10), v.first());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.first());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n@@ -286,6 +349,16 @@ pub trait SliceExt {\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&30), v.last());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.last());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n \n@@ -676,15 +749,43 @@ pub trait SliceExt {\n     #[unstable(feature = \"collections\")]\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n-    /// Return true if the slice contains an element with the given value.\n+    /// Returns true if the slice contains an element with the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.contains(&30));\n+    /// assert!(!v.contains(&50));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a prefix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.starts_with(&[10]));\n+    /// assert!(v.starts_with(&[10, 40]));\n+    /// assert!(!v.starts_with(&[50]));\n+    /// assert!(!v.starts_with(&[10, 50]));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a suffix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.ends_with(&[30]));\n+    /// assert!(v.ends_with(&[40, 30]));\n+    /// assert!(!v.ends_with(&[50]));\n+    /// assert!(!v.ends_with(&[50, 30]));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n "}, {"sha": "367ab28e47bdca52340e7f0b5f4e605cf34c2940", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -993,6 +993,43 @@ impl<T> Vec<T> {\n             result\n         }\n     }\n+\n+    /// Splits the collection into two at the given index.\n+    ///\n+    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n+    /// and the returned `Self` contains elements `[at, len)`.\n+    ///\n+    /// Note that the capacity of `self` does not change.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let mut vec = vec![1,2,3];\n+    /// let vec2 = vec.split_off(1);\n+    /// assert_eq!(vec, vec![1]);\n+    /// assert_eq!(vec2, vec![2, 3]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"collections\",\n+               reason = \"new API, waiting for dust to settle\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        assert!(at < self.len(), \"`at` out of bounds\");\n+\n+        let other_len = self.len - at;\n+        let mut other = Vec::with_capacity(other_len);\n+\n+        // Unsafely `set_len` and copy items to `other`.\n+        unsafe {\n+            self.set_len(at);\n+            other.set_len(other_len);\n+\n+            ptr::copy_nonoverlapping_memory(\n+                other.as_mut_ptr(),\n+                self.as_ptr().offset(at as isize),\n+                other.len());\n+        }\n+        other\n+    }\n+\n }\n \n impl<T: Clone> Vec<T> {\n@@ -1966,7 +2003,7 @@ mod tests {\n     fn test_slice_from_mut() {\n         let mut values = vec![1u8,2,3,4,5];\n         {\n-            let slice = values.slice_from_mut(2);\n+            let slice = &mut values[2 ..];\n             assert!(slice == [3, 4, 5]);\n             for p in slice.iter_mut() {\n                 *p += 2;\n@@ -1980,7 +2017,7 @@ mod tests {\n     fn test_slice_to_mut() {\n         let mut values = vec![1u8,2,3,4,5];\n         {\n-            let slice = values.slice_to_mut(2);\n+            let slice = &mut values[.. 2];\n             assert!(slice == [1, 2]);\n             for p in slice.iter_mut() {\n                 *p += 1;\n@@ -2354,6 +2391,14 @@ mod tests {\n         assert_eq!(vec2, vec![]);\n     }\n \n+    #[test]\n+    fn test_split_off() {\n+        let mut vec = vec![1, 2, 3, 4, 5, 6];\n+        let vec2 = vec.split_off(4);\n+        assert_eq!(vec, vec![1, 2, 3, 4]);\n+        assert_eq!(vec2, vec![5, 6]);\n+    }\n+\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "495c7c2bc2e3a982f6d52a8073d432eb879e9fd1", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -31,7 +31,7 @@ unsafe impl Zeroable for u64 {}\n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show)]\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show, Hash)]\n #[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n "}, {"sha": "bbb964508b4da30b2277f1f6d5bb5976806c1c24", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -449,10 +449,9 @@ rem_float_impl! { f64, fmod }\n /// ```\n /// use std::ops::Neg;\n ///\n+/// #[derive(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Neg for Foo {\n ///     type Output = Foo;\n ///\n@@ -526,10 +525,9 @@ neg_uint_impl! { u64, i64 }\n /// ```\n /// use std::ops::Not;\n ///\n+/// #[derive(Copy)]\n /// struct Foo;\n ///\n-/// impl Copy for Foo {}\n-///\n /// impl Not for Foo {\n ///     type Output = Foo;\n ///\n@@ -899,6 +897,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"index\"]\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Index}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n@@ -937,6 +936,7 @@ pub trait Index<Index: ?Sized> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Index}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;"}, {"sha": "aca4d265bc963d12ec40d18a2c072c9fd9efac9f", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -37,6 +37,8 @@ impl OptimizationDiagnosticKind {\n     }\n }\n \n+#[allow(raw_pointer_derive)]\n+#[derive(Copy)]\n pub struct OptimizationDiagnostic {\n     pub kind: OptimizationDiagnosticKind,\n     pub pass_name: *const c_char,\n@@ -45,8 +47,6 @@ pub struct OptimizationDiagnostic {\n     pub message: TwineRef,\n }\n \n-impl Copy for OptimizationDiagnostic {}\n-\n impl OptimizationDiagnostic {\n     unsafe fn unpack(kind: OptimizationDiagnosticKind, di: DiagnosticInfoRef)\n             -> OptimizationDiagnostic {"}, {"sha": "46faa3efc34a238aabe39a8212a1d143a3e50160", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -64,7 +64,6 @@\n \n body {\n     color: #333;\n-    min-width: 500px;\n     font: 16px/1.4 \"Source Serif Pro\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n     margin: 0;\n     position: relative;\n@@ -592,6 +591,14 @@ pre.rust { position: relative; }\n         margin-left: 0px;\n     }\n \n+    .content .in-band {\n+        width: 100%;\n+    }\n+\n+    .content .out-of-band {\n+        display: none;\n+    }\n+\n     .toggle-wrapper > .collapse-toggle {\n         left: 0px;\n     }"}, {"sha": "979a61d20d5c7018d38590d89bcf72f16a87a522", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -815,6 +815,8 @@ pub struct MemoryMap {\n }\n \n /// Type of memory map\n+#[allow(raw_pointer_derive)]\n+#[derive(Copy)]\n pub enum MemoryMapKind {\n     /// Virtual memory map. Usually used to change the permissions of a given\n     /// chunk of memory.  Corresponds to `VirtualAlloc` on Windows.\n@@ -825,9 +827,9 @@ pub enum MemoryMapKind {\n     MapVirtual\n }\n \n-impl Copy for MemoryMapKind {}\n-\n /// Options the memory map is created with\n+#[allow(raw_pointer_derive)]\n+#[derive(Copy)]\n pub enum MapOption {\n     /// The memory should be readable\n     MapReadable,\n@@ -854,8 +856,6 @@ pub enum MapOption {\n     MapNonStandardFlags(c_int),\n }\n \n-impl Copy for MapOption {}\n-\n /// Possible errors when creating a map.\n #[derive(Copy, Show)]\n pub enum MapError {"}, {"sha": "0a6dc386edf25d816e8d003399b5c2dc75e414fc", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -99,10 +99,10 @@\n //!    let between = Range::new(-1f64, 1.);\n //!    let mut rng = rand::thread_rng();\n //!\n-//!    let total = 1_000_000u;\n-//!    let mut in_circle = 0u;\n+//!    let total = 1_000_000;\n+//!    let mut in_circle = 0;\n //!\n-//!    for _ in range(0u, total) {\n+//!    for _ in range(0, total) {\n //!        let a = between.ind_sample(&mut rng);\n //!        let b = between.ind_sample(&mut rng);\n //!        if a*a + b*b <= 1. {\n@@ -176,18 +176,18 @@\n //! }\n //!\n //! fn free_doors(blocked: &[uint]) -> Vec<uint> {\n-//!     range(0u, 3).filter(|x| !blocked.contains(x)).collect()\n+//!     range(0, 3).filter(|x| !blocked.contains(x)).collect()\n //! }\n //!\n //! fn main() {\n //!     // The estimation will be more accurate with more simulations\n-//!     let num_simulations = 10000u;\n+//!     let num_simulations = 10000;\n //!\n //!     let mut rng = rand::thread_rng();\n-//!     let random_door = Range::new(0u, 3);\n+//!     let random_door = Range::new(0, 3);\n //!\n-//!     let (mut switch_wins, mut switch_losses) = (0u, 0u);\n-//!     let (mut keep_wins, mut keep_losses) = (0u, 0u);\n+//!     let (mut switch_wins, mut switch_losses) = (0, 0);\n+//!     let (mut keep_wins, mut keep_losses) = (0, 0);\n //!\n //!     println!(\"Running {} simulations...\", num_simulations);\n //!     for _ in range(0, num_simulations) {\n@@ -279,14 +279,14 @@ impl Rng for StdRng {\n     }\n }\n \n-impl<'a> SeedableRng<&'a [uint]> for StdRng {\n-    fn reseed(&mut self, seed: &'a [uint]) {\n+impl<'a> SeedableRng<&'a [usize]> for StdRng {\n+    fn reseed(&mut self, seed: &'a [usize]) {\n         // the internal RNG can just be seeded from the above\n         // randomness.\n         self.rng.reseed(unsafe {mem::transmute(seed)})\n     }\n \n-    fn from_seed(seed: &'a [uint]) -> StdRng {\n+    fn from_seed(seed: &'a [usize]) -> StdRng {\n         StdRng { rng: SeedableRng::from_seed(unsafe {mem::transmute(seed)}) }\n     }\n }\n@@ -318,7 +318,7 @@ impl reseeding::Reseeder<StdRng> for ThreadRngReseeder {\n         }\n     }\n }\n-static THREAD_RNG_RESEED_THRESHOLD: uint = 32_768;\n+static THREAD_RNG_RESEED_THRESHOLD: usize = 32_768;\n type ThreadRngInner = reseeding::ReseedingRng<StdRng, ThreadRngReseeder>;\n \n /// The thread-local RNG.\n@@ -384,7 +384,7 @@ impl Rng for ThreadRng {\n /// use std::rand;\n ///\n /// let x = rand::random();\n-/// println!(\"{}\", 2u * x);\n+/// println!(\"{}\", 2u8 * x);\n ///\n /// let y = rand::random::<f64>();\n /// println!(\"{}\", y);\n@@ -432,7 +432,7 @@ pub fn random<T: Rand>() -> T {\n /// ```\n pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,\n                                          mut iter: I,\n-                                         amount: uint) -> Vec<T> {\n+                                         amount: usize) -> Vec<T> {\n     let mut reservoir: Vec<T> = iter.by_ref().take(amount).collect();\n     for (i, elem) in iter.enumerate() {\n         let k = rng.gen_range(0, i + 1 + amount);\n@@ -480,18 +480,18 @@ mod test {\n     #[test]\n     fn test_gen_range() {\n         let mut r = thread_rng();\n-        for _ in range(0u, 1000) {\n+        for _ in range(0, 1000) {\n             let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n             assert_eq!(r.gen_range(0i, 1), 0);\n             assert_eq!(r.gen_range(-12i, -11), -12);\n         }\n \n-        for _ in range(0u, 1000) {\n+        for _ in range(0, 1000) {\n             let a = r.gen_range(10i, 42);\n             assert!(a >= 10 && a < 42);\n             assert_eq!(r.gen_range(0i, 1), 0);\n-            assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n+            assert_eq!(r.gen_range(3_000_000, 3_000_001), 3_000_000);\n         }\n \n     }\n@@ -507,7 +507,7 @@ mod test {\n     #[should_fail]\n     fn test_gen_range_panic_uint() {\n         let mut r = thread_rng();\n-        r.gen_range(5u, 2u);\n+        r.gen_range(5us, 2us);\n     }\n \n     #[test]\n@@ -521,24 +521,24 @@ mod test {\n     #[test]\n     fn test_gen_weighted_bool() {\n         let mut r = thread_rng();\n-        assert_eq!(r.gen_weighted_bool(0u), true);\n-        assert_eq!(r.gen_weighted_bool(1u), true);\n+        assert_eq!(r.gen_weighted_bool(0), true);\n+        assert_eq!(r.gen_weighted_bool(1), true);\n     }\n \n     #[test]\n     fn test_gen_ascii_str() {\n         let mut r = thread_rng();\n-        assert_eq!(r.gen_ascii_chars().take(0).count(), 0u);\n-        assert_eq!(r.gen_ascii_chars().take(10).count(), 10u);\n-        assert_eq!(r.gen_ascii_chars().take(16).count(), 16u);\n+        assert_eq!(r.gen_ascii_chars().take(0).count(), 0);\n+        assert_eq!(r.gen_ascii_chars().take(10).count(), 10);\n+        assert_eq!(r.gen_ascii_chars().take(16).count(), 16);\n     }\n \n     #[test]\n     fn test_gen_vec() {\n         let mut r = thread_rng();\n-        assert_eq!(r.gen_iter::<u8>().take(0).count(), 0u);\n-        assert_eq!(r.gen_iter::<u8>().take(10).count(), 10u);\n-        assert_eq!(r.gen_iter::<f64>().take(16).count(), 16u);\n+        assert_eq!(r.gen_iter::<u8>().take(0).count(), 0);\n+        assert_eq!(r.gen_iter::<u8>().take(10).count(), 10);\n+        assert_eq!(r.gen_iter::<f64>().take(16).count(), 16);\n     }\n \n     #[test]\n@@ -578,7 +578,7 @@ mod test {\n         r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n         assert_eq!(v, b);\n-        assert_eq!(r.gen_range(0u, 1u), 0u);\n+        assert_eq!(r.gen_range(0, 1), 0);\n     }\n \n     #[test]"}, {"sha": "fb8fd0b50782c449b3f714d2f1441049415f346c", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -49,7 +49,7 @@ mod imp {\n         const NR_GETRANDOM: libc::c_long = 384;\n \n         unsafe {\n-            syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), 0u)\n+            syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), 0)\n         }\n     }\n \n@@ -74,7 +74,7 @@ mod imp {\n                     panic!(\"unexpected getrandom error: {}\", err);\n                 }\n             } else {\n-                read += result as uint;\n+                read += result as usize;\n             }\n         }\n     }\n@@ -378,7 +378,7 @@ mod test {\n     fn test_os_rng_tasks() {\n \n         let mut txs = vec!();\n-        for _ in range(0u, 20) {\n+        for _ in range(0, 20) {\n             let (tx, rx) = channel();\n             txs.push(tx);\n \n@@ -392,7 +392,7 @@ mod test {\n                 Thread::yield_now();\n                 let mut v = [0u8; 1000];\n \n-                for _ in range(0u, 100) {\n+                for _ in range(0, 100) {\n                     r.next_u32();\n                     Thread::yield_now();\n                     r.next_u64();"}, {"sha": "02f738c9d29e1c2e50437e2d7252c31b2541e8e0", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -83,4 +83,5 @@ mod std {\n     pub use core::clone;\n     pub use core::cmp;\n     pub use core::fmt;\n+    pub use core::marker;\n }"}, {"sha": "a38f911688d75c8940d069826c37b686a09171d8", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -7801,13 +7801,12 @@ pub mod charwidth {\n }\n \n pub mod grapheme {\n-    use core::marker::Copy;\n     use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n     use core::result::Result::{Ok, Err};\n \n     #[allow(non_camel_case_types)]\n-    #[derive(Clone)]\n+    #[derive(Clone, Copy)]\n     pub enum GraphemeCat {\n         GC_LV,\n         GC_LVT,\n@@ -7821,8 +7820,6 @@ pub mod grapheme {\n         GC_Any,\n     }\n \n-    impl Copy for GraphemeCat {}\n-\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n         match r.binary_search_by(|&(lo, hi, _)| {"}, {"sha": "b4bafe31ff24a4c702b9e07c00b8f4086eed02e8", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -410,16 +410,14 @@ pub struct Utf16Items<'a> {\n     iter: slice::Iter<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[derive(PartialEq, Eq, Clone, Show)]\n+#[derive(Copy, PartialEq, Eq, Clone, Show)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n     ScalarValue(char),\n     /// An invalid surrogate without its pair.\n     LoneSurrogate(u16)\n }\n \n-impl Copy for Utf16Item {}\n-\n impl Utf16Item {\n     /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n     /// replacement character (U+FFFD)."}, {"sha": "3e23698397b4f5da4dd31ceac6ce53141537cc01", "filename": "src/test/auxiliary/issue-14422.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fissue-14422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fissue-14422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14422.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -23,10 +23,9 @@ mod src {\n     pub mod hidden_core {\n         use super::aliases::B;\n \n+        #[derive(Copy)]\n         pub struct A;\n \n-        impl Copy for A {}\n-\n         pub fn make() -> B { A }\n \n         impl A {"}, {"sha": "227fab73048d76a1ec4d278568d155dc7729e014", "filename": "src/test/auxiliary/issue13213aux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,19 +13,18 @@\n \n pub use private::P;\n \n+#[derive(Copy)]\n pub struct S {\n     p: P,\n }\n \n mod private {\n+    #[derive(Copy)]\n     pub struct P {\n         p: i32,\n     }\n     pub const THREE: P = P { p: 3 };\n-    impl Copy for P {}\n }\n \n pub static A: S = S { p: private::THREE };\n \n-impl Copy for S {}\n-"}, {"sha": "643442363a4463e6ac8e2c5701dedc77bbdf4c94", "filename": "src/test/auxiliary/method_self_arg1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fmethod_self_arg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fmethod_self_arg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmethod_self_arg1.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,10 +17,9 @@ static mut COUNT: u64 = 1;\n \n pub fn get_count() -> u64 { unsafe { COUNT } }\n \n+#[derive(Copy)]\n pub struct Foo;\n \n-impl Copy for Foo {}\n-\n impl Foo {\n     pub fn foo(self, x: &Foo) {\n         unsafe { COUNT *= 2; }"}, {"sha": "fd99da87e6b0d1f1e00f67425ba66fe22a9805a5", "filename": "src/test/auxiliary/method_self_arg2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,10 +17,9 @@ static mut COUNT: u64 = 1;\n \n pub fn get_count() -> u64 { unsafe { COUNT } }\n \n+#[derive(Copy)]\n pub struct Foo;\n \n-impl Copy for Foo {}\n-\n impl Foo {\n     pub fn run_trait(self) {\n         unsafe { COUNT *= 17; }"}, {"sha": "7ae36554079166397c4a4ca73de7748384240fed", "filename": "src/test/auxiliary/xcrate_unit_struct.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -12,33 +12,28 @@\n \n // used by the rpass test\n \n+#[derive(Copy)]\n pub struct Struct;\n \n-impl Copy for Struct {}\n-\n+#[derive(Copy)]\n pub enum Unit {\n     UnitVariant,\n     Argument(Struct)\n }\n \n-impl Copy for Unit {}\n-\n+#[derive(Copy)]\n pub struct TupleStruct(pub uint, pub &'static str);\n \n-impl Copy for TupleStruct {}\n-\n // used by the cfail test\n \n+#[derive(Copy)]\n pub struct StructWithFields {\n     foo: int,\n }\n \n-impl Copy for StructWithFields {}\n-\n+#[derive(Copy)]\n pub enum EnumWithVariants {\n     EnumVariant,\n     EnumVariantArg(int)\n }\n \n-impl Copy for EnumWithVariants {}\n-"}, {"sha": "75edd64fb2e7844915ed663928b4ddc521288f48", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -16,13 +16,12 @@ use std::f32::consts::PI;\n use std::num::Float;\n use std::rand::{Rng, StdRng};\n \n+#[derive(Copy)]\n struct Vec2 {\n     x: f32,\n     y: f32,\n }\n \n-impl Copy for Vec2 {}\n-\n fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n \n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }"}, {"sha": "12dc224a82f5e53af0d8de98872f33d27a343066", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -54,14 +54,13 @@ fn print_complements() {\n     }\n }\n \n+#[derive(Copy)]\n enum Color {\n     Red,\n     Yellow,\n     Blue,\n }\n \n-impl Copy for Color {}\n-\n impl fmt::Show for Color {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let str = match *self {\n@@ -73,13 +72,12 @@ impl fmt::Show for Color {\n     }\n }\n \n+#[derive(Copy)]\n struct CreatureInfo {\n     name: uint,\n     color: Color\n }\n \n-impl Copy for CreatureInfo {}\n-\n fn show_color_list(set: Vec<Color>) -> String {\n     let mut out = String::new();\n     for col in set.iter() {"}, {"sha": "42b41d955fbabfa50df91bcd66bd60e0003d0308", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -61,12 +61,12 @@ fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     }\n }\n \n+#[derive(Copy)]\n struct P {\n     p: [i32; 16],\n }\n \n-impl Copy for P {}\n-\n+#[derive(Copy)]\n struct Perm {\n     cnt: [i32; 16],\n     fact: [u32; 16],\n@@ -75,8 +75,6 @@ struct Perm {\n     perm: P,\n }\n \n-impl Copy for Perm {}\n-\n impl Perm {\n     fn new(n: u32) -> Perm {\n         let mut fact = [1; 16];"}, {"sha": "37e64aca32437269bf6d2bc082453c7313970111", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -103,13 +103,12 @@ fn sum_and_scale(a: &'static [AminoAcid]) -> Vec<AminoAcid> {\n     result\n }\n \n+#[derive(Copy)]\n struct AminoAcid {\n     c: u8,\n     p: f32,\n }\n \n-impl Copy for AminoAcid {}\n-\n struct RepeatFasta<'a, W:'a> {\n     alu: &'static str,\n     out: &'a mut W"}, {"sha": "1bfd6a6301acfe1e35fa70ade6019283eb415e99", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -60,11 +60,9 @@ static OCCURRENCES: [&'static str;5] = [\n \n // Code implementation\n \n-#[derive(PartialEq, PartialOrd, Ord, Eq)]\n+#[derive(Copy, PartialEq, PartialOrd, Ord, Eq)]\n struct Code(u64);\n \n-impl Copy for Code {}\n-\n impl Code {\n     fn hash(&self) -> u64 {\n         let Code(ret) = *self;"}, {"sha": "1b3d66ca7d23d256e349861ad479f425f6f76e73", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -94,14 +94,13 @@ static BODIES: [Planet;N_BODIES] = [\n     },\n ];\n \n+#[derive(Copy)]\n struct Planet {\n     x: f64, y: f64, z: f64,\n     vx: f64, vy: f64, vz: f64,\n     mass: f64,\n }\n \n-impl Copy for Planet {}\n-\n fn advance(bodies: &mut [Planet;N_BODIES], dt: f64, steps: int) {\n     for _ in range(0, steps) {\n         let mut b_slice = bodies.as_mut_slice();"}, {"sha": "e3b51cb6b5bfd2405967e3c8f983021bf9b75db5", "filename": "src/test/bench/task-perf-one-million.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45e117733b866302fa99390553d1c548508dcca/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=a45e117733b866302fa99390553d1c548508dcca", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test for concurrent tasks\n-\n-// ignore-test OOM on linux-32 without opts\n-\n-use std::os;\n-use std::task;\n-use std::uint;\n-use std::slice;\n-\n-fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n-\n-    let wait_ports: Vec<Reciever<Sender<Sender<int>>>> = vec::from_fn(children, |_| {\n-        let (wait_port, wait_chan) = stream::<Sender<Sender<int>>>();\n-        task::spawn(move|| {\n-            calc(children / 2, &wait_chan);\n-        });\n-        wait_port\n-    });\n-\n-    let child_start_chans: Vec<Sender<Sender<int>>> =\n-        wait_ports.into_iter().map(|port| port.recv()).collect();\n-\n-    let (start_port, start_chan) = stream::<Sender<int>>();\n-    parent_wait_chan.send(start_chan);\n-    let parent_result_chan: Sender<int> = start_port.recv();\n-\n-    let child_sum_ports: Vec<Reciever<int>> =\n-        child_start_chans.into_iter().map(|child_start_chan| {\n-            let (child_sum_port, child_sum_chan) = stream::<int>();\n-            child_start_chan.send(child_sum_chan);\n-            child_sum_port\n-    }).collect();\n-\n-    let sum = child_sum_ports.into_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n-\n-    parent_result_chan.send(sum + 1);\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"30\".to_string())\n-    } else if args.len() <= 1u {\n-        vec!(\"\".to_string(), \"10\".to_string())\n-    } else {\n-        args\n-    };\n-\n-    let children = from_str::<uint>(args[1]).unwrap();\n-    let (wait_port, wait_chan) = stream();\n-    task::spawn(move|| {\n-        calc(children, &wait_chan);\n-    });\n-\n-    let start_chan = wait_port.recv();\n-    let (sum_port, sum_chan) = stream::<int>();\n-    start_chan.send(sum_chan);\n-    let sum = sum_port.recv();\n-    println!(\"How many tasks? {} tasks.\", sum);\n-}"}, {"sha": "99618c6bf5626911d8629249df01a2a9c126e052", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -9,20 +9,18 @@\n // except according to those terms.\n \n \n+#[derive(Copy)]\n struct Foo {\n   bar1: Bar,\n   bar2: Bar\n }\n \n-impl Copy for Foo {}\n-\n+#[derive(Copy)]\n struct Bar {\n   int1: isize,\n   int2: isize,\n }\n \n-impl Copy for Bar {}\n-\n fn make_foo() -> Box<Foo> { panic!() }\n \n fn borrow_same_field_twice_mut_mut() {"}, {"sha": "849c98e122e526b2b78f7adbf25fe7f0a3eb4c09", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n struct Foo {\n   bar1: Bar,\n   bar2: Bar\n }\n \n-impl Copy for Foo {}\n-\n+#[derive(Copy)]\n struct Bar {\n   int1: isize,\n   int2: isize,\n }\n \n-impl Copy for Bar {}\n-\n fn make_foo() -> Foo { panic!() }\n \n fn borrow_same_field_twice_mut_mut() {"}, {"sha": "52f89da10b97726013a74d01d5a324fa4f2047b5", "filename": "src/test/compile-fail/borrowck-use-mut-borrow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,10 +10,9 @@\n \n #![feature(box_syntax)]\n \n+#[derive(Copy)]\n struct A { a: isize, b: isize }\n \n-impl Copy for A {}\n-\n struct B { a: isize, b: Box<isize> }\n \n fn var_copy_after_var_borrow() {"}, {"sha": "91f34320482561aca98a3a707e8405a976579c41", "filename": "src/test/compile-fail/dst-index.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,10 +14,9 @@\n use std::ops::Index;\n use std::fmt::Debug;\n \n+#[derive(Copy)]\n struct S;\n \n-impl Copy for S {}\n-\n impl Index<usize> for S {\n     type Output = str;\n \n@@ -26,10 +25,9 @@ impl Index<usize> for S {\n     }\n }\n \n+#[derive(Copy)]\n struct T;\n \n-impl Copy for T {}\n-\n impl Index<usize> for T {\n     type Output = Debug + 'static;\n "}, {"sha": "56f83d9300861b353d2a0dd61196e0eebf8ce847", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,13 +17,12 @@ fn assert_copy<T:Copy>() { }\n \n trait Dummy { }\n \n+#[derive(Copy)]\n struct MyStruct {\n     x: isize,\n     y: isize,\n }\n \n-impl Copy for MyStruct {}\n-\n struct MyNoncopyStruct {\n     x: Box<char>,\n }"}, {"sha": "d94baa637c2d0fd2739f2829d718189238a8150e", "filename": "src/test/debuginfo/generic-method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -115,6 +115,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct Struct<T> {\n     x: T\n }\n@@ -150,5 +151,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl<T:Copy> Copy for Struct<T> {}\n-"}, {"sha": "f891263697170be6f796fea96234c83979c6db3e", "filename": "src/test/debuginfo/method-on-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -116,6 +116,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n enum Enum {\n     Variant1 { x: u16, y: u16 },\n     Variant2 (u32)\n@@ -152,5 +153,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl Copy for Enum {}\n-"}, {"sha": "fa93eaba2793eea419688f33c1048de9ece70064", "filename": "src/test/debuginfo/method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -116,6 +116,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct Struct<T> {\n     x: T\n }\n@@ -151,5 +152,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl<T:Copy> Copy for Struct<T> {}\n-"}, {"sha": "56f79da709efd92c061afba2105cf0a2faa26dd8", "filename": "src/test/debuginfo/method-on-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -116,6 +116,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct Struct {\n     x: int\n }\n@@ -151,5 +152,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl Copy for Struct {}\n-"}, {"sha": "4fff301eb5f548a60315a55ed5832b1937c3892d", "filename": "src/test/debuginfo/method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -116,6 +116,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct Struct {\n     x: int\n }\n@@ -157,5 +158,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl Copy for Struct {}\n-"}, {"sha": "7c4ce211f2fe5edc676f2642ef689259761b4021", "filename": "src/test/debuginfo/method-on-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -116,6 +116,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct TupleStruct(int, f64);\n \n impl TupleStruct {\n@@ -149,5 +150,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl Copy for TupleStruct {}\n-"}, {"sha": "e494973b975bca54dd95fa0a1f94facbad2eea88", "filename": "src/test/debuginfo/self-in-default-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -115,6 +115,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct Struct {\n     x: int\n }\n@@ -151,5 +152,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl Copy for Struct {}\n-"}, {"sha": "0fe74015611f5914ec5a619307d4b0c41555611f", "filename": "src/test/debuginfo/self-in-generic-default-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -115,6 +115,7 @@\n #![feature(box_syntax)]\n #![omit_gdb_pretty_printer_section]\n \n+#[derive(Copy)]\n struct Struct {\n     x: int\n }\n@@ -152,5 +153,3 @@ fn main() {\n \n fn zzz() {()}\n \n-impl Copy for Struct {}\n-"}, {"sha": "1e286c236a5d92a2391b520fc97c560512d20cc1", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -19,10 +19,9 @@ fn test1() { let val = &0i; { } *val; }\n \n fn test2() -> int { let val = &0i; { } *val }\n \n+#[derive(Copy)]\n struct S { eax: int }\n \n-impl Copy for S {}\n-\n fn test3() {\n     let regs = &Cell::new(S {eax: 0});\n     match true { true => { } _ => { } }"}, {"sha": "3e3f4c5948e665095d291582c8d38e5f3befc331", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -9,15 +9,13 @@\n // except according to those terms.\n \n #[repr(packed)]\n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n struct Foo {\n     a: i8,\n     b: i16,\n     c: i8\n }\n \n-impl Copy for Foo {}\n-\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn foo(f: Foo) -> Foo;"}, {"sha": "d95594119b6bceb131d38aa6bb3a88be3f958607", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,12 +11,11 @@\n \n use std::cell::Cell;\n \n+#[derive(Copy)]\n enum newtype {\n     newvar(int)\n }\n \n-impl Copy for newtype {}\n-\n pub fn main() {\n \n     // Test that borrowck treats enums with a single variant"}, {"sha": "c115415bb9b7b1739d1d12b1bc4b493586a8d1f0", "filename": "src/test/run-pass/builtin-superkinds-in-metadata.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,10 +17,9 @@ extern crate trait_superkinds_in_metadata;\n use trait_superkinds_in_metadata::{RequiresRequiresShareAndSend, RequiresShare};\n use trait_superkinds_in_metadata::{RequiresCopy};\n \n+#[derive(Copy)]\n struct X<T>(T);\n \n-impl<T:Copy> Copy for X<T> {}\n-\n impl<T:Sync> RequiresShare for X<T> { }\n \n impl<T:Sync+Send> RequiresRequiresShareAndSend for X<T> { }"}, {"sha": "ea1d0b625fcd757eab2b37ecc478b7f0d32194f5", "filename": "src/test/run-pass/cell-does-not-clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fcell-does-not-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fcell-does-not-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcell-does-not-clone.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,6 +10,7 @@\n \n use std::cell::Cell;\n \n+#[derive(Copy)]\n struct Foo {\n     x: int\n }\n@@ -24,8 +25,6 @@ impl Clone for Foo {\n     }\n }\n \n-impl Copy for Foo {}\n-\n pub fn main() {\n     let x = Cell::new(Foo { x: 22 });\n     let _y = x.get();"}, {"sha": "993f27d061d20f9c000517591305e8a2940f4728", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,11 +11,9 @@\n \n use std::cmp;\n \n-#[derive(Show)]\n+#[derive(Copy, Show)]\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n-impl Copy for cat_type {}\n-\n impl cmp::PartialEq for cat_type {\n     fn eq(&self, other: &cat_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "6edd7390f0f31a37ad0cf088a3dec7ff0e2ec070", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n+    #[derive(Copy)]\n     enum x { foo }\n-    impl Copy for x {}\n     impl ::std::cmp::PartialEq for x {\n         fn eq(&self, other: &x) -> bool {\n             (*self) as int == (*other) as int"}, {"sha": "d9c292a3e0b6eaac017159b3f9bad5a55304d70c", "filename": "src/test/run-pass/coherence-where-clause.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fcoherence-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fcoherence-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-where-clause.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -23,13 +23,11 @@ impl<T> MyTrait for T\n     }\n }\n \n-#[derive(Clone,Debug,PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n struct MyType {\n     dummy: uint\n }\n \n-impl Copy for MyType {}\n-\n impl MyTrait for MyType {\n     fn get(&self) -> MyType { (*self).clone() }\n }"}, {"sha": "86b194f2eb3419b1f99e46aa291bf1142c91ef98", "filename": "src/test/run-pass/const-nullary-univariant-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fconst-nullary-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fconst-nullary-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-nullary-univariant-enum.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n enum Foo {\n     Bar = 0xDEADBEE\n }\n \n-impl Copy for Foo {}\n-\n static X: Foo = Foo::Bar;\n \n pub fn main() {"}, {"sha": "74f4b9e923301732b7786d14adae54d5601dd307", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -30,11 +30,9 @@ fn foo2<T:ToBar>(x: &Fat<[T]>) {\n     assert!(x.ptr[1].to_bar() == bar);\n }\n \n-#[derive(PartialEq,Eq)]\n+#[derive(Copy, PartialEq, Eq)]\n struct Bar;\n \n-impl Copy for Bar {}\n-\n trait ToBar {\n     fn to_bar(&self) -> Bar;\n }"}, {"sha": "fa2af29431c308262352bdd6bec362dd4077cb04", "filename": "src/test/run-pass/dst-struct.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -49,11 +49,9 @@ fn foo3(x: &Fat<Fat<[int]>>) {\n }\n \n \n-#[derive(PartialEq,Eq)]\n+#[derive(Copy, PartialEq, Eq)]\n struct Bar;\n \n-impl Copy for Bar {}\n-\n trait ToBar {\n     fn to_bar(&self) -> Bar;\n }"}, {"sha": "fd1c7247e375d501a9c637b0606c593fcbc9bb79", "filename": "src/test/run-pass/dst-trait.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,18 +17,14 @@ struct Fat<T: ?Sized> {\n     ptr: T\n }\n \n-#[derive(PartialEq,Eq)]\n+#[derive(Copy, PartialEq, Eq)]\n struct Bar;\n \n-impl Copy for Bar {}\n-\n-#[derive(PartialEq,Eq)]\n+#[derive(Copy, PartialEq, Eq)]\n struct Bar1 {\n     f: int\n }\n \n-impl Copy for Bar1 {}\n-\n trait ToBar {\n     fn to_bar(&self) -> Bar;\n     fn to_val(&self) -> int;"}, {"sha": "35c394cf535a579d538372e801a58758f6d1b789", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)]\n+#[derive(Copy, Show)]\n enum chan { chan_t, }\n \n-impl Copy for chan {}\n-\n impl PartialEq for chan {\n     fn eq(&self, other: &chan) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "c323bff254d234c8f37716cd25dd1ea265b9f4a8", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -12,13 +12,12 @@ macro_rules! check {\n     ($m:ident, $t:ty, $v:expr) => {{\n         mod $m {\n             use std::mem::size_of;\n-            #[derive(Show)]\n+            #[derive(Copy, Show)]\n             enum E {\n                 V = $v,\n                 A = 0\n             }\n             static C: E = E::V;\n-            impl Copy for E {}\n             pub fn check() {\n                 assert_eq!(size_of::<E>(), size_of::<$t>());\n                 assert_eq!(E::V as $t, $v as $t);"}, {"sha": "066a5f9580ac42756f3c476b9dc9621df6321d61", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,10 +11,9 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n+#[derive(Copy)]\n struct LM { resize_at: uint, size: uint }\n \n-impl Copy for LM {}\n-\n enum HashMap<K,V> {\n     HashMap_(LM)\n }"}, {"sha": "807d28feb6e76742e0535a497574ed23f442bbf1", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,10 +13,9 @@\n \n mod foo {\n     // not exported\n+    #[derive(Copy)]\n     enum t { t1, t2, }\n \n-    impl Copy for t {}\n-\n     impl PartialEq for t {\n         fn eq(&self, other: &t) -> bool {\n             ((*self) as uint) == ((*other) as uint)"}, {"sha": "6c6c5085749bb9be42bad0c0a0583b2954891b10", "filename": "src/test/run-pass/expr-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-copy.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,10 +13,9 @@ fn f(arg: &mut A) {\n     arg.a = 100;\n }\n \n+#[derive(Copy)]\n struct A { a: int }\n \n-impl Copy for A {}\n-\n pub fn main() {\n     let mut x = A {a: 10};\n     f(&mut x);"}, {"sha": "f1457829d03ed2038eaea6dd0456cfcfb4f9c936", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,20 +14,17 @@\n \n // Tests for if as expressions returning nominal types\n \n+#[derive(Copy)]\n struct I { i: int }\n \n-impl Copy for I {}\n-\n fn test_rec() {\n     let rs = if true { I {i: 100} } else { I {i: 101} };\n     assert_eq!(rs.i, 100);\n }\n \n-#[derive(Show)]\n+#[derive(Copy, Show)]\n enum mood { happy, sad, }\n \n-impl Copy for mood {}\n-\n impl PartialEq for mood {\n     fn eq(&self, other: &mood) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "1b5a33dff3da0ada61007f50e2d2659ef4bc64cc", "filename": "src/test/run-pass/expr-match-struct.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,20 +13,17 @@\n \n \n // Tests for match as expressions resulting in struct types\n+#[derive(Copy)]\n struct R { i: int }\n \n-impl Copy for R {}\n-\n fn test_rec() {\n     let rs = match true { true => R {i: 100}, _ => panic!() };\n     assert_eq!(rs.i, 100);\n }\n \n-#[derive(Show)]\n+#[derive(Copy, Show)]\n enum mood { happy, sad, }\n \n-impl Copy for mood {}\n-\n impl PartialEq for mood {\n     fn eq(&self, other: &mood) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "bba8cbdb83dd67d7314cf07ba0a3ee4c84b3b8fd", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,10 +11,9 @@\n \n use std::cell::Cell;\n \n+#[derive(Copy)]\n struct Point {x: int, y: int, z: int}\n \n-impl Copy for Point {}\n-\n fn f(p: &Cell<Point>) {\n     assert!((p.get().z == 12));\n     p.set(Point {x: 10, y: 11, z: 13});"}, {"sha": "f7aef2e59c91ec1e435a328c6d3651584084f4a0", "filename": "src/test/run-pass/extern-pass-TwoU16s.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,13 +11,11 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n pub struct TwoU16s {\n     one: u16, two: u16\n }\n \n-impl Copy for TwoU16s {}\n-\n #[link(name = \"rust_test_helpers\")]\n extern {\n     pub fn rust_dbg_extern_identity_TwoU16s(v: TwoU16s) -> TwoU16s;"}, {"sha": "8e13017fdbf8a71dade3687ff13c9c74348b20c5", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,13 +11,11 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n pub struct TwoU32s {\n     one: u32, two: u32\n }\n \n-impl Copy for TwoU32s {}\n-\n #[link(name = \"rust_test_helpers\")]\n extern {\n     pub fn rust_dbg_extern_identity_TwoU32s(v: TwoU32s) -> TwoU32s;"}, {"sha": "b95eb7974b6de82d175e05295e9053744ad73f8a", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,13 +11,11 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n pub struct TwoU64s {\n     one: u64, two: u64\n }\n \n-impl Copy for TwoU64s {}\n-\n #[link(name = \"rust_test_helpers\")]\n extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(v: TwoU64s) -> TwoU64s;"}, {"sha": "d5c727be4bc7a3d9f0dcd60796a5aa725e1d44c9", "filename": "src/test/run-pass/extern-pass-TwoU8s.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,13 +11,11 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n pub struct TwoU8s {\n     one: u8, two: u8\n }\n \n-impl Copy for TwoU8s {}\n-\n #[link(name = \"rust_test_helpers\")]\n extern {\n     pub fn rust_dbg_extern_identity_TwoU8s(v: TwoU8s) -> TwoU8s;"}, {"sha": "09317abce921d9383e5f28668220a2a1a938e16d", "filename": "src/test/run-pass/foreign-fn-with-byval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n pub struct S {\n     x: u64,\n     y: u64,\n     z: u64,\n }\n \n-impl Copy for S {}\n-\n #[link(name = \"rust_test_helpers\")]\n extern {\n     pub fn get_x(x: S) -> u64;"}, {"sha": "8da8c6808478b799daef899eafaacb35802581a8", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -12,10 +12,9 @@\n \n fn id<T>(x: T) -> T { return x; }\n \n+#[derive(Copy)]\n struct Triple {x: int, y: int, z: int}\n \n-impl Copy for Triple {}\n-\n pub fn main() {\n     let mut x = 62;\n     let mut y = 63;"}, {"sha": "addd6a63836f3512b033ba144a715b620f42d5f3", "filename": "src/test/run-pass/guards-not-exhaustive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fguards-not-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fguards-not-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fguards-not-exhaustive.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n enum Q { R(Option<uint>) }\n \n-impl Copy for Q {}\n-\n fn xyzzy(q: Q) -> uint {\n     match q {\n         Q::R(S) if S.is_some() => { 0 }"}, {"sha": "e7031ae147e433a12373819fcb8697d016166484", "filename": "src/test/run-pass/guards.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fguards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fguards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fguards.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n struct Pair { x: int, y: int }\n \n-impl Copy for Pair {}\n-\n pub fn main() {\n     let a: int =\n         match 10i { x if x < 7 => { 1i } x if x < 11 => { 2i } 10 => { 3i } _ => { 4i } };"}, {"sha": "9c9f95f61e9be666c88d02f8bb38a03aa73ef416", "filename": "src/test/run-pass/hrtb-opt-in-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -29,10 +29,9 @@ enum TyS<'tcx> {\n     Boop(marker::InvariantLifetime<'tcx>)\n }\n \n+#[derive(Copy)]\n enum Bar<'tcx> {\n     Baz(Foo<Ty<'tcx>>)\n }\n \n-impl<'tcx> Copy for Bar<'tcx> { }\n-\n fn main() { }"}, {"sha": "a05cc9c0f74c241a16f0331650fb57b1f34e7e0d", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,15 +13,13 @@ extern crate collections;\n \n use std::collections::HashSet;\n \n-#[derive(PartialEq, Eq, Hash)]\n+#[derive(Copy, PartialEq, Eq, Hash)]\n struct XYZ {\n     x: int,\n     y: int,\n     z: int\n }\n \n-impl Copy for XYZ {}\n-\n fn main() {\n     let mut connected = HashSet::new();\n     let mut border = HashSet::new();"}, {"sha": "26eacd682efddbdbe958a471dfa1ea3b37da8a1b", "filename": "src/test/run-pass/issue-19100.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-19100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-19100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19100.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n enum Foo {\n     Bar,\n     Baz\n }\n \n-impl Copy for Foo {}\n-\n impl Foo {\n     fn foo(&self) {\n         match self {"}, {"sha": "18bb6fe55299d0a0c362b11ab04de38e554e24b6", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,12 +15,11 @@ trait clam<A> {\n   fn chowder(&self, y: A);\n }\n \n+#[derive(Copy)]\n struct foo<A> {\n   x: A,\n }\n \n-impl<A:Copy> Copy for foo<A> {}\n-\n impl<A> clam<A> for foo<A> {\n   fn chowder(&self, _y: A) {\n   }"}, {"sha": "de99141c80311381a47ca48841732d40c6e26142", "filename": "src/test/run-pass/issue-2633.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2633.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n struct cat {\n     meow: extern \"Rust\" fn(),\n }\n \n-impl Copy for cat {}\n-\n fn meow() {\n     println!(\"meow\")\n }\n@@ -24,10 +23,9 @@ fn cat() -> cat {\n     }\n }\n \n+#[derive(Copy)]\n struct KittyInfo {kitty: cat}\n \n-impl Copy for KittyInfo {}\n-\n // Code compiles and runs successfully if we add a + before the first arg\n fn nyan(kitty: cat, _kitty_info: KittyInfo) {\n     (kitty.meow)();"}, {"sha": "b6ed85e9e4a49b5e42ee049c3d4e3096033dba73", "filename": "src/test/run-pass/issue-3121.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3121.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,14 +11,13 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n+#[derive(Copy)]\n enum side { mayo, catsup, vinegar }\n+#[derive(Copy)]\n enum order { hamburger, fries(side), shake }\n+#[derive(Copy)]\n enum meal { to_go(order), for_here(order) }\n \n-impl Copy for side {}\n-impl Copy for order {}\n-impl Copy for meal {}\n-\n fn foo(m: Box<meal>, cond: bool) {\n     match *m {\n       meal::to_go(_) => { }"}, {"sha": "004bcf6dcd09c25bc6b7e51e35f18ce199974a99", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -27,29 +27,26 @@ use std::iter::repeat;\n use std::slice;\n \n // Represents a position on a canvas.\n+#[derive(Copy)]\n struct Point {\n     x: int,\n     y: int,\n }\n \n-impl Copy for Point {}\n-\n // Represents an offset on a canvas. (This has the same structure as a Point.\n // but different semantics).\n+#[derive(Copy)]\n struct Size {\n     width: int,\n     height: int,\n }\n \n-impl Copy for Size {}\n-\n+#[derive(Copy)]\n struct Rect {\n     top_left: Point,\n     size: Size,\n }\n \n-impl Copy for Rect {}\n-\n // Contains the information needed to do shape rendering via ASCII art.\n struct AsciiArt {\n     width: uint,"}, {"sha": "03699ff8d60369d7657c9ecad9b6ea00f0f9086f", "filename": "src/test/run-pass/issue-3743.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3743.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,13 +14,12 @@\n \n use std::ops::Mul;\n \n+#[derive(Copy)]\n struct Vec2 {\n     x: f64,\n     y: f64\n }\n \n-impl Copy for Vec2 {}\n-\n // methods we want to export as methods as well as operators\n impl Vec2 {\n #[inline(always)]"}, {"sha": "58d7aa276f15a6611ce5e1b4f34c65e60d8a6965", "filename": "src/test/run-pass/issue-3753.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3753.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,20 +14,18 @@\n \n use std::f64;\n \n+#[derive(Copy)]\n pub struct Point {\n     x: f64,\n     y: f64\n }\n \n-impl Copy for Point {}\n-\n+#[derive(Copy)]\n pub enum Shape {\n     Circle(Point, f64),\n     Rectangle(Point, Point)\n }\n \n-impl Copy for Shape {}\n-\n impl Shape {\n     pub fn area(&self, sh: Shape) -> f64 {\n         match sh {"}, {"sha": "a4f3988484661cb5274ca9643d20542f542f3d6e", "filename": "src/test/run-pass/issue-5688.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-5688.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fissue-5688.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5688.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,10 +17,9 @@ with the representation of [int; n] and [int] somehow, or at least\n failed to typecheck correctly.\n */\n \n+#[derive(Copy)]\n struct X { vec: &'static [int] }\n \n-impl Copy for X {}\n-\n static V: &'static [X] = &[X { vec: &[1, 2, 3] }];\n \n pub fn main() {"}, {"sha": "1964bf4bd7d7a9f1ff5c3ddc9ff031a96eeb8a1c", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -36,10 +36,9 @@ const VARIANT2_NORTH: EnumWithStructVariants = EnumWithStructVariants::Variant2\n     dir: Direction::North };\n \n pub mod glfw {\n+    #[derive(Copy)]\n     pub struct InputState(uint);\n \n-    impl Copy for InputState {}\n-\n     pub const RELEASE  : InputState = InputState(0);\n     pub const PRESS    : InputState = InputState(1);\n     pub const REPEAT   : InputState = InputState(2);"}, {"sha": "c79141d97950045a9b1f2e68e9bbe7ad44f6f67d", "filename": "src/test/run-pass/method-self-arg-trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmethod-self-arg-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmethod-self-arg-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-self-arg-trait.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,10 +15,9 @@\n \n static mut COUNT: u64 = 1;\n \n+#[derive(Copy)]\n struct Foo;\n \n-impl Copy for Foo {}\n-\n trait Bar : Sized {\n     fn foo1(&self);\n     fn foo2(self);"}, {"sha": "2225ccdc5169fdc2adf67d91bec5a8f443bb35f5", "filename": "src/test/run-pass/method-self-arg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmethod-self-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmethod-self-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-self-arg.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,10 +15,9 @@\n \n static mut COUNT: uint = 1;\n \n+#[derive(Copy)]\n struct Foo;\n \n-impl Copy for Foo {}\n-\n impl Foo {\n     fn foo(self, x: &Foo) {\n         unsafe { COUNT *= 2; }"}, {"sha": "8ec16419a22a04845d3795f32a92f2017cdfda5e", "filename": "src/test/run-pass/monomorphize-abi-alignment.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -18,26 +18,21 @@\n  * and apply the wrong instance of the method `unwrap`.\n  */\n \n+#[derive(Copy)]\n struct S<T> { i:u8, t:T }\n \n-impl<T:Copy> Copy for S<T> {}\n-\n impl<T> S<T> {\n     fn unwrap(self) -> T {\n         self.t\n     }\n }\n \n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n struct A((u32, u32));\n \n-impl Copy for A {}\n-\n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n struct B(u64);\n \n-impl Copy for B {}\n-\n pub fn main() {\n     static Ca: S<A> = S { i: 0, t: A((13, 104)) };\n     static Cb: S<B> = S { i: 0, t: B(31337) };"}, {"sha": "b9435afdc7a934b93d89eb4e4a6b14c86af87f1b", "filename": "src/test/run-pass/multidispatch1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmultidispatch1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmultidispatch1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultidispatch1.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -14,12 +14,11 @@ trait MyTrait<T> {\n     fn get(&self) -> T;\n }\n \n+#[derive(Copy)]\n struct MyType {\n     dummy: uint\n }\n \n-impl Copy for MyType {}\n-\n impl MyTrait<uint> for MyType {\n     fn get(&self) -> uint { self.dummy }\n }"}, {"sha": "ecacc7f1df98126b86c532f657a51938348cc6cb", "filename": "src/test/run-pass/multidispatch2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmultidispatch2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fmultidispatch2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultidispatch2.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -23,12 +23,11 @@ impl<T> MyTrait<T> for T\n     }\n }\n \n+#[derive(Copy)]\n struct MyType {\n     dummy: uint\n }\n \n-impl Copy for MyType {}\n-\n impl MyTrait<uint> for MyType {\n     fn get(&self) -> uint { self.dummy }\n }"}, {"sha": "869ae4a37d22a62b4e881ea58c71130f843ca881", "filename": "src/test/run-pass/newtype.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n struct mytype(Mytype);\n \n-impl Copy for mytype {}\n-\n+#[derive(Copy)]\n struct Mytype {\n     compute: fn(mytype) -> int,\n     val: int,\n }\n \n-impl Copy for Mytype {}\n-\n fn compute(i: mytype) -> int {\n     let mytype(m) = i;\n     return m.val + 20;"}, {"sha": "eee9838da21ee68a96ef021397c716d49a4efb2c", "filename": "src/test/run-pass/out-pointer-aliasing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fout-pointer-aliasing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fout-pointer-aliasing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-pointer-aliasing.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n pub struct Foo {\n     f1: int,\n     _f2: int,\n }\n \n-impl Copy for Foo {}\n-\n #[inline(never)]\n pub fn foo(f: &mut Foo) -> Foo {\n     let ret = *f;"}, {"sha": "4c48b0ba710971fff20f113268d20657842485bb", "filename": "src/test/run-pass/overloaded-autoderef-order.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-order.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,13 +11,12 @@\n use std::rc::Rc;\n use std::ops::Deref;\n \n+#[derive(Copy)]\n struct DerefWrapper<X, Y> {\n     x: X,\n     y: Y\n }\n \n-impl<X:Copy,Y:Copy> Copy for DerefWrapper<X,Y> {}\n-\n impl<X, Y> DerefWrapper<X, Y> {\n     fn get_x(self) -> X {\n         self.x\n@@ -35,13 +34,12 @@ impl<X, Y> Deref for DerefWrapper<X, Y> {\n mod priv_test {\n     use std::ops::Deref;\n \n+    #[derive(Copy)]\n     pub struct DerefWrapperHideX<X, Y> {\n         x: X,\n         pub y: Y\n     }\n \n-    impl<X:Copy,Y:Copy> Copy for DerefWrapperHideX<X,Y> {}\n-\n     impl<X, Y> DerefWrapperHideX<X, Y> {\n         pub fn new(x: X, y: Y) -> DerefWrapperHideX<X, Y> {\n             DerefWrapperHideX {"}, {"sha": "c2e7a56d2709ef925160807626e63436fc7ab19c", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,14 +13,12 @@\n use std::mem;\n \n #[repr(packed)]\n-#[derive(PartialEq, Show)]\n+#[derive(Copy, PartialEq, Show)]\n struct Foo {\n     bar: u8,\n     baz: u64\n }\n \n-impl Copy for Foo {}\n-\n pub fn main() {\n     let foos = [Foo { bar: 1, baz: 2 }; 10];\n "}, {"sha": "dab7d26cc820039db62ed98f70a80afa3d10f866", "filename": "src/test/run-pass/rec-tup.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Frec-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Frec-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-tup.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy)]\n struct Point {x: int, y: int}\n \n-impl Copy for Point {}\n-\n type rect = (Point, Point);\n \n fn fst(r: rect) -> Point { let (fst, _) = r; return fst; }"}, {"sha": "f59538c51a07802b1ed6e453bb935c599826b5e7", "filename": "src/test/run-pass/rec.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Frec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Frec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -8,13 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n-\n+#[derive(Copy)]\n struct Rect {x: int, y: int, w: int, h: int}\n \n-impl Copy for Rect {}\n-\n fn f(r: Rect, x: int, y: int, w: int, h: int) {\n     assert_eq!(r.x, x);\n     assert_eq!(r.y, y);"}, {"sha": "85402080f1170c228555f1bc0b4d1e338b44a395", "filename": "src/test/run-pass/regions-dependent-addr-of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -27,12 +27,11 @@ struct B {\n     v6: Option<C>\n }\n \n+#[derive(Copy)]\n struct C {\n     f: int\n }\n \n-impl Copy for C {}\n-\n fn get_v1(a: &A) -> &int {\n     // Region inferencer must deduce that &v < L2 < L1\n     let foo = &a.value; // L1"}, {"sha": "410415e57a0679be7fe84e6203a99e9722ff1696", "filename": "src/test/run-pass/regions-early-bound-used-in-bound-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,12 +15,11 @@ trait GetRef<'a> {\n     fn get(&self) -> &'a int;\n }\n \n+#[derive(Copy)]\n struct Box<'a> {\n     t: &'a int\n }\n \n-impl<'a> Copy for Box<'a> {}\n-\n impl<'a> GetRef<'a> for Box<'a> {\n     fn get(&self) -> &'a int {\n         self.t"}, {"sha": "e0d5e0a1c7811d929a0704455bb613bce2fbf138", "filename": "src/test/run-pass/regions-early-bound-used-in-type-param.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,12 +15,11 @@ trait Get<T> {\n     fn get(&self) -> T;\n }\n \n+#[derive(Copy)]\n struct Box<T> {\n     t: T\n }\n \n-impl<T:Copy> Copy for Box<T> {}\n-\n impl<T:Clone> Get<T> for Box<T> {\n     fn get(&self) -> T {\n         self.t.clone()"}, {"sha": "eec4ee1be94cfe2ccf6f4de1916c8308d3f510c7", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -27,14 +27,12 @@ use std::mem;\n \n type Type<'tcx> = &'tcx TypeStructure<'tcx>;\n \n-#[derive(Show)]\n+#[derive(Copy, Show)]\n enum TypeStructure<'tcx> {\n     TypeInt,\n     TypeFunction(Type<'tcx>, Type<'tcx>),\n }\n \n-impl<'tcx> Copy for TypeStructure<'tcx> {}\n-\n impl<'tcx> PartialEq for TypeStructure<'tcx> {\n     fn eq(&self, other: &TypeStructure<'tcx>) -> bool {\n         match (*self, *other) {\n@@ -91,30 +89,26 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash)]\n+#[derive(Copy, PartialEq, Eq, Hash)]\n struct NodeId {\n     id: uint\n }\n \n-impl Copy for NodeId {}\n-\n type Ast<'ast> = &'ast AstStructure<'ast>;\n \n+#[derive(Copy)]\n struct AstStructure<'ast> {\n     id: NodeId,\n     kind: AstKind<'ast>\n }\n \n-impl<'ast> Copy for AstStructure<'ast> {}\n-\n+#[derive(Copy)]\n enum AstKind<'ast> {\n     ExprInt,\n     ExprVar(uint),\n     ExprLambda(Ast<'ast>),\n }\n \n-impl<'ast> Copy for AstKind<'ast> {}\n-\n fn compute_types<'tcx,'ast>(tcx: &mut TypeContext<'tcx,'ast>,\n                             ast: Ast<'ast>) -> Type<'tcx>\n {"}, {"sha": "a4b5ea1d682823e1d93e8ab401ac1940fb19c5d1", "filename": "src/test/run-pass/self-in-mut-slot-immediate-value.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,12 +11,11 @@\n // Assert that `mut self` on an immediate value doesn't\n // allow mutating the original - issue #10615.\n \n+#[derive(Copy)]\n struct Value {\n     n: int\n }\n \n-impl Copy for Value {}\n-\n impl Value {\n     fn squared(mut self) -> Value {\n         self.n *= self.n;"}, {"sha": "1371c4cc5f4ad7f6405eaa290ad719d4bbbc4727", "filename": "src/test/run-pass/simd-generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-generics.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,9 +13,9 @@\n \n use std::ops;\n \n-#[simd] struct f32x4(f32, f32, f32, f32);\n-\n-impl Copy for f32x4 {}\n+#[simd]\n+#[derive(Copy)]\n+struct f32x4(f32, f32, f32, f32);\n \n fn add<T: ops::Add<Output=T>>(lhs: T, rhs: T) -> T {\n     lhs + rhs"}, {"sha": "35283e466c1c099f4c6a6993cf5aa439652d8ff0", "filename": "src/test/run-pass/small-enum-range-edge.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -13,18 +13,16 @@\n  */\n \n #[repr(u8)]\n+#[derive(Copy)]\n enum Eu { Lu = 0, Hu = 255 }\n \n-impl Copy for Eu {}\n-\n static CLu: Eu = Eu::Lu;\n static CHu: Eu = Eu::Hu;\n \n #[repr(i8)]\n+#[derive(Copy)]\n enum Es { Ls = -128, Hs = 127 }\n \n-impl Copy for Es {}\n-\n static CLs: Es = Es::Ls;\n static CHs: Es = Es::Hs;\n "}, {"sha": "c8768731e2bdb5c19022a99f92bd134cb53d0ffe", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,14 +10,12 @@\n //\n // ignore-lexer-test FIXME #15883\n \n+#[derive(Copy)]\n pub struct Quad { a: u64, b: u64, c: u64, d: u64 }\n \n-impl Copy for Quad {}\n-\n+#[derive(Copy)]\n pub struct Floats { a: f64, b: u8, c: f64 }\n \n-impl Copy for Floats {}\n-\n mod rustrt {\n     use super::{Floats, Quad};\n "}, {"sha": "9278ebebc539dd25a9e982ed310f7ebf66749b65", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -10,11 +10,9 @@\n \n \n \n-#[derive(Show)]\n+#[derive(Copy, Show)]\n enum foo { large, small, }\n \n-impl Copy for foo {}\n-\n impl PartialEq for foo {\n     fn eq(&self, other: &foo) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "915a0b5b7e3b76bb87c3dc2ba76e5aa4d756e527", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n use color::{red, green, blue, black, white, imaginary, purple, orange};\n \n+#[derive(Copy)]\n enum color {\n     red = 0xff0000,\n     green = 0x00ff00,\n@@ -20,8 +21,6 @@ enum color {\n     orange = 8 >> 1\n }\n \n-impl Copy for color {}\n-\n impl PartialEq for color {\n     fn eq(&self, other: &color) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "fa02dabb373b198690cd228533e818a2ead112d3", "filename": "src/test/run-pass/trait-coercion-generic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -15,13 +15,12 @@ trait Trait<T> {\n     fn f(&self, x: T);\n }\n \n+#[derive(Copy)]\n struct Struct {\n     x: int,\n     y: int,\n }\n \n-impl Copy for Struct {}\n-\n impl Trait<&'static str> for Struct {\n     fn f(&self, x: &'static str) {\n         println!(\"Hi, {}!\", x);"}, {"sha": "1ae9b3f0e959bb25d1a446075a37175532af6abe", "filename": "src/test/run-pass/trait-coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -17,13 +17,12 @@ trait Trait {\n     fn f(&self);\n }\n \n+#[derive(Copy)]\n struct Struct {\n     x: int,\n     y: int,\n }\n \n-impl Copy for Struct {}\n-\n impl Trait for Struct {\n     fn f(&self) {\n         println!(\"Hi!\");"}, {"sha": "0ea7a1be432158c7313ab002e37b4cce70967094", "filename": "src/test/run-pass/typeclasses-eq-example-static.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example-static.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -21,11 +21,9 @@ trait Equal {\n     fn isEq(a: &Self, b: &Self) -> bool;\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Copy)]\n enum Color { cyan, magenta, yellow, black }\n \n-impl Copy for Color {}\n-\n impl Equal for Color {\n     fn isEq(a: &Color, b: &Color) -> bool {\n         match (*a, *b) {"}, {"sha": "69d22cf34f1b763dbd42e4440adfba013efef89d", "filename": "src/test/run-pass/typeclasses-eq-example.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeclasses-eq-example.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -19,11 +19,9 @@ trait Equal {\n     fn isEq(&self, a: &Self) -> bool;\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Copy)]\n enum Color { cyan, magenta, yellow, black }\n \n-impl Copy for Color {}\n-\n impl Equal for Color {\n     fn isEq(&self, a: &Color) -> bool {\n         match (*self, *a) {"}, {"sha": "2be9f75dae12ca2b1d071c262373524ee7b8c655", "filename": "src/test/run-pass/ufcs-explicit-self.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fufcs-explicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Fufcs-explicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-explicit-self.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -11,12 +11,11 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n+#[derive(Copy)]\n struct Foo {\n     f: int,\n }\n \n-impl Copy for Foo {}\n-\n impl Foo {\n     fn foo(self: Foo, x: int) -> int {\n         self.f + x\n@@ -29,12 +28,11 @@ impl Foo {\n     }\n }\n \n+#[derive(Copy)]\n struct Bar<T> {\n     f: T,\n }\n \n-impl<T:Copy> Copy for Bar<T> {}\n-\n impl<T> Bar<T> {\n     fn foo(self: Bar<T>, x: int) -> int {\n         x"}, {"sha": "6d192daca2fe94c3af3111492652f1f4405511c5", "filename": "src/test/run-pass/unboxed-closures-monomorphization.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0be3b3e76773618bf230b7188ac633ac0e76aa/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs?ref=ee0be3b3e76773618bf230b7188ac633ac0e76aa", "patch": "@@ -30,11 +30,9 @@ fn main(){\n     let mut f = bar(&x);\n     assert_eq!(f.call_mut(()), &x);\n \n-    #[derive(Clone, Show, PartialEq)]\n+    #[derive(Clone, Copy, Show, PartialEq)]\n     struct Foo(uint, &'static str);\n \n-    impl Copy for Foo {}\n-\n     let x = Foo(42, \"forty-two\");\n     let mut f = bar(x);\n     assert_eq!(f.call_mut(()), x);"}]}