{"sha": "7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NjBjZjQ1NDI2MWU3ZWI3YjE4ZWRkMTRmNGZiZjdmYjY2MjdmMmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-06T23:39:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-06T23:39:30Z"}, "message": "Rollup merge of #63294 - alsuren:async-tests, r=cramertj\n\ntests for async/await drop order\n\nThis is just me helping out with https://github.com/rust-lang/rust/issues/62121 where I can.\n\nI'm also going to use this as a public place to collect my thoughts about what has already been done and what hasn't (adding comments to the dropbox paper doc was quickly getting spammy).\n\nI've tried to keep my commit messages similar to the line items on https://paper.dropbox.com/doc/async.await-Call-for-Tests--AiKouT0L41mSnK1741s~TiiRAg-nMyZGrra7dz9KcFRMLKJy as possible.\n\nA bunch of my tests are likely to be either redundant with other tests, or lower quality than other tests that people are writing. A reasonable approach might be to tell me which commits you want to keep and I'll throw away the rest of them.\n\nThe part from the dropbox paper doc that I'm concentrating on here is:\n(items marked with `?` are ones that I can't immediately think of how to test, so I will leave for other people. Items with checkboxes are things that I have done or will try to do next)\n\n### Dynamic semantics\n- `async`/`await` with unusual locals:\n    - ? partially uninhabited\n    - ? conditionally initialized\n    - ~drop impls~ already done in src/test/ui/async-await/drop-order/*\n    - ? nested drop impls\n    - ~partially moved (e.g., `let x = (vec![], vec![]); drop(x.0); foo.await; drop(x.1);`)~ see  https://github.com/rust-lang/rust/pull/63310\n- Control flow:\n    - basic\n    - complex\n- [x] `.await` while holding variables of different sizes\n- (possibly) drop order\n    - [x] including drop order for locals when a future is dropped part-way through execution\n         - Parameters' drop order is covered in my commit f40190a\n    - ~An async fn version of `dynamic-drop.rs`~\n        - already done by matthewjasper in https://github.com/rust-lang/rust/pull/62193/files\n- ? interaction with const eval, promoteds, and temporaries\n- [x] drop the resulting future and check that local variables and parameters are dropped in the expected order (interaction with cancellation, in other words)\n    - also in f40190a\n\nExplanation of commits:\n\n* 0a1bdd4 is the simplest place I could think of to explicitly test `.await` while holding variables of different sizes. I'm pretty sure that this will end up being redundant with something else, so I'm happy to drop it.\n* f40190a is a copy-paste from `drop-order-for-async-fn-parameters.rs` with `NeverReady.await` dumped on the end of each testcase.\n    * Normally I don't like copy-paste-based tests, but `drop-order-for-async-fn-parameters-by-ref-binding.rs` is also copy-paste, so I thought it might be okay.\n    * [x] I'm a bit sad that this doesn't cover non-parameter locals, but I think it should be easy enough to extend in that direction, so I might have a crack at that tomorrow.\n* c4940e0f90 makes a bunch of local variables and moves them into either `{}` blocks or `async move {}` blocks, checking for any surprising differences.\n    * I have tried to give the test functions descriptive names\n    * I have not duplicated the tests for methods with/without self.\n    * I think that all of these tests could be rewritten to be clearer if I could write down the expected drop order next to each test.", "tree": {"sha": "0810e2531c8c890d58b288b5598623c864a41c4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0810e2531c8c890d58b288b5598623c864a41c4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdSg+yCRBK7hj4Ov3rIwAAdHIIAENyL91/5WukzKTJ7Y6PII+t\nTwxduZB/crCTH5dtj9yLb9T1JvwQhINLsRanT9HZ4m5AKUhpl1J4jSjnqKLJ0U5x\nvgooOsvxcGjW+vBusUdwQs/pKrmYn5JIAu/erP1Dlisy+mJWLIUwRhuIgySwgZfS\nTOnM4nAoqg+uYpo8faG2R9xULat53Cq20q851KH5T5GnMJ2jsH1RAmIf8f9so+OW\nLwFQGbHJ4uwtxOaTo4ct80cTlQ6Jiiw7D1ubX1ycEpO78cFwxvLiivhk+C0GpU7c\nMTl+HdlBLyT8yPj7/e/oy1SntFJUS+R8yTMFnQffN/lXFE8+V23qbxiWsgHpgWc=\n=+EuB\n-----END PGP SIGNATURE-----\n", "payload": "tree 0810e2531c8c890d58b288b5598623c864a41c4c\nparent fb79a74020061dcbb44de4bcb1b6590cb3bda35c\nparent c4940e0f90d7d0e1784ade2b9e1ccc7ae7acfd4a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565134770 +0200\ncommitter GitHub <noreply@github.com> 1565134770 +0200\n\nRollup merge of #63294 - alsuren:async-tests, r=cramertj\n\ntests for async/await drop order\n\nThis is just me helping out with https://github.com/rust-lang/rust/issues/62121 where I can.\n\nI'm also going to use this as a public place to collect my thoughts about what has already been done and what hasn't (adding comments to the dropbox paper doc was quickly getting spammy).\n\nI've tried to keep my commit messages similar to the line items on https://paper.dropbox.com/doc/async.await-Call-for-Tests--AiKouT0L41mSnK1741s~TiiRAg-nMyZGrra7dz9KcFRMLKJy as possible.\n\nA bunch of my tests are likely to be either redundant with other tests, or lower quality than other tests that people are writing. A reasonable approach might be to tell me which commits you want to keep and I'll throw away the rest of them.\n\nThe part from the dropbox paper doc that I'm concentrating on here is:\n(items marked with `?` are ones that I can't immediately think of how to test, so I will leave for other people. Items with checkboxes are things that I have done or will try to do next)\n\n### Dynamic semantics\n- `async`/`await` with unusual locals:\n    - ? partially uninhabited\n    - ? conditionally initialized\n    - ~drop impls~ already done in src/test/ui/async-await/drop-order/*\n    - ? nested drop impls\n    - ~partially moved (e.g., `let x = (vec![], vec![]); drop(x.0); foo.await; drop(x.1);`)~ see  https://github.com/rust-lang/rust/pull/63310\n- Control flow:\n    - basic\n    - complex\n- [x] `.await` while holding variables of different sizes\n- (possibly) drop order\n    - [x] including drop order for locals when a future is dropped part-way through execution\n         - Parameters' drop order is covered in my commit f40190a\n    - ~An async fn version of `dynamic-drop.rs`~\n        - already done by matthewjasper in https://github.com/rust-lang/rust/pull/62193/files\n- ? interaction with const eval, promoteds, and temporaries\n- [x] drop the resulting future and check that local variables and parameters are dropped in the expected order (interaction with cancellation, in other words)\n    - also in f40190a\n\nExplanation of commits:\n\n* 0a1bdd4 is the simplest place I could think of to explicitly test `.await` while holding variables of different sizes. I'm pretty sure that this will end up being redundant with something else, so I'm happy to drop it.\n* f40190a is a copy-paste from `drop-order-for-async-fn-parameters.rs` with `NeverReady.await` dumped on the end of each testcase.\n    * Normally I don't like copy-paste-based tests, but `drop-order-for-async-fn-parameters-by-ref-binding.rs` is also copy-paste, so I thought it might be okay.\n    * [x] I'm a bit sad that this doesn't cover non-parameter locals, but I think it should be easy enough to extend in that direction, so I might have a crack at that tomorrow.\n* c4940e0f90 makes a bunch of local variables and moves them into either `{}` blocks or `async move {}` blocks, checking for any surprising differences.\n    * I have tried to give the test functions descriptive names\n    * I have not duplicated the tests for methods with/without self.\n    * I think that all of these tests could be rewritten to be clearer if I could write down the expected drop order next to each test.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "html_url": "https://github.com/rust-lang/rust/commit/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb79a74020061dcbb44de4bcb1b6590cb3bda35c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb79a74020061dcbb44de4bcb1b6590cb3bda35c", "html_url": "https://github.com/rust-lang/rust/commit/fb79a74020061dcbb44de4bcb1b6590cb3bda35c"}, {"sha": "c4940e0f90d7d0e1784ade2b9e1ccc7ae7acfd4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4940e0f90d7d0e1784ade2b9e1ccc7ae7acfd4a", "html_url": "https://github.com/rust-lang/rust/commit/c4940e0f90d7d0e1784ade2b9e1ccc7ae7acfd4a"}], "stats": {"total": 501, "additions": 501, "deletions": 0}, "files": [{"sha": "30b59d037d51239ff0fc56b28751a4e141a25734", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "patch": "@@ -93,9 +93,27 @@ async fn joined_with_noop() {\n     joiner.await\n }\n \n+async fn mixed_sizes() {\n+    let a = BigFut::new();\n+    let b = BigFut::new();\n+    let c = BigFut::new();\n+    let d = BigFut::new();\n+    let e = BigFut::new();\n+    let joiner = Joiner {\n+        a: Some(a),\n+        b: Some(b),\n+        c: Some(c),\n+    };\n+\n+    d.await;\n+    e.await;\n+    joiner.await;\n+}\n+\n fn main() {\n     assert_eq!(1028, std::mem::size_of_val(&single()));\n     assert_eq!(1032, std::mem::size_of_val(&single_with_noop()));\n     assert_eq!(3084, std::mem::size_of_val(&joined()));\n     assert_eq!(3084, std::mem::size_of_val(&joined_with_noop()));\n+    assert_eq!(7188, std::mem::size_of_val(&mixed_sizes()));\n }"}, {"sha": "db396d3957e13c1ce005b3282e8c36f859533919", "filename": "src/test/ui/async-await/drop-order/drop-order-for-locals-when-cancelled.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-locals-when-cancelled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-locals-when-cancelled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-for-locals-when-cancelled.rs?ref=7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "patch": "@@ -0,0 +1,176 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+#![deny(dead_code)]\n+#![feature(async_await)]\n+\n+// Test that the drop order for locals in a fn and async fn matches up.\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+use std::task::{Context, Poll};\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+struct NeverReady;\n+\n+impl Future for NeverReady {\n+    type Output = ();\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        Poll::Pending\n+    }\n+}\n+\n+async fn simple_variable_declaration_async(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+    NeverReady.await;\n+}\n+\n+fn simple_variable_declaration_sync(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+}\n+\n+async fn varable_completely_contained_within_block_async(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    async {\n+        let x = D(\"x\", l.clone());\n+    }\n+        .await;\n+    let y = D(\"y\", l.clone());\n+    NeverReady.await;\n+}\n+\n+fn varable_completely_contained_within_block_sync(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    {\n+        let x = D(\"x\", l.clone());\n+    }\n+    let y = D(\"y\", l.clone());\n+}\n+\n+async fn variables_moved_into_separate_blocks_async(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+    async move { x }.await;\n+    async move { y }.await;\n+    NeverReady.await;\n+}\n+\n+fn variables_moved_into_separate_blocks_sync(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+    {\n+        x\n+    };\n+    {\n+        y\n+    };\n+}\n+\n+async fn variables_moved_into_same_block_async(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+    async move {\n+        x;\n+        y;\n+    };\n+    NeverReady.await;\n+}\n+\n+fn variables_moved_into_same_block_sync(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+    {\n+        x;\n+        y;\n+    };\n+    return;\n+}\n+\n+async fn move_after_current_await_doesnt_affect_order(l: DropOrderListPtr) {\n+    l.borrow_mut().push(DropOrder::Function);\n+    let x = D(\"x\", l.clone());\n+    let y = D(\"y\", l.clone());\n+    NeverReady.await;\n+    async move {\n+        x;\n+        y;\n+    };\n+}\n+\n+fn assert_drop_order_after_cancel<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    g: impl FnOnce(DropOrderListPtr),\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let _ = fut.as_mut().poll(&mut cx);\n+    drop(fut);\n+\n+    let expected_order = Rc::new(RefCell::new(Vec::new()));\n+    g(expected_order.clone());\n+    assert_eq!(*actual_order.borrow(), *expected_order.borrow());\n+}\n+\n+fn main() {\n+    assert_drop_order_after_cancel(\n+        simple_variable_declaration_async,\n+        simple_variable_declaration_sync,\n+    );\n+    assert_drop_order_after_cancel(\n+        varable_completely_contained_within_block_async,\n+        varable_completely_contained_within_block_sync,\n+    );\n+    assert_drop_order_after_cancel(\n+        variables_moved_into_separate_blocks_async,\n+        variables_moved_into_separate_blocks_sync,\n+    );\n+    assert_drop_order_after_cancel(\n+        variables_moved_into_same_block_async,\n+        variables_moved_into_same_block_sync,\n+    );\n+    assert_drop_order_after_cancel(\n+        move_after_current_await_doesnt_affect_order,\n+        simple_variable_declaration_sync,\n+    );\n+}"}, {"sha": "410a623681db546c4826604ed44bf0898c528352", "filename": "src/test/ui/async-await/drop-order/drop-order-when-cancelled.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-when-cancelled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7860cf454261e7eb7b18edd14f4fbf7fb6627f2c/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-when-cancelled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-order%2Fdrop-order-when-cancelled.rs?ref=7860cf454261e7eb7b18edd14f4fbf7fb6627f2c", "patch": "@@ -0,0 +1,307 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+#![feature(async_await)]\n+\n+// Test that the drop order for parameters in a fn and async fn matches up. Also test that\n+// parameters (used or unused) are not dropped until the async fn is cancelled.\n+// This file is mostly copy-pasted from drop-order-for-async-fn-parameters.rs\n+\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+use std::task::{Context, Poll};\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+struct NeverReady;\n+\n+impl Future for NeverReady {\n+    type Output = ();\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        Poll::Pending\n+    }\n+}\n+\n+/// Check that unused bindings are dropped after the function is polled.\n+async fn foo_async(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+    NeverReady.await;\n+}\n+\n+fn foo_sync(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns are dropped after the function is polled.\n+async fn bar_async(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+    NeverReady.await;\n+}\n+\n+fn bar_sync(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns within more complex patterns are dropped after the function\n+/// is polled.\n+async fn baz_async((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+    NeverReady.await;\n+}\n+\n+fn baz_sync((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n+/// after the function is polled.\n+async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+    NeverReady.await;\n+}\n+\n+fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    /// Check that unused bindings are dropped after the method is polled.\n+    async fn foo_async(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn foo_sync(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method is polled.\n+    async fn bar_async(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn bar_sync(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// is polled.\n+    async fn baz_async((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn baz_sync((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method is polled.\n+    async fn foobar_async(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn foobar_sync(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+struct Bar<'a>(PhantomData<&'a ()>);\n+\n+impl<'a> Bar<'a> {\n+    /// Check that unused bindings are dropped after the method with self is polled.\n+    async fn foo_async(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn foo_sync(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method with self is polled.\n+    async fn bar_async(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn bar_sync(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// with self is polled.\n+    async fn baz_async(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn baz_sync(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method with self is polled.\n+    async fn foobar_async(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+        NeverReady.await;\n+    }\n+\n+    fn foobar_sync(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+fn assert_drop_order_after_cancel<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    g: impl FnOnce(DropOrderListPtr),\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let _ = fut.as_mut().poll(&mut cx);\n+\n+    // Parameters are never dropped until the future completes.\n+    assert_eq!(*actual_order.borrow(), vec![DropOrder::Function]);\n+\n+    drop(fut);\n+\n+    let expected_order = Rc::new(RefCell::new(Vec::new()));\n+    g(expected_order.clone());\n+    assert_eq!(*actual_order.borrow(), *expected_order.borrow());\n+}\n+\n+fn main() {\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_cancel(\n+        |l| foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+        |l| foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+        |l| bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+        |l| baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| {\n+            foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods w/out self (see doc comment on function for what it tests).\n+    assert_drop_order_after_cancel(\n+        |l| Foo::foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+        |l| Foo::foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| Foo::bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+        |l| Foo::bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| Foo::baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+        |l| Foo::baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| {\n+            Foo::foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            Foo::foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+\n+    // Methods (see doc comment on function for what it tests).\n+    let b = Bar(Default::default());\n+    assert_drop_order_after_cancel(\n+        |l| b.foo_async(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+        |l| b.foo_sync(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| b.bar_async(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+        |l| b.bar_sync(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| b.baz_async((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+        |l| b.baz_sync((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+    );\n+    assert_drop_order_after_cancel(\n+        |l| {\n+            b.foobar_async(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+        |l| {\n+            b.foobar_sync(\n+                D(\"x\", l.clone()),\n+                (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+                D(\"_\", l.clone()),\n+                D(\"_y\", l.clone()),\n+            )\n+        },\n+    );\n+}"}]}