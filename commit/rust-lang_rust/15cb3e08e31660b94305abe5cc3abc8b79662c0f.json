{"sha": "15cb3e08e31660b94305abe5cc3abc8b79662c0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1Y2IzZTA4ZTMxNjYwYjk0MzA1YWJlNWNjM2FiYzhiNzk2NjJjMGY=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2019-10-13T23:17:15Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2019-10-18T02:32:27Z"}, "message": "Fix cfgs for current libc", "tree": {"sha": "8c53be388c57f689fcd3502723a511d61c30af3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c53be388c57f689fcd3502723a511d61c30af3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15cb3e08e31660b94305abe5cc3abc8b79662c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2pJDsACgkQztOS3gxI\nPQDoSRAAm7v4+B0cUfECD+EMiBd0foLd0VHFjPISa/gTmXBHeiKgq4h1/Nu02ywa\nzf9USNQpWRDKyP9+yWgPceGk+quXbmJes7rI/JW3A6LjJ1PF7D5uws00c8VGuWYd\nKmMw9voESfQOYI3Gcl/KbUve2fbDMK6imb7ImD+DHexvpnfd2ZLoH5Hq9f3YWZ2D\niAIpNYXcXBPFIL0zs4Q/pmCI1adGlQz0qq830lXRh37udua4jAi25OdFIs5rW4E6\n2f0RCwFc9My6sjN+69tyb65TK5ztG6aZNou2ToNJl2iro/88pOy9hew27eY2XV+I\nWKWUSkUBHK+6x2lyMdbYhTgxaJwQLL6pVntLNyXHJdpQ1y9nxvhvGR+210WAPaO0\n2cBu4XWQBo1r1LbffTGLMqP3q0HaN4qc9DfkaKwb/B7/8LrMHd9PIseFLR6mhyWc\n+NaIBlDtltLbvCX25p9qrQ2/nOghpdk98TbcxPC8FpF73p1BpdMnOje24W4f1tiA\nCNeKzUNQrx41GLm4boQuZqcVeFfBqY1RMrfIVYSEwCLzotOo5kdCfYiOLod8kT5A\ncGMTsl7lsN9ftt6Ce2HtAmYJYS229lBP6HXtf+pBEAlR1UjiarNKSv8YVUaKgp8J\nU+HErb2TRP/TjP3J5RI6HzhbdaClLDNk9WocH7ZGBWIJ9qFV3EI=\n=IhwC\n-----END PGP SIGNATURE-----", "payload": "tree 8c53be388c57f689fcd3502723a511d61c30af3c\nparent 43f398be6d0faaf119150c950133ba4aa0ff42b3\nauthor oxalica <oxalicc@pm.me> 1571008635 +0800\ncommitter oxalica <oxalicc@pm.me> 1571365947 +0800\n\nFix cfgs for current libc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15cb3e08e31660b94305abe5cc3abc8b79662c0f", "html_url": "https://github.com/rust-lang/rust/commit/15cb3e08e31660b94305abe5cc3abc8b79662c0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15cb3e08e31660b94305abe5cc3abc8b79662c0f/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43f398be6d0faaf119150c950133ba4aa0ff42b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/43f398be6d0faaf119150c950133ba4aa0ff42b3", "html_url": "https://github.com/rust-lang/rust/commit/43f398be6d0faaf119150c950133ba4aa0ff42b3"}], "stats": {"total": 228, "additions": 139, "deletions": 89}, "files": [{"sha": "fee6eecf864a9c99b6586c60652bfb7fe923d012", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 139, "deletions": 89, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/15cb3e08e31660b94305abe5cc3abc8b79662c0f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15cb3e08e31660b94305abe5cc3abc8b79662c0f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=15cb3e08e31660b94305abe5cc3abc8b79662c0f", "patch": "@@ -41,88 +41,137 @@ pub use crate::sys_common::fs::remove_dir_all;\n \n pub struct File(FileDesc);\n \n-#[derive(Clone)]\n-pub struct FileAttr {\n-    stat: stat64,\n-    #[cfg(target_os = \"linux\")]\n-    statx_extra_fields: Option<StatxExtraFields>,\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[derive(Clone)]\n-struct StatxExtraFields {\n-    // This is needed to check if btime is supported by the filesystem.\n-    stx_mask: u32,\n-    stx_btime: libc::statx_timestamp,\n+// FIXME: This should be available on Linux with all `target_arch` and `target_env`.\n+// https://github.com/rust-lang/libc/issues/1545\n+macro_rules! cfg_has_statx {\n+    ({ $($then_tt:tt)* } else { $($else_tt:tt)* }) => {\n+        cfg_if::cfg_if! {\n+            if #[cfg(all(target_os = \"linux\", target_env = \"gnu\", any(\n+                target_arch = \"x86\",\n+                target_arch = \"arm\",\n+                // target_arch = \"mips\",\n+                target_arch = \"powerpc\",\n+                target_arch = \"x86_64\",\n+                // target_arch = \"aarch64\",\n+                target_arch = \"powerpc64\",\n+                // target_arch = \"mips64\",\n+                // target_arch = \"s390x\",\n+                target_arch = \"sparc64\",\n+            )))] {\n+                $($then_tt)*\n+            } else {\n+                $($else_tt)*\n+            }\n+        }\n+    };\n+    ($($block_inner:tt)*) => {\n+        #[cfg(all(target_os = \"linux\", target_env = \"gnu\", any(\n+            target_arch = \"x86\",\n+            target_arch = \"arm\",\n+            // target_arch = \"mips\",\n+            target_arch = \"powerpc\",\n+            target_arch = \"x86_64\",\n+            // target_arch = \"aarch64\",\n+            target_arch = \"powerpc64\",\n+            // target_arch = \"mips64\",\n+            // target_arch = \"s390x\",\n+            target_arch = \"sparc64\",\n+        )))]\n+        {\n+            $($block_inner)*\n+        }\n+    };\n }\n \n-// We prefer `statx` on Linux if available, which contains file creation time.\n-// Default `stat64` contains no creation time.\n-#[cfg(target_os = \"linux\")]\n-unsafe fn try_statx(\n-    fd: c_int,\n-    path: *const libc::c_char,\n-    flags: i32,\n-    mask: u32,\n-) -> Option<io::Result<FileAttr>> {\n-    use crate::sync::atomic::{AtomicBool, Ordering};\n+cfg_has_statx! {{\n+    #[derive(Clone)]\n+    pub struct FileAttr {\n+        stat: stat64,\n+        statx_extra_fields: Option<StatxExtraFields>,\n+    }\n+\n+    #[derive(Clone)]\n+    struct StatxExtraFields {\n+        // This is needed to check if btime is supported by the filesystem.\n+        stx_mask: u32,\n+        stx_btime: libc::statx_timestamp,\n+    }\n+\n+    // We prefer `statx` on Linux if available, which contains file creation time.\n+    // Default `stat64` contains no creation time.\n+    unsafe fn try_statx(\n+        fd: c_int,\n+        path: *const libc::c_char,\n+        flags: i32,\n+        mask: u32,\n+    ) -> Option<io::Result<FileAttr>> {\n+        use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n+        // We store the availability in a global to avoid unnecessary syscalls\n+        static HAS_STATX: AtomicBool = AtomicBool::new(true);\n+        syscall! {\n+            fn statx(\n+                fd: c_int,\n+                pathname: *const libc::c_char,\n+                flags: c_int,\n+                mask: libc::c_uint,\n+                statxbuf: *mut libc::statx\n+            ) -> c_int\n+        }\n \n-    // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-    // We store the availability in a global to avoid unnecessary syscalls\n-    static HAS_STATX: AtomicBool = AtomicBool::new(true);\n-    syscall! {\n-        fn statx(\n-            fd: c_int,\n-            pathname: *const libc::c_char,\n-            flags: c_int,\n-            mask: libc::c_uint,\n-            statxbuf: *mut libc::statx\n-        ) -> c_int\n-    }\n+        if !HAS_STATX.load(Ordering::Relaxed) {\n+            return None;\n+        }\n \n-    if !HAS_STATX.load(Ordering::Relaxed) {\n-        return None;\n-    }\n+        let mut buf: libc::statx = mem::zeroed();\n+        let ret = cvt(statx(fd, path, flags, mask, &mut buf));\n+        match ret {\n+            Err(err) => match err.raw_os_error() {\n+                Some(libc::ENOSYS) => {\n+                    HAS_STATX.store(false, Ordering::Relaxed);\n+                    return None;\n+                }\n+                _ => return Some(Err(err)),\n+            }\n+            Ok(_) => {\n+                // We cannot fill `stat64` exhaustively because of private padding fields.\n+                let mut stat: stat64 = mem::zeroed();\n+                // `c_ulong` on gnu-mips, `dev_t` otherwise\n+                stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n+                stat.st_ino = buf.stx_ino as libc::ino64_t;\n+                stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n+                stat.st_mode = buf.stx_mode as libc::mode_t;\n+                stat.st_uid = buf.stx_uid as libc::uid_t;\n+                stat.st_gid = buf.stx_gid as libc::gid_t;\n+                stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n+                stat.st_size = buf.stx_size as off64_t;\n+                stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n+                stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n+                stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n+                // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n+                stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n+                stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n+                stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n+                stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n+                stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n+\n+                let extra = StatxExtraFields {\n+                    stx_mask: buf.stx_mask,\n+                    stx_btime: buf.stx_btime,\n+                };\n \n-    let mut buf: libc::statx = mem::zeroed();\n-    let ret = cvt(statx(fd, path, flags, mask, &mut buf));\n-    match ret {\n-        Err(err) => match err.raw_os_error() {\n-            Some(libc::ENOSYS) => {\n-                HAS_STATX.store(false, Ordering::Relaxed);\n-                return None;\n+                Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n             }\n-            _ => return Some(Err(err)),\n         }\n-        Ok(_) => {\n-            // We cannot fill `stat64` exhaustively because of private padding fields.\n-            let mut stat: stat64 = mem::zeroed();\n-            stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor);\n-            stat.st_ino = buf.stx_ino as libc::ino64_t;\n-            stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n-            stat.st_mode = buf.stx_mode as libc::mode_t;\n-            stat.st_uid = buf.stx_uid as libc::uid_t;\n-            stat.st_gid = buf.stx_gid as libc::gid_t;\n-            stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor);\n-            stat.st_size = buf.stx_size as off64_t;\n-            stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n-            stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n-            stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n-            stat.st_atime_nsec = buf.stx_atime.tv_nsec as libc::c_long;\n-            stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n-            stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as libc::c_long;\n-            stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n-            stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as libc::c_long;\n-\n-            let extra = StatxExtraFields {\n-                stx_mask: buf.stx_mask,\n-                stx_btime: buf.stx_btime,\n-            };\n+    }\n \n-            Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n-        }\n+} else {\n+    #[derive(Clone)]\n+    pub struct FileAttr {\n+        stat: stat64,\n     }\n-}\n+}}\n \n // all DirEntry's will have a reference to this struct\n struct InnerReadDir {\n@@ -175,15 +224,21 @@ pub struct FileType { mode: mode_t }\n #[derive(Debug)]\n pub struct DirBuilder { mode: mode_t }\n \n-impl FileAttr {\n-    fn from_stat64(stat: stat64) -> Self {\n-        Self {\n-            stat,\n-            #[cfg(target_os = \"linux\")]\n-            statx_extra_fields: None,\n+cfg_has_statx! {{\n+    impl FileAttr {\n+        fn from_stat64(stat: stat64) -> Self {\n+            Self { stat, statx_extra_fields: None }\n         }\n     }\n+} else {\n+    impl FileAttr {\n+        fn from_stat64(stat: stat64) -> Self {\n+            Self { stat }\n+        }\n+    }\n+}}\n \n+impl FileAttr {\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { mode: (self.stat.st_mode as mode_t) }\n@@ -250,8 +305,7 @@ impl FileAttr {\n                   target_os = \"macos\",\n                   target_os = \"ios\")))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n-        #[cfg(target_os = \"linux\")]\n-        {\n+        cfg_has_statx! {\n             if let Some(ext) = &self.statx_extra_fields {\n                 return if (ext.stx_mask & libc::STATX_BTIME) != 0 {\n                     Ok(SystemTime::from(libc::timespec {\n@@ -412,8 +466,7 @@ impl DirEntry {\n         let fd = cvt(unsafe { dirfd(self.dir.inner.dirp.0) })?;\n         let name = self.entry.d_name.as_ptr();\n \n-        #[cfg(target_os = \"linux\")]\n-        {\n+        cfg_has_statx! {\n             if let Some(ret) = unsafe { try_statx(\n                 fd,\n                 name,\n@@ -636,8 +689,7 @@ impl File {\n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         let fd = self.0.raw();\n \n-        #[cfg(target_os = \"linux\")]\n-        {\n+        cfg_has_statx! {\n             if let Some(ret) = unsafe { try_statx(\n                 fd,\n                 b\"\\0\" as *const _ as *const libc::c_char,\n@@ -930,8 +982,7 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n \n-    #[cfg(target_os = \"linux\")]\n-    {\n+    cfg_has_statx! {\n         if let Some(ret) = unsafe { try_statx(\n             libc::AT_FDCWD,\n             p.as_ptr(),\n@@ -952,8 +1003,7 @@ pub fn stat(p: &Path) -> io::Result<FileAttr> {\n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n \n-    #[cfg(target_os = \"linux\")]\n-    {\n+    cfg_has_statx! {\n         if let Some(ret) = unsafe { try_statx(\n             libc::AT_FDCWD,\n             p.as_ptr(),"}]}