{"sha": "4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYTFiMTlmZGUwYzRmY2RlYmEyNGE4ZTYxMzU1NzdlODZjNjlmNDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-23T15:14:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-07T15:17:52Z"}, "message": "rustc: Implement ThinLTO\n\nThis commit is an implementation of LLVM's ThinLTO for consumption in rustc\nitself. Currently today LTO works by merging all relevant LLVM modules into one\nand then running optimization passes. \"Thin\" LTO operates differently by having\nmore sharded work and allowing parallelism opportunities between optimizing\ncodegen units. Further down the road Thin LTO also allows *incremental* LTO\nwhich should enable even faster release builds without compromising on the\nperformance we have today.\n\nThis commit uses a `-Z thinlto` flag to gate whether ThinLTO is enabled. It then\nalso implements two forms of ThinLTO:\n\n* In one mode we'll *only* perform ThinLTO over the codegen units produced in a\n  single compilation. That is, we won't load upstream rlibs, but we'll instead\n  just perform ThinLTO amongst all codegen units produced by the compiler for\n  the local crate. This is intended to emulate a desired end point where we have\n  codegen units turned on by default for all crates and ThinLTO allows us to do\n  this without performance loss.\n\n* In anther mode, like full LTO today, we'll optimize all upstream dependencies\n  in \"thin\" mode. Unlike today, however, this LTO step is fully parallelized so\n  should finish much more quickly.\n\nThere's a good bit of comments about what the implementation is doing and where\nit came from, but the tl;dr; is that currently most of the support here is\ncopied from upstream LLVM. This code duplication is done for a number of\nreasons:\n\n* Controlling parallelism means we can use the existing jobserver support to\n  avoid overloading machines.\n* We will likely want a slightly different form of incremental caching which\n  integrates with our own incremental strategy, but this is yet to be\n  determined.\n* This buys us some flexibility about when/where we run ThinLTO, as well as\n  having it tailored to fit our needs for the time being.\n* Finally this allows us to reuse some artifacts such as our `TargetMachine`\n  creation, where all our options we used today aren't necessarily supported by\n  upstream LLVM yet.\n\nMy hope is that we can get some experience with this copy/paste in tree and then\neventually upstream some work to LLVM itself to avoid the duplication while\nstill ensuring our needs are met. Otherwise I fear that maintaining these\nbindings may be quite costly over the years with LLVM updates!", "tree": {"sha": "eb02149ccbe44173a8efedf58944d20fea4a8683", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb02149ccbe44173a8efedf58944d20fea4a8683"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "html_url": "https://github.com/rust-lang/rust/commit/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abef7e1fd26e6828bbba457173a76d150b1378d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/abef7e1fd26e6828bbba457173a76d150b1378d8", "html_url": "https://github.com/rust-lang/rust/commit/abef7e1fd26e6828bbba457173a76d150b1378d8"}], "stats": {"total": 1472, "additions": 1289, "deletions": 183}, "files": [{"sha": "6ef64ef3d96d91401240b3c59f81ad887c79d478", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -409,9 +409,7 @@ impl_stable_hash_for!(struct self::OutputFilenames {\n     outputs\n });\n \n-/// Codegen unit names generated by the numbered naming scheme will contain this\n-/// marker right before the index of the codegen unit.\n-pub const NUMBERED_CODEGEN_UNIT_MARKER: &'static str = \".cgu-\";\n+pub const RUST_CGU_EXT: &str = \"rust-cgu\";\n \n impl OutputFilenames {\n     pub fn path(&self, flavor: OutputType) -> PathBuf {\n@@ -442,22 +440,14 @@ impl OutputFilenames {\n         let mut extension = String::new();\n \n         if let Some(codegen_unit_name) = codegen_unit_name {\n-            if codegen_unit_name.contains(NUMBERED_CODEGEN_UNIT_MARKER) {\n-                // If we use the numbered naming scheme for modules, we don't want\n-                // the files to look like <crate-name><extra>.<crate-name>.<index>.<ext>\n-                // but simply <crate-name><extra>.<index>.<ext>\n-                let marker_offset = codegen_unit_name.rfind(NUMBERED_CODEGEN_UNIT_MARKER)\n-                                                     .unwrap();\n-                let index_offset = marker_offset + NUMBERED_CODEGEN_UNIT_MARKER.len();\n-                extension.push_str(&codegen_unit_name[index_offset .. ]);\n-            } else {\n-                extension.push_str(codegen_unit_name);\n-            };\n+            extension.push_str(codegen_unit_name);\n         }\n \n         if !ext.is_empty() {\n             if !extension.is_empty() {\n                 extension.push_str(\".\");\n+                extension.push_str(RUST_CGU_EXT);\n+                extension.push_str(\".\");\n             }\n \n             extension.push_str(ext);\n@@ -1105,6 +1095,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n                  \"run the non-lexical lifetimes MIR pass\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n+    thinlto: bool = (false, parse_bool, [TRACKED],\n+        \"enable ThinLTO when possible\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "676bbc87b6cdbd57ca98f5c9e895b44f11cde5d5", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -115,6 +115,7 @@ fn main() {\n                                 \"linker\",\n                                 \"asmparser\",\n                                 \"mcjit\",\n+                                \"lto\",\n                                 \"interpreter\",\n                                 \"instrumentation\"];\n "}, {"sha": "3399bf2acd8917c88bab7b3f4a337bc3a2a9ff7e", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -345,6 +345,20 @@ pub enum PassKind {\n     Module,\n }\n \n+/// LLVMRustThinLTOData\n+pub enum ThinLTOData {}\n+\n+/// LLVMRustThinLTOBuffer\n+pub enum ThinLTOBuffer {}\n+\n+/// LLVMRustThinLTOModule\n+#[repr(C)]\n+pub struct ThinLTOModule {\n+    pub identifier: *const c_char,\n+    pub data: *const u8,\n+    pub len: usize,\n+}\n+\n // Opaque pointer types\n #[allow(missing_copy_implementations)]\n pub enum Module_opaque {}\n@@ -1271,6 +1285,9 @@ extern \"C\" {\n                                                         PM: PassManagerRef,\n                                                         Internalize: Bool,\n                                                         RunInliner: Bool);\n+    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef) -> bool;\n \n     // Stuff that's in rustllvm/ because it's not upstream yet.\n \n@@ -1685,4 +1702,43 @@ extern \"C\" {\n     pub fn LLVMRustModuleBufferLen(p: *const ModuleBuffer) -> usize;\n     pub fn LLVMRustModuleBufferFree(p: *mut ModuleBuffer);\n     pub fn LLVMRustModuleCost(M: ModuleRef) -> u64;\n+\n+    pub fn LLVMRustThinLTOAvailable() -> bool;\n+    pub fn LLVMRustWriteThinBitcodeToFile(PMR: PassManagerRef,\n+                                          M: ModuleRef,\n+                                          BC: *const c_char) -> bool;\n+    pub fn LLVMRustThinLTOBufferCreate(M: ModuleRef) -> *mut ThinLTOBuffer;\n+    pub fn LLVMRustThinLTOBufferFree(M: *mut ThinLTOBuffer);\n+    pub fn LLVMRustThinLTOBufferPtr(M: *const ThinLTOBuffer) -> *const c_char;\n+    pub fn LLVMRustThinLTOBufferLen(M: *const ThinLTOBuffer) -> size_t;\n+    pub fn LLVMRustCreateThinLTOData(\n+        Modules: *const ThinLTOModule,\n+        NumModules: c_uint,\n+        PreservedSymbols: *const *const c_char,\n+        PreservedSymbolsLen: c_uint,\n+    ) -> *mut ThinLTOData;\n+    pub fn LLVMRustPrepareThinLTORename(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOResolveWeak(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOInternalize(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOImport(\n+        Data: *const ThinLTOData,\n+        Module: ModuleRef,\n+    ) -> bool;\n+    pub fn LLVMRustFreeThinLTOData(Data: *mut ThinLTOData);\n+    pub fn LLVMRustParseBitcodeForThinLTO(\n+        Context: ContextRef,\n+        Data: *const u8,\n+        len: usize,\n+        Identifier: *const c_char,\n+    ) -> ModuleRef;\n+    pub fn LLVMGetModuleIdentifier(M: ModuleRef, size: *mut usize) -> *const c_char;\n }"}, {"sha": "3f25c182fa22af775721682eb8818c294a346d7f", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -16,6 +16,7 @@ use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, PrintRequest};\n+use rustc::session::config::RUST_CGU_EXT;\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n@@ -45,13 +46,9 @@ use syntax::attr;\n /// The LLVM module name containing crate-metadata. This includes a `.` on\n /// purpose, so it cannot clash with the name of a user-defined module.\n pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n-/// The name of the crate-metadata object file the compiler generates. Must\n-/// match up with `METADATA_MODULE_NAME`.\n-pub const METADATA_OBJ_NAME: &'static str = \"crate.metadata.o\";\n \n // same as for metadata above, but for allocator shim\n pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n-pub const ALLOCATOR_OBJ_NAME: &'static str = \"crate.allocator.o\";\n \n pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n@@ -129,6 +126,14 @@ fn command_path(sess: &Session) -> OsString {\n     env::join_paths(new_path).unwrap()\n }\n \n+fn metadata_obj(outputs: &OutputFilenames) -> PathBuf {\n+    outputs.temp_path(OutputType::Object, Some(METADATA_MODULE_NAME))\n+}\n+\n+fn allocator_obj(outputs: &OutputFilenames) -> PathBuf {\n+    outputs.temp_path(OutputType::Object, Some(ALLOCATOR_MODULE_NAME))\n+}\n+\n pub fn remove(sess: &Session, path: &Path) {\n     match fs::remove_file(path) {\n         Ok(..) => {}\n@@ -174,9 +179,9 @@ pub fn link_binary(sess: &Session,\n                 remove(sess, &obj.object);\n             }\n         }\n-        remove(sess, &outputs.with_extension(METADATA_OBJ_NAME));\n+        remove(sess, &metadata_obj(outputs));\n         if trans.allocator_module.is_some() {\n-            remove(sess, &outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+            remove(sess, &allocator_obj(outputs));\n         }\n     }\n \n@@ -478,7 +483,7 @@ fn link_rlib<'a>(sess: &'a Session,\n \n         RlibFlavor::StaticlibBase => {\n             if trans.allocator_module.is_some() {\n-                ab.add_file(&outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+                ab.add_file(&allocator_obj(outputs));\n             }\n         }\n     }\n@@ -908,11 +913,11 @@ fn link_args(cmd: &mut Linker,\n     // object file, so we link that in here.\n     if crate_type == config::CrateTypeDylib ||\n        crate_type == config::CrateTypeProcMacro {\n-        cmd.add_object(&outputs.with_extension(METADATA_OBJ_NAME));\n+        cmd.add_object(&metadata_obj(outputs));\n     }\n \n     if trans.allocator_module.is_some() {\n-        cmd.add_object(&outputs.with_extension(ALLOCATOR_OBJ_NAME));\n+        cmd.add_object(&allocator_obj(outputs));\n     }\n \n     // Try to strip as much out of the generated object by removing unused\n@@ -1265,11 +1270,23 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 let canonical = f.replace(\"-\", \"_\");\n                 let canonical_name = name.replace(\"-\", \"_\");\n \n+                // Look for `.rust-cgu.o` at the end of the filename to conclude\n+                // that this is a Rust-related object file.\n+                fn looks_like_rust(s: &str) -> bool {\n+                    let path = Path::new(s);\n+                    let ext = path.extension().and_then(|s| s.to_str());\n+                    if ext != Some(OutputType::Object.extension()) {\n+                        return false\n+                    }\n+                    let ext2 = path.file_stem()\n+                        .and_then(|s| Path::new(s).extension())\n+                        .and_then(|s| s.to_str());\n+                    ext2 == Some(RUST_CGU_EXT)\n+                }\n+\n                 let is_rust_object =\n-                    canonical.starts_with(&canonical_name) && {\n-                        let num = &f[name.len()..f.len() - 2];\n-                        num.len() > 0 && num[1..].parse::<u32>().is_ok()\n-                    };\n+                    canonical.starts_with(&canonical_name) &&\n+                    looks_like_rust(&f);\n \n                 // If we've been requested to skip all native object files\n                 // (those not generated by the rust compiler) then we can skip"}, {"sha": "8f75b891a302c9dd765c4ee7d4a64fc8051d2822", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 395, "deletions": 70, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -9,23 +9,25 @@\n // except according to those terms.\n \n use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n-use back::write;\n use back::symbol_export;\n-use rustc::session::config;\n+use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n+use back::write;\n use errors::{FatalError, Handler};\n-use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n+use llvm;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n+use rustc::session::config;\n use rustc::util::common::time;\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n-use {ModuleTranslation, ModuleKind};\n+use time_graph::Timeline;\n+use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n \n use libc;\n \n use std::ffi::CString;\n use std::slice;\n+use std::sync::Arc;\n \n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n@@ -45,14 +47,14 @@ pub enum LtoModuleTranslation {\n         _serialized_bitcode: Vec<SerializedModule>,\n     },\n \n-    // Note the lack of other entries in this enum! Ideally one day this gap is\n-    // intended to be filled with a \"Thin\" LTO variant.\n+    Thin(ThinModule),\n }\n \n impl LtoModuleTranslation {\n     pub fn name(&self) -> &str {\n         match *self {\n             LtoModuleTranslation::Fat { .. } => \"everything\",\n+            LtoModuleTranslation::Thin(ref m) => m.name(),\n         }\n     }\n \n@@ -62,7 +64,9 @@ impl LtoModuleTranslation {\n     /// points to LLVM data structures owned by this `LtoModuleTranslation`.\n     /// It's intended that the module returned is immediately code generated and\n     /// dropped, and then this LTO module is dropped.\n-    pub unsafe fn optimize(&mut self, cgcx: &CodegenContext)\n+    pub unsafe fn optimize(&mut self,\n+                           cgcx: &CodegenContext,\n+                           timeline: &mut Timeline)\n         -> Result<ModuleTranslation, FatalError>\n     {\n         match *self {\n@@ -71,9 +75,11 @@ impl LtoModuleTranslation {\n                 let config = cgcx.config(trans.kind);\n                 let llmod = trans.llvm().unwrap().llmod;\n                 let tm = trans.llvm().unwrap().tm;\n-                run_pass_manager(cgcx, tm, llmod, config);\n+                run_pass_manager(cgcx, tm, llmod, config, false);\n+                timeline.record(\"fat-done\");\n                 Ok(trans)\n             }\n+            LtoModuleTranslation::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n         }\n     }\n \n@@ -83,33 +89,31 @@ impl LtoModuleTranslation {\n         match *self {\n             // Only one module with fat LTO, so the cost doesn't matter.\n             LtoModuleTranslation::Fat { .. } => 0,\n+            LtoModuleTranslation::Thin(ref m) => m.cost(),\n         }\n     }\n }\n \n-pub fn run(cgcx: &CodegenContext, modules: Vec<ModuleTranslation>)\n+pub enum LTOMode {\n+    WholeCrateGraph,\n+    JustThisCrate,\n+}\n+\n+pub fn run(cgcx: &CodegenContext,\n+           modules: Vec<ModuleTranslation>,\n+           mode: LTOMode,\n+           timeline: &mut Timeline)\n     -> Result<Vec<LtoModuleTranslation>, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    if cgcx.opts.cg.prefer_dynamic {\n-        diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-                    .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                           supported with LTO\")\n-                    .emit();\n-        return Err(FatalError)\n-    }\n-\n-    // Make sure we actually can run LTO\n-    for crate_type in cgcx.crate_types.iter() {\n-        if !crate_type_allows_lto(*crate_type) {\n-            let e = diag_handler.fatal(\"lto can only be run for executables, cdylibs and \\\n-                                        static library outputs\");\n-            return Err(e)\n+    let export_threshold = match mode {\n+        LTOMode::WholeCrateGraph => {\n+            symbol_export::crates_export_threshold(&cgcx.crate_types)\n         }\n-    }\n-\n-    let export_threshold =\n-        symbol_export::crates_export_threshold(&cgcx.crate_types);\n+        LTOMode::JustThisCrate => {\n+            SymbolExportLevel::Rust\n+        }\n+    };\n \n     let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n         if level.is_below_threshold(export_threshold) {\n@@ -121,55 +125,81 @@ pub fn run(cgcx: &CodegenContext, modules: Vec<ModuleTranslation>)\n         }\n     };\n \n-    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols[&LOCAL_CRATE]\n+    let mut symbol_white_list = cgcx.exported_symbols[&LOCAL_CRATE]\n         .iter()\n         .filter_map(symbol_filter)\n-        .collect();\n-    info!(\"{} symbols in whitelist\", symbol_white_list.len());\n+        .collect::<Vec<CString>>();\n+    timeline.record(\"whitelist\");\n \n-    // For each of our upstream dependencies, find the corresponding rlib and\n-    // load the bitcode from the archive. Then merge it into the current LLVM\n-    // module that we've got.\n+    // If we're performing LTO for the entire crate graph, then for each of our\n+    // upstream dependencies, find the corresponding rlib and load the bitcode\n+    // from the archive.\n+    //\n+    // We save off all the bytecode and LLVM module ids for later processing\n+    // with either fat or thin LTO\n     let mut upstream_modules = Vec::new();\n-    for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n-        symbol_white_list.extend(\n-            cgcx.exported_symbols[&cnum]\n-                .iter()\n-                .filter_map(symbol_filter));\n-        info!(\"{} symbols in whitelist after {}\", symbol_white_list.len(), cnum);\n-\n-        let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n-        let bytecodes = archive.iter().filter_map(|child| {\n-            child.ok().and_then(|c| c.name().map(|name| (name, c)))\n-        }).filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n-        for (name, data) in bytecodes {\n-            info!(\"adding bytecode {}\", name);\n-            let bc_encoded = data.data();\n-\n-            let (bc, id) = time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n-                match DecodedBytecode::new(bc_encoded) {\n-                    Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n-                    Err(e) => Err(diag_handler.fatal(&e)),\n-                }\n-            })?;\n-            let bc = SerializedModule::FromRlib(bc);\n-            upstream_modules.push((bc, CString::new(id).unwrap()));\n+    if let LTOMode::WholeCrateGraph = mode {\n+        if cgcx.opts.cg.prefer_dynamic {\n+            diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+                        .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n+                               supported with LTO\")\n+                        .emit();\n+            return Err(FatalError)\n+        }\n+\n+        // Make sure we actually can run LTO\n+        for crate_type in cgcx.crate_types.iter() {\n+            if !crate_type_allows_lto(*crate_type) {\n+                let e = diag_handler.fatal(\"lto can only be run for executables, cdylibs and \\\n+                                            static library outputs\");\n+                return Err(e)\n+            }\n         }\n-    }\n \n-    // Internalize everything but the exported symbols of the current module\n-    let arr: Vec<*const libc::c_char> = symbol_white_list.iter()\n-                                                         .map(|c| c.as_ptr())\n-                                                         .collect();\n+        for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n+            symbol_white_list.extend(\n+                cgcx.exported_symbols[&cnum]\n+                    .iter()\n+                    .filter_map(symbol_filter));\n+\n+            let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n+            let bytecodes = archive.iter().filter_map(|child| {\n+                child.ok().and_then(|c| c.name().map(|name| (name, c)))\n+            }).filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n+            for (name, data) in bytecodes {\n+                info!(\"adding bytecode {}\", name);\n+                let bc_encoded = data.data();\n+\n+                let (bc, id) = time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n+                    match DecodedBytecode::new(bc_encoded) {\n+                        Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n+                        Err(e) => Err(diag_handler.fatal(&e)),\n+                    }\n+                })?;\n+                let bc = SerializedModule::FromRlib(bc);\n+                upstream_modules.push((bc, CString::new(id).unwrap()));\n+            }\n+            timeline.record(&format!(\"load: {}\", path.display()));\n+        }\n+    }\n \n-    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr)\n+    let arr = symbol_white_list.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n+    match mode {\n+        LTOMode::WholeCrateGraph if !cgcx.thinlto => {\n+            fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr, timeline)\n+        }\n+        _ => {\n+            thin_lto(&diag_handler, modules, upstream_modules, &arr, timeline)\n+        }\n+    }\n }\n \n fn fat_lto(cgcx: &CodegenContext,\n            diag_handler: &Handler,\n            mut modules: Vec<ModuleTranslation>,\n            mut serialized_modules: Vec<(SerializedModule, CString)>,\n-           symbol_white_list: &[*const libc::c_char])\n+           symbol_white_list: &[*const libc::c_char],\n+           timeline: &mut Timeline)\n     -> Result<Vec<LtoModuleTranslation>, FatalError>\n {\n     info!(\"going for a fat lto\");\n@@ -228,6 +258,7 @@ fn fat_lto(cgcx: &CodegenContext,\n                 Err(write::llvm_err(&diag_handler, msg))\n             }\n         })?;\n+        timeline.record(&format!(\"link {:?}\", name));\n         serialized_bitcode.push(bc_decoded);\n     }\n     cgcx.save_temp_bitcode(&module, \"lto.input\");\n@@ -248,18 +279,151 @@ fn fat_lto(cgcx: &CodegenContext,\n         }\n         cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n     }\n+    timeline.record(\"passes\");\n \n     Ok(vec![LtoModuleTranslation::Fat {\n         module: Some(module),\n         _serialized_bitcode: serialized_bitcode,\n     }])\n }\n \n+/// Prepare \"thin\" LTO to get run on these modules.\n+///\n+/// The general structure of ThinLTO is quite different from the structure of\n+/// \"fat\" LTO above. With \"fat\" LTO all LLVM modules in question are merged into\n+/// one giant LLVM module, and then we run more optimization passes over this\n+/// big module after internalizing most symbols. Thin LTO, on the other hand,\n+/// avoid this large bottleneck through more targeted optimization.\n+///\n+/// At a high level Thin LTO looks like:\n+///\n+///     1. Prepare a \"summary\" of each LLVM module in question which describes\n+///        the values inside, cost of the values, etc.\n+///     2. Merge the summaries of all modules in question into one \"index\"\n+///     3. Perform some global analysis on this index\n+///     4. For each module, use the index and analysis calculated previously to\n+///        perform local transformations on the module, for example inlining\n+///        small functions from other modules.\n+///     5. Run thin-specific optimization passes over each module, and then code\n+///        generate everything at the end.\n+///\n+/// The summary for each module is intended to be quite cheap, and the global\n+/// index is relatively quite cheap to create as well. As a result, the goal of\n+/// ThinLTO is to reduce the bottleneck on LTO and enable LTO to be used in more\n+/// situations. For example one cheap optimization is that we can parallelize\n+/// all codegen modules, easily making use of all the cores on a machine.\n+///\n+/// With all that in mind, the function here is designed at specifically just\n+/// calculating the *index* for ThinLTO. This index will then be shared amongst\n+/// all of the `LtoModuleTranslation` units returned below and destroyed once\n+/// they all go out of scope.\n+fn thin_lto(diag_handler: &Handler,\n+            modules: Vec<ModuleTranslation>,\n+            serialized_modules: Vec<(SerializedModule, CString)>,\n+            symbol_white_list: &[*const libc::c_char],\n+            timeline: &mut Timeline)\n+    -> Result<Vec<LtoModuleTranslation>, FatalError>\n+{\n+    unsafe {\n+        info!(\"going for that thin, thin LTO\");\n+\n+        let mut thin_buffers = Vec::new();\n+        let mut module_names = Vec::new();\n+        let mut thin_modules = Vec::new();\n+\n+        // FIXME: right now, like with fat LTO, we serialize all in-memory\n+        //        modules before working with them and ThinLTO. We really\n+        //        shouldn't do this, however, and instead figure out how to\n+        //        extract a summary from an in-memory module and then merge that\n+        //        into the global index. It turns out that this loop is by far\n+        //        the most expensive portion of this small bit of global\n+        //        analysis!\n+        for (i, module) in modules.iter().enumerate() {\n+            info!(\"local module: {} - {}\", i, module.llmod_id);\n+            let llvm = module.llvm().expect(\"can't lto pretranslated module\");\n+            let name = CString::new(module.llmod_id.clone()).unwrap();\n+            let buffer = llvm::LLVMRustThinLTOBufferCreate(llvm.llmod);\n+            let buffer = ThinBuffer(buffer);\n+            thin_modules.push(llvm::ThinLTOModule {\n+                identifier: name.as_ptr(),\n+                data: buffer.data().as_ptr(),\n+                len: buffer.data().len(),\n+            });\n+            thin_buffers.push(buffer);\n+            module_names.push(name);\n+            timeline.record(&module.llmod_id);\n+        }\n+\n+        // FIXME: All upstream crates are deserialized internally in the\n+        //        function below to extract their summary and modules. Note that\n+        //        unlike the loop above we *must* decode and/or read something\n+        //        here as these are all just serialized files on disk. An\n+        //        improvement, however, to make here would be to store the\n+        //        module summary separately from the actual module itself. Right\n+        //        now this is store in one large bitcode file, and the entire\n+        //        file is deflate-compressed. We could try to bypass some of the\n+        //        decompression by storing the index uncompressed and only\n+        //        lazily decompressing the bytecode if necessary.\n+        //\n+        //        Note that truly taking advantage of this optimization will\n+        //        likely be further down the road. We'd have to implement\n+        //        incremental ThinLTO first where we could actually avoid\n+        //        looking at upstream modules entirely sometimes (the contents,\n+        //        we must always unconditionally look at the index).\n+        let mut serialized = Vec::new();\n+        for (module, name) in serialized_modules {\n+            info!(\"foreign module {:?}\", name);\n+            thin_modules.push(llvm::ThinLTOModule {\n+                identifier: name.as_ptr(),\n+                data: module.data().as_ptr(),\n+                len: module.data().len(),\n+            });\n+            serialized.push(module);\n+            module_names.push(name);\n+        }\n+\n+        // Delegate to the C++ bindings to create some data here. Once this is a\n+        // tried-and-true interface we may wish to try to upstream some of this\n+        // to LLVM itself, right now we reimplement a lot of what they do\n+        // upstream...\n+        let data = llvm::LLVMRustCreateThinLTOData(\n+            thin_modules.as_ptr(),\n+            thin_modules.len() as u32,\n+            symbol_white_list.as_ptr(),\n+            symbol_white_list.len() as u32,\n+        );\n+        if data.is_null() {\n+            let msg = format!(\"failed to prepare thin LTO context\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        let data = ThinData(data);\n+        info!(\"thin LTO data created\");\n+        timeline.record(\"data\");\n+\n+        // Throw our data in an `Arc` as we'll be sharing it across threads. We\n+        // also put all memory referenced by the C++ data (buffers, ids, etc)\n+        // into the arc as well. After this we'll create a thin module\n+        // translation per module in this data.\n+        let shared = Arc::new(ThinShared {\n+            data,\n+            thin_buffers,\n+            serialized_modules: serialized,\n+            module_names,\n+        });\n+        Ok((0..shared.module_names.len()).map(|i| {\n+            LtoModuleTranslation::Thin(ThinModule {\n+                shared: shared.clone(),\n+                idx: i,\n+            })\n+        }).collect())\n+    }\n+}\n+\n fn run_pass_manager(cgcx: &CodegenContext,\n                     tm: TargetMachineRef,\n                     llmod: ModuleRef,\n-                    config: &ModuleConfig) {\n-\n+                    config: &ModuleConfig,\n+                    thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n     // LTO-specific optimization passes that LLVM provides.\n     //\n@@ -274,9 +438,15 @@ fn run_pass_manager(cgcx: &CodegenContext,\n         llvm::LLVMRustAddPass(pm, pass);\n \n         with_llvm_pmb(llmod, config, &mut |b| {\n-            llvm::LLVMPassManagerBuilderPopulateLTOPassManager(b, pm,\n-                /* Internalize = */ False,\n-                /* RunInliner = */ True);\n+            if thin {\n+                if !llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm) {\n+                    panic!(\"this version of LLVM does not support ThinLTO\");\n+                }\n+            } else {\n+                llvm::LLVMPassManagerBuilderPopulateLTOPassManager(b, pm,\n+                    /* Internalize = */ False,\n+                    /* RunInliner = */ True);\n+            }\n         });\n \n         let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n@@ -331,3 +501,158 @@ impl Drop for ModuleBuffer {\n         unsafe { llvm::LLVMRustModuleBufferFree(self.0); }\n     }\n }\n+\n+pub struct ThinModule {\n+    shared: Arc<ThinShared>,\n+    idx: usize,\n+}\n+\n+struct ThinShared {\n+    data: ThinData,\n+    thin_buffers: Vec<ThinBuffer>,\n+    serialized_modules: Vec<SerializedModule>,\n+    module_names: Vec<CString>,\n+}\n+\n+struct ThinData(*mut llvm::ThinLTOData);\n+\n+unsafe impl Send for ThinData {}\n+unsafe impl Sync for ThinData {}\n+\n+impl Drop for ThinData {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustFreeThinLTOData(self.0);\n+        }\n+    }\n+}\n+\n+struct ThinBuffer(*mut llvm::ThinLTOBuffer);\n+\n+unsafe impl Send for ThinBuffer {}\n+unsafe impl Sync for ThinBuffer {}\n+\n+impl ThinBuffer {\n+    fn data(&self) -> &[u8] {\n+        unsafe {\n+            let ptr = llvm::LLVMRustThinLTOBufferPtr(self.0) as *const _;\n+            let len = llvm::LLVMRustThinLTOBufferLen(self.0);\n+            slice::from_raw_parts(ptr, len)\n+        }\n+    }\n+}\n+\n+impl Drop for ThinBuffer {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustThinLTOBufferFree(self.0);\n+        }\n+    }\n+}\n+\n+impl ThinModule {\n+    fn name(&self) -> &str {\n+        self.shared.module_names[self.idx].to_str().unwrap()\n+    }\n+\n+    fn cost(&self) -> u64 {\n+        // Yes, that's correct, we're using the size of the bytecode as an\n+        // indicator for how costly this codegen unit is.\n+        self.data().len() as u64\n+    }\n+\n+    fn data(&self) -> &[u8] {\n+        let a = self.shared.thin_buffers.get(self.idx).map(|b| b.data());\n+        a.unwrap_or_else(|| {\n+            let len = self.shared.thin_buffers.len();\n+            self.shared.serialized_modules[self.idx - len].data()\n+        })\n+    }\n+\n+    unsafe fn optimize(&mut self, cgcx: &CodegenContext, timeline: &mut Timeline)\n+        -> Result<ModuleTranslation, FatalError>\n+    {\n+        let diag_handler = cgcx.create_diag_handler();\n+        let tm = (cgcx.tm_factory)().map_err(|e| {\n+            write::llvm_err(&diag_handler, e)\n+        })?;\n+\n+        // Right now the implementation we've got only works over serialized\n+        // modules, so we create a fresh new LLVM context and parse the module\n+        // into that context. One day, however, we may do this for upstream\n+        // crates but for locally translated modules we may be able to reuse\n+        // that LLVM Context and Module.\n+        let llcx = llvm::LLVMContextCreate();\n+        let llmod = llvm::LLVMRustParseBitcodeForThinLTO(\n+            llcx,\n+            self.data().as_ptr(),\n+            self.data().len(),\n+            self.shared.module_names[self.idx].as_ptr(),\n+        );\n+        assert!(!llmod.is_null());\n+        let mtrans = ModuleTranslation {\n+            source: ModuleSource::Translated(ModuleLlvm {\n+                llmod,\n+                llcx,\n+                tm,\n+            }),\n+            llmod_id: self.name().to_string(),\n+            name: self.name().to_string(),\n+            kind: ModuleKind::Regular,\n+        };\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-input\");\n+\n+        // Like with \"fat\" LTO, get some better optimizations if landing pads\n+        // are disabled by removing all landing pads.\n+        if cgcx.no_landing_pads {\n+            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-nounwind\");\n+            timeline.record(\"nounwind\");\n+        }\n+\n+        // Up next comes the per-module local analyses that we do for Thin LTO.\n+        // Each of these functions is basically copied from the LLVM\n+        // implementation and then tailored to suit this implementation. Ideally\n+        // each of these would be supported by upstream LLVM but that's perhaps\n+        // a patch for another day!\n+        //\n+        // You can find some more comments about these functions in the LLVM\n+        // bindings we've got (currently `PassWrapper.cpp`)\n+        if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-rename\");\n+        timeline.record(\"rename\");\n+        if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-resolve\");\n+        timeline.record(\"resolve\");\n+        if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-internalize\");\n+        timeline.record(\"internalize\");\n+        if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n+            let msg = format!(\"failed to prepare thin LTO module\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-import\");\n+        timeline.record(\"import\");\n+\n+        // Alright now that we've done everything related to the ThinLTO\n+        // analysis it's time to run some optimizations! Here we use the same\n+        // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n+        // populate a thin-specific pass manager, which presumably LLVM treats a\n+        // little differently.\n+        info!(\"running thin lto passes over {}\", mtrans.name);\n+        let config = cgcx.config(mtrans.kind);\n+        run_pass_manager(cgcx, tm, llmod, config, true);\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-pm\");\n+        timeline.record(\"thin-done\");\n+        Ok(mtrans)\n+    }\n+}"}, {"sha": "b3b2384a027664ece0ac6cd1c3994b51b0006788", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 73, "deletions": 15, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -19,7 +19,7 @@ use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Pas\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n-use time_graph::{self, TimeGraph};\n+use time_graph::{self, TimeGraph, Timeline};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::{SMDiagnosticRef, ContextRef};\n@@ -303,6 +303,7 @@ pub struct CodegenContext {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n     pub lto: bool,\n+    pub thinlto: bool,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub exported_symbols: Arc<ExportedSymbols>,\n@@ -315,6 +316,8 @@ pub struct CodegenContext {\n     allocator_module_config: Arc<ModuleConfig>,\n     pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n \n+    // Number of cgus excluding the allocator/metadata modules\n+    pub total_cgus: usize,\n     // Handler to use for diagnostics produced during codegen.\n     pub diag_emitter: SharedEmitter,\n     // LLVM passes added by plugins.\n@@ -450,7 +453,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n unsafe fn optimize(cgcx: &CodegenContext,\n                    diag_handler: &Handler,\n                    mtrans: &ModuleTranslation,\n-                   config: &ModuleConfig)\n+                   config: &ModuleConfig,\n+                   timeline: &mut Timeline)\n     -> Result<(), FatalError>\n {\n     let (llmod, llcx, tm) = match mtrans.source {\n@@ -529,6 +533,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         // Finally, run the actual optimization passes\n         time(config.time_passes, &format!(\"llvm function passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+        timeline.record(\"fpm\");\n         time(config.time_passes, &format!(\"llvm module passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRunPassManager(mpm, llmod));\n \n@@ -543,7 +548,18 @@ fn generate_lto_work(cgcx: &CodegenContext,\n                      modules: Vec<ModuleTranslation>)\n     -> Vec<(WorkItem, u64)>\n {\n-    let lto_modules = lto::run(cgcx, modules).unwrap_or_else(|e| panic!(e));\n+    let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n+        tg.start(TRANS_WORKER_TIMELINE,\n+                 TRANS_WORK_PACKAGE_KIND,\n+                 \"generate lto\")\n+    }).unwrap_or(Timeline::noop());\n+    let mode = if cgcx.lto {\n+        lto::LTOMode::WholeCrateGraph\n+    } else {\n+        lto::LTOMode::JustThisCrate\n+    };\n+    let lto_modules = lto::run(cgcx, modules, mode, &mut timeline)\n+        .unwrap_or_else(|e| panic!(e));\n \n     lto_modules.into_iter().map(|module| {\n         let cost = module.cost();\n@@ -554,9 +570,11 @@ fn generate_lto_work(cgcx: &CodegenContext,\n unsafe fn codegen(cgcx: &CodegenContext,\n                   diag_handler: &Handler,\n                   mtrans: ModuleTranslation,\n-                  config: &ModuleConfig)\n+                  config: &ModuleConfig,\n+                  timeline: &mut Timeline)\n     -> Result<CompiledModule, FatalError>\n {\n+    timeline.record(\"codegen\");\n     let (llmod, llcx, tm) = match mtrans.source {\n         ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n         ModuleSource::Preexisting(_) => {\n@@ -601,7 +619,18 @@ unsafe fn codegen(cgcx: &CodegenContext,\n \n     if write_bc {\n         let bc_out_c = path2cstr(&bc_out);\n-        llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n+        if llvm::LLVMRustThinLTOAvailable() {\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                llvm::LLVMRustWriteThinBitcodeToFile(\n+                    cpm,\n+                    llmod,\n+                    bc_out_c.as_ptr(),\n+                )\n+            });\n+        } else {\n+            llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n+        }\n+        timeline.record(\"bc\");\n     }\n \n     time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n@@ -644,7 +673,8 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n                 llvm::LLVMDisposePassManager(cpm);\n-            })\n+            });\n+            timeline.record(\"ir\");\n         }\n \n         if config.emit_asm {\n@@ -665,13 +695,15 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n+            timeline.record(\"asm\");\n         }\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile)\n             })?;\n+            timeline.record(\"obj\");\n         }\n \n         Ok(())\n@@ -712,7 +744,8 @@ pub fn start_async_translation(tcx: TyCtxt,\n                                time_graph: Option<TimeGraph>,\n                                link: LinkMeta,\n                                metadata: EncodedMetadata,\n-                               coordinator_receive: Receiver<Box<Any + Send>>)\n+                               coordinator_receive: Receiver<Box<Any + Send>>,\n+                               total_cgus: usize)\n                                -> OngoingCrateTranslation {\n     let sess = tcx.sess;\n     let crate_output = tcx.output_filenames(LOCAL_CRATE);\n@@ -836,6 +869,7 @@ pub fn start_async_translation(tcx: TyCtxt,\n                                                   shared_emitter,\n                                                   trans_worker_send,\n                                                   coordinator_receive,\n+                                                  total_cgus,\n                                                   client,\n                                                   time_graph.clone(),\n                                                   Arc::new(modules_config),\n@@ -1080,7 +1114,9 @@ enum WorkItemResult {\n     NeedsLTO(ModuleTranslation),\n }\n \n-fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n+fn execute_work_item(cgcx: &CodegenContext,\n+                     work_item: WorkItem,\n+                     timeline: &mut Timeline)\n     -> Result<WorkItemResult, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n@@ -1089,8 +1125,8 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n         WorkItem::Optimize(mtrans) => mtrans,\n         WorkItem::LTO(mut lto) => {\n             unsafe {\n-                let module = lto.optimize(cgcx)?;\n-                let module = codegen(cgcx, &diag_handler, module, config)?;\n+                let module = lto.optimize(cgcx, timeline)?;\n+                let module = codegen(cgcx, &diag_handler, module, config, timeline)?;\n                 return Ok(WorkItemResult::Compiled(module))\n             }\n         }\n@@ -1140,9 +1176,27 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n         debug!(\"llvm-optimizing {:?}\", module_name);\n \n         unsafe {\n-            optimize(cgcx, &diag_handler, &mtrans, config)?;\n-            if !cgcx.lto || mtrans.kind == ModuleKind::Metadata {\n-                let module = codegen(cgcx, &diag_handler, mtrans, config)?;\n+            optimize(cgcx, &diag_handler, &mtrans, config, timeline)?;\n+\n+            let lto = cgcx.lto;\n+\n+            let auto_thin_lto =\n+                cgcx.thinlto &&\n+                cgcx.total_cgus > 1 &&\n+                mtrans.kind != ModuleKind::Allocator;\n+\n+            // If we're a metadata module we never participate in LTO.\n+            //\n+            // If LTO was explicitly requested on the command line, we always\n+            // LTO everything else.\n+            //\n+            // If LTO *wasn't* explicitly requested and we're not a metdata\n+            // module, then we may automatically do ThinLTO if we've got\n+            // multiple codegen units. Note, however, that the allocator module\n+            // doesn't participate here automatically because of linker\n+            // shenanigans later on.\n+            if mtrans.kind == ModuleKind::Metadata || (!lto && !auto_thin_lto) {\n+                let module = codegen(cgcx, &diag_handler, mtrans, config, timeline)?;\n                 Ok(WorkItemResult::Compiled(module))\n             } else {\n                 Ok(WorkItemResult::NeedsLTO(mtrans))\n@@ -1187,6 +1241,7 @@ fn start_executing_work(tcx: TyCtxt,\n                         shared_emitter: SharedEmitter,\n                         trans_worker_send: Sender<Message>,\n                         coordinator_receive: Receiver<Box<Any + Send>>,\n+                        total_cgus: usize,\n                         jobserver: Client,\n                         time_graph: Option<TimeGraph>,\n                         modules_config: Arc<ModuleConfig>,\n@@ -1229,6 +1284,7 @@ fn start_executing_work(tcx: TyCtxt,\n         crate_types: sess.crate_types.borrow().clone(),\n         each_linked_rlib_for_lto,\n         lto: sess.lto(),\n+        thinlto: sess.opts.debugging_opts.thinlto,\n         no_landing_pads: sess.no_landing_pads(),\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n@@ -1246,6 +1302,7 @@ fn start_executing_work(tcx: TyCtxt,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n         tm_factory: target_machine_factory(tcx.sess),\n+        total_cgus,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1743,12 +1800,13 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let _timing_guard = cgcx.time_graph.as_ref().map(|tg| {\n+            let timeline = cgcx.time_graph.as_ref().map(|tg| {\n                 tg.start(time_graph::TimelineId(cgcx.worker),\n                          LLVM_WORK_PACKAGE_KIND,\n                          &work.name())\n             });\n-            execute_work_item(&cgcx, work).ok()\n+            let mut timeline = timeline.unwrap_or(Timeline::noop());\n+            execute_work_item(&cgcx, work, &mut timeline).ok()\n         };\n     });\n }"}, {"sha": "5764b0b34d1c9368943cb2de195b8391445c476e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -886,6 +886,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     check_for_rustc_errors_attr(tcx);\n \n+    if tcx.sess.opts.debugging_opts.thinlto {\n+        if unsafe { !llvm::LLVMRustThinLTOAvailable() } {\n+            tcx.sess.fatal(\"this compiler's LLVM does not support ThinLTO\");\n+        }\n+    }\n \n     let crate_hash = tcx.dep_graph\n                         .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n@@ -925,7 +930,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             time_graph.clone(),\n             link_meta,\n             metadata,\n-            rx);\n+            rx,\n+            1);\n \n         ongoing_translation.submit_pre_translated_module_to_llvm(tcx, metadata_module);\n         ongoing_translation.translation_finished(tcx);\n@@ -961,7 +967,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         time_graph.clone(),\n         link_meta,\n         metadata,\n-        rx);\n+        rx,\n+        codegen_units.len());\n \n     // Translate an allocator shim, if any\n     let allocator_module = if let Some(kind) = tcx.sess.allocator_kind.get() {\n@@ -1372,7 +1379,9 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // crashes if the module identifier is same as other symbols\n         // such as a function name in the module.\n         // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-        let llmod_id = format!(\"{}.rs\", cgu.name());\n+        let llmod_id = format!(\"{}-{}.rs\",\n+                               cgu.name(),\n+                               tcx.crate_disambiguator(LOCAL_CRATE));\n \n         // Instantiate translation items without filling out definitions yet...\n         let scx = SharedCrateContext::new(tcx);"}, {"sha": "82ec1aaa413642cafa2a1327ec34ad215c7f2a6c", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -108,7 +108,6 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::trans::{Linkage, Visibility};\n-use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -627,7 +626,7 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n+    Symbol::intern(&format!(\"{}{}\", crate_name, index)).as_str()\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "a8502682a806b718f93c6e5b7c9943d86cba759a", "filename": "src/librustc_trans/time_graph.rs", "status": "modified", "additions": 123, "deletions": 29, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Flibrustc_trans%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftime_graph.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::prelude::*;\n use std::marker::PhantomData;\n+use std::mem;\n use std::sync::{Arc, Mutex};\n use std::time::Instant;\n-use std::io::prelude::*;\n-use std::fs::File;\n \n const OUTPUT_WIDTH_IN_PX: u64 = 1000;\n const TIME_LINE_HEIGHT_IN_PX: u64 = 20;\n@@ -25,6 +26,7 @@ struct Timing {\n     end: Instant,\n     work_package_kind: WorkPackageKind,\n     name: String,\n+    events: Vec<(String, Instant)>,\n }\n \n #[derive(Clone, Copy, Hash, Eq, PartialEq, Debug)]\n@@ -44,17 +46,22 @@ pub struct TimeGraph {\n #[derive(Clone, Copy)]\n pub struct WorkPackageKind(pub &'static [&'static str]);\n \n-pub struct RaiiToken {\n+pub struct Timeline {\n+    token: Option<RaiiToken>,\n+}\n+\n+struct RaiiToken {\n     graph: TimeGraph,\n     timeline: TimelineId,\n+    events: Vec<(String, Instant)>,\n     // The token must not be Send:\n     _marker: PhantomData<*const ()>\n }\n \n \n impl Drop for RaiiToken {\n     fn drop(&mut self) {\n-        self.graph.end(self.timeline);\n+        self.graph.end(self.timeline, mem::replace(&mut self.events, Vec::new()));\n     }\n }\n \n@@ -68,7 +75,7 @@ impl TimeGraph {\n     pub fn start(&self,\n                  timeline: TimelineId,\n                  work_package_kind: WorkPackageKind,\n-                 name: &str) -> RaiiToken {\n+                 name: &str) -> Timeline {\n         {\n             let mut table = self.data.lock().unwrap();\n \n@@ -81,14 +88,17 @@ impl TimeGraph {\n             data.open_work_package = Some((Instant::now(), work_package_kind, name.to_string()));\n         }\n \n-        RaiiToken {\n-            graph: self.clone(),\n-            timeline,\n-            _marker: PhantomData,\n+        Timeline {\n+            token: Some(RaiiToken {\n+                graph: self.clone(),\n+                timeline,\n+                events: Vec::new(),\n+                _marker: PhantomData,\n+            }),\n         }\n     }\n \n-    fn end(&self, timeline: TimelineId) {\n+    fn end(&self, timeline: TimelineId, events: Vec<(String, Instant)>) {\n         let end = Instant::now();\n \n         let mut table = self.data.lock().unwrap();\n@@ -100,6 +110,7 @@ impl TimeGraph {\n                 end,\n                 work_package_kind,\n                 name,\n+                events,\n             });\n         } else {\n             bug!(\"end timing without start?\")\n@@ -113,13 +124,13 @@ impl TimeGraph {\n             assert!(data.open_work_package.is_none());\n         }\n \n-        let mut timelines: Vec<PerThread> =\n+        let mut threads: Vec<PerThread> =\n             table.values().map(|data| data.clone()).collect();\n \n-        timelines.sort_by_key(|timeline| timeline.timings[0].start);\n+        threads.sort_by_key(|timeline| timeline.timings[0].start);\n \n-        let earliest_instant = timelines[0].timings[0].start;\n-        let latest_instant = timelines.iter()\n+        let earliest_instant = threads[0].timings[0].start;\n+        let latest_instant = threads.iter()\n                                        .map(|timeline| timeline.timings\n                                                                .last()\n                                                                .unwrap()\n@@ -130,16 +141,46 @@ impl TimeGraph {\n \n         let mut file = File::create(format!(\"{}.html\", output_filename)).unwrap();\n \n-        writeln!(file, \"<html>\").unwrap();\n-        writeln!(file, \"<head></head>\").unwrap();\n-        writeln!(file, \"<body>\").unwrap();\n+        writeln!(file, \"\n+            <html>\n+            <head>\n+                <style>\n+                    #threads a {{\n+                        position: absolute;\n+                        overflow: hidden;\n+                    }}\n+                    #threads {{\n+                        height: {total_height}px;\n+                        width: {width}px;\n+                    }}\n+\n+                    .timeline {{\n+                        display: none;\n+                        width: {width}px;\n+                        position: relative;\n+                    }}\n+\n+                    .timeline:target {{\n+                        display: block;\n+                    }}\n+\n+                    .event {{\n+                        position: absolute;\n+                    }}\n+                </style>\n+            </head>\n+            <body>\n+                <div id='threads'>\n+        \",\n+            total_height = threads.len() * TIME_LINE_HEIGHT_STRIDE_IN_PX,\n+            width = OUTPUT_WIDTH_IN_PX,\n+        ).unwrap();\n \n         let mut color = 0;\n-\n-        for (line_index, timeline) in timelines.iter().enumerate() {\n+        for (line_index, thread) in threads.iter().enumerate() {\n             let line_top = line_index * TIME_LINE_HEIGHT_STRIDE_IN_PX;\n \n-            for span in &timeline.timings {\n+            for span in &thread.timings {\n                 let start = distance(earliest_instant, span.start);\n                 let end = distance(earliest_instant, span.end);\n \n@@ -148,13 +189,13 @@ impl TimeGraph {\n \n                 let colors = span.work_package_kind.0;\n \n-                writeln!(file, \"<div style='position:absolute; \\\n-                                            overflow:hidden; \\\n-                                            top:{}px; \\\n-                                            left:{}px; \\\n-                                            width:{}px; \\\n-                                            height:{}px; \\\n-                                            background:{};'>{}</div>\",\n+                writeln!(file, \"<a href='#timing{}'\n+                                   style='top:{}px; \\\n+                                          left:{}px; \\\n+                                          width:{}px; \\\n+                                          height:{}px; \\\n+                                          background:{};'>{}</a>\",\n+                    color,\n                     line_top,\n                     start,\n                     end - start,\n@@ -167,8 +208,61 @@ impl TimeGraph {\n             }\n         }\n \n-        writeln!(file, \"</body>\").unwrap();\n-        writeln!(file, \"</html>\").unwrap();\n+        writeln!(file, \"\n+            </div>\n+        \").unwrap();\n+\n+        let mut idx = 0;\n+        for thread in threads.iter() {\n+            for timing in &thread.timings {\n+                let colors = timing.work_package_kind.0;\n+                let height = TIME_LINE_HEIGHT_STRIDE_IN_PX * timing.events.len();\n+                writeln!(file, \"<div class='timeline'\n+                                     id='timing{}'\n+                                     style='background:{};height:{}px;'>\",\n+                         idx,\n+                         colors[idx % colors.len()],\n+                         height).unwrap();\n+                idx += 1;\n+                let max = distance(timing.start, timing.end);\n+                for (i, &(ref event, time)) in timing.events.iter().enumerate() {\n+                    let i = i as u64;\n+                    let time = distance(timing.start, time);\n+                    let at = normalize(time, max, OUTPUT_WIDTH_IN_PX);\n+                    writeln!(file, \"<span class='event'\n+                                          style='left:{}px;\\\n+                                                 top:{}px;'>{}</span>\",\n+                             at,\n+                             TIME_LINE_HEIGHT_IN_PX * i,\n+                             event).unwrap();\n+                }\n+                writeln!(file, \"</div>\").unwrap();\n+            }\n+        }\n+\n+        writeln!(file, \"\n+            </body>\n+            </html>\n+        \").unwrap();\n+    }\n+}\n+\n+impl Timeline {\n+    pub fn noop() -> Timeline {\n+        Timeline { token: None }\n+    }\n+\n+    /// Record an event which happened at this moment on this timeline.\n+    ///\n+    /// Events are displayed in the eventual HTML output where you can click on\n+    /// a particular timeline and it'll expand to all of the events that\n+    /// happened on that timeline. This can then be used to drill into a\n+    /// particular timeline and see what events are happening and taking the\n+    /// most time.\n+    pub fn record(&mut self, name: &str) {\n+        if let Some(ref mut token) = self.token {\n+            token.events.push((name.to_string(), Instant::now()));\n+        }\n     }\n }\n "}, {"sha": "e37f048dd4757c2779efb02a0dc3974592418921", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -26,7 +26,11 @@\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n \n #if LLVM_VERSION_GE(4, 0)\n+#include \"llvm/Object/ModuleSummaryIndexObjectFile.h\"\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n+#include \"llvm/Transforms/IPO/FunctionImport.h\"\n+#include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n+#include \"llvm/LTO/LTO.h\"\n #endif\n \n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n@@ -102,6 +106,19 @@ extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n   PMB->add(Pass);\n }\n \n+extern \"C\"\n+bool LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n+  LLVMPassManagerBuilderRef PMBR,\n+  LLVMPassManagerRef PMR\n+) {\n+#if LLVM_VERSION_GE(4, 0)\n+  unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n #ifdef LLVM_COMPONENT_X86\n #define SUBTARGET_X86 SUBTARGET(X86)\n #else\n@@ -740,3 +757,447 @@ extern \"C\" void LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n   unwrap(M)->setPIELevel(PIELevel::Level::Large);\n #endif\n }\n+\n+extern \"C\" bool\n+LLVMRustThinLTOAvailable() {\n+#if LLVM_VERSION_GE(4, 0)\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+#if LLVM_VERSION_GE(4, 0)\n+\n+// Here you'll find an implementation of ThinLTO as used by the Rust compiler\n+// right now. This ThinLTO support is only enabled on \"recent ish\" versions of\n+// LLVM, and otherwise it's just blanket rejected from other compilers.\n+//\n+// Most of this implementation is straight copied from LLVM. At the time of\n+// this writing it wasn't *quite* suitable to reuse more code from upstream\n+// for our purposes, but we should strive to upstream this support once it's\n+// ready to go! I figure we may want a bit of testing locally first before\n+// sending this upstream to LLVM. I hear though they're quite eager to receive\n+// feedback like this!\n+//\n+// If you're reading this code and wondering \"what in the world\" or you're\n+// working \"good lord by LLVM upgrade is *still* failing due to these bindings\"\n+// then fear not! (ok maybe fear a little). All code here is mostly based\n+// on `lib/LTO/ThinLTOCodeGenerator.cpp` in LLVM.\n+//\n+// You'll find that the general layout here roughly corresponds to the `run`\n+// method in that file as well as `ProcessThinLTOModule`. Functions are\n+// specifically commented below as well, but if you're updating this code\n+// or otherwise trying to understand it, the LLVM source will be useful in\n+// interpreting the mysteries within.\n+//\n+// Otherwise I'll apologize in advance, it probably requires a relatively\n+// significant investment on your part to \"truly understand\" what's going on\n+// here. Not saying I do myself, but it took me awhile staring at LLVM's source\n+// and various online resources about ThinLTO to make heads or tails of all\n+// this.\n+\n+extern \"C\" bool\n+LLVMRustWriteThinBitcodeToFile(LLVMPassManagerRef PMR,\n+                               LLVMModuleRef M,\n+                               const char *BcFile) {\n+  llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n+  std::error_code EC;\n+  llvm::raw_fd_ostream bc(BcFile, EC, llvm::sys::fs::F_None);\n+  if (EC) {\n+    LLVMRustSetLastError(EC.message().c_str());\n+    return false;\n+  }\n+  PM->add(createWriteThinLTOBitcodePass(bc));\n+  PM->run(*unwrap(M));\n+  delete PM;\n+  return true;\n+}\n+\n+// This is a shared data structure which *must* be threadsafe to share\n+// read-only amongst threads. This also corresponds basically to the arguments\n+// of the `ProcessThinLTOModule` function in the LLVM source.\n+struct LLVMRustThinLTOData {\n+  // The combined index that is the global analysis over all modules we're\n+  // performing ThinLTO for. This is mostly managed by LLVM.\n+  ModuleSummaryIndex Index;\n+\n+  // All modules we may look at, stored as in-memory serialized versions. This\n+  // is later used when inlining to ensure we can extract any module to inline\n+  // from.\n+  StringMap<MemoryBufferRef> ModuleMap;\n+\n+  // A set that we manage of everything we *don't* want internalized. Note that\n+  // this includes all transitive references right now as well, but it may not\n+  // always!\n+  DenseSet<GlobalValue::GUID> GUIDPreservedSymbols;\n+\n+  // Not 100% sure what these are, but they impact what's internalized and\n+  // what's inlined across modules, I believe.\n+  StringMap<FunctionImporter::ImportMapTy> ImportLists;\n+  StringMap<FunctionImporter::ExportSetTy> ExportLists;\n+  StringMap<GVSummaryMapTy> ModuleToDefinedGVSummaries;\n+};\n+\n+// Just an argument to the `LLVMRustCreateThinLTOData` function below.\n+struct LLVMRustThinLTOModule {\n+  const char *identifier;\n+  const char *data;\n+  size_t len;\n+};\n+\n+// This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp`, not sure what it\n+// does.\n+static const GlobalValueSummary *\n+getFirstDefinitionForLinker(const GlobalValueSummaryList &GVSummaryList) {\n+  auto StrongDefForLinker = llvm::find_if(\n+      GVSummaryList, [](const std::unique_ptr<GlobalValueSummary> &Summary) {\n+        auto Linkage = Summary->linkage();\n+        return !GlobalValue::isAvailableExternallyLinkage(Linkage) &&\n+               !GlobalValue::isWeakForLinker(Linkage);\n+      });\n+  if (StrongDefForLinker != GVSummaryList.end())\n+    return StrongDefForLinker->get();\n+\n+  auto FirstDefForLinker = llvm::find_if(\n+      GVSummaryList, [](const std::unique_ptr<GlobalValueSummary> &Summary) {\n+        auto Linkage = Summary->linkage();\n+        return !GlobalValue::isAvailableExternallyLinkage(Linkage);\n+      });\n+  if (FirstDefForLinker == GVSummaryList.end())\n+    return nullptr;\n+  return FirstDefForLinker->get();\n+}\n+\n+// This is a helper function we added that isn't present in LLVM's source.\n+//\n+// The way LTO works in Rust is that we typically have a number of symbols that\n+// we know ahead of time need to be preserved. We want to ensure that ThinLTO\n+// doesn't accidentally internalize any of these and otherwise is always\n+// ready to keep them linking correctly.\n+//\n+// This function will recursively walk the `GUID` provided and all of its\n+// references, as specified in the `Index`. In other words, we're taking a\n+// `GUID` as input, adding it to `Preserved`, and then taking all `GUID`\n+// items that the input references and recursing.\n+static void\n+addPreservedGUID(const ModuleSummaryIndex &Index,\n+                 DenseSet<GlobalValue::GUID> &Preserved,\n+                 GlobalValue::GUID GUID) {\n+  if (Preserved.count(GUID))\n+    return;\n+  Preserved.insert(GUID);\n+\n+  auto SummaryList = Index.findGlobalValueSummaryList(GUID);\n+  if (SummaryList == Index.end())\n+    return;\n+  for (auto &Summary : SummaryList->second) {\n+    for (auto &Ref : Summary->refs()) {\n+      if (Ref.isGUID()) {\n+        addPreservedGUID(Index, Preserved, Ref.getGUID());\n+      } else {\n+        auto Value = Ref.getValue();\n+        addPreservedGUID(Index, Preserved, Value->getGUID());\n+      }\n+    }\n+\n+    GlobalValueSummary *GVSummary = Summary.get();\n+    if (isa<FunctionSummary>(GVSummary)) {\n+      FunctionSummary *FS = cast<FunctionSummary>(GVSummary);\n+      for (auto &Call: FS->calls()) {\n+        if (Call.first.isGUID()) {\n+          addPreservedGUID(Index, Preserved, Call.first.getGUID());\n+        } else {\n+          auto Value = Call.first.getValue();\n+          addPreservedGUID(Index, Preserved, Value->getGUID());\n+        }\n+      }\n+      for (auto &GUID: FS->type_tests()) {\n+        addPreservedGUID(Index, Preserved, GUID);\n+      }\n+    }\n+  }\n+}\n+\n+// The main entry point for creating the global ThinLTO analysis. The structure\n+// here is basically the same as before threads are spawned in the `run`\n+// function of `lib/LTO/ThinLTOCodeGenerator.cpp`.\n+extern \"C\" LLVMRustThinLTOData*\n+LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n+                          int num_modules,\n+                          const char **preserved_symbols,\n+                          int num_symbols) {\n+  auto Ret = llvm::make_unique<LLVMRustThinLTOData>();\n+\n+  // Load each module's summary and merge it into one combined index\n+  for (int i = 0; i < num_modules; i++) {\n+    auto module = &modules[i];\n+    StringRef buffer(module->data, module->len);\n+    MemoryBufferRef mem_buffer(buffer, module->identifier);\n+\n+    Ret->ModuleMap[module->identifier] = mem_buffer;\n+\n+    Expected<std::unique_ptr<object::ModuleSummaryIndexObjectFile>> ObjOrErr =\n+      object::ModuleSummaryIndexObjectFile::create(mem_buffer);\n+    if (!ObjOrErr) {\n+      LLVMRustSetLastError(toString(ObjOrErr.takeError()).c_str());\n+      return nullptr;\n+    }\n+    auto Index = (*ObjOrErr)->takeIndex();\n+    Ret->Index.mergeFrom(std::move(Index), i);\n+  }\n+\n+  // Collect for each module the list of function it defines (GUID -> Summary)\n+  Ret->Index.collectDefinedGVSummariesPerModule(Ret->ModuleToDefinedGVSummaries);\n+\n+  // Convert the preserved symbols set from string to GUID, this is then needed\n+  // for internalization. We use `addPreservedGUID` to include any transitively\n+  // used symbol as well.\n+  for (int i = 0; i < num_symbols; i++) {\n+    addPreservedGUID(Ret->Index,\n+                     Ret->GUIDPreservedSymbols,\n+                     GlobalValue::getGUID(preserved_symbols[i]));\n+  }\n+\n+  // Collect the import/export lists for all modules from the call-graph in the\n+  // combined index\n+  //\n+  // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp`\n+  computeDeadSymbols(Ret->Index, Ret->GUIDPreservedSymbols);\n+  ComputeCrossModuleImport(\n+    Ret->Index,\n+    Ret->ModuleToDefinedGVSummaries,\n+    Ret->ImportLists,\n+    Ret->ExportLists\n+  );\n+\n+  // Resolve LinkOnce/Weak symbols, this has to be computed early be cause it\n+  // impacts the caching.\n+  //\n+  // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp`\n+  StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n+  DenseMap<GlobalValue::GUID, const GlobalValueSummary *> PrevailingCopy;\n+  for (auto &I : Ret->Index) {\n+    if (I.second.size() > 1)\n+      PrevailingCopy[I.first] = getFirstDefinitionForLinker(I.second);\n+  }\n+  auto isPrevailing = [&](GlobalValue::GUID GUID, const GlobalValueSummary *S) {\n+    const auto &Prevailing = PrevailingCopy.find(GUID);\n+    if (Prevailing == PrevailingCopy.end())\n+      return true;\n+    return Prevailing->second == S;\n+  };\n+  auto recordNewLinkage = [&](StringRef ModuleIdentifier,\n+                              GlobalValue::GUID GUID,\n+                              GlobalValue::LinkageTypes NewLinkage) {\n+    ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n+  };\n+  thinLTOResolveWeakForLinkerInIndex(Ret->Index, isPrevailing, recordNewLinkage);\n+  auto isExported = [&](StringRef ModuleIdentifier, GlobalValue::GUID GUID) {\n+    const auto &ExportList = Ret->ExportLists.find(ModuleIdentifier);\n+    return (ExportList != Ret->ExportLists.end() &&\n+      ExportList->second.count(GUID)) ||\n+      Ret->GUIDPreservedSymbols.count(GUID);\n+  };\n+  thinLTOInternalizeAndPromoteInIndex(Ret->Index, isExported);\n+\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustFreeThinLTOData(LLVMRustThinLTOData *Data) {\n+  delete Data;\n+}\n+\n+// Below are the various passes that happen *per module* when doing ThinLTO.\n+//\n+// In other words, these are the functions that are all run concurrently\n+// with one another, one per module. The passes here correspond to the analysis\n+// passes in `lib/LTO/ThinLTOCodeGenerator.cpp`, currently found in the\n+// `ProcessThinLTOModule` function. Here they're split up into separate steps\n+// so rustc can save off the intermediate bytecode between each step.\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  Module &Mod = *unwrap(M);\n+  if (renameModuleForThinLTO(Mod, Data->Index)) {\n+    LLVMRustSetLastError(\"renameModuleForThinLTO failed\");\n+    return false;\n+  }\n+  return true;\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTOResolveWeak(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  Module &Mod = *unwrap(M);\n+  const auto &DefinedGlobals = Data->ModuleToDefinedGVSummaries.lookup(Mod.getModuleIdentifier());\n+  thinLTOResolveWeakForLinkerModule(Mod, DefinedGlobals);\n+  return true;\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTOInternalize(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  Module &Mod = *unwrap(M);\n+  const auto &DefinedGlobals = Data->ModuleToDefinedGVSummaries.lookup(Mod.getModuleIdentifier());\n+  thinLTOInternalizeModule(Mod, DefinedGlobals);\n+  return true;\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  Module &Mod = *unwrap(M);\n+  const auto &ImportList = Data->ImportLists.lookup(Mod.getModuleIdentifier());\n+  auto Loader = [&](StringRef Identifier) {\n+    const auto &Memory = Data->ModuleMap.lookup(Identifier);\n+    auto &Context = Mod.getContext();\n+    return getLazyBitcodeModule(Memory, Context, true, true);\n+  };\n+  FunctionImporter Importer(Data->Index, Loader);\n+  Expected<bool> Result = Importer.importFunctions(Mod, ImportList);\n+  if (!Result) {\n+    LLVMRustSetLastError(toString(Result.takeError()).c_str());\n+    return false;\n+  }\n+  return true;\n+}\n+\n+// This struct and various functions are sort of a hack right now, but the\n+// problem is that we've got in-memory LLVM modules after we generate and\n+// optimize all codegen-units for one compilation in rustc. To be compatible\n+// with the LTO support above we need to serialize the modules plus their\n+// ThinLTO summary into memory.\n+//\n+// This structure is basically an owned version of a serialize module, with\n+// a ThinLTO summary attached.\n+struct LLVMRustThinLTOBuffer {\n+  std::string data;\n+};\n+\n+extern \"C\" LLVMRustThinLTOBuffer*\n+LLVMRustThinLTOBufferCreate(LLVMModuleRef M) {\n+  auto Ret = llvm::make_unique<LLVMRustThinLTOBuffer>();\n+  {\n+    raw_string_ostream OS(Ret->data);\n+    {\n+      legacy::PassManager PM;\n+      PM.add(createWriteThinLTOBitcodePass(OS));\n+      PM.run(*unwrap(M));\n+    }\n+  }\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustThinLTOBufferFree(LLVMRustThinLTOBuffer *Buffer) {\n+  delete Buffer;\n+}\n+\n+extern \"C\" const void*\n+LLVMRustThinLTOBufferPtr(const LLVMRustThinLTOBuffer *Buffer) {\n+  return Buffer->data.data();\n+}\n+\n+extern \"C\" size_t\n+LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n+  return Buffer->data.length();\n+}\n+\n+// This is what we used to parse upstream bitcode for actual ThinLTO\n+// processing.  We'll call this once per module optimized through ThinLTO, and\n+// it'll be called concurrently on many threads.\n+extern \"C\" LLVMModuleRef\n+LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n+                               const char *data,\n+                               size_t len,\n+                               const char *identifier) {\n+  StringRef Data(data, len);\n+  MemoryBufferRef Buffer(Data, identifier);\n+  unwrap(Context)->enableDebugTypeODRUniquing();\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      parseBitcodeFile(Buffer, *unwrap(Context));\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return nullptr;\n+  }\n+  return wrap(std::move(*SrcOrError).release());\n+}\n+\n+#else\n+\n+extern \"C\" bool\n+LLVMRustWriteThinBitcodeToFile(LLVMPassManagerRef PMR,\n+                               LLVMModuleRef M,\n+                               const char *BcFile) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+struct LLVMRustThinLTOData {\n+};\n+\n+struct LLVMRustThinLTOModule {\n+};\n+\n+extern \"C\" LLVMRustThinLTOData*\n+LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n+                          int num_modules,\n+                          const char **preserved_symbols,\n+                          int num_symbols) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTOResolveWeak(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTOInternalize(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" bool\n+LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" void\n+LLVMRustFreeThinLTOData(LLVMRustThinLTOData *Data) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+struct LLVMRustThinLTOBuffer {\n+};\n+\n+extern \"C\" LLVMRustThinLTOBuffer*\n+LLVMRustThinLTOBufferCreate(LLVMModuleRef M) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" void\n+LLVMRustThinLTOBufferFree(LLVMRustThinLTOBuffer *Buffer) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" const void*\n+LLVMRustThinLTOBufferPtr(const LLVMRustThinLTOBuffer *Buffer) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" size_t\n+LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" LLVMModuleRef\n+LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n+                               const char *data,\n+                               size_t len,\n+                               const char *identifier) {\n+  llvm_unreachable(\"ThinLTO not available\");\n+}\n+#endif // LLVM_VERSION_GE(4, 0)"}, {"sha": "bd1325e7501c131a5e3b67cf98dc17d43ae7cfba", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic0[Internal]\n struct StructWithDtor(u32);\n \n impl Drop for StructWithDtor {\n@@ -22,7 +22,7 @@ impl Drop for StructWithDtor {\n //~ TRANS_ITEM fn drop_in_place_intrinsic::main[0]\n fn main() {\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic0[Internal]\n     let x = [StructWithDtor(0), StructWithDtor(1)];\n \n     drop_slice_in_place(&x);\n@@ -34,7 +34,7 @@ fn drop_slice_in_place(x: &[StructWithDtor]) {\n         // This is the interesting thing in this test case: Normally we would\n         // not have drop-glue for the unsized [StructWithDtor]. This has to be\n         // generated though when the drop_in_place() intrinsic is used.\n-        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic0[Internal]\n         ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n     }\n }"}, {"sha": "108a8b570deddf1f1064f46916d8a1208c58b710", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -45,7 +45,7 @@ enum EnumNoDrop<T1, T2> {\n struct NonGenericNoDrop(i32);\n \n struct NonGenericWithDrop(i32);\n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue0[Internal]\n \n impl Drop for NonGenericWithDrop {\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n@@ -54,11 +54,11 @@ impl Drop for NonGenericWithDrop {\n \n //~ TRANS_ITEM fn generic_drop_glue::main[0]\n fn main() {\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n@@ -67,17 +67,17 @@ fn main() {\n \n     // This is supposed to generate drop-glue because it contains a field that\n     // needs to be dropped.\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue0[Internal]\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n-    //~TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue.cgu-0[Internal]\n+    //~TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,"}, {"sha": "875cacb3907e0a4a1022ab5158ab07fac24f73d6", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -31,13 +31,13 @@ impl<T> Trait for Struct<T> {\n fn main() {\n     let s1 = Struct { _a: 0u32 };\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable0[Internal]\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;\n \n     let s1 = Struct { _a: 0u64 };\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable0[Internal]\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n     let _ = &s1 as &Trait;"}, {"sha": "a6081b2c5eb233e7f60b7264445496a299cd4bd7", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -13,7 +13,7 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n struct StructWithDrop {\n     x: i32\n }\n@@ -27,7 +27,7 @@ struct StructNoDrop {\n     x: i32\n }\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n enum EnumWithDrop {\n     A(i32)\n }"}, {"sha": "8eef5f00f2a78a652bccb532dd526ef9b98f0316", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -13,11 +13,11 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue0[Internal]\n struct Root(Intermediate);\n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue0[Internal]\n struct Intermediate(Leaf);\n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue0[Internal]\n struct Leaf;\n \n impl Drop for Leaf {\n@@ -38,15 +38,15 @@ fn main() {\n \n     let _ = Root(Intermediate(Leaf));\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n }"}, {"sha": "7edb1c14525a92ab1e98b56c2773669f90292676", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -13,7 +13,7 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue.cgu-0[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue0[Internal]\n struct Dropped;\n \n impl Drop for Dropped {\n@@ -23,10 +23,10 @@ impl Drop for Dropped {\n \n //~ TRANS_ITEM fn tuple_drop_glue::main[0]\n fn main() {\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue0[Internal]\n     let x = (0u32, Dropped);\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue.cgu-0[Internal]\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue0[Internal]\n     let x = (0i16, (Dropped, true));\n }"}, {"sha": "cf0c6643238b17937bdcdd170f2f8413c5094b16", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -57,13 +57,13 @@ fn main()\n {\n     // simple case\n     let bool_sized = &true;\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n \n     let char_sized = &'a';\n \n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[1]::foo[0]\n     let _char_unsized = char_sized as &Trait;\n \n@@ -73,13 +73,13 @@ fn main()\n         _b: 2,\n         _c: 3.0f64\n     };\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[2]::foo[0]\n     let _struct_unsized = struct_sized as &Struct<Trait>;\n \n     // custom coercion\n     let wrapper_sized = Wrapper(&0u32);\n-    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[3]::foo[0]\n     let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n }"}, {"sha": "13ca397eaf23e6bdd7da538494416c5141e9a734", "filename": "src/test/run-make/extra-filename-with-temp-outputs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -2,5 +2,5 @@\n \n all:\n \t$(RUSTC) -C extra-filename=bar foo.rs -C save-temps\n-\trm $(TMPDIR)/foobar.0.o\n+\trm $(TMPDIR)/foobar.foo0.rust-cgu.o\n \trm $(TMPDIR)/$(call BIN,foobar)"}, {"sha": "8324a074d6c72156939746bd4b8f1e1eef3f0c60", "filename": "src/test/run-make/sepcomp-cci-copies/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -6,4 +6,4 @@\n all:\n \t$(RUSTC) cci_lib.rs\n \t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ .*cci_fn)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ .*cci_fn)\" -eq \"2\" ]"}, {"sha": "6dc837b8a78740232aef8718485dec19b8b96a21", "filename": "src/test/run-make/sepcomp-inlining/Makefile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -8,7 +8,7 @@\n \n all:\n \t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"0\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ internal\\ i32\\ .*inlined)\" -eq \"2\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ hidden\\ i32\\ .*normal)\" -eq \"1\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ hidden\\ i32\\ .*normal)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"0\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ internal\\ i32\\ .*inlined)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ hidden\\ i32\\ .*normal)\" -eq \"1\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c declare\\ hidden\\ i32\\ .*normal)\" -eq \"2\" ]"}, {"sha": "5b8bdb0fad8cdd7c5cbda1a3526cc585e3d61f95", "filename": "src/test/run-make/sepcomp-separate/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fsepcomp-separate%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-make%2Fsepcomp-separate%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-separate%2FMakefile?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -6,4 +6,4 @@\n \n all:\n \t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ .*magic_fn)\" -eq \"3\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ .*magic_fn)\" -eq \"3\" ]"}, {"sha": "ccbb0e7a7186332cd7101a834e46352e50777bc8", "filename": "src/test/run-pass/auxiliary/thin-lto-inlines-aux.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthin-lto-inlines-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthin-lto-inlines-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthin-lto-inlines-aux.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+pub fn bar() -> u32 {\n+    3\n+}"}, {"sha": "3135a682d869d827f2133d1370cfca69f3d52776", "filename": "src/test/run-pass/thin-lto-inlines.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-pass%2Fthin-lto-inlines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-pass%2Fthin-lto-inlines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthin-lto-inlines.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z thinlto -C codegen-units=8 -O\n+// min-llvm-version 4.0\n+// ignore-emscripten\n+\n+// We want to assert here that ThinLTO will inline across codegen units. There's\n+// not really a great way to do that in general so we sort of hack around it by\n+// praying two functions go into separate codegen units and then assuming that\n+// if inlining *doesn't* happen the first byte of the functions will differ.\n+\n+pub fn foo() -> u32 {\n+    bar::bar()\n+}\n+\n+mod bar {\n+    pub fn bar() -> u32 {\n+        3\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{} {}\", foo(), bar::bar());\n+\n+    unsafe {\n+        let foo = foo as usize as *const u8;\n+        let bar = bar::bar as usize as *const u8;\n+\n+        assert_eq!(*foo, *bar);\n+    }\n+}"}, {"sha": "ed899d2b115b6b2c80cddebe804cf49df8913c3a", "filename": "src/test/run-pass/thin-lto-inlines2.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-pass%2Fthin-lto-inlines2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca1b19fde0c4fcdeba24a8e6135577e86c69f49/src%2Ftest%2Frun-pass%2Fthin-lto-inlines2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthin-lto-inlines2.rs?ref=4ca1b19fde0c4fcdeba24a8e6135577e86c69f49", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z thinlto -C codegen-units=8 -O -C lto\n+// aux-build:thin-lto-inlines-aux.rs\n+// min-llvm-version 4.0\n+// no-prefer-dynamic\n+// ignore-emscripten\n+\n+// We want to assert here that ThinLTO will inline across codegen units. There's\n+// not really a great way to do that in general so we sort of hack around it by\n+// praying two functions go into separate codegen units and then assuming that\n+// if inlining *doesn't* happen the first byte of the functions will differ.\n+\n+extern crate thin_lto_inlines_aux as bar;\n+\n+pub fn foo() -> u32 {\n+    bar::bar()\n+}\n+\n+fn main() {\n+    println!(\"{} {}\", foo(), bar::bar());\n+\n+    unsafe {\n+        let foo = foo as usize as *const u8;\n+        let bar = bar::bar as usize as *const u8;\n+\n+        assert_eq!(*foo, *bar);\n+    }\n+}\n+"}]}