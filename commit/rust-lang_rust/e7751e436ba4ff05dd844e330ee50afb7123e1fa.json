{"sha": "e7751e436ba4ff05dd844e330ee50afb7123e1fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NzUxZTQzNmJhNGZmMDVkZDg0NGUzMzBlZTUwYWZiNzEyM2UxZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-08T12:24:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-08T12:24:43Z"}, "message": "Auto merge of #34720 - Manishearth:rollup, r=Manishearth\n\nRollup of 9 pull requests\n\n- Successful merges: #34097, #34456, #34610, #34612, #34659, #34688, #34691, #34699, #34700\n- Failed merges:", "tree": {"sha": "56d348d5842edcb8ae3d528b512a17e481d847c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56d348d5842edcb8ae3d528b512a17e481d847c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7751e436ba4ff05dd844e330ee50afb7123e1fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7751e436ba4ff05dd844e330ee50afb7123e1fa", "html_url": "https://github.com/rust-lang/rust/commit/e7751e436ba4ff05dd844e330ee50afb7123e1fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7751e436ba4ff05dd844e330ee50afb7123e1fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fa1cdf23cd28b8dc5c8ba1f626c5256713cc991", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa1cdf23cd28b8dc5c8ba1f626c5256713cc991", "html_url": "https://github.com/rust-lang/rust/commit/3fa1cdf23cd28b8dc5c8ba1f626c5256713cc991"}, {"sha": "5389ccc0c198298fbc3f81915791788688012466", "url": "https://api.github.com/repos/rust-lang/rust/commits/5389ccc0c198298fbc3f81915791788688012466", "html_url": "https://github.com/rust-lang/rust/commit/5389ccc0c198298fbc3f81915791788688012466"}], "stats": {"total": 174, "additions": 84, "deletions": 90}, "files": [{"sha": "78ab3c18e4561988429bdb55ffbec9da21eb8caf", "filename": "src/doc/book/conditional-compilation.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Fdoc%2Fbook%2Fconditional-compilation.md", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Fdoc%2Fbook%2Fconditional-compilation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconditional-compilation.md?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -41,8 +41,9 @@ they get set in the [`[features]` section][features] of your `Cargo.toml`:\n # no features by default\n default = []\n \n-# The \u201csecure-password\u201d feature depends on the bcrypt package.\n-secure-password = [\"bcrypt\"]\n+# Add feature \"foo\" here, then you can use it. \n+# Our \"foo\" feature depends on nothing else.\n+foo = []\n ```\n \n When you do this, Cargo passes along a flag to `rustc`:"}, {"sha": "700ab2be589326f5b30521f66cbc94705ae5c341", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -11,7 +11,7 @@ an Internet connection to run the commands in this section, as we\u2019ll be\n downloading Rust from the Internet.\n \n We\u2019ll be showing off a number of commands using a terminal, and those lines all\n-start with `$`. We don't need to type in the `$`s, they are there to indicate\n+start with `$`. You don't need to type in the `$`s, they are there to indicate\n the start of each command. We\u2019ll see many tutorials and examples around the web\n that follow this convention: `$` for commands run as our regular user, and `#`\n for commands we should be running as an administrator.\n@@ -159,9 +159,11 @@ You should see the version number, commit hash, and commit date.\n If you do, Rust has been installed successfully! Congrats!\n \n If you don't and you're on Windows, check that Rust is in your %PATH% system\n-variable. If it isn't, run the installer again, select \"Change\" on the \"Change,\n-repair, or remove installation\" page and ensure \"Add to PATH\" is installed on\n-the local hard drive.\n+variable: `$ echo %PATH%`. If it isn't, run the installer again, select \"Change\"\n+on the \"Change, repair, or remove installation\" page and ensure \"Add to PATH\" is\n+installed on the local hard drive.  If you need to configure your path manually,\n+you can find the Rust executables in a directory like\n+`\"C:\\Program Files\\Rust stable GNU 1.x\\bin\"`.\n \n Rust does not do its own linking, and so you\u2019ll need to have a linker\n installed. Doing so will depend on your specific system, consult its\n@@ -339,15 +341,16 @@ On Windows, you'd enter:\n \n ```bash\n $ dir\n-main.exe  main.rs\n+main.exe\n+main.rs\n ```\n \n This shows we have two files: the source code, with an `.rs` extension, and the\n executable (`main.exe` on Windows, `main` everywhere else). All that's left to\n do from here is run the `main` or `main.exe` file, like this:\n \n ```bash\n-$ ./main  # or main.exe on Windows\n+$ ./main  # or .\\main.exe on Windows\n ```\n \n If *main.rs* were your \"Hello, world!\" program, this would print `Hello,"}, {"sha": "2beb652aa017a6d2c16e959afe05d592a203224d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -10,7 +10,8 @@\n \n #![allow(deprecated)]\n \n-//! Thread-local reference-counted boxes (the `Rc<T>` type).\n+//! Unsynchronized reference-counted boxes (the `Rc<T>` type) which are usable\n+//! only within a single thread.\n //!\n //! The `Rc<T>` type provides shared ownership of an immutable value.\n //! Destruction is deterministic, and will occur as soon as the last owner is"}, {"sha": "9b5c2128f1eaf9fd59460d6fc432794f0a05fc26", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -371,13 +371,16 @@ pub trait Extend<A> {\n /// Basic usage:\n ///\n /// ```\n-/// let numbers = vec![1, 2, 3];\n+/// let numbers = vec![1, 2, 3, 4, 5, 6];\n ///\n /// let mut iter = numbers.iter();\n ///\n /// assert_eq!(Some(&1), iter.next());\n-/// assert_eq!(Some(&3), iter.next_back());\n-/// assert_eq!(Some(&2), iter.next_back());\n+/// assert_eq!(Some(&6), iter.next_back());\n+/// assert_eq!(Some(&5), iter.next_back());\n+/// assert_eq!(Some(&2), iter.next());\n+/// assert_eq!(Some(&3), iter.next());\n+/// assert_eq!(Some(&4), iter.next());\n /// assert_eq!(None, iter.next());\n /// assert_eq!(None, iter.next_back());\n /// ```\n@@ -395,13 +398,16 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let numbers = vec![1, 2, 3];\n+    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n     ///\n     /// let mut iter = numbers.iter();\n     ///\n     /// assert_eq!(Some(&1), iter.next());\n-    /// assert_eq!(Some(&3), iter.next_back());\n-    /// assert_eq!(Some(&2), iter.next_back());\n+    /// assert_eq!(Some(&6), iter.next_back());\n+    /// assert_eq!(Some(&5), iter.next_back());\n+    /// assert_eq!(Some(&2), iter.next());\n+    /// assert_eq!(Some(&3), iter.next());\n+    /// assert_eq!(Some(&4), iter.next());\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next_back());\n     /// ```"}, {"sha": "05ae8ed5b0b66be71b491821fa99be19f2534f74", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -214,6 +214,30 @@ impl Error {\n     }\n \n     /// Creates a new instance of an `Error` from a particular OS error code.\n+    ///\n+    /// # Examples\n+    ///\n+    /// On Linux:\n+    ///\n+    /// ```\n+    /// # if cfg!(target_os = \"linux\") {\n+    /// use std::io;\n+    ///\n+    /// let error = io::Error::from_raw_os_error(98);\n+    /// assert_eq!(error.kind(), io::ErrorKind::AddrInUse);\n+    /// # }\n+    /// ```\n+    ///\n+    /// On Windows:\n+    ///\n+    /// ```\n+    /// # if cfg!(windows) {\n+    /// use std::io;\n+    ///\n+    /// let error = io::Error::from_raw_os_error(10048);\n+    /// assert_eq!(error.kind(), io::ErrorKind::AddrInUse);\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_raw_os_error(code: i32) -> Error {\n         Error { repr: Repr::Os(code) }"}, {"sha": "2d19561139b58144d12df7dc4c37f838199a1505", "filename": "src/libstd/path.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -1529,8 +1529,7 @@ impl Path {\n \n     /// The final component of the path, if it is a normal file.\n     ///\n-    /// If the path terminates in `.`, `..`, or consists solely of a root of\n-    /// prefix, `file_name` will return `None`.\n+    /// If the path terminates in `..`, `file_name` will return `None`.\n     ///\n     /// # Examples\n     ///\n@@ -1543,6 +1542,17 @@ impl Path {\n     ///\n     /// assert_eq!(Some(os_str), path.file_name());\n     /// ```\n+    ///\n+    /// # Other examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    /// use std::ffi::OsStr;\n+    ///\n+    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n+    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n+    /// assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| {"}, {"sha": "26925b12f93d6ba3d28fb0fb0eee80c1f8d639c0", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -152,9 +152,19 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     init();\n \n     let c_host = CString::new(host)?;\n+    let hints = c::addrinfo {\n+        ai_flags: 0,\n+        ai_family: 0,\n+        ai_socktype: c::SOCK_STREAM,\n+        ai_protocol: 0,\n+        ai_addrlen: 0,\n+        ai_addr: ptr::null_mut(),\n+        ai_canonname: ptr::null_mut(),\n+        ai_next: ptr::null_mut()\n+    };\n     let mut res = ptr::null_mut();\n     unsafe {\n-        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n+        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints,\n                                &mut res))?;\n         Ok(LookupHost { original: res, cur: res })\n     }"}, {"sha": "e4875b7c244fd9cb8f641fee92312b9954a0dc07", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 72, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7751e436ba4ff05dd844e330ee50afb7123e1fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e7751e436ba4ff05dd844e330ee50afb7123e1fa", "patch": "@@ -495,64 +495,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Check for erroneous `ident { }`; if matches, signal error and\n-    /// recover (without consuming any expected input token).  Returns\n-    /// true if and only if input was consumed for recovery.\n-    pub fn check_for_erroneous_unit_struct_expecting(&mut self,\n-                                                     expected: &[token::Token])\n-                                                     -> bool {\n-        if self.token == token::OpenDelim(token::Brace)\n-            && expected.iter().all(|t| *t != token::OpenDelim(token::Brace))\n-            && self.look_ahead(1, |t| *t == token::CloseDelim(token::Brace)) {\n-            // matched; signal non-fatal error and recover.\n-            let span = self.span;\n-            self.span_err(span, \"unit-like struct construction is written with no trailing `{ }`\");\n-            self.eat(&token::OpenDelim(token::Brace));\n-            self.eat(&token::CloseDelim(token::Brace));\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Commit to parsing a complete expression `e` expected to be\n-    /// followed by some token from the set edible + inedible.  Recover\n-    /// from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token],\n-                       inedible: &[token::Token]) -> PResult<'a, ()> {\n-        debug!(\"commit_expr {:?}\", e);\n-        if let ExprKind::Path(..) = e.node {\n-            // might be unit-struct construction; check for recoverableinput error.\n-            let expected = edible.iter()\n-                .cloned()\n-                .chain(inedible.iter().cloned())\n-                .collect::<Vec<_>>();\n-            self.check_for_erroneous_unit_struct_expecting(&expected[..]);\n-        }\n-        self.expect_one_of(edible, inedible)\n-    }\n-\n-    pub fn commit_expr_expecting(&mut self, e: &Expr, edible: token::Token) -> PResult<'a, ()> {\n-        self.commit_expr(e, &[edible], &[])\n-    }\n-\n-    /// Commit to parsing a complete statement `s`, which expects to be\n-    /// followed by some token from the set edible + inedible.  Check\n-    /// for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&mut self, edible: &[token::Token],\n-                       inedible: &[token::Token]) -> PResult<'a, ()> {\n-        if self.last_token\n-               .as_ref()\n-               .map_or(false, |t| t.is_ident() || t.is_path()) {\n-            let expected = edible.iter()\n-                .cloned()\n-                .chain(inedible.iter().cloned())\n-                .collect::<Vec<_>>();\n-            self.check_for_erroneous_unit_struct_expecting(&expected);\n-        }\n-        self.expect_one_of(edible, inedible)\n-    }\n-\n     /// returns the span of expr, if it was not interpolated or the span of the interpolated token\n     fn interpolated_or_expr_span(&self,\n                                  expr: PResult<'a, P<Expr>>)\n@@ -1247,7 +1189,7 @@ impl<'a> Parser<'a> {\n             let default = if self.check(&token::Eq) {\n                 self.bump();\n                 let expr = self.parse_expr()?;\n-                self.commit_expr_expecting(&expr, token::Semi)?;\n+                self.expect(&token::Semi)?;\n                 Some(expr)\n             } else {\n                 self.expect(&token::Semi)?;\n@@ -2195,8 +2137,7 @@ impl<'a> Parser<'a> {\n                 let mut trailing_comma = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(self.parse_expr()?);\n-                    self.commit_expr(&es.last().unwrap(), &[],\n-                                     &[token::Comma, token::CloseDelim(token::Paren)])?;\n+                    self.expect_one_of(&[], &[token::Comma, token::CloseDelim(token::Paren)])?;\n                     if self.check(&token::Comma) {\n                         trailing_comma = true;\n \n@@ -2407,9 +2348,8 @@ impl<'a> Parser<'a> {\n                                     }\n                                 }\n \n-                                match self.commit_expr(&fields.last().unwrap().expr,\n-                                                       &[token::Comma],\n-                                                       &[token::CloseDelim(token::Brace)]) {\n+                                match self.expect_one_of(&[token::Comma],\n+                                                         &[token::CloseDelim(token::Brace)]) {\n                                     Ok(()) => {}\n                                     Err(mut e) => {\n                                         e.emit();\n@@ -2662,7 +2602,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let ix = self.parse_expr()?;\n                 hi = self.span.hi;\n-                self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket))?;\n+                self.expect(&token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n                 e = self.mk_expr(lo, hi, index, ThinVec::new())\n               }\n@@ -3329,8 +3269,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n-        if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n-                                                       token::OpenDelim(token::Brace)) {\n+        if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n                 e.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n             }\n@@ -3376,7 +3315,7 @@ impl<'a> Parser<'a> {\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            self.commit_expr(&expr, &[token::Comma], &[token::CloseDelim(token::Brace)])?;\n+            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])?;\n         } else {\n             self.eat(&token::Comma);\n         }\n@@ -4118,7 +4057,7 @@ impl<'a> Parser<'a> {\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n                     if classify::stmt_ends_with_semi(&node) {\n-                        self.commit_stmt(&[token::Semi], &[])?;\n+                        self.expect(&token::Semi)?;\n                         hi = self.last_span.hi;\n                     }\n \n@@ -4196,7 +4135,7 @@ impl<'a> Parser<'a> {\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n             if let Err(mut e) =\n-                self.commit_stmt(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n             {\n                 e.emit();\n                 self.recover_stmt();\n@@ -4863,7 +4802,7 @@ impl<'a> Parser<'a> {\n             let typ = self.parse_ty_sum()?;\n             self.expect(&token::Eq)?;\n             let expr = self.parse_expr()?;\n-            self.commit_expr_expecting(&expr, token::Semi)?;\n+            self.expect(&token::Semi)?;\n             (name, ast::ImplItemKind::Const(typ, expr))\n         } else {\n             let (name, inner_attrs, node) = self.parse_impl_method(&vis)?;\n@@ -5287,7 +5226,7 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty_sum()?;\n         self.expect(&token::Eq)?;\n         let e = self.parse_expr()?;\n-        self.commit_expr_expecting(&e, token::Semi)?;\n+        self.expect(&token::Semi)?;\n         let item = match m {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),"}]}