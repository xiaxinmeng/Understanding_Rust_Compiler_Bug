{"sha": "533a50547f9868ed8a278b80f2504b5ddf65dfb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzM2E1MDU0N2Y5ODY4ZWQ4YTI3OGI4MGYyNTA0YjVkZGY2NWRmYjU=", "commit": {"author": {"name": "Cameron Steffen", "email": "CSteffen@trustwave.com", "date": "2017-10-08T22:24:32Z"}, "committer": {"name": "Cameron Steffen", "email": "CSteffen@trustwave.com", "date": "2017-10-08T22:24:32Z"}, "message": "remove contains_continue functions", "tree": {"sha": "68929726ebaedcd0c921ae93ed1e9ffe1ca0f641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68929726ebaedcd0c921ae93ed1e9ffe1ca0f641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/533a50547f9868ed8a278b80f2504b5ddf65dfb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/533a50547f9868ed8a278b80f2504b5ddf65dfb5", "html_url": "https://github.com/rust-lang/rust/commit/533a50547f9868ed8a278b80f2504b5ddf65dfb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/533a50547f9868ed8a278b80f2504b5ddf65dfb5/comments", "author": null, "committer": null, "parents": [{"sha": "a013568f70ab5099f269c5f86eeca5f71d1275e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a013568f70ab5099f269c5f86eeca5f71d1275e6", "html_url": "https://github.com/rust-lang/rust/commit/a013568f70ab5099f269c5f86eeca5f71d1275e6"}], "stats": {"total": 71, "additions": 0, "deletions": 71}, "files": [{"sha": "0844b1b1608d4792086379c5ff7eb05733501db7", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/533a50547f9868ed8a278b80f2504b5ddf65dfb5/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533a50547f9868ed8a278b80f2504b5ddf65dfb5/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=533a50547f9868ed8a278b80f2504b5ddf65dfb5", "patch": "@@ -489,77 +489,6 @@ fn never_loop(block: &Block, id: NodeId) -> bool {\n     !contains_continue_block(block, Some(id)) && loop_exit_block(block, &mut vec![id])\n }\n \n-fn contains_continue_block(block: &Block, dest: Option<NodeId>) -> bool {\n-    block.stmts.iter().any(|e| contains_continue_stmt(e, dest)) ||\n-        block.expr.as_ref().map_or(\n-            false,\n-            |e| contains_continue_expr(e, dest),\n-        )\n-}\n-\n-fn contains_continue_stmt(stmt: &Stmt, dest: Option<NodeId>) -> bool {\n-    match stmt.node {\n-        StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n-        StmtDecl(ref d, _) => contains_continue_decl(d, dest),\n-    }\n-}\n-\n-fn contains_continue_decl(decl: &Decl, dest: Option<NodeId>) -> bool {\n-    match decl.node {\n-        DeclLocal(ref local) => {\n-            local.init.as_ref().map_or(\n-                false,\n-                |e| contains_continue_expr(e, dest),\n-            )\n-        },\n-        _ => false,\n-    }\n-}\n-\n-fn contains_continue_expr(expr: &Expr, dest: Option<NodeId>) -> bool {\n-    match expr.node {\n-        ExprRet(Some(ref e)) |\n-        ExprBox(ref e) |\n-        ExprUnary(_, ref e) |\n-        ExprCast(ref e, _) |\n-        ExprType(ref e, _) |\n-        ExprField(ref e, _) |\n-        ExprTupField(ref e, _) |\n-        ExprAddrOf(_, ref e) |\n-        ExprRepeat(ref e, _) => contains_continue_expr(e, dest),\n-        ExprArray(ref es) |\n-        ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| contains_continue_expr(e, dest)),\n-        ExprCall(ref e, ref es) => {\n-            contains_continue_expr(e, dest) || es.iter().any(|e| contains_continue_expr(e, dest))\n-        },\n-        ExprBinary(_, ref e1, ref e2) |\n-        ExprAssign(ref e1, ref e2) |\n-        ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| contains_continue_expr(e, dest)),\n-        ExprIf(ref e, ref e2, ref e3) => {\n-            [e, e2].iter().chain(e3.as_ref().iter()).any(|e| {\n-                contains_continue_expr(e, dest)\n-            })\n-        },\n-        ExprWhile(ref e, ref b, _) => contains_continue_expr(e, dest) || contains_continue_block(b, dest),\n-        ExprMatch(ref e, ref arms, _) => {\n-            contains_continue_expr(e, dest) || arms.iter().any(|a| contains_continue_expr(&a.body, dest))\n-        },\n-        ExprBlock(ref block) |\n-        ExprLoop(ref block, ..) => contains_continue_block(block, dest),\n-        ExprStruct(_, _, ref base) => {\n-            base.as_ref().map_or(\n-                false,\n-                |e| contains_continue_expr(e, dest),\n-            )\n-        },\n-        ExprAgain(d) => dest.map_or(true, |dest| d.target_id.opt_id().map_or(false, |id| id == dest)),\n-        _ => false,\n-    }\n-}\n-\n fn loop_exit_block(block: &Block, loops: &mut Vec<NodeId>) -> bool {\n     block.stmts.iter().take_while(|s| !contains_continue_stmt(s, None)).any(|s| loop_exit_stmt(s, loops))\n         || block.expr.as_ref().map_or(false, |e| loop_exit_expr(e, loops))"}]}