{"sha": "9be3e9185b3c6676ce5e8dd16499915251bd7242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZTNlOTE4NWIzYzY2NzZjZTVlOGRkMTY0OTk5MTUyNTFiZDcyNDI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-23T10:55:49Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-23T10:55:49Z"}, "message": "Remove the zst allocation", "tree": {"sha": "058d7a5846f02ac456d7871c778dc4ec57772de3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/058d7a5846f02ac456d7871c778dc4ec57772de3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be3e9185b3c6676ce5e8dd16499915251bd7242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be3e9185b3c6676ce5e8dd16499915251bd7242", "html_url": "https://github.com/rust-lang/rust/commit/9be3e9185b3c6676ce5e8dd16499915251bd7242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be3e9185b3c6676ce5e8dd16499915251bd7242/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f10dd417cb798c7fb497154ddf893be440bf0f27", "url": "https://api.github.com/repos/rust-lang/rust/commits/f10dd417cb798c7fb497154ddf893be440bf0f27", "html_url": "https://github.com/rust-lang/rust/commit/f10dd417cb798c7fb497154ddf893be440bf0f27"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "91bd0d959ff290e0ef12eb513dafd12cada6eea5", "filename": "src/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -59,6 +59,8 @@ pub enum EvalError<'tcx> {\n     ReallocatedStaticMemory,\n     DeallocatedStaticMemory,\n     Layout(layout::LayoutError<'tcx>),\n+    HeapAllocZeroBytes,\n+    HeapAllocNonPowerOfTwoAlignment(u64),\n     Unreachable,\n     Panic,\n }\n@@ -146,6 +148,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"rustc layout computation failed\",\n             EvalError::UnterminatedCString(_) =>\n                 \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n+            EvalError::HeapAllocZeroBytes =>\n+                \"tried to re-, de- or allocate zero bytes on the heap\",\n+            EvalError::HeapAllocNonPowerOfTwoAlignment(_) =>\n+                \"tried to re-, de-, or allocate heap memory with alignment that is not a power of two\",\n             EvalError::Unreachable =>\n                 \"entered unreachable code\",\n             EvalError::Panic =>"}, {"sha": "0a2bce922df50d892a9a79e7cfd7e4b4dbf2c9ad", "filename": "src/eval_context.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -370,7 +370,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         instance,\n                         mir.span,\n                         mir,\n-                        Lvalue::zst(),\n+                        Lvalue::undef(),\n                         StackPopCleanup::Tls(Some(key)),\n                     )?;\n                     let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n@@ -673,8 +673,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                // FIXME: call the `exchange_malloc` lang item if available\n+                if self.type_size(ty)?.expect(\"box only works with sized types\") == 0 {\n+                    let align = self.type_align(ty)?;\n+                    self.write_primval(dest, PrimVal::Bytes(align.into()), dest_ty)?;\n+                } else {\n+                    let ptr = self.alloc_ptr(ty)?;\n+                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                }\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n@@ -904,11 +910,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n-            // Do not do bounds-checking for integers or ZST; they can never alias a normal pointer anyway.\n+            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let PrimVal::Ptr(ptr) = ptr {\n-                if !(ptr.points_to_zst() && (offset == 0 || pointee_size == 0)) {\n-                    self.memory.check_bounds(ptr, false)?;\n-                }\n+                self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n                 return Err(EvalError::NullPointerOutOfBounds);\n@@ -1697,7 +1701,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 main_instance,\n                 main_mir.span,\n                 main_mir,\n-                Lvalue::zst(),\n+                Lvalue::undef(),\n                 StackPopCleanup::Tls(None),\n             )?;\n         }"}, {"sha": "9205e0c299bd29f2868eed9d0f80f2d0f8eec077", "filename": "src/lvalue.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -73,10 +73,6 @@ impl<'tcx> Lvalue<'tcx> {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n-    pub fn zst() -> Self {\n-        Self::from_ptr(Pointer::zst_ptr())\n-    }\n-\n     pub fn from_ptr(ptr: Pointer) -> Self {\n         Self::from_primval_ptr(PrimVal::Ptr(ptr))\n     }"}, {"sha": "e34737f464de4cc6147786d4dc47aebf34c7fe24", "filename": "src/memory.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -81,14 +81,6 @@ impl Pointer {\n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }\n-\n-    pub fn points_to_zst(&self) -> bool {\n-        self.alloc_id == ZST_ALLOC_ID\n-    }\n-\n-    pub fn zst_ptr() -> Self {\n-        Pointer::new(ZST_ALLOC_ID, 0)\n-    }\n }\n \n pub type TlsKey = usize;\n@@ -157,15 +149,13 @@ pub struct Memory<'a, 'tcx> {\n     next_thread_local: TlsKey,\n }\n \n-const ZST_ALLOC_ID: AllocId = AllocId(0);\n-\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n-            next_id: AllocId(2),\n+            next_id: AllocId(0),\n             layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n@@ -206,10 +196,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n-        if size == 0 {\n-            return Ok(Pointer::zst_ptr());\n-        }\n         assert_ne!(align, 0);\n+        assert!(align.is_power_of_two());\n \n         if self.memory_size - self.memory_usage < size {\n             return Err(EvalError::OutOfMemory {\n@@ -236,13 +224,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n     pub fn reallocate(&mut self, ptr: Pointer, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n+        assert!(align.is_power_of_two());\n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n-        if ptr.points_to_zst() {\n-            return self.allocate(new_size, align);\n-        }\n         if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n             return Err(EvalError::ReallocatedStaticMemory);\n         }\n@@ -253,13 +239,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             let amount = new_size - size;\n             self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n+            // FIXME: check alignment here\n             assert_eq!(amount as usize as u64, amount);\n             alloc.bytes.extend(iter::repeat(0).take(amount as usize));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n             self.clear_relocations(ptr.offset(new_size, self.layout)?, size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n+            // FIXME: check alignment here\n             // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n             alloc.bytes.truncate(new_size as usize);\n             alloc.bytes.shrink_to_fit();\n@@ -271,9 +259,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): See comment on `reallocate`.\n     pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n-        if ptr.points_to_zst() {\n-            return Ok(());\n-        }\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -459,7 +444,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -474,7 +458,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -508,7 +491,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let mut allocs_seen = HashSet::new();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            if id == ZST_ALLOC_ID { continue; }\n             let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n             let prefix_len = msg.len();\n             let mut relocations = vec![];\n@@ -556,10 +538,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 for (i, target_id) in relocations {\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                     write!(msg, \"{:1$}\", \"\", ((i - pos) * 3) as usize).unwrap();\n-                    let target = match target_id {\n-                        ZST_ALLOC_ID => String::from(\"zst\"),\n-                        _ => format!(\"({})\", target_id),\n-                    };\n+                    let target = format!(\"({})\", target_id);\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                     write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n                     pos = i + self.pointer_size();\n@@ -637,7 +616,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n         trace!(\"mark_static: {:?}\", alloc_id);\n-        if alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n+        if !self.static_alloc.insert(alloc_id) {\n             bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n         }\n     }\n@@ -667,7 +646,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n             },\n-            None if alloc_id == ZST_ALLOC_ID => return Ok(()),\n             None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n             _ => return Ok(()),\n         };"}, {"sha": "072a5d16a1bea2a1b85e26228ba9e00d88bf20f5", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             instance,\n             span,\n             mir,\n-            Lvalue::zst(),\n+            Lvalue::undef(),\n             StackPopCleanup::None,\n         )?;\n "}, {"sha": "c773620cbb581d827a9a5a895bd3278d774d2e74", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -596,13 +596,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"__rust_allocate\" => {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 let ptr = self.memory.allocate(size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n             \"__rust_allocate_zeroed\" => {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 let ptr = self.memory.allocate(size, align)?;\n                 self.memory.write_repeat(ptr, 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n@@ -611,15 +623,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"__rust_deallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 // FIXME: insert sanity check for size and align?\n-                let _old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let _align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 self.memory.deallocate(ptr)?;\n             },\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n@@ -640,7 +664,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    Lvalue::zst(),\n+                    Lvalue::undef(),\n                     StackPopCleanup::Goto(dest_block),\n                 )?;\n "}, {"sha": "3439824047943c08b83493a6a0d25ed5bd90edcd", "filename": "tests/compile-fail/zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR: tried to access memory through an invalid pointer\n+    let _ = unsafe { *x }; //~ ERROR: tried to access memory with alignment 1, but alignment 4 is required\n }"}, {"sha": "dd619377b9f66f280823918f3e09539df7a773b2", "filename": "tests/compile-fail/zst2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Fcompile-fail%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Fcompile-fail%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst2.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern: the evaluated program panicked\n+\n+#[derive(Debug)]\n+struct A;\n+\n+fn main() {\n+    assert_eq!(&A as *const A as *const (), &() as *const _);\n+}"}, {"sha": "561938e4e9dbf9a10a6c9da4939d0a29571c9ea6", "filename": "tests/compile-fail/zst3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Fcompile-fail%2Fzst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Fcompile-fail%2Fzst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst3.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern: the evaluated program panicked\n+\n+#[derive(Debug)]\n+struct A;\n+\n+fn main() {\n+    assert_eq!(&A as *const A, &A as *const A);\n+}"}, {"sha": "c1c88875c5c80f8e514d64d2f1baa72f6e17d01b", "filename": "tests/run-pass/zst.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be3e9185b3c6676ce5e8dd16499915251bd7242/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=9be3e9185b3c6676ce5e8dd16499915251bd7242", "patch": "@@ -13,8 +13,6 @@ fn use_zst() -> A {\n fn main() {\n     assert_eq!(zst_ret(), A);\n     assert_eq!(use_zst(), A);\n-    assert_eq!(&A as *const A as *const (), &() as *const _);\n-    assert_eq!(&A as *const A, &A as *const A);\n     let x = 42 as *mut ();\n     unsafe { *x = (); }\n }"}]}