{"sha": "a76274e533969c8458c4471fbfc1b84ba44137e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NjI3NGU1MzM5NjljODQ1OGM0NDcxZmJmYzFiODRiYTQ0MTM3ZTA=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-04-20T18:25:05Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-04-21T04:16:31Z"}, "message": "Remove EnumSet\n\n[unstable, deprecated since 1.16.0]", "tree": {"sha": "3e0ba4cfc1f10c1f1e8425913c912d35183a550d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e0ba4cfc1f10c1f1e8425913c912d35183a550d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a76274e533969c8458c4471fbfc1b84ba44137e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a76274e533969c8458c4471fbfc1b84ba44137e0", "html_url": "https://github.com/rust-lang/rust/commit/a76274e533969c8458c4471fbfc1b84ba44137e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a76274e533969c8458c4471fbfc1b84ba44137e0/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535ee6c7f05e29a6e94edba06b228d64f8ba74ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/535ee6c7f05e29a6e94edba06b228d64f8ba74ec", "html_url": "https://github.com/rust-lang/rust/commit/535ee6c7f05e29a6e94edba06b228d64f8ba74ec"}], "stats": {"total": 344, "additions": 1, "deletions": 343}, "files": [{"sha": "b803b6556cfa1fabb93a1ff2f5b9228ff046c12b", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a76274e533969c8458c4471fbfc1b84ba44137e0/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/a76274e533969c8458c4471fbfc1b84ba44137e0/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=a76274e533969c8458c4471fbfc1b84ba44137e0", "patch": "@@ -130,7 +130,6 @@\n     - [derive_clone_copy](library-features/derive-clone-copy.md)\n     - [derive_eq](library-features/derive-eq.md)\n     - [discriminant_value](library-features/discriminant-value.md)\n-    - [enumset](library-features/enumset.md)\n     - [error_type_id](library-features/error-type-id.md)\n     - [exact_size_is_empty](library-features/exact-size-is-empty.md)\n     - [fd](library-features/fd.md)"}, {"sha": "24c8d8fa7dbb914ae7243fb81af9b67bb544791e", "filename": "src/doc/unstable-book/src/library-features/enumset.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/535ee6c7f05e29a6e94edba06b228d64f8ba74ec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md", "raw_url": "https://github.com/rust-lang/rust/raw/535ee6c7f05e29a6e94edba06b228d64f8ba74ec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md?ref=535ee6c7f05e29a6e94edba06b228d64f8ba74ec", "patch": "@@ -1,7 +0,0 @@\n-# `enumset`\n-\n-The tracking issue for this feature is: [#37966]\n-\n-[#37966]: https://github.com/rust-lang/rust/issues/37966\n-\n-------------------------"}, {"sha": "aaee567bf1dbfe475b13951d6e28fdddb7c75eab", "filename": "src/libcollections/enum_set.rs", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/535ee6c7f05e29a6e94edba06b228d64f8ba74ec/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535ee6c7f05e29a6e94edba06b228d64f8ba74ec/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=535ee6c7f05e29a6e94edba06b228d64f8ba74ec", "patch": "@@ -1,313 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A structure for holding a set of enum variants.\n-//!\n-//! This module defines a container which uses an efficient bit mask\n-//! representation to hold C-like enum variants.\n-\n-#![unstable(feature = \"enumset\",\n-            reason = \"matches collection reform specification, \\\n-                      waiting for dust to settle\",\n-            issue = \"37966\")]\n-#![rustc_deprecated(since = \"1.16.0\", reason = \"long since replaced\")]\n-#![allow(deprecated)]\n-\n-use core::marker;\n-use core::fmt;\n-use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{Sub, BitOr, BitAnd, BitXor};\n-\n-// FIXME(contentions): implement union family of methods? (general design may be\n-// wrong here)\n-\n-/// A specialized set implementation to use enum types.\n-///\n-/// It is a logic error for an item to be modified in such a way that the\n-/// transformation of the item to or from a `usize`, as determined by the\n-/// `CLike` trait, changes while the item is in the set. This is normally only\n-/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct EnumSet<E> {\n-    // We must maintain the invariant that no bits are set\n-    // for which no variant exists\n-    bits: usize,\n-    marker: marker::PhantomData<E>,\n-}\n-\n-impl<E> Copy for EnumSet<E> {}\n-\n-impl<E> Clone for EnumSet<E> {\n-    fn clone(&self) -> EnumSet<E> {\n-        *self\n-    }\n-}\n-\n-impl<E: CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_set().entries(self).finish()\n-    }\n-}\n-\n-/// An interface for casting C-like enum to usize and back.\n-/// A typically implementation is as below.\n-///\n-/// ```{rust,ignore}\n-/// #[repr(usize)]\n-/// enum Foo {\n-///     A, B, C\n-/// }\n-///\n-/// impl CLike for Foo {\n-///     fn to_usize(&self) -> usize {\n-///         *self as usize\n-///     }\n-///\n-///     fn from_usize(v: usize) -> Foo {\n-///         unsafe { mem::transmute(v) }\n-///     }\n-/// }\n-/// ```\n-pub trait CLike {\n-    /// Converts a C-like enum to a `usize`.\n-    fn to_usize(&self) -> usize;\n-    /// Converts a `usize` to a C-like enum.\n-    fn from_usize(usize) -> Self;\n-}\n-\n-fn bit<E: CLike>(e: &E) -> usize {\n-    use core::mem;\n-    let value = e.to_usize();\n-    let bits = mem::size_of::<usize>() * 8;\n-    assert!(value < bits,\n-            \"EnumSet only supports up to {} variants.\",\n-            bits - 1);\n-    1 << value\n-}\n-\n-impl<E: CLike> EnumSet<E> {\n-    /// Returns an empty `EnumSet`.\n-    pub fn new() -> EnumSet<E> {\n-        EnumSet {\n-            bits: 0,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Returns the number of elements in the given `EnumSet`.\n-    pub fn len(&self) -> usize {\n-        self.bits.count_ones() as usize\n-    }\n-\n-    /// Returns `true` if the `EnumSet` is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.bits == 0\n-    }\n-\n-    pub fn clear(&mut self) {\n-        self.bits = 0;\n-    }\n-\n-    /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n-        (self.bits & other.bits) == 0\n-    }\n-\n-    /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n-        (self.bits & other.bits) == other.bits\n-    }\n-\n-    /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n-        other.is_superset(self)\n-    }\n-\n-    /// Returns the union of both `EnumSets`.\n-    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits | e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Returns the intersection of both `EnumSets`.\n-    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    pub fn insert(&mut self, e: E) -> bool {\n-        let result = !self.contains(&e);\n-        self.bits |= bit(&e);\n-        result\n-    }\n-\n-    /// Removes an enum from the EnumSet\n-    pub fn remove(&mut self, e: &E) -> bool {\n-        let result = self.contains(e);\n-        self.bits &= !bit(e);\n-        result\n-    }\n-\n-    /// Returns `true` if an `EnumSet` contains a given enum.\n-    pub fn contains(&self, e: &E) -> bool {\n-        (self.bits & bit(e)) != 0\n-    }\n-\n-    /// Returns an iterator over an `EnumSet`.\n-    pub fn iter(&self) -> Iter<E> {\n-        Iter::new(self.bits)\n-    }\n-}\n-\n-impl<E: CLike> Sub for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & !e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitOr for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits | e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitAnd for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitXor for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits ^ e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-/// An iterator over an `EnumSet`\n-pub struct Iter<E> {\n-    index: usize,\n-    bits: usize,\n-    marker: marker::PhantomData<E>,\n-}\n-\n-impl<E: fmt::Debug> fmt::Debug for Iter<E> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Iter\")\n-         .field(&self.index)\n-         .field(&self.bits)\n-         .finish()\n-    }\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<E> Clone for Iter<E> {\n-    fn clone(&self) -> Iter<E> {\n-        Iter {\n-            index: self.index,\n-            bits: self.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> Iter<E> {\n-    fn new(bits: usize) -> Iter<E> {\n-        Iter {\n-            index: 0,\n-            bits: bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> Iterator for Iter<E> {\n-    type Item = E;\n-\n-    fn next(&mut self) -> Option<E> {\n-        if self.bits == 0 {\n-            return None;\n-        }\n-\n-        while (self.bits & 1) == 0 {\n-            self.index += 1;\n-            self.bits >>= 1;\n-        }\n-        let elem = CLike::from_usize(self.index);\n-        self.index += 1;\n-        self.bits >>= 1;\n-        Some(elem)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = self.bits.count_ones() as usize;\n-        (exact, Some(exact))\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<E: CLike> FusedIterator for Iter<E> {}\n-\n-impl<E: CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I: IntoIterator<Item = E>>(iter: I) -> EnumSet<E> {\n-        let mut ret = EnumSet::new();\n-        ret.extend(iter);\n-        ret\n-    }\n-}\n-\n-impl<'a, E> IntoIterator for &'a EnumSet<E>\n-    where E: CLike\n-{\n-    type Item = E;\n-    type IntoIter = Iter<E>;\n-\n-    fn into_iter(self) -> Iter<E> {\n-        self.iter()\n-    }\n-}\n-\n-impl<E: CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item = E>>(&mut self, iter: I) {\n-        for element in iter {\n-            self.insert(element);\n-        }\n-    }\n-}\n-\n-impl<'a, E: 'a + CLike + Copy> Extend<&'a E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item = &'a E>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().cloned());\n-    }\n-}"}, {"sha": "8d056afdb571a4881ed1e86399fc3cc3294bbb06", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a76274e533969c8458c4471fbfc1b84ba44137e0/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76274e533969c8458c4471fbfc1b84ba44137e0/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a76274e533969c8458c4471fbfc1b84ba44137e0", "patch": "@@ -89,9 +89,6 @@ pub use btree_set::BTreeSet;\n #[doc(no_inline)]\n pub use linked_list::LinkedList;\n #[doc(no_inline)]\n-#[allow(deprecated)]\n-pub use enum_set::EnumSet;\n-#[doc(no_inline)]\n pub use vec_deque::VecDeque;\n #[doc(no_inline)]\n pub use string::String;\n@@ -107,7 +104,6 @@ mod macros;\n pub mod binary_heap;\n mod btree;\n pub mod borrow;\n-pub mod enum_set;\n pub mod fmt;\n pub mod linked_list;\n pub mod range;"}, {"sha": "ea154590deef0af432ff2ce192a7cb76ee60be33", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a76274e533969c8458c4471fbfc1b84ba44137e0/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76274e533969c8458c4471fbfc1b84ba44137e0/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=a76274e533969c8458c4471fbfc1b84ba44137e0", "patch": "@@ -10,13 +10,12 @@\n \n #![allow(warnings)]\n #![feature(collections)]\n-#![feature(drain, enumset, collections_bound, btree_range, vecmap)]\n+#![feature(drain, collections_bound, btree_range, vecmap)]\n \n extern crate collections;\n \n use collections::BinaryHeap;\n use collections::{BTreeMap, BTreeSet};\n-use collections::EnumSet;\n use collections::LinkedList;\n use collections::String;\n use collections::Vec;\n@@ -25,7 +24,6 @@ use std::collections::HashMap;\n use std::collections::HashSet;\n \n use collections::Bound::Included;\n-use collections::enum_set::CLike;\n use std::mem;\n \n fn is_sync<T>(_: T) where T: Sync {}\n@@ -76,21 +74,6 @@ fn main() {\n \n     all_sync_send!(LinkedList::<usize>::new(), iter, iter_mut, into_iter);\n \n-    #[derive(Copy, Clone)]\n-    #[repr(usize)]\n-    #[allow(dead_code)]\n-    enum Foo { A, B, C }\n-    impl CLike for Foo {\n-        fn to_usize(&self) -> usize {\n-            *self as usize\n-        }\n-\n-        fn from_usize(v: usize) -> Foo {\n-            unsafe { mem::transmute(v) }\n-        }\n-    }\n-    all_sync_send!(EnumSet::<Foo>::new(), iter);\n-\n     all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, into_iter);\n     is_sync_send!(VecDeque::<usize>::new(), drain(..));\n "}]}