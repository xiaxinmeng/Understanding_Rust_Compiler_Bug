{"sha": "050bd32958dac4413bfc1de0f48073dfbc06c278", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MGJkMzI5NThkYWM0NDEzYmZjMWRlMGY0ODA3M2RmYmMwNmMyNzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-18T00:19:26Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-05T07:40:40Z"}, "message": "resolve: Merge resolution for `macro_rules` into the common early in-scope resolution function\n\n`fn resolve_legacy_scope`/`fn resolve_lexical_macro_path_segment` -> `fn early_resolve_ident_in_lexical_scope`", "tree": {"sha": "068adc089c30e548f3abaacccb699f291a2ceb76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/068adc089c30e548f3abaacccb699f291a2ceb76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/050bd32958dac4413bfc1de0f48073dfbc06c278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/050bd32958dac4413bfc1de0f48073dfbc06c278", "html_url": "https://github.com/rust-lang/rust/commit/050bd32958dac4413bfc1de0f48073dfbc06c278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/050bd32958dac4413bfc1de0f48073dfbc06c278/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05a46815e4c54bffd95036249b080f293cd3acff", "url": "https://api.github.com/repos/rust-lang/rust/commits/05a46815e4c54bffd95036249b080f293cd3acff", "html_url": "https://github.com/rust-lang/rust/commit/05a46815e4c54bffd95036249b080f293cd3acff"}], "stats": {"total": 426, "additions": 173, "deletions": 253}, "files": [{"sha": "3a8e84a3280c6dd3ca30b17a74004a7926db0191", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=050bd32958dac4413bfc1de0f48073dfbc06c278", "patch": "@@ -10,6 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+bitflags = \"1.0\"\n log = \"0.4\"\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }"}, {"sha": "b41e9625e4e8765ff87bd9b312e29edc46a13755", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=050bd32958dac4413bfc1de0f48073dfbc06c278", "patch": "@@ -17,6 +17,8 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n \n+#[macro_use]\n+extern crate bitflags;\n #[macro_use]\n extern crate log;\n #[macro_use]\n@@ -1210,10 +1212,6 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn get_macro<'b: 'a>(&self, resolver: &mut Resolver<'a, 'b>) -> Lrc<SyntaxExtension> {\n-        resolver.get_macro(self.def_ignoring_ambiguity())\n-    }\n-\n     // We sometimes need to treat variants as `pub` for backwards compatibility\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() && self.def().def_id().is_local() {\n@@ -3664,8 +3662,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_scope, record_used,\n-                                                        record_used, path_span).map(|(b, _)| b)\n+                self.early_resolve_ident_in_lexical_scope(ident, ns, None, parent_scope,\n+                                                          record_used, record_used, path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };"}, {"sha": "6c067c669cb34b4a6c4df39b4f91fc3571d55ca8", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 132, "deletions": 228, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=050bd32958dac4413bfc1de0f48073dfbc06c278", "patch": "@@ -43,9 +43,6 @@ use std::cell::Cell;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n \n-#[derive(Clone, Copy)]\n-crate struct FromPrelude(bool);\n-\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     def_index: DefIndex,\n@@ -503,37 +500,36 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n+\n             parent_scope.module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n-            return def;\n-        }\n \n-        let result = if let Some(legacy_binding) = self.resolve_legacy_scope(path[0], Some(kind),\n-                                                                             parent_scope, false) {\n-            Ok(legacy_binding.def())\n+            def\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, Some(kind),\n-                                                          parent_scope, false, force, span) {\n-                Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n+            let def = match self.early_resolve_ident_in_lexical_scope(path[0], MacroNS, Some(kind),\n+                                                                      parent_scope, false, force,\n+                                                                      span) {\n+                Ok(binding) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n                     self.found_unresolved_macro = true;\n                     Err(Determinacy::Determined)\n                 }\n-            }\n-        };\n+            };\n \n-        parent_scope.module.legacy_macro_resolutions.borrow_mut()\n-            .push((path[0], kind, parent_scope.clone(), result.ok()));\n+            parent_scope.module.legacy_macro_resolutions.borrow_mut()\n+                .push((path[0], kind, parent_scope.clone(), def.ok()));\n \n-        result\n+            def\n+        }\n     }\n \n-    // Resolve the initial segment of a non-global macro path\n-    // (e.g. `foo` in `foo::bar!(); or `foo!();`).\n+    // Resolve an identifier in lexical scope.\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n-    crate fn resolve_lexical_macro_path_segment(\n+    // The function is used for resolving initial segments of macro paths (e.g. `foo` in\n+    // `foo::bar!(); or `foo!();`) and can be used for \"uniform path\" imports in the future.\n+    crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n@@ -542,7 +538,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         record_used: bool,\n         force: bool,\n         path_span: Span,\n-    ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n         //    built into the language or standard library. This way we can add new names into the\n@@ -565,30 +561,50 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         //    (open, not controlled).\n         // 3. Standard library prelude (de-facto closed, controlled).\n         // (Macro NS)\n-        // 0. Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and probably even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n-        // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 2. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 2a. User-defined prelude from macro-use\n+        // 1-2. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 3. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 3a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n-        // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n-        // 4. Language prelude: builtin attributes (closed, controlled).\n+        // 3b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+        // 3-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n+        //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n+        //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n         // N (unordered). Derive helpers (open, not controlled). All ambiguities with other names\n         //    are currently reported as errors. They should be higher in priority than preludes\n         //    and maybe even names in modules according to the \"general principles\" above. They\n         //    also should be subject to restricted shadowing because are effectively produced by\n         //    derives (you need to resolve the derive first to add helpers into scope), but they\n         //    should be available before the derive is expanded for compatibility.\n         //    It's mess in general, so we are being conservative for now.\n-        // N (unordered). Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n-        //    but introduced by legacy plugins using `register_attribute`.\n+\n+        enum WhereToResolve<'a> {\n+            MacroRules(LegacyScope<'a>),\n+            Module(Module<'a>),\n+            MacroUsePrelude,\n+            BuiltinMacros,\n+            BuiltinAttrs,\n+            DeriveHelpers,\n+            LegacyPluginHelpers,\n+            ExternPrelude,\n+            ToolPrelude,\n+            StdLibPrelude,\n+            BuiltinTypes,\n+        }\n+\n+        bitflags! {\n+            struct Flags: u8 {\n+                const DERIVE_HELPERS = 1 << 0;\n+                const MACRO_RULES    = 1 << 1;\n+                const MODULE         = 1 << 2;\n+                const PRELUDE        = 1 << 3;\n+            }\n+        }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n         ident = ident.modern();\n@@ -604,26 +620,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // }\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding, FromPrelude)> = None;\n-\n-        enum WhereToResolve<'a> {\n-            Module(Module<'a>),\n-            MacroUsePrelude,\n-            BuiltinMacros,\n-            BuiltinAttrs,\n-            DeriveHelpers,\n-            LegacyPluginHelpers,\n-            ExternPrelude,\n-            ToolPrelude,\n-            StdLibPrelude,\n-            BuiltinTypes,\n-        }\n+        let mut innermost_result: Option<(&NameBinding, Flags, /* conflicts with */ Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n+        let mut where_to_resolve = WhereToResolve::MacroRules(parent_scope.legacy);\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         loop {\n             let result = match where_to_resolve {\n+                WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                    LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n+                        Ok((legacy_binding.binding, Flags::MACRO_RULES, Flags::MODULE)),\n+                    _ => Err(Determinacy::Determined),\n+                }\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n                     let binding = self.resolve_ident_in_module_unadjusted(\n@@ -635,17 +643,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    binding.map(|binding| (binding, FromPrelude(false)))\n+                    binding.map(|binding| (binding, Flags::MODULE, Flags::empty()))\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n                     match self.macro_use_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, FromPrelude(true))),\n+                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, FromPrelude(true))),\n+                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n@@ -654,7 +662,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n+                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -671,7 +679,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                         (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                         ty::Visibility::Public, derive.span, Mark::root())\n                                         .to_name_binding(self.arenas);\n-                                    result = Ok((binding, FromPrelude(false)));\n+                                    result = Ok((binding, Flags::DERIVE_HELPERS, Flags::all()));\n                                     break;\n                                 }\n                             }\n@@ -685,7 +693,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(false)))\n+                        Ok((binding, Flags::PRELUDE, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -700,7 +708,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                         let binding = (crate_root, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n+                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -709,7 +717,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Def::ToolMod, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n+                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -726,26 +734,34 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 false,\n                                 path_span,\n                             ) {\n-                                result = Ok((binding, FromPrelude(true)));\n+                                result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n                             }\n                         }\n                     }\n                     result\n                 }\n                 WhereToResolve::BuiltinTypes => {\n-                    if let Some(prim_ty) =\n-                            self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n-                        let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n-                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, FromPrelude(true)))\n-                    } else {\n-                        Err(Determinacy::Determined)\n+                    match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n+                        Some(prim_ty) => {\n+                            let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n+                                           ident.span, Mark::root()).to_name_binding(self.arenas);\n+                            Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                        }\n+                        None => Err(Determinacy::Determined)\n                     }\n                 }\n             };\n \n             macro_rules! continue_search { () => {\n                 where_to_resolve = match where_to_resolve {\n+                    WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                        LegacyScope::Binding(binding) =>\n+                            WhereToResolve::MacroRules(binding.parent_legacy_scope),\n+                        LegacyScope::Invocation(invocation) =>\n+                            WhereToResolve::MacroRules(invocation.output_legacy_scope.get()),\n+                        LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n+                        LegacyScope::Uninitialized => unreachable!(),\n+                    }\n                     WhereToResolve::Module(module) => {\n                         match self.hygienic_lexical_parent(module, &mut ident.span) {\n                             Some(parent_module) => WhereToResolve::Module(parent_module),\n@@ -778,36 +794,33 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }}\n \n             match result {\n-                Ok(result) => {\n-                    if sub_namespace_mismatch(kind, result.0.macro_kind()) {\n+                Ok((binding, flags, ambig_flags)) => {\n+                    if sub_namespace_mismatch(kind, binding.macro_kind()) {\n                         continue_search!();\n                     }\n \n                     if !record_used {\n-                        return Ok(result);\n+                        return Ok(binding);\n                     }\n \n-                    if let Some(innermost_result) = innermost_result {\n+                    if let Some((innermost_binding, innermost_flags, innermost_ambig_flags))\n+                            = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n-                        let prohibit_ambiguities = |def| {\n-                            def == Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper) ||\n-                            def == Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper)\n-                        };\n-                        if result.0.def() != innermost_result.0.def() &&\n-                           (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.may_appear_after(parent_scope.expansion, result.0) ||\n-                            prohibit_ambiguities(innermost_result.0.def()) ||\n-                            prohibit_ambiguities(result.0.def())) {\n+                        if binding.def() != innermost_binding.def() &&\n+                           (innermost_binding.is_glob_import() ||\n+                            innermost_binding.may_appear_after(parent_scope.expansion, binding) ||\n+                            innermost_flags.intersects(ambig_flags) ||\n+                            flags.intersects(innermost_ambig_flags)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n-                                b1: innermost_result.0,\n-                                b2: result.0,\n+                                b1: innermost_binding,\n+                                b2: binding,\n                             });\n-                            return Ok(innermost_result);\n+                            return Ok(innermost_binding);\n                         }\n                     } else {\n                         // Found the first solution.\n-                        innermost_result = Some(result);\n+                        innermost_result = Some((binding, flags, ambig_flags));\n                     }\n \n                     continue_search!();\n@@ -820,8 +833,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         // The first found solution was the only one, return it.\n-        if let Some(innermost_result) = innermost_result {\n-            return Ok(innermost_result);\n+        if let Some((binding, ..)) = innermost_result {\n+            return Ok(binding);\n         }\n \n         let determinacy = Determinacy::determined(force);\n@@ -833,92 +846,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n                            ty::Visibility::Public, ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n-            Ok((binding, FromPrelude(true)))\n+            Ok(binding)\n         } else {\n             Err(determinacy)\n         }\n     }\n \n-    fn resolve_legacy_scope(\n-        &mut self,\n-        ident: Ident,\n-        kind: Option<MacroKind>,\n-        parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-    ) -> Option<&'a NameBinding<'a>> {\n-        if sub_namespace_mismatch(kind, Some(MacroKind::Bang)) {\n-            return None;\n-        }\n-\n-        let ident = ident.modern();\n-\n-        // This is *the* result, resolution from the scope closest to the resolved identifier.\n-        // However, sometimes this result is \"weak\" because it comes from a macro expansion,\n-        // and in this case it cannot shadow names from outer scopes, e.g.\n-        // macro_rules! m { ... } // solution in outer scope\n-        // {\n-        //     define_m!(); // generates another `macro_rules! m` - innermost solution\n-        //                  // weak, cannot shadow the outer `m`, need to report ambiguity error\n-        //     m!();\n-        // }\n-        // So we have to save the innermost solution and continue searching in outer scopes\n-        // to detect potential ambiguities.\n-        let mut innermost_result: Option<&NameBinding> = None;\n-\n-        // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = parent_scope.legacy;\n-        loop {\n-            let result = match where_to_resolve {\n-                LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n-                    Some(legacy_binding.binding),\n-                _ => None,\n-            };\n-\n-            macro_rules! continue_search { () => {\n-                where_to_resolve = match where_to_resolve {\n-                    LegacyScope::Empty => break, // nowhere else to search\n-                    LegacyScope::Binding(binding) => binding.parent_legacy_scope,\n-                    LegacyScope::Invocation(invocation) => invocation.output_legacy_scope.get(),\n-                    LegacyScope::Uninitialized => unreachable!(),\n-                };\n-\n-                continue;\n-            }}\n-\n-            match result {\n-                Some(result) => {\n-                    if !record_used {\n-                        return Some(result);\n-                    }\n-\n-                    if let Some(innermost_result) = innermost_result {\n-                        // Found another solution, if the first one was \"weak\", report an error.\n-                        if result.def() != innermost_result.def() &&\n-                           innermost_result.may_appear_after(parent_scope.expansion, result) {\n-                            self.ambiguity_errors.push(AmbiguityError {\n-                                ident,\n-                                b1: innermost_result,\n-                                b2: result,\n-                            });\n-                            return Some(innermost_result);\n-                        }\n-                    } else {\n-                        // Found the first solution.\n-                        innermost_result = Some(result);\n-                    }\n-\n-                    continue_search!();\n-                }\n-                None => {\n-                    continue_search!();\n-                }\n-            }\n-        }\n-\n-        // The first found solution was the only one (or there was no solution at all), return it.\n-        innermost_result\n-    }\n-\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n@@ -933,80 +866,51 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         let legacy_macro_resolutions =\n             mem::replace(&mut *module.legacy_macro_resolutions.borrow_mut(), Vec::new());\n-        for (ident, kind, parent_scope, def) in legacy_macro_resolutions {\n-            let span = ident.span;\n-            let legacy_resolution = self.resolve_legacy_scope(\n-                ident, Some(kind), &parent_scope, true\n+        for (ident, kind, parent_scope, initial_def) in legacy_macro_resolutions {\n+            let binding = self.early_resolve_ident_in_lexical_scope(\n+                ident, MacroNS, Some(kind), &parent_scope, true, true, ident.span\n             );\n-            let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, Some(kind), &parent_scope, true, true, span\n-            );\n-\n-            let check_consistency = |this: &Self, new_def: Def| {\n-                if let Some(def) = def {\n-                    if this.ambiguity_errors.is_empty() && new_def != def && new_def != Def::Err {\n-                        // Make sure compilation does not succeed if preferred macro resolution\n-                        // has changed after the macro had been expanded. In theory all such\n-                        // situations should be reported as ambiguity errors, so this is span-bug.\n-                        span_bug!(span, \"inconsistent resolution for a macro\");\n+            match binding {\n+                Ok(binding) => {\n+                    self.record_use(ident, MacroNS, binding);\n+                    let def = binding.def_ignoring_ambiguity();\n+                    if let Some(initial_def) = initial_def {\n+                        if self.ambiguity_errors.is_empty() &&\n+                           def != initial_def && def != Def::Err {\n+                            // Make sure compilation does not succeed if preferred macro resolution\n+                            // has changed after the macro had been expanded. In theory all such\n+                            // situations should be reported as ambiguity errors, so this is a bug.\n+                            span_bug!(ident.span, \"inconsistent resolution for a macro\");\n+                        }\n+                    } else {\n+                        // It's possible that the macro was unresolved (indeterminate) and silently\n+                        // expanded into a dummy fragment for recovery during expansion.\n+                        // Now, post-expansion, the resolution may succeed, but we can't change the\n+                        // past and need to report an error.\n+                        let msg = format!(\"cannot determine resolution for the {} `{}`\",\n+                                          kind.descr(), ident);\n+                        let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n+                        self.session.struct_span_err(ident.span, &msg).note(msg_note).emit();\n                     }\n-                } else {\n-                    // It's possible that the macro was unresolved (indeterminate) and silently\n-                    // expanded into a dummy fragment for recovery during expansion.\n-                    // Now, post-expansion, the resolution may succeed, but we can't change the\n-                    // past and need to report an error.\n-                    let msg =\n-                        format!(\"cannot determine resolution for the {} `{}`\", kind.descr(), ident);\n-                    let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n                 }\n-            };\n-\n-            match (legacy_resolution, resolution) {\n-                (None, Err(_)) => {\n-                    assert!(def.is_none());\n+                Err(..) => {\n+                    assert!(initial_def.is_none());\n                     let bang = if kind == MacroKind::Bang { \"!\" } else { \"\" };\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n-                    let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n+                    let mut err = self.session.struct_span_err(ident.span, &msg);\n+                    self.suggest_macro_name(&ident.as_str(), kind, &mut err, ident.span);\n                     err.emit();\n-                },\n-                (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n-                        if legacy_binding.def() != binding.def_ignoring_ambiguity() &&\n-                           (!from_prelude &&\n-                            !self.disambiguate_legacy_vs_modern(legacy_binding, binding) ||\n-                            legacy_binding.may_appear_after(parent_scope.expansion, binding)) => {\n-                    self.report_ambiguity_error(ident, legacy_binding, binding);\n-                },\n-                // OK, non-macro-expanded legacy wins over prelude even if defs are different\n-                // Also, non-macro-expanded legacy wins over modern from the same module\n-                // Also, legacy and modern can co-exist if their defs are same\n-                (Some(legacy_binding), Ok(_)) |\n-                // OK, unambiguous resolution\n-                (Some(legacy_binding), Err(_)) => {\n-                    check_consistency(self, legacy_binding.def());\n                 }\n-                // OK, unambiguous resolution\n-                (None, Ok((binding, FromPrelude(from_prelude)))) => {\n-                    check_consistency(self, binding.def_ignoring_ambiguity());\n-                    if from_prelude {\n-                        self.record_use(ident, MacroNS, binding);\n-                    }\n-                }\n-            };\n+            }\n         }\n \n         let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n         for (ident, parent_scope) in builtin_attrs {\n-            let resolve_legacy = |this: &mut Self| this.resolve_legacy_scope(\n-                ident, Some(MacroKind::Attr), &parent_scope, true\n-            );\n-            let resolve_modern = |this: &mut Self| this.resolve_lexical_macro_path_segment(\n+            let binding = self.early_resolve_ident_in_lexical_scope(\n                 ident, MacroNS, Some(MacroKind::Attr), &parent_scope, true, true, ident.span\n-            ).map(|(binding, _)| binding).ok();\n-\n-            if let Some(binding) = resolve_legacy(self).or_else(|| resolve_modern(self)) {\n+            );\n+            if let Ok(binding) = binding {\n                 if binding.def_ignoring_ambiguity() !=\n                         Def::NonMacroAttr(NonMacroAttrKind::Builtin) {\n                     let builtin_binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),"}, {"sha": "6e9877b1ab66d2591c385991b07e7013bc6dd414", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=050bd32958dac4413bfc1de0f48073dfbc06c278", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         // expansion. With restricted shadowing names from globs and macro expansions cannot\n         // shadow names from outer scopes, so we can freely fallback from module search to search\n         // in outer scopes. To continue search in outer scopes we have to lie a bit and return\n-        // `Determined` to `resolve_lexical_macro_path_segment` even if the correct answer\n+        // `Determined` to `early_resolve_ident_in_lexical_scope` even if the correct answer\n         // for in-module resolution could be `Undetermined`.\n         if restricted_shadowing {\n             return Err(Determined);"}, {"sha": "965b23e1a5c9ffe0ec7f2b665b04c8276bb4a320", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=050bd32958dac4413bfc1de0f48073dfbc06c278", "patch": "@@ -34,6 +34,23 @@ LL |     use two_macros::m;\n    |         ^^^^^^^^^^^^^\n    = note: macro-expanded macro imports do not shadow\n \n-error: aborting due to 2 previous errors\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/macros.rs:48:5\n+   |\n+LL |     m!(); //~ ERROR ambiguous\n+   |     ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/macros.rs:46:5\n+   |\n+LL |     macro_rules! m { () => {} }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: `m` could also refer to the name imported here\n+  --> $DIR/macros.rs:47:9\n+   |\n+LL |     use two_macros::m;\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "7e5ab0c5abe07596fa3cfaac5249cd1f18b62b47", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/050bd32958dac4413bfc1de0f48073dfbc06c278/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=050bd32958dac4413bfc1de0f48073dfbc06c278", "patch": "@@ -1,20 +1,3 @@\n-error[E0659]: `panic` is ambiguous\n-  --> $DIR/shadow_builtin_macros.rs:43:5\n-   |\n-LL |     panic!(); //~ ERROR `panic` is ambiguous\n-   |     ^^^^^ ambiguous name\n-   |\n-note: `panic` could refer to the name defined here\n-  --> $DIR/shadow_builtin_macros.rs:40:9\n-   |\n-LL |         macro_rules! panic { () => {} }\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |     } }\n-LL |     m!();\n-   |     ----- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n-\n error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:25:14\n    |\n@@ -43,6 +26,23 @@ LL |     ::two_macros::m!(use foo::panic;);\n    = note: `panic` is also a builtin macro\n    = note: macro-expanded macro imports do not shadow\n \n+error[E0659]: `panic` is ambiguous\n+  --> $DIR/shadow_builtin_macros.rs:43:5\n+   |\n+LL |     panic!(); //~ ERROR `panic` is ambiguous\n+   |     ^^^^^ ambiguous name\n+   |\n+note: `panic` could refer to the name defined here\n+  --> $DIR/shadow_builtin_macros.rs:40:9\n+   |\n+LL |         macro_rules! panic { () => {} }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     } }\n+LL |     m!();\n+   |     ----- in this macro invocation\n+   = note: `panic` is also a builtin macro\n+   = note: macro-expanded macros do not shadow\n+\n error[E0659]: `n` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:59:5\n    |"}]}