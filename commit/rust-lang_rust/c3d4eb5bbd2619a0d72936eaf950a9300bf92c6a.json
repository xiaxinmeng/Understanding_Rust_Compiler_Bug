{"sha": "c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZDRlYjViYmQyNjE5YTBkNzI5MzZlYWY5NTBhOTMwMGJmOTJjNmE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-27T05:39:40Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-27T13:25:56Z"}, "message": "Merge branch 'pr-228'\n\nConflicts:\n\tREADME.md\n\tsrc/methods.rs", "tree": {"sha": "1e2fc2f70166b56c6a26dfbe2eb71bcba7fdd7e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2fc2f70166b56c6a26dfbe2eb71bcba7fdd7e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "html_url": "https://github.com/rust-lang/rust/commit/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac8ab4eb8e6319f91619173868c1a40997e36f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8ab4eb8e6319f91619173868c1a40997e36f9f", "html_url": "https://github.com/rust-lang/rust/commit/ac8ab4eb8e6319f91619173868c1a40997e36f9f"}, {"sha": "56e8db476c437590f21be041c0e751ee185d8dd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e8db476c437590f21be041c0e751ee185d8dd0", "html_url": "https://github.com/rust-lang/rust/commit/56e8db476c437590f21be041c0e751ee185d8dd0"}], "stats": {"total": 376, "additions": 230, "deletions": 146}, "files": [{"sha": "478bb25272f9cfde1b2280bb9d7c68a40ed9dbc9", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 48 lints included in this crate:\n+There are 49 lints included in this crate:\n \n name                                                                                                 | default | meaning\n -----------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -47,6 +47,7 @@ name\n [shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                         | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                           | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                 | warn    | The name is re-bound without even using the original value\n+[should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)     | warn    | defining a method that should be implementing a std trait\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n [str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                       | warn    | using `to_string()` on a str, which should be `to_owned()`\n [string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                             | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead"}, {"sha": "d307c7dd0563d648891268ea87d1051b42359cbe", "filename": "src/approx_const.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -3,7 +3,7 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use std::f64::consts as f64;\n \n-use utils::span_help_and_lint;\n+use utils::span_lint;\n \n declare_lint! {\n     pub APPROX_CONSTANT,\n@@ -40,7 +40,7 @@ fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n     match lit.node {\n         LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n         LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        LitFloatUnsuffixed(ref str) => \n+        LitFloatUnsuffixed(ref str) =>\n             check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n@@ -50,18 +50,16 @@ fn check_known_consts(cx: &Context, span: Span, str: &str, module: &str) {\n     if let Ok(value) = str.parse::<f64>() {\n         for &(constant, name) in KNOWN_CONSTS {\n             if within_epsilon(constant, value) {\n-                span_help_and_lint(cx, APPROX_CONSTANT, span, &format!(\n+                span_lint(cx, APPROX_CONSTANT, span, &format!(\n                     \"approximate value of `{}::{}` found. \\\n-                    Consider using it directly\", module, &name),\n-                    \"for further information see https://github.com/\\\n-                     Manishearth/rust-clippy/wiki#approx_constant\");\n+                    Consider using it directly\", module, &name));\n             }\n         }\n     }\n }\n \n fn within_epsilon(target: f64, value: f64) -> bool {\n-    f64::abs(value - target) < f64::abs(if target > value { \n-                                            target \n+    f64::abs(value - target) < f64::abs(if target > value {\n+                                            target\n                                         } else { value }) / EPSILON_DIVISOR\n }"}, {"sha": "ad021f28a4d67ef45f43044c76ea6dab12b7ba2c", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -4,7 +4,7 @@ use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, match_path, span_help_and_lint};\n+use utils::{in_macro, match_path, span_lint};\n \n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"`#[inline(always)]` is a bad idea in most cases\" }\n@@ -98,12 +98,10 @@ fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n             if values.len() != 1 || inline != &\"inline\" { continue; }\n             if let MetaWord(ref always) = values[0].node {\n                 if always != &\"always\" { continue; }\n-                span_help_and_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n+                span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n                     \"you have declared `#[inline(always)]` on `{}`. This \\\n                      is usually a bad idea. Are you sure?\",\n-                    ident.name),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#inline_always\");\n+                    ident.name));\n             }\n         }\n     }"}, {"sha": "465b772da5cee43eb126f92382ade403023761fe", "filename": "src/bit_mask.rs", "status": "modified", "additions": 20, "deletions": 45, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -5,7 +5,7 @@ use syntax::ast::*;\n use syntax::ast_util::is_comparison_binop;\n use syntax::codemap::Span;\n \n-use utils::span_help_and_lint;\n+use utils::span_lint;\n \n declare_lint! {\n     pub BAD_BIT_MASK,\n@@ -100,50 +100,36 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         BiEq | BiNe => match bit_op {\n             BiBitAnd => if mask_value & cmp_value != mask_value {\n                 if cmp_value != 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                         \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                        mask_value, cmp_value),\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                        mask_value, cmp_value));\n                 }\n             } else {\n                 if mask_value == 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span, \n-                        \"&-masking with zero\",\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                 }\n             },\n             BiBitOr => if mask_value | cmp_value != cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             },\n             _ => ()\n         },\n         BiLt | BiGe => match bit_op {\n             BiBitAnd => if mask_value < cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 if mask_value == 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span,\n-                        \"&-masking with zero\",\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                 }\n             },\n             BiBitOr => if mask_value >= cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n             },\n@@ -153,25 +139,18 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         },\n         BiLe | BiGt => match bit_op {\n             BiBitAnd => if mask_value <= cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 if mask_value == 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span, \n-                        \"&-masking with zero\",\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                 }\n             },\n             BiBitOr => if mask_value > cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n             },\n@@ -185,21 +164,17 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n \n fn check_ineffective_lt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n     if c.is_power_of_two() && m < c {\n-        span_help_and_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n+        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n+            op, m, c));\n     }\n }\n \n fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n-        span_help_and_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n+        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n+            op, m, c));\n     }\n }\n "}, {"sha": "32fc953d1c3230adcbb3e2bf7a14ef4b870a0557", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -100,6 +100,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n+        methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n         misc::CMP_NAN,"}, {"sha": "50f3512b4f00347702c3d856c7360cd38001110b", "filename": "src/methods.rs", "status": "modified", "additions": 116, "deletions": 2, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -4,9 +4,12 @@ use rustc::middle::ty;\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, match_type, walk_ptrs_ty_depth};\n+use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n+use self::SelfKind::*;\n+use self::OutType::*;\n+\n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n \n@@ -18,10 +21,13 @@ declare_lint!(pub STR_TO_STRING, Warn,\n               \"using `to_string()` on a str, which should be `to_owned()`\");\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n+declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n+              \"defining a method that should be implementing a std trait\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n+        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n+                    SHOULD_IMPLEMENT_TRAIT)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -57,4 +63,112 @@ impl LintPass for MethodsPass {\n             }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        if let ItemImpl(_, _, _, None, _, ref items) = item.node {\n+            for item in items {\n+                let name = item.ident.name;\n+                for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                    if_let_chain! {\n+                        [\n+                            name == method_name,\n+                            let MethodImplItem(ref sig, _) = item.node,\n+                            sig.decl.inputs.len() == n_args,\n+                            out_type.matches(&sig.decl.output),\n+                            self_kind.matches(&sig.explicit_self.node)\n+                        ], {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, item.span, &format!(\n+                                \"defining a method called `{}` on this type; consider implementing \\\n+                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n+    (\"add\",        2, ValueSelf,  AnyType,  \"std::ops::Add`\"),\n+    (\"sub\",        2, ValueSelf,  AnyType,  \"std::ops::Sub\"),\n+    (\"mul\",        2, ValueSelf,  AnyType,  \"std::ops::Mul\"),\n+    (\"div\",        2, ValueSelf,  AnyType,  \"std::ops::Div\"),\n+    (\"rem\",        2, ValueSelf,  AnyType,  \"std::ops::Rem\"),\n+    (\"shl\",        2, ValueSelf,  AnyType,  \"std::ops::Shl\"),\n+    (\"shr\",        2, ValueSelf,  AnyType,  \"std::ops::Shr\"),\n+    (\"bitand\",     2, ValueSelf,  AnyType,  \"std::ops::BitAnd\"),\n+    (\"bitor\",      2, ValueSelf,  AnyType,  \"std::ops::BitOr\"),\n+    (\"bitxor\",     2, ValueSelf,  AnyType,  \"std::ops::BitXor\"),\n+    (\"neg\",        1, ValueSelf,  AnyType,  \"std::ops::Neg\"),\n+    (\"not\",        1, ValueSelf,  AnyType,  \"std::ops::Not\"),\n+    (\"drop\",       1, RefMutSelf, UnitType, \"std::ops::Drop\"),\n+    (\"index\",      2, RefSelf,    RefType,  \"std::ops::Index\"),\n+    (\"index_mut\",  2, RefMutSelf, RefType,  \"std::ops::IndexMut\"),\n+    (\"deref\",      1, RefSelf,    RefType,  \"std::ops::Deref\"),\n+    (\"deref_mut\",  1, RefMutSelf, RefType,  \"std::ops::DerefMut\"),\n+    (\"clone\",      1, RefSelf,    AnyType,  \"std::clone::Clone\"),\n+    (\"borrow\",     1, RefSelf,    RefType,  \"std::borrow::Borrow\"),\n+    (\"borrow_mut\", 1, RefMutSelf, RefType,  \"std::borrow::BorrowMut\"),\n+    (\"as_ref\",     1, RefSelf,    RefType,  \"std::convert::AsRef\"),\n+    (\"as_mut\",     1, RefMutSelf, RefType,  \"std::convert::AsMut\"),\n+    (\"eq\",         2, RefSelf,    BoolType, \"std::cmp::PartialEq\"),\n+    (\"cmp\",        2, RefSelf,    AnyType,  \"std::cmp::Ord\"),\n+    (\"default\",    0, NoSelf,     AnyType,  \"std::default::Default\"),\n+    (\"hash\",       2, RefSelf,    UnitType, \"std::hash::Hash\"),\n+    (\"next\",       1, RefMutSelf, AnyType,  \"std::iter::Iterator\"),\n+    (\"into_iter\",  1, ValueSelf,  AnyType,  \"std::iter::IntoIterator\"),\n+    (\"from_iter\",  1, NoSelf,     AnyType,  \"std::iter::FromIterator\"),\n+    (\"from_str\",   1, NoSelf,     AnyType,  \"std::str::FromStr\"),\n+];\n+\n+#[derive(Clone, Copy)]\n+enum SelfKind {\n+    ValueSelf,\n+    RefSelf,\n+    RefMutSelf,\n+    NoSelf\n+}\n+\n+impl SelfKind {\n+    fn matches(&self, slf: &ExplicitSelf_) -> bool {\n+        match (self, slf) {\n+            (&ValueSelf, &SelfValue(_)) => true,\n+            (&RefSelf, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n+            (&RefMutSelf, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n+            (&NoSelf, &SelfStatic) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum OutType {\n+    UnitType,\n+    BoolType,\n+    AnyType,\n+    RefType,\n+}\n+\n+impl OutType {\n+    fn matches(&self, ty: &FunctionRetTy) -> bool {\n+        match (self, ty) {\n+            (&UnitType, &DefaultReturn(_)) => true,\n+            (&UnitType, &Return(ref ty)) if ty.node == TyTup(vec![]) => true,\n+            (&BoolType, &Return(ref ty)) if is_bool(ty) => true,\n+            (&AnyType, &Return(ref ty)) if ty.node != TyTup(vec![])  => true,\n+            (&RefType, &Return(ref ty)) => {\n+                if let TyRptr(_, _) = ty.node { true } else { false }\n+            }\n+            _ => false\n+        }\n+    }\n+}\n+\n+fn is_bool(ty: &Ty) -> bool {\n+    if let TyPath(None, ref p) = ty.node {\n+        if match_path(p, &[\"bool\"]) {\n+            return true;\n+        }\n+    }\n+    false\n }"}, {"sha": "6e4384072169b2639ff210161c0b29f12e75f85a", "filename": "src/misc.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -6,7 +6,7 @@ use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n \n-use utils::{match_path, snippet, span_lint, span_help_and_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n use consts::constant;\n \n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n@@ -65,10 +65,8 @@ impl LintPass for CmpNan {\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n     path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n-        span_help_and_lint(cx, CMP_NAN, span,\n-            \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#cmp_nan\");\n+        span_lint(cx, CMP_NAN, span,\n+            \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n     });\n }\n \n@@ -126,11 +124,9 @@ impl LintPass for Precedence {\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n-                span_help_and_lint(cx, PRECEDENCE, expr.span,\n+                span_lint(cx, PRECEDENCE, expr.span,\n                     \"operator precedence can trip the unwary. Consider adding parentheses \\\n-                     to the subexpression\",\n-                    \"for further information see https://github.com/\\\n-                     Manishearth/rust-clippy/wiki#precedence\");\n+                     to the subexpression\");\n             }\n         }\n     }"}, {"sha": "eba7a9da1875888b087c7fe3531c72a0a807a9e8", "filename": "src/shadow.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -6,7 +6,7 @@ use syntax::visit::FnKind;\n use rustc::lint::{Context, LintArray, LintPass};\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{in_external_macro, snippet, span_help_and_lint};\n+use utils::{in_external_macro, snippet, span_lint};\n \n declare_lint!(pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n@@ -72,7 +72,7 @@ fn is_binding(cx: &Context, pat: &Pat) -> bool {\n     }\n }\n \n-fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,  \n+fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n         bindings: &mut Vec<Name>) where T: Deref<Target=Expr> {\n     //TODO: match more stuff / destructuring\n     match pat.node {\n@@ -94,7 +94,7 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n         PatBox(ref inner) => {\n             if let Some(ref initp) = *init {\n                 match initp.node {\n-                    ExprBox(_, ref inner_init) => \n+                    ExprBox(_, ref inner_init) =>\n                         check_pat(cx, inner, &Some(&**inner_init), span, bindings),\n                     //TODO: ExprCall on Box::new\n                     _ => check_pat(cx, inner, init, span, bindings),\n@@ -110,38 +110,30 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n     }\n }\n \n-fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init: \n+fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n         &Option<T>) where T: Deref<Target=Expr> {\n     if let &Some(ref expr) = init {\n         if is_self_shadow(name, expr) {\n-            span_help_and_lint(cx, SHADOW_SAME, span, &format!(\n+            span_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n-                snippet(cx, expr.span, \"..\")),\n-                \"for further information see \\\n-                https://github.com/Manishearth/rust-clippy/wiki#shadow_same\");\n+                snippet(cx, expr.span, \"..\")));\n         } else {\n             if contains_self(name, expr) {\n-                span_help_and_lint(cx, SHADOW_REUSE, span, &format!(\n+                span_lint(cx, SHADOW_REUSE, span, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")),\n-                    \"for further information see https://\\\n-                    github.com/Manishearth/rust-clippy/wiki#shadow_reuse\");\n+                    snippet(cx, expr.span, \"..\")));\n             } else {\n-                span_help_and_lint(cx, SHADOW_UNRELATED, span, &format!(\n+                span_lint(cx, SHADOW_UNRELATED, span, &format!(\n                     \"{} is shadowed by {} in this declaration\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")),\n-                    \"for further information see https://github.com\\\n-                    /Manishearth/rust-clippy/wiki#shadow_unrelated\");\n+                    snippet(cx, expr.span, \"..\")));\n             }\n         }\n     } else {\n-        span_help_and_lint(cx, SHADOW_UNRELATED, span, &format!(\n-            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")),\n-            \"for further information see \\\n-            https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated\");\n+        span_lint(cx, SHADOW_UNRELATED, span, &format!(\n+            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")));\n     }\n }\n \n@@ -218,7 +210,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && \n+    !path.global && path.segments.len() == 1 &&\n         path.segments[0].identifier.name == name\n }\n \n@@ -242,8 +234,8 @@ fn contains_self(name: Name, expr: &Expr) -> bool {\n             otherwise.as_ref().map_or(false, |ref e| contains_self(name, e)),\n         ExprWhile(ref e, ref block, _)  =>\n             contains_self(name, e) || contains_block_self(name, block),\n-        ExprMatch(ref e, ref arms, _) => \n-            arms.iter().any(|ref arm| arm.pats.iter().any(|ref pat| \n+        ExprMatch(ref e, ref arms, _) =>\n+            arms.iter().any(|ref arm| arm.pats.iter().any(|ref pat|\n                 contains_pat_self(name, pat))) || contains_self(name, e),\n         ExprPath(_, ref path) => path_eq_name(name, path),\n         _ => false\n@@ -274,18 +266,18 @@ fn contains_pat_self(name: Name, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, ref ident, ref inner) => name == ident.node.name ||\n             inner.as_ref().map_or(false, |ref p| contains_pat_self(name, p)),\n-        PatEnum(_, ref opats) => opats.as_ref().map_or(false, \n+        PatEnum(_, ref opats) => opats.as_ref().map_or(false,\n             |pats| pats.iter().any(|p| contains_pat_self(name, p))),\n         PatQPath(_, ref path) => path_eq_name(name, path),\n         PatStruct(_, ref fieldpats, _) => fieldpats.iter().any(\n             |ref fp| contains_pat_self(name, &fp.node.pat)),\n         PatTup(ref ps) => ps.iter().any(|ref p| contains_pat_self(name, p)),\n         PatBox(ref p) |\n         PatRegion(ref p, _) => contains_pat_self(name, p),\n-        PatRange(ref from, ref until) => \n+        PatRange(ref from, ref until) =>\n             contains_self(name, from) || contains_self(name, until),\n         PatVec(ref pre, ref opt, ref post) =>\n-            pre.iter().any(|ref p| contains_pat_self(name, p)) || \n+            pre.iter().any(|ref p| contains_pat_self(name, p)) ||\n                 opt.as_ref().map_or(false, |ref p| contains_pat_self(name, p)) ||\n                 post.iter().any(|ref p| contains_pat_self(name, p)),\n         _ => false,"}, {"sha": "fc8a2d238bb3d0f5987ae293242c38b6131bb293", "filename": "src/strings.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -8,7 +8,7 @@ use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_type, span_help_and_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n declare_lint! {\n@@ -45,19 +45,15 @@ impl LintPass for StringAdd {\n                         }\n                     }\n                 }\n-                span_help_and_lint(cx, STRING_ADD, e.span,\n+                span_lint(cx, STRING_ADD, e.span,\n                     \"you added something to a string. \\\n-                     Consider using `String::push_str()` instead\",\n-                    \"for further information see https://github.com/\\\n-                     Manishearth/rust-clippy/wiki#string_add\")\n+                     Consider using `String::push_str()` instead\")\n             }\n         } else if let &ExprAssign(ref target, ref  src) = &e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n-                span_help_and_lint(cx, STRING_ADD_ASSIGN, e.span,\n+                span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n-                     Consider using `String::push_str()` instead\",\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#string_add_assign\")\n+                     Consider using `String::push_str()` instead\")\n             }\n         }\n     }"}, {"sha": "3c4d1441f177e1fb4aa2a8ce1b76a77607963c17", "filename": "src/types.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -31,17 +31,14 @@ impl LintPass for TypePass {\n                     span_help_and_lint(\n                         cx, BOX_VEC, ast_ty.span,\n                         \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation. \\\n-                         for further information see https://github.com/\\\n-                         Manishearth/rust-clippy/wiki#box_vec\");\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                 }\n             }\n             else if match_type(cx, ty, &LL_PATH) {\n                 span_help_and_lint(\n                     cx, LINKEDLIST, ast_ty.span,\n                     \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                    \"a RingBuf might work; for further information see \\\n-                     https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n+                    \"a RingBuf might work\");\n             }\n         }\n     }\n@@ -141,15 +138,12 @@ fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast\n     let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n                          else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n                          else {int_ty_to_nbits(cast_from).to_string()};\n-    span_help_and_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n         &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n             ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n             cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n             if arch_dependent {arch_dependent_str} else {\"\"},\n-            from_nbits_str,\n-            mantissa_nbits),\n-        \"for further information see https://github.com/\\\n-        Manishearth/rust-clippy/wiki#cast_precision_loss\");\n+            from_nbits_str, mantissa_nbits));\n }\n \n enum ArchSuffix {\n@@ -183,26 +177,22 @@ fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS,\n                 ),\n         };\n     if span_truncation {\n-        span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n             &format!(\"casting {} to {} may truncate the value{}\",\n                cast_from, cast_to,\n                match suffix_truncation {\n                    ArchSuffix::_32 => arch_32_suffix,\n                    ArchSuffix::_64 => arch_64_suffix,\n-                   ArchSuffix::None => \"\" }),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n+                   ArchSuffix::None => \"\" }));\n     }\n     if span_wrap {\n-        span_help_and_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n             &format!(\"casting {} to {} may wrap around the value{}\",\n                 cast_from, cast_to,\n                 match suffix_wrap {\n                     ArchSuffix::_32 => arch_32_suffix,\n                     ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\" }),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#cast_possible_wrap\");\n+                    ArchSuffix::None => \"\" }));\n     }\n }\n \n@@ -227,37 +217,29 @@ impl LintPass for CastPass {\n                         }\n                     },\n                     (false, true) => {\n-                        span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                            &format!(\"casting {} to {} may truncate the value\", \n-                                  cast_from, cast_to),\n-                            \"for further information see https://github.com/\\\n-                            Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n+                        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                            &format!(\"casting {} to {} may truncate the value\",\n+                                  cast_from, cast_to));\n                         if !cast_to.is_signed() {\n-                            span_help_and_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\", \n-                                    cast_from, cast_to),\n-                                \"for further information see https://github.com/\\\n-                                Manishearth/rust-clippy/wiki#cast_sign_loss\");\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\",\n+                                    cast_from, cast_to));\n                         }\n                     },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n-                            span_help_and_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\", \n-                                    cast_from, cast_to),\n-                                \"for further information see https://github.com/\\\n-                                Manishearth/rust-clippy/wiki#cast_sign_loss\");\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\",\n+                                    cast_from, cast_to));\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n                         if let (&ty::TyFloat(ast::TyF64),\n                                 &ty::TyFloat(ast::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, \n-                                expr.span, \n-                                \"casting f64 to f32 may truncate the value\",\n-                                \"for further information see https://github.com/\\\n-                                Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n+                            span_lint(cx, CAST_POSSIBLE_TRUNCATION,\n+                                expr.span,\n+                                \"casting f64 to f32 may truncate the value\");\n                         }\n                     }\n                 }"}, {"sha": "69f5e22c48feaf2ecb5f83eadf6044ba045e0279", "filename": "src/utils.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -141,6 +141,11 @@ pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n #[cfg(not(feature=\"structured_logging\"))]\n pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     cx.span_lint(lint, sp, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            lint.name_lower()))\n+    }\n }\n \n #[cfg(feature=\"structured_logging\")]\n@@ -149,13 +154,20 @@ pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     // cx.sess().codemap() has all these nice functions for line/column/snippet details\n     // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n     cx.span_lint(lint, sp, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            lint.name_lower()))\n+    }\n }\n \n pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n         msg: &str, help: &str) {\n     span_lint(cx, lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(span, help);\n+        cx.sess().fileline_help(span, &format!(\"{}\\nfor further information \\\n+            visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            help, lint.name_lower()))\n     }\n }\n "}, {"sha": "05f77c1511e8c5e73bf9998f0ec996784dee9f63", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=c3d4eb5bbd2619a0d72936eaf950a9300bf92c6a", "patch": "@@ -1,8 +1,27 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#[deny(option_unwrap_used, result_unwrap_used)]\n-#[deny(str_to_string, string_to_string)]\n+#![allow(unused)]\n+#![deny(clippy)]\n+\n+use std::ops::Mul;\n+\n+struct T;\n+\n+impl T {\n+    fn add(self, other: T) -> T { self } //~ERROR defining a method called `add`\n+    fn drop(&mut self) { } //~ERROR defining a method called `drop`\n+\n+    fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+    fn div(self) -> T { self } // no error, different #arguments\n+    fn rem(self, other: T) { } // no error, wrong return type\n+}\n+\n+impl Mul<T> for T {\n+    type Output = T;\n+    fn mul(self, other: T) -> T { self } // no error, obviously\n+}\n+\n fn main() {\n     let opt = Some(0);\n     let _ = opt.unwrap();  //~ERROR used unwrap() on an Option"}]}