{"sha": "433024147ae1e9795fe7e94cb1810a17fd37fa51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMzAyNDE0N2FlMWU5Nzk1ZmU3ZTk0Y2IxODEwYTE3ZmQzN2ZhNTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T21:24:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-24T09:29:44Z"}, "message": "syntax_ext: Turn `#[global_allocator]` into a regular attribute macro", "tree": {"sha": "3afa866aa7a338c7f04dc6da7ac4798d9584e2c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3afa866aa7a338c7f04dc6da7ac4798d9584e2c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/433024147ae1e9795fe7e94cb1810a17fd37fa51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/433024147ae1e9795fe7e94cb1810a17fd37fa51", "html_url": "https://github.com/rust-lang/rust/commit/433024147ae1e9795fe7e94cb1810a17fd37fa51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/433024147ae1e9795fe7e94cb1810a17fd37fa51/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a93fdfedf36dcb909d90cbf963b087c5873bec1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a93fdfedf36dcb909d90cbf963b087c5873bec1d", "html_url": "https://github.com/rust-lang/rust/commit/a93fdfedf36dcb909d90cbf963b087c5873bec1d"}], "stats": {"total": 440, "additions": 205, "deletions": 235}, "files": [{"sha": "17781798946ed8d71f86b467ca18e09208a619ef", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -1281,6 +1281,13 @@ mod builtin {\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n+    /// Attribute macro applied to a static to register it as a global allocator.\n+    #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n+    #[allow_internal_unstable(rustc_attrs)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro global_allocator($item:item) { /* compiler built-in */ }\n+\n     /// Derive macro generating an impl of the trait `Clone`.\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]"}, {"sha": "88de77829a6e06fc28da53a50f331fd61fec1b5a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -320,11 +320,6 @@ fn has_allow_dead_code_or_lang_attr(\n         return true;\n     }\n \n-    // Don't lint about global allocators\n-    if attr::contains_name(attrs, sym::global_allocator) {\n-        return true;\n-    }\n-\n     let def_id = tcx.hir().local_def_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n "}, {"sha": "b460a908f1b129d7fc61b3c173d6f37dd1de0848", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -468,7 +468,7 @@ fn configure_and_expand_inner<'a>(\n         util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n     }\n \n-    let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n+    let has_proc_macro_decls = time(sess, \"AST validation\", || {\n         ast_validation::check_crate(sess, &krate)\n     });\n \n@@ -494,19 +494,6 @@ fn configure_and_expand_inner<'a>(\n         });\n     }\n \n-    if has_global_allocator {\n-        // Expand global allocators, which are treated as an in-tree proc macro\n-        time(sess, \"creating allocators\", || {\n-            syntax_ext::global_allocator::modify(\n-                &sess.parse_sess,\n-                &mut resolver,\n-                &mut krate,\n-                crate_name.to_string(),\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n-\n     // Done with macro expansion!\n \n     if sess.opts.debugging_opts.input_stats {"}, {"sha": "3404ec5e173bdfd93aed4325d61c8da79d86c8d9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -25,10 +25,9 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::allocator::AllocatorKind;\n+use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n-use syntax::visit;\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n@@ -888,7 +887,14 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        let has_global_allocator = has_global_allocator(krate);\n+        let has_global_allocator = match &*global_allocator_spans(krate) {\n+            [span1, span2, ..] => {\n+                self.sess.struct_span_err(*span2, \"cannot define multiple global allocators\")\n+                         .span_note(*span1, \"the previous global allocator is defined here\").emit();\n+                true\n+            }\n+            spans => !spans.is_empty()\n+        };\n         self.sess.has_global_allocator.set(has_global_allocator);\n \n         // Check to see if we actually need an allocator. This desire comes\n@@ -975,25 +981,8 @@ impl<'a> CrateLoader<'a> {\n                            that implements the GlobalAlloc trait.\");\n         }\n         self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n-\n-        fn has_global_allocator(krate: &ast::Crate) -> bool {\n-            struct Finder(bool);\n-            let mut f = Finder(false);\n-            visit::walk_crate(&mut f, krate);\n-            return f.0;\n-\n-            impl<'ast> visit::Visitor<'ast> for Finder {\n-                fn visit_item(&mut self, i: &'ast ast::Item) {\n-                    if attr::contains_name(&i.attrs, sym::global_allocator) {\n-                        self.0 = true;\n-                    }\n-                    visit::walk_item(self, i)\n-                }\n-            }\n-        }\n     }\n \n-\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,"}, {"sha": "30bb37e4680d1784070df3adefc7eb47c9bdef24", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -1,16 +1,17 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_patterns)]\n+#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(crate_visibility_modifier)]\n-#![feature(specialization)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n+#![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "b550029d9786d33bdc962ac0e3f718825d2525df", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -51,7 +51,6 @@ impl OuterImplTrait {\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n-    has_global_allocator: bool,\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     /// Nested `impl Trait` _is_ allowed in associated type position,\n@@ -539,10 +538,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, sym::global_allocator) {\n-            self.has_global_allocator = true;\n-        }\n-\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n@@ -848,11 +843,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n-pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n+pub fn check_crate(session: &Session, krate: &Crate) -> bool {\n     let mut validator = AstValidator {\n         session,\n         has_proc_macro_decls: false,\n-        has_global_allocator: false,\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n@@ -861,5 +855,5 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n     };\n     visit::walk_crate(&mut validator, krate);\n \n-    (validator.has_proc_macro_decls, validator.has_global_allocator)\n+    validator.has_proc_macro_decls\n }"}, {"sha": "99aeb5414c5d8d5b62057d8c6ae2499ce906146a", "filename": "src/libsyntax/ext/allocator.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax%2Fext%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax%2Fext%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fallocator.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -1,3 +1,7 @@\n+use crate::{ast, attr, visit};\n+use crate::symbol::{sym, Symbol};\n+use syntax_pos::Span;\n+\n #[derive(Clone, Copy)]\n pub enum AllocatorKind {\n     Global,\n@@ -51,3 +55,21 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         output: AllocatorTy::ResultPtr,\n     },\n ];\n+\n+pub fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder { name: Symbol, spans: Vec<Span> }\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name &&\n+               attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol) {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(\"alloc\"));\n+    let mut f = Finder { name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "214160f10790d81c4436eddc54b3e65d6178148f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -1117,7 +1117,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                             \"the `#[rustc_const_unstable]` attribute \\\n                                             is an internal feature\",\n                                             cfg_fn!(rustc_const_unstable))),\n-    (sym::global_allocator, Normal, template!(Word), Ungated),\n     (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                             sym::allocator_internals,\n                                             \"the `#[default_lib_allocator]` \\"}, {"sha": "785636abb121fcc4f6e771ce42dd636c02a7785a", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 78, "deletions": 145, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -1,162 +1,95 @@\n-use log::debug;\n-use smallvec::{smallvec, SmallVec};\n-use syntax::{\n-    ast::{\n-        self, Arg, Attribute, Crate, Expr, FnHeader, Generics, Ident, Item, ItemKind,\n-        Mac, Mod, Mutability, Ty, TyKind, Unsafety, VisibilityKind,\n-    },\n-    attr,\n-    source_map::{\n-        respan, ExpnInfo, ExpnKind,\n-    },\n-    ext::{\n-        allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS},\n-        base::{ExtCtxt, MacroKind, Resolver},\n-        build::AstBuilder,\n-        expand::ExpansionConfig,\n-        hygiene::ExpnId,\n-    },\n-    mut_visit::{self, MutVisitor},\n-    parse::ParseSess,\n-    ptr::P,\n-    symbol::{kw, sym}\n-};\n+use errors::Applicability;\n+use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident, Item};\n+use syntax::ast::{ItemKind, Mutability, Ty, TyKind, Unsafety, VisibilityKind};\n+use syntax::source_map::respan;\n+use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::SyntaxContext;\n+use syntax::ptr::P;\n+use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n-pub fn modify(\n-    sess: &ParseSess,\n-    resolver: &mut dyn Resolver,\n-    krate: &mut Crate,\n-    crate_name: String,\n-    handler: &errors::Handler,\n-) {\n-    ExpandAllocatorDirectives {\n-        handler,\n-        sess,\n-        resolver,\n-        found: false,\n-        crate_name: Some(crate_name),\n-        in_submod: -1, // -1 to account for the \"root\" module\n-    }.visit_crate(krate);\n-}\n-\n-struct ExpandAllocatorDirectives<'a> {\n-    found: bool,\n-    handler: &'a errors::Handler,\n-    sess: &'a ParseSess,\n-    resolver: &'a mut dyn Resolver,\n-    crate_name: Option<String>,\n-\n-    // For now, we disallow `global_allocator` in submodules because hygiene is hard. Keep track of\n-    // whether we are in a submodule or not. If `in_submod > 0` we are in a submodule.\n-    in_submod: isize,\n-}\n-\n-impl MutVisitor for ExpandAllocatorDirectives<'_> {\n-    fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n-        debug!(\"in submodule {}\", self.in_submod);\n-\n-        if !attr::contains_name(&item.attrs, sym::global_allocator) {\n-            return mut_visit::noop_flat_map_item(item, self);\n-        }\n-\n-        match item.node {\n-            ItemKind::Static(..) => {}\n-            _ => {\n-                self.handler\n-                    .span_err(item.span, \"allocators must be statics\");\n-                return smallvec![item];\n-            }\n-        }\n-\n-        if self.in_submod > 0 {\n-            self.handler\n-                .span_err(item.span, \"`global_allocator` cannot be used in submodules\");\n-            return smallvec![item];\n-        }\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    if !meta_item.is_word() {\n+        let msg = format!(\"malformed `{}` attribute input\", meta_item.path);\n+        ecx.parse_sess.span_diagnostic.struct_span_err(span, &msg)\n+            .span_suggestion(\n+                span,\n+                \"must be of the form\",\n+                format!(\"`#[{}]`\", meta_item.path),\n+                Applicability::MachineApplicable\n+            ).emit();\n+    }\n \n-        if self.found {\n-            self.handler\n-                .span_err(item.span, \"cannot define more than one `#[global_allocator]`\");\n-            return smallvec![item];\n+    let not_static = |item: Annotatable| {\n+        ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+        vec![item]\n+    };\n+    let item = match item {\n+        Annotatable::Item(item) => match item.node {\n+            ItemKind::Static(..) => item,\n+            _ => return not_static(Annotatable::Item(item)),\n         }\n-        self.found = true;\n-\n-        // Create a new expansion for the generated allocator code.\n-        let span = item.span.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n-            ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n-            [sym::rustc_attrs][..].into(),\n-        ));\n-\n-        // Create an expansion config\n-        let ecfg = ExpansionConfig::default(self.crate_name.take().unwrap());\n-\n-        // Generate a bunch of new items using the AllocFnFactory\n-        let mut f = AllocFnFactory {\n-            span,\n-            kind: AllocatorKind::Global,\n-            global: item.ident,\n-            core: Ident::with_empty_ctxt(sym::core),\n-            cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n-        };\n-\n-        // We will generate a new submodule. To `use` the static from that module, we need to get\n-        // the `super::...` path.\n-        let super_path = f.cx.path(f.span, vec![Ident::with_empty_ctxt(kw::Super), f.global]);\n-\n-        // Generate the items in the submodule\n-        let mut items = vec![\n-            // import `core` to use allocators\n-            f.cx.item_extern_crate(f.span, f.core),\n-            // `use` the `global_allocator` in `super`\n-            f.cx.item_use_simple(\n-                f.span,\n-                respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n-                super_path,\n-            ),\n-        ];\n-\n-        // Add the allocator methods to the submodule\n-        items.extend(\n-            ALLOCATOR_METHODS\n-                .iter()\n-                .map(|method| f.allocator_fn(method)),\n-        );\n-\n-        // Generate the submodule itself\n-        let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::from_str(&name).gensym();\n-        let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n-        let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n-\n-        // Return the item and new submodule\n-        smallvec![item, module]\n-    }\n+        _ => return not_static(item),\n+    };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.mark));\n+    let f = AllocFnFactory {\n+        span,\n+        kind: AllocatorKind::Global,\n+        global: item.ident,\n+        core: Ident::with_empty_ctxt(sym::core),\n+        cx: ecx,\n+    };\n+\n+    // We will generate a new submodule. To `use` the static from that module, we need to get\n+    // the `super::...` path.\n+    let super_path = f.cx.path(f.span, vec![Ident::with_empty_ctxt(kw::Super), f.global]);\n+\n+    // Generate the items in the submodule\n+    let mut items = vec![\n+        // import `core` to use allocators\n+        f.cx.item_extern_crate(f.span, f.core),\n+        // `use` the `global_allocator` in `super`\n+        f.cx.item_use_simple(\n+            f.span,\n+            respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n+            super_path,\n+        ),\n+    ];\n+\n+    // Add the allocator methods to the submodule\n+    items.extend(\n+        ALLOCATOR_METHODS\n+            .iter()\n+            .map(|method| f.allocator_fn(method)),\n+    );\n \n-    // If we enter a submodule, take note.\n-    fn visit_mod(&mut self, m: &mut Mod) {\n-        debug!(\"enter submodule\");\n-        self.in_submod += 1;\n-        mut_visit::noop_visit_mod(m, self);\n-        self.in_submod -= 1;\n-        debug!(\"exit submodule\");\n-    }\n+    // Generate the submodule itself\n+    let name = f.kind.fn_name(\"allocator_abi\");\n+    let allocator_abi = Ident::from_str(&name).gensym();\n+    let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n \n-    // `visit_mac` is disabled by default. Enable it here.\n-    fn visit_mac(&mut self, mac: &mut Mac) {\n-        mut_visit::noop_visit_mac(mac, self)\n-    }\n+    // Return the item and new submodule\n+    vec![Annotatable::Item(item), Annotatable::Item(module)]\n }\n \n-struct AllocFnFactory<'a> {\n+struct AllocFnFactory<'a, 'b> {\n     span: Span,\n     kind: AllocatorKind,\n     global: Ident,\n     core: Ident,\n-    cx: ExtCtxt<'a>,\n+    cx: &'b ExtCtxt<'a>,\n }\n \n-impl AllocFnFactory<'_> {\n+impl AllocFnFactory<'_, '_> {\n     fn allocator_fn(&self, method: &AllocatorMethod) -> P<Item> {\n         let mut abi_args = Vec::new();\n         let mut i = 0;"}, {"sha": "400bfe796bb0765793019b5bb7f51045cfbcf816", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -29,6 +29,7 @@ mod concat_idents;\n mod env;\n mod format;\n mod format_foreign;\n+mod global_allocator;\n mod global_asm;\n mod log_syntax;\n mod proc_macro_server;\n@@ -37,7 +38,6 @@ mod test_case;\n mod trace_macros;\n \n pub mod deriving;\n-pub mod global_allocator;\n pub mod proc_macro_decls;\n pub mod proc_macro_impl;\n \n@@ -152,6 +152,12 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n             SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_bench)), edition\n         )\n     });\n+    register(sym::global_allocator, SyntaxExtension {\n+        allow_internal_unstable: Some([sym::rustc_attrs][..].into()),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyAttr(Box::new(global_allocator::expand)), edition\n+        )\n+    });\n \n     let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n     register(sym::format_args, SyntaxExtension {"}, {"sha": "506154ec601ae6e3ea4ebdd2bf66d6f45edf16e9", "filename": "src/test/run-pass/allocator/custom-in-block.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+fn main() {\n+    #[global_allocator]\n+    pub static GLOBAL: A = A(AtomicUsize::new(0));\n+\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 1);\n+    drop(s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 2);\n+}"}, {"sha": "f9c4ad7668b634278a129870f9587c72ebce00c6", "filename": "src/test/run-pass/allocator/custom-in-submodule.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+mod submodule {\n+    use super::*;\n+\n+    #[global_allocator]\n+    pub static GLOBAL: A = A(AtomicUsize::new(0));\n+}\n+\n+fn main() {\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), 1);\n+    drop(s);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), 2);\n+}"}, {"sha": "7a8d86b8da18cf08df1f0225a654fd40851a15d6", "filename": "src/test/ui/allocator-submodule.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a93fdfedf36dcb909d90cbf963b087c5873bec1d/src%2Ftest%2Fui%2Fallocator-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93fdfedf36dcb909d90cbf963b087c5873bec1d/src%2Ftest%2Fui%2Fallocator-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.rs?ref=a93fdfedf36dcb909d90cbf963b087c5873bec1d", "patch": "@@ -1,28 +0,0 @@\n-// Tests that it is possible to create a global allocator in a submodule, rather than in the crate\n-// root.\n-\n-extern crate alloc;\n-\n-use std::{\n-    alloc::{GlobalAlloc, Layout},\n-    ptr,\n-};\n-\n-struct MyAlloc;\n-\n-unsafe impl GlobalAlloc for MyAlloc {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        ptr::null_mut()\n-    }\n-\n-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {}\n-}\n-\n-mod submod {\n-    use super::MyAlloc;\n-\n-    #[global_allocator]\n-    static MY_HEAP: MyAlloc = MyAlloc; //~ ERROR global_allocator\n-}\n-\n-fn main() {}"}, {"sha": "91c7c0f6b8e24fd3f8035c093b706d0011f6a284", "filename": "src/test/ui/allocator-submodule.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a93fdfedf36dcb909d90cbf963b087c5873bec1d/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a93fdfedf36dcb909d90cbf963b087c5873bec1d/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.stderr?ref=a93fdfedf36dcb909d90cbf963b087c5873bec1d", "patch": "@@ -1,8 +0,0 @@\n-error: `global_allocator` cannot be used in submodules\n-  --> $DIR/allocator-submodule.rs:25:5\n-   |\n-LL |     static MY_HEAP: MyAlloc = MyAlloc;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "1033f947c5f5b68a72f4b4bde656114a7c9ad63b", "filename": "src/test/ui/allocator/allocator-args.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -0,0 +1,13 @@\n+use std::alloc::{GlobalAlloc, Layout};\n+\n+struct A;\n+\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, _: Layout) -> *mut u8 { panic!() }\n+    unsafe fn dealloc(&self, _: *mut u8, _: Layout) { panic!() }\n+}\n+\n+#[global_allocator(malloc)] //~ ERROR malformed `global_allocator` attribute input\n+static S: A = A;\n+\n+fn main() {}"}, {"sha": "d8ae7130e5d3da9578a5c0e72ab39fa92d5080a4", "filename": "src/test/ui/allocator/allocator-args.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -0,0 +1,8 @@\n+error: malformed `global_allocator` attribute input\n+  --> $DIR/allocator-args.rs:10:1\n+   |\n+LL | #[global_allocator(malloc)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: ``#[global_allocator]``\n+\n+error: aborting due to previous error\n+"}, {"sha": "aa1291e77aecbb3a495210ef3b318af7078208fc", "filename": "src/test/ui/allocator/two-allocators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -4,6 +4,6 @@ use std::alloc::System;\n static A: System = System;\n #[global_allocator]\n static B: System = System;\n-//~^ ERROR: cannot define more than one `#[global_allocator]`\n+//~^ ERROR: cannot define multiple global allocators\n \n fn main() {}"}, {"sha": "ed0aa13eb8078e6bce1bace25afc41b5c8d7d210", "filename": "src/test/ui/allocator/two-allocators.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -1,8 +1,14 @@\n-error: cannot define more than one `#[global_allocator]`\n+error: cannot define multiple global allocators\n   --> $DIR/two-allocators.rs:6:1\n    |\n LL | static B: System = System;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the previous global allocator is defined here\n+  --> $DIR/two-allocators.rs:4:1\n+   |\n+LL | static A: System = System;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ade61abb7485e2bb1cd3b75bbffb0574ae08e892", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433024147ae1e9795fe7e94cb1810a17fd37fa51/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=433024147ae1e9795fe7e94cb1810a17fd37fa51", "patch": "@@ -344,7 +344,7 @@ fn get_and_check_lib_features(base_src_path: &Path,\n                 Ok((name, f)) => {\n                     let mut check_features = |f: &Feature, list: &Features, display: &str| {\n                         if let Some(ref s) = list.get(name) {\n-                            if f.tracking_issue != s.tracking_issue {\n+                            if f.tracking_issue != s.tracking_issue && f.level != Status::Stable {\n                                 tidy_error!(bad,\n                                             \"{}:{}: mismatches the `issue` in {}\",\n                                             file.display(),"}]}