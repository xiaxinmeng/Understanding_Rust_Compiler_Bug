{"sha": "5b838c586c4da31395d614d9f076430314fa05ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViODM4YzU4NmM0ZGEzMTM5NWQ2MTRkOWYwNzY0MzAzMTRmYTA1ZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-25T14:27:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-25T14:27:58Z"}, "message": "Auto merge of #30555 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #30485, #30490, #30513, #30518, #30528, #30545, #30551, #30552\n- Failed merges:", "tree": {"sha": "84a20186d24b6ccaa333ee74c427f38c868c2e2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84a20186d24b6ccaa333ee74c427f38c868c2e2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b838c586c4da31395d614d9f076430314fa05ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b838c586c4da31395d614d9f076430314fa05ff", "html_url": "https://github.com/rust-lang/rust/commit/5b838c586c4da31395d614d9f076430314fa05ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b838c586c4da31395d614d9f076430314fa05ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "711f11e8d607b3ecf297366fa704b5200709d12d", "url": "https://api.github.com/repos/rust-lang/rust/commits/711f11e8d607b3ecf297366fa704b5200709d12d", "html_url": "https://github.com/rust-lang/rust/commit/711f11e8d607b3ecf297366fa704b5200709d12d"}, {"sha": "04fe94a6660f6028a208fa5858a2a68f50f74b6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/04fe94a6660f6028a208fa5858a2a68f50f74b6c", "html_url": "https://github.com/rust-lang/rust/commit/04fe94a6660f6028a208fa5858a2a68f50f74b6c"}], "stats": {"total": 595, "additions": 487, "deletions": 108}, "files": [{"sha": "f7e32943c638e470b76d4930f69a71009022a42f", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -41,6 +41,7 @@\n \n * `!` (`ident!(\u2026)`, `ident!{\u2026}`, `ident![\u2026]`): denotes macro expansion.  See [Macros].\n * `!` (`!expr`): bitwise or logical complement.  Overloadable (`Not`).\n+* `!=` (`var != expr`): nonequality comparison.  Overloadable (`PartialEq`).\n * `%` (`expr % expr`): arithmetic remainder.  Overloadable (`Rem`).\n * `%=` (`var %= expr`): arithmetic remainder & assignment.\n * `&` (`expr & expr`): bitwise and.  Overloadable (`BitAnd`).\n@@ -75,13 +76,13 @@\n * `;` (`[\u2026; len]`): part of fixed-size array syntax.  See [Primitive Types (Arrays)].\n * `<<` (`expr << expr`): left-shift.  Overloadable (`Shl`).\n * `<<=` (`var <<= expr`): left-shift & assignment.\n-* `<` (`expr < expr`): less-than comparison.  Overloadable (`Cmp`, `PartialCmp`).\n-* `<=` (`var <= expr`): less-than or equal-to comparison.  Overloadable (`Cmp`, `PartialCmp`).\n+* `<` (`expr < expr`): less-than comparison.  Overloadable (`PartialOrd`).\n+* `<=` (`var <= expr`): less-than or equal-to comparison.  Overloadable (`PartialOrd`).\n * `=` (`var = expr`, `ident = type`): assignment/equivalence.  See [Variable Bindings], [`type` Aliases], generic parameter defaults.\n-* `==` (`var == expr`): comparison.  Overloadable (`Eq`, `PartialEq`).\n+* `==` (`var == expr`): equality comparison.  Overloadable (`PartialEq`).\n * `=>` (`pat => expr`): part of match arm syntax.  See [Match].\n-* `>` (`expr > expr`): greater-than comparison.  Overloadable (`Cmp`, `PartialCmp`).\n-* `>=` (`var >= expr`): greater-than or equal-to comparison.  Overloadable (`Cmp`, `PartialCmp`).\n+* `>` (`expr > expr`): greater-than comparison.  Overloadable (`PartialOrd`).\n+* `>=` (`var >= expr`): greater-than or equal-to comparison.  Overloadable (`PartialOrd`).\n * `>>` (`expr >> expr`): right-shift.  Overloadable (`Shr`).\n * `>>=` (`var >>= expr`): right-shift & assignment.\n * `@` (`ident @ pat`): pattern binding.  See [Patterns (Bindings)]."}, {"sha": "3aa76d168df077ae02358f8a247ee96e104661d8", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -1822,8 +1822,8 @@ unpaired_token\n | LIT_FLOAT                  { $$ = mk_atom(yytext); }\n | LIT_STR                    { $$ = mk_atom(yytext); }\n | LIT_STR_RAW                { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR                 { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR_RAW             { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n | IDENT                      { $$ = mk_atom(yytext); }\n | UNDERSCORE                 { $$ = mk_atom(yytext); }\n | LIFETIME                   { $$ = mk_atom(yytext); }"}, {"sha": "7de6099544525328e259949cc1a247abe96ba50e", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -839,11 +839,10 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n }\n \n /// Used for items loaded from external crate that are being inlined into this\n-/// crate.  The `path` should be the path to the item but should not include\n-/// the item itself.\n+/// crate.\n pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n-                                          path: Vec<PathElem>,\n-                                          def_path: DefPath,\n+                                          parent_path: Vec<PathElem>,\n+                                          parent_def_path: DefPath,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n@@ -862,7 +861,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     };\n \n     let ii_parent = map.forest.inlined_items.alloc(InlinedParent {\n-        path: path,\n+        path: parent_path,\n         ii: ii\n     });\n \n@@ -872,7 +871,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             map.krate(),\n             ii_parent,\n             ii_parent_id,\n-            def_path,\n+            parent_def_path,\n             mem::replace(&mut *map.map.borrow_mut(), vec![]),\n             mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n     ii_parent.ii.visit(&mut collector);"}, {"sha": "be6bb8689eefab0674e5e978cadec17f50887764", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -701,9 +701,9 @@ pub struct Constant<'tcx> {\n #[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum ItemKind {\n     Constant,\n+    /// This is any sort of callable (usually those that have a type of `fn(\u2026) -> \u2026`). This\n+    /// includes functions, constructors, but not methods which have their own ItemKind.\n     Function,\n-    Struct,\n-    Variant,\n     Method,\n }\n "}, {"sha": "8f74acd9ebdf6f8da88694d89f608ee60df1d5c8", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -124,20 +124,20 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n /// ast-map.\n pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n-                                 path: Vec<ast_map::PathElem>,\n-                                 def_path: ast_map::DefPath,\n+                                 parent_path: Vec<ast_map::PathElem>,\n+                                 parent_def_path: ast_map::DefPath,\n                                  par_doc: rbml::Doc,\n                                  orig_did: DefId)\n                                  -> Result<&'tcx InlinedItem, (Vec<ast_map::PathElem>,\n                                                                ast_map::DefPath)> {\n     match par_doc.opt_child(c::tag_ast) {\n-      None => Err((path, def_path)),\n+      None => Err((parent_path, parent_def_path)),\n       Some(ast_doc) => {\n         let mut path_as_str = None;\n         debug!(\"> Decoding inlined fn: {:?}::?\",\n         {\n             // Do an Option dance to use the path after it is moved below.\n-            let s = ast_map::path_to_string(path.iter().cloned());\n+            let s = ast_map::path_to_string(parent_path.iter().cloned());\n             path_as_str = Some(s);\n             path_as_str.as_ref().map(|x| &x[..])\n         });\n@@ -152,8 +152,11 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             last_filemap_index: Cell::new(0)\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, def_path, raw_ii, dcx);\n-\n+        let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n+                                           parent_path,\n+                                           parent_def_path,\n+                                           raw_ii,\n+                                           dcx);\n         let name = match *ii {\n             InlinedItem::Item(ref i) => i.name,\n             InlinedItem::Foreign(ref i) => i.name,"}, {"sha": "8126970759e6dcc7e0adaaf3c202126fa0820422", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -763,29 +763,54 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n pub type DecodeInlinedItem<'a> =\n     Box<for<'tcx> FnMut(Cmd,\n                         &ty::ctxt<'tcx>,\n-                        Vec<hir_map::PathElem>,\n-                        hir_map::DefPath,\n+                        Vec<hir_map::PathElem>, // parent_path\n+                        hir_map::DefPath,       // parent_def_path\n                         rbml::Doc,\n                         DefId)\n                         -> Result<&'tcx InlinedItem, (Vec<hir_map::PathElem>,\n                                                       hir_map::DefPath)> + 'a>;\n \n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: DefIndex,\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd,\n+                                tcx: &ty::ctxt<'tcx>,\n+                                id: DefIndex,\n                                 mut decode_inlined_item: DecodeInlinedItem)\n                                 -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n-    let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n-    let def_path = def_path(cdata, id);\n-    match decode_inlined_item(cdata, tcx, path, def_path, item_doc, item_did) {\n+    let parent_path = {\n+        let mut path = item_path(item_doc);\n+        path.pop();\n+        path\n+    };\n+    let parent_def_path = {\n+        let mut def_path = def_path(cdata, id);\n+        def_path.pop();\n+        def_path\n+    };\n+    match decode_inlined_item(cdata,\n+                              tcx,\n+                              parent_path,\n+                              parent_def_path,\n+                              item_doc,\n+                              item_did) {\n         Ok(ii) => FoundAst::Found(ii),\n-        Err((path, def_path)) => {\n+        Err((mut parent_path, mut parent_def_path)) => {\n             match item_parent_item(cdata, item_doc) {\n-                Some(did) => {\n-                    let parent_item = cdata.lookup_item(did.index);\n-                    match decode_inlined_item(cdata, tcx, path, def_path, parent_item, did) {\n-                        Ok(ii) => FoundAst::FoundParent(did, ii),\n+                Some(parent_did) => {\n+                    // Remove the last element from the paths, since we are now\n+                    // trying to inline the parent.\n+                    parent_path.pop();\n+                    parent_def_path.pop();\n+\n+                    let parent_item = cdata.lookup_item(parent_did.index);\n+                    match decode_inlined_item(cdata,\n+                                              tcx,\n+                                              parent_path,\n+                                              parent_def_path,\n+                                              parent_item,\n+                                              parent_did) {\n+                        Ok(ii) => FoundAst::FoundParent(parent_did, ii),\n                         Err(_) => FoundAst::NotFound\n                     }\n                 }"}, {"sha": "46e6243c8bf30c205ecd21a0dbbf7edd556207e8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -519,51 +519,51 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n-    match def {\n-        def::DefVariant(_, def_id, false) |\n-        def::DefStruct(def_id) |\n-        def::DefFn(def_id, _) |\n-        def::DefMethod(def_id) => {\n-            let kind = match def {\n-                def::DefVariant(..) => ItemKind::Variant,\n-                def::DefStruct(..) => ItemKind::Struct,\n-                def::DefFn(..) => ItemKind::Function,\n-                def::DefMethod(..) => ItemKind::Method,\n-                _ => panic!()\n-            };\n-            ExprKind::Literal {\n-                literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n+    let (def_id, kind) = match def {\n+        // A variant constructor.\n+        def::DefVariant(_, def_id, false) => (def_id, ItemKind::Function),\n+        // A regular function.\n+        def::DefFn(def_id, _) => (def_id, ItemKind::Function),\n+        def::DefMethod(def_id) => (def_id, ItemKind::Method),\n+        def::DefStruct(def_id) => {\n+            match cx.tcx.node_id_to_type(expr.id).sty {\n+                // A tuple-struct constructor.\n+                ty::TyBareFn(..) => (def_id, ItemKind::Function),\n+                // This is a special case: a unit struct which is used as a value. We return a\n+                // completely different ExprKind here to account for this special case.\n+                ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: 0,\n+                    substs: substs,\n+                    fields: vec![],\n+                    base: None\n+                },\n+                ref sty => panic!(\"unexpected sty: {:?}\", sty)\n             }\n         },\n         def::DefConst(def_id) |\n         def::DefAssociatedConst(def_id) => {\n             if let Some(v) = cx.try_const_eval_literal(expr) {\n-                ExprKind::Literal { literal: v }\n+                return ExprKind::Literal { literal: v };\n             } else {\n-                ExprKind::Literal {\n-                    literal: Literal::Item {\n-                        def_id: def_id,\n-                        kind: ItemKind::Constant,\n-                        substs: substs\n-                    }\n-                }\n+                (def_id, ItemKind::Constant)\n             }\n         }\n \n-\n-        def::DefStatic(node_id, _) =>\n-            ExprKind::StaticRef {\n-                id: node_id,\n-            },\n+        def::DefStatic(node_id, _) => return ExprKind::StaticRef {\n+            id: node_id,\n+        },\n \n         def @ def::DefLocal(..) |\n-        def @ def::DefUpvar(..) =>\n-            convert_var(cx, expr, def),\n+        def @ def::DefUpvar(..) => return convert_var(cx, expr, def),\n \n         def =>\n             cx.tcx.sess.span_bug(\n                 expr.span,\n                 &format!(\"def `{:?}` not yet implemented\", def)),\n+    };\n+    ExprKind::Literal {\n+        literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n     }\n }\n "}, {"sha": "d4a7a7c8b48ff3234be80857dfae5c084e39d550", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -39,9 +39,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           did: DefId)\n                           -> OperandRef<'tcx> {\n         match kind {\n-            ItemKind::Function |\n-            ItemKind::Struct |\n-            ItemKind::Variant => self.trans_fn_ref(bcx, ty, substs, did),\n+            ItemKind::Function => self.trans_fn_ref(bcx, ty, substs, did),\n             ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n                 ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n                 ty::TraitContainer(tdid) => self.trans_static_method(bcx, ty, did, tdid, substs)"}, {"sha": "55a41201b2ba17c849236fbf26c55dd53bb2bee4", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -19,28 +19,30 @@ use trans::common::{self, Block, Result};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n+use trans::adt;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::tvec;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n+use super::lvalue::LvalueRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n                         bcx: Block<'bcx, 'tcx>,\n-                        lldest: ValueRef,\n+                        dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Block<'bcx, 'tcx>\n     {\n-        debug!(\"trans_rvalue(lldest={}, rvalue={:?})\",\n-               bcx.val_to_string(lldest),\n+        debug!(\"trans_rvalue(dest.llval={}, rvalue={:?})\",\n+               bcx.val_to_string(dest.llval),\n                rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                self.trans_operand_into(bcx, lldest, operand);\n+                self.trans_operand_into(bcx, dest.llval, operand);\n                 bcx\n             }\n \n@@ -49,7 +51,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(bcx, lldest, temp);\n+                    self.store_operand(bcx, dest.llval, temp);\n                     return bcx;\n                 }\n \n@@ -72,12 +74,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         base::store_ty(bcx, llval, lltemp, operand.ty);\n                         base::coerce_unsized_into(bcx,\n                                                   lltemp, operand.ty,\n-                                                  lldest, cast_ty);\n+                                                  dest.llval, cast_ty);\n                     }\n                     OperandValue::Ref(llref) => {\n                         base::coerce_unsized_into(bcx,\n                                                   llref, operand.ty,\n-                                                  lldest, cast_ty);\n+                                                  dest.llval, cast_ty);\n                     }\n                 }\n                 bcx\n@@ -86,20 +88,31 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let elem = self.trans_operand(bcx, elem);\n                 let size = self.trans_constant(bcx, count).immediate();\n-                let base = expr::get_dataptr(bcx, lldest);\n+                let base = expr::get_dataptr(bcx, dest.llval);\n                 tvec::iter_vec_raw(bcx, base, elem.ty, size, |bcx, llslot, _| {\n                     self.store_operand(bcx, llslot, elem);\n                     bcx\n                 })\n             }\n \n-            mir::Rvalue::Aggregate(_, ref operands) => {\n-                for (i, operand) in operands.iter().enumerate() {\n-                    // Note: perhaps this should be StructGep, but\n-                    // note that in some cases the values here will\n-                    // not be structs but arrays.\n-                    let lldest_i = build::GEPi(bcx, lldest, &[0, i]);\n-                    self.trans_operand_into(bcx, lldest_i, operand);\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                match *kind {\n+                    // Unit struct, which is translated very differently compared to any other\n+                    // aggregate\n+                    mir::AggregateKind::Adt(adt_def, 0, _)\n+                    if adt_def.struct_variant().kind() == ty::VariantKind::Unit => {\n+                        let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n+                        adt::trans_set_discr(bcx, &*repr, dest.llval, 0);\n+                    },\n+                    _ => {\n+                        for (i, operand) in operands.iter().enumerate() {\n+                            // Note: perhaps this should be StructGep, but\n+                            // note that in some cases the values here will\n+                            // not be structs but arrays.\n+                            let lldest_i = build::GEPi(bcx, dest.llval, &[0, i]);\n+                            self.trans_operand_into(bcx, lldest_i, operand);\n+                        }\n+                    }\n                 }\n                 bcx\n             }\n@@ -113,9 +126,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n                 let adj = common::C_uint(ccx, from_start + from_end);\n                 let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n-                let lladdrdest = expr::get_dataptr(bcx, lldest);\n+                let lladdrdest = expr::get_dataptr(bcx, dest.llval);\n                 build::Store(bcx, llbase1, lladdrdest);\n-                let llmetadest = expr::get_meta(bcx, lldest);\n+                let llmetadest = expr::get_meta(bcx, dest.llval);\n                 build::Store(bcx, lllen1, llmetadest);\n                 bcx\n             }\n@@ -127,7 +140,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(bcx, lldest, temp);\n+                self.store_operand(bcx, dest.llval, temp);\n                 bcx\n             }\n         }"}, {"sha": "dae0d3b55c0ba2bec9c3bfee01abd13aa2197929", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -31,7 +31,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let index = index as usize;\n                         match self.temps[index as usize] {\n                             TempRef::Lvalue(tr_dest) => {\n-                                self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                                self.trans_rvalue(bcx, tr_dest, rvalue)\n                             }\n                             TempRef::Operand(None) => {\n                                 let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n@@ -47,7 +47,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     _ => {\n                         let tr_dest = self.trans_lvalue(bcx, lvalue);\n-                        self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                        self.trans_rvalue(bcx, tr_dest, rvalue)\n                     }\n                 }\n             }"}, {"sha": "b42d1d1b8d4ce5fb95d4cdc7d1d09207b150d6fc", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -21,6 +21,8 @@ use sync::{Arc, Mutex, RwLock};\n use sys_common::unwind;\n use thread::Result;\n \n+pub use panicking::{take_handler, set_handler, PanicInfo, Location};\n+\n /// A marker trait which represents \"panic safe\" types in Rust.\n ///\n /// This trait is implemented by default for many types and behaves similarly in\n@@ -99,16 +101,19 @@ use thread::Result;\n                             across a recover boundary\"]\n pub trait RecoverSafe {}\n \n-/// A marker trait representing types which do not contain an `UnsafeCell` by\n-/// value internally.\n+/// A marker trait representing types where a shared reference is considered\n+/// recover safe.\n+///\n+/// This trait is namely not implemented by `UnsafeCell`, the root of all\n+/// interior mutability.\n ///\n /// This is a \"helper marker trait\" used to provide impl blocks for the\n /// `RecoverSafe` trait, for more information see that documentation.\n #[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n #[rustc_on_unimplemented = \"the type {Self} contains interior mutability \\\n                             and a reference may not be safely transferrable \\\n                             across a recover boundary\"]\n-pub trait NoUnsafeCell {}\n+pub trait RefRecoverSafe {}\n \n /// A simple wrapper around a type to assert that it is panic safe.\n ///\n@@ -157,27 +162,28 @@ pub struct AssertRecoverSafe<T>(T);\n // * Our custom AssertRecoverSafe wrapper is indeed recover safe\n impl RecoverSafe for .. {}\n impl<'a, T: ?Sized> !RecoverSafe for &'a mut T {}\n-impl<'a, T: NoUnsafeCell + ?Sized> RecoverSafe for &'a T {}\n-impl<T: NoUnsafeCell + ?Sized> RecoverSafe for *const T {}\n-impl<T: NoUnsafeCell + ?Sized> RecoverSafe for *mut T {}\n+impl<'a, T: RefRecoverSafe + ?Sized> RecoverSafe for &'a T {}\n+impl<T: RefRecoverSafe + ?Sized> RecoverSafe for *const T {}\n+impl<T: RefRecoverSafe + ?Sized> RecoverSafe for *mut T {}\n impl<T: RecoverSafe> RecoverSafe for Unique<T> {}\n-impl<T: NoUnsafeCell + ?Sized> RecoverSafe for Shared<T> {}\n+impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Shared<T> {}\n impl<T: ?Sized> RecoverSafe for Mutex<T> {}\n impl<T: ?Sized> RecoverSafe for RwLock<T> {}\n impl<T> RecoverSafe for AssertRecoverSafe<T> {}\n \n // not covered via the Shared impl above b/c the inner contents use\n // Cell/AtomicUsize, but the usage here is recover safe so we can lift the\n // impl up one level to Arc/Rc itself\n-impl<T: NoUnsafeCell + ?Sized> RecoverSafe for Rc<T> {}\n-impl<T: NoUnsafeCell + ?Sized> RecoverSafe for Arc<T> {}\n+impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Rc<T> {}\n+impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Arc<T> {}\n \n-// Pretty simple implementations for the `NoUnsafeCell` marker trait, basically\n-// just saying that this is a marker trait and `UnsafeCell` is the only thing\n-// which doesn't implement it (which then transitively applies to everything\n-// else.\n-impl NoUnsafeCell for .. {}\n-impl<T: ?Sized> !NoUnsafeCell for UnsafeCell<T> {}\n+// Pretty simple implementations for the `RefRecoverSafe` marker trait,\n+// basically just saying that this is a marker trait and `UnsafeCell` is the\n+// only thing which doesn't implement it (which then transitively applies to\n+// everything else.\n+impl RefRecoverSafe for .. {}\n+impl<T: ?Sized> !RefRecoverSafe for UnsafeCell<T> {}\n+impl<T> RefRecoverSafe for AssertRecoverSafe<T> {}\n \n impl<T> AssertRecoverSafe<T> {\n     /// Creates a new `AssertRecoverSafe` wrapper around the provided type."}, {"sha": "3f9a1c30ef4936c6d4767fcc27c1d767aa91af0d", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 148, "deletions": 8, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -15,10 +15,12 @@ use any::Any;\n use cell::Cell;\n use cell::RefCell;\n use intrinsics;\n+use sync::StaticRwLock;\n use sys::stdio::Stderr;\n use sys_common::backtrace;\n use sys_common::thread_info;\n use sys_common::util;\n+use thread;\n \n thread_local! { pub static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n \n@@ -28,11 +30,138 @@ thread_local! {\n     }\n }\n \n-fn log_panic(obj: &(Any+Send), file: &'static str, line: u32,\n-             log_backtrace: bool) {\n-    let msg = match obj.downcast_ref::<&'static str>() {\n+#[derive(Copy, Clone)]\n+enum Handler {\n+    Default,\n+    Custom(*mut (Fn(&PanicInfo) + 'static + Sync + Send)),\n+}\n+\n+static HANDLER_LOCK: StaticRwLock = StaticRwLock::new();\n+static mut HANDLER: Handler = Handler::Default;\n+\n+/// Registers a custom panic handler, replacing any that was previously\n+/// registered.\n+///\n+/// The panic handler is invoked when a thread panics, but before it begins\n+/// unwinding the stack. The default handler prints a message to standard error\n+/// and generates a backtrace if requested, but this behavior can be customized\n+/// with the `set_handler` and `take_handler` functions.\n+///\n+/// The handler is provided with a `PanicInfo` struct which contains information\n+/// about the origin of the panic, including the payload passed to `panic!` and\n+/// the source code location from which the panic originated.\n+///\n+/// The panic handler is a global resource.\n+///\n+/// # Panics\n+///\n+/// Panics if called from a panicking thread.\n+#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+pub fn set_handler<F>(handler: F) where F: Fn(&PanicInfo) + 'static + Sync + Send {\n+    if thread::panicking() {\n+        panic!(\"cannot modify the panic handler from a panicking thread\");\n+    }\n+\n+    let handler = Box::new(handler);\n+    unsafe {\n+        let lock = HANDLER_LOCK.write();\n+        let old_handler = HANDLER;\n+        HANDLER = Handler::Custom(Box::into_raw(handler));\n+        drop(lock);\n+\n+        if let Handler::Custom(ptr) = old_handler {\n+            Box::from_raw(ptr);\n+        }\n+    }\n+}\n+\n+/// Unregisters the current panic handler, returning it.\n+///\n+/// If no custom handler is registered, the default handler will be returned.\n+///\n+/// # Panics\n+///\n+/// Panics if called from a panicking thread.\n+#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n+    if thread::panicking() {\n+        panic!(\"cannot modify the panic handler from a panicking thread\");\n+    }\n+\n+    unsafe {\n+        let lock = HANDLER_LOCK.write();\n+        let handler = HANDLER;\n+        HANDLER = Handler::Default;\n+        drop(lock);\n+\n+        match handler {\n+            Handler::Default => Box::new(default_handler),\n+            Handler::Custom(ptr) => {Box::from_raw(ptr)} // FIXME #30530\n+        }\n+    }\n+}\n+\n+/// A struct providing information about a panic.\n+#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+pub struct PanicInfo<'a> {\n+    payload: &'a (Any + Send),\n+    location: Location<'a>,\n+}\n+\n+impl<'a> PanicInfo<'a> {\n+    /// Returns the payload associated with the panic.\n+    ///\n+    /// This will commonly, but not always, be a `&'static str` or `String`.\n+    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    pub fn payload(&self) -> &(Any + Send) {\n+        self.payload\n+    }\n+\n+    /// Returns information about the location from which the panic originated,\n+    /// if available.\n+    ///\n+    /// This method will currently always return `Some`, but this may change\n+    /// in future versions.\n+    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    pub fn location(&self) -> Option<&Location> {\n+        Some(&self.location)\n+    }\n+}\n+\n+/// A struct containing information about the location of a panic.\n+#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+pub struct Location<'a> {\n+    file: &'a str,\n+    line: u32,\n+}\n+\n+impl<'a> Location<'a> {\n+    /// Returns the name of the source file from which the panic originated.\n+    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    pub fn file(&self) -> &str {\n+        self.file\n+    }\n+\n+    /// Returns the line number from which the panic originated.\n+    #[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n+    pub fn line(&self) -> u32 {\n+        self.line\n+    }\n+}\n+\n+fn default_handler(info: &PanicInfo) {\n+    let panics = PANIC_COUNT.with(|s| s.get());\n+\n+    // If this is a double panic, make sure that we print a backtrace\n+    // for this panic. Otherwise only print it if logging is enabled.\n+    let log_backtrace = panics >= 2 || backtrace::log_enabled();\n+\n+    let file = info.location.file;\n+    let line = info.location.line;\n+\n+    let msg = match info.payload.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n-        None => match obj.downcast_ref::<String>() {\n+        None => match info.payload.downcast_ref::<String>() {\n             Some(s) => &s[..],\n             None => \"Box<Any>\",\n         }\n@@ -81,10 +210,21 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n         unsafe { intrinsics::abort() }\n     }\n \n-    // If this is a double panic, make sure that we print a backtrace\n-    // for this panic. Otherwise only print it if logging is enabled.\n-    let log_backtrace = panics >= 2 || backtrace::log_enabled();\n-    log_panic(obj, file, line, log_backtrace);\n+    let info = PanicInfo {\n+        payload: obj,\n+        location: Location {\n+            file: file,\n+            line: line,\n+        },\n+    };\n+\n+    unsafe {\n+        let _lock = HANDLER_LOCK.read();\n+        match HANDLER {\n+            Handler::Default => default_handler(&info),\n+            Handler::Custom(ptr) => (*ptr)(&info),\n+        }\n+    }\n \n     if panics >= 2 {\n         // If a thread panics while it's already unwinding then we"}, {"sha": "34773e1657c2d220f2272648cb4edd9ecb223275", "filename": "src/snapshots.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -3,6 +3,7 @@ S 2015-12-18 3391630\n   linux-x86_64 97e2a5eb8904962df8596e95d6e5d9b574d73bf4\n   macos-i386 ca52d2d3ba6497ed007705ee3401cf7efc136ca1\n   macos-x86_64 3c44ffa18f89567c2b81f8d695e711c86d81ffc7\n+  openbsd-x86_64 6c8aab2c8a169274942f9a15e460069a3ff64be9\n   winnt-i386 f9056ebd3db9611d31c2dc6dc5f96c7208d5d227\n   winnt-x86_64 a85a40e535d828016181d3aa40afe34c3e36ab8c\n "}, {"sha": "bfeb407dd25a439dbfb51497fb1fe2883de0cc4e", "filename": "src/test/run-fail/panic-set-handler.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:greetings from the panic handler\n+\n+#![feature(std_panic, panic_handler)]\n+use std::panic;\n+use std::io::{self, Write};\n+\n+fn main() {\n+    panic::set_handler(|i| {\n+        write!(io::stderr(), \"greetings from the panic handler\");\n+    });\n+    panic!(\"foobar\");\n+}"}, {"sha": "6999aa715e791b7d2346581afe5cb9c2bab60b15", "filename": "src/test/run-fail/panic-set-unset-handler.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'foobar'\n+\n+#![feature(std_panic, panic_handler)]\n+use std::panic;\n+use std::io::{self, Write};\n+\n+fn main() {\n+    panic::set_handler(|i| {\n+        write!(io::stderr(), \"greetings from the panic handler\");\n+    });\n+    panic::take_handler();\n+    panic!(\"foobar\");\n+}"}, {"sha": "fec1db24adf09cc50446bff45b74ef0eb0a2f6b7", "filename": "src/test/run-fail/panic-take-handler-nop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-fail%2Fpanic-take-handler-nop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-fail%2Fpanic-take-handler-nop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-take-handler-nop.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'foobar'\n+\n+#![feature(std_panic, panic_handler)]\n+use std::panic;\n+\n+fn main() {\n+    panic::take_handler();\n+    panic!(\"foobar\");\n+}"}, {"sha": "9b349c0e4e21bee0719deec86ea46e02501f3df1", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -14,6 +14,8 @@\n extern crate mir_external_refs as ext;\n \n struct S(u8);\n+#[derive(Debug, PartialEq, Eq)]\n+struct Unit;\n \n impl S {\n     fn hey() -> u8 { 42 }\n@@ -175,6 +177,11 @@ fn t20() -> fn(u64, u32)->(u64, u32) {\n     <u32 as T<_, _>>::staticmeth\n }\n \n+#[rustc_mir]\n+fn t21() -> Unit {\n+    Unit\n+}\n+\n fn main(){\n     unsafe {\n         assert_eq!(t1()(), regular());\n@@ -214,5 +221,6 @@ fn main(){\n         assert_eq!(t18()(50u64, 5u64), F::f(50u64, 5u64));\n         assert_eq!(t19()(322u64, 2u32), F::f(322u64, 2u32));\n         assert_eq!(t20()(123u64, 38u32), <u32 as T<_, _>>::staticmeth(123, 38));\n+        assert_eq!(t21(), Unit);\n     }\n }"}, {"sha": "1ed592d3d6b92622a05ab013ace8c24c476a29bb", "filename": "src/test/run-pass/panic-handler-chain.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-handler-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-handler-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-handler-chain.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(panic_handler, const_fn, std_panic)]\n+\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::panic;\n+use std::thread;\n+\n+static A: AtomicUsize = AtomicUsize::new(0);\n+static B: AtomicUsize = AtomicUsize::new(0);\n+\n+fn main() {\n+    panic::set_handler(|_| { A.fetch_add(1, Ordering::SeqCst); });\n+    let handler = panic::take_handler();\n+    panic::set_handler(move |info| {\n+        B.fetch_add(1, Ordering::SeqCst);\n+        handler(info);\n+    });\n+\n+    let _ = thread::spawn(|| {\n+        panic!();\n+    }).join();\n+\n+    assert_eq!(1, A.load(Ordering::SeqCst));\n+    assert_eq!(1, B.load(Ordering::SeqCst));\n+}"}, {"sha": "783a44beaf36a0b256a3d4b8a130fe8c300db549", "filename": "src/test/run-pass/panic-handler-flail-wildly.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-handler-flail-wildly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-handler-flail-wildly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-handler-flail-wildly.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(panic_handler, std_panic)]\n+\n+use std::panic;\n+use std::thread;\n+\n+fn a() {\n+    panic::set_handler(|_| println!(\"hello yes this is a\"));\n+    panic::take_handler();\n+    panic::set_handler(|_| println!(\"hello yes this is a part 2\"));\n+    panic::take_handler();\n+}\n+\n+fn b() {\n+    panic::take_handler();\n+    panic::take_handler();\n+    panic::take_handler();\n+    panic::take_handler();\n+    panic::take_handler();\n+    panic!();\n+}\n+\n+fn c() {\n+    panic::set_handler(|_| ());\n+    panic::set_handler(|_| ());\n+    panic::set_handler(|_| ());\n+    panic::set_handler(|_| ());\n+    panic::set_handler(|_| ());\n+    panic::set_handler(|_| ());\n+    panic!();\n+}\n+\n+fn main() {\n+    for _ in 0..10 {\n+        let mut handles = vec![];\n+        for _ in 0..10 {\n+            handles.push(thread::spawn(a));\n+        }\n+        for _ in 0..10 {\n+            handles.push(thread::spawn(b));\n+        }\n+        for _ in 0..10 {\n+            handles.push(thread::spawn(c));\n+        }\n+        for handle in handles {\n+            let _ = handle.join();\n+        }\n+    }\n+}"}, {"sha": "edf65e8e2aa699f373116e7d20bf5ef095df782e", "filename": "src/test/run-pass/panic-handler-set-twice.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-handler-set-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-handler-set-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-handler-set-twice.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(panic_handler, const_fn, std_panic)]\n+\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::panic;\n+use std::thread;\n+\n+static A: AtomicUsize = AtomicUsize::new(0);\n+\n+fn main() {\n+    panic::set_handler(|_| ());\n+    panic::set_handler(|info| { A.fetch_add(1, Ordering::SeqCst); });\n+\n+    let _ = thread::spawn(|| {\n+        panic!();\n+    }).join();\n+\n+    assert_eq!(1, A.load(Ordering::SeqCst));\n+}"}, {"sha": "9949b79278c11a2ecb871557a17ce481302d57d1", "filename": "src/test/run-pass/panic-safe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b838c586c4da31395d614d9f076430314fa05ff/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-safe.rs?ref=5b838c586c4da31395d614d9f076430314fa05ff", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)]\n #![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::{RecoverSafe, AssertRecoverSafe};\n use std::cell::RefCell;\n use std::sync::{Mutex, RwLock, Arc};\n use std::rc::Rc;\n@@ -47,5 +47,9 @@ fn main() {\n         assert::<Box<T>>();\n         assert::<Vec<T>>();\n         assert::<RefCell<T>>();\n+        assert::<AssertRecoverSafe<T>>();\n+        assert::<&AssertRecoverSafe<T>>();\n+        assert::<Rc<AssertRecoverSafe<T>>>();\n+        assert::<Arc<AssertRecoverSafe<T>>>();\n     }\n }"}]}