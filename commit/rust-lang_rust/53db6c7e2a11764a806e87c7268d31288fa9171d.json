{"sha": "53db6c7e2a11764a806e87c7268d31288fa9171d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZGI2YzdlMmExMTc2NGE4MDZlODdjNzI2OGQzMTI4OGZhOTE3MWQ=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-02-15T06:16:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-11T22:38:55Z"}, "message": "core: rt/core: impl os::env() in rust ref #4812", "tree": {"sha": "c835cfe8a43f81b6701704a8e6ad95ab2d4ae8d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c835cfe8a43f81b6701704a8e6ad95ab2d4ae8d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53db6c7e2a11764a806e87c7268d31288fa9171d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53db6c7e2a11764a806e87c7268d31288fa9171d", "html_url": "https://github.com/rust-lang/rust/commit/53db6c7e2a11764a806e87c7268d31288fa9171d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53db6c7e2a11764a806e87c7268d31288fa9171d/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bc26ce575b4bc6f7254a2cfe9fee0a08de90b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc26ce575b4bc6f7254a2cfe9fee0a08de90b49", "html_url": "https://github.com/rust-lang/rust/commit/4bc26ce575b4bc6f7254a2cfe9fee0a08de90b49"}], "stats": {"total": 236, "additions": 196, "deletions": 40}, "files": [{"sha": "9a45ffc5b2ebf3e87832a1b950e245cc04309ce9", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=53db6c7e2a11764a806e87c7268d31288fa9171d", "patch": "@@ -534,6 +534,7 @@ pub mod types {\n \n                 pub type LPCWSTR = *WCHAR;\n                 pub type LPCSTR = *CHAR;\n+                pub type LPTCH = *CHAR;\n \n                 pub type LPWSTR = *mut WCHAR;\n                 pub type LPSTR = *mut CHAR;\n@@ -1594,7 +1595,7 @@ pub mod funcs {\n \n         pub mod kernel32 {\n             use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n-            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR};\n+            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPTCH};\n             use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES};\n \n             #[abi = \"stdcall\"]\n@@ -1605,6 +1606,8 @@ pub mod funcs {\n                                                -> DWORD;\n                 unsafe fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR)\n                                                -> BOOL;\n+                unsafe fn GetEnvironmentStringsA() -> LPTCH;\n+                unsafe fn FreeEnvironmentStringsA(env_ptr: LPTCH) -> BOOL;\n \n                 unsafe fn GetModuleFileNameW(hModule: HMODULE,\n                                              lpFilename: LPWSTR,"}, {"sha": "a1793cc5efa848acb51a948f9c0928ee28776fa6", "filename": "src/libcore/os.rs", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=53db6c7e2a11764a806e87c7268d31288fa9171d", "patch": "@@ -171,20 +171,68 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n }\n \n pub fn env() -> ~[(~str,~str)] {\n-    extern {\n-        unsafe fn rust_env_pairs() -> ~[~str];\n-    }\n-\n     unsafe {\n-        do with_env_lock {\n+        #[cfg(windows)]\n+        unsafe fn get_env_pairs() -> ~[~str] {\n+            use libc::types::os::arch::extra::LPTCH;\n+            use libc::funcs::extra::kernel32::{\n+                GetEnvironmentStringsA,\n+                FreeEnvironmentStringsA\n+            };\n+            let ch = GetEnvironmentStringsA();\n+            if (ch as uint == 0) {\n+                fail!(fmt!(\"os::env() failure getting env string from OS: %s\",\n+                           os::last_os_error()));\n+            }\n+            let mut curr_ptr: uint = ch as uint;\n+            let mut result = ~[];\n+            while(*(curr_ptr as *libc::c_char) != 0 as libc::c_char) {\n+                let env_pair = str::raw::from_c_str(\n+                    curr_ptr as *libc::c_char);\n+                result.push(env_pair);\n+                curr_ptr +=\n+                    libc::strlen(curr_ptr as *libc::c_char) as uint\n+                    + 1;\n+            }\n+            FreeEnvironmentStringsA(ch);\n+            result\n+        }\n+        #[cfg(unix)]\n+        unsafe fn get_env_pairs() -> ~[~str] {\n+            extern mod rustrt {\n+                unsafe fn rust_env_pairs() -> **libc::c_char;\n+            }\n+            let environ = rustrt::rust_env_pairs();\n+            if (environ as uint == 0) {\n+                fail!(fmt!(\"os::env() failure getting env string from OS: %s\",\n+                           os::last_os_error()));\n+            }\n+            let mut result = ~[];\n+            ptr::array_each(environ, |e| {\n+                let env_pair = str::raw::from_c_str(e);\n+                log(debug, fmt!(\"get_env_pairs: %s\",\n+                                env_pair));\n+                result.push(env_pair);\n+            });\n+            result\n+        }\n+\n+        fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n-            for vec::each(rust_env_pairs()) |p| {\n-                let vs = str::splitn_char(*p, '=', 1u);\n-                fail_unless!(vec::len(vs) == 2u);\n+            for input.each |p| {\n+                let vs = str::splitn_char(*p, '=', 1);\n+                log(debug,\n+                    fmt!(\"splitting: len: %u\",\n+                    vs.len()));\n+                assert vs.len() == 2;\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n             pairs\n         }\n+        do with_env_lock {\n+            let unparsed_environ = get_env_pairs();\n+            env_convert(unparsed_environ)\n+        }\n     }\n }\n "}, {"sha": "042720e1b4e7dbe6a235b3bdde96c28ef87025fa", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=53db6c7e2a11764a806e87c7268d31288fa9171d", "patch": "@@ -18,6 +18,8 @@ use sys;\n \n #[cfg(test)] use vec;\n #[cfg(test)] use str;\n+#[cfg(test)] use uint;\n+#[cfg(test)] use debug;\n #[cfg(notest)] use cmp::{Eq, Ord};\n \n pub mod libc_ {\n@@ -181,6 +183,46 @@ pub pure fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n+/**\n+  Given a **T (pointer to an array of pointers),\n+  iterate through each *T, up to the provided `len`,\n+  passing to the provided callback function\n+\n+  SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n+*/\n+pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: fn(*T)) {\n+    log(debug, \"array_each_with_len: before iterate\");\n+    if (arr as uint == 0) {\n+        fail!(~\"ptr::array_each_with_len failure: arr input is null pointer\");\n+    }\n+    //let start_ptr = *arr;\n+    uint::iterate(0, len, |e| {\n+        let n = offset(arr, e);\n+        cb(*n);\n+        true\n+    });\n+    log(debug, \"array_each_with_len: after iterate\");\n+}\n+\n+/**\n+  Given a null-pointer-terminated **T (pointer to\n+  an array of pointers), iterate through each *T,\n+  passing to the provided callback function\n+\n+  SAFETY NOTE: This will only work with a null-terminated\n+  pointer array. Barely less-dodgey Pointer Arithmetic.\n+  Dragons be here.\n+*/\n+pub unsafe fn array_each<T>(arr: **T, cb: fn(*T)) {\n+    if (arr as uint == 0) {\n+        fail!(~\"ptr::array_each_with_len failure: arr input is null pointer\");\n+    }\n+    let len = buf_len(arr);\n+    log(debug, fmt!(\"array_each inferred len: %u\",\n+                    len));\n+    array_each_with_len(arr, len, cb);\n+}\n+\n pub trait Ptr<T> {\n     pure fn is_null(&self) -> bool;\n     pure fn is_not_null(&self) -> bool;\n@@ -389,3 +431,93 @@ pub fn test_is_null() {\n    fail_unless!(!mq.is_null());\n    fail_unless!(mq.is_not_null());\n }\n+\n+#[cfg(test)]\n+pub mod ptr_tests {\n+    use debug;\n+    use ptr;\n+    use str;\n+    use libc;\n+    use vec;\n+    #[test]\n+    pub fn test_ptr_array_each_with_len() {\n+        unsafe {\n+            let one = ~\"oneOne\";\n+            let two = ~\"twoTwo\";\n+            let three = ~\"threeThree\";\n+            let arr: ~[*i8] = ~[\n+                ::cast::transmute(&one[0]),\n+                ::cast::transmute(&two[0]),\n+                ::cast::transmute(&three[0]),\n+            ];\n+            let expected_arr = [\n+                one, two, three\n+            ];\n+            let arr_ptr = &arr[0];\n+            let mut ctr = 0;\n+            let mut iteration_count = 0;\n+            ptr::array_each_with_len(arr_ptr, vec::len(arr),\n+                |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = copy expected_arr[ctr];\n+                log(debug,\n+                    fmt!(\"test_ptr_array_each e: %s, a: %s\",\n+                         expected, actual));\n+                assert actual == expected;\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+            assert iteration_count == 3u;\n+        }\n+    }\n+    #[test]\n+    pub fn test_ptr_array_each() {\n+        unsafe {\n+            let one = ~\"oneOne\";\n+            let two = ~\"twoTwo\";\n+            let three = ~\"threeThree\";\n+            let arr: ~[*i8] = ~[\n+                ::cast::transmute(&one[0]),\n+                ::cast::transmute(&two[0]),\n+                ::cast::transmute(&three[0]),\n+                // fake a null terminator\n+                0 as *i8\n+            ];\n+            let expected_arr = [\n+                one, two, three\n+            ];\n+            let arr_ptr = &arr[0];\n+            let mut ctr = 0;\n+            let mut iteration_count = 0;\n+            ptr::array_each(arr_ptr, |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = copy expected_arr[ctr];\n+                log(debug,\n+                    fmt!(\"test_ptr_array_each e: %s, a: %s\",\n+                         expected, actual));\n+                assert actual == expected;\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+            assert iteration_count == 3;\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    pub fn test_ptr_array_each_with_len_null_ptr() {\n+        unsafe {\n+            ptr::array_each_with_len(0 as **libc::c_char, 1, |e| {\n+                str::raw::from_c_str(e);\n+            });\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    pub fn test_ptr_array_each_null_ptr() {\n+        unsafe {\n+            ptr::array_each(0 as **libc::c_char, |e| {\n+                str::raw::from_c_str(e);\n+            });\n+        }\n+    }\n+}"}, {"sha": "2c9c4a706812f648ff4f47c1f59ae84b28674492", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/53db6c7e2a11764a806e87c7268d31288fa9171d/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=53db6c7e2a11764a806e87c7268d31288fa9171d", "patch": "@@ -53,44 +53,17 @@ timegm(struct tm *tm)\n #endif\n \n #if defined(__WIN32__)\n-extern \"C\" CDECL rust_vec_box *\n+extern \"C\" CDECL char**\n rust_env_pairs() {\n-    rust_task *task = rust_get_current_task();\n-    size_t envc = 0;\n-    LPTCH ch = GetEnvironmentStringsA();\n-    LPTCH c;\n-    for (c = ch; *c; c += strlen(c) + 1) {\n-        ++envc;\n-    }\n-    c = ch;\n-    rust_vec_box *v = (rust_vec_box *)\n-        task->kernel->malloc(vec_size<rust_vec_box*>(envc),\n-                       \"str vec interior\");\n-    v->body.fill = v->body.alloc = sizeof(rust_vec*) * envc;\n-    for (size_t i = 0; i < envc; ++i) {\n-        size_t n = strlen(c);\n-        rust_str *str = make_str(task->kernel, c, n, \"str\");\n-        ((rust_str**)&v->body.data)[i] = str;\n-        c += n + 1;\n-    }\n-    if (ch) {\n-        FreeEnvironmentStrings(ch);\n-    }\n-    return v;\n+    return 0;\n }\n #else\n-extern \"C\" CDECL rust_vec_box *\n+extern \"C\" CDECL char**\n rust_env_pairs() {\n-    rust_task *task = rust_get_current_task();\n #ifdef __APPLE__\n     char **environ = *_NSGetEnviron();\n #endif\n-    char **e = environ;\n-    size_t envc = 0;\n-    while (*e) {\n-        ++envc; ++e;\n-    }\n-    return make_str_vec(task->kernel, envc, environ);\n+    return environ;\n }\n #endif\n "}]}