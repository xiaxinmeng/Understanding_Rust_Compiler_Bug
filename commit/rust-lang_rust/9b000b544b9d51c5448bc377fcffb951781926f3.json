{"sha": "9b000b544b9d51c5448bc377fcffb951781926f3", "node_id": "C_kwDOAAsO6NoAKDliMDAwYjU0NGI5ZDUxYzU0NDhiYzM3N2ZjZmZiOTUxNzgxOTI2ZjM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-31T13:01:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-31T13:01:10Z"}, "message": "Merge #11827\n\n11827: internal: Enforce Invariant that Resolver always contains a ModuleScope r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "6f957f3ac95899e0ebfe65b268a261eb9d294e75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f957f3ac95899e0ebfe65b268a261eb9d294e75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b000b544b9d51c5448bc377fcffb951781926f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiRaYWCRBK7hj4Ov3rIwAAp70IADNzjGMWUIkWRZ/8lrya3kFb\nJ2n3+GRq5SeQ1aWzB8qpV00QYyKNQd9ZJGu+PLheAR/TDvtX2AAf+Y8mbrbNm7vr\neH1tuzi9f18NJLTlDW0k974orhb9wu7Hs5k8KW9NV4qh53uVtwlRiikjYNqegr1P\n0Oc0dtXLKuK4dxZXAe0js2ght7s5MzNmJd5UWH7nXDaFav/vS6sbPXBZML5GtFXl\nukjrhZlqLTv3SysLxh5LhuxcdBulQADN1Pq5rY14/zI9NEgdM7RmOC+L1LmRKLA+\nrLymc2ApdK80WSRKbvEaCgXMaKi8Nx7ZiTwk+p300vAHXr0ASfW796YbbAI472M=\n=3xyo\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f957f3ac95899e0ebfe65b268a261eb9d294e75\nparent 9da9418661c2a357b291d6adf11ea296d9dd924a\nparent 75689f2ad8f74bbbff1f44f75330b2e4d43ed44a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648731670 +0000\ncommitter GitHub <noreply@github.com> 1648731670 +0000\n\nMerge #11827\n\n11827: internal: Enforce Invariant that Resolver always contains a ModuleScope r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b000b544b9d51c5448bc377fcffb951781926f3", "html_url": "https://github.com/rust-lang/rust/commit/9b000b544b9d51c5448bc377fcffb951781926f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b000b544b9d51c5448bc377fcffb951781926f3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da9418661c2a357b291d6adf11ea296d9dd924a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da9418661c2a357b291d6adf11ea296d9dd924a", "html_url": "https://github.com/rust-lang/rust/commit/9da9418661c2a357b291d6adf11ea296d9dd924a"}, {"sha": "75689f2ad8f74bbbff1f44f75330b2e4d43ed44a", "url": "https://api.github.com/repos/rust-lang/rust/commits/75689f2ad8f74bbbff1f44f75330b2e4d43ed44a", "html_url": "https://github.com/rust-lang/rust/commit/75689f2ad8f74bbbff1f44f75330b2e4d43ed44a"}], "stats": {"total": 1005, "additions": 504, "deletions": 501}, "files": [{"sha": "daa0e3f6997f72cdb576cd61ae9697cd20209c7d", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -10,7 +10,7 @@ use tt::Subtree;\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n-    input::{CrateName, CrateOrigin},\n+    input::{CrateName, CrateOrigin, LangCrateOrigin},\n     Change, CrateDisplayName, CrateGraph, CrateId, Dependency, Edition, Env, FileId, FilePosition,\n     FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, SourceDatabaseExt,\n     SourceRoot, SourceRootId,\n@@ -196,7 +196,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 Default::default(),\n                 false,\n-                Default::default(),\n+                CrateOrigin::CratesIo { repo: None },\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -233,7 +233,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 Vec::new(),\n                 false,\n-                CrateOrigin::Lang,\n+                CrateOrigin::Lang(LangCrateOrigin::Core),\n             );\n \n             for krate in all_crates {\n@@ -270,7 +270,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 proc_macro,\n                 true,\n-                CrateOrigin::Lang,\n+                CrateOrigin::CratesIo { repo: None },\n             );\n \n             for krate in all_crates {\n@@ -406,7 +406,11 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n         };\n         (a.to_owned(), origin, Some(version.to_string()))\n     } else {\n-        (crate_str, CrateOrigin::Unknown, None)\n+        let crate_origin = match &*crate_str {\n+            \"std\" => CrateOrigin::Lang(LangCrateOrigin::Std),\n+            _ => CrateOrigin::CratesIo { repo: None },\n+        };\n+        (crate_str, crate_origin, None)\n     }\n }\n "}, {"sha": "43d7ccad492d8ad7eb33f15f71e8eb88b54e6e2a", "filename": "crates/base_db/src/input.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fbase_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fbase_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Finput.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -117,21 +117,22 @@ impl ops::Deref for CrateName {\n }\n \n /// Origin of the crates. It is used in emitting monikers.\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum CrateOrigin {\n     /// Crates that are from crates.io official registry,\n     CratesIo { repo: Option<String> },\n     /// Crates that are provided by the language, like std, core, proc-macro, ...\n-    Lang,\n-    /// Crates that we don't know their origin.\n-    // Ideally this enum should cover all cases, and then we remove this variant.\n-    Unknown,\n+    Lang(LangCrateOrigin),\n }\n \n-impl Default for CrateOrigin {\n-    fn default() -> Self {\n-        Self::Unknown\n-    }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum LangCrateOrigin {\n+    Alloc,\n+    Core,\n+    ProcMacro,\n+    Std,\n+    Test,\n+    Other,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -585,6 +586,8 @@ impl fmt::Display for CyclicDependenciesError {\n \n #[cfg(test)]\n mod tests {\n+    use crate::CrateOrigin;\n+\n     use super::{CfgOptions, CrateGraph, CrateName, Dependency, Edition::Edition2018, Env, FileId};\n \n     #[test]\n@@ -600,7 +603,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -612,7 +615,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -624,7 +627,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -650,7 +653,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -662,7 +665,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -685,7 +688,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -697,7 +700,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -709,7 +712,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -732,7 +735,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -744,7 +747,7 @@ mod tests {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         assert!(graph\n             .add_dep("}, {"sha": "2454698bb61c64c2babd1874be5ad4546a207cff", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -12,8 +12,8 @@ pub use crate::{\n     change::Change,\n     input::{\n         CrateData, CrateDisplayName, CrateGraph, CrateId, CrateName, CrateOrigin, Dependency,\n-        Edition, Env, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacroId,\n-        ProcMacroKind, SourceRoot, SourceRootId,\n+        Edition, Env, LangCrateOrigin, ProcMacro, ProcMacroExpander, ProcMacroExpansionError,\n+        ProcMacroId, ProcMacroKind, SourceRoot, SourceRootId,\n     },\n };\n pub use salsa::{self, Cancelled};"}, {"sha": "8b99662685c52d85e6a4c9658ff2526c7d76ec4d", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -148,6 +148,10 @@ impl Crate {\n         db.crate_graph()[self.id].origin.clone()\n     }\n \n+    pub fn is_builtin(self, db: &dyn HirDatabase) -> bool {\n+        matches!(self.origin(db), CrateOrigin::Lang(_))\n+    }\n+\n     pub fn dependencies(self, db: &dyn HirDatabase) -> Vec<CrateDependency> {\n         db.crate_graph()[self.id]\n             .dependencies\n@@ -1741,10 +1745,8 @@ impl BuiltinType {\n         BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }\n     }\n \n-    pub fn ty(self, db: &dyn HirDatabase, module: Module) -> Type {\n-        let resolver = module.id.resolver(db.upcast());\n-        Type::new_with_resolver(db, &resolver, TyBuilder::builtin(self.inner))\n-            .expect(\"crate not present in resolver\")\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::new_for_crate(db.crate_graph().iter().next().unwrap(), TyBuilder::builtin(self.inner))\n     }\n \n     pub fn name(self) -> Name {\n@@ -2222,7 +2224,7 @@ impl BuiltinAttr {\n         Some(BuiltinAttr { krate: Some(krate.id), idx })\n     }\n \n-    pub(crate) fn builtin(name: &str) -> Option<Self> {\n+    fn builtin(name: &str) -> Option<Self> {\n         hir_def::builtin_attr::INERT_ATTRIBUTES\n             .iter()\n             .position(|tool| tool.name == name)\n@@ -2261,7 +2263,7 @@ impl ToolModule {\n         Some(ToolModule { krate: Some(krate.id), idx })\n     }\n \n-    pub(crate) fn builtin(name: &str) -> Option<Self> {\n+    fn builtin(name: &str) -> Option<Self> {\n         hir_def::builtin_attr::TOOL_MODULES\n             .iter()\n             .position(|&tool| tool == name)\n@@ -2611,14 +2613,11 @@ pub struct Type {\n }\n \n impl Type {\n-    pub(crate) fn new_with_resolver(\n-        db: &dyn HirDatabase,\n-        resolver: &Resolver,\n-        ty: Ty,\n-    ) -> Option<Type> {\n-        let krate = resolver.krate()?;\n-        Some(Type::new_with_resolver_inner(db, krate, resolver, ty))\n+    pub(crate) fn new_with_resolver(db: &dyn HirDatabase, resolver: &Resolver, ty: Ty) -> Type {\n+        let krate = resolver.krate();\n+        Type::new_with_resolver_inner(db, krate, resolver, ty)\n     }\n+\n     pub(crate) fn new_with_resolver_inner(\n         db: &dyn HirDatabase,\n         krate: CrateId,\n@@ -2631,6 +2630,10 @@ impl Type {\n         Type { krate, env: environment, ty }\n     }\n \n+    pub(crate) fn new_for_crate(krate: CrateId, ty: Ty) -> Type {\n+        Type { krate, env: Arc::new(TraitEnvironment::empty(krate)), ty }\n+    }\n+\n     pub fn reference(inner: &Type, m: Mutability) -> Type {\n         inner.derived(\n             TyKind::Ref(\n@@ -3031,10 +3034,7 @@ impl Type {\n         // There should be no inference vars in types passed here\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n-        let krate = match scope.krate() {\n-            Some(k) => k,\n-            None => return,\n-        };\n+        let krate = scope.krate();\n         let environment = scope.resolver().generic_def().map_or_else(\n             || Arc::new(TraitEnvironment::empty(krate.id)),\n             |d| db.trait_environment(d),\n@@ -3091,10 +3091,7 @@ impl Type {\n     ) {\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n-        let krate = match scope.krate() {\n-            Some(k) => k,\n-            None => return,\n-        };\n+        let krate = scope.krate();\n         let environment = scope.resolver().generic_def().map_or_else(\n             || Arc::new(TraitEnvironment::empty(krate.id)),\n             |d| db.trait_environment(d),"}, {"sha": "8a700027a3ad3719173fc66c115e68c670218cb1", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 73, "deletions": 48, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -403,11 +403,15 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.to_module_def(file)\n     }\n \n-    pub fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n+    pub fn scope(&self, node: &SyntaxNode) -> Option<SemanticsScope<'db>> {\n         self.imp.scope(node)\n     }\n \n-    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n+    pub fn scope_at_offset(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextSize,\n+    ) -> Option<SemanticsScope<'db>> {\n         self.imp.scope_at_offset(node, offset)\n     }\n \n@@ -456,7 +460,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n-        let sa = self.analyze_no_infer(macro_call.syntax());\n+        let sa = self.analyze_no_infer(macro_call.syntax())?;\n         let file_id = sa.expand(self.db, InFile::new(sa.file_id, macro_call))?;\n         let node = self.parse_or_expand(file_id)?;\n         Some(node)\n@@ -535,9 +539,9 @@ impl<'db> SemanticsImpl<'db> {\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n         let SourceAnalyzer { file_id, resolver, .. } =\n-            self.analyze_no_infer(actual_macro_call.syntax());\n+            self.analyze_no_infer(actual_macro_call.syntax())?;\n         let macro_call = InFile::new(file_id, actual_macro_call);\n-        let krate = resolver.krate()?;\n+        let krate = resolver.krate();\n         let macro_call_id = macro_call.as_call_id(self.db.upcast(), krate, |path| {\n             resolver\n                 .resolve_path_as_macro(self.db.upcast(), &path)\n@@ -669,7 +673,10 @@ impl<'db> SemanticsImpl<'db> {\n             Some(it) => it,\n             None => return,\n         };\n-        let sa = self.analyze_no_infer(&parent);\n+        let sa = match self.analyze_no_infer(&parent) {\n+            Some(it) => it,\n+            None => return,\n+        };\n         let mut stack: SmallVec<[_; 4]> = smallvec![InFile::new(sa.file_id, token)];\n         let mut cache = self.expansion_info_cache.borrow_mut();\n         let mut mcache = self.macro_call_cache.borrow_mut();\n@@ -903,70 +910,74 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn resolve_type(&self, ty: &ast::Type) -> Option<Type> {\n-        let scope = self.scope(ty.syntax());\n-        let ctx = body::LowerCtx::new(self.db.upcast(), scope.file_id);\n-        let ty = hir_ty::TyLoweringContext::new(self.db, &scope.resolver)\n+        let analyze = self.analyze(ty.syntax())?;\n+        let ctx = body::LowerCtx::new(self.db.upcast(), analyze.file_id);\n+        let ty = hir_ty::TyLoweringContext::new(self.db, &analyze.resolver)\n             .lower_ty(&crate::TypeRef::from_ast(&ctx, ty.clone()));\n-        Type::new_with_resolver(self.db, &scope.resolver, ty)\n+        Some(Type::new_with_resolver(self.db, &analyze.resolver, ty))\n     }\n \n     fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n-        self.analyze(expr.syntax()).is_implicit_reborrow(self.db, expr)\n+        self.analyze(expr.syntax())?.is_implicit_reborrow(self.db, expr)\n     }\n \n     fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n-        self.analyze(expr.syntax())\n+        self.analyze(expr.syntax())?\n             .type_of_expr(self.db, expr)\n             .map(|(ty, coerced)| TypeInfo { original: ty, adjusted: coerced })\n     }\n \n     fn type_of_pat(&self, pat: &ast::Pat) -> Option<TypeInfo> {\n-        self.analyze(pat.syntax())\n+        self.analyze(pat.syntax())?\n             .type_of_pat(self.db, pat)\n             .map(|(ty, coerced)| TypeInfo { original: ty, adjusted: coerced })\n     }\n \n     fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n-        self.analyze(param.syntax()).type_of_self(self.db, param)\n+        self.analyze(param.syntax())?.type_of_self(self.db, param)\n     }\n \n     fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n-        self.analyze(call.syntax()).resolve_method_call(self.db, call).map(|(id, _)| id)\n+        self.analyze(call.syntax())?.resolve_method_call(self.db, call).map(|(id, _)| id)\n     }\n \n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n-        let (func, subst) = self.analyze(call.syntax()).resolve_method_call(self.db, call)?;\n+        let source_analyzer = self.analyze(call.syntax())?;\n+        let (func, subst) = source_analyzer.resolve_method_call(self.db, call)?;\n         let ty = self.db.value_ty(func.into()).substitute(Interner, &subst);\n-        let resolver = self.analyze(call.syntax()).resolver;\n-        let ty = Type::new_with_resolver(self.db, &resolver, ty)?;\n+        let resolver = source_analyzer.resolver;\n+        let ty = Type::new_with_resolver(self.db, &resolver, ty);\n         let mut res = ty.as_callable(self.db)?;\n         res.is_bound_method = true;\n         Some(res)\n     }\n \n     fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {\n-        self.analyze(field.syntax()).resolve_field(self.db, field)\n+        self.analyze(field.syntax())?.resolve_field(self.db, field)\n     }\n \n     fn resolve_record_field(\n         &self,\n         field: &ast::RecordExprField,\n     ) -> Option<(Field, Option<Local>, Type)> {\n-        self.analyze(field.syntax()).resolve_record_field(self.db, field)\n+        self.analyze(field.syntax())?.resolve_record_field(self.db, field)\n     }\n \n     fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n-        self.analyze(field.syntax()).resolve_record_pat_field(self.db, field)\n+        self.analyze(field.syntax())?.resolve_record_pat_field(self.db, field)\n     }\n \n     fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<Macro> {\n-        let sa = self.analyze(macro_call.syntax());\n+        let sa = self.analyze(macro_call.syntax())?;\n         let macro_call = self.find_file(macro_call.syntax()).with_value(macro_call);\n         sa.resolve_macro_call(self.db, macro_call)\n     }\n \n     fn is_unsafe_macro_call(&self, macro_call: &ast::MacroCall) -> bool {\n-        let sa = self.analyze(macro_call.syntax());\n+        let sa = match self.analyze(macro_call.syntax()) {\n+            Some(it) => it,\n+            None => return false,\n+        };\n         let macro_call = self.find_file(macro_call.syntax()).with_value(macro_call);\n         sa.is_unsafe_macro_call(self.db, macro_call)\n     }\n@@ -981,11 +992,11 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn resolve_path(&self, path: &ast::Path) -> Option<PathResolution> {\n-        self.analyze(path.syntax()).resolve_path(self.db, path)\n+        self.analyze(path.syntax())?.resolve_path(self.db, path)\n     }\n \n     fn resolve_extern_crate(&self, extern_crate: &ast::ExternCrate) -> Option<Crate> {\n-        let krate = self.scope(extern_crate.syntax()).krate()?;\n+        let krate = self.scope(extern_crate.syntax())?.krate();\n         let name = extern_crate.name_ref()?.as_name();\n         if name == known::SELF_PARAM {\n             return Some(krate);\n@@ -997,22 +1008,22 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {\n-        self.analyze(record_lit.syntax()).resolve_variant(self.db, record_lit)\n+        self.analyze(record_lit.syntax())?.resolve_variant(self.db, record_lit)\n     }\n \n     fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n-        self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n+        self.analyze(pat.syntax())?.resolve_bind_pat_to_const(self.db, pat)\n     }\n \n     fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.analyze(literal.syntax())\n-            .record_literal_missing_fields(self.db, literal)\n+            .and_then(|it| it.record_literal_missing_fields(self.db, literal))\n             .unwrap_or_default()\n     }\n \n     fn record_pattern_missing_fields(&self, pattern: &ast::RecordPat) -> Vec<(Field, Type)> {\n         self.analyze(pattern.syntax())\n-            .record_pattern_missing_fields(self.db, pattern)\n+            .and_then(|it| it.record_pattern_missing_fields(self.db, pattern))\n             .unwrap_or_default()\n     }\n \n@@ -1026,15 +1037,22 @@ impl<'db> SemanticsImpl<'db> {\n         self.with_ctx(|ctx| ctx.file_to_def(file)).into_iter().map(Module::from)\n     }\n \n-    fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n-        let SourceAnalyzer { file_id, resolver, .. } = self.analyze_no_infer(node);\n-        SemanticsScope { db: self.db, file_id, resolver }\n+    fn scope(&self, node: &SyntaxNode) -> Option<SemanticsScope<'db>> {\n+        self.analyze_no_infer(node).map(|SourceAnalyzer { file_id, resolver, .. }| SemanticsScope {\n+            db: self.db,\n+            file_id,\n+            resolver,\n+        })\n     }\n \n-    fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n-        let SourceAnalyzer { file_id, resolver, .. } =\n-            self.analyze_with_offset_no_infer(node, offset);\n-        SemanticsScope { db: self.db, file_id, resolver }\n+    fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> Option<SemanticsScope<'db>> {\n+        self.analyze_with_offset_no_infer(node, offset).map(\n+            |SourceAnalyzer { file_id, resolver, .. }| SemanticsScope {\n+                db: self.db,\n+                file_id,\n+                resolver,\n+            },\n+        )\n     }\n \n     fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n@@ -1052,15 +1070,21 @@ impl<'db> SemanticsImpl<'db> {\n         Some(res)\n     }\n \n-    fn analyze(&self, node: &SyntaxNode) -> SourceAnalyzer {\n+    /// Returns none if the file of the node is not part of a crate.\n+    fn analyze(&self, node: &SyntaxNode) -> Option<SourceAnalyzer> {\n         self.analyze_impl(node, None, true)\n     }\n \n-    fn analyze_no_infer(&self, node: &SyntaxNode) -> SourceAnalyzer {\n+    /// Returns none if the file of the node is not part of a crate.\n+    fn analyze_no_infer(&self, node: &SyntaxNode) -> Option<SourceAnalyzer> {\n         self.analyze_impl(node, None, false)\n     }\n \n-    fn analyze_with_offset_no_infer(&self, node: &SyntaxNode, offset: TextSize) -> SourceAnalyzer {\n+    fn analyze_with_offset_no_infer(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextSize,\n+    ) -> Option<SourceAnalyzer> {\n         self.analyze_impl(node, Some(offset), false)\n     }\n \n@@ -1069,22 +1093,22 @@ impl<'db> SemanticsImpl<'db> {\n         node: &SyntaxNode,\n         offset: Option<TextSize>,\n         infer_body: bool,\n-    ) -> SourceAnalyzer {\n+    ) -> Option<SourceAnalyzer> {\n         let _p = profile::span(\"Semantics::analyze_impl\");\n         let node = self.find_file(node);\n \n         let container = match self.with_ctx(|ctx| ctx.find_container(node)) {\n             Some(it) => it,\n-            None => return SourceAnalyzer::new_for_resolver(Resolver::default(), node),\n+            None => return None,\n         };\n \n         let resolver = match container {\n             ChildContainer::DefWithBodyId(def) => {\n-                return if infer_body {\n+                return Some(if infer_body {\n                     SourceAnalyzer::new_for_body(self.db, def, node, offset)\n                 } else {\n                     SourceAnalyzer::new_for_body_no_infer(self.db, def, node, offset)\n-                }\n+                })\n             }\n             ChildContainer::TraitId(it) => it.resolver(self.db.upcast()),\n             ChildContainer::ImplId(it) => it.resolver(self.db.upcast()),\n@@ -1094,7 +1118,7 @@ impl<'db> SemanticsImpl<'db> {\n             ChildContainer::TypeAliasId(it) => it.resolver(self.db.upcast()),\n             ChildContainer::GenericDefId(it) => it.resolver(self.db.upcast()),\n         };\n-        SourceAnalyzer::new_for_resolver(resolver, node)\n+        Some(SourceAnalyzer::new_for_resolver(resolver, node))\n     }\n \n     fn cache(&self, root_node: SyntaxNode, file_id: HirFileId) {\n@@ -1118,6 +1142,7 @@ impl<'db> SemanticsImpl<'db> {\n         InFile::new(file_id, node)\n     }\n \n+    /// Wraps the node in a [`InFile`] with the file id it belongs to.\n     fn find_file<'node>(&self, node: &'node SyntaxNode) -> InFile<&'node SyntaxNode> {\n         let root_node = find_root(node);\n         let file_id = self.lookup(&root_node).unwrap_or_else(|| {\n@@ -1319,12 +1344,12 @@ pub struct SemanticsScope<'a> {\n }\n \n impl<'a> SemanticsScope<'a> {\n-    pub fn module(&self) -> Option<Module> {\n-        Some(Module { id: self.resolver.module()? })\n+    pub fn module(&self) -> Module {\n+        Module { id: self.resolver.module() }\n     }\n \n-    pub fn krate(&self) -> Option<Crate> {\n-        Some(Crate { id: self.resolver.krate()? })\n+    pub fn krate(&self) -> Crate {\n+        Crate { id: self.resolver.krate() }\n     }\n \n     pub(crate) fn resolver(&self) -> &Resolver {"}, {"sha": "f91844342731aa1975aa0b3824fa2628f56dea96", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -169,7 +169,7 @@ impl SourceAnalyzer {\n             .and_then(|adjusts| adjusts.last().map(|adjust| adjust.target.clone()));\n         let ty = infer[expr_id].clone();\n         let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n-        mk_ty(ty).zip(Some(coerced.and_then(mk_ty)))\n+        Some((mk_ty(ty), coerced.map(mk_ty)))\n     }\n \n     pub(crate) fn type_of_pat(\n@@ -185,7 +185,7 @@ impl SourceAnalyzer {\n             .and_then(|adjusts| adjusts.last().map(|adjust| adjust.target.clone()));\n         let ty = infer[pat_id].clone();\n         let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n-        mk_ty(ty).zip(Some(coerced.and_then(mk_ty)))\n+        Some((mk_ty(ty), coerced.map(mk_ty)))\n     }\n \n     pub(crate) fn type_of_self(\n@@ -196,7 +196,7 @@ impl SourceAnalyzer {\n         let src = InFile { file_id: self.file_id, value: param };\n         let pat_id = self.body_source_map()?.node_self_param(src)?;\n         let ty = self.infer.as_ref()?[pat_id].clone();\n-        Type::new_with_resolver(db, &self.resolver, ty)\n+        Some(Type::new_with_resolver(db, &self.resolver, ty))\n     }\n \n     pub(crate) fn resolve_method_call(\n@@ -244,7 +244,7 @@ impl SourceAnalyzer {\n         let field = FieldId { parent: variant, local_id: variant_data.field(&local_name)? };\n         let field_ty =\n             db.field_types(variant).get(field.local_id)?.clone().substitute(Interner, subst);\n-        Some((field.into(), local, Type::new_with_resolver(db, &self.resolver, field_ty)?))\n+        Some((field.into(), local, Type::new_with_resolver(db, &self.resolver, field_ty)))\n     }\n \n     pub(crate) fn resolve_record_pat_field(\n@@ -366,11 +366,8 @@ impl SourceAnalyzer {\n             return match resolve_hir_path_qualifier(db, &self.resolver, &hir_path) {\n                 None if is_path_of_attr => {\n                     path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n-                        match self.resolver.krate() {\n-                            Some(krate) => ToolModule::by_name(db, krate.into(), &name_ref.text()),\n-                            None => ToolModule::builtin(&name_ref.text()),\n-                        }\n-                        .map(PathResolution::ToolModule)\n+                        ToolModule::by_name(db, self.resolver.krate().into(), &name_ref.text())\n+                            .map(PathResolution::ToolModule)\n                     })\n                 }\n                 res => res,\n@@ -380,9 +377,8 @@ impl SourceAnalyzer {\n             // in this case we have to check for inert/builtin attributes and tools and prioritize\n             // resolution of attributes over other namespaces\n             let name_ref = path.as_single_name_ref();\n-            let builtin = name_ref.as_ref().and_then(|name_ref| match self.resolver.krate() {\n-                Some(krate) => BuiltinAttr::by_name(db, krate.into(), &name_ref.text()),\n-                None => BuiltinAttr::builtin(&name_ref.text()),\n+            let builtin = name_ref.as_ref().and_then(|name_ref| {\n+                BuiltinAttr::by_name(db, self.resolver.krate().into(), &name_ref.text())\n             });\n             if let builtin @ Some(_) = builtin {\n                 return builtin.map(PathResolution::BuiltinAttr);\n@@ -392,11 +388,8 @@ impl SourceAnalyzer {\n                 // this labels any path that starts with a tool module as the tool itself, this is technically wrong\n                 // but there is no benefit in differentiating these two cases for the time being\n                 None => path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n-                    match self.resolver.krate() {\n-                        Some(krate) => ToolModule::by_name(db, krate.into(), &name_ref.text()),\n-                        None => ToolModule::builtin(&name_ref.text()),\n-                    }\n-                    .map(PathResolution::ToolModule)\n+                    ToolModule::by_name(db, self.resolver.krate().into(), &name_ref.text())\n+                        .map(PathResolution::ToolModule)\n                 }),\n             };\n         }\n@@ -412,7 +405,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         literal: &ast::RecordExpr,\n     ) -> Option<Vec<(Field, Type)>> {\n-        let krate = self.resolver.krate()?;\n+        let krate = self.resolver.krate();\n         let body = self.body()?;\n         let infer = self.infer.as_ref()?;\n \n@@ -430,7 +423,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         pattern: &ast::RecordPat,\n     ) -> Option<Vec<(Field, Type)>> {\n-        let krate = self.resolver.krate()?;\n+        let krate = self.resolver.krate();\n         let body = self.body()?;\n         let infer = self.infer.as_ref()?;\n \n@@ -468,7 +461,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<HirFileId> {\n-        let krate = self.resolver.krate()?;\n+        let krate = self.resolver.krate();\n         let macro_call_id = macro_call.as_call_id(db.upcast(), krate, |path| {\n             self.resolver\n                 .resolve_path_as_macro(db.upcast(), &path)"}, {"sha": "fe0100fb8cc282d468a21151eafcabc9340827b0", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -25,12 +25,14 @@ use crate::{\n     StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, VariantId,\n };\n \n-#[derive(Debug, Clone, Default)]\n+#[derive(Debug, Clone)]\n pub struct Resolver {\n     /// The stack of scopes, where the inner-most scope is the last item.\n     ///\n     /// When using, you generally want to process the scopes in reverse order,\n     /// there's `scopes` *method* for that.\n+    ///\n+    /// Invariant: There exists at least one Scope::ModuleScope at the start of the vec.\n     scopes: Vec<Scope>,\n }\n \n@@ -135,10 +137,7 @@ impl Resolver {\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n-        let (item_map, module) = match self.module_scope() {\n-            Some(it) => it,\n-            None => return PerNs::none(),\n-        };\n+        let (item_map, module) = self.module_scope();\n         let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n         if segment_index.is_some() {\n             return PerNs::none();\n@@ -155,7 +154,7 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<PerNs> {\n-        let (item_map, module) = self.module_scope()?;\n+        let (item_map, module) = self.module_scope();\n         let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n         match module_res.take_types()? {\n             ModuleDefId::TraitId(it) => {\n@@ -235,10 +234,7 @@ impl Resolver {\n     ) -> Option<Visibility> {\n         match visibility {\n             RawVisibility::Module(_) => {\n-                let (item_map, module) = match self.module_scope() {\n-                    Some(it) => it,\n-                    None => return None,\n-                };\n+                let (item_map, module) = self.module_scope();\n                 item_map.resolve_visibility(db, module, visibility)\n             }\n             RawVisibility::Public => Some(Visibility::Public),\n@@ -336,7 +332,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n-        let (item_map, module) = self.module_scope()?;\n+        let (item_map, module) = self.module_scope();\n         item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n@@ -425,22 +421,22 @@ impl Resolver {\n         traits\n     }\n \n-    fn module_scope(&self) -> Option<(&DefMap, LocalModuleId)> {\n-        self.scopes().find_map(|scope| match scope {\n-            Scope::ModuleScope(m) => Some((&*m.def_map, m.module_id)),\n-\n-            _ => None,\n-        })\n+    fn module_scope(&self) -> (&DefMap, LocalModuleId) {\n+        self.scopes()\n+            .find_map(|scope| match scope {\n+                Scope::ModuleScope(m) => Some((&*m.def_map, m.module_id)),\n+                _ => None,\n+            })\n+            .expect(\"module scope invariant violated\")\n     }\n \n-    pub fn module(&self) -> Option<ModuleId> {\n-        let (def_map, local_id) = self.module_scope()?;\n-        Some(def_map.module_id(local_id))\n+    pub fn module(&self) -> ModuleId {\n+        let (def_map, local_id) = self.module_scope();\n+        def_map.module_id(local_id)\n     }\n \n-    pub fn krate(&self) -> Option<CrateId> {\n-        // FIXME: can this ever be `None`?\n-        self.module_scope().map(|t| t.0.krate())\n+    pub fn krate(&self) -> CrateId {\n+        self.module_scope().0.krate()\n     }\n \n     pub fn where_predicates_in_scope(\n@@ -749,8 +745,7 @@ impl HasResolver for ModuleId {\n             def_map = parent.def_map(db);\n             modules.push((def_map.clone(), parent.local_id));\n         }\n-        let mut resolver = Resolver::default();\n-        resolver.scopes.reserve(modules.len());\n+        let mut resolver = Resolver { scopes: Vec::with_capacity(modules.len()) };\n         for (def_map, module) in modules.into_iter().rev() {\n             resolver = resolver.push_module_scope(def_map, module);\n         }"}, {"sha": "6972db849565d1f968d218d43742ca603d353b40", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -420,9 +420,8 @@ pub(crate) fn associated_ty_data_query(\n         .collect();\n \n     if !ctx.unsized_types.borrow().contains(&self_ty) {\n-        let sized_trait = resolver\n-            .krate()\n-            .and_then(|krate| db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n+        let sized_trait = db\n+            .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n             .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n         let sized_bound = sized_trait.into_iter().map(|sized_trait| {\n             let trait_bound ="}, {"sha": "70bb56e02f241cb9ed0628916a5ce34e70d588af", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -762,7 +762,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_lang_item(&self, name: Name) -> Option<LangItemTarget> {\n-        let krate = self.resolver.krate()?;\n+        let krate = self.resolver.krate();\n         self.db.lang_item(krate, name.to_smol_str())\n     }\n "}, {"sha": "fc88e97d6abf659da9ea54f0ba9e09dd134ee2f4", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -29,7 +29,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution,\n+    method_resolution::{self, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -487,13 +487,8 @@ impl<'a> InferenceContext<'a> {\n                         }\n                         _ => return None,\n                     };\n-                    let module = self.resolver.module();\n-                    let is_visible = module\n-                        .map(|mod_id| {\n-                            self.db.field_visibilities(field_id.parent)[field_id.local_id]\n-                                .is_visible_from(self.db.upcast(), mod_id)\n-                        })\n-                        .unwrap_or(true);\n+                    let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n+                        .is_visible_from(self.db.upcast(), self.resolver.module());\n                     if !is_visible {\n                         // Write down the first field resolution even if it is not visible\n                         // This aids IDE features for private fields like goto def and in\n@@ -946,7 +941,7 @@ impl<'a> InferenceContext<'a> {\n             self.db,\n             self.trait_env.clone(),\n             &traits_in_scope,\n-            self.resolver.module().into(),\n+            VisibleFromModule::Filter(self.resolver.module()),\n             method_name,\n         );\n         let (receiver_ty, method_ty, substs) = match resolved {"}, {"sha": "f580e09e91229cdef416b9a250bcd940bdf6d41d", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -9,8 +9,11 @@ use hir_def::{\n use hir_expand::name::Name;\n \n use crate::{\n-    builder::ParamKind, consteval, method_resolution, GenericArgData, Interner, Substitution,\n-    TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n+    builder::ParamKind,\n+    consteval,\n+    method_resolution::{self, VisibleFromModule},\n+    GenericArgData, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -231,7 +234,7 @@ impl<'a> InferenceContext<'a> {\n             self.db,\n             self.table.trait_env.clone(),\n             &traits_in_scope,\n-            self.resolver.module().into(),\n+            VisibleFromModule::Filter(self.resolver.module()),\n             Some(name),\n             method_resolution::LookupMode::Path,\n             move |_ty, item| {"}, {"sha": "81134f666b52acdedd06cf308a6e23185833eba2", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -335,12 +335,13 @@ impl<'a> TyLoweringContext<'a> {\n                     let mut expander = self.expander.borrow_mut();\n                     if expander.is_some() {\n                         (Some(expander), false)\n-                    } else if let Some(module_id) = self.resolver.module() {\n-                        *expander =\n-                            Some(Expander::new(self.db.upcast(), macro_call.file_id, module_id));\n-                        (Some(expander), true)\n                     } else {\n-                        (None, false)\n+                        *expander = Some(Expander::new(\n+                            self.db.upcast(),\n+                            macro_call.file_id,\n+                            self.resolver.module(),\n+                        ));\n+                        (Some(expander), true)\n                     }\n                 };\n                 let ty = if let Some(mut expander) = expander {\n@@ -860,9 +861,8 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeBound::Path(path, TraitBoundModifier::Maybe) => {\n                 let sized_trait = self\n-                    .resolver\n-                    .krate()\n-                    .and_then(|krate| self.db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n+                    .db\n+                    .lang_item(self.resolver.krate(), SmolStr::new_inline(\"sized\"))\n                     .and_then(|lang_item| lang_item.as_trait());\n                 // Don't lower associated type bindings as the only possible relaxed trait bound\n                 // `?Sized` has no of them.\n@@ -1268,9 +1268,8 @@ fn implicitly_sized_clauses<'a>(\n ) -> impl Iterator<Item = WhereClause> + 'a {\n     let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n     let generic_args = &substitution.as_slice(Interner)[is_trait_def as usize..];\n-    let sized_trait = resolver\n-        .krate()\n-        .and_then(|krate| db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n+    let sized_trait = db\n+        .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n         .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n \n     sized_trait.into_iter().flat_map(move |sized_trait| {"}, {"sha": "a7d6bc24019900abdbf77be3b7d05fa5afe0c783", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -63,10 +63,7 @@ pub(crate) fn goto_implementation(\n                 Definition::Trait(trait_) => impls_for_trait(&sema, trait_),\n                 Definition::Adt(adt) => impls_for_ty(&sema, adt.ty(sema.db)),\n                 Definition::TypeAlias(alias) => impls_for_ty(&sema, alias.ty(sema.db)),\n-                Definition::BuiltinType(builtin) => {\n-                    let module = sema.to_module_def(position.file_id)?;\n-                    impls_for_ty(&sema, builtin.ty(sema.db, module))\n-                }\n+                Definition::BuiltinType(builtin) => impls_for_ty(&sema, builtin.ty(sema.db)),\n                 Definition::Function(f) => {\n                     let assoc = f.as_assoc_item(sema.db)?;\n                     let name = assoc.name(sema.db)?;"}, {"sha": "23b995dbb8cf53515c7c86af8667a5b2be41c405", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -170,7 +170,7 @@ pub(crate) fn hover_for_definition(\n     config: &HoverConfig,\n ) -> Option<HoverResult> {\n     let famous_defs = match &definition {\n-        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node).krate())),\n+        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n         _ => None,\n     };\n     if let Some(markup) = render::definition(sema.db, definition, famous_defs.as_ref(), config) {"}, {"sha": "067622027207e7133c40de9d20f8e9172ea64f78", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -103,7 +103,7 @@ pub(super) fn try_expr(\n \n     let adts = inner_ty.as_adt().zip(body_ty.as_adt());\n     if let Some((hir::Adt::Enum(inner), hir::Adt::Enum(body))) = adts {\n-        let famous_defs = FamousDefs(sema, sema.scope(try_expr.syntax()).krate());\n+        let famous_defs = FamousDefs(sema, sema.scope(try_expr.syntax())?.krate());\n         // special case for two options, there is no value in showing them\n         if let Some(option_enum) = famous_defs.core_option_Option() {\n             if inner == option_enum && body == option_enum {\n@@ -234,7 +234,7 @@ pub(super) fn keyword(\n         return None;\n     }\n     let parent = token.parent()?;\n-    let famous_defs = FamousDefs(sema, sema.scope(&parent).krate());\n+    let famous_defs = FamousDefs(sema, sema.scope(&parent)?.krate());\n \n     let KeywordHint { description, keyword_mod, actions } = keyword_hints(sema, token, parent);\n "}, {"sha": "ba2b397f2a8fccb7d2cfb262130575fe989b3569", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -110,7 +110,10 @@ fn hints(\n     config: &InlayHintsConfig,\n     node: SyntaxNode,\n ) {\n-    let krate = sema.scope(&node).module().map(|it| it.krate());\n+    let krate = match sema.scope(&node) {\n+        Some(it) => it.krate(),\n+        None => return,\n+    };\n     let famous_defs = FamousDefs(sema, krate);\n     if let Some(expr) = ast::Expr::cast(node.clone()) {\n         chaining_hints(hints, sema, &famous_defs, config, &expr);\n@@ -503,7 +506,7 @@ fn bind_pat_hints(\n         return None;\n     }\n \n-    let krate = sema.scope(desc_pat.syntax()).module().map(|it| it.krate());\n+    let krate = sema.scope(desc_pat.syntax())?.krate();\n     let famous_defs = FamousDefs(sema, krate);\n     let label = hint_iterator(sema, &famous_defs, config, &ty);\n "}, {"sha": "c9b53b1c48f77b31193a865912a43cf989faeed3", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -64,7 +64,7 @@ use cfg::CfgOptions;\n use ide_db::{\n     base_db::{\n         salsa::{self, ParallelDatabase},\n-        Env, FileLoader, FileSet, SourceDatabase, VfsPath,\n+        CrateOrigin, Env, FileLoader, FileSet, SourceDatabase, VfsPath,\n     },\n     symbol_index, LineIndexDatabase,\n };\n@@ -232,7 +232,7 @@ impl Analysis {\n             Env::default(),\n             Default::default(),\n             false,\n-            Default::default(),\n+            CrateOrigin::CratesIo { repo: None },\n         );\n         change.change_file(file_id, Some(Arc::new(text)));\n         change.set_crate_graph(crate_graph);\n@@ -635,7 +635,7 @@ impl Analysis {\n         self.with_db(|db| {\n             let rule: ide_ssr::SsrRule = query.parse()?;\n             let mut match_finder =\n-                ide_ssr::MatchFinder::in_context(db, resolve_context, selections);\n+                ide_ssr::MatchFinder::in_context(db, resolve_context, selections)?;\n             match_finder.add_rule(rule)?;\n             let edits = if parse_only { Default::default() } else { match_finder.edits() };\n             Ok(SourceChange::from(edits))"}, {"sha": "0f75abe55c1d5c67b6afb1c8fefa89cdc13d88df", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -3,7 +3,7 @@\n \n use hir::{db::DefDatabase, AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n use ide_db::{\n-    base_db::{CrateOrigin, FileId, FileLoader, FilePosition},\n+    base_db::{CrateOrigin, FileId, FileLoader, FilePosition, LangCrateOrigin},\n     defs::{Definition, IdentClass},\n     helpers::pick_best_token,\n     RootDatabase,\n@@ -151,11 +151,20 @@ pub(crate) fn def_to_moniker(\n             let name = krate.display_name(db)?.to_string();\n             let (repo, version) = match krate.origin(db) {\n                 CrateOrigin::CratesIo { repo } => (repo?, krate.version(db)?),\n-                CrateOrigin::Lang => (\n+                CrateOrigin::Lang(lang) => (\n                     \"https://github.com/rust-lang/rust/\".to_string(),\n-                    \"compiler_version\".to_string(),\n+                    format!(\n+                        \"https://github.com/rust-lang/rust/library/{}\",\n+                        match lang {\n+                            LangCrateOrigin::Alloc => \"alloc\",\n+                            LangCrateOrigin::Core => \"core\",\n+                            LangCrateOrigin::ProcMacro => \"proc_macro\",\n+                            LangCrateOrigin::Std => \"std\",\n+                            LangCrateOrigin::Test => \"test\",\n+                            LangCrateOrigin::Other => \"\",\n+                        }\n+                    ),\n                 ),\n-                CrateOrigin::Unknown => return None,\n             };\n             PackageInformation { name, repo, version }\n         },"}, {"sha": "908bbfde24d7259f3f3a2b50d7f29d8ae275dce7", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -179,12 +179,16 @@ pub(crate) fn highlight(\n     };\n \n     let mut hl = highlights::Highlights::new(root.text_range());\n+    let krate = match sema.scope(&root) {\n+        Some(it) => it.krate(),\n+        None => return hl.to_vec(),\n+    };\n     traverse(\n         &mut hl,\n         &sema,\n         file_id,\n         &root,\n-        sema.scope(&root).krate(),\n+        krate,\n         range_to_highlight,\n         syntactic_name_ref_highlighting,\n     );\n@@ -196,7 +200,7 @@ fn traverse(\n     sema: &Semantics<RootDatabase>,\n     file_id: FileId,\n     root: &SyntaxNode,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n     range_to_highlight: TextRange,\n     syntactic_name_ref_highlighting: bool,\n ) {"}, {"sha": "5fb87598f47f9cd7540af11c382b1c8ff164aa44", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -3,7 +3,6 @@\n use hir::{AsAssocItem, HasVisibility, Semantics};\n use ide_db::{\n     defs::{Definition, IdentClass, NameClass, NameRefClass},\n-    famous_defs::FamousDefs,\n     RootDatabase, SymbolKind,\n };\n use rustc_hash::FxHashMap;\n@@ -49,7 +48,7 @@ pub(super) fn token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Optio\n \n pub(super) fn name_like(\n     sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     syntactic_name_ref_highlighting: bool,\n     name_like: ast::NameLike,\n@@ -193,7 +192,7 @@ fn keyword(\n \n fn highlight_name_ref(\n     sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     binding_hash: &mut Option<u64>,\n     syntactic_name_ref_highlighting: bool,\n@@ -279,7 +278,7 @@ fn highlight_name(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n     binding_hash: &mut Option<u64>,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n     name: ast::Name,\n ) -> Highlight {\n     let name_kind = NameClass::classify(sema, &name);\n@@ -323,11 +322,7 @@ fn calc_binding_hash(name: &hir::Name, shadow_count: u32) -> u64 {\n     hash((name, shadow_count))\n }\n \n-fn highlight_def(\n-    sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n-    def: Definition,\n-) -> Highlight {\n+fn highlight_def(sema: &Semantics<RootDatabase>, krate: hir::Crate, def: Definition) -> Highlight {\n     let db = sema.db;\n     let mut h = match def {\n         Definition::Macro(m) => Highlight::new(HlTag::Symbol(m.kind(sema.db).into())),\n@@ -472,14 +467,12 @@ fn highlight_def(\n         Definition::ToolModule(_) => Highlight::new(HlTag::Symbol(SymbolKind::ToolModule)),\n     };\n \n-    let famous_defs = FamousDefs(sema, krate);\n     let def_crate = def.module(db).map(hir::Module::krate).or_else(|| match def {\n         Definition::Module(module) => Some(module.krate()),\n         _ => None,\n     });\n-    let is_from_other_crate = def_crate != krate;\n-    let is_from_builtin_crate =\n-        def_crate.map_or(false, |def_crate| famous_defs.builtin_crates().any(|it| def_crate == it));\n+    let is_from_other_crate = def_crate != Some(krate);\n+    let is_from_builtin_crate = def_crate.map_or(false, |def_crate| def_crate.is_builtin(db));\n     let is_builtin_type = matches!(def, Definition::BuiltinType(_));\n     let is_public = def.visibility(db) == Some(hir::Visibility::Public);\n \n@@ -498,7 +491,7 @@ fn highlight_def(\n \n fn highlight_method_call_by_name_ref(\n     sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n     name_ref: &ast::NameRef,\n ) -> Option<Highlight> {\n     let mc = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n@@ -507,7 +500,7 @@ fn highlight_method_call_by_name_ref(\n \n fn highlight_method_call(\n     sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n     method_call: &ast::MethodCallExpr,\n ) -> Option<Highlight> {\n     let func = sema.resolve_method_call(method_call)?;\n@@ -525,10 +518,9 @@ fn highlight_method_call(\n         h |= HlMod::Trait;\n     }\n \n-    let famous_defs = FamousDefs(sema, krate);\n     let def_crate = func.module(sema.db).krate();\n-    let is_from_other_crate = Some(def_crate) != krate;\n-    let is_from_builtin_crate = famous_defs.builtin_crates().any(|it| def_crate == it);\n+    let is_from_other_crate = def_crate != krate;\n+    let is_from_builtin_crate = def_crate.is_builtin(sema.db);\n     let is_public = func.visibility(sema.db) == hir::Visibility::Public;\n \n     if is_from_other_crate {\n@@ -593,7 +585,7 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n fn highlight_name_ref_by_syntax(\n     name: ast::NameRef,\n     sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n+    krate: hir::Crate,\n ) -> Highlight {\n     let default = HlTag::UnresolvedReference;\n "}, {"sha": "af41796e2169bbf8128ab4f978ff057a75db129d", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_extern_crate.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_extern_crate.html", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_extern_crate.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_extern_crate.html?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -43,5 +43,5 @@\n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n <pre><code><span class=\"keyword\">extern</span> <span class=\"keyword\">crate</span> <span class=\"module crate_root default_library library\">std</span><span class=\"semicolon\">;</span>\n-<span class=\"keyword\">extern</span> <span class=\"keyword\">crate</span> <span class=\"module crate_root default_library library\">alloc</span> <span class=\"keyword\">as</span> <span class=\"module crate_root default_library declaration library\">abc</span><span class=\"semicolon\">;</span>\n+<span class=\"keyword\">extern</span> <span class=\"keyword\">crate</span> <span class=\"module crate_root library\">alloc</span> <span class=\"keyword\">as</span> <span class=\"module crate_root declaration library\">abc</span><span class=\"semicolon\">;</span>\n </code></pre>\n\\ No newline at end of file"}, {"sha": "6b7db739c80701cae764baf08dde9305f9adc202", "filename": "crates/ide_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         return None;\n     };\n \n-    let module = ctx.sema.scope(pat.syntax()).module()?;\n+    let module = ctx.sema.scope(pat.syntax())?.module();\n     let pat_range = pat.syntax().text_range();\n \n     // Don't enable the assist if there is a type ascription without any placeholders"}, {"sha": "6e700695fb42be796139955d4ac7cf3ff00a7bd7", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -104,6 +104,7 @@ fn add_missing_impl_members_inner(\n ) -> Option<()> {\n     let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n+    let target_scope = ctx.sema.scope(impl_def.syntax())?;\n     let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n \n     let missing_items = filter_assoc_items(\n@@ -118,7 +119,6 @@ fn add_missing_impl_members_inner(\n \n     let target = impl_def.syntax().text_range();\n     acc.add(AssistId(assist_id, AssistKind::QuickFix), label, target, |builder| {\n-        let target_scope = ctx.sema.scope(impl_def.syntax());\n         let missing_items = missing_items\n             .into_iter()\n             .map(|it| {"}, {"sha": "171b3f443262c333d2e3596807af1a5664320f72", "filename": "crates/ide_assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n         .filter(|pat| !matches!(pat, Pat::WildcardPat(_)))\n         .collect();\n \n-    let module = ctx.sema.scope(expr.syntax()).module()?;\n+    let module = ctx.sema.scope(expr.syntax())?.module();\n     let (mut missing_pats, is_non_exhaustive): (\n         Peekable<Box<dyn Iterator<Item = (ast::Pat, bool)>>>,\n         bool,\n@@ -92,8 +92,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n             })\n             .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n \n-        let option_enum =\n-            FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum);\n+        let option_enum = FamousDefs(&ctx.sema, module.krate()).core_option_Option().map(lift_enum);\n         let missing_pats: Box<dyn Iterator<Item = _>> = if Some(enum_def) == option_enum {\n             // Match `Some` variant first.\n             cov_mark::hit!(option_order);"}, {"sha": "42a5b8b672fc606c7bf33a1aed81aa3a264b4685", "filename": "crates/ide_assists/src/handlers/add_return_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -17,7 +17,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let (fn_type, tail_expr, builder_edit_pos) = extract_tail(ctx)?;\n-    let module = ctx.sema.scope(tail_expr.syntax()).module()?;\n+    let module = ctx.sema.scope(tail_expr.syntax())?.module();\n     let ty = ctx.sema.type_of_expr(&peel_blocks(tail_expr.clone()))?.original();\n     if ty.is_unit() {\n         return None;"}, {"sha": "f07fde07c034988838bbc7d4ad35dbc76c2df7f1", "filename": "crates/ide_assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -222,7 +222,7 @@ fn option_variants(\n     sema: &Semantics<RootDatabase>,\n     expr: &SyntaxNode,\n ) -> Option<(hir::Variant, hir::Variant)> {\n-    let fam = FamousDefs(sema, sema.scope(expr).krate());\n+    let fam = FamousDefs(sema, sema.scope(expr)?.krate());\n     let option_variants = fam.core_option_Option()?.variants(sema.db);\n     match &*option_variants {\n         &[variant0, variant1] => Some(if variant0.name(sema.db) == known::None {"}, {"sha": "869f76951d2286194646e4320498827c5a0de5a1", "filename": "crates/ide_assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -36,10 +36,10 @@ pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext) -> Op\n     let src_type = impl_.self_ty()?;\n     let ast_trait = impl_.trait_()?;\n \n-    let module = ctx.sema.scope(impl_.syntax()).module()?;\n+    let module = ctx.sema.scope(impl_.syntax())?.module();\n \n     let trait_ = resolve_target_trait(&ctx.sema, &impl_)?;\n-    if trait_ != FamousDefs(&ctx.sema, Some(module.krate())).core_convert_Into()? {\n+    if trait_ != FamousDefs(&ctx.sema, module.krate()).core_convert_Into()? {\n         return None;\n     }\n "}, {"sha": "711b9145610368782801a4b1f6bc425adfb04300", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -146,10 +146,10 @@ fn is_ref_and_impls_iter_method(\n     let wanted_method = if ref_expr.mut_token().is_some() { known::iter_mut } else { known::iter };\n     let expr_behind_ref = ref_expr.expr()?;\n     let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n-    let scope = sema.scope(iterable.syntax());\n-    let krate = scope.module()?.krate();\n+    let scope = sema.scope(iterable.syntax())?;\n+    let krate = scope.krate();\n     let traits_in_scope = scope.visible_traits();\n-    let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n+    let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n \n     let has_wanted_method = ty\n         .iterate_method_candidates(\n@@ -175,24 +175,17 @@ fn is_ref_and_impls_iter_method(\n \n /// Whether iterable implements core::Iterator\n fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n-    let it_typ = match sema.type_of_expr(iterable) {\n-        Some(it) => it.adjusted(),\n-        None => return false,\n-    };\n+    (|| {\n+        let it_typ = sema.type_of_expr(iterable)?.adjusted();\n \n-    let module = match sema.scope(iterable.syntax()).module() {\n-        Some(it) => it,\n-        None => return false,\n-    };\n+        let module = sema.scope(iterable.syntax())?.module();\n \n-    let krate = module.krate();\n-    match FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n-        Some(iter_trait) => {\n-            cov_mark::hit!(test_already_impls_iterator);\n-            it_typ.impls_trait(sema.db, iter_trait, &[])\n-        }\n-        None => false,\n-    }\n+        let krate = module.krate();\n+        let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n+        cov_mark::hit!(test_already_impls_iterator);\n+        Some(it_typ.impls_trait(sema.db, iter_trait, &[]))\n+    })()\n+    .unwrap_or(false)\n }\n \n fn validate_method_call_expr(\n@@ -214,10 +207,10 @@ fn validate_method_call_expr(\n     let expr = ast::Expr::MethodCallExpr(expr);\n \n     let it_type = sema.type_of_expr(&receiver)?.adjusted();\n-    let module = sema.scope(receiver.syntax()).module()?;\n+    let module = sema.scope(receiver.syntax())?.module();\n     let krate = module.krate();\n \n-    let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n+    let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n     it_type.impls_trait(sema.db, iter_trait, &[]).then(|| (expr, receiver))\n }\n "}, {"sha": "3566b1be895ae3bc5b39f1dee68fa630ae05b573", "filename": "crates/ide_assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -49,8 +49,8 @@ pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Opti\n         _ => return None,\n     };\n \n-    let current_scope = ctx.sema.scope(&star.parent()?);\n-    let current_module = current_scope.module()?;\n+    let current_scope = ctx.sema.scope(&star.parent()?)?;\n+    let current_module = current_scope.module();\n \n     let refs_in_target = find_refs_in_mod(ctx, target_module, Some(current_module))?;\n     let imported_defs = find_imported_defs(ctx, star)?;"}, {"sha": "c26e4b1c751b715cadeb9334ed57ad21b23113ac", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -81,7 +81,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n     let insert_after = node_to_insert_after(&body, anchor)?;\n-    let module = ctx.sema.scope(&insert_after).module()?;\n+    let module = ctx.sema.scope(&insert_after)?.module();\n \n     let ret_ty = body.return_ty(ctx)?;\n     let control_flow = body.external_control_flow(ctx, &container_info)?;\n@@ -132,7 +132,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 };\n \n                 let control_flow_enum =\n-                    FamousDefs(&ctx.sema, Some(module.krate())).core_ops_ControlFlow();\n+                    FamousDefs(&ctx.sema, module.krate()).core_ops_ControlFlow();\n \n                 if let Some(control_flow_enum) = control_flow_enum {\n                     let mod_path = module.find_use_path_prefixed("}, {"sha": "45f98e690fff818d0945c2b21d88b22aac6f0b93", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -423,7 +423,7 @@ fn reference_to_node(\n             _ => return None,\n         }\n     };\n-    let module = sema.scope(&expr_or_pat).module()?;\n+    let module = sema.scope(&expr_or_pat)?.module();\n     Some((segment, expr_or_pat, module))\n }\n "}, {"sha": "b895208f4137b7b5e59b47dfb890e3fa7056aed2", "filename": "crates/ide_assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -43,7 +43,7 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> O\n         _ => return None,\n     };\n \n-    let current_module = ctx.sema.scope(path.syntax()).module()?;\n+    let current_module = ctx.sema.scope(path.syntax())?.module();\n     let target_module = def.module(ctx.db())?;\n \n     if def.visibility(ctx.db()).is_visible_from(ctx.db(), current_module.into()) {\n@@ -86,7 +86,7 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) ->\n     let record_field: ast::RecordExprField = ctx.find_node_at_offset()?;\n     let (record_field_def, _, _) = ctx.sema.resolve_record_field(&record_field)?;\n \n-    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n+    let current_module = ctx.sema.scope(record_field.syntax())?.module();\n     let visibility = record_field_def.visibility(ctx.db());\n     if visibility.is_visible_from(ctx.db(), current_module.into()) {\n         return None;"}, {"sha": "c4b759d5f3c5e4a7e2c2bdd99eb4e90139d96eea", "filename": "crates/ide_assists/src/handlers/generate_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -35,8 +35,8 @@ pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     let expr = constant_token.syntax().ancestors().find_map(ast::Expr::cast)?;\n     let statement = expr.syntax().ancestors().find_map(ast::Stmt::cast)?;\n     let ty = ctx.sema.type_of_expr(&expr)?;\n-    let scope = ctx.sema.scope(statement.syntax());\n-    let module = scope.module()?;\n+    let scope = ctx.sema.scope(statement.syntax())?;\n+    let module = scope.module();\n     let type_name = ty.original().display_source_code(ctx.db(), module.into()).ok()?;\n     let indent = IndentLevel::from_node(statement.syntax());\n     if constant_token.to_string().chars().any(|it| !(it.is_uppercase() || it == '_')) {"}, {"sha": "4d47437f7c1f180d733665db554fcdb82b5a32ff", "filename": "crates/ide_assists/src/handlers/generate_default_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -75,7 +75,7 @@ fn existing_default_impl(\n     let enum_ = variant.parent_enum(sema.db);\n     let krate = enum_.module(sema.db).krate();\n \n-    let default_trait = FamousDefs(sema, Some(krate)).core_default_Default()?;\n+    let default_trait = FamousDefs(sema, krate).core_default_Default()?;\n     let enum_type = enum_.ty(sema.db);\n \n     if enum_type.impls_trait(sema.db, default_trait, &[]) {"}, {"sha": "119bb6e07b48b73404e56af5df62ed427be4f74b", "filename": "crates/ide_assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -132,7 +132,7 @@ fn is_default_implemented(ctx: &AssistContext, impl_: &Impl) -> bool {\n \n     let ty = impl_def.self_ty(db);\n     let krate = impl_def.module(db).krate();\n-    let default = FamousDefs(&ctx.sema, Some(krate)).core_default_Default();\n+    let default = FamousDefs(&ctx.sema, krate).core_default_Default();\n     let default_trait = match default {\n         Some(value) => value,\n         None => return false,"}, {"sha": "120acde8e5b4d0ef33a7217e32c86e0870b6440d", "filename": "crates/ide_assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -45,7 +45,7 @@ use syntax::ast::edit::AstNodeEdit;\n pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let strukt_name = strukt.name()?;\n-    let current_module = ctx.sema.scope(strukt.syntax()).module()?;\n+    let current_module = ctx.sema.scope(strukt.syntax())?.module();\n \n     let (field_name, field_ty, target) = match ctx.find_node_at_offset::<ast::RecordField>() {\n         Some(field) => {"}, {"sha": "3cb8a68687e974d7f98aca93af9885d6b74e72b0", "filename": "crates/ide_assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -110,7 +110,7 @@ fn existing_deref_impl(\n     let strukt = sema.to_def(strukt)?;\n     let krate = strukt.module(sema.db).krate();\n \n-    let deref_trait = FamousDefs(sema, Some(krate)).core_ops_Deref()?;\n+    let deref_trait = FamousDefs(sema, krate).core_ops_Deref()?;\n     let strukt_type = strukt.ty(sema.db);\n \n     if strukt_type.impls_trait(sema.db, deref_trait, &[]) {"}, {"sha": "3eaa445d322d53cc236f98201980a1394f2897ba", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -202,7 +202,7 @@ fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext) -> bool\n \n /// Returns the name of the current crate\n fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n-    let krate = ctx.sema.scope(ast_func.syntax()).module()?.krate();\n+    let krate = ctx.sema.scope(ast_func.syntax())?.krate();\n     Some(krate.display_name(ctx.db())?.to_string())\n }\n "}, {"sha": "5bb7edb0a7e47b70a20b8fccc9b9a1029e363bbe", "filename": "crates/ide_assists/src/handlers/generate_from_impl_for_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -86,7 +86,7 @@ fn existing_from_impl(\n     let enum_ = variant.parent_enum(sema.db);\n     let krate = enum_.module(sema.db).krate();\n \n-    let from_trait = FamousDefs(sema, Some(krate)).core_convert_From()?;\n+    let from_trait = FamousDefs(sema, krate).core_convert_From()?;\n \n     let enum_type = enum_.ty(sema.db);\n "}, {"sha": "ae4436ce88d0ff6bd4114d785b595d4c3a296cc8", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -73,7 +73,7 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n                 get_fn_target(ctx, &target_module, call.clone())?\n             }\n             Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n-                let current_module = current_module(call.syntax(), ctx)?;\n+                let current_module = ctx.sema.scope(call.syntax())?.module();\n                 let module = adt.module(ctx.sema.db);\n                 target_module = if current_module == module { None } else { Some(module) };\n                 if current_module.krate() != module.krate() {\n@@ -117,7 +117,7 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let fn_name = call.name_ref()?;\n     let adt = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references().as_adt()?;\n \n-    let current_module = current_module(call.syntax(), ctx)?;\n+    let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module = adt.module(ctx.sema.db);\n \n     if current_module.krate() != target_module.krate() {\n@@ -166,10 +166,6 @@ fn add_func_to_accumulator(\n     })\n }\n \n-fn current_module(current_node: &SyntaxNode, ctx: &AssistContext) -> Option<Module> {\n-    ctx.sema.scope(current_node).module()\n-}\n-\n fn get_adt_source(\n     ctx: &AssistContext,\n     adt: &hir::Adt,\n@@ -235,7 +231,8 @@ impl FunctionBuilder {\n         target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n         let needs_pub = target_module.is_some();\n-        let target_module = target_module.or_else(|| current_module(target.syntax(), ctx))?;\n+        let target_module =\n+            target_module.or_else(|| ctx.sema.scope(target.syntax()).map(|it| it.module()))?;\n         let fn_name = make::name(fn_name);\n         let (type_params, params) =\n             fn_args(ctx, target_module, ast::CallableExpr::Call(call.clone()))?;\n@@ -266,7 +263,7 @@ impl FunctionBuilder {\n         target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n         let needs_pub =\n-            !module_is_descendant(&current_module(call.syntax(), ctx)?, &target_module, ctx);\n+            !module_is_descendant(&ctx.sema.scope(call.syntax())?.module(), &target_module, ctx);\n         let fn_name = make::name(&name.text());\n         let (type_params, params) =\n             fn_args(ctx, target_module, ast::CallableExpr::MethodCall(call.clone()))?;\n@@ -520,7 +517,7 @@ fn fn_arg_type(ctx: &AssistContext, target_module: hir::Module, fn_arg: &ast::Ex\n         }\n \n         if ty.is_reference() || ty.is_mutable_reference() {\n-            let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(fn_arg.syntax()).krate());\n+            let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(fn_arg.syntax())?.krate());\n             convert_reference_type(ty.strip_references(), ctx.db(), famous_defs)\n                 .map(|conversion| conversion.convert_type(ctx.db()))\n                 .or_else(|| ty.display_source_code(ctx.db(), target_module.into()).ok())"}, {"sha": "9513c112f32e9aa5bf210b68d768cc07b12cf216", "filename": "crates/ide_assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -121,25 +121,24 @@ pub(crate) fn generate_getter_impl(\n                     \"a mutable reference to \",\n                 )\n             } else {\n-                let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(field_ty.syntax()).krate());\n-                ctx.sema\n-                    .resolve_type(&field_ty)\n-                    .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n-                    .map(|conversion| {\n-                        cov_mark::hit!(convert_reference_type);\n-                        (\n-                            conversion.convert_type(ctx.db()),\n-                            conversion.getter(field_name.to_string()),\n-                            if conversion.is_copy() { \"\" } else { \"a reference to \" },\n-                        )\n-                    })\n-                    .unwrap_or_else(|| {\n-                        (\n-                            format!(\"&{}\", field_ty),\n-                            format!(\"&self.{}\", field_name),\n-                            \"a reference to \",\n-                        )\n-                    })\n+                (|| {\n+                    let krate = ctx.sema.scope(field_ty.syntax())?.krate();\n+                    let famous_defs = &FamousDefs(&ctx.sema, krate);\n+                    ctx.sema\n+                        .resolve_type(&field_ty)\n+                        .and_then(|ty| convert_reference_type(ty, ctx.db(), famous_defs))\n+                        .map(|conversion| {\n+                            cov_mark::hit!(convert_reference_type);\n+                            (\n+                                conversion.convert_type(ctx.db()),\n+                                conversion.getter(field_name.to_string()),\n+                                if conversion.is_copy() { \"\" } else { \"a reference to \" },\n+                            )\n+                        })\n+                })()\n+                .unwrap_or_else(|| {\n+                    (format!(\"&{}\", field_ty), format!(\"&self.{}\", field_name), \"a reference to \")\n+                })\n             };\n \n             format_to!("}, {"sha": "1ad1cea43fce964b052e4167afcffa7b44cdc2e5", "filename": "crates/ide_assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -93,7 +93,7 @@ fn get_impl_method(\n     let db = ctx.sema.db;\n     let impl_def: hir::Impl = ctx.sema.to_def(impl_)?;\n \n-    let scope = ctx.sema.scope(impl_.syntax());\n+    let scope = ctx.sema.scope(impl_.syntax())?;\n     let ty = impl_def.self_ty(db);\n     let traits_in_scope = scope.visible_traits();\n     ty.iterate_method_candidates(db, &scope, &traits_in_scope, None, Some(fn_name), |func| {"}, {"sha": "5a28cbcc233d96935a4f0dcdaba7a0602baa51fd", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -391,13 +391,11 @@ fn inline(\n         }\n     }\n     if let Some(generic_arg_list) = generic_arg_list.clone() {\n-        PathTransform::function_call(\n-            &sema.scope(node.syntax()),\n-            &sema.scope(fn_body.syntax()),\n-            function,\n-            generic_arg_list,\n-        )\n-        .apply(body.syntax());\n+        if let Some((target, source)) = &sema.scope(node.syntax()).zip(sema.scope(fn_body.syntax()))\n+        {\n+            PathTransform::function_call(target, source, function, generic_arg_list)\n+                .apply(body.syntax());\n+        }\n     }\n \n     let original_indentation = match node {"}, {"sha": "65c14406f98f95f02d119c9f7447bfbf6428e09e", "filename": "crates/ide_assists/src/handlers/promote_local_to_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn promote_local_to_const(acc: &mut Assists, ctx: &AssistContext) ->\n     }\n     let let_stmt = pat.syntax().parent().and_then(ast::LetStmt::cast)?;\n \n-    let module = ctx.sema.scope(pat.syntax()).module()?;\n+    let module = ctx.sema.scope(pat.syntax())?.module();\n     let local = ctx.sema.to_def(&pat)?;\n     let ty = ctx.sema.type_of_pat(&pat.into())?.original;\n "}, {"sha": "ba0a14271818dcf750a22fe78b5da779fd51d2fc", "filename": "crates/ide_assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -44,7 +44,7 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext) -> Opt\n     let range = call.syntax().text_range();\n     let resolved_call = ctx.sema.resolve_method_call(&call)?;\n \n-    let current_module = ctx.sema.scope(call.syntax()).module()?;\n+    let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module_def = ModuleDef::from(resolved_call);\n     let item_in_ns = ItemInNs::from(target_module_def);\n     let receiver_path = current_module"}, {"sha": "03e41b43407af048a13b3430b7a35419b8caf7bd", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n     let attr = ast::Attr::cast(value)?;\n     let args = attr.token_tree()?;\n \n-    let current_module = ctx.sema.scope(adt.syntax()).module()?;\n+    let current_module = ctx.sema.scope(adt.syntax())?.module();\n     let current_crate = current_module.krate();\n \n     let found_traits = items_locator::items_with_name(\n@@ -177,7 +177,7 @@ fn impl_def_from_trait(\n     trait_path: &ast::Path,\n ) -> Option<(ast::Impl, ast::AssocItem)> {\n     let trait_ = trait_?;\n-    let target_scope = sema.scope(annotated_name.syntax());\n+    let target_scope = sema.scope(annotated_name.syntax())?;\n     let trait_items = filter_assoc_items(sema, &trait_.items(sema.db), DefaultMethods::No);\n     if trait_items.is_empty() {\n         return None;"}, {"sha": "4800d549567b2ed0955dea8b18cca7ee952e83ea", "filename": "crates/ide_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -63,9 +63,11 @@ pub(crate) fn replace_qualified_name_with_use(\n     );\n     let path_to_qualifier = starts_with_name_ref\n         .then(|| {\n-            ctx.sema.scope(path.syntax()).module().and_then(|m| {\n-                m.find_use_path_prefixed(ctx.sema.db, module, ctx.config.insert_use.prefix_kind)\n-            })\n+            ctx.sema.scope(path.syntax())?.module().find_use_path_prefixed(\n+                ctx.sema.db,\n+                module,\n+                ctx.config.insert_use.prefix_kind,\n+            )\n         })\n         .flatten();\n "}, {"sha": "ff79c5b82a10b2474aa350747c9f97b8eb3ba87b", "filename": "crates/ide_assists/src/handlers/unwrap_result_return_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -38,9 +38,9 @@ pub(crate) fn unwrap_result_return_type(acc: &mut Assists, ctx: &AssistContext)\n     };\n \n     let type_ref = &ret_type.ty()?;\n-    let ty = ctx.sema.resolve_type(type_ref).and_then(|ty| ty.as_adt());\n+    let ty = ctx.sema.resolve_type(type_ref)?.as_adt();\n     let result_enum =\n-        FamousDefs(&ctx.sema, ctx.sema.scope(type_ref.syntax()).krate()).core_result_Result()?;\n+        FamousDefs(&ctx.sema, ctx.sema.scope(type_ref.syntax())?.krate()).core_result_Result()?;\n \n     if !matches!(ty, Some(hir::Adt::Enum(ret_type)) if ret_type == result_enum) {\n         return None;"}, {"sha": "251b41c84a422f61a0d5ca361ae2017c68921280", "filename": "crates/ide_assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -39,9 +39,9 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n     };\n \n     let type_ref = &ret_type.ty()?;\n-    let ty = ctx.sema.resolve_type(type_ref).and_then(|ty| ty.as_adt());\n+    let ty = ctx.sema.resolve_type(type_ref)?.as_adt();\n     let result_enum =\n-        FamousDefs(&ctx.sema, ctx.sema.scope(type_ref.syntax()).krate()).core_result_Result()?;\n+        FamousDefs(&ctx.sema, ctx.sema.scope(type_ref.syntax())?.krate()).core_result_Result()?;\n \n     if matches!(ty, Some(hir::Adt::Enum(ret_type)) if ret_type == result_enum) {\n         cov_mark::hit!(wrap_return_type_in_result_simple_return_type_already_result);"}, {"sha": "0add9507185c636619494de91ec6c0590ae5070d", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -600,8 +600,7 @@ fn handle_as_ref_str(\n     db: &dyn HirDatabase,\n     famous_defs: &FamousDefs,\n ) -> Option<ReferenceConversionType> {\n-    let module = famous_defs.1?.root_module(db);\n-    let str_type = hir::BuiltinType::str().ty(db, module);\n+    let str_type = hir::BuiltinType::str().ty(db);\n \n     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[str_type])\n         .then(|| ReferenceConversionType::AsRefStr)"}, {"sha": "ab442fa64b1f4f74ae03b874bbf9cf129b11470f", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -352,14 +352,6 @@ fn enum_variants_with_paths(\n ) {\n     let variants = enum_.variants(ctx.db);\n \n-    let module = if let Some(module) = ctx.module {\n-        // Compute path from the completion site if available.\n-        module\n-    } else {\n-        // Otherwise fall back to the enum's definition site.\n-        enum_.module(ctx.db)\n-    };\n-\n     if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n         if impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_)) {\n             for &variant in &variants {\n@@ -373,7 +365,7 @@ fn enum_variants_with_paths(\n     }\n \n     for variant in variants {\n-        if let Some(path) = module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n+        if let Some(path) = ctx.module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n             // Variants with trivial paths are already added by the existing completion logic,\n             // so we should avoid adding these twice\n             if path.segments().len() > 1 {"}, {"sha": "c79a9816f489df20dbfe1567e531b91e6b01c8ae", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -91,7 +91,7 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n                 _ => return,\n             };\n \n-            for (name, def) in module.scope(ctx.db, ctx.module) {\n+            for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                 if let Some(def) = module_or_attr(ctx.db, def) {\n                     acc.add_resolution(ctx, name, def);\n                 }"}, {"sha": "b7e69d7b43cd2892175faaf152d53dae3cf334f5", "filename": "crates/ide_completion/src/completions/attribute/cfg.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -27,26 +27,17 @@ pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(\"target_os\") => KNOWN_OS.iter().copied().for_each(add_completion),\n         Some(\"target_vendor\") => KNOWN_VENDOR.iter().copied().for_each(add_completion),\n         Some(\"target_endian\") => [\"little\", \"big\"].into_iter().for_each(add_completion),\n-        Some(name) => {\n-            if let Some(krate) = ctx.krate {\n-                krate.potential_cfg(ctx.db).get_cfg_values(name).cloned().for_each(|s| {\n-                    let insert_text = format!(r#\"\"{}\"\"#, s);\n-                    let mut item =\n-                        CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n-                    item.insert_text(insert_text);\n+        Some(name) => ctx.krate.potential_cfg(ctx.db).get_cfg_values(name).cloned().for_each(|s| {\n+            let insert_text = format!(r#\"\"{}\"\"#, s);\n+            let mut item = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n+            item.insert_text(insert_text);\n \n-                    acc.add(item.build());\n-                })\n-            };\n-        }\n-        None => {\n-            if let Some(krate) = ctx.krate {\n-                krate.potential_cfg(ctx.db).get_cfg_keys().cloned().for_each(|s| {\n-                    let item = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n-                    acc.add(item.build());\n-                })\n-            }\n-        }\n+            acc.add(item.build());\n+        }),\n+        None => ctx.krate.potential_cfg(ctx.db).get_cfg_keys().cloned().for_each(|s| {\n+            let item = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n+            acc.add(item.build());\n+        }),\n     };\n }\n "}, {"sha": "4611811539d4c1e2368aedbccb86ba521796d273", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n                 _ => return,\n             };\n \n-            for (name, def) in module.scope(ctx.db, ctx.module) {\n+            for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                 let add_def = match def {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n                         !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db)"}, {"sha": "c237a65bfe4903244815f265ae783d2868912513", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -87,7 +87,7 @@ fn complete_methods(\n         ctx.db,\n         &ctx.scope,\n         &traits_in_scope,\n-        ctx.module,\n+        Some(ctx.module),\n         None,\n         |func| {\n             if func.self_param(ctx.db).is_some() && seen_methods.insert(func.name(ctx.db)) {"}, {"sha": "7d5709ec90297bd3d5a29e087683cbfc9122fcef", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -225,7 +225,7 @@ pub(crate) fn position_for_import(\n }\n \n fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAssets> {\n-    let current_module = ctx.module?;\n+    let current_module = ctx.module;\n     if let Some(dot_receiver) = ctx.dot_receiver() {\n         ImportAssets::for_fuzzy_method_call(\n             current_module,"}, {"sha": "7e9c1f49deaa5b3d3ef51f01ebbffc01df78f6e7", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -120,18 +120,18 @@ fn params_from_stmt_list_scope(\n         Some(it) => it,\n         None => return,\n     };\n-    let scope = ctx.sema.scope_at_offset(stmt_list.syntax(), syntax_node.text_range().end());\n-    let module = match scope.module() {\n-        Some(it) => it,\n-        None => return,\n-    };\n-    scope.process_all_names(&mut |name, def| {\n-        if let hir::ScopeDef::Local(local) = def {\n-            if let Ok(ty) = local.ty(ctx.db).display_source_code(ctx.db, module.into()) {\n-                cb(name, ty);\n+    if let Some(scope) =\n+        ctx.sema.scope_at_offset(stmt_list.syntax(), syntax_node.text_range().end())\n+    {\n+        let module = scope.module().into();\n+        scope.process_all_names(&mut |name, def| {\n+            if let hir::ScopeDef::Local(local) = def {\n+                if let Ok(ty) = local.ty(ctx.db).display_source_code(ctx.db, module) {\n+                    cb(name, ty);\n+                }\n             }\n-        }\n-    });\n+        });\n+    }\n }\n \n fn remove_duplicated("}, {"sha": "fb42e4e72f777667fb05d425a81e6ee7a55f46f3", "filename": "crates/ide_completion/src/completions/mod_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n \n     let _p = profile::span(\"completion::complete_mod\");\n \n-    let current_module = ctx.module?;\n+    let current_module = ctx.module;\n \n     let module_definition_file =\n         current_module.definition_source(ctx.db).file_id.original_file(ctx.db);"}, {"sha": "00f9bdfb51ad79895885c880cd33661c9ed58cd7", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -122,7 +122,7 @@ fn pattern_path_completion(\n \n             match resolution {\n                 hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n-                    let module_scope = module.scope(ctx.db, ctx.module);\n+                    let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     for (name, def) in module_scope {\n                         let add_resolution = match def {\n                             ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n@@ -159,13 +159,7 @@ fn pattern_path_completion(\n                         hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Union(u))) => {\n                             u.ty(ctx.db)\n                         }\n-                        hir::PathResolution::Def(hir::ModuleDef::BuiltinType(ty)) => {\n-                            let module = match ctx.module {\n-                                Some(m) => m,\n-                                None => return,\n-                            };\n-                            ty.ty(ctx.db, module)\n-                        }\n+                        hir::PathResolution::Def(hir::ModuleDef::BuiltinType(ty)) => ty.ty(ctx.db),\n                         _ => return,\n                     };\n \n@@ -175,7 +169,7 @@ fn pattern_path_completion(\n                         ctx.db,\n                         &ctx.scope,\n                         &traits_in_scope,\n-                        ctx.module,\n+                        Some(ctx.module),\n                         None,\n                         |item| {\n                             match item {"}, {"sha": "534d27d983043e34a97a2187b40cb2fc0c8d532d", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -1,7 +1,6 @@\n //! Completion of paths, i.e. `some::prefix::$0`.\n \n use hir::{ScopeDef, Trait};\n-use ide_db::famous_defs::FamousDefs;\n use rustc_hash::FxHashSet;\n use syntax::ast;\n \n@@ -26,7 +25,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     };\n     let traits_in_scope = |ctx: &CompletionContext| {\n         let mut traits_in_scope = ctx.scope.visible_traits();\n-        if let Some(drop) = FamousDefs(&ctx.sema, ctx.krate).core_ops_Drop() {\n+        if let Some(drop) = ctx.famous_defs().core_ops_Drop() {\n             traits_in_scope.remove(&drop.into());\n         }\n         traits_in_scope\n@@ -58,7 +57,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     match ctx.completion_location {\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {\n             if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n-                for (name, def) in module.scope(ctx.db, ctx.module) {\n+                for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                     if let Some(def) = module_or_fn_macro(ctx.db, def) {\n                         acc.add_resolution(ctx, name, def);\n                     }\n@@ -90,7 +89,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n     match resolution {\n         hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n-            let module_scope = module.scope(ctx.db, ctx.module);\n+            let module_scope = module.scope(ctx.db, Some(ctx.module));\n             for (name, def) in module_scope {\n                 let add_resolution = match def {\n                     // Don't suggest attribute macros and derives.\n@@ -133,42 +132,35 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     ty\n                 }\n                 hir::ModuleDef::BuiltinType(builtin) => {\n-                    let module = match ctx.module {\n-                        Some(it) => it,\n-                        None => return,\n-                    };\n                     cov_mark::hit!(completes_primitive_assoc_const);\n-                    builtin.ty(ctx.db, module)\n+                    builtin.ty(ctx.db)\n                 }\n                 _ => unreachable!(),\n             };\n \n             // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n             // (where AssocType is defined on a trait, not an inherent impl)\n \n-            let krate = ctx.krate;\n-            if let Some(krate) = krate {\n-                let traits_in_scope = traits_in_scope(ctx);\n-                ty.iterate_path_candidates(\n-                    ctx.db,\n-                    &ctx.scope,\n-                    &traits_in_scope,\n-                    ctx.module,\n-                    None,\n-                    |item| {\n-                        add_assoc_item(acc, ctx, item);\n-                        None::<()>\n-                    },\n-                );\n-\n-                // Iterate assoc types separately\n-                ty.iterate_assoc_items(ctx.db, krate, |item| {\n-                    if let hir::AssocItem::TypeAlias(ty) = item {\n-                        acc.add_type_alias(ctx, ty)\n-                    }\n+            let traits_in_scope = traits_in_scope(ctx);\n+            ty.iterate_path_candidates(\n+                ctx.db,\n+                &ctx.scope,\n+                &traits_in_scope,\n+                Some(ctx.module),\n+                None,\n+                |item| {\n+                    add_assoc_item(acc, ctx, item);\n                     None::<()>\n-                });\n-            }\n+                },\n+            );\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n         }\n         hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n             // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n@@ -192,7 +184,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 ctx.db,\n                 &ctx.scope,\n                 &traits_in_scope,\n-                ctx.module,\n+                Some(ctx.module),\n                 None,\n                 |item| {\n                     // We might iterate candidates of a trait multiple times here, so deduplicate"}, {"sha": "b65cf60a015c9925f8766510fcd3f53207eab30d", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -83,17 +83,18 @@ pub(crate) fn complete_record_literal(\n \n     match ctx.expected_type.as_ref()?.as_adt()? {\n         hir::Adt::Struct(strukt) if ctx.path_qual().is_none() => {\n-            let module = if let Some(module) = ctx.module { module } else { strukt.module(ctx.db) };\n-            let path = module\n+            let path = ctx\n+                .module\n                 .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n                 .filter(|it| it.len() > 1);\n \n             acc.add_struct_literal(ctx, strukt, path, None);\n         }\n         hir::Adt::Union(un) if ctx.path_qual().is_none() => {\n-            let module = if let Some(module) = ctx.module { module } else { un.module(ctx.db) };\n-            let path =\n-                module.find_use_path(ctx.db, hir::ModuleDef::from(un)).filter(|it| it.len() > 1);\n+            let path = ctx\n+                .module\n+                .find_use_path(ctx.db, hir::ModuleDef::from(un))\n+                .filter(|it| it.len() > 1);\n \n             acc.add_union_literal(ctx, un, path, None);\n         }"}, {"sha": "9c557aa524432fd670a28af33f53efd5589a6e3e", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -183,7 +183,7 @@ fn get_transformed_assoc_item(\n     let assoc_item = assoc_item.clone_for_update();\n     let trait_ = impl_def.trait_(ctx.db)?;\n     let source_scope = &ctx.sema.scope_for_def(trait_);\n-    let target_scope = &ctx.sema.scope(ctx.sema.source(impl_def)?.syntax().value);\n+    let target_scope = &ctx.sema.scope(ctx.sema.source(impl_def)?.syntax().value)?;\n     let transform = PathTransform::trait_impl(\n         target_scope,\n         source_scope,"}, {"sha": "d7c279f9d95da81766dd1b974424b7f102b107e8", "filename": "crates/ide_completion/src/completions/use_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext)\n \n             match resolution {\n                 hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n-                    let module_scope = module.scope(ctx.db, ctx.module);\n+                    let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     let unknown_is_current = |name: &hir::Name| {\n                         matches!(\n                             ctx.name_syntax.as_ref(),"}, {"sha": "ca6f6dff1eb841665a007c0c2e1ace3c49147b1e", "filename": "crates/ide_completion/src/completions/vis.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -22,17 +22,16 @@ pub(crate) fn complete_vis(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n             // Try completing next child module of the path that is still a parent of the current module\n             if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n-                if let Some(current_module) = ctx.module {\n-                    let next_towards_current = current_module\n-                        .path_to_root(ctx.db)\n-                        .into_iter()\n-                        .take_while(|it| it != module)\n-                        .last();\n-                    if let Some(next) = next_towards_current {\n-                        if let Some(name) = next.name(ctx.db) {\n-                            cov_mark::hit!(visibility_qualified);\n-                            acc.add_resolution(ctx, name, ScopeDef::ModuleDef(next.into()));\n-                        }\n+                let next_towards_current = ctx\n+                    .module\n+                    .path_to_root(ctx.db)\n+                    .into_iter()\n+                    .take_while(|it| it != module)\n+                    .last();\n+                if let Some(next) = next_towards_current {\n+                    if let Some(name) = next.name(ctx.db) {\n+                        cov_mark::hit!(visibility_qualified);\n+                        acc.add_resolution(ctx, name, ScopeDef::ModuleDef(next.into()));\n                     }\n                 }\n             }"}, {"sha": "12747b3ce4a3b3f94da0b95b696eb9a105a2a55b", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -121,9 +121,9 @@ pub(crate) struct CompletionContext<'a> {\n     /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n     /// The crate of the current file.\n-    pub(super) krate: Option<hir::Crate>,\n+    pub(super) krate: hir::Crate,\n     /// The module of the `scope`.\n-    pub(super) module: Option<hir::Module>,\n+    pub(super) module: hir::Module,\n     pub(super) expected_name: Option<NameOrNameRef>,\n     pub(super) expected_type: Option<Type>,\n \n@@ -353,11 +353,7 @@ impl<'a> CompletionContext<'a> {\n         attrs: &hir::Attrs,\n         defining_crate: hir::Crate,\n     ) -> Visible {\n-        let module = match self.module {\n-            Some(it) => it,\n-            None => return Visible::No,\n-        };\n-        if !vis.is_visible_from(self.db, module.into()) {\n+        if !vis.is_visible_from(self.db, self.module.into()) {\n             if !self.config.enable_private_editable {\n                 return Visible::No;\n             }\n@@ -376,11 +372,8 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn is_doc_hidden(&self, attrs: &hir::Attrs, defining_crate: hir::Crate) -> bool {\n-        match self.krate {\n-            // `doc(hidden)` items are only completed within the defining crate.\n-            Some(krate) => krate != defining_crate && attrs.has_doc_hidden(),\n-            None => true,\n-        }\n+        // `doc(hidden)` items are only completed within the defining crate.\n+        self.krate != defining_crate && attrs.has_doc_hidden()\n     }\n }\n \n@@ -409,7 +402,7 @@ impl<'a> CompletionContext<'a> {\n \n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());\n-        let scope = sema.scope_at_offset(&token.parent()?, offset);\n+        let scope = sema.scope_at_offset(&token.parent()?, offset)?;\n         let krate = scope.krate();\n         let module = scope.module();\n         let mut locals = FxHashMap::default();"}, {"sha": "56c41a88e4567b38c572d247817063d551634bc4", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -185,7 +185,7 @@ pub fn resolve_completion_edits(\n     let position_for_import = &position_for_import(&ctx, None)?;\n     let scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n \n-    let current_module = ctx.sema.scope(position_for_import).module()?;\n+    let current_module = ctx.sema.scope(position_for_import)?.module();\n     let current_crate = current_module.krate();\n     let new_ast = scope.clone_for_update();\n     let mut import_insert = TextEdit::builder();"}, {"sha": "39a37dc9f8ec2bfc559a3a3e868ba34f597607f4", "filename": "crates/ide_completion/src/render/variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fvariant.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -72,7 +72,7 @@ pub(crate) fn visible_fields(\n     fields: &[hir::Field],\n     item: impl HasAttrs,\n ) -> Option<(Vec<hir::Field>, bool)> {\n-    let module = ctx.module?;\n+    let module = ctx.module;\n     let n_fields = fields.len();\n     let fields = fields\n         .iter()"}, {"sha": "1340080fdf4a334c286d8fcfbcf9c6f276aba1aa", "filename": "crates/ide_completion/src/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fsnippet.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -185,7 +185,7 @@ fn import_edits(\n             _ => return None,\n         };\n         let path =\n-            ctx.module?.find_use_path_prefixed(ctx.db, item, ctx.config.insert_use.prefix_kind)?;\n+            ctx.module.find_use_path_prefixed(ctx.db, item, ctx.config.insert_use.prefix_kind)?;\n         Some((path.len() > 1).then(|| ImportEdit {\n             import: LocatedImport::new(path.clone(), item, item, None),\n             scope: import_scope.clone(),"}, {"sha": "58d99ff9dfdd3ab92fc37e595587f910fe6519eb", "filename": "crates/ide_db/src/famous_defs.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Ffamous_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Ffamous_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ffamous_defs.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -1,4 +1,6 @@\n //! See [`FamousDefs`].\n+\n+use base_db::{CrateOrigin, LangCrateOrigin, SourceDatabase};\n use hir::{Crate, Enum, Macro, Module, ScopeDef, Semantics, Trait};\n \n use crate::RootDatabase;\n@@ -16,16 +18,28 @@ use crate::RootDatabase;\n /// ```\n /// //- minicore: iterator, ord, derive\n /// ```\n-pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Option<Crate>);\n+pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Crate);\n \n #[allow(non_snake_case)]\n impl FamousDefs<'_, '_> {\n     pub fn std(&self) -> Option<Crate> {\n-        self.find_crate(\"std\")\n+        self.find_lang_crate(LangCrateOrigin::Std)\n     }\n \n     pub fn core(&self) -> Option<Crate> {\n-        self.find_crate(\"core\")\n+        self.find_lang_crate(LangCrateOrigin::Core)\n+    }\n+\n+    pub fn alloc(&self) -> Option<Crate> {\n+        self.find_lang_crate(LangCrateOrigin::Alloc)\n+    }\n+\n+    pub fn test(&self) -> Option<Crate> {\n+        self.find_lang_crate(LangCrateOrigin::Test)\n+    }\n+\n+    pub fn proc_macro(&self) -> Option<Crate> {\n+        self.find_lang_crate(LangCrateOrigin::ProcMacro)\n     }\n \n     pub fn core_cmp_Ord(&self) -> Option<Trait> {\n@@ -88,18 +102,6 @@ impl FamousDefs<'_, '_> {\n         self.find_macro(\"core:macros:builtin:derive\")\n     }\n \n-    pub fn alloc(&self) -> Option<Crate> {\n-        self.find_crate(\"alloc\")\n-    }\n-\n-    pub fn test(&self) -> Option<Crate> {\n-        self.find_crate(\"test\")\n-    }\n-\n-    pub fn proc_macro(&self) -> Option<Crate> {\n-        self.find_crate(\"proc_macro\")\n-    }\n-\n     pub fn builtin_crates(&self) -> impl Iterator<Item = Crate> {\n         IntoIterator::into_iter([\n             self.std(),\n@@ -139,20 +141,32 @@ impl FamousDefs<'_, '_> {\n         }\n     }\n \n-    fn find_crate(&self, name: &str) -> Option<Crate> {\n-        let krate = self.1?;\n+    fn find_lang_crate(&self, origin: LangCrateOrigin) -> Option<Crate> {\n+        let krate = self.1;\n         let db = self.0.db;\n-        let res =\n-            krate.dependencies(db).into_iter().find(|dep| dep.name.to_smol_str() == name)?.krate;\n+        let crate_graph = self.0.db.crate_graph();\n+        let res = krate\n+            .dependencies(db)\n+            .into_iter()\n+            .find(|dep| crate_graph[dep.krate.into()].origin == CrateOrigin::Lang(origin))?\n+            .krate;\n         Some(res)\n     }\n \n     fn find_def(&self, path: &str) -> Option<ScopeDef> {\n         let db = self.0.db;\n         let mut path = path.split(':');\n         let trait_ = path.next_back()?;\n-        let std_crate = path.next()?;\n-        let std_crate = self.find_crate(std_crate)?;\n+        let lang_crate = path.next()?;\n+        let lang_crate = match lang_crate {\n+            \"core\" => LangCrateOrigin::Core,\n+            \"alloc\" => LangCrateOrigin::Alloc,\n+            \"test\" => LangCrateOrigin::Test,\n+            \"proc_macro\" => LangCrateOrigin::ProcMacro,\n+            \"std\" => LangCrateOrigin::Std,\n+            _ => return None,\n+        };\n+        let std_crate = self.find_lang_crate(lang_crate)?;\n         let mut module = std_crate.root_module(db);\n         for segment in path {\n             module = module.children(db).find_map(|child| {"}, {"sha": "f8cfe15c89607f2e1744d8b9a03c384a8203054b", "filename": "crates/ide_db/src/imports/import_assets.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -104,7 +104,7 @@ impl ImportAssets {\n         let candidate_node = method_call.syntax().clone();\n         Some(Self {\n             import_candidate: ImportCandidate::for_method_call(sema, method_call)?,\n-            module_with_candidate: sema.scope(&candidate_node).module()?,\n+            module_with_candidate: sema.scope(&candidate_node)?.module(),\n             candidate_node,\n         })\n     }\n@@ -119,7 +119,7 @@ impl ImportAssets {\n         }\n         Some(Self {\n             import_candidate: ImportCandidate::for_regular_path(sema, fully_qualified_path)?,\n-            module_with_candidate: sema.scope(&candidate_node).module()?,\n+            module_with_candidate: sema.scope(&candidate_node)?.module(),\n             candidate_node,\n         })\n     }\n@@ -132,7 +132,7 @@ impl ImportAssets {\n         let candidate_node = pat.syntax().clone();\n         Some(Self {\n             import_candidate: ImportCandidate::for_name(sema, &name)?,\n-            module_with_candidate: sema.scope(&candidate_node).module()?,\n+            module_with_candidate: sema.scope(&candidate_node)?.module(),\n             candidate_node,\n         })\n     }\n@@ -248,7 +248,10 @@ impl ImportAssets {\n         };\n \n         let krate = self.module_with_candidate.krate();\n-        let scope = sema.scope(&self.candidate_node);\n+        let scope = match sema.scope(&self.candidate_node) {\n+            Some(it) => it,\n+            None => return Vec::new(),\n+        };\n \n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n@@ -271,9 +274,11 @@ impl ImportAssets {\n     fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n         let _p = profile::span(\"import_assets::scope_definitions\");\n         let mut scope_definitions = FxHashSet::default();\n-        sema.scope(&self.candidate_node).process_all_names(&mut |_, scope_def| {\n-            scope_definitions.insert(scope_def);\n-        });\n+        if let Some(scope) = sema.scope(&self.candidate_node) {\n+            scope.process_all_names(&mut |_, scope_def| {\n+                scope_definitions.insert(scope_def);\n+            });\n+        }\n         scope_definitions\n     }\n }\n@@ -588,7 +593,7 @@ impl ImportCandidate {\n \n     fn for_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<Self> {\n         if sema\n-            .scope(name.syntax())\n+            .scope(name.syntax())?\n             .speculative_resolve(&ast::make::ext::ident_path(&name.text()))\n             .is_some()\n         {"}, {"sha": "15bd9a8c9c18c96f215358b489c7a6cdc8409f07", "filename": "crates/ide_db/src/path_transform.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -69,15 +69,13 @@ impl<'a> PathTransform<'a> {\n     }\n \n     pub fn apply(&self, syntax: &SyntaxNode) {\n-        if let Some(ctx) = self.build_ctx() {\n-            ctx.apply(syntax)\n-        }\n+        self.build_ctx().apply(syntax)\n     }\n \n-    fn build_ctx(&self) -> Option<Ctx<'a>> {\n+    fn build_ctx(&self) -> Ctx<'a> {\n         let db = self.source_scope.db;\n-        let target_module = self.target_scope.module()?;\n-        let source_module = self.source_scope.module()?;\n+        let target_module = self.target_scope.module();\n+        let source_module = self.source_scope.module();\n         let skip = match self.generic_def {\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n             hir::GenericDef::Trait(_) => 1,\n@@ -111,8 +109,7 @@ impl<'a> PathTransform<'a> {\n                 },\n             })\n             .collect();\n-        let res = Ctx { substs: substs_by_param, target_module, source_scope: self.source_scope };\n-        Some(res)\n+        Ctx { substs: substs_by_param, target_module, source_scope: self.source_scope }\n     }\n }\n "}, {"sha": "fe99c2e2ce0251e7c55448f48f13caf48b076a4d", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -734,13 +734,7 @@ fn def_to_ty(sema: &Semantics<RootDatabase>, def: &Definition) -> Option<hir::Ty\n     match def {\n         Definition::Adt(adt) => Some(adt.ty(sema.db)),\n         Definition::TypeAlias(it) => Some(it.ty(sema.db)),\n-        Definition::BuiltinType(it) => {\n-            let graph = sema.db.crate_graph();\n-            let krate = graph.iter().next()?;\n-            let root_file = graph[krate].root_file_id;\n-            let module = sema.to_module_def(root_file)?;\n-            Some(it.ty(sema.db, module))\n-        }\n+        Definition::BuiltinType(it) => Some(it.ty(sema.db)),\n         Definition::SelfType(it) => Some(it.self_ty(sema.db)),\n         _ => None,\n     }"}, {"sha": "414878b2308a7f7f53302cb098e422f361d94cab", "filename": "crates/ide_diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -64,7 +64,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n \n     let new_field_list = old_field_list.clone_for_update();\n     let mut locals = FxHashMap::default();\n-    ctx.sema.scope(field_list_parent.syntax()).process_all_names(&mut |name, def| {\n+    ctx.sema.scope(field_list_parent.syntax())?.process_all_names(&mut |name, def| {\n         if let hir::ScopeDef::Local(local) = def {\n             locals.insert(name, local);\n         }\n@@ -171,11 +171,7 @@ fn get_default_constructor(\n     if has_new_func {\n         Some(make::ext::expr_ty_new(&make_ty(ty, ctx.sema.db, module)))\n     } else if !ty.is_array()\n-        && ty.impls_trait(\n-            ctx.sema.db,\n-            FamousDefs(&ctx.sema, Some(krate)).core_default_Default()?,\n-            &[],\n-        )\n+        && ty.impls_trait(ctx.sema.db, FamousDefs(&ctx.sema, krate).core_default_Default()?, &[])\n     {\n         Some(make::ext::expr_ty_default(&make_ty(ty, ctx.sema.db, module)))\n     } else {"}, {"sha": "1b275f7e6cb798ba2a2bf6fa48f868dbaa0a1949", "filename": "crates/ide_diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -76,7 +76,7 @@ fn add_missing_ok_or_some(\n     let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n     let expr = d.expr.value.to_node(&root);\n     let expr_range = expr.syntax().text_range();\n-    let scope = ctx.sema.scope(expr.syntax());\n+    let scope = ctx.sema.scope(expr.syntax())?;\n \n     let expected_adt = d.expected.as_adt()?;\n     let expected_enum = expected_adt.as_enum()?;"}, {"sha": "c50e74d93a4679b1c60ba2bd3531b1581a665351", "filename": "crates/ide_ssr/src/from_comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Ffrom_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Ffrom_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Ffrom_comment.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -25,7 +25,7 @@ pub fn ssr_from_comment(db: &RootDatabase, frange: FileRange) -> Option<(MatchFi\n \n     let lookup_context = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let mut match_finder = MatchFinder::in_context(db, lookup_context, vec![]);\n+    let mut match_finder = MatchFinder::in_context(db, lookup_context, vec![]).ok()?;\n     match_finder.add_rule(ssr_rule).ok()?;\n \n     Some((match_finder, comment.syntax().text_range()))"}, {"sha": "4db8034212166767327b3f5be15de0ba6639f8d6", "filename": "crates/ide_ssr/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Flib.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -128,11 +128,12 @@ impl<'db> MatchFinder<'db> {\n         db: &'db ide_db::RootDatabase,\n         lookup_context: FilePosition,\n         mut restrict_ranges: Vec<FileRange>,\n-    ) -> MatchFinder<'db> {\n+    ) -> Result<MatchFinder<'db>, SsrError> {\n         restrict_ranges.retain(|range| !range.range.is_empty());\n         let sema = Semantics::new(db);\n-        let resolution_scope = resolving::ResolutionScope::new(&sema, lookup_context);\n-        MatchFinder { sema, rules: Vec::new(), resolution_scope, restrict_ranges }\n+        let resolution_scope = resolving::ResolutionScope::new(&sema, lookup_context)\n+            .ok_or_else(|| SsrError(\"no resolution scope for file\".into()))?;\n+        Ok(MatchFinder { sema, rules: Vec::new(), resolution_scope, restrict_ranges })\n     }\n \n     /// Constructs an instance using the start of the first file in `db` as the lookup context.\n@@ -142,11 +143,11 @@ impl<'db> MatchFinder<'db> {\n         if let Some(first_file_id) =\n             db.local_roots().iter().next().and_then(|root| db.source_root(*root).iter().next())\n         {\n-            Ok(MatchFinder::in_context(\n+            MatchFinder::in_context(\n                 db,\n                 FilePosition { file_id: first_file_id, offset: 0.into() },\n                 vec![],\n-            ))\n+            )\n         } else {\n             bail!(\"No files to search\");\n         }"}, {"sha": "ba5aa0cc94ef86dea6e66789e43969a699f0e114", "filename": "crates/ide_ssr/src/matching.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fmatching.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -646,8 +646,8 @@ impl Match {\n     ) -> Result<(), MatchFailed> {\n         let module = sema\n             .scope(&self.matched_node)\n-            .module()\n-            .ok_or_else(|| match_error!(\"Matched node isn't in a module\"))?;\n+            .ok_or_else(|| match_error!(\"Matched node isn't in a module\"))?\n+            .module();\n         for (path, resolved_path) in &template.resolved_paths {\n             if let hir::PathResolution::Def(module_def) = resolved_path.resolution {\n                 let mod_path = module.find_use_path(sema.db, module_def).ok_or_else(|| {\n@@ -788,7 +788,7 @@ mod tests {\n         let input = \"fn foo() {} fn bar() {} fn main() { foo(1+2); }\";\n \n         let (db, position, selections) = crate::tests::single_file(input);\n-        let mut match_finder = MatchFinder::in_context(&db, position, selections);\n+        let mut match_finder = MatchFinder::in_context(&db, position, selections).unwrap();\n         match_finder.add_rule(rule).unwrap();\n         let matches = match_finder.matches();\n         assert_eq!(matches.matches.len(), 1);"}, {"sha": "d9b40608b82dfb4749696378a4128282251ba63a", "filename": "crates/ide_ssr/src/resolving.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fresolving.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -186,7 +186,7 @@ impl<'db> ResolutionScope<'db> {\n     pub(crate) fn new(\n         sema: &hir::Semantics<'db, ide_db::RootDatabase>,\n         resolve_context: FilePosition,\n-    ) -> ResolutionScope<'db> {\n+    ) -> Option<ResolutionScope<'db>> {\n         use syntax::ast::AstNode;\n         let file = sema.parse(resolve_context.file_id);\n         // Find a node at the requested position, falling back to the whole file.\n@@ -197,8 +197,8 @@ impl<'db> ResolutionScope<'db> {\n             .and_then(|token| token.parent())\n             .unwrap_or_else(|| file.syntax().clone());\n         let node = pick_node_for_resolution(node);\n-        let scope = sema.scope(&node);\n-        ResolutionScope { scope, node }\n+        let scope = sema.scope(&node)?;\n+        Some(ResolutionScope { scope, node })\n     }\n \n     /// Returns the function in which SSR was invoked, if any.\n@@ -219,7 +219,7 @@ impl<'db> ResolutionScope<'db> {\n         let resolved_qualifier = self.scope.speculative_resolve(&path.qualifier()?)?;\n         if let hir::PathResolution::Def(hir::ModuleDef::Adt(adt)) = resolved_qualifier {\n             let name = path.segment()?.name_ref()?;\n-            let module = self.scope.module()?;\n+            let module = self.scope.module();\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 &self.scope,"}, {"sha": "26a043dc98ef9624fb2c745bdc988c09267e9aae", "filename": "crates/ide_ssr/src/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fide_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Ftests.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -94,7 +94,7 @@ fn assert_ssr_transform(rule: &str, input: &str, expected: Expect) {\n \n fn assert_ssr_transforms(rules: &[&str], input: &str, expected: Expect) {\n     let (db, position, selections) = single_file(input);\n-    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections).unwrap();\n     for rule in rules {\n         let rule: SsrRule = rule.parse().unwrap();\n         match_finder.add_rule(rule).unwrap();\n@@ -124,7 +124,7 @@ fn print_match_debug_info(match_finder: &MatchFinder, file_id: FileId, snippet:\n \n fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n     let (db, position, selections) = single_file(code);\n-    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections).unwrap();\n     match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let matched_strings: Vec<String> =\n         match_finder.matches().flattened().matches.iter().map(|m| m.matched_text()).collect();\n@@ -136,7 +136,7 @@ fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n \n fn assert_no_match(pattern: &str, code: &str) {\n     let (db, position, selections) = single_file(code);\n-    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections).unwrap();\n     match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let matches = match_finder.matches().flattened().matches;\n     if !matches.is_empty() {\n@@ -147,7 +147,7 @@ fn assert_no_match(pattern: &str, code: &str) {\n \n fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expected_reason: &str) {\n     let (db, position, selections) = single_file(code);\n-    let mut match_finder = MatchFinder::in_context(&db, position, selections);\n+    let mut match_finder = MatchFinder::in_context(&db, position, selections).unwrap();\n     match_finder.add_search_pattern(pattern.parse().unwrap()).unwrap();\n     let mut reasons = Vec::new();\n     for d in match_finder.debug_where_text_equal(position.file_id, snippet) {"}, {"sha": "351e820adab21fa314fec9734ca54df140da9e44", "filename": "crates/project_model/src/tests.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fproject_model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fproject_model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Ftests.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -1261,7 +1261,9 @@ fn rust_project_hello_world_project_model() {\n                             },\n                         ],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Alloc,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1291,7 +1293,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Other,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1321,7 +1325,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Other,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1361,7 +1367,9 @@ fn rust_project_hello_world_project_model() {\n                             },\n                         ],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            ProcMacro,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1391,7 +1399,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Core,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1490,7 +1500,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Other,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1520,7 +1532,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Other,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1550,7 +1564,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Other,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1580,7 +1596,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Test,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1692,7 +1710,9 @@ fn rust_project_hello_world_project_model() {\n                             },\n                         ],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Std,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n@@ -1722,7 +1742,9 @@ fn rust_project_hello_world_project_model() {\n                         },\n                         dependencies: [],\n                         proc_macro: [],\n-                        origin: Lang,\n+                        origin: Lang(\n+                            Other,\n+                        ),\n                         is_proc_macro: false,\n                     },\n                 },"}, {"sha": "509219f0b66586f8355467c20673a09bf1050cbd", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b000b544b9d51c5448bc377fcffb951781926f3/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=9b000b544b9d51c5448bc377fcffb951781926f3", "patch": "@@ -7,7 +7,7 @@ use std::{collections::VecDeque, fmt, fs, process::Command};\n use anyhow::{format_err, Context, Result};\n use base_db::{\n     CrateDisplayName, CrateGraph, CrateId, CrateName, CrateOrigin, Dependency, Edition, Env,\n-    FileId, ProcMacro,\n+    FileId, LangCrateOrigin, ProcMacro,\n };\n use cfg::{CfgDiff, CfgOptions};\n use paths::{AbsPath, AbsPathBuf};\n@@ -487,7 +487,7 @@ fn project_json_to_crate_graph(\n                     if krate.display_name.is_some() {\n                         CrateOrigin::CratesIo { repo: krate.repository.clone() }\n                     } else {\n-                        CrateOrigin::Unknown\n+                        CrateOrigin::CratesIo { repo: None }\n                     },\n                 ),\n             )\n@@ -710,7 +710,7 @@ fn detached_files_to_crate_graph(\n             Env::default(),\n             Vec::new(),\n             false,\n-            CrateOrigin::Unknown,\n+            CrateOrigin::CratesIo { repo: None },\n         );\n \n         public_deps.add(detached_file_crate, &mut crate_graph);\n@@ -908,7 +908,14 @@ fn sysroot_to_crate_graph(\n                 env,\n                 proc_macro,\n                 false,\n-                CrateOrigin::Lang,\n+                CrateOrigin::Lang(match &*sysroot[krate].name {\n+                    \"alloc\" => LangCrateOrigin::Alloc,\n+                    \"core\" => LangCrateOrigin::Core,\n+                    \"proc_macro\" => LangCrateOrigin::ProcMacro,\n+                    \"std\" => LangCrateOrigin::Std,\n+                    \"test\" => LangCrateOrigin::Test,\n+                    _ => LangCrateOrigin::Other,\n+                }),\n             );\n             Some((krate, crate_id))\n         })"}]}