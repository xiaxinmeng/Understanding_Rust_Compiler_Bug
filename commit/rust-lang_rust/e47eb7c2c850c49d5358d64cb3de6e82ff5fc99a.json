{"sha": "e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0N2ViN2MyYzg1MGM0OWQ1MzU4ZDY0Y2IzZGU2ZTgyZmY1ZmM5OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-19T03:50:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-19T03:50:05Z"}, "message": "Auto merge of #27493 - GSam:master, r=nrc\n\nIn order to test the validity of identifiers, exposing the name resolution module is necessary. Other changes mostly comprise of exposing modules publicly like parts of save-analysis, so they can be called appropriately.", "tree": {"sha": "520295e90663d009b95426a8d9cc774dffc07f16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/520295e90663d009b95426a8d9cc774dffc07f16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a", "html_url": "https://github.com/rust-lang/rust/commit/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e13faee1776595fb1e460005d8271c141f758b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e13faee1776595fb1e460005d8271c141f758b0", "html_url": "https://github.com/rust-lang/rust/commit/7e13faee1776595fb1e460005d8271c141f758b0"}, {"sha": "fc9ecae4442ba39ed1474a129d10bd37c7fdab00", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9ecae4442ba39ed1474a129d10bd37c7fdab00", "html_url": "https://github.com/rust-lang/rust/commit/fc9ecae4442ba39ed1474a129d10bd37c7fdab00"}], "stats": {"total": 122, "additions": 91, "deletions": 31}, "files": [{"sha": "da6ece73f79b355a8610325e293d676a1b36b9ee", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 88, "deletions": 28, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a", "patch": "@@ -109,6 +109,17 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n+// Perform the callback, not walking deeper if the return is true\n+macro_rules! execute_callback {\n+    ($node: expr, $walker: expr) => (\n+        if let Some(ref callback) = $walker.callback {\n+            if callback($node, &mut $walker.resolved) {\n+                return;\n+            }\n+        }\n+    )\n+}\n+\n pub enum ResolutionError<'a> {\n     /// error E0401: can't use type parameters from outer function\n     TypeParametersFromOuterFunction,\n@@ -397,7 +408,7 @@ enum PatternBindingMode {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-enum Namespace {\n+pub enum Namespace {\n     TypeNS,\n     ValueNS\n }\n@@ -445,18 +456,22 @@ enum NameDefinition {\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n+        execute_callback!(ast_map::Node::NodeItem(item), self);\n         self.resolve_item(item);\n     }\n     fn visit_arm(&mut self, arm: &Arm) {\n         self.resolve_arm(arm);\n     }\n     fn visit_block(&mut self, block: &Block) {\n+        execute_callback!(ast_map::Node::NodeBlock(block), self);\n         self.resolve_block(block);\n     }\n     fn visit_expr(&mut self, expr: &Expr) {\n+        execute_callback!(ast_map::Node::NodeExpr(expr), self);\n         self.resolve_expr(expr);\n     }\n     fn visit_local(&mut self, local: &Local) {\n+        execute_callback!(ast_map::Node::NodeLocal(&*local.pat), self);\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &Ty) {\n@@ -475,6 +490,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self, variant: &ast::Variant, generics: &Generics) {\n+        execute_callback!(ast_map::Node::NodeVariant(variant), self);\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n             self.with_constant_rib(|this| {\n@@ -498,6 +514,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         }\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &ast::ForeignItem) {\n+        execute_callback!(ast_map::Node::NodeForeignItem(foreign_item), self);\n         let type_parameters = match foreign_item.node {\n             ForeignItemFn(_, ref generics) => {\n                 HasTypeParameters(generics, FnSpace, ItemRibKind)\n@@ -1147,6 +1164,13 @@ pub struct Resolver<'a, 'tcx:'a> {\n \n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n+\n+    // Callback function for intercepting walks\n+    callback: Option<Box<Fn(ast_map::Node, &mut bool) -> bool>>,\n+    // The intention is that the callback modifies this flag.\n+    // Once set, the resolver falls out of the walk, preserving the ribs.\n+    resolved: bool,\n+\n }\n \n #[derive(PartialEq)]\n@@ -1208,6 +1232,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: HashMap::new(),\n+\n+            callback: None,\n+            resolved: false,\n+\n         }\n     }\n \n@@ -2234,7 +2262,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         f(self);\n \n         match type_parameters {\n-            HasTypeParameters(..) => { self.type_ribs.pop(); }\n+            HasTypeParameters(..) => { if !self.resolved { self.type_ribs.pop(); } }\n             NoTypeParameters => { }\n         }\n     }\n@@ -2244,7 +2272,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n-        self.label_ribs.pop();\n+        if !self.resolved {\n+            self.label_ribs.pop();\n+        }\n     }\n \n     fn with_constant_rib<F>(&mut self, f: F) where\n@@ -2253,8 +2283,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        self.type_ribs.pop();\n-        self.value_ribs.pop();\n+        if !self.resolved {\n+            self.type_ribs.pop();\n+            self.value_ribs.pop();\n+        }\n     }\n \n     fn resolve_function(&mut self,\n@@ -2285,8 +2317,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving function) leaving function\");\n \n-        self.label_ribs.pop();\n-        self.value_ribs.pop();\n+        if !self.resolved {\n+            self.label_ribs.pop();\n+            self.value_ribs.pop();\n+        }\n     }\n \n     fn resolve_trait_reference(&mut self,\n@@ -2389,7 +2423,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self_type_rib.bindings.insert(name, DlDef(self_def));\n         self.type_ribs.push(self_type_rib);\n         f(self);\n-        self.type_ribs.pop();\n+        if !self.resolved {\n+            self.type_ribs.pop();\n+        }\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -2558,7 +2594,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         visit::walk_expr_opt(self, &arm.guard);\n         self.visit_expr(&*arm.body);\n \n-        self.value_ribs.pop();\n+        if !self.resolved {\n+            self.value_ribs.pop();\n+        }\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n@@ -2600,9 +2638,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         visit::walk_block(self, block);\n \n         // Move back up.\n-        self.current_module = orig_module;\n-\n-        self.value_ribs.pop();\n+        if !self.resolved {\n+            self.current_module = orig_module;\n+            self.value_ribs.pop();\n+        }\n         debug!(\"(resolving block) leaving block\");\n     }\n \n@@ -3044,12 +3083,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// doesn't skip straight to the containing module.\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `middle::def::PathResolution` for more info.\n-    fn resolve_path(&mut self,\n-                    id: NodeId,\n-                    path: &Path,\n-                    path_depth: usize,\n-                    namespace: Namespace,\n-                    check_ribs: bool) -> Option<PathResolution> {\n+    pub fn resolve_path(&mut self,\n+                        id: NodeId,\n+                        path: &Path,\n+                        path_depth: usize,\n+                        namespace: Namespace,\n+                        check_ribs: bool) -> Option<PathResolution> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len()-path_depth];\n \n@@ -3988,16 +4027,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                make_glob_map: MakeGlobMap)\n                                -> CrateMap {\n     let krate = ast_map.krate();\n-    let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n-\n-    build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n-    session.abort_if_errors();\n-\n-    resolve_imports::resolve_imports(&mut resolver);\n-    session.abort_if_errors();\n-\n-    record_exports::record(&mut resolver);\n-    session.abort_if_errors();\n+    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, None);\n \n     resolver.resolve_crate(krate);\n     session.abort_if_errors();\n@@ -4018,4 +4048,34 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     }\n }\n \n+/// Builds a name resolution walker to be used within this module,\n+/// or used externally, with an optional callback function.\n+///\n+/// The callback takes a &mut bool which allows callbacks to end a\n+/// walk when set to true, passing through the rest of the walk, while\n+/// preserving the ribs + current module. This allows resolve_path\n+/// calls to be made with the correct scope info. The node in the\n+/// callback corresponds to the current node in the walk.\n+pub fn create_resolver<'a, 'tcx>(session: &'a Session,\n+                                 ast_map: &'a ast_map::Map<'tcx>,\n+                                 krate: &'a Crate,\n+                                 make_glob_map: MakeGlobMap,\n+                                 callback: Option<Box<Fn(ast_map::Node, &mut bool) -> bool>>)\n+                                 -> Resolver<'a, 'tcx> {\n+    let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n+\n+    resolver.callback = callback;\n+\n+    build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n+    session.abort_if_errors();\n+\n+    resolve_imports::resolve_imports(&mut resolver);\n+    session.abort_if_errors();\n+\n+    record_exports::record(&mut resolver);\n+    session.abort_if_errors();\n+\n+    resolver\n+}\n+\n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "d90c78301f9d82a0ce5c367e44548788fc8ccf73", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=e47eb7c2c850c49d5358d64cb3de6e82ff5fc99a", "patch": "@@ -28,8 +28,8 @@ use syntax::print::pprust::ty_to_string;\n use self::span_utils::SpanUtils;\n \n \n-mod span_utils;\n-mod recorder;\n+pub mod span_utils;\n+pub mod recorder;\n \n mod dump_csv;\n \n@@ -645,7 +645,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     #[inline]\n-    fn enclosing_scope(&self, id: NodeId) -> NodeId {\n+    pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n         self.tcx.map.get_enclosing_scope(id).unwrap_or(0)\n     }\n }"}]}