{"sha": "e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MTJjYTQ3MmEyYTUyODRlOWYxNWNkOWFmMzIyODVkN2ZmM2ZkMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-02T04:22:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-02T04:22:55Z"}, "message": "Auto merge of #54701 - arielb1:outlives-later, r=nikomatsakis\n\nnormalize param-env type-outlives predicates last\n\nThe normalization of type-outlives predicates can depend on misc.\nenvironment predicates, but not the other way around. Inferred lifetime\nbounds can propagate type-outlives bounds far and wide, so their\nnormalization needs to work well.\n\nFixes #54467\n\nr? @nikomatsakis\nbeta-nominating because this is required for inferred_outlives_bounds, which is in beta", "tree": {"sha": "95573240736e7f0488f9de0ebba124cc96c82c2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95573240736e7f0488f9de0ebba124cc96c82c2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "html_url": "https://github.com/rust-lang/rust/commit/e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d1065bc2a4a79e553e87cb18faf48aa7df1858f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1065bc2a4a79e553e87cb18faf48aa7df1858f", "html_url": "https://github.com/rust-lang/rust/commit/2d1065bc2a4a79e553e87cb18faf48aa7df1858f"}, {"sha": "b95d0489d96cc7e8f9e0a800cf9fa0907a8840c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b95d0489d96cc7e8f9e0a800cf9fa0907a8840c5", "html_url": "https://github.com/rust-lang/rust/commit/b95d0489d96cc7e8f9e0a800cf9fa0907a8840c5"}], "stats": {"total": 229, "additions": 172, "deletions": 57}, "files": [{"sha": "7722896b6eb4a8263d2c6ac8fb6c8c80d2187520", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "patch": "@@ -1456,7 +1456,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Clears the selection, evaluation, and projection cachesThis is useful when\n+    /// Clears the selection, evaluation, and projection caches. This is useful when\n     /// repeatedly attemping to select an Obligation while changing only\n     /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n     pub fn clear_caches(&self) {"}, {"sha": "286e35c5d4e9582cebe50b93dd204b5f3d2f67f2", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 117, "deletions": 56, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "patch": "@@ -29,6 +29,7 @@ use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n use infer::{InferCtxt};\n+use util::common::ErrorReported;\n \n use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n@@ -632,44 +633,15 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n     }\n }\n \n-// FIXME: this is gonna need to be removed ...\n-/// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              region_context: DefId,\n-                                              unnormalized_env: ty::ParamEnv<'tcx>,\n-                                              cause: ObligationCause<'tcx>)\n-                                              -> ty::ParamEnv<'tcx>\n+fn do_normalize_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     region_context: DefId,\n+                                     cause: ObligationCause<'tcx>,\n+                                     elaborated_env: ty::ParamEnv<'tcx>,\n+                                     predicates: Vec<ty::Predicate<'tcx>>)\n+                                     -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported>\n {\n-    // I'm not wild about reporting errors here; I'd prefer to\n-    // have the errors get reported at a defined place (e.g.,\n-    // during typeck). Instead I have all parameter\n-    // environments, in effect, going through this function\n-    // and hence potentially reporting errors. This ensures of\n-    // course that we never forget to normalize (the\n-    // alternative seemed like it would involve a lot of\n-    // manual invocations of this fn -- and then we'd have to\n-    // deal with the errors at each of those sites).\n-    //\n-    // In any case, in practice, typeck constructs all the\n-    // parameter environments once for every fn as it goes,\n-    // and errors will get reported then; so after typeck we\n-    // can be sure that no errors should occur.\n-\n+    debug!(\"do_normalize_predicates({:?})\", predicates);\n     let span = cause.span;\n-\n-    debug!(\"normalize_param_env_or_error(unnormalized_env={:?})\",\n-           unnormalized_env);\n-\n-    let predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n-            .collect();\n-\n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n-           predicates);\n-\n-    let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                           unnormalized_env.reveal);\n-\n     tcx.infer_ctxt().enter(|infcx| {\n         // FIXME. We should really... do something with these region\n         // obligations. But this call just continues the older\n@@ -685,30 +657,21 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // them here too, and we will remove this function when\n         // we move over to lazy normalization *anyway*.\n         let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-\n         let predicates = match fully_normalize(\n             &infcx,\n             fulfill_cx,\n             cause,\n             elaborated_env,\n-            // You would really want to pass infcx.param_env.caller_bounds here,\n-            // but that is an interned slice, and fully_normalize takes &T and returns T, so\n-            // without further refactoring, a slice can't be used. Luckily, we still have the\n-            // predicate vector from which we created the ParamEnv in infcx, so we\n-            // can pass that instead. It's roundabout and a bit brittle, but this code path\n-            // ought to be refactored anyway, and until then it saves us from having to copy.\n             &predicates,\n         ) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n                 infcx.report_fulfillment_errors(&errors, None, false);\n-                // An unnormalized env is better than nothing.\n-                return elaborated_env;\n+                return Err(ErrorReported)\n             }\n         };\n \n-        debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n-               predicates);\n+        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n         let region_scope_tree = region::ScopeTree::default();\n \n@@ -734,21 +697,119 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // unconstrained variable, and it seems better not to ICE,\n                 // all things considered.\n                 tcx.sess.span_err(span, &fixup_err.to_string());\n-                // An unnormalized env is better than nothing.\n-                return elaborated_env;\n+                return Err(ErrorReported)\n             }\n         };\n \n-        let predicates = match tcx.lift_to_global(&predicates) {\n-            Some(predicates) => predicates,\n-            None => return elaborated_env,\n+        match tcx.lift_to_global(&predicates) {\n+            Some(predicates) => Ok(predicates),\n+            None => {\n+                // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n+                Err(ErrorReported)\n+            }\n+        }\n+    })\n+}\n+\n+// FIXME: this is gonna need to be removed ...\n+/// Normalizes the parameter environment, reporting errors if they occur.\n+pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                              region_context: DefId,\n+                                              unnormalized_env: ty::ParamEnv<'tcx>,\n+                                              cause: ObligationCause<'tcx>)\n+                                              -> ty::ParamEnv<'tcx>\n+{\n+    // I'm not wild about reporting errors here; I'd prefer to\n+    // have the errors get reported at a defined place (e.g.,\n+    // during typeck). Instead I have all parameter\n+    // environments, in effect, going through this function\n+    // and hence potentially reporting errors. This ensures of\n+    // course that we never forget to normalize (the\n+    // alternative seemed like it would involve a lot of\n+    // manual invocations of this fn -- and then we'd have to\n+    // deal with the errors at each of those sites).\n+    //\n+    // In any case, in practice, typeck constructs all the\n+    // parameter environments once for every fn as it goes,\n+    // and errors will get reported then; so after typeck we\n+    // can be sure that no errors should occur.\n+\n+    debug!(\"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n+           region_context, unnormalized_env, cause);\n+\n+    let mut predicates: Vec<_> =\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n+            .collect();\n+\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n+           predicates);\n+\n+    let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n+                                           unnormalized_env.reveal);\n+\n+    // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n+    // normalization expects its param-env to be already normalized, which means we have\n+    // a circularity.\n+    //\n+    // The way we handle this is by normalizing the param-env inside an unnormalized version\n+    // of the param-env, which means that if the param-env contains unnormalized projections,\n+    // we'll have some normalization failures. This is unfortunate.\n+    //\n+    // Lazy normalization would basically handle this by treating just the\n+    // normalizing-a-trait-ref-requires-itself cycles as evaluation failures.\n+    //\n+    // Inferred outlives bounds can create a lot of `TypeOutlives` predicates for associated\n+    // types, so to make the situation less bad, we normalize all the predicates *but*\n+    // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n+    // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n+    //\n+    // This works fairly well because trait matching  does not actually care about param-env\n+    // TypeOutlives predicates - these are normally used by regionck.\n+    let outlives_predicates: Vec<_> = predicates.drain_filter(|predicate| {\n+        match predicate {\n+            ty::Predicate::TypeOutlives(..) => true,\n+            _ => false\n+        }\n+    }).collect();\n+\n+    debug!(\"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n+           predicates, outlives_predicates);\n+    let non_outlives_predicates =\n+        match do_normalize_predicates(tcx, region_context, cause.clone(),\n+                                      elaborated_env, predicates) {\n+            Ok(predicates) => predicates,\n+            // An unnormalized env is better than nothing.\n+            Err(ErrorReported) => {\n+                debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n+                return elaborated_env\n+            }\n         };\n \n-        debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n-               predicates);\n+    debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n+\n+    // Not sure whether it is better to include the unnormalized TypeOutlives predicates\n+    // here. I believe they should not matter, because we are ignoring TypeOutlives param-env\n+    // predicates here anyway. Keeping them here anyway because it seems safer.\n+    let outlives_env: Vec<_> =\n+        non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n+    let outlives_env = ty::ParamEnv::new(tcx.intern_predicates(&outlives_env),\n+                                         unnormalized_env.reveal);\n+    let outlives_predicates =\n+        match do_normalize_predicates(tcx, region_context, cause,\n+                                      outlives_env, outlives_predicates) {\n+            Ok(predicates) => predicates,\n+            // An unnormalized env is better than nothing.\n+            Err(ErrorReported) => {\n+                debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n+                return elaborated_env\n+            }\n+        };\n+    debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n \n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n-    })\n+    let mut predicates = non_outlives_predicates;\n+    predicates.extend(outlives_predicates);\n+    debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n+    ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n }\n \n pub fn fully_normalize<'a, 'gcx, 'tcx, T>("}, {"sha": "4fc44952e3a815c392261a67f0e03af0875f2631", "filename": "src/test/run-pass/issue-54467.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/src%2Ftest%2Frun-pass%2Fissue-54467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e812ca472a2a5284e9f15cd9af32285d7ff3fd39/src%2Ftest%2Frun-pass%2Fissue-54467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54467.rs?ref=e812ca472a2a5284e9f15cd9af32285d7ff3fd39", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Stream {\n+    type Item;\n+    type Error;\n+}\n+\n+pub trait ParseError<I> {\n+    type Output;\n+}\n+\n+impl ParseError<char> for u32 {\n+    type Output = ();\n+}\n+\n+impl Stream for () {\n+    type Item = char;\n+    type Error = u32;\n+}\n+\n+pub struct Lex<'a, I>\n+    where I: Stream,\n+          I::Error: ParseError<char>,\n+          <<I as Stream>::Error as ParseError<char>>::Output: 'a\n+{\n+    x: &'a <I::Error as ParseError<char>>::Output\n+}\n+\n+pub struct Reserved<'a, I> where\n+    I: Stream<Item=char> + 'a,\n+    I::Error: ParseError<I::Item>,\n+    <<I as Stream>::Error as ParseError<char>>::Output: 'a\n+\n+{\n+    x: Lex<'a, I>\n+}\n+\n+fn main() {\n+    let r: Reserved<()> = Reserved {\n+        x: Lex {\n+            x: &()\n+        }\n+    };\n+\n+    let _v = r.x.x;\n+}"}]}