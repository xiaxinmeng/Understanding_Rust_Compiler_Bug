{"sha": "c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMGQ3ZWVjYmMwOTI4YjU3ZGE4ZmUzMGIyZWY4NTI4ZTJiZGQ1YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-11T13:05:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-11T13:05:52Z"}, "message": "Auto merge of #69919 - Centril:rollup-fxo33zs, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #66472 (--show-coverage json)\n - #69603 (tidy: replace `make check` with `./x.py test` in documentation)\n - #69760 (Improve expression & attribute parsing)\n - #69828 (fix memory leak when vec::IntoIter panics during drop)\n - #69850 (panic_bounds_check: use caller_location, like PanicFnLangItem)\n - #69876 (Add long error explanation for E0739)\n - #69888 ([Miri] Use a session variable instead of checking for an env var always)\n - #69893 (librustc_codegen_llvm: Use slices instead of 0-terminated strings)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e8f110a9249dbcf8ce290bda1b3c7702488247fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f110a9249dbcf8ce290bda1b3c7702488247fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "html_url": "https://github.com/rust-lang/rust/commit/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303d8aff6092709edd4dbd35b1c88e9aa40bf6d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8", "html_url": "https://github.com/rust-lang/rust/commit/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8"}, {"sha": "a77206fa4a35e7926fb4404bd167b06e342b7626", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77206fa4a35e7926fb4404bd167b06e342b7626", "html_url": "https://github.com/rust-lang/rust/commit/a77206fa4a35e7926fb4404bd167b06e342b7626"}], "stats": {"total": 1773, "additions": 1262, "deletions": 511}, "files": [{"sha": "a58d4f2a7c6a437697361ecab5518ac6a3cd2b46", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -142,7 +142,7 @@ the issue in question.\n Please make sure your pull request is in compliance with Rust's style\n guidelines by running\n \n-    $ python x.py test src/tools/tidy\n+    $ python x.py test tidy\n \n Make this check before every pull request (and every new commit in a pull\n request); you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)"}, {"sha": "87da7327fe619b433fb1af2756360c1ee601240f", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -55,6 +55,9 @@ The script accepts commands, flags, and arguments to determine what to do:\n   # run all unit tests\n   ./x.py test\n \n+  # execute tool tests\n+  ./x.py test tidy\n+\n   # execute the UI test suite\n   ./x.py test src/test/ui\n "}, {"sha": "d8831c6d9e566d34db206c416d1a29000b794e3e", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -359,7 +359,7 @@ Arguments:\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n-    This subcommand accepts a number of paths to directories to tests that\n+    This subcommand accepts a number of paths to test directories that\n     should be compiled and run. For example:\n \n         ./x.py test src/test/ui\n@@ -372,6 +372,10 @@ Arguments:\n     just like `build src/libstd --stage N` it tests the compiler produced by the previous\n     stage.\n \n+    Execute tool tests with a tool name argument:\n+\n+        ./x.py test tidy\n+\n     If no arguments are passed then the complete artifacts for that stage are\n     compiled and tested.\n "}, {"sha": "d1956270f135fc937143974e5577c4f6038f3071", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -2626,13 +2626,21 @@ impl<T: Clone> Clone for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n+        struct DropGuard<'a, T>(&'a mut IntoIter<T>);\n+\n+        impl<T> Drop for DropGuard<'_, T> {\n+            fn drop(&mut self) {\n+                // RawVec handles deallocation\n+                let _ = unsafe { RawVec::from_raw_parts(self.0.buf.as_ptr(), self.0.cap) };\n+            }\n+        }\n+\n+        let guard = DropGuard(self);\n         // destroy the remaining elements\n         unsafe {\n-            ptr::drop_in_place(self.as_mut_slice());\n+            ptr::drop_in_place(guard.0.as_mut_slice());\n         }\n-\n-        // RawVec handles deallocation\n-        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n+        // now `guard` will be dropped and do the rest\n     }\n }\n "}, {"sha": "04af5b5f7682800cd5694bfb6a9eb58e715c1b14", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,3 +1,4 @@\n+#[cfg(bootstrap)]\n #[doc(include = \"panic.md\")]\n #[macro_export]\n #[allow_internal_unstable(core_panic, track_caller)]\n@@ -20,6 +21,26 @@ macro_rules! panic {\n     );\n }\n \n+#[cfg(not(bootstrap))]\n+#[doc(include = \"panic.md\")]\n+#[macro_export]\n+#[allow_internal_unstable(core_panic, track_caller)]\n+#[stable(feature = \"core\", since = \"1.6.0\")]\n+macro_rules! panic {\n+    () => (\n+        $crate::panic!(\"explicit panic\")\n+    );\n+    ($msg:expr) => (\n+        $crate::panicking::panic($msg)\n+    );\n+    ($msg:expr,) => (\n+        $crate::panic!($msg)\n+    );\n+    ($fmt:expr, $($arg:tt)+) => (\n+        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+))\n+    );\n+}\n+\n /// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n ///\n /// On panic, this macro will print the values of the expressions with their"}, {"sha": "3587f3f0ebf56c738feb4be9a8db8327052a6424", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -32,6 +32,7 @@\n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n+/// The underlying implementation of libcore's `panic!` macro when no formatting is used.\n #[cold]\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n@@ -49,9 +50,28 @@ pub fn panic(expr: &str) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), Location::caller())\n+    #[cfg(not(bootstrap))]\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+    #[cfg(bootstrap)]\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), Location::caller());\n }\n \n+#[cfg(not(bootstrap))]\n+#[cold]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[track_caller]\n+#[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    panic!(\"index out of bounds: the len is {} but the index is {}\", len, index)\n+}\n+\n+// For bootstrap, we need a variant with the old argument order, and a corresponding\n+// `panic_fmt`.\n+#[cfg(bootstrap)]\n #[cold]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n@@ -66,10 +86,12 @@ fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n     )\n }\n \n+/// The underlying implementation of libcore's `panic!` macro when formatting is used.\n #[cold]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n+#[cfg_attr(not(bootstrap), track_caller)]\n+pub fn panic_fmt(fmt: fmt::Arguments<'_>, #[cfg(bootstrap)] location: &Location<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }\n     }\n@@ -81,6 +103,10 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;\n     }\n \n+    #[cfg(bootstrap)]\n     let pi = PanicInfo::internal_constructor(Some(&fmt), location);\n+    #[cfg(not(bootstrap))]\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller());\n+\n     unsafe { panic_impl(&pi) }\n }"}, {"sha": "0b33408edf02d0cb31c06a436773dc68325b71f0", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -5,15 +5,18 @@ use crate::mir;\n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::{Align, LayoutError, Size};\n use crate::ty::query::TyCtxtAt;\n+use crate::ty::tls;\n use crate::ty::{self, layout, Ty};\n \n use backtrace::Backtrace;\n+use rustc_data_structures::sync::Lock;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_macros::HashStable;\n+use rustc_session::CtfeBacktrace;\n use rustc_span::{Pos, Span};\n use rustc_target::spec::abi::Abi;\n-use std::{any::Any, env, fmt};\n+use std::{any::Any, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n@@ -257,21 +260,25 @@ impl From<ErrorHandled> for InterpErrorInfo<'_> {\n \n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n-        let backtrace = match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n-            // Matching `RUST_BACKTRACE` -- we treat \"0\" the same as \"not present\".\n-            Ok(ref val) if val != \"0\" => {\n-                let mut backtrace = Backtrace::new_unresolved();\n+        let capture_backtrace = tls::with_context_opt(|ctxt| {\n+            if let Some(ctxt) = ctxt {\n+                *Lock::borrow(&ctxt.tcx.sess.ctfe_backtrace)\n+            } else {\n+                CtfeBacktrace::Disabled\n+            }\n+        });\n \n-                if val == \"immediate\" {\n-                    // Print it now.\n-                    print_backtrace(&mut backtrace);\n-                    None\n-                } else {\n-                    Some(Box::new(backtrace))\n-                }\n+        let backtrace = match capture_backtrace {\n+            CtfeBacktrace::Disabled => None,\n+            CtfeBacktrace::Capture => Some(Box::new(Backtrace::new_unresolved())),\n+            CtfeBacktrace::Immediate => {\n+                // Print it now.\n+                let mut backtrace = Backtrace::new_unresolved();\n+                print_backtrace(&mut backtrace);\n+                None\n             }\n-            _ => None,\n         };\n+\n         InterpErrorInfo { kind, backtrace }\n     }\n }"}, {"sha": "3fc6444168e24297b8e1118ad9e1b384d9100a60", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -535,6 +535,16 @@ impl Token {\n         false\n     }\n \n+    // Is the token an interpolated block (`$b:block`)?\n+    pub fn is_whole_block(&self) -> bool {\n+        if let Interpolated(ref nt) = self.kind {\n+            if let NtBlock(..) = **nt {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     /// Returns `true` if the token is either the `mut` or `const` keyword.\n     pub fn is_mutability(&self) -> bool {\n         self.is_keyword(kw::Mut) || self.is_keyword(kw::Const)"}, {"sha": "4e7bc9fa0e2aed5fa11796834cbbb2b027cbfd42", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,5 +1,3 @@\n-use std::ffi::CString;\n-\n use crate::attributes;\n use libc::c_uint;\n use rustc::bug;\n@@ -50,8 +48,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: Alloc\n             args.len() as c_uint,\n             False,\n         );\n-        let name = CString::new(format!(\"__rust_{}\", method.name)).unwrap();\n-        let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr(), ty);\n+        let name = format!(\"__rust_{}\", method.name);\n+        let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n \n         if tcx.sess.target.target.options.default_hidden_visibility {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n@@ -60,8 +58,9 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: Alloc\n             attributes::emit_uwtable(llfn, true);\n         }\n \n-        let callee = CString::new(kind.fn_name(method.name)).unwrap();\n-        let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr(), ty);\n+        let callee = kind.fn_name(method.name);\n+        let callee =\n+            llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n         llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n \n         let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n@@ -73,14 +72,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut ModuleLlvm, kind: Alloc\n             .enumerate()\n             .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n             .collect::<Vec<_>>();\n-        let ret = llvm::LLVMRustBuildCall(\n-            llbuilder,\n-            callee,\n-            args.as_ptr(),\n-            args.len() as c_uint,\n-            None,\n-            \"\\0\".as_ptr().cast(),\n-        );\n+        let ret =\n+            llvm::LLVMRustBuildCall(llbuilder, callee, args.as_ptr(), args.len() as c_uint, None);\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {\n             llvm::LLVMBuildRet(llbuilder, ret);"}, {"sha": "6edc3d5ecd4776b4ee353f806393ea969fbc24a8", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -12,7 +12,6 @@ use rustc_span::Span;\n \n use libc::{c_char, c_uint};\n use log::debug;\n-use std::ffi::{CStr, CString};\n \n impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn codegen_inline_asm(\n@@ -80,12 +79,11 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             _ => self.type_struct(&output_types, false),\n         };\n \n-        let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n-        let constraint_cstr = CString::new(all_constraints).unwrap();\n+        let asm = ia.asm.as_str();\n         let r = inline_asm_call(\n             self,\n             &asm,\n-            &constraint_cstr,\n+            &all_constraints,\n             &inputs,\n             output_type,\n             ia.volatile,\n@@ -125,17 +123,17 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n impl AsmMethods for CodegenCx<'ll, 'tcx> {\n     fn codegen_global_asm(&self, ga: &hir::GlobalAsm) {\n-        let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n+        let asm = ga.asm.as_str();\n         unsafe {\n-            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr());\n+            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr().cast(), asm.len());\n         }\n     }\n }\n \n fn inline_asm_call(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    asm: &CStr,\n-    cons: &CStr,\n+    asm: &str,\n+    cons: &str,\n     inputs: &[&'ll Value],\n     output: &'ll llvm::Type,\n     volatile: bool,\n@@ -157,13 +155,15 @@ fn inline_asm_call(\n     let fty = bx.cx.type_func(&argtys[..], output);\n     unsafe {\n         // Ask LLVM to verify that the constraints are well-formed.\n-        let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr());\n+        let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr().cast(), cons.len());\n         debug!(\"constraint verification result: {:?}\", constraints_ok);\n         if constraints_ok {\n             let v = llvm::LLVMRustInlineAsm(\n                 fty,\n-                asm.as_ptr(),\n-                cons.as_ptr(),\n+                asm.as_ptr().cast(),\n+                asm.len(),\n+                cons.as_ptr().cast(),\n+                cons.len(),\n                 volatile,\n                 alignstack,\n                 llvm::AsmDialect::from_generic(dia),"}, {"sha": "1c5987f26f129f3112e4a365e44b87405a2a62f2", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1016,7 +1016,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n                 bundle,\n-                UNNAMED,\n             )\n         }\n     }"}, {"sha": "fab6321186b2c27363a34d60761a0724092f9861", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -21,7 +21,6 @@ use crate::value::Value;\n use log::debug;\n use rustc::ty::Ty;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::small_c_str::SmallCStr;\n \n /// Declare a function.\n ///\n@@ -34,8 +33,9 @@ fn declare_raw_fn(\n     ty: &'ll Type,\n ) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n-    let namebuf = SmallCStr::new(name);\n-    let llfn = unsafe { llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty) };\n+    let llfn = unsafe {\n+        llvm::LLVMRustGetOrInsertFunction(cx.llmod, name.as_ptr().cast(), name.len(), ty)\n+    };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n     // Function addresses in Rust are never significant, allowing functions to\n@@ -83,8 +83,7 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n         debug!(\"get_declared_value(name={:?})\", name);\n-        let namebuf = SmallCStr::new(name);\n-        unsafe { llvm::LLVMRustGetNamedValue(self.llmod, namebuf.as_ptr()) }\n+        unsafe { llvm::LLVMRustGetNamedValue(self.llmod, name.as_ptr().cast(), name.len()) }\n     }\n \n     fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {"}, {"sha": "388b6c74839583535ab1e6f9474a6a02aa29a315", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -732,7 +732,7 @@ extern \"C\" {\n \n     /// See Module::setModuleInlineAsm.\n     pub fn LLVMSetModuleInlineAsm(M: &Module, Asm: *const c_char);\n-    pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char);\n+    pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char, AsmLen: size_t);\n \n     /// See llvm::LLVMTypeKind::getTypeID.\n     pub fn LLVMRustGetTypeKind(Ty: &Type) -> TypeKind;\n@@ -879,13 +879,18 @@ extern \"C\" {\n     pub fn LLVMSetThreadLocalMode(GlobalVar: &Value, Mode: ThreadLocalMode);\n     pub fn LLVMIsGlobalConstant(GlobalVar: &Value) -> Bool;\n     pub fn LLVMSetGlobalConstant(GlobalVar: &Value, IsConstant: Bool);\n-    pub fn LLVMRustGetNamedValue(M: &Module, Name: *const c_char) -> Option<&Value>;\n+    pub fn LLVMRustGetNamedValue(\n+        M: &Module,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+    ) -> Option<&Value>;\n     pub fn LLVMSetTailCall(CallInst: &Value, IsTailCall: Bool);\n \n     // Operations on functions\n     pub fn LLVMRustGetOrInsertFunction(\n         M: &'a Module,\n         Name: *const c_char,\n+        NameLen: size_t,\n         FunctionTy: &'a Type,\n     ) -> &'a Value;\n     pub fn LLVMSetFunctionCallConv(Fn: &Value, CC: c_uint);\n@@ -1332,7 +1337,6 @@ extern \"C\" {\n         Args: *const &'a Value,\n         NumArgs: c_uint,\n         Bundle: Option<&OperandBundleDef<'a>>,\n-        Name: *const c_char,\n     ) -> &'a Value;\n     pub fn LLVMRustBuildMemCpy(\n         B: &Builder<'a>,\n@@ -1581,12 +1585,18 @@ extern \"C\" {\n     pub fn LLVMRustInlineAsm(\n         Ty: &Type,\n         AsmString: *const c_char,\n+        AsmStringLen: size_t,\n         Constraints: *const c_char,\n+        ConstraintsLen: size_t,\n         SideEffects: Bool,\n         AlignStack: Bool,\n         Dialect: AsmDialect,\n     ) -> &Value;\n-    pub fn LLVMRustInlineAsmVerify(Ty: &Type, Constraints: *const c_char) -> bool;\n+    pub fn LLVMRustInlineAsmVerify(\n+        Ty: &Type,\n+        Constraints: *const c_char,\n+        ConstraintsLen: size_t,\n+    ) -> bool;\n \n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n     pub fn LLVMRustVersionMajor() -> u32;"}, {"sha": "9ce23ff5f3fc855a619e4e85b992369f26d166bd", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -415,11 +415,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             AssertKind::BoundsCheck { ref len, ref index } => {\n                 let len = self.codegen_operand(&mut bx, len).immediate();\n                 let index = self.codegen_operand(&mut bx, index).immediate();\n-                (lang_items::PanicBoundsCheckFnLangItem, vec![location, index, len])\n+                // It's `fn panic_bounds_check(index: usize, len: usize)`,\n+                // and `#[track_caller]` adds an implicit third argument.\n+                (lang_items::PanicBoundsCheckFnLangItem, vec![index, len, location])\n             }\n             _ => {\n                 let msg_str = Symbol::intern(msg.description());\n                 let msg = bx.const_str(msg_str);\n+                // It's `pub fn panic(expr: &str)`, with the wide reference being passed\n+                // as two arguments, and `#[track_caller]` adds an implicit third argument.\n                 (lang_items::PanicFnLangItem, vec![msg.0, msg.1, location])\n             }\n         };"}, {"sha": "0e14e2196caf00a47d3de713f8a3ba46cd153053", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -411,6 +411,7 @@ E0735: include_str!(\"./error_codes/E0735.md\"),\n E0736: include_str!(\"./error_codes/E0736.md\"),\n E0737: include_str!(\"./error_codes/E0737.md\"),\n E0738: include_str!(\"./error_codes/E0738.md\"),\n+E0739: include_str!(\"./error_codes/E0739.md\"),\n E0740: include_str!(\"./error_codes/E0740.md\"),\n E0741: include_str!(\"./error_codes/E0741.md\"),\n E0742: include_str!(\"./error_codes/E0742.md\"),\n@@ -610,5 +611,4 @@ E0748: include_str!(\"./error_codes/E0748.md\"),\n     E0722, // Malformed `#[optimize]` attribute\n     E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n-    E0739, // invalid track_caller application/syntax\n }"}, {"sha": "707751066edbc22843e010c128d92dce874b7d0a", "filename": "src/librustc_error_codes/error_codes/E0739.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_error_codes%2Ferror_codes%2FE0739.md", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_error_codes%2Ferror_codes%2FE0739.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0739.md?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,13 @@\n+`#[track_caller]` can not be applied on struct.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0739\n+#![feature(track_caller)]\n+#[track_caller]\n+struct Bar {\n+    a: u8,\n+}\n+```\n+\n+[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md"}, {"sha": "bb661d3d2a30a3e7ff9d1b1998c2bcab7e755373", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -280,7 +280,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn assert_panic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _span: Span,\n         msg: &AssertMessage<'tcx>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {"}, {"sha": "087517ff4e31da59e0e1b9689787a3f20c9bb2ea", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -165,7 +165,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Called to evaluate `Assert` MIR terminators that trigger a panic.\n     fn assert_panic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n         msg: &mir::AssertMessage<'tcx>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;"}, {"sha": "b5c34daf8a318c503c49f8c3255146fdb99de3fd", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -95,7 +95,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n-                    M::assert_panic(self, terminator.source_info.span, msg, cleanup)?;\n+                    M::assert_panic(self, msg, cleanup)?;\n                 }\n             }\n "}, {"sha": "f9682a77173f540e5d5d24f31b91fd596ada3593", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -197,7 +197,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn assert_panic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _span: Span,\n         _msg: &rustc::mir::AssertMessage<'tcx>,\n         _unwind: Option<rustc::mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {"}, {"sha": "fe75062ee503cb63fbebcaf5228fcb154d941326", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(bindings_after_at)]\n \n use rustc_ast::ast;\n use rustc_ast::token::{self, Nonterminal};"}, {"sha": "b56dd30739dae76ee75262c76e26663779ab7362", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 98, "deletions": 133, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,4 +1,4 @@\n-use super::{Parser, PathStyle, TokenType};\n+use super::{Parser, PathStyle};\n use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::token::{self, Nonterminal};\n@@ -10,63 +10,65 @@ use rustc_span::{Span, Symbol};\n use log::debug;\n \n #[derive(Debug)]\n-enum InnerAttributeParsePolicy<'a> {\n+pub(super) enum InnerAttrPolicy<'a> {\n     Permitted,\n-    NotPermitted { reason: &'a str, saw_doc_comment: bool, prev_attr_sp: Option<Span> },\n+    Forbidden { reason: &'a str, saw_doc_comment: bool, prev_attr_sp: Option<Span> },\n }\n \n const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n                                                      permitted in this context\";\n \n+pub(super) const DEFAULT_INNER_ATTR_FORBIDDEN: InnerAttrPolicy<'_> = InnerAttrPolicy::Forbidden {\n+    reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG,\n+    saw_doc_comment: false,\n+    prev_attr_sp: None,\n+};\n+\n impl<'a> Parser<'a> {\n     /// Parses attributes that appear before an item.\n     pub(super) fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         let mut just_parsed_doc_comment = false;\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n-            match self.token.kind {\n-                token::Pound => {\n-                    let inner_error_reason = if just_parsed_doc_comment {\n-                        \"an inner attribute is not permitted following an outer doc comment\"\n-                    } else if !attrs.is_empty() {\n-                        \"an inner attribute is not permitted following an outer attribute\"\n-                    } else {\n-                        DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n-                    };\n-                    let inner_parse_policy = InnerAttributeParsePolicy::NotPermitted {\n-                        reason: inner_error_reason,\n-                        saw_doc_comment: just_parsed_doc_comment,\n-                        prev_attr_sp: attrs.last().map(|a| a.span),\n-                    };\n-                    let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n-                    attrs.push(attr);\n-                    just_parsed_doc_comment = false;\n-                }\n-                token::DocComment(s) => {\n-                    let attr = self.mk_doc_comment(s);\n-                    if attr.style != ast::AttrStyle::Outer {\n-                        let span = self.token.span;\n-                        let mut err = self.struct_span_err(span, \"expected outer doc comment\");\n-                        err.note(\n+            if self.check(&token::Pound) {\n+                let inner_error_reason = if just_parsed_doc_comment {\n+                    \"an inner attribute is not permitted following an outer doc comment\"\n+                } else if !attrs.is_empty() {\n+                    \"an inner attribute is not permitted following an outer attribute\"\n+                } else {\n+                    DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n+                };\n+                let inner_parse_policy = InnerAttrPolicy::Forbidden {\n+                    reason: inner_error_reason,\n+                    saw_doc_comment: just_parsed_doc_comment,\n+                    prev_attr_sp: attrs.last().map(|a| a.span),\n+                };\n+                let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n+                attrs.push(attr);\n+                just_parsed_doc_comment = false;\n+            } else if let token::DocComment(s) = self.token.kind {\n+                let attr = self.mk_doc_comment(s);\n+                if attr.style != ast::AttrStyle::Outer {\n+                    self.struct_span_err(self.token.span, \"expected outer doc comment\")\n+                        .note(\n                             \"inner doc comments like this (starting with \\\n-                                  `//!` or `/*!`) can only appear before items\",\n-                        );\n-                        return Err(err);\n-                    }\n-                    attrs.push(attr);\n-                    self.bump();\n-                    just_parsed_doc_comment = true;\n+                              `//!` or `/*!`) can only appear before items\",\n+                        )\n+                        .emit();\n                 }\n-                _ => break,\n+                attrs.push(attr);\n+                self.bump();\n+                just_parsed_doc_comment = true;\n+            } else {\n+                break;\n             }\n         }\n         Ok(attrs)\n     }\n \n     fn mk_doc_comment(&self, s: Symbol) -> ast::Attribute {\n-        let style = comments::doc_comment_style(&s.as_str());\n-        attr::mk_doc_comment(style, s, self.token.span)\n+        attr::mk_doc_comment(comments::doc_comment_style(&s.as_str()), s, self.token.span)\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`.\n@@ -75,96 +77,67 @@ impl<'a> Parser<'a> {\n     /// attribute.\n     pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n         debug!(\"parse_attribute: permit_inner={:?} self.token={:?}\", permit_inner, self.token);\n-        let inner_parse_policy = if permit_inner {\n-            InnerAttributeParsePolicy::Permitted\n-        } else {\n-            InnerAttributeParsePolicy::NotPermitted {\n-                reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG,\n-                saw_doc_comment: false,\n-                prev_attr_sp: None,\n-            }\n-        };\n+        let inner_parse_policy =\n+            if permit_inner { InnerAttrPolicy::Permitted } else { DEFAULT_INNER_ATTR_FORBIDDEN };\n         self.parse_attribute_with_inner_parse_policy(inner_parse_policy)\n     }\n \n-    /// The same as `parse_attribute`, except it takes in an `InnerAttributeParsePolicy`\n+    /// The same as `parse_attribute`, except it takes in an `InnerAttrPolicy`\n     /// that prescribes how to handle inner attributes.\n     fn parse_attribute_with_inner_parse_policy(\n         &mut self,\n-        inner_parse_policy: InnerAttributeParsePolicy<'_>,\n+        inner_parse_policy: InnerAttrPolicy<'_>,\n     ) -> PResult<'a, ast::Attribute> {\n         debug!(\n             \"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n             inner_parse_policy, self.token\n         );\n-        let (span, item, style) = match self.token.kind {\n-            token::Pound => {\n-                let lo = self.token.span;\n-                self.bump();\n-\n-                if let InnerAttributeParsePolicy::Permitted = inner_parse_policy {\n-                    self.expected_tokens.push(TokenType::Token(token::Not));\n-                }\n-\n-                let style = if self.token == token::Not {\n-                    self.bump();\n-                    ast::AttrStyle::Inner\n-                } else {\n-                    ast::AttrStyle::Outer\n-                };\n+        let lo = self.token.span;\n+        let (span, item, style) = if self.eat(&token::Pound) {\n+            let style =\n+                if self.eat(&token::Not) { ast::AttrStyle::Inner } else { ast::AttrStyle::Outer };\n \n-                self.expect(&token::OpenDelim(token::Bracket))?;\n-                let item = self.parse_attr_item()?;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.prev_token.span;\n-\n-                let attr_sp = lo.to(hi);\n-\n-                // Emit error if inner attribute is encountered and not permitted\n-                if style == ast::AttrStyle::Inner {\n-                    if let InnerAttributeParsePolicy::NotPermitted {\n-                        reason,\n-                        saw_doc_comment,\n-                        prev_attr_sp,\n-                    } = inner_parse_policy\n-                    {\n-                        let prev_attr_note = if saw_doc_comment {\n-                            \"previous doc comment\"\n-                        } else {\n-                            \"previous outer attribute\"\n-                        };\n-\n-                        let mut diagnostic = self.struct_span_err(attr_sp, reason);\n-\n-                        if let Some(prev_attr_sp) = prev_attr_sp {\n-                            diagnostic\n-                                .span_label(attr_sp, \"not permitted following an outer attribute\")\n-                                .span_label(prev_attr_sp, prev_attr_note);\n-                        }\n-\n-                        diagnostic\n-                            .note(\n-                                \"inner attributes, like `#![no_std]`, annotate the item \\\n-                                   enclosing them, and are usually found at the beginning of \\\n-                                   source files. Outer attributes, like `#[test]`, annotate the \\\n-                                   item following them.\",\n-                            )\n-                            .emit();\n-                    }\n-                }\n+            self.expect(&token::OpenDelim(token::Bracket))?;\n+            let item = self.parse_attr_item()?;\n+            self.expect(&token::CloseDelim(token::Bracket))?;\n+            let attr_sp = lo.to(self.prev_token.span);\n \n-                (attr_sp, item, style)\n-            }\n-            _ => {\n-                let token_str = pprust::token_to_string(&self.token);\n-                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n-                return Err(self.struct_span_err(self.token.span, msg));\n+            // Emit error if inner attribute is encountered and forbidden.\n+            if style == ast::AttrStyle::Inner {\n+                self.error_on_forbidden_inner_attr(attr_sp, inner_parse_policy);\n             }\n+\n+            (attr_sp, item, style)\n+        } else {\n+            let token_str = pprust::token_to_string(&self.token);\n+            let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+            return Err(self.struct_span_err(self.token.span, msg));\n         };\n \n         Ok(attr::mk_attr_from_item(style, item, span))\n     }\n \n+    pub(super) fn error_on_forbidden_inner_attr(&self, attr_sp: Span, policy: InnerAttrPolicy<'_>) {\n+        if let InnerAttrPolicy::Forbidden { reason, saw_doc_comment, prev_attr_sp } = policy {\n+            let prev_attr_note =\n+                if saw_doc_comment { \"previous doc comment\" } else { \"previous outer attribute\" };\n+\n+            let mut diag = self.struct_span_err(attr_sp, reason);\n+\n+            if let Some(prev_attr_sp) = prev_attr_sp {\n+                diag.span_label(attr_sp, \"not permitted following an outer attribute\")\n+                    .span_label(prev_attr_sp, prev_attr_note);\n+            }\n+\n+            diag.note(\n+                \"inner attributes, like `#![no_std]`, annotate the item enclosing them, \\\n+                and are usually found at the beginning of source files. \\\n+                Outer attributes, like `#[test]`, annotate the item following them.\",\n+            )\n+            .emit();\n+        }\n+    }\n+\n     /// Parses an inner part of an attribute (the path and following tokens).\n     /// The tokens must be either a delimited token stream, or empty token stream,\n     /// or the \"legacy\" key-value form.\n@@ -200,28 +173,22 @@ impl<'a> Parser<'a> {\n     crate fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n-            match self.token.kind {\n-                token::Pound => {\n-                    // Don't even try to parse if it's not an inner attribute.\n-                    if !self.look_ahead(1, |t| t == &token::Not) {\n-                        break;\n-                    }\n-\n-                    let attr = self.parse_attribute(true)?;\n-                    assert_eq!(attr.style, ast::AttrStyle::Inner);\n+            // Only try to parse if it is an inner attribute (has `!`).\n+            if self.check(&token::Pound) && self.look_ahead(1, |t| t == &token::Not) {\n+                let attr = self.parse_attribute(true)?;\n+                assert_eq!(attr.style, ast::AttrStyle::Inner);\n+                attrs.push(attr);\n+            } else if let token::DocComment(s) = self.token.kind {\n+                // We need to get the position of this token before we bump.\n+                let attr = self.mk_doc_comment(s);\n+                if attr.style == ast::AttrStyle::Inner {\n                     attrs.push(attr);\n+                    self.bump();\n+                } else {\n+                    break;\n                 }\n-                token::DocComment(s) => {\n-                    // We need to get the position of this token before we bump.\n-                    let attr = self.mk_doc_comment(s);\n-                    if attr.style == ast::AttrStyle::Inner {\n-                        attrs.push(attr);\n-                        self.bump();\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                _ => break,\n+            } else {\n+                break;\n             }\n         }\n         Ok(attrs)\n@@ -232,12 +199,10 @@ impl<'a> Parser<'a> {\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n-            let msg = \"suffixed literals are not allowed in attributes\";\n-            self.struct_span_err(lit.span, msg)\n+            self.struct_span_err(lit.span, \"suffixed literals are not allowed in attributes\")\n                 .help(\n-                    \"instead of using a suffixed literal \\\n-                                    (`1u8`, `1.0f32`, etc.), use an unsuffixed version \\\n-                                    (`1`, `1.0`, etc.)\",\n+                    \"instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), \\\n+                    use an unsuffixed version (`1`, `1.0`, etc.)\",\n                 )\n                 .emit();\n         }"}, {"sha": "7f6f90431fc940a3dbfec9ca3247ff22efeee51e", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 100, "deletions": 31, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -673,10 +673,28 @@ impl<'a> Parser<'a> {\n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n     fn parse_borrow_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n+        let has_lifetime = self.token.is_lifetime() && self.look_ahead(1, |t| t != &token::Colon);\n+        let lifetime = has_lifetime.then(|| self.expect_lifetime()); // For recovery, see below.\n         let (borrow_kind, mutbl) = self.parse_borrow_modifiers(lo);\n         let expr = self.parse_prefix_expr(None);\n-        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n-        Ok((lo.to(span), ExprKind::AddrOf(borrow_kind, mutbl, expr)))\n+        let (hi, expr) = self.interpolated_or_expr_span(expr)?;\n+        let span = lo.to(hi);\n+        if let Some(lt) = lifetime {\n+            self.error_remove_borrow_lifetime(span, lt.ident.span);\n+        }\n+        Ok((span, ExprKind::AddrOf(borrow_kind, mutbl, expr)))\n+    }\n+\n+    fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n+        self.struct_span_err(span, \"borrow expressions cannot be annotated with lifetimes\")\n+            .span_label(lt_span, \"annotated with lifetime here\")\n+            .span_suggestion(\n+                lt_span,\n+                \"remove the lifetime annotation\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -901,7 +919,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_lt() {\n             let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n             Ok(self.mk_expr(lo.to(path.span), ExprKind::Path(Some(qself), path), attrs))\n-        } else if self.token.is_path_start() {\n+        } else if self.check_path() {\n             self.parse_path_start_expr(attrs)\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n             self.parse_closure_expr(attrs)\n@@ -1067,26 +1085,44 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    /// Parse `'label: $expr`. The label is already parsed.\n     fn parse_labeled_expr(&mut self, label: Label, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n-        self.expect(&token::Colon)?;\n-        if self.eat_keyword(kw::While) {\n-            return self.parse_while_expr(Some(label), lo, attrs);\n-        }\n-        if self.eat_keyword(kw::For) {\n-            return self.parse_for_expr(Some(label), lo, attrs);\n-        }\n-        if self.eat_keyword(kw::Loop) {\n-            return self.parse_loop_expr(Some(label), lo, attrs);\n-        }\n-        if self.token == token::OpenDelim(token::Brace) {\n-            return self.parse_block_expr(Some(label), lo, BlockCheckMode::Default, attrs);\n+        let label = Some(label);\n+        let ate_colon = self.eat(&token::Colon);\n+        let expr = if self.eat_keyword(kw::While) {\n+            self.parse_while_expr(label, lo, attrs)\n+        } else if self.eat_keyword(kw::For) {\n+            self.parse_for_expr(label, lo, attrs)\n+        } else if self.eat_keyword(kw::Loop) {\n+            self.parse_loop_expr(label, lo, attrs)\n+        } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n+            self.parse_block_expr(label, lo, BlockCheckMode::Default, attrs)\n+        } else {\n+            let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n+            self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n+            // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n+            self.parse_expr()\n+        }?;\n+\n+        if !ate_colon {\n+            self.error_labeled_expr_must_be_followed_by_colon(lo, expr.span);\n         }\n \n-        let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-        self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n-        // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n-        self.parse_expr()\n+        Ok(expr)\n+    }\n+\n+    fn error_labeled_expr_must_be_followed_by_colon(&self, lo: Span, span: Span) {\n+        self.struct_span_err(span, \"labeled expression must be followed by `:`\")\n+            .span_label(lo, \"the label\")\n+            .span_suggestion_short(\n+                lo.shrink_to_hi(),\n+                \"add `:` after the label\",\n+                \": \".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .note(\"labels are used before loops and blocks, allowing e.g., `break 'label` to them\")\n+            .emit();\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n@@ -1363,18 +1399,20 @@ impl<'a> Parser<'a> {\n         opt_label: Option<Label>,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-        outer_attrs: AttrVec,\n+        mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n             self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n         }\n \n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        let mut attrs = outer_attrs;\n-        attrs.extend(self.parse_inner_attributes()?);\n+        if self.token.is_whole_block() {\n+            self.struct_span_err(self.token.span, \"cannot use a `block` macro fragment here\")\n+                .span_label(lo.to(self.token.span), \"the `block` fragment is within this context\")\n+                .emit();\n+        }\n \n-        let blk = self.parse_block_tail(lo, blk_mode)?;\n+        let (inner_attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n+        attrs.extend(inner_attrs);\n         Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n@@ -1476,13 +1514,16 @@ impl<'a> Parser<'a> {\n         let thn = if self.eat_keyword(kw::Else) || !cond.returns() {\n             self.error_missing_if_cond(lo, cond.span)\n         } else {\n+            let attrs = self.parse_outer_attributes()?; // For recovery.\n             let not_block = self.token != token::OpenDelim(token::Brace);\n-            self.parse_block().map_err(|mut err| {\n+            let block = self.parse_block().map_err(|mut err| {\n                 if not_block {\n                     err.span_label(lo, \"this `if` expression has a condition, but no block\");\n                 }\n                 err\n-            })?\n+            })?;\n+            self.error_on_if_block_attrs(lo, false, block.span, &attrs);\n+            block\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n@@ -1524,12 +1565,40 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.eat_keyword(kw::If) {\n-            self.parse_if_expr(AttrVec::new())\n+        let ctx_span = self.prev_token.span; // `else`\n+        let attrs = self.parse_outer_attributes()?; // For recovery.\n+        let expr = if self.eat_keyword(kw::If) {\n+            self.parse_if_expr(AttrVec::new())?\n         } else {\n             let blk = self.parse_block()?;\n-            Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()))\n-        }\n+            self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new())\n+        };\n+        self.error_on_if_block_attrs(ctx_span, true, expr.span, &attrs);\n+        Ok(expr)\n+    }\n+\n+    fn error_on_if_block_attrs(\n+        &self,\n+        ctx_span: Span,\n+        is_ctx_else: bool,\n+        branch_span: Span,\n+        attrs: &[ast::Attribute],\n+    ) {\n+        let (span, last) = match attrs {\n+            [] => return,\n+            [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n+        };\n+        let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n+        self.struct_span_err(last, \"outer attributes are not allowed on `if` and `else` branches\")\n+            .span_label(branch_span, \"the attributes are attached to this branch\")\n+            .span_label(ctx_span, format!(\"the branch belongs to this `{}`\", ctx))\n+            .span_suggestion(\n+                span,\n+                \"remove the attributes\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten)."}, {"sha": "3932bbd7564c385f374ab73cdd602a2c35780186", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -218,7 +218,7 @@ impl<'a> Parser<'a> {\n         } else if vis.node.is_pub() && self.isnt_macro_invocation() {\n             self.recover_missing_kw_before_item()?;\n             return Ok(None);\n-        } else if macros_allowed && self.token.is_path_start() {\n+        } else if macros_allowed && self.check_path() {\n             // MACRO INVOCATION ITEM\n             (Ident::invalid(), ItemKind::Mac(self.parse_item_macro(vis)?))\n         } else {\n@@ -352,8 +352,7 @@ impl<'a> Parser<'a> {\n     fn recover_attrs_no_item(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n         let (start, end) = match attrs {\n             [] => return Ok(()),\n-            [x0] => (x0, x0),\n-            [x0, .., xn] => (x0, xn),\n+            [x0 @ xn] | [x0, .., xn] => (x0, xn),\n         };\n         let msg = if end.is_doc_comment() {\n             \"expected item after doc comment\"\n@@ -1411,23 +1410,28 @@ impl<'a> Parser<'a> {\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the function is a provided one.\n     fn parse_fn_body(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, Option<P<Block>>> {\n-        let (inner_attrs, body) = match self.token.kind {\n-            token::Semi => {\n-                self.bump();\n-                (Vec::new(), None)\n-            }\n-            token::OpenDelim(token::Brace) => {\n-                let (attrs, body) = self.parse_inner_attrs_and_block()?;\n-                (attrs, Some(body))\n-            }\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtBlock(..) => {\n-                    let (attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    (attrs, Some(body))\n-                }\n-                _ => return self.expected_semi_or_open_brace(),\n-            },\n-            _ => return self.expected_semi_or_open_brace(),\n+        let (inner_attrs, body) = if self.check(&token::Semi) {\n+            self.bump(); // `;`\n+            (Vec::new(), None)\n+        } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n+            self.parse_inner_attrs_and_block().map(|(attrs, body)| (attrs, Some(body)))?\n+        } else if self.token.kind == token::Eq {\n+            // Recover `fn foo() = $expr;`.\n+            self.bump(); // `=`\n+            let eq_sp = self.prev_token.span;\n+            let _ = self.parse_expr()?;\n+            self.expect_semi()?; // `;`\n+            let span = eq_sp.to(self.prev_token.span);\n+            self.struct_span_err(span, \"function body cannot be `= expression;`\")\n+                .multipart_suggestion(\n+                    \"surround the expression with `{` and `}` instead of `=` and `;`\",\n+                    vec![(eq_sp, \"{\".to_string()), (self.prev_token.span, \" }\".to_string())],\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            (Vec::new(), Some(self.mk_block_err(span)))\n+        } else {\n+            return self.expected_semi_or_open_brace();\n         };\n         attrs.extend(inner_attrs);\n         Ok(body)"}, {"sha": "5f2b3b03488b4a4981cb7278481a52b8fc03ac03", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -704,7 +704,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.token.is_path_start() {\n+        if self.check_path() {\n             let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path"}, {"sha": "489549a57505fa43ce88fee18fc105c6cd2a0a87", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,3 +1,4 @@\n+use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n use super::diagnostics::Error;\n use super::expr::LhsExpr;\n use super::pat::GateOr;\n@@ -47,10 +48,7 @@ impl<'a> Parser<'a> {\n             self.bump(); // `var`\n             let msg = \"write `let` instead of `var` to introduce a new variable\";\n             self.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n-        } else if self.token.is_path_start()\n-            && !self.token.is_qpath_start()\n-            && !self.is_path_start_item()\n-        {\n+        } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n@@ -238,15 +236,11 @@ impl<'a> Parser<'a> {\n \n     /// Parses a block. No inner attributes are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n-        maybe_whole!(self, NtBlock, |x| x);\n-\n-        let lo = self.token.span;\n-\n-        if !self.eat(&token::OpenDelim(token::Brace)) {\n-            return self.error_block_no_opening_brace();\n+        let (attrs, block) = self.parse_inner_attrs_and_block()?;\n+        if let [.., last] = &*attrs {\n+            self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);\n         }\n-\n-        self.parse_block_tail(lo, BlockCheckMode::Default)\n+        Ok(block)\n     }\n \n     fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n@@ -262,16 +256,14 @@ impl<'a> Parser<'a> {\n         //\n         // which is valid in other languages, but not Rust.\n         match self.parse_stmt_without_recovery() {\n-            Ok(Some(stmt)) => {\n+            // If the next token is an open brace (e.g., `if a b {`), the place-\n+            // inside-a-block suggestion would be more likely wrong than right.\n+            Ok(Some(_))\n                 if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n-                    || do_not_suggest_help\n-                {\n-                    // If the next token is an open brace (e.g., `if a b {`), the place-\n-                    // inside-a-block suggestion would be more likely wrong than right.\n-                    e.span_label(sp, \"expected `{`\");\n-                    return Err(e);\n-                }\n-                let stmt_span = if self.eat(&token::Semi) {\n+                    || do_not_suggest_help => {}\n+            Ok(Some(stmt)) => {\n+                let stmt_own_line = self.sess.source_map().is_line_before_span_empty(sp);\n+                let stmt_span = if stmt_own_line && self.eat(&token::Semi) {\n                     // Expand the span to include the semicolon.\n                     stmt.span.with_hi(self.prev_token.span.hi())\n                 } else {\n@@ -300,21 +292,28 @@ impl<'a> Parser<'a> {\n     /// Parses a block. Inner attributes are allowed.\n     pub(super) fn parse_inner_attrs_and_block(\n         &mut self,\n+    ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n+        self.parse_block_common(self.token.span, BlockCheckMode::Default)\n+    }\n+\n+    /// Parses a block. Inner attributes are allowed.\n+    pub(super) fn parse_block_common(\n+        &mut self,\n+        lo: Span,\n+        blk_mode: BlockCheckMode,\n     ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n-        let lo = self.token.span;\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-        Ok((self.parse_inner_attributes()?, self.parse_block_tail(lo, BlockCheckMode::Default)?))\n+        if !self.eat(&token::OpenDelim(token::Brace)) {\n+            return self.error_block_no_opening_brace();\n+        }\n+\n+        Ok((self.parse_inner_attributes()?, self.parse_block_tail(lo, blk_mode)?))\n     }\n \n     /// Parses the rest of a block expression or function body.\n     /// Precondition: already parsed the '{'.\n-    pub(super) fn parse_block_tail(\n-        &mut self,\n-        lo: Span,\n-        s: BlockCheckMode,\n-    ) -> PResult<'a, P<Block>> {\n+    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             if self.token == token::Eof {"}, {"sha": "3dd415bf37289bd2683845e7f47dc4d3eee46ad4", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -142,24 +142,20 @@ impl<'a> Parser<'a> {\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n                 let parse_plus = allow_plus == AllowPlus::Yes && self.check_plus();\n-                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n+                self.parse_remaining_bounds_path(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(kw::Impl) {\n             self.parse_impl_ty(&mut impl_dyn_multi)?\n         } else if self.is_explicit_dyn_type() {\n             self.parse_dyn_ty(&mut impl_dyn_multi)?\n-        } else if self.check(&token::Question)\n-            || self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus())\n-        {\n-            // Bound list (trait object type)\n-            let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n-            TyKind::TraitObject(bounds, TraitObjectSyntax::None)\n         } else if self.eat_lt() {\n             // Qualified path\n             let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n-        } else if self.token.is_path_start() {\n+        } else if self.check_path() {\n             self.parse_path_start_ty(lo, allow_plus)?\n+        } else if self.can_begin_bound() {\n+            self.parse_bare_trait_object(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n             if allow_c_variadic == AllowCVariadic::Yes {\n                 TyKind::CVarArgs\n@@ -203,21 +199,12 @@ impl<'a> Parser<'a> {\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                 TyKind::Path(None, path) if maybe_bounds => {\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                    self.parse_remaining_bounds_path(Vec::new(), path, lo, true)\n                 }\n-                TyKind::TraitObject(mut bounds, TraitObjectSyntax::None)\n+                TyKind::TraitObject(bounds, TraitObjectSyntax::None)\n                     if maybe_bounds && bounds.len() == 1 && !trailing_plus =>\n                 {\n-                    let path = match bounds.remove(0) {\n-                        GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n-                        GenericBound::Outlives(..) => {\n-                            return Err(self.struct_span_err(\n-                                ty.span,\n-                                \"expected trait bound, not lifetime bound\",\n-                            ));\n-                        }\n-                    };\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                    self.parse_remaining_bounds(bounds, true)\n                 }\n                 // `(TYPE)`\n                 _ => Ok(TyKind::Paren(P(ty))),\n@@ -227,18 +214,35 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_remaining_bounds(\n+    fn parse_bare_trait_object(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n+        let lt_no_plus = self.check_lifetime() && !self.look_ahead(1, |t| t.is_like_plus());\n+        let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n+        if lt_no_plus {\n+            self.struct_span_err(lo, \"lifetime in trait object type must be followed by `+`\").emit()\n+        }\n+        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n+    }\n+\n+    fn parse_remaining_bounds_path(\n         &mut self,\n         generic_params: Vec<GenericParam>,\n         path: ast::Path,\n         lo: Span,\n         parse_plus: bool,\n     ) -> PResult<'a, TyKind> {\n-        assert_ne!(self.token, token::Question);\n-\n         let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_token.span));\n-        let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n-        if parse_plus {\n+        let bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n+        self.parse_remaining_bounds(bounds, parse_plus)\n+    }\n+\n+    /// Parse the remainder of a bare trait object type given an already parsed list.\n+    fn parse_remaining_bounds(\n+        &mut self,\n+        mut bounds: GenericBounds,\n+        plus: bool,\n+    ) -> PResult<'a, TyKind> {\n+        assert_ne!(self.token, token::Question);\n+        if plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n             bounds.append(&mut self.parse_generic_bounds(Some(self.prev_token.span))?);\n         }\n@@ -358,7 +362,7 @@ impl<'a> Parser<'a> {\n             }))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n-            self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+            self.parse_remaining_bounds_path(Vec::new(), path, lo, true)\n         } else {\n             // Just a type path.\n             Ok(TyKind::Path(None, path))"}, {"sha": "8cda95783a8a9544f5d152b5fb23dd58936ce5c6", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -49,6 +49,18 @@ pub struct OptimizationFuel {\n     out_of_fuel: bool,\n }\n \n+/// The behavior of the CTFE engine when an error occurs with regards to backtraces.\n+#[derive(Clone, Copy)]\n+pub enum CtfeBacktrace {\n+    /// Do nothing special, return the error as usual without a backtrace.\n+    Disabled,\n+    /// Capture a backtrace at the point the error is created and return it in the error\n+    /// (to be printed later if/when the error ever actually gets shown to the user).\n+    Capture,\n+    /// Capture a backtrace at the point the error is created and immediately print it out.\n+    Immediate,\n+}\n+\n /// Represents the data associated with a compilation\n /// session for a single crate.\n pub struct Session {\n@@ -139,6 +151,11 @@ pub struct Session {\n     /// Path for libraries that will take preference over libraries shipped by Rust.\n     /// Used by windows-gnu targets to priortize system mingw-w64 libraries.\n     pub system_library_path: OneThread<RefCell<Option<Option<PathBuf>>>>,\n+\n+    /// Tracks the current behavior of the CTFE engine when an error occurs.\n+    /// Options range from returning the error without a backtrace to returning an error\n+    /// and immediately printing the backtrace to stderr.\n+    pub ctfe_backtrace: Lock<CtfeBacktrace>,\n }\n \n pub struct PerfStats {\n@@ -1040,6 +1057,12 @@ fn build_session_(\n         sopts.debugging_opts.time_passes,\n     );\n \n+    let ctfe_backtrace = Lock::new(match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n+        Ok(ref val) if val == \"immediate\" => CtfeBacktrace::Immediate,\n+        Ok(ref val) if val != \"0\" => CtfeBacktrace::Capture,\n+        _ => CtfeBacktrace::Disabled,\n+    });\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1078,6 +1101,7 @@ fn build_session_(\n         trait_methods_not_found: Lock::new(Default::default()),\n         confused_type_with_std_module: Lock::new(Default::default()),\n         system_library_path: OneThread::new(RefCell::new(Default::default())),\n+        ctfe_backtrace,\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "353f7b3f52bc3d10fa22f1e17c8141bd115ee312", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -517,6 +517,13 @@ impl SourceMap {\n         Ok((lo, hi))\n     }\n \n+    pub fn is_line_before_span_empty(&self, sp: Span) -> bool {\n+        match self.span_to_prev_source(sp) {\n+            Ok(s) => s.split('\\n').last().map(|l| l.trim_start().is_empty()).unwrap_or(false),\n+            Err(_) => false,\n+        }\n+    }\n+\n     pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n         debug!(\"span_to_lines(sp={:?})\", sp);\n         let (lo, hi) = self.is_valid_span(sp)?;"}, {"sha": "58c8a7d82bfb5ff8d9e5f55329ce5a200728b8f9", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,4 +1,5 @@\n use std::collections::BTreeMap;\n+use std::convert::TryFrom;\n use std::ffi::OsStr;\n use std::fmt;\n use std::path::PathBuf;\n@@ -24,6 +25,33 @@ use crate::opts;\n use crate::passes::{self, Condition, DefaultPassOption};\n use crate::theme;\n \n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum OutputFormat {\n+    Json,\n+    Html,\n+}\n+\n+impl OutputFormat {\n+    pub fn is_json(&self) -> bool {\n+        match self {\n+            OutputFormat::Json => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl TryFrom<&str> for OutputFormat {\n+    type Error = String;\n+\n+    fn try_from(value: &str) -> Result<Self, Self::Error> {\n+        match value {\n+            \"json\" => Ok(OutputFormat::Json),\n+            \"html\" => Ok(OutputFormat::Html),\n+            _ => Err(format!(\"unknown output format `{}`\", value)),\n+        }\n+    }\n+}\n+\n /// Configuration options for rustdoc.\n #[derive(Clone)]\n pub struct Options {\n@@ -115,6 +143,8 @@ pub struct Options {\n     pub crate_version: Option<String>,\n     /// Collected options specific to outputting final pages.\n     pub render_options: RenderOptions,\n+    /// Output format rendering (used only for \"show-coverage\" option for the moment)\n+    pub output_format: Option<OutputFormat>,\n }\n \n impl fmt::Debug for Options {\n@@ -425,14 +455,6 @@ impl Options {\n             }\n         }\n \n-        match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n-            Some(\"html\") | None => {}\n-            Some(s) => {\n-                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n-                return Err(1);\n-            }\n-        }\n-\n         let index_page = matches.opt_str(\"index-page\").map(|s| PathBuf::from(&s));\n         if let Some(ref index_page) = index_page {\n             if !index_page.is_file() {\n@@ -469,6 +491,29 @@ impl Options {\n             }\n         };\n \n+        let output_format = match matches.opt_str(\"output-format\") {\n+            Some(s) => match OutputFormat::try_from(s.as_str()) {\n+                Ok(o) => {\n+                    if o.is_json() && !show_coverage {\n+                        diag.struct_err(\"json output format isn't supported for doc generation\")\n+                            .emit();\n+                        return Err(1);\n+                    } else if !o.is_json() && show_coverage {\n+                        diag.struct_err(\n+                            \"html output format isn't supported for the --show-coverage option\",\n+                        )\n+                        .emit();\n+                        return Err(1);\n+                    }\n+                    Some(o)\n+                }\n+                Err(e) => {\n+                    diag.struct_err(&e).emit();\n+                    return Err(1);\n+                }\n+            },\n+            None => None,\n+        };\n         let crate_name = matches.opt_str(\"crate-name\");\n         let proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n         let playground_url = matches.opt_str(\"playground-url\");\n@@ -553,6 +598,7 @@ impl Options {\n                 generate_search_filter,\n                 generate_redirect_pages,\n             },\n+            output_format,\n         })\n     }\n \n@@ -568,6 +614,9 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &rustc_errors::Han\n \n     for flag in deprecated_flags.iter() {\n         if matches.opt_present(flag) {\n+            if *flag == \"output-format\" && matches.opt_present(\"show-coverage\") {\n+                continue;\n+            }\n             let mut err =\n                 diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\", flag));\n             err.warn("}, {"sha": "b9ae3d53afc042b3b7d5750680f1b860e1ba19fa", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -228,6 +228,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         mut manual_passes,\n         display_warnings,\n         render_options,\n+        output_format,\n         ..\n     } = options;\n \n@@ -385,6 +386,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n                 let mut renderinfo = RenderInfo::default();\n                 renderinfo.access_levels = access_levels;\n+                renderinfo.output_format = output_format;\n \n                 let mut ctxt = DocContext {\n                     tcx,"}, {"sha": "2d1e3c29055cf96ba00cf38dedb59e8be1515b52", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -60,7 +60,7 @@ use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy};\n-use crate::config::RenderOptions;\n+use crate::config::{OutputFormat, RenderOptions};\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::html::escape::Escape;\n@@ -270,6 +270,7 @@ pub struct RenderInfo {\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n     pub owned_box_did: Option<DefId>,\n+    pub output_format: Option<OutputFormat>,\n }\n \n // Helper structs for rendering items/sidebars and carrying along contextual"}, {"sha": "4198369eca8f55eed32237f160aa70de389bee7e", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -139,6 +139,7 @@ impl Cache {\n             deref_trait_did,\n             deref_mut_trait_did,\n             owned_box_did,\n+            ..\n         } = renderinfo;\n \n         let external_paths ="}, {"sha": "f48224512ba4f9b54b45edc88f684dad9afe8aef", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,11 +1,14 @@\n use crate::clean;\n+use crate::config::OutputFormat;\n use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n \n use rustc_ast::attr;\n use rustc_span::symbol::sym;\n use rustc_span::FileName;\n+use serde::Serialize;\n+use serde_json;\n \n use std::collections::BTreeMap;\n use std::ops;\n@@ -16,16 +19,16 @@ pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     description: \"counts the number of items with and without documentation\",\n };\n \n-fn calculate_doc_coverage(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n-    let mut calc = CoverageCalculator::default();\n+fn calculate_doc_coverage(krate: clean::Crate, ctx: &DocContext<'_>) -> clean::Crate {\n+    let mut calc = CoverageCalculator::new();\n     let krate = calc.fold_crate(krate);\n \n-    calc.print_results();\n+    calc.print_results(ctx.renderinfo.borrow().output_format);\n \n     krate\n }\n \n-#[derive(Default, Copy, Clone)]\n+#[derive(Default, Copy, Clone, Serialize)]\n struct ItemCount {\n     total: u64,\n     with_docs: u64,\n@@ -64,13 +67,41 @@ impl ops::AddAssign for ItemCount {\n     }\n }\n \n-#[derive(Default)]\n struct CoverageCalculator {\n     items: BTreeMap<FileName, ItemCount>,\n }\n \n+fn limit_filename_len(filename: String) -> String {\n+    let nb_chars = filename.chars().count();\n+    if nb_chars > 35 {\n+        \"...\".to_string()\n+            + &filename[filename.char_indices().nth(nb_chars - 32).map(|x| x.0).unwrap_or(0)..]\n+    } else {\n+        filename\n+    }\n+}\n+\n impl CoverageCalculator {\n-    fn print_results(&self) {\n+    fn new() -> CoverageCalculator {\n+        CoverageCalculator { items: Default::default() }\n+    }\n+\n+    fn to_json(&self) -> String {\n+        serde_json::to_string(\n+            &self\n+                .items\n+                .iter()\n+                .map(|(k, v)| (k.to_string(), v))\n+                .collect::<BTreeMap<String, &ItemCount>>(),\n+        )\n+        .expect(\"failed to convert JSON data to string\")\n+    }\n+\n+    fn print_results(&self, output_format: Option<OutputFormat>) {\n+        if output_format.map(|o| o.is_json()).unwrap_or_else(|| false) {\n+            println!(\"{}\", self.to_json());\n+            return;\n+        }\n         let mut total = ItemCount::default();\n \n         fn print_table_line() {\n@@ -93,15 +124,7 @@ impl CoverageCalculator {\n \n         for (file, &count) in &self.items {\n             if let Some(percentage) = count.percentage() {\n-                let mut name = file.to_string();\n-                // if a filename is too long, shorten it so we don't blow out the table\n-                // FIXME(misdreavus): this needs to count graphemes, and probably also track\n-                // double-wide characters...\n-                if name.len() > 35 {\n-                    name = \"...\".to_string() + &name[name.len() - 32..];\n-                }\n-\n-                print_table_record(&name, count, percentage);\n+                print_table_record(&limit_filename_len(file.to_string()), count, percentage);\n \n                 total += count;\n             }"}, {"sha": "25cfee3373dc4e5197d99006ed7f199817c4f595", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -112,20 +112,22 @@ extern \"C\" void LLVMRustPrintPassTimings() {\n   TimerGroup::printAll(OS);\n }\n \n-extern \"C\" LLVMValueRef LLVMRustGetNamedValue(LLVMModuleRef M,\n-                                              const char *Name) {\n-  return wrap(unwrap(M)->getNamedValue(Name));\n+extern \"C\" LLVMValueRef LLVMRustGetNamedValue(LLVMModuleRef M, const char *Name,\n+                                              size_t NameLen) {\n+  return wrap(unwrap(M)->getNamedValue(StringRef(Name, NameLen)));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n                                                     const char *Name,\n+                                                    size_t NameLen,\n                                                     LLVMTypeRef FunctionTy) {\n-  return wrap(\n-      unwrap(M)->getOrInsertFunction(Name, unwrap<FunctionType>(FunctionTy))\n+  return wrap(unwrap(M)\n+                  ->getOrInsertFunction(StringRef(Name, NameLen),\n+                                        unwrap<FunctionType>(FunctionTy))\n #if LLVM_VERSION_GE(9, 0)\n-      .getCallee()\n+                  .getCallee()\n #endif\n-      );\n+  );\n }\n \n extern \"C\" LLVMValueRef\n@@ -395,22 +397,26 @@ static InlineAsm::AsmDialect fromRust(LLVMRustAsmDialect Dialect) {\n   }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString,\n-                                          char *Constraints,\n-                                          LLVMBool HasSideEffects,\n-                                          LLVMBool IsAlignStack,\n-                                          LLVMRustAsmDialect Dialect) {\n-  return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString, Constraints,\n+extern \"C\" LLVMValueRef\n+LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString, size_t AsmStringLen,\n+                  char *Constraints, size_t ConstraintsLen,\n+                  LLVMBool HasSideEffects, LLVMBool IsAlignStack,\n+                  LLVMRustAsmDialect Dialect) {\n+  return wrap(InlineAsm::get(unwrap<FunctionType>(Ty),\n+                             StringRef(AsmString, AsmStringLen),\n+                             StringRef(Constraints, ConstraintsLen),\n                              HasSideEffects, IsAlignStack, fromRust(Dialect)));\n }\n \n-extern \"C\" bool LLVMRustInlineAsmVerify(LLVMTypeRef Ty,\n-                                          char *Constraints) {\n-  return InlineAsm::Verify(unwrap<FunctionType>(Ty), Constraints);\n+extern \"C\" bool LLVMRustInlineAsmVerify(LLVMTypeRef Ty, char *Constraints,\n+                                        size_t ConstraintsLen) {\n+  return InlineAsm::Verify(unwrap<FunctionType>(Ty),\n+                           StringRef(Constraints, ConstraintsLen));\n }\n \n-extern \"C\" void LLVMRustAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm) {\n-  unwrap(M)->appendModuleInlineAsm(StringRef(Asm));\n+extern \"C\" void LLVMRustAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm,\n+                                              size_t AsmLen) {\n+  unwrap(M)->appendModuleInlineAsm(StringRef(Asm, AsmLen));\n }\n \n typedef DIBuilder *LLVMRustDIBuilderRef;\n@@ -1282,12 +1288,11 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n \n extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n-                                          OperandBundleDef *Bundle,\n-                                          const char *Name) {\n+                                          OperandBundleDef *Bundle) {\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n-      unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles, Name));\n+      unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,"}, {"sha": "181cb4c5061a7fc2db405b7d88abd99abf22bcbd", "filename": "src/test/rustdoc-ui/coverage/html.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fhtml.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags:-Z unstable-options --output-format html --show-coverage\n+\n+/// Foo\n+pub struct Xo;"}, {"sha": "adca375d4bce59e41eb070d91634b618f3080966", "filename": "src/test/rustdoc-ui/coverage/html.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fhtml.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fhtml.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fhtml.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,2 @@\n+error: html output format isn't supported for the --show-coverage option\n+"}, {"sha": "b1220b32e9194a2a6408bd117976d72b9abd9a19", "filename": "src/test/rustdoc-ui/coverage/json.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,27 @@\n+// build-pass\n+// compile-flags:-Z unstable-options --output-format json --show-coverage\n+\n+pub mod foo {\n+    /// Hello!\n+    pub struct Foo;\n+    /// Bar\n+    pub enum Bar { A }\n+}\n+\n+/// X\n+pub struct X;\n+\n+/// Bar\n+pub mod bar {\n+    /// bar\n+    pub struct Bar;\n+    /// X\n+    pub enum X { Y }\n+}\n+\n+/// yolo\n+pub enum Yolo { X }\n+\n+pub struct Xo<T: Clone> {\n+    x: T,\n+}"}, {"sha": "63b22a7d94b00f5073577418ceb03fe85b51a8b6", "filename": "src/test/rustdoc-ui/coverage/json.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.stdout?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1 @@\n+{\"$DIR/json.rs\":{\"total\":13,\"with_docs\":7}}"}, {"sha": "76e87a3749c33a5b8f2849c41707741b14b78dc6", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -32,11 +32,11 @@ LL |     X() {}\n LL | }\n    | - the item list ends here\n \n-error: expected `[`, found `#`\n+error: expected one of `!` or `[`, found `#`\n   --> $DIR/issue-40006.rs:19:17\n    |\n LL |     fn xxx() { ### }\n-   |                 ^ expected `[`\n+   |                 ^ expected one of `!` or `[`\n \n error: expected one of `!` or `::`, found `=`\n   --> $DIR/issue-40006.rs:22:7"}, {"sha": "6eb25a92f34133587558e8196be83835d03d9a88", "filename": "src/test/ui/generic-associated-types/empty_generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -3,7 +3,7 @@\n \n trait Foo {\n     type Bar<,>;\n-    //~^ ERROR expected one of `>`, `const`, identifier, or lifetime, found `,`\n+    //~^ ERROR expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n }\n \n fn main() {}"}, {"sha": "1599d683ad6dd7dc078b9e9b01d0c80a446cd9c8", "filename": "src/test/ui/generic-associated-types/empty_generics.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fempty_generics.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,10 +1,10 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/empty_generics.rs:5:14\n    |\n LL | trait Foo {\n    |           - while parsing this item list starting here\n LL |     type Bar<,>;\n-   |              ^ expected one of `>`, `const`, identifier, or lifetime\n+   |              ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n LL |\n LL | }\n    | - the item list ends here"}, {"sha": "85da7cf6bb8c3d453cc2558e11aac91b1f6e58b9", "filename": "src/test/ui/if-attrs/else-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -8,7 +8,7 @@ fn if_else_parse_error() {\n #[cfg(FALSE)]\n fn else_attr_ifparse_error() {\n     if true {\n-    } else #[attr] if false { //~ ERROR expected\n+    } else #[attr] if false { //~ ERROR outer attributes are not allowed\n     } else {\n     }\n }"}, {"sha": "2733377054d7d93df1d1cc38e7ff4ed361a5963a", "filename": "src/test/ui/if-attrs/else-attrs.stderr", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -4,18 +4,17 @@ error: expected expression, found keyword `else`\n LL |     } #[attr] else if false {\n    |               ^^^^ expected expression\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/else-attrs.rs:11:12\n    |\n-LL |     } else #[attr] if false {\n-   |            ^ expected `{`\n-   |\n-help: try placing this code inside a block\n-   |\n-LL |     } else #[attr] { if false {\n-LL |     } else {\n-LL |     } }\n-   |\n+LL |       } else #[attr] if false {\n+   |  _______----_^^^^^^^_-\n+   | |       |    |\n+   | |       |    help: remove the attributes\n+   | |       the branch belongs to this `else`\n+LL | |     } else {\n+LL | |     }\n+   | |_____- the attributes are attached to this branch\n \n error: expected expression, found keyword `else`\n   --> $DIR/else-attrs.rs:20:15"}, {"sha": "3ceb58d1252d315c67e63d44b318aace5d719b31", "filename": "src/test/ui/issues/issue-20616-8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -29,7 +29,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n \n \n type Type_8<'a,,> = &'a ();\n-//~^ error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+//~^ error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n \n \n //type Type_9<T,,> = Box<T>; // error: expected identifier, found `,`"}, {"sha": "e9f37e50fffec7e02ce674346c82b42f5f932c45", "filename": "src/test/ui/issues/issue-20616-8.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-8.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/issue-20616-8.rs:31:16\n    |\n LL | type Type_8<'a,,> = &'a ();\n-   |                ^ expected one of `>`, `const`, identifier, or lifetime\n+   |                ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n \n error: aborting due to previous error\n "}, {"sha": "7f84284481e2f02e07fc82788163d6e01bf1d98d", "filename": "src/test/ui/issues/issue-20616-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -32,4 +32,4 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n \n \n type Type_9<T,,> = Box<T>;\n-//~^ error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+//~^ error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`"}, {"sha": "dc309d1bce1586c12e35eb3fae926ca6a246edf8", "filename": "src/test/ui/issues/issue-20616-9.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20616-9.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/issue-20616-9.rs:34:15\n    |\n LL | type Type_9<T,,> = Box<T>;\n-   |               ^ expected one of `>`, `const`, identifier, or lifetime\n+   |               ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n \n error: aborting due to previous error\n "}, {"sha": "9db4521bb423926b5dba771279e0e245581d51be", "filename": "src/test/ui/issues/issue-66473.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-66473.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-66473.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66473.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be"}, {"sha": "b370b125cfefda4f82cbb4866fec528b1465a2ef", "filename": "src/test/ui/issues/issue-66473.stderr", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-66473.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fissues%2Fissue-66473.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66473.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be"}, {"sha": "a2c75882be0ca3d76d19efb4f9edfb46a5ad08ba", "filename": "src/test/ui/label/label_break_value_illegal_uses.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -2,7 +2,10 @@ error: expected `{`, found `'b`\n   --> $DIR/label_break_value_illegal_uses.rs:6:12\n    |\n LL |     unsafe 'b: {}\n-   |            ^^ expected `{`\n+   |            ^^----\n+   |            |\n+   |            expected `{`\n+   |            help: try placing this code inside a block: `{ 'b: {} }`\n \n error: expected `{`, found `'b`\n   --> $DIR/label_break_value_illegal_uses.rs:10:13"}, {"sha": "09f494bdc2fed2b6a8cf2d25ea4eea15652de015", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -39,35 +39,35 @@ fn main() {}\n #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n //~^ ERROR expected one of\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n //~^ ERROR expected one of\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n-//~^ ERROR expected `{`, found `#`\n+//~^ ERROR outer attributes are not allowed on `if`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n "}, {"sha": "6dfe7aad6ea64b3412b04c781e26fcd907c0744c", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -136,14 +136,14 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:41:37\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n-   |                                --   ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                --   ^^^^^^^ -- the attributes are attached to this branch\n    |                                |    |\n-   |                                |    expected `{`\n-   |                                this `if` expression has a condition, but no block\n+   |                                |    help: remove the attributes\n+   |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:43:38\n@@ -159,13 +159,14 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n    |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n-   |                                             ^       --- help: try placing this code inside a block: `{ {}; }`\n-   |                                             |\n-   |                                             expected `{`\n+   |                                        ---- ^^^^^^^ -- the attributes are attached to this branch\n+   |                                        |    |\n+   |                                        |    help: remove the attributes\n+   |                                        the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:49:46\n@@ -175,22 +176,23 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n-   |                                             ^       -------- help: try placing this code inside a block: `{ if 0 {}; }`\n-   |                                             |\n-   |                                             expected `{`\n+   |                                        ---- ^^^^^^^ ------- the attributes are attached to this branch\n+   |                                        |    |\n+   |                                        |    help: remove the attributes\n+   |                                        the branch belongs to this `else`\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:53:50\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n-   |                                             --   ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                             --   ^^^^^^^ -- the attributes are attached to this branch\n    |                                             |    |\n-   |                                             |    expected `{`\n-   |                                             this `if` expression has a condition, but no block\n+   |                                             |    help: remove the attributes\n+   |                                             the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:55:51\n@@ -200,14 +202,14 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:57:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n-   |                                --           ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                --           ^^^^^^^ -- the attributes are attached to this branch\n    |                                |            |\n-   |                                |            expected `{`\n-   |                                this `if` expression has a condition, but no block\n+   |                                |            help: remove the attributes\n+   |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:59:46\n@@ -223,13 +225,14 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n    |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:63:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n-   |                                                     ^       --- help: try placing this code inside a block: `{ {}; }`\n-   |                                                     |\n-   |                                                     expected `{`\n+   |                                                ---- ^^^^^^^ -- the attributes are attached to this branch\n+   |                                                |    |\n+   |                                                |    help: remove the attributes\n+   |                                                the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:65:54\n@@ -239,22 +242,23 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:67:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n-   |                                                     ^       ---------------- help: try placing this code inside a block: `{ if let _ = 0 {}; }`\n-   |                                                     |\n-   |                                                     expected `{`\n+   |                                                ---- ^^^^^^^ --------------- the attributes are attached to this branch\n+   |                                                |    |\n+   |                                                |    help: remove the attributes\n+   |                                                the branch belongs to this `else`\n \n-error: expected `{`, found `#`\n+error: outer attributes are not allowed on `if` and `else` branches\n   --> $DIR/attr-stmt-expr-attr-bad.rs:69:66\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n-   |                                                     --           ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                                     --           ^^^^^^^ -- the attributes are attached to this branch\n    |                                                     |            |\n-   |                                                     |            expected `{`\n-   |                                                     this `if` expression has a condition, but no block\n+   |                                                     |            help: remove the attributes\n+   |                                                     the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:71:67"}, {"sha": "38d53a14bc0bc7e52419e6eb29e067ae3abacbdc", "filename": "src/test/ui/parser/bad-interpolated-block.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,15 @@\n+#![feature(label_break_value)]\n+\n+fn main() {}\n+\n+macro_rules! m {\n+    ($b:block) => {\n+        'lab: $b; //~ ERROR cannot use a `block` macro fragment here\n+        unsafe $b; //~ ERROR cannot use a `block` macro fragment here\n+        |x: u8| -> () $b; //~ ERROR cannot use a `block` macro fragment here\n+    }\n+}\n+\n+fn foo() {\n+    m!({});\n+}"}, {"sha": "2cbb6a13e74b9b192b790b05fe8bfc07d9e470da", "filename": "src/test/ui/parser/bad-interpolated-block.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-interpolated-block.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,39 @@\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/bad-interpolated-block.rs:7:15\n+   |\n+LL |         'lab: $b;\n+   |         ------^^\n+   |         |\n+   |         the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/bad-interpolated-block.rs:8:16\n+   |\n+LL |         unsafe $b;\n+   |         -------^^\n+   |         |\n+   |         the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/bad-interpolated-block.rs:9:23\n+   |\n+LL |         |x: u8| -> () $b;\n+   |                       ^^ the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "e4bb39f6836b48c9ca7570acb29509f820fa379c", "filename": "src/test/ui/parser/block-no-opening-brace.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,31 @@\n+// edition:2018\n+\n+#![feature(try_blocks)]\n+\n+fn main() {}\n+\n+fn f1() {\n+    loop\n+        let x = 0; //~ ERROR expected `{`, found keyword `let`\n+        drop(0);\n+    }\n+\n+fn f2() {\n+    while true\n+        let x = 0; //~ ERROR expected `{`, found keyword `let`\n+    }\n+\n+fn f3() {\n+    for x in 0..1\n+        let x = 0; //~ ERROR expected `{`, found keyword `let`\n+    }\n+\n+fn f4() {\n+    try //~ ERROR expected expression, found reserved keyword `try`\n+        let x = 0;\n+    }\n+\n+fn f5() {\n+    async //~ ERROR async closures are unstable\n+        let x = 0; //~ ERROR expected one of `move`, `|`, or `||`, found keyword `let`\n+    }"}, {"sha": "a88e4ac44cfda5f75bf1d25f7f2ac2d7156abf3a", "filename": "src/test/ui/parser/block-no-opening-brace.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,53 @@\n+error: expected `{`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:9:9\n+   |\n+LL |         let x = 0;\n+   |         ^^^-------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ let x = 0; }`\n+\n+error: expected `{`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:15:9\n+   |\n+LL |         let x = 0;\n+   |         ^^^-------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ let x = 0; }`\n+\n+error: expected `{`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:20:9\n+   |\n+LL |         let x = 0;\n+   |         ^^^-------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ let x = 0; }`\n+\n+error: expected expression, found reserved keyword `try`\n+  --> $DIR/block-no-opening-brace.rs:24:5\n+   |\n+LL |     try\n+   |     ^^^ expected expression\n+\n+error: expected one of `move`, `|`, or `||`, found keyword `let`\n+  --> $DIR/block-no-opening-brace.rs:30:9\n+   |\n+LL |     async\n+   |          - expected one of `move`, `|`, or `||`\n+LL |         let x = 0;\n+   |         ^^^ unexpected token\n+\n+error[E0658]: async closures are unstable\n+  --> $DIR/block-no-opening-brace.rs:29:5\n+   |\n+LL |     async\n+   |     ^^^^^\n+   |\n+   = note: see issue #62290 <https://github.com/rust-lang/rust/issues/62290> for more information\n+   = help: add `#![feature(async_closure)]` to the crate attributes to enable\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c9251ac5321851c786cc06862790481505887481", "filename": "src/test/ui/parser/bounds-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -6,6 +6,6 @@ type A = for<'a: 'b + 'c> fn(); // OK (rejected later by ast_validation)\n type A = for<'a: 'b,> fn(); // OK(rejected later by ast_validation)\n type A = for<'a: 'b +> fn(); // OK (rejected later by ast_validation)\n type A = for<'a, T> fn(); // OK (rejected later by ast_validation)\n-type A = for<,> fn(); //~ ERROR expected one of `>`, `const`, identifier, or lifetime, found `,`\n+type A = for<,> fn(); //~ ERROR expected one of `#`, `>`, `const`, identifier, or lifetime\n \n fn main() {}"}, {"sha": "e47a21d892b2f745a68e92e7bb3982409d9a1d6f", "filename": "src/test/ui/parser/bounds-lifetime.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-lifetime.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `>`, `const`, identifier, or lifetime, found `,`\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `,`\n   --> $DIR/bounds-lifetime.rs:9:14\n    |\n LL | type A = for<,> fn();\n-   |              ^ expected one of `>`, `const`, identifier, or lifetime\n+   |              ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n \n error: aborting due to previous error\n "}, {"sha": "c6a08abeff4ba76d1094bddf8618a08c9f2e091d", "filename": "src/test/ui/parser/closure-return-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -3,5 +3,5 @@\n \n fn main() {\n     let x = || -> i32 22;\n-    //~^ ERROR expected one of `!`, `(`, `+`, `::`, `<`, or `{`, found `22`\n+    //~^ ERROR expected `{`, found `22`\n }"}, {"sha": "1ccdd977305559e318cd35b99b035fc08b9929b2", "filename": "src/test/ui/parser/closure-return-syntax.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,11 @@\n-error: expected one of `!`, `(`, `+`, `::`, `<`, or `{`, found `22`\n+error: expected `{`, found `22`\n   --> $DIR/closure-return-syntax.rs:5:23\n    |\n LL |     let x = || -> i32 22;\n-   |                       ^^ expected one of `!`, `(`, `+`, `::`, `<`, or `{`\n+   |                       ^^\n+   |                       |\n+   |                       expected `{`\n+   |                       help: try placing this code inside a block: `{ 22 }`\n \n error: aborting due to previous error\n "}, {"sha": "0c24478c25c8b62af03ed797833d1a9c9902f0c5", "filename": "src/test/ui/parser/column-offset-1-based.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1 +1 @@\n-# //~ ERROR expected `[`, found `<eof>`\n+# //~ ERROR expected one of `!` or `[`, found `<eof>`"}, {"sha": "766d72a0a5a93b9cef808048fdad8c6fb3753225", "filename": "src/test/ui/parser/column-offset-1-based.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcolumn-offset-1-based.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,8 @@\n-error: expected `[`, found `<eof>`\n+error: expected one of `!` or `[`, found `<eof>`\n   --> $DIR/column-offset-1-based.rs:1:1\n    |\n LL | #\n-   | ^ expected `[`\n+   | ^ expected one of `!` or `[`\n \n error: aborting due to previous error\n "}, {"sha": "343eac1b81ff0dc958a0e183ec9bdb11f2458ed6", "filename": "src/test/ui/parser/doc-comment-in-if-statement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n     if true /*!*/ {}\n-    //~^ ERROR expected `{`, found doc comment `/*!*/`\n+    //~^ ERROR outer attributes are not allowed on\n+    //~| ERROR expected outer doc comment\n }"}, {"sha": "af21b78733f90baa9c6f92d9dcbd105b6d3e2847", "filename": "src/test/ui/parser/doc-comment-in-if-statement.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-comment-in-if-statement.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,10 +1,19 @@\n-error: expected `{`, found doc comment `/*!*/`\n+error: expected outer doc comment\n   --> $DIR/doc-comment-in-if-statement.rs:2:13\n    |\n LL |     if true /*!*/ {}\n-   |     --      ^^^^^ expected `{`\n-   |     |\n-   |     this `if` expression has a condition, but no block\n+   |             ^^^^^\n+   |\n+   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n+\n+error: outer attributes are not allowed on `if` and `else` branches\n+  --> $DIR/doc-comment-in-if-statement.rs:2:13\n+   |\n+LL |     if true /*!*/ {}\n+   |     --      ^^^^^ -- the attributes are attached to this branch\n+   |     |       |\n+   |     |       help: remove the attributes\n+   |     the branch belongs to this `if`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "09444079365bf0df973c36100c58f67986add58c", "filename": "src/test/ui/parser/fn-body-eq-expr-semi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,23 @@\n+fn main() {}\n+\n+fn syntax() {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+}\n+\n+extern {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    //~^ ERROR incorrect function inside `extern` block\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+    //~^ ERROR incorrect function inside `extern` block\n+}\n+\n+trait Foo {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+}\n+\n+impl Foo for () {\n+    fn foo() = 42; //~ ERROR function body cannot be `= expression;`\n+    fn bar() -> u8 = 42; //~ ERROR function body cannot be `= expression;`\n+}"}, {"sha": "739133e0b408b825f0b36e536aa1f37fe1cfd899", "filename": "src/test/ui/parser/fn-body-eq-expr-semi.stderr", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-body-eq-expr-semi.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,117 @@\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:4:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:5:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:9:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:11:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:16:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:17:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:21:14\n+   |\n+LL |     fn foo() = 42;\n+   |              ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn foo() { 42 }\n+   |              ^    ^\n+\n+error: function body cannot be `= expression;`\n+  --> $DIR/fn-body-eq-expr-semi.rs:22:20\n+   |\n+LL |     fn bar() -> u8 = 42;\n+   |                    ^^^^^\n+   |\n+help: surround the expression with `{` and `}` instead of `=` and `;`\n+   |\n+LL |     fn bar() -> u8 { 42 }\n+   |                    ^    ^\n+\n+error: incorrect function inside `extern` block\n+  --> $DIR/fn-body-eq-expr-semi.rs:9:8\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+LL |     fn foo() = 42;\n+   |        ^^^   ----- help: remove the invalid body: `;`\n+   |        |\n+   |        cannot have a body\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: incorrect function inside `extern` block\n+  --> $DIR/fn-body-eq-expr-semi.rs:11:8\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+...\n+LL |     fn bar() -> u8 = 42;\n+   |        ^^^         ----- help: remove the invalid body: `;`\n+   |        |\n+   |        cannot have a body\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e9fc6f15346f24ec13200f98b6a053665397cd90", "filename": "src/test/ui/parser/issue-1655.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-1655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-1655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-1655.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,6 +1,5 @@\n-// error-pattern:expected `[`, found `vec`\n mod blade_runner {\n-    #vec[doc(\n+    #vec[doc( //~ ERROR expected one of `!` or `[`, found `vec`\n         brief = \"Blade Runner is probably the best movie ever\",\n         desc = \"I like that in the world of Blade Runner it is always\n                 raining, and that it's always night time. And Aliens"}, {"sha": "0c390a0ec563c95c78e25b7fcf996520a33f0bd0", "filename": "src/test/ui/parser/issue-1655.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-1655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-1655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-1655.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,8 @@\n-error: expected `[`, found `vec`\n-  --> $DIR/issue-1655.rs:3:6\n+error: expected one of `!` or `[`, found `vec`\n+  --> $DIR/issue-1655.rs:2:6\n    |\n LL |     #vec[doc(\n-   |      ^^^ expected `[`\n+   |      ^^^ expected one of `!` or `[`\n \n error: aborting due to previous error\n "}, {"sha": "15cd3df860b0da7a44d1cd045877b545f5d99e0b", "filename": "src/test/ui/parser/issue-63116.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -12,7 +12,7 @@ error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `;`\n LL | impl W <s(f;Y(;]\n    |            ^ expected one of 7 possible tokens\n \n-error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `->`, `...`, `::`, `<`, `>`, `?`, `[`, `_`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, or lifetime, found `;`\n+error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `->`, `...`, `::`, `<`, `>`, `?`, `[`, `_`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, lifetime, or path, found `;`\n   --> $DIR/issue-63116.rs:3:15\n    |\n LL | impl W <s(f;Y(;]"}, {"sha": "a5a8de85466bbccf5c549f3d538f82bf69ccc854", "filename": "src/test/ui/parser/issue-63135.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern: aborting due to 7 previous errors\n+// error-pattern: aborting due to 5 previous errors\n \n fn i(n{...,f #"}, {"sha": "396aec8335dbf162fa2c574bd3b78a328aa7cc6c", "filename": "src/test/ui/parser/issue-63135.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63135.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -31,23 +31,11 @@ LL | fn i(n{...,f #\n    |        |  expected `}`\n    |        `..` must be at the end and cannot have a trailing comma\n \n-error: expected `[`, found `}`\n+error: expected one of `!` or `[`, found `}`\n   --> $DIR/issue-63135.rs:3:16\n    |\n LL | fn i(n{...,f #\n-   |                ^ expected `[`\n+   |                ^ expected one of `!` or `[`\n \n-error: expected one of `:` or `|`, found `)`\n-  --> $DIR/issue-63135.rs:3:16\n-   |\n-LL | fn i(n{...,f #\n-   |                ^ expected one of `:` or `|`\n-\n-error: expected `;` or `{`, found `<eof>`\n-  --> $DIR/issue-63135.rs:3:16\n-   |\n-LL | fn i(n{...,f #\n-   |                ^ expected `;` or `{`\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "20e18b4bcbb323d50ecfe254f9800cd5aa0a4a40", "filename": "src/test/ui/parser/issue-68730.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68730.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be"}, {"sha": "9f8833e17fe25afc9f10b08683294ecd7e9efe32", "filename": "src/test/ui/parser/issue-68730.stderr", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68730.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be"}, {"sha": "ae02246046880e48ddfd4c9ce46310f74fee1e92", "filename": "src/test/ui/parser/issue-68890-2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,6 @@\n+fn main() {}\n+\n+type X<'a> = (?'a) +;\n+//~^ ERROR `?` may only modify trait bounds, not lifetime bounds\n+//~| ERROR at least one trait is required for an object type\n+//~| WARN trait objects without an explicit `dyn` are deprecated"}, {"sha": "d475c79cb27b4522a6ccbd33383a1c6e0ae5b23e", "filename": "src/test/ui/parser/issue-68890-2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890-2.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,22 @@\n+error: `?` may only modify trait bounds, not lifetime bounds\n+  --> $DIR/issue-68890-2.rs:3:15\n+   |\n+LL | type X<'a> = (?'a) +;\n+   |               ^\n+\n+warning: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/issue-68890-2.rs:3:14\n+   |\n+LL | type X<'a> = (?'a) +;\n+   |              ^^^^^^^ help: use `dyn`: `dyn (?'a) +`\n+   |\n+   = note: `#[warn(bare_trait_objects)]` on by default\n+\n+error[E0224]: at least one trait is required for an object type\n+  --> $DIR/issue-68890-2.rs:3:14\n+   |\n+LL | type X<'a> = (?'a) +;\n+   |              ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bab4ed7f800c5d7dcf32f2c344542703016cb4c7", "filename": "src/test/ui/parser/issue-68890.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,4 +1,4 @@\n enum e{A((?'a a+?+l))}\n //~^ ERROR `?` may only modify trait bounds, not lifetime bounds\n //~| ERROR expected one of `)`, `+`, or `,`\n-//~| ERROR expected trait bound, not lifetime bound\n+//~| ERROR expected item, found `)`"}, {"sha": "2a3bf6b41f02ea7c363eebc582786a62d4f7559a", "filename": "src/test/ui/parser/issue-68890.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-68890.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -10,11 +10,11 @@ error: expected one of `)`, `+`, or `,`, found `a`\n LL | enum e{A((?'a a+?+l))}\n    |               ^ expected one of `)`, `+`, or `,`\n \n-error: expected trait bound, not lifetime bound\n-  --> $DIR/issue-68890.rs:1:11\n+error: expected item, found `)`\n+  --> $DIR/issue-68890.rs:1:21\n    |\n LL | enum e{A((?'a a+?+l))}\n-   |           ^^^\n+   |                     ^ expected item\n \n error: aborting due to 3 previous errors\n "}, {"sha": "db9ef52c1aeec3a71e6aa4995b6d7bfeec122d8f", "filename": "src/test/ui/parser/labeled-no-colon-expr.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,17 @@\n+#![feature(label_break_value)]\n+\n+fn main() {\n+    'l0 while false {} //~ ERROR labeled expression must be followed by `:`\n+    'l1 for _ in 0..1 {} //~ ERROR labeled expression must be followed by `:`\n+    'l2 loop {} //~ ERROR labeled expression must be followed by `:`\n+    'l3 {} //~ ERROR labeled expression must be followed by `:`\n+    'l4 0; //~ ERROR labeled expression must be followed by `:`\n+    //~^ ERROR expected `while`, `for`, `loop` or `{`\n+\n+    macro_rules! m {\n+        ($b:block) => {\n+            'l5 $b; //~ ERROR cannot use a `block` macro fragment here\n+        }\n+    }\n+    m!({}); //~ ERROR labeled expression must be followed by `:`\n+}"}, {"sha": "4f5e8f78aa0cdcb5bd400a23ce34f0b159901306", "filename": "src/test/ui/parser/labeled-no-colon-expr.stderr", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -0,0 +1,89 @@\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:4:5\n+   |\n+LL |     'l0 while false {}\n+   |     ----^^^^^^^^^^^^^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:5:5\n+   |\n+LL |     'l1 for _ in 0..1 {}\n+   |     ----^^^^^^^^^^^^^^^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:6:5\n+   |\n+LL |     'l2 loop {}\n+   |     ----^^^^^^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:7:5\n+   |\n+LL |     'l3 {}\n+   |     ----^^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/labeled-no-colon-expr.rs:8:9\n+   |\n+LL |     'l4 0;\n+   |         ^ expected `while`, `for`, `loop` or `{` after a label\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:8:9\n+   |\n+LL |     'l4 0;\n+   |     ----^\n+   |     |  |\n+   |     |  help: add `:` after the label\n+   |     the label\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: cannot use a `block` macro fragment here\n+  --> $DIR/labeled-no-colon-expr.rs:13:17\n+   |\n+LL |             'l5 $b;\n+   |             ----^^\n+   |             |\n+   |             the `block` fragment is within this context\n+...\n+LL |     m!({});\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: labeled expression must be followed by `:`\n+  --> $DIR/labeled-no-colon-expr.rs:16:8\n+   |\n+LL |             'l5 $b;\n+   |             ---- help: add `:` after the label\n+   |             |\n+   |             the label\n+...\n+LL |     m!({});\n+   |        ^^\n+   |\n+   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "170ac22780b6319d4a1bb9876231af29e8b5ee36", "filename": "src/test/ui/parser/macro/trait-object-macro-matcher.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -2,9 +2,14 @@\n // `ty` matcher in particular doesn't accept a single lifetime\n \n macro_rules! m {\n-    ($t: ty) => ( let _: $t; )\n+    ($t: ty) => {\n+        let _: $t;\n+    };\n }\n \n fn main() {\n-    m!('static); //~ ERROR expected type, found `'static`\n+    m!('static);\n+    //~^ ERROR lifetime in trait object type must be followed by `+`\n+    //~| ERROR at least one trait is required for an object type\n+    //~| WARN trait objects without an explicit `dyn` are deprecated\n }"}, {"sha": "230733371ddd8a362efd512eb042126d82568a96", "filename": "src/test/ui/parser/macro/trait-object-macro-matcher.stderr", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-object-macro-matcher.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,22 @@\n-error: expected type, found `'static`\n-  --> $DIR/trait-object-macro-matcher.rs:9:8\n+error: lifetime in trait object type must be followed by `+`\n+  --> $DIR/trait-object-macro-matcher.rs:11:8\n    |\n LL |     m!('static);\n-   |        ^^^^^^^ expected type\n+   |        ^^^^^^^\n \n-error: aborting due to previous error\n+warning: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/trait-object-macro-matcher.rs:11:8\n+   |\n+LL |     m!('static);\n+   |        ^^^^^^^ help: use `dyn`: `dyn 'static`\n+   |\n+   = note: `#[warn(bare_trait_objects)]` on by default\n+\n+error[E0224]: at least one trait is required for an object type\n+  --> $DIR/trait-object-macro-matcher.rs:11:8\n+   |\n+LL |     m!('static);\n+   |        ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "d223619e1de9ed3bdb23d80dc9ad9f9260b04874", "filename": "src/test/ui/parser/regions-out-of-scope-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -4,7 +4,7 @@ fn foo(cond: bool) {\n     let mut x;\n \n     if cond {\n-        x = &'blk [1,2,3]; //~ ERROR expected `:`, found `[`\n+        x = &'blk [1,2,3]; //~ ERROR borrow expressions cannot be annotated with lifetimes\n     }\n }\n "}, {"sha": "bbc657ffd614c40cac5689a7cca84156a72536c8", "filename": "src/test/ui/parser/regions-out-of-scope-slice.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fregions-out-of-scope-slice.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,11 @@\n-error: expected `:`, found `[`\n-  --> $DIR/regions-out-of-scope-slice.rs:7:19\n+error: borrow expressions cannot be annotated with lifetimes\n+  --> $DIR/regions-out-of-scope-slice.rs:7:13\n    |\n LL |         x = &'blk [1,2,3];\n-   |                   ^ expected `:`\n+   |             ^----^^^^^^^^\n+   |              |\n+   |              annotated with lifetime here\n+   |              help: remove the lifetime annotation\n \n error: aborting due to previous error\n "}, {"sha": "5a5c19f32e8060553581805d79d4e819e94d51d4", "filename": "src/test/ui/parser/trait-object-lifetime-parens.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -6,9 +6,7 @@ fn f<'a, T: Trait + ('a)>() {} //~ ERROR parenthesized lifetime bounds are not s\n \n fn check<'a>() {\n     let _: Box<Trait + ('a)>; //~ ERROR parenthesized lifetime bounds are not supported\n-    let _: Box<('a) + Trait>;\n-    //~^ ERROR expected type, found `'a`\n-    //~| ERROR expected `:`, found `)`\n+    let _: Box<('a) + Trait>; //~ ERROR lifetime in trait object type must be followed by `+`\n }\n \n fn main() {}"}, {"sha": "1289c248275dc8b39b6b16ea8bee252fc17727eb", "filename": "src/test/ui/parser/trait-object-lifetime-parens.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -10,19 +10,11 @@ error: parenthesized lifetime bounds are not supported\n LL |     let _: Box<Trait + ('a)>;\n    |                        ^^^^ help: remove the parentheses\n \n-error: expected `:`, found `)`\n-  --> $DIR/trait-object-lifetime-parens.rs:9:19\n-   |\n-LL |     let _: Box<('a) + Trait>;\n-   |                   ^ expected `:`\n-\n-error: expected type, found `'a`\n+error: lifetime in trait object type must be followed by `+`\n   --> $DIR/trait-object-lifetime-parens.rs:9:17\n    |\n LL |     let _: Box<('a) + Trait>;\n-   |         -       ^^ expected type\n-   |         |\n-   |         while parsing the type for `_`\n+   |                 ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "9fbc938c4dce81e290668ffab3ebddfc3e993db3", "filename": "src/test/ui/parser/trait-object-trait-parens.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,15 +1,20 @@\n trait Trait<'a> {}\n \n+trait Obj {}\n+\n fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {}\n \n fn main() {\n-    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n+    let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+    //~^ ERROR `?Trait` is not permitted in trait object types\n+    //~| ERROR only auto traits can be used as additional traits\n+    //~| WARN trait objects without an explicit `dyn` are deprecated\n+    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n     //~^ ERROR `?Trait` is not permitted in trait object types\n+    //~| ERROR only auto traits can be used as additional traits\n     //~| WARN trait objects without an explicit `dyn` are deprecated\n-    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;\n-    //~^ WARN trait objects without an explicit `dyn` are deprecated\n-    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-    //~^ ERROR use of undeclared lifetime name `'a`\n-    //~| ERROR `?Trait` is not permitted in trait object types\n+    let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+    //~^ ERROR `?Trait` is not permitted in trait object types\n+    //~| ERROR only auto traits can be used as additional traits\n     //~| WARN trait objects without an explicit `dyn` are deprecated\n }"}, {"sha": "7022a66ca1a17be179961799c2bba804dbaa4cc8", "filename": "src/test/ui/parser/trait-object-trait-parens.stderr", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-trait-parens.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,44 +1,74 @@\n error: `?Trait` is not permitted in trait object types\n-  --> $DIR/trait-object-trait-parens.rs:6:25\n+  --> $DIR/trait-object-trait-parens.rs:8:24\n    |\n-LL |     let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n-   |                         ^^^^^^^^\n+LL |     let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+   |                        ^^^^^^^^\n \n error: `?Trait` is not permitted in trait object types\n-  --> $DIR/trait-object-trait-parens.rs:11:47\n+  --> $DIR/trait-object-trait-parens.rs:12:17\n    |\n-LL |     let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-   |                                               ^^^^^^^^\n+LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n+   |                 ^^^^^^\n+\n+error: `?Trait` is not permitted in trait object types\n+  --> $DIR/trait-object-trait-parens.rs:16:46\n+   |\n+LL |     let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+   |                                              ^^^^^^^^\n \n warning: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/trait-object-trait-parens.rs:6:16\n+  --> $DIR/trait-object-trait-parens.rs:8:16\n    |\n-LL |     let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (Copy) + (?Sized) + (for<'a> Trait<'a>)`\n+LL |     let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (Obj) + (?Sized) + (for<'a> Trait<'a>)`\n    |\n    = note: `#[warn(bare_trait_objects)]` on by default\n \n warning: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/trait-object-trait-parens.rs:9:16\n+  --> $DIR/trait-object-trait-parens.rs:12:16\n    |\n-LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (?Sized) + (for<'a> Trait<'a>) + (Copy)`\n+LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (?Sized) + (for<'a> Trait<'a>) + (Obj)`\n \n warning: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/trait-object-trait-parens.rs:11:16\n+  --> $DIR/trait-object-trait-parens.rs:16:16\n+   |\n+LL |     let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (for<'a> Trait<'a>) + (Obj) + (?Sized)`\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/trait-object-trait-parens.rs:8:35\n+   |\n+LL |     let _: Box<(Obj) + (?Sized) + (for<'a> Trait<'a>)>;\n+   |                -----              ^^^^^^^^^^^^^^^^^^^\n+   |                |                  |\n+   |                |                  additional non-auto trait\n+   |                |                  trait alias used in trait object type (additional use)\n+   |                first non-auto trait\n+   |                trait alias used in trait object type (first use)\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/trait-object-trait-parens.rs:12:49\n    |\n-LL |     let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn (for<'a> Trait<'a>) + (Copy) + (?Sized)`\n+LL |     let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Obj)>;\n+   |                           -------------------   ^^^^^\n+   |                           |                     |\n+   |                           |                     additional non-auto trait\n+   |                           |                     trait alias used in trait object type (additional use)\n+   |                           first non-auto trait\n+   |                           trait alias used in trait object type (first use)\n \n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/trait-object-trait-parens.rs:11:31\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/trait-object-trait-parens.rs:16:38\n    |\n-LL | fn main() {\n-   |        - help: consider introducing lifetime `'a` here: `<'a>`\n-...\n-LL |     let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n-   |                               ^^ undeclared lifetime\n+LL |     let _: Box<(for<'a> Trait<'a>) + (Obj) + (?Sized)>;\n+   |                 -----------------    ^^^^^\n+   |                 |                    |\n+   |                 |                    additional non-auto trait\n+   |                 |                    trait alias used in trait object type (additional use)\n+   |                 first non-auto trait\n+   |                 trait alias used in trait object type (first use)\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0261`.\n+For more information about this error, try `rustc --explain E0225`."}, {"sha": "c2fb8fa1eb6caceff1b55b985ecb5ab2b2e6e03b", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -8,3 +8,4 @@ LL | struct S;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0739`."}, {"sha": "895f33638f95aa0154beb2036b78494bf56ed9ea", "filename": "src/test/ui/unsafe/unsafe-block-without-braces.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,10 +1,11 @@\n error: expected `{`, found `std`\n   --> $DIR/unsafe-block-without-braces.rs:3:9\n    |\n-LL |     unsafe //{\n-   |           - expected `{`\n LL |         std::mem::transmute::<f32, u32>(1.0);\n-   |         ^^^ unexpected token\n+   |         ^^^----------------------------------\n+   |         |\n+   |         expected `{`\n+   |         help: try placing this code inside a block: `{ std::mem::transmute::<f32, u32>(1.0); }`\n \n error: aborting due to previous error\n "}, {"sha": "680c32c92af4b190a710c8ebb6899bd39a9e4f63", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -3204,7 +3204,9 @@ impl<'test> TestCx<'test> {\n         let json = cflags.contains(\"--error-format json\")\n             || cflags.contains(\"--error-format pretty-json\")\n             || cflags.contains(\"--error-format=json\")\n-            || cflags.contains(\"--error-format=pretty-json\");\n+            || cflags.contains(\"--error-format=pretty-json\")\n+            || cflags.contains(\"--output-format json\")\n+            || cflags.contains(\"--output-format=json\");\n \n         let mut normalized = output.to_string();\n "}, {"sha": "909529d7307847a600de8ba1fbeea6c58296733a", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=c20d7eecbc0928b57da8fe30b2ef8528e2bdd5be", "patch": "@@ -1,8 +1,8 @@\n //! Tidy checks source code in this repository.\n //!\n //! This program runs all of the various tidy checks for style, cleanliness,\n-//! etc. This is run by default on `make check` and as part of the auto\n-//! builders.\n+//! etc. This is run by default on `./x.py test` and as part of the auto\n+//! builders. The tidy checks can be executed with `./x.py test tidy`.\n \n #![deny(warnings)]\n "}]}