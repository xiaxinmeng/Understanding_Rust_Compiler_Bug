{"sha": "494ad4e601834f1b28e58c1c0ba579c2972c9a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NGFkNGU2MDE4MzRmMWIyOGU1OGMxYzBiYTU3OWMyOTcyYzlhMjc=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2012-01-05T13:46:14Z"}, "committer": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2012-01-05T15:25:51Z"}, "message": "Merge branch 'master' into kmath", "tree": {"sha": "84da9a41f60154049f69dd3c4e25a4eac96d9864", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84da9a41f60154049f69dd3c4e25a4eac96d9864"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/494ad4e601834f1b28e58c1c0ba579c2972c9a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/494ad4e601834f1b28e58c1c0ba579c2972c9a27", "html_url": "https://github.com/rust-lang/rust/commit/494ad4e601834f1b28e58c1c0ba579c2972c9a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/494ad4e601834f1b28e58c1c0ba579c2972c9a27/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a16acc0c105c438a5cf1500eb4c4a5c4388c2dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16acc0c105c438a5cf1500eb4c4a5c4388c2dca", "html_url": "https://github.com/rust-lang/rust/commit/a16acc0c105c438a5cf1500eb4c4a5c4388c2dca"}, {"sha": "3a20dda7eacf84faa64be0031c67e2169928962f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a20dda7eacf84faa64be0031c67e2169928962f", "html_url": "https://github.com/rust-lang/rust/commit/3a20dda7eacf84faa64be0031c67e2169928962f"}], "stats": {"total": 985, "additions": 586, "deletions": 399}, "files": [{"sha": "db415d5d31a4239b93580b76ef9f4e21700ad6cb", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -66,7 +66,9 @@ const tag_crate_hash: uint = 0x28u;\n \n const tag_mod_impl: uint = 0x30u;\n \n-const tag_impl_method: uint = 0x31u;\n+const tag_item_method: uint = 0x31u;\n+const tag_impl_iface: uint = 0x32u;\n+const tag_impl_iface_did: uint = 0x33u;\n \n // djb's cdb hashes.\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }"}, {"sha": "364dd7aef21f2a411968fb439c7e01461fc5e161", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -10,9 +10,10 @@ export get_type_param_count;\n export lookup_defs;\n export get_tag_variants;\n export get_impls_for_mod;\n-export get_impl_methods;\n+export get_iface_methods;\n export get_type;\n export get_item_name;\n+export get_impl_iface;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n@@ -65,33 +66,23 @@ fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option::t<ast::ident>)\n-    -> [@middle::resolve::_impl] {\n+    -> @[@middle::resolve::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    let result = [];\n-    for did in decoder::get_impls_for_mod(cdata, def.node, def.crate) {\n-        let nm = decoder::lookup_item_name(cdata, did.node);\n-        if alt name { some(n) { n == nm } none. { true } } {\n-            result += [@{did: did,\n-                         iface_did: none::<ast::def_id>, // FIXME[impl]\n-                         ident: nm,\n-                         methods: decoder::lookup_impl_methods(\n-                             cdata, did.node, did.crate)}];\n-        }\n-    }\n-    result\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n+    decoder::get_impls_for_mod(cdata, def, name, resolver)\n }\n \n-fn get_impl_methods(cstore: cstore::cstore, def: ast::def_id)\n-    -> [@middle::resolve::method_info] {\n+fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n+    let cstore = tcx.sess.get_cstore();\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    decoder::lookup_impl_methods(cdata, def.node, def.crate)\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n+    decoder::get_iface_methods(cdata, def, tcx, resolver)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.get_cstore();\n-    let cnum = def.crate;\n-    let cdata = cstore::get_crate_data(cstore, cnum).data;\n-    let resolver = bind translate_def_id(cstore, cnum, _);\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n     decoder::get_type(cdata, def, tcx, resolver)\n }\n \n@@ -100,6 +91,14 @@ fn get_item_name(cstore: cstore::cstore, cnum: int, id: int) -> ast::ident {\n     ret decoder::lookup_item_name(cdata, id);\n }\n \n+fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n+    -> option::t<ty::t> {\n+    let cstore = tcx.sess.get_cstore();\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n+    decoder::get_impl_iface(cdata, def, tcx, resolver)\n+}\n+\n // Translates a def_id from an external crate to a def_id for the current\n // compilation environment. We use this when trying to load types from\n // external crates - if those types further refer to types in other crates"}, {"sha": "95bd8e5811df739470171a9484381a703a5bab70", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 87, "deletions": 46, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -14,8 +14,10 @@ export get_symbol;\n export get_tag_variants;\n export get_type;\n export get_type_param_count;\n+export get_impl_iface;\n export lookup_def;\n export lookup_item_name;\n+export get_impl_iface;\n export resolve_path;\n export get_crate_attributes;\n export list_crate_metadata;\n@@ -24,7 +26,7 @@ export get_crate_deps;\n export get_crate_hash;\n export external_resolver;\n export get_impls_for_mod;\n-export lookup_impl_methods;\n+export get_iface_methods;\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -103,16 +105,42 @@ fn parse_external_def_id(this_cnum: ast::crate_num,\n     } else { ret extres(external_def_id); }\n }\n \n+fn doc_type(doc: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+            extres: external_resolver) -> ty::t {\n+    let tp = ebml::get_doc(doc, tag_items_data_item_type);\n+    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n+    parse_ty_data(tp.data, this_cnum, tp.start, def_parser, tcx)\n+}\n+\n fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n              extres: external_resolver) -> ty::t {\n-    let tp = ebml::get_doc(item, tag_items_data_item_type);\n-    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n-    let t = parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n-                          def_parser, tcx);\n+    let t = doc_type(item, this_cnum, tcx, extres);\n     if family_names_type(item_family(item)) {\n-        t = ty::mk_named(tcx, t, @item_name(item));\n+        ty::mk_named(tcx, t, @item_name(item))\n+    } else { t }\n+}\n+\n+fn item_impl_iface(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+                   extres: external_resolver) -> option::t<ty::t> {\n+    let result = none;\n+    ebml::tagged_docs(item, tag_impl_iface) {|ity|\n+        let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n+        let t = parse_ty_data(ity.data, this_cnum, ity.start, def_parser,\n+                              tcx);\n+        result = some(t);\n+    }\n+    result\n+}\n+\n+fn item_impl_iface_did(item: ebml::doc, this_cnum: ast::crate_num,\n+                       extres: external_resolver)\n+    -> option::t<ast::def_id> {\n+    let result = none;\n+    ebml::tagged_docs(item, tag_impl_iface_did) {|doc|\n+        let s = str::unsafe_from_bytes(ebml::doc_data(doc));\n+        result = some(parse_external_def_id(this_cnum, extres, s));\n     }\n-    t\n+    result\n }\n \n fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n@@ -121,8 +149,8 @@ fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n     let bounds = [];\n     let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n-        bounds += [tydecode::parse_bounds_data(@ebml::doc_data(p), this_cnum,\n-                                               def_parser, tcx)];\n+        bounds += [tydecode::parse_bounds_data(p.data, p.start,\n+                                               this_cnum, def_parser, tcx)];\n     }\n     @bounds\n }\n@@ -197,18 +225,17 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n             tid = {crate: cnum, node: tid.node};\n             ast::def_variant(tid, did)\n           }\n+          'I' { ast::def_ty(did) }\n         };\n     ret def;\n }\n \n fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n             extres: external_resolver) -> ty::ty_param_bounds_and_ty {\n-    let this_cnum = def.crate;\n-    let node_id = def.node;\n-    let item = lookup_item(node_id, data);\n-    let t = item_type(item, this_cnum, tcx, extres);\n+    let item = lookup_item(def.node, data);\n+    let t = item_type(item, def.crate, tcx, extres);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, this_cnum, tcx, extres)\n+        item_ty_param_bounds(item, def.crate, tcx, extres)\n     } else { @[] };\n     ret {bounds: tp_bounds, ty: t};\n }\n@@ -217,6 +244,11 @@ fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n+fn get_impl_iface(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n+                  extres: external_resolver) -> option::t<ty::t> {\n+    item_impl_iface(lookup_item(def.node, data), def.crate, tcx, extres)\n+}\n+\n fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n@@ -245,52 +277,59 @@ fn get_tag_variants(_data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n     ret infos;\n }\n \n-fn get_impls_for_mod(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n-    -> [ast::def_id] {\n-    let mod_item = lookup_item(node, data), result = [];\n-    ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n-        let did = parse_def_id(ebml::doc_data(doc));\n-        result += [{crate: cnum with did}];\n-    }\n-    result\n-}\n-\n-fn lookup_impl_methods(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n+fn item_impl_methods(data: @[u8], item: ebml::doc, base_tps: uint)\n     -> [@middle::resolve::method_info] {\n-    let impl_item = lookup_item(node, data), rslt = [];\n-    let base_tps = item_ty_param_count(impl_item);\n-    ebml::tagged_docs(impl_item, tag_impl_method) {|doc|\n+    let rslt = [];\n+    ebml::tagged_docs(item, tag_item_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, data);\n-        rslt += [@{did: {crate: cnum, node: m_did.node},\n+        rslt += [@{did: m_did,\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n                    ident: item_name(mth_item)}];\n     }\n     rslt\n }\n \n+fn get_impls_for_mod(data: @[u8], m_def: ast::def_id,\n+                     name: option::t<ast::ident>, extres: external_resolver)\n+    -> @[@middle::resolve::_impl] {\n+    let mod_item = lookup_item(m_def.node, data), result = [];\n+    ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n+        let did = parse_external_def_id(\n+            m_def.crate, extres, str::unsafe_from_bytes(ebml::doc_data(doc)));\n+        let item = lookup_item(did.node, data), nm = item_name(item);\n+        if alt name { some(n) { n == nm } none. { true } } {\n+            let base_tps = item_ty_param_count(doc);\n+            let i_did = item_impl_iface_did(item, m_def.crate, extres);\n+            result += [@{did: did, iface_did: i_did, ident: nm,\n+                         methods: item_impl_methods(data, doc, base_tps)}];\n+        }\n+    }\n+    @result\n+}\n+\n+fn get_iface_methods(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n+                     extres: external_resolver) -> @[ty::method] {\n+    let item = lookup_item(def.node, data), result = [];\n+    ebml::tagged_docs(item, tag_item_method) {|mth|\n+        let bounds = item_ty_param_bounds(mth, def.crate, tcx, extres);\n+        let name = item_name(mth);\n+        let ty = doc_type(mth, def.crate, tcx, extres);\n+        let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f } };\n+        result += [{ident: name, tps: bounds, fty: fty}];\n+    }\n+    @result\n+}\n \n fn family_has_type_params(fam_ch: u8) -> bool {\n-    ret alt fam_ch as char {\n-          'c' { false }\n-          'f' { true }\n-          'u' { true }\n-          'p' { true }\n-          'F' { true }\n-          'U' { true }\n-          'P' { true }\n-          'y' { true }\n-          't' { true }\n-          'T' { false }\n-          'm' { false }\n-          'n' { false }\n-          'v' { true }\n-          'i' { true }\n-        };\n+    alt fam_ch as char {\n+      'c' | 'T' | 'm' | 'n' { false }\n+      'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' { true }\n+    }\n }\n \n fn family_names_type(fam_ch: u8) -> bool {\n-    alt fam_ch as char { 'y' | 't' { true } _ { false } }\n+    alt fam_ch as char { 'y' | 't' | 'I' { true } _ { false } }\n }\n \n fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n@@ -321,6 +360,8 @@ fn item_family_to_str(fam: u8) -> str {\n       'm' { ret \"mod\"; }\n       'n' { ret \"native mod\"; }\n       'v' { ret \"tag\"; }\n+      'i' { ret \"impl\"; }\n+      'I' { ret \"iface\"; }\n     }\n }\n "}, {"sha": "8c564ec627aeb60d29151f6a45b240a65e810d37", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -202,13 +202,17 @@ fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{ds: def_to_str,\n           tcx: ecx.ccx.tcx,\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(io::new_writer(ebml_w.writer), ty_str_ctxt, typ);\n+}\n+\n+fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+    write_type(ecx, ebml_w, typ);\n     ebml::end_tag(ebml_w);\n }\n \n@@ -273,12 +277,13 @@ fn encode_info_for_mod(ebml_w: ebml::writer, md: _mod,\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         &index: [entry<int>]) {\n+    let tcx = ecx.ccx.tcx;\n     alt item.node {\n       item_const(_, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'c' as u8);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n@@ -292,7 +297,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         impure_fn. { 'f' }\n                       } as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n@@ -311,7 +316,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n       }\n@@ -320,7 +325,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for v: variant in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n@@ -329,13 +334,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_tag_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n       item_res(_, tps, _, _, ctor_id) {\n-        let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n+        let fn_ty = node_id_to_monotype(tcx, ctor_id);\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(tcx, fn_ty));\n         encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n@@ -350,13 +355,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::end_tag(ebml_w);\n       }\n       item_obj(_, tps, ctor_id) {\n-        let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n+        let fn_ty = node_id_to_monotype(tcx, ctor_id);\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(tcx, fn_ty));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n \n@@ -369,18 +374,35 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebml::end_tag(ebml_w);\n       }\n-      item_impl(tps, _, _, methods) {\n+      item_impl(tps, ifce, _, methods) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for m in methods {\n-            ebml::start_tag(ebml_w, tag_impl_method);\n+            ebml::start_tag(ebml_w, tag_item_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml::end_tag(ebml_w);\n         }\n+        alt ifce {\n+          some(_) {\n+            encode_symbol(ecx, ebml_w, item.id);\n+            let i_ty = ty::lookup_item_type(tcx, local_def(item.id)).ty;\n+            ebml::start_tag(ebml_w, tag_impl_iface);\n+            write_type(ecx, ebml_w, i_ty);\n+            ebml::end_tag(ebml_w);\n+            ebml::start_tag(ebml_w, tag_impl_iface_did);\n+            alt ty::struct(tcx, i_ty) {\n+              ty::ty_iface(did, _) {\n+                ebml_w.writer.write(str::bytes(def_to_str(did)));\n+              }\n+            }\n+            ebml::end_tag(ebml_w);\n+          }\n+          _ {}\n+        }\n         ebml::end_tag(ebml_w);\n \n         for m in methods {\n@@ -390,13 +412,30 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_family(ebml_w, 'f' as u8);\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, m.id));\n+                        node_id_to_monotype(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n             ebml::end_tag(ebml_w);\n         }\n       }\n-      item_iface(_, _) { /* FIXME[impl] */ }\n+      item_iface(tps, ms) {\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'I' as u8);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_name(ebml_w, item.ident);\n+        let i = 0u;\n+        for mty in *ty::iface_methods(tcx, local_def(item.id)) {\n+            ebml::start_tag(ebml_w, tag_item_method);\n+            encode_name(ebml_w, mty.ident);\n+            encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n+            encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n+            ebml::end_tag(ebml_w);\n+            i += 1u;\n+        }\n+        ebml::end_tag(ebml_w);\n+      }\n     }\n }\n "}, {"sha": "9e87a17537b1b69e8ca9049867d62a46e3970ec6", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -19,11 +19,10 @@ export parse_bounds_data;\n // Callback to translate defs to strs or back:\n type str_def = fn@(str) -> ast::def_id;\n \n-type pstate =\n-    {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n+type pstate = {data: @[u8], crate: int, mutable pos: uint, tcx: ty::ctxt};\n \n fn peek(st: @pstate) -> u8 {\n-    if st.pos < vec::len(*st.data) { st.data[st.pos] } else { 0u8 }\n+    st.data[st.pos]\n }\n \n fn next(st: @pstate) -> u8 {\n@@ -47,10 +46,9 @@ fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn@(char) -> bool) ->\n }\n \n \n-fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n-                 sd: str_def, tcx: ty::ctxt) -> ty::t {\n-    let st =\n-        @{data: data, crate: crate_num, mutable pos: pos, len: len, tcx: tcx};\n+fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, sd: str_def,\n+                 tcx: ty::ctxt) -> ty::t {\n+    let st = @{data: data, crate: crate_num, mutable pos: pos, tcx: tcx};\n     parse_ty(st, sd)\n }\n \n@@ -295,7 +293,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n           some(tt) { ret tt; }\n           none. {\n-            let ps = @{pos: pos, len: len with *st};\n+            let ps = @{pos: pos with *st};\n             let tt = parse_ty(ps, sd);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n             ret tt;\n@@ -381,7 +379,7 @@ fn parse_ty_fn(st: @pstate, sd: str_def) -> ty::fn_ty {\n // Rust metadata parsing\n fn parse_def_id(buf: [u8]) -> ast::def_id {\n     let colon_idx = 0u;\n-    let len = vec::len::<u8>(buf);\n+    let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         #error(\"didn't find ':' when parsing def id\");\n@@ -400,20 +398,21 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     ret {crate: crate_num, node: def_num};\n }\n \n-fn parse_bounds_data(data: @[u8], crate_num: int, sd: str_def, tcx: ty::ctxt)\n+fn parse_bounds_data(data: @[u8], start: uint,\n+                     crate_num: int, sd: str_def, tcx: ty::ctxt)\n     -> @[ty::param_bound] {\n-    let st = @{data: data, crate: crate_num, mutable pos: 0u,\n-               len: vec::len(*data), tcx: tcx};\n+    let st = @{data: data, crate: crate_num, mutable pos: start, tcx: tcx};\n     parse_bounds(st, sd)\n }\n \n fn parse_bounds(st: @pstate, sd: str_def) -> @[ty::param_bound] {\n     let bounds = [];\n-    while peek(st) != 0u8 {\n+    while true {\n         bounds += [alt next(st) as char {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'I' { ty::bound_iface(parse_ty(st, sd)) }\n+          '.' { break; }\n         }];\n     }\n     @bounds"}, {"sha": "2ba572154c55807c51f085bd13412047552e3fb3", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -66,10 +66,8 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n             let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n             if abbrev_len < len {\n                 // I.e. it's actually an abbreviation.\n-\n-                let s =\n-                    \"#\" + uint::to_str(pos, 16u) + \":\" +\n-                        uint::to_str(len, 16u) + \"#\";\n+                let s = \"#\" + uint::to_str(pos, 16u) + \":\" +\n+                    uint::to_str(len, 16u) + \"#\";\n                 let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }\n@@ -282,6 +280,7 @@ fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n           }\n         }\n     }\n+    w.write_char('.');\n }\n \n //"}, {"sha": "abf3d0cac1ed97cdccbc093557a880a3f7b27b2a", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -88,6 +88,14 @@ fn map_native_item(cx: ctx, i: @native_item) {\n \n fn map_expr(cx: ctx, ex: @expr) {\n     cx.map.insert(ex.id, node_expr(ex));\n+    alt ex.node {\n+      expr_anon_obj(ao) {\n+        for m in ao.methods {\n+            cx.map.insert(m.id, node_obj_method(m));\n+        }\n+      }\n+      _ {}\n+    }\n }\n \n fn new_smallintmap_int_adapter<copy V>() -> std::map::hashmap<int, V> {"}, {"sha": "bdb76dfd921095866fba045d1550225e16a608ad", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -726,7 +726,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           }\n         }\n       }\n-      ast_map::node_obj_method(method) {\n+      ast_map::node_obj_method(method) | ast_map::node_method(method) {\n         (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_res_ctor(item) {"}, {"sha": "01be1c4409f50223e0302a523c55a2987a6a30d9", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -1827,7 +1827,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n                 }\n                 @tmp\n             } else {\n-                @csearch::get_impls_for_mod(e.cstore, defid, name)\n+                csearch::get_impls_for_mod(e.sess.get_cstore(), defid, name)\n             };\n             e.impl_cache.insert(defid, cached);\n           }"}, {"sha": "4325f0af52b66dec851972269e9d4220dc24fb01", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -5039,8 +5039,8 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(tps, ifce, _, ms) {\n-        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps, ifce);\n+      ast::item_impl(tps, _, _, ms) {\n+        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n         trans_res_ctor(cx, item.span, decl, ctor_id, tps);\n@@ -5436,6 +5436,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, True);\n         ccx.item_ids.insert(it.id, vt_gvar);\n+        ccx.item_symbols.insert(it.id, s);\n       }\n       _ { }\n     }"}, {"sha": "bddfbb03e6e417a8210c2a8973fe168e22e9e3f3", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -3,13 +3,13 @@ import trans_common::*;\n import trans_build::*;\n import option::{some, none};\n import syntax::{ast, ast_util};\n+import metadata::csearch;\n import back::link;\n import lib::llvm;\n import llvm::llvm::{ValueRef, TypeRef, LLVMGetParam};\n \n fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n-              id: ast::node_id, tps: [ast::ty_param],\n-              _ifce: option::t<@ast::ty>) {\n+              id: ast::node_id, tps: [ast::ty_param]) {\n     let sub_cx = extend_path(cx, name);\n     for m in methods {\n         alt cx.ccx.item_ids.find(m.id) {\n@@ -136,8 +136,12 @@ fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n     let bcx = bcx, ccx = bcx_ccx(bcx);\n     alt origin {\n       typeck::dict_static(impl_did, tys, sub_origins) {\n-        assert impl_did.crate == ast::local_crate; // FIXME[impl]\n-        let vtable = ccx.item_ids.get(impl_did.node);\n+        let vtable = if impl_did.crate == ast::local_crate {\n+            ccx.item_ids.get(impl_did.node)\n+        } else {\n+            let name = csearch::get_symbol(ccx.sess.get_cstore(), impl_did);\n+            get_extern_const(ccx.externs, ccx.llmod, name, T_ptr(T_i8()))\n+        };\n         let impl_params = ty::lookup_item_type(ccx.tcx, impl_did).bounds;\n         let ptrs = [vtable], i = 0u, origin = 0u, ti = none;\n         for param in *impl_params {"}, {"sha": "76a3591cd183816d61b21f2eba03dd0879274f92", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -28,7 +28,6 @@ export node_id_to_ty_param_substs_opt_and_ty;\n export arg;\n export args_eq;\n export ast_constr_to_constr;\n-export bind_params_in_type;\n export block_ty;\n export constr;\n export constr_general;\n@@ -103,7 +102,7 @@ export substitute_type_params;\n export t;\n export new_ty_hash;\n export tag_variants;\n-export iface_methods, store_iface_methods;\n+export iface_methods, store_iface_methods, impl_iface;\n export tag_variant_with_id;\n export ty_param_substs_opt_and_ty;\n export ty_param_bounds_and_ty;\n@@ -2632,23 +2631,6 @@ fn type_err_to_str(err: ty::type_err) -> str {\n     }\n }\n \n-\n-// Converts type parameters in a type to type variables and returns the\n-// resulting type along with a list of type variable IDs.\n-fn bind_params_in_type(cx: ctxt, next_ty_var: block() -> int, typ: t,\n-                       ty_param_count: uint) -> {ids: [int], ty: t} {\n-    let param_var_ids = [], i = 0u;\n-    while i < ty_param_count { param_var_ids += [next_ty_var()]; i += 1u; }\n-    let param_var_ids = @param_var_ids;\n-    fn binder(cx: ctxt, param_var_ids: @[int], index: uint,\n-              _did: def_id) -> t {\n-        ret mk_var(cx, param_var_ids[index]);\n-    }\n-    {ids: *param_var_ids,\n-     ty: fold_ty(cx, fm_param(bind binder(cx, param_var_ids, _, _)), typ)}\n-}\n-\n-\n // Replaces type parameters in the given type using the given list of\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n@@ -2683,11 +2665,19 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n     }\n     // Local interfaces are supposed to have been added explicitly.\n     assert id.crate != ast::local_crate;\n-    let result = @[]; // FIXME[impl]\n+    let result = csearch::get_iface_methods(cx, id);\n     cx.iface_method_cache.insert(id, result);\n     result\n }\n \n+fn impl_iface(cx: ctxt, id: ast::def_id) -> option::t<t> {\n+    if id.crate == ast::local_crate {\n+        option::map(cx.tcache.find(id), {|it| it.ty})\n+    } else {\n+        csearch::get_impl_iface(cx, id)\n+    }\n+}\n+\n // Tag information\n type variant_info = @{args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n "}, {"sha": "02e1ed9d4f2e515d9d87d8a829fd3362ebed6d6e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 95, "deletions": 138, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -138,23 +138,16 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     }\n }\n \n-fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n-    -> {ids: [int], ty: ty::t} {\n-    ty::bind_params_in_type(fcx.ccx.tcx, {|| next_ty_var_id(fcx)}, tp, count)\n-}\n-\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n                     tpt: ty_param_bounds_and_ty, sp: span)\n     -> ty_param_substs_opt_and_ty {\n     let ty_param_count = vec::len(*tpt.bounds);\n-    let bind_result = bind_params(fcx, tpt.ty, ty_param_count);\n-    let ty_param_vars = bind_result.ids;\n-    let ty_substs_opt;\n-    let ty_substs_len = vec::len::<@ast::ty>(pth.node.types);\n+    let vars = vec::init_fn({|_i| next_ty_var(fcx)}, ty_param_count);\n+    let ty_substs_len = vec::len(pth.node.types);\n     if ty_substs_len > 0u {\n-        let param_var_len = vec::len(ty_param_vars);\n+        let param_var_len = vec::len(vars);\n         if param_var_len == 0u {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"this item does not take type parameters\");\n@@ -165,32 +158,16 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"not enough type parameters provided for this item\");\n         }\n-        let ty_substs: [ty::t] = [];\n-        let i = 0u;\n-        while i < ty_substs_len {\n-            let ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars[i]);\n-            let ty_subst = ast_ty_to_ty_crate(fcx.ccx, pth.node.types[i]);\n-            let res_ty = demand::simple(fcx, pth.span, ty_var, ty_subst);\n-            ty_substs += [res_ty];\n-            i += 1u;\n+        vec::iter2(pth.node.types, vars) {|sub, var|\n+            let ty_subst = ast_ty_to_ty_crate(fcx.ccx, sub);\n+            demand::simple(fcx, pth.span, var, ty_subst);\n         }\n-        ty_substs_opt = some::<[ty::t]>(ty_substs);\n         if ty_param_count == 0u {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                                        \"this item does not take type \\\n-                                      parameters\");\n+            fcx.ccx.tcx.sess.span_fatal(\n+                sp, \"this item does not take type parameters\");\n         }\n-    } else {\n-        // We will acquire the type parameters through unification.\n-        let ty_substs: [ty::t] = [];\n-        let i = 0u;\n-        while i < ty_param_count {\n-            ty_substs += [ty::mk_var(fcx.ccx.tcx, ty_param_vars[i])];\n-            i += 1u;\n-        }\n-        ty_substs_opt = some::<[ty::t]>(ty_substs);\n     }\n-    ret {substs: ty_substs_opt, ty: tpt.ty};\n+    {substs: some(vars), ty: tpt.ty}\n }\n \n // Type tests\n@@ -529,8 +506,17 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n                 bounds += [alt b {\n                   ast::bound_send. { ty::bound_send }\n                   ast::bound_copy. { ty::bound_copy }\n-                  ast::bound_iface(ifc) {\n-                    ty::bound_iface(ast_ty_to_ty(tcx, mode, ifc))\n+                  ast::bound_iface(t) {\n+                    let ity = ast_ty_to_ty(tcx, mode, t);\n+                    alt ty::struct(tcx, ity) {\n+                      ty::ty_iface(_, _) {}\n+                      _ {\n+                        tcx.sess.span_fatal(\n+                            t.span, \"type parameter bounds must be \\\n+                                     interface types\");\n+                      }\n+                    }\n+                    ty::bound_iface(ity)\n                   }\n                 }];\n             }\n@@ -650,6 +636,30 @@ fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n      })}\n }\n \n+fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n+    if impl_m.tps != if_m.tps {\n+        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                          \"` has an incompatible set of type parameters\");\n+    } else {\n+        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        // Add dummy substs for the parameters of the impl method\n+        let substs = substs + vec::init_fn({|i|\n+            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+        }, vec::len(*if_m.tps));\n+        let if_fty = ty::substitute_type_params(tcx, substs,\n+                                                ty::mk_fn(tcx, if_m.fty));\n+        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n+          ty::unify::ures_err(err) {\n+            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                              \"` has an incompatible type: \" +\n+                              ty::type_err_to_str(err));\n+          }\n+          _ {}\n+        }\n+    }\n+}\n+\n // Item collection - a pair of bootstrap passes:\n //\n // (1) Collect the IDs of all type items (typedefs) and store them in a table.\n@@ -707,20 +717,50 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n-          ast::item_impl(tps, _, selfty, ms) {\n+          ast::item_impl(tps, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(cx.tcx, m_collect, tps);\n+            let my_methods = [];\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n-                let ty = ty::mk_fn(cx.tcx,\n-                                   ty_of_fn_decl(cx.tcx, m_collect,\n-                                                 ast::proto_bare, m.decl));\n+                let mty = ty_of_method(cx.tcx, m_collect, m);\n+                my_methods += [mty];\n+                let fty = ty::mk_fn(cx.tcx, mty.fty);\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n-                                      ty: ty});\n-                write::ty_only(cx.tcx, m.id, ty);\n+                                      ty: fty});\n+                write::ty_only(cx.tcx, m.id, fty);\n             }\n             write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n                                                        selfty));\n+            alt ifce {\n+              some(t) {\n+                let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n+                cx.tcx.tcache.insert(local_def(it.id),\n+                                     {bounds: i_bounds, ty: iface_ty});\n+                alt ty::struct(cx.tcx, iface_ty) {\n+                  ty::ty_iface(did, tys) {\n+                    for if_m in *ty::iface_methods(cx.tcx, did) {\n+                        alt vec::find(my_methods,\n+                                      {|m| if_m.ident == m.ident}) {\n+                          some(m) {\n+                            compare_impl_method(cx.tcx, t.span, m,\n+                                                vec::len(tps), if_m, tys);\n+                          }\n+                          none. {\n+                            cx.tcx.sess.span_err(t.span, \"missing method `\" +\n+                                                 if_m.ident + \"`\");\n+                          }\n+                        }\n+                    }\n+                  }\n+                  _ {\n+                    cx.tcx.sess.span_fatal(t.span, \"can only implement \\\n+                                                    interface types\");\n+                  }\n+                }\n+              }\n+              _ {}\n+            }\n           }\n           ast::item_obj(object, ty_params, ctor_id) {\n             // Now we need to call ty_of_obj_ctor(); this is the type that\n@@ -1514,7 +1554,6 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n               ty::bound_iface(t) {\n                 let (iid, tps) = alt ty::struct(tcx, t) {\n                     ty::ty_iface(i, tps) { (i, tps) }\n-                    _ { cont; }\n                 };\n                 let ifce_methods = ty::iface_methods(tcx, iid);\n                 alt vec::position_pred(*ifce_methods, {|m| m.ident == name}) {\n@@ -1555,9 +1594,9 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n             alt vec::find(methods, {|m| m.ident == name}) {\n               some(m) {\n                 let {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n-                let {ids, ty: self_ty} = if n_tps > 0u {\n+                let {vars, ty: self_ty} = if n_tps > 0u {\n                     bind_params(fcx, self_ty, n_tps)\n-                } else { {ids: [], ty: self_ty} };\n+                } else { {vars: [], ty: self_ty} };\n                 alt unify::unify(fcx, ty, self_ty) {\n                   ures_ok(_) {\n                     if option::is_some(result) {\n@@ -1568,7 +1607,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                         result = some({\n                             method_ty: ty_from_did(tcx, m.did),\n                             n_tps: m.n_tps,\n-                            substs: vec::map(ids, {|id| ty::mk_var(tcx, id)}),\n+                            substs: vars,\n                             origin: method_static(m.did)\n                         });\n                     }\n@@ -2451,6 +2490,12 @@ fn next_ty_var(fcx: @fn_ctxt) -> ty::t {\n     ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n }\n \n+fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n+    -> {vars: [ty::t], ty: ty::t} {\n+    let vars = vec::init_fn({|_i| next_ty_var(fcx)}, count);\n+    {vars: vars, ty: ty::substitute_type_params(fcx.ccx.tcx, vars, tp)}\n+}\n+\n fn get_self_info(ccx: @crate_ctxt) -> option::t<self_info> {\n     ret vec::last(ccx.self_infos);\n }\n@@ -2737,30 +2782,6 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n     check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n }\n \n-fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n-    if impl_m.tps != if_m.tps {\n-        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n-                          \"` has an incompatible set of type parameters\");\n-    } else {\n-        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n-        // Add dummy substs for the parameters of the impl method\n-        let substs = substs + vec::init_fn({|i|\n-            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n-        }, vec::len(*if_m.tps));\n-        let if_fty = ty::substitute_type_params(tcx, substs,\n-                                                ty::mk_fn(tcx, if_m.fty));\n-        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n-          ty::unify::ures_err(err) {\n-            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n-                              \"` has an incompatible type: \" +\n-                              ty::type_err_to_str(err));\n-          }\n-          _ {}\n-        }\n-    }\n-}\n-\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n@@ -2779,70 +2800,15 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         // Now remove the info from the stack.\n         vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(tps, ifce, ty, ms) {\n+      ast::item_impl(tps, _, ty, ms) {\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n-        let my_methods = vec::map(ms, {|m|\n-            check_method(ccx, m);\n-            ty_of_method(ccx.tcx, m_check, m)\n-        });\n+        for m in ms { check_method(ccx, m); }\n         vec::pop(ccx.self_infos);\n-        alt ifce {\n-          some(ty) {\n-            let iface_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n-            alt ty::struct(ccx.tcx, iface_ty) {\n-              ty::ty_iface(did, tys) {\n-                for if_m in *ty::iface_methods(ccx.tcx, did) {\n-                    alt vec::find(my_methods, {|m| if_m.ident == m.ident}) {\n-                      some(m) {\n-                        compare_impl_method(ccx.tcx, ty.span, m,\n-                                            vec::len(tps), if_m, tys);\n-                      }\n-                      none. {\n-                        ccx.tcx.sess.span_err(ty.span, \"missing method `\" +\n-                                              if_m.ident + \"`\");\n-                      }\n-                    }\n-                }\n-                let tpt = {bounds: ty_param_bounds(ccx.tcx, m_check, tps),\n-                           ty: iface_ty};\n-                ccx.tcx.tcache.insert(local_def(it.id), tpt);\n-              }\n-              _ {\n-                ccx.tcx.sess.span_err(ty.span, \"can only implement interface \\\n-                                                types\");\n-              }\n-            }\n-          }\n-          _ {}\n-        }\n       }\n       _ {/* nothing to do */ }\n     }\n }\n \n-fn check_ty_params(ccx: @crate_ctxt, tps: [ast::ty_param]) {\n-    for tp in tps {\n-        let i = 0u;\n-        for bound in *tp.bounds {\n-            alt bound {\n-              ast::bound_iface(at) {\n-                let tbound = ccx.tcx.ty_param_bounds.get(tp.id)[i];\n-                let bound_ty = alt tbound { ty::bound_iface(t) { t } };\n-                alt ty::struct(ccx.tcx, bound_ty) {\n-                  ty::ty_iface(_, _) {}\n-                  _ {\n-                    ccx.tcx.sess.span_err(at.span, \"type parameter bounds \\\n-                                                    must be interface types\");\n-                  }\n-                }\n-              }\n-              _ {}\n-            }\n-            i += 1u;\n-        }\n-    }\n-}\n-\n fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n       ty::ty_vec(mt) {\n@@ -2924,7 +2890,6 @@ mod dict {\n         let tcx = fcx.ccx.tcx;\n         let (iface_id, iface_tps) = alt ty::struct(tcx, iface_ty) {\n             ty::ty_iface(did, tps) { (did, tps) }\n-            _ { tcx.sess.abort_if_errors(); fail; }\n         };\n         let ty = fixup_ty(fcx, sp, ty);\n         alt ty::struct(tcx, ty) {\n@@ -2951,10 +2916,9 @@ mod dict {\n                 for im in *impls {\n                     if im.iface_did == some(iface_id) {\n                         let {n_tps, ty: self_ty} = impl_self_ty(tcx, im.did);\n-                        let {ids, ty: self_ty} = if n_tps > 0u {\n+                        let {vars, ty: self_ty} = if n_tps > 0u {\n                             bind_params(fcx, self_ty, n_tps)\n-                        } else { {ids: [], ty: self_ty} };\n-                        let vars = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n+                        } else { {vars: [], ty: self_ty} };\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n                         // FIXME[impl] don't do this in fcx (or make\n                         // unify transactional by scrubbing bindings on fail)\n@@ -3007,13 +2971,7 @@ mod dict {\n     fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: [ty::t],\n                          iface_tys: [ty::t], impl_did: ast::def_id) {\n         let tcx = fcx.ccx.tcx;\n-        // FIXME[impl]\n-        assert impl_did.crate == ast::local_crate;\n-        let ity = alt tcx.items.get(impl_did.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, some(ity), _, _), _}) {\n-              ast_ty_to_ty(tcx, m_check, ity)\n-          }\n-        };\n+        let ity = option::get(ty::impl_iface(tcx, impl_did));\n         let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n         alt ty::struct(tcx, iface_ty) {\n           ty::ty_iface(_, tps) {\n@@ -3086,8 +3044,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 dict_map: std::map::new_int_hash(),\n                 tcx: tcx};\n     let visit = visit::mk_simple_visitor(@{\n-        visit_item: bind check_item(ccx, _),\n-        visit_ty_params: bind check_ty_params(ccx, _)\n+        visit_item: bind check_item(ccx, _)\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);"}, {"sha": "990132e01bff52cd741b081aebf8b61e92c330b9", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -394,26 +394,23 @@ fn parse_type_constraints(p: parser) -> [@ast::ty_constr] {\n     ret parse_constrs(parse_constr_in_type, p);\n }\n \n-fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool)\n-   -> @ast::ty {\n-    let lo = p.get_lo_pos();\n-\n+fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n+                    lo: uint) -> @ast::ty {\n     if colons_before_params && p.peek() == token::MOD_SEP {\n         p.bump();\n         expect(p, token::LT);\n     } else if !colons_before_params && p.peek() == token::LT {\n         p.bump();\n-    } else { ret @spanned(lo, p.get_lo_pos(), orig_t); }\n+    } else { ret @spanned(lo, p.get_last_hi_pos(), orig_t); }\n \n     // If we're here, we have explicit type parameter instantiation.\n     let seq = parse_seq_to_gt(some(token::COMMA), {|p| parse_ty(p, false)},\n                               p);\n \n     alt orig_t {\n       ast::ty_path(pth, ann) {\n-        let hi = p.get_hi_pos();\n-        ret @spanned(lo, hi,\n-                     ast::ty_path(@spanned(lo, hi,\n+        ret @spanned(lo, p.get_last_hi_pos(),\n+                     ast::ty_path(@spanned(lo, p.get_last_hi_pos(),\n                                            {global: pth.node.global,\n                                             idents: pth.node.idents,\n                                             types: seq}), ann));\n@@ -527,7 +524,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n     } else { p.fatal(\"expecting type\"); }\n-    ret parse_ty_postfix(t, p, colons_before_params);\n+    ret parse_ty_postfix(t, p, colons_before_params, lo);\n }\n \n fn parse_arg_mode(p: parser) -> ast::mode {"}, {"sha": "a0deaeda26a010bd0769599a054ae2a12983a2c3", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -5,11 +5,11 @@ mod util;\n mod header;\n mod runtest;\n mod common;\n+mod errors;\n \n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "c0d96fc514258445f97b0672a610965cb06dc749", "filename": "src/compiletest/errors.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -0,0 +1,54 @@\n+import option;\n+import str;\n+import std::io;\n+import std::fs;\n+\n+import common::config;\n+\n+export load_errors;\n+export expected_error;\n+\n+type expected_error = { line: uint, kind: str, msg: str };\n+\n+// Load any test directives embedded in the file\n+fn load_errors(testfile: str) -> [expected_error] {\n+    let error_patterns = [];\n+    let rdr = result::get(io::file_reader(testfile));\n+    let line_num = 1u;\n+    while !rdr.eof() {\n+        let ln = rdr.read_line();\n+        error_patterns += parse_expected(line_num, ln);\n+        line_num += 1u;\n+    }\n+    ret error_patterns;\n+}\n+\n+fn parse_expected(line_num: uint, line: str) -> [expected_error] {\n+    let error_tag = \"//!\";\n+    let idx0 = str::find(line, error_tag);\n+    if idx0 < 0 { ret []; }\n+    let idx = (idx0 as uint) + str::byte_len(error_tag);\n+\n+    // \"//!^^^ kind msg\" denotes a message expected\n+    // three lines above current line:\n+    let adjust_line = 0u;\n+    let len = str::byte_len(line);\n+    while idx < len && line[idx] == ('^' as u8) {\n+        adjust_line += 1u;\n+        idx += 1u;\n+    }\n+\n+    // Extract kind:\n+    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+    let start_kind = idx;\n+    while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n+    let kind = str::to_lower(str::slice(line, start_kind, idx));\n+\n+    // Extract msg:\n+    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+    let msg = str::slice(line, idx, len);\n+\n+    #debug(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n+\n+    ret [{line: line_num - adjust_line, kind: kind, msg: msg}];\n+}"}, {"sha": "1efc06d91de46092a74bd1b65430f5ffb40a74bd", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -42,7 +42,16 @@ fn run_cfail_test(cx: cx, props: test_props, testfile: str) {\n     }\n \n     check_correct_failure_status(procres);\n-    check_error_patterns(props, testfile, procres);\n+\n+    let expected_errors = errors::load_errors(testfile);\n+    if vec::is_not_empty(expected_errors) {\n+        if vec::is_not_empty(props.error_patterns) {\n+            fatal(\"both error pattern and expected errors specified\");\n+        }\n+        check_expected_errors(expected_errors, testfile, procres);\n+    } else {\n+        check_error_patterns(props, testfile, procres);\n+    }\n }\n \n fn run_rfail_test(cx: cx, props: test_props, testfile: str) {\n@@ -181,7 +190,9 @@ actual:\\n\\\n     }\n }\n \n-fn check_error_patterns(props: test_props, testfile: str, procres: procres) {\n+fn check_error_patterns(props: test_props,\n+                        testfile: str,\n+                        procres: procres) {\n     if vec::is_empty(props.error_patterns) {\n         fatal(\"no error pattern specified in \" + testfile);\n     }\n@@ -218,6 +229,63 @@ fn check_error_patterns(props: test_props, testfile: str, procres: procres) {\n     }\n }\n \n+fn check_expected_errors(expected_errors: [errors::expected_error],\n+                         testfile: str,\n+                         procres: procres) {\n+\n+    // true if we found the error in question\n+    let found_flags = vec::init_elt_mut(false, vec::len(expected_errors));\n+\n+    if procres.status == 0 {\n+        fatal(\"process did not return an error status\");\n+    }\n+\n+    let prefixes = vec::map(expected_errors, {|ee|\n+        #fmt(\"%s:%u:\", testfile, ee.line)\n+    });\n+\n+    // Scan and extract our error/warning messages,\n+    // which look like:\n+    //    filename:line1:col1: line2:col2: *error:* msg\n+    //    filename:line1:col1: line2:col2: *warning:* msg\n+    // where line1:col1: is the starting point, line2:col2:\n+    // is the ending point, and * represents ANSI color codes.\n+    for line: str in str::split(procres.stdout, '\\n' as u8) {\n+        let was_expected = false;\n+        vec::iteri(expected_errors) {|i, ee|\n+            if !found_flags[i] {\n+                #debug[\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n+                       prefixes[i], ee.kind, ee.msg, line];\n+                if (str::starts_with(line, prefixes[i]) &&\n+                    str::contains(line, ee.kind) &&\n+                    str::contains(line, ee.msg)) {\n+                    found_flags[i] = true;\n+                    was_expected = true;\n+                }\n+            }\n+        }\n+\n+        // ignore this msg which gets printed at the end\n+        if str::contains(line, \"aborting due to previous errors\") {\n+            was_expected = true;\n+        }\n+\n+        if !was_expected && (str::contains(line, \"error\") ||\n+                             str::contains(line, \"warning\")) {\n+            fatal_procres(#fmt[\"unexpected error pattern '%s'!\", line],\n+                          procres);\n+        }\n+    }\n+\n+    uint::range(0u, vec::len(found_flags)) {|i|\n+        if !found_flags[i] {\n+            let ee = expected_errors[i];\n+            fatal_procres(#fmt[\"expected %s on line %u not found: %s\",\n+                               ee.kind, ee.line, ee.msg], procres);\n+        }\n+    }\n+}\n+\n type procargs = {prog: str, args: [str]};\n \n type procres = {status: int, stdout: str, stderr: str, cmdline: str};"}, {"sha": "7a7f13a7e9764545f2e56ea2e1347e5b55017557", "filename": "src/etc/cmathconsts.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fetc%2Fcmathconsts.c", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fetc%2Fcmathconsts.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcmathconsts.c?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -63,11 +63,11 @@ int main(int argc, char** argv) {\n   printf(\"}\\n\\n\");\n \n   printf(\"mod c_float_targ_consts {\\n\");\n-  printf(\"    const radix: uint = %u;\\n\", FLT_RADIX);\n-  printf(\"    const mantissa_digits: uint = %u;\\n\", FLT_MANT_DIG);\n-  printf(\"    const digits: uint = %u;\\n\", FLT_DIG);\n-  printf(\"    const min_exp: uint = %i;\\n\", FLT_MIN_EXP);\n-  printf(\"    const max_exp: uint = %i;\\n\", FLT_MAX_EXP);\n+  printf(\"    const radix: uint = %uu;\\n\", FLT_RADIX);\n+  printf(\"    const mantissa_digits: uint = %uu;\\n\", FLT_MANT_DIG);\n+  printf(\"    const digits: uint = %uu;\\n\", FLT_DIG);\n+  printf(\"    const min_exp: int = %i;\\n\", FLT_MIN_EXP);\n+  printf(\"    const max_exp: int = %i;\\n\", FLT_MAX_EXP);\n   printf(\"    const min_10_exp: int = %i;\\n\", FLT_MIN_10_EXP);\n   printf(\"    const max_10_exp: int = %i;\\n\", FLT_MAX_10_EXP);\n   printf(\"    const min_value: c_float = %a_%s;\\n\", C_FLT(FLT_MIN), c_flt);\n@@ -76,11 +76,11 @@ int main(int argc, char** argv) {\n   printf(\"}\\n\\n\");\n \n   printf(\"mod c_double_targ_consts {\\n\");\n-  printf(\"    const radix: uint = %u;\\n\", FLT_RADIX);\n-  printf(\"    const mantissa_digits: uint = %u;\\n\", DBL_MANT_DIG);\n-  printf(\"    const digits: uint = %u;\\n\", DBL_DIG);\n-  printf(\"    const min_exp: uint = %i;\\n\", DBL_MIN_EXP);\n-  printf(\"    const max_exp: uint = %i;\\n\", DBL_MAX_EXP);\n+  printf(\"    const radix: uint = %uu;\\n\", FLT_RADIX);\n+  printf(\"    const mantissa_digits: uint = %uu;\\n\", DBL_MANT_DIG);\n+  printf(\"    const digits: uint = %uu;\\n\", DBL_DIG);\n+  printf(\"    const min_exp: int = %i;\\n\", DBL_MIN_EXP);\n+  printf(\"    const max_exp: int = %i;\\n\", DBL_MAX_EXP);\n   printf(\"    const min_10_exp: int = %i;\\n\", DBL_MIN_10_EXP);\n   printf(\"    const max_10_exp: int = %i;\\n\", DBL_MAX_10_EXP);\n   printf(\"    const min_value: c_double = %a_%s;\\n\", C_DBL(DBL_MIN), c_dbl);"}, {"sha": "721df01690307eaf3c2d87621993c4292f6a3607", "filename": "src/libcore/bessel.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Fbessel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Fbessel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbessel.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -2,8 +2,8 @@\n // (cant do better via libm; bessel functions only exist for c_double)\n \n // code that wants to use bessel functions should use\n-// values of type bessel::t and cast from/to float/f32/f64 \n-// when working with them at the peril of precision loss \n+// values of type bessel::t and cast from/to float/f32/f64\n+// when working with them at the peril of precision loss\n // for platform neutrality\n \n import f64::*;"}, {"sha": "b1d528cbe764b193fa7587e38008bca51eac9f27", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -60,7 +60,7 @@ native mod c_double {\n     #[cfg(target_os=\"macos\")]\n     #[cfg(target_os=\"win32\")]\n     pure fn log2(n: c_double) -> c_double;\n-    #[link_name=\"ilogb\"] pure fn ilogradix(n: c_double) -> c_int;\n+    #[link_name=\"ilogb\"] pure fn ilog_radix(n: c_double) -> c_int;\n     pure fn modf(n: c_double, &iptr: c_double) -> c_double;\n     pure fn pow(n: c_double, e: c_double) -> c_double;\n // FIXME enable when rounding modes become available\n@@ -139,7 +139,8 @@ native mod c_float {\n // FIXME enable when rounding modes become available\n //    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;\n     #[link_name=\"roundf\"] pure fn round(n: c_float) -> c_float;\n-    #[link_name=\"scalbnf\"] pure fn ldexp_radix(n: c_float, i: c_int) -> c_float;\n+    #[link_name=\"scalbnf\"] pure fn ldexp_radix(n: c_float, i: c_int)\n+        -> c_float;\n     #[link_name=\"sinf\"] pure fn sin(n: c_float) -> c_float;\n     #[link_name=\"sinhf\"] pure fn sinh(n: c_float) -> c_float;\n     #[link_name=\"sqrtf\"] pure fn sqrt(n: c_float) -> c_float;\n@@ -154,11 +155,11 @@ native mod c_float {\n // FIXME obtain machine float/math constants automatically\n \n mod c_float_targ_consts {\n-    const radix: uint = 2;\n-    const mantissa_digits: uint = 24;\n-    const digits: uint = 6;\n-    const min_exp: uint = -125;\n-    const max_exp: uint = 128;\n+    const radix: uint = 2u;\n+    const mantissa_digits: uint = 24u;\n+    const digits: uint = 6u;\n+    const min_exp: uint = -125u;\n+    const max_exp: uint = 128u;\n     const min_10_exp: int = -37;\n     const max_10_exp: int = 38;\n     // FIXME this is wrong! replace with hexadecimal (%a) constants below\n@@ -168,11 +169,11 @@ mod c_float_targ_consts {\n }\n \n mod c_double_targ_consts {\n-    const radix: uint = 2;\n-    const mantissa_digits: uint = 53;\n-    const digits: uint = 15;\n-    const min_exp: uint = -1021;\n-    const max_exp: uint = 1024;\n+    const radix: uint = 2u;\n+    const mantissa_digits: uint = 53u;\n+    const digits: uint = 15u;\n+    const min_exp: uint = -1021u;\n+    const max_exp: uint = 1024u;\n     const min_10_exp: int = -307;\n     const max_10_exp: int = 308;\n     // FIXME this is wrong! replace with hexadecimal (%a) constants below\n@@ -218,11 +219,11 @@ mod c_double_math_consts {\n }\n \n mod c_float_targ_consts {\n-    const radix: uint = 2;\n-    const mantissa_digits: uint = 24;\n-    const digits: uint = 6;\n-    const min_exp: uint = -125;\n-    const max_exp: uint = 128;\n+    const radix: uint = 2u;\n+    const mantissa_digits: uint = 24u;\n+    const digits: uint = 6u;\n+    const min_exp: int = -125;\n+    const max_exp: int = 128;\n     const min_10_exp: int = -37;\n     const max_10_exp: int = 38;\n     const min_value: c_float = 0x1p-126_f32;\n@@ -231,17 +232,18 @@ mod c_float_targ_consts {\n }\n \n mod c_double_targ_consts {\n-    const radix: uint = 2;\n-    const mantissa_digits: uint = 53;\n-    const digits: uint = 15;\n-    const min_exp: uint = -1021;\n-    const max_exp: uint = 1024;\n+    const radix: uint = 2u;\n+    const mantissa_digits: uint = 53u;\n+    const digits: uint = 15u;\n+    const min_exp: int = -1021;\n+    const max_exp: int = 1024;\n     const min_10_exp: int = -307;\n     const max_10_exp: int = 308;\n     const min_value: c_double = 0x1p-1022_f64;\n     const max_value: c_double = 0x1.fffffffffffffp+1023_f64;\n     const epsilon: c_double = 0x1p-52_f64;\n }\n+\n */\n \n //"}, {"sha": "3948dc9c9d42ef5d3561727a9d9d4408241dacef", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -122,7 +122,7 @@ Predicate: is_finite\n Returns true if `x`is a finite numer\n */\n pure fn is_finite(x: f32) -> bool {\n-    ret !(is_nan(x) || is_infinite(x));\n+    ret !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME add is_normal, is_subnormal, and fpclassify"}, {"sha": "eb8714dcb70db16fd4773924e5398c1f80ddfe0a", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -139,7 +139,7 @@ Predicate: is_finite\n Returns true if `x`is a finite numer\n */\n pure fn is_finite(x: f64) -> bool {\n-    ret !(is_nan(x) || is_infinite(x));\n+    ret !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME add is_normal, is_subnormal, and fpclassify"}, {"sha": "28ffc72f82b1496fad72e3ff0890a48ace1806dd", "filename": "src/libcore/float.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -2,10 +2,29 @@\n Module: float\n */\n \n+// FIXME find out why these have to be exported explicitly\n+\n+export to_str_common, to_str_exact, to_str, from_str, min, max;\n+export add, sub, mul, div, rem, lt, le, gt, eq, eq, ne;\n+export is_positive, is_negative, is_nonpositive, is_nonnegative;\n+export is_zero, is_infinite, is_finite;\n+export NaN, is_NaN, infinity, neg_infinity;\n+export consts;\n+export logarithm;\n+export acos, asin, atan, atan2, cbrt, ceil, copysign, cos, cosh;\n+export erf, erfc, exp, expm1, exp2, abs, abs_sub;\n+export mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp;\n+export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n+export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n+\n+// export when m_float == c_double\n+\n+export j0, j1, jn, y0, y1, yn;\n+\n // PORT this must match in width according to architecture\n \n import m_float = f64;\n-import m_float::*;\n+import f64::*;\n \n type t = float;\n \n@@ -25,7 +44,7 @@ digits - The number of significant digits\n exact - Whether to enforce the exact number of significant digits\n */\n fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n-    if isNaN(num) { ret \"NaN\"; }\n+    if is_NaN(num) { ret \"NaN\"; }\n     let (num, accum) = num < 0.0 ? (-num, \"-\") : (num, \"\");\n     let trunc = num as uint;\n     let frac = num - (trunc as float);"}, {"sha": "aabc349938517bebea7df0a1cbf6976af0604e5b", "filename": "src/libstd/list.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -46,16 +46,10 @@ ls - The list to fold\n z - The initial value\n f - The function to apply\n */\n-fn foldl<copy T, copy U>(ls: list<U>, z: T, f: block(T, U) -> T) -> T {\n+fn foldl<copy T, U>(ls: list<U>, z: T, f: block(T, U) -> T) -> T {\n     let accum: T = z;\n-    let ls = ls;\n-    while true {\n-        alt ls {\n-          cons(hd, tl) { accum = f(accum, hd); ls = *tl; }\n-          nil. { break; }\n-        }\n-    }\n-    ret accum;\n+    iter(ls) {|elt| accum = f(accum, elt);}\n+    accum\n }\n \n /*\n@@ -123,9 +117,10 @@ Function: len\n \n Returns the length of a list\n */\n-fn len<copy T>(ls: list<T>) -> uint {\n-    fn count<T>(&&u: uint, _t: T) -> uint { ret u + 1u; }\n-    ret foldl(ls, 0u, bind count(_, _));\n+fn len<T>(ls: list<T>) -> uint {\n+    let count = 0u;\n+    iter(ls) {|_e| count += 1u;}\n+    count\n }\n \n /*\n@@ -169,15 +164,22 @@ Function: iter\n \n Iterate over a list\n */\n-fn iter<copy T>(l: list<T>, f: block(T)) {\n-    let cur = l;\n-    while cur != nil {\n-        alt cur {\n-          cons(hd, tl) {\n-            f(hd);\n-            cur = *tl;\n-          }\n+fn iter<T>(l: list<T>, f: block(T)) {\n+    alt l {\n+      cons(hd, tl) {\n+        f(hd);\n+        let cur = tl;\n+        while true {\n+            alt *cur {\n+              cons(hd, tl) {\n+                f(hd);\n+                cur = tl;\n+              }\n+              nil. { break; }\n+            }\n         }\n+      }\n+      nil. {}\n     }\n }\n "}, {"sha": "33f205cca7d7b4e8cc5bd5f85b3941afe038db46", "filename": "src/snapshots.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -1,3 +1,10 @@\n+S 2012-01-05 3eb3590\n+  winnt-i386 bfa10b10e65c953f900296e7d28c89fa50257808\n+  linux-i386 f3744aaba89ba8995b0e5f911c15822304507c70\n+  macos-i386 64e33d698ff4dfba56e69a5191698d7f50a97e2d\n+  linux-x86_64 80a5eb9fce7fcf6c61d46607c2d6a1669e50f96f\n+  macos-x86_64 5cab4f241407ae5d867855aa02c869cf7d65c8b5\n+\n S 2011-12-22 ccb5b6f\n   winnt-i386 35be60caa888246e9710bd34ccbbe8a322d3c6de\n   linux-i386 8f88a285fa86613e268503a310e32cb053c2e300"}, {"sha": "bc1357372b025c790ffe571fc2533e22dd6685fc", "filename": "src/test/compile-fail/alt-join.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-join.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -1,4 +1,3 @@\n-// error-pattern:unresolved name\n // a good test that we merge paths correctly in the presence of a\n // variable that's used before it's declared\n \n@@ -7,6 +6,6 @@ fn my_fail() -> ! { fail; }\n fn main() {\n     alt true { false { my_fail(); } true { } }\n \n-    log(debug, x);\n+    log(debug, x); //! ERROR unresolved name: x\n     let x: int;\n }"}, {"sha": "84ad2da4f4e84b538af0603898b5c643028310b3", "filename": "src/test/run-pass/block-arg-in-ternary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Frun-pass%2Fblock-arg-in-ternary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Frun-pass%2Fblock-arg-in-ternary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-ternary.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -1,6 +1,6 @@\n // Allow block arguments with ternary... why not, no chance of ambig.\n fn main() {\n     let v = [-1f, 1f];\n-    let foo = vec::any(v) { |e| float::negative(e) } ? true : false;\n+    let foo = vec::any(v) { |e| float::is_negative(e) } ? true : false;\n     assert foo;\n }"}, {"sha": "ebbcc65d1580acbb3b8039bb4577eb4e49b31eea", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -8,28 +8,28 @@ fn main() {\n     }\n \n     // Usable at all:\n-    let any_negative = vec::any(v) { |e| float::negative(e) };\n+    let any_negative = vec::any(v) { |e| float::is_negative(e) };\n     assert any_negative;\n \n     // Higher precedence than assignments:\n-    any_negative = vec::any(v) { |e| float::negative(e) };\n+    any_negative = vec::any(v) { |e| float::is_negative(e) };\n     assert any_negative;\n \n     // Higher precedence than unary operations:\n     let abs_v = vec::map(v) { |e| float::abs(e) };\n-    assert vec::all(abs_v) { |e| float::nonnegative(e) };\n-    assert !vec::any(abs_v) { |e| float::negative(e) };\n+    assert vec::all(abs_v) { |e| float::is_nonnegative(e) };\n+    assert !vec::any(abs_v) { |e| float::is_negative(e) };\n \n     // Usable in funny statement-like forms:\n-    if !vec::any(v) { |e| float::positive(e) } {\n+    if !vec::any(v) { |e| float::is_positive(e) } {\n         assert false;\n     }\n-    alt vec::all(v) { |e| float::negative(e) } {\n+    alt vec::all(v) { |e| float::is_negative(e) } {\n         true { fail \"incorrect answer.\"; }\n         false { }\n     }\n     alt 3 {\n-      _ when vec::any(v) { |e| float::negative(e) } {\n+      _ when vec::any(v) { |e| float::is_negative(e) } {\n       }\n       _ {\n         fail \"wrong answer.\";\n@@ -46,7 +46,7 @@ fn main() {\n \n     // They are not allowed as the tail of a block without parentheses:\n     let w =\n-      if true { vec::any(abs_v, { |e| float::nonnegative(e) }) }\n+      if true { vec::any(abs_v, { |e| float::is_nonnegative(e) }) }\n       else { false };\n     assert w;\n }"}, {"sha": "540beec1f7d589854b38b13e13e2471eb959afe7", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -3,7 +3,7 @@ import float;\n \n fn main() {\n   let nan = float::NaN;\n-  assert(float::isNaN(nan));\n+  assert(float::is_NaN(nan));\n \n   let inf = float::infinity;\n   assert(-inf == float::neg_infinity);\n@@ -61,22 +61,22 @@ fn main() {\n   assert(!(-inf < nan));\n   assert(!(-nan < nan));\n \n-  assert(float::isNaN(nan + inf));\n-  assert(float::isNaN(nan + -inf));\n-  assert(float::isNaN(nan + 0.));\n-  assert(float::isNaN(nan + 1.));\n-  assert(float::isNaN(nan * 1.));\n-  assert(float::isNaN(nan / 1.));\n-  assert(float::isNaN(nan / 0.));\n-  assert(float::isNaN(0. / 0.));\n-  assert(float::isNaN(-inf + inf));\n-  assert(float::isNaN(inf - inf));\n+  assert(float::is_NaN(nan + inf));\n+  assert(float::is_NaN(nan + -inf));\n+  assert(float::is_NaN(nan + 0.));\n+  assert(float::is_NaN(nan + 1.));\n+  assert(float::is_NaN(nan * 1.));\n+  assert(float::is_NaN(nan / 1.));\n+  assert(float::is_NaN(nan / 0.));\n+  assert(float::is_NaN(0. / 0.));\n+  assert(float::is_NaN(-inf + inf));\n+  assert(float::is_NaN(inf - inf));\n \n-  assert(!float::isNaN(-1.));\n-  assert(!float::isNaN(0.));\n-  assert(!float::isNaN(0.1));\n-  assert(!float::isNaN(1.));\n-  assert(!float::isNaN(inf));\n-  assert(!float::isNaN(-inf));\n-  assert(!float::isNaN(1./-inf));\n+  assert(!float::is_NaN(-1.));\n+  assert(!float::is_NaN(0.));\n+  assert(!float::is_NaN(0.1));\n+  assert(!float::is_NaN(1.));\n+  assert(!float::is_NaN(inf));\n+  assert(!float::is_NaN(-inf));\n+  assert(!float::is_NaN(1./-inf));\n }"}, {"sha": "3ac3d67b8346eaee1647f4aa2cd16a0596c4f4bc", "filename": "src/test/stdtest/float.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Fstdtest%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ad4e601834f1b28e58c1c0ba579c2972c9a27/src%2Ftest%2Fstdtest%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffloat.rs?ref=494ad4e601834f1b28e58c1c0ba579c2972c9a27", "patch": "@@ -26,60 +26,60 @@ fn test_from_str() {\n    assert ( float::from_str(\" -.5 \") == -0.5 );\n    assert ( float::from_str(\" -5 \") == -5. );\n \n-   assert ( float::isNaN(float::from_str(\"x\")) );\n+   assert ( float::is_NaN(float::from_str(\"x\")) );\n    assert ( float::from_str(\" \") == 0. );\n    assert ( float::from_str(\"   \") == 0. );\n    assert ( float::from_str(\" 0.5\") == 0.5 );\n    assert ( float::from_str(\" 0.5 \") == 0.5 );\n    assert ( float::from_str(\" .1 \") == 0.1 );\n-   assert ( float::isNaN(float::from_str(\"e\")) );\n-   assert ( float::isNaN(float::from_str(\"E\")) );\n-   assert ( float::isNaN(float::from_str(\"E1\")) );\n-   assert ( float::isNaN(float::from_str(\"1e1e1\")) );\n-   assert ( float::isNaN(float::from_str(\"1e1.1\")) );\n-   assert ( float::isNaN(float::from_str(\"1e1-1\")) );\n+   assert ( float::is_NaN(float::from_str(\"e\")) );\n+   assert ( float::is_NaN(float::from_str(\"E\")) );\n+   assert ( float::is_NaN(float::from_str(\"E1\")) );\n+   assert ( float::is_NaN(float::from_str(\"1e1e1\")) );\n+   assert ( float::is_NaN(float::from_str(\"1e1.1\")) );\n+   assert ( float::is_NaN(float::from_str(\"1e1-1\")) );\n }\n \n #[test]\n fn test_positive() {\n-  assert(float::positive(float::infinity));\n-  assert(float::positive(1.));\n-  assert(float::positive(0.));\n-  assert(!float::positive(-1.));\n-  assert(!float::positive(float::neg_infinity));\n-  assert(!float::positive(1./float::neg_infinity));\n-  assert(!float::positive(float::NaN));\n+  assert(float::is_positive(float::infinity));\n+  assert(float::is_positive(1.));\n+  assert(float::is_positive(0.));\n+  assert(!float::is_positive(-1.));\n+  assert(!float::is_positive(float::neg_infinity));\n+  assert(!float::is_positive(1./float::neg_infinity));\n+  assert(!float::is_positive(float::NaN));\n }\n \n #[test]\n fn test_negative() {\n-  assert(!float::negative(float::infinity));\n-  assert(!float::negative(1.));\n-  assert(!float::negative(0.));\n-  assert(float::negative(-1.));\n-  assert(float::negative(float::neg_infinity));\n-  assert(float::negative(1./float::neg_infinity));\n-  assert(!float::negative(float::NaN));\n+  assert(!float::is_negative(float::infinity));\n+  assert(!float::is_negative(1.));\n+  assert(!float::is_negative(0.));\n+  assert(float::is_negative(-1.));\n+  assert(float::is_negative(float::neg_infinity));\n+  assert(float::is_negative(1./float::neg_infinity));\n+  assert(!float::is_negative(float::NaN));\n }\n \n #[test]\n fn test_nonpositive() {\n-  assert(!float::nonpositive(float::infinity));\n-  assert(!float::nonpositive(1.));\n-  assert(!float::nonpositive(0.));\n-  assert(float::nonpositive(-1.));\n-  assert(float::nonpositive(float::neg_infinity));\n-  assert(float::nonpositive(1./float::neg_infinity));\n-  assert(!float::nonpositive(float::NaN));\n+  assert(!float::is_nonpositive(float::infinity));\n+  assert(!float::is_nonpositive(1.));\n+  assert(!float::is_nonpositive(0.));\n+  assert(float::is_nonpositive(-1.));\n+  assert(float::is_nonpositive(float::neg_infinity));\n+  assert(float::is_nonpositive(1./float::neg_infinity));\n+  assert(!float::is_nonpositive(float::NaN));\n }\n \n #[test]\n fn test_nonnegative() {\n-  assert(float::nonnegative(float::infinity));\n-  assert(float::nonnegative(1.));\n-  assert(float::nonnegative(0.));\n-  assert(!float::nonnegative(-1.));\n-  assert(!float::nonnegative(float::neg_infinity));\n-  assert(!float::nonnegative(1./float::neg_infinity));\n-  assert(!float::nonnegative(float::NaN));\n+  assert(float::is_nonnegative(float::infinity));\n+  assert(float::is_nonnegative(1.));\n+  assert(float::is_nonnegative(0.));\n+  assert(!float::is_nonnegative(-1.));\n+  assert(!float::is_nonnegative(float::neg_infinity));\n+  assert(!float::is_nonnegative(1./float::neg_infinity));\n+  assert(!float::is_nonnegative(float::NaN));\n }"}]}