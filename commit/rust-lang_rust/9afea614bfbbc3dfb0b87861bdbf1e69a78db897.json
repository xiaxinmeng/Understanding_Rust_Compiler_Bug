{"sha": "9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZmVhNjE0YmZiYmMzZGZiMGI4Nzg2MWJkYmYxZTY5YTc4ZGI4OTc=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-04-08T23:09:08Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-05-06T18:17:59Z"}, "message": "Add additional migrations to handle auto-traits and clone traits\nCombine all 2229 migrations under one flag name", "tree": {"sha": "12da27dba5739a0185c2b642bf17a6d6a1223956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12da27dba5739a0185c2b642bf17a6d6a1223956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "html_url": "https://github.com/rust-lang/rust/commit/9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "109248a4eb99bc83684c94ca4ef36f2fadc17e2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/109248a4eb99bc83684c94ca4ef36f2fadc17e2a", "html_url": "https://github.com/rust-lang/rust/commit/109248a4eb99bc83684c94ca4ef36f2fadc17e2a"}], "stats": {"total": 749, "additions": 666, "deletions": 83}, "files": [{"sha": "7b788b13b9f7d41aa197123f2f3398558e8adda0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -343,4 +343,7 @@ language_item_table! {\n     Range,                   sym::Range,               range_struct,               Target::Struct;\n     RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct;\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct;\n+    Send,                    sym::send,                send_trait,                 Target::Trait;\n+    UnwindSafe,              sym::unwind_safe,         unwind_safe_trait,          Target::Trait;\n+    RefUnwindSafe,           sym::ref_unwind_safe,     ref_unwind_safe_trait,      Target::Trait;\n }"}, {"sha": "15246971bae02e82175430a15b2b5f92a65ba82f", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -2995,7 +2995,7 @@ declare_lint_pass! {\n         UNSUPPORTED_NAKED_FUNCTIONS,\n         MISSING_ABI,\n         SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n-        DISJOINT_CAPTURE_DROP_REORDER,\n+        DISJOINT_CAPTURE_MIGRATION,\n         LEGACY_DERIVE_HELPERS,\n         PROC_MACRO_BACK_COMPAT,\n         OR_PATTERNS_BACK_COMPAT,\n@@ -3027,14 +3027,17 @@ declare_lint! {\n }\n \n declare_lint! {\n-    /// The `disjoint_capture_drop_reorder` lint detects variables that aren't completely\n+    /// The `disjoint_capture_migration` lint detects variables that aren't completely\n     /// captured when the feature `capture_disjoint_fields` is enabled and it affects the Drop\n     /// order of at least one path starting at this variable.\n+    /// It can also detect when a variable implements a trait, but one of its field does not and\n+    /// the field is captured by a closure and used with the assumption that said field implements\n+    /// the same trait as the root variable.\n     ///\n-    /// ### Example\n+    /// ### Example of drop reorder\n     ///\n     /// ```rust,compile_fail\n-    /// # #![deny(disjoint_capture_drop_reorder)]\n+    /// # #![deny(disjoint_capture_migration)]\n     /// # #![allow(unused)]\n     /// struct FancyInteger(i32);\n     ///\n@@ -3065,10 +3068,35 @@ declare_lint! {\n     ///\n     /// In the above example `p.y` will be dropped at the end of `f` instead of with `c` if\n     /// the feature `capture_disjoint_fields` is enabled.\n-    pub DISJOINT_CAPTURE_DROP_REORDER,\n+    ///\n+    /// ### Example of auto-trait\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(disjoint_capture_migration)]\n+    /// use std::thread;\n+    ///\n+    /// struct Pointer (*mut i32);\n+    /// unsafe impl Send for Pointer {}\n+    ///\n+    /// fn main() {\n+    ///     let mut f = 10;\n+    ///     let fptr = Pointer(&mut f as *mut i32);\n+    ///     thread::spawn(move || unsafe {\n+    ///         *fptr.0 = 20;\n+    ///     });\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the above example `fptr.0` is captured when feature `capture_disjoint_fields` is enabled.\n+    /// The field is of type *mut i32 which doesn't implement Send, making the code invalid as the\n+    /// field cannot be sent between thread safely.\n+    pub DISJOINT_CAPTURE_MIGRATION,\n     Allow,\n-    \"Drop reorder because of `capture_disjoint_fields`\"\n-\n+    \"Drop reorder and auto traits error because of `capture_disjoint_fields`\"\n }\n \n declare_lint_pass!(UnusedDocComment => [UNUSED_DOC_COMMENTS]);"}, {"sha": "6ba68fb767d61ae0a194d0f7455fa6899f4a89a0", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -933,6 +933,7 @@ symbols! {\n         receiver,\n         recursion_limit,\n         reexport_test_harness_main,\n+        ref_unwind_safe,\n         reference,\n         reflect,\n         reg,\n@@ -1054,6 +1055,7 @@ symbols! {\n         self_in_typedefs,\n         self_struct_ctor,\n         semitransparent,\n+        send,\n         send_trait,\n         shl,\n         shl_assign,\n@@ -1275,6 +1277,7 @@ symbols! {\n         unused_qualifications,\n         unwind,\n         unwind_attributes,\n+        unwind_safe,\n         unwrap,\n         unwrap_or,\n         use_extern_macros,"}, {"sha": "81c0010fd24d98b23142963f6b9bd7366e7a67f9", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 295, "deletions": 57, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -42,11 +42,13 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n use rustc_middle::mir::FakeReadCause;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n+use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n+use rustc_trait_selection::traits::{Obligation, ObligationCause};\n \n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_index::vec::Idx;\n use rustc_target::abi::VariantIdx;\n \n@@ -168,7 +170,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.compute_min_captures(closure_def_id, delegate.capture_information);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n-        if should_do_migration_analysis(self.tcx, closure_hir_id) {\n+\n+        if should_do_disjoint_capture_migration_analysis(self.tcx, closure_hir_id) {\n             self.perform_2229_migration_anaysis(closure_def_id, body_id, capture_clause, span);\n         }\n \n@@ -471,7 +474,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         capture_clause: hir::CaptureBy,\n         span: Span,\n     ) {\n-        let need_migrations = self.compute_2229_migrations(\n+        let (need_migrations, reasons) = self.compute_2229_migrations(\n             closure_def_id,\n             span,\n             capture_clause,\n@@ -485,12 +488,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let local_def_id = closure_def_id.expect_local();\n             let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n             self.tcx.struct_span_lint_hir(\n-                lint::builtin::DISJOINT_CAPTURE_DROP_REORDER,\n+                lint::builtin::DISJOINT_CAPTURE_MIGRATION,\n                 closure_hir_id,\n                 span,\n                 |lint| {\n                     let mut diagnostics_builder = lint.build(\n-                        \"drop order affected for closure because of `capture_disjoint_fields`\",\n+                        format!(\n+                            \"{} affected for closure because of `capture_disjoint_fields`\",\n+                            reasons\n+                        )\n+                        .as_str(),\n                     );\n                     let closure_body_span = self.tcx.hir().span(body_id.hir_id);\n                     let (sugg, app) =\n@@ -527,6 +534,188 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Combines all the reasons for 2229 migrations\n+    fn compute_2229_migrations_reasons(\n+        &self,\n+        auto_trait_reasons: FxHashSet<&str>,\n+        drop_reason: bool,\n+    ) -> String {\n+        let mut reasons = String::new();\n+\n+        if auto_trait_reasons.len() > 0 {\n+            reasons = format!(\n+                \"{} trait implementation\",\n+                auto_trait_reasons.clone().into_iter().collect::<Vec<&str>>().join(\", \")\n+            );\n+        }\n+\n+        if auto_trait_reasons.len() > 0 && drop_reason {\n+            reasons = format!(\"{}, and \", reasons);\n+        }\n+\n+        if drop_reason {\n+            reasons = format!(\"{}drop order\", reasons);\n+        }\n+\n+        reasons\n+    }\n+\n+    fn ty_contains_trait(\n+        &self,\n+        ty: Ty<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        trait_def_id: DefId,\n+    ) -> bool {\n+        use crate::rustc_middle::ty::ToPredicate;\n+        use crate::rustc_middle::ty::WithConstness;\n+        use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+        let tcx = self.infcx.tcx;\n+\n+        let trait_ref = TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n+\n+        let obligation = Obligation::new(\n+            cause.clone(),\n+            self.param_env,\n+            trait_ref.without_const().to_predicate(tcx),\n+        );\n+\n+        self.infcx.predicate_may_hold(&obligation)\n+    }\n+\n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and auto-traits\n+    /// differ between the root variable and the captured paths.\n+    ///\n+    /// The output list would include a root variable if:\n+    /// - It would have been captured into the closure when `capture_disjoint_fields` wasn't\n+    ///   enabled, **and**\n+    /// - It wasn't completely captured by the closure, **and**\n+    /// - One of the paths captured does not implement all the auto-traits its root variable\n+    ///   implements.\n+    fn compute_2229_migrations_for_trait(\n+        &self,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+        _closure_clause: hir::CaptureBy,\n+        var_hir_id: hir::HirId,\n+    ) -> Option<FxHashSet<&str>> {\n+        let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n+            min_captures.and_then(|m| m.get(&var_hir_id))\n+        {\n+            root_var_min_capture_list\n+        } else {\n+            return None;\n+        };\n+\n+        let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n+\n+        let tcx = self.infcx.tcx;\n+\n+        let cause = ObligationCause::misc(self.tcx.hir().span(var_hir_id), self.body_id);\n+\n+        let clone_obligation_should_hold = tcx\n+            .lang_items()\n+            .clone_trait()\n+            .map(|clone_trait| self.ty_contains_trait(ty, &cause, clone_trait))\n+            .unwrap_or(false);\n+        let sync_obligation_should_hold = tcx\n+            .lang_items()\n+            .sync_trait()\n+            .map(|sync_trait| self.ty_contains_trait(ty, &cause, sync_trait))\n+            .unwrap_or(false);\n+        let send_obligation_should_hold = tcx\n+            .lang_items()\n+            .send_trait()\n+            .map(|send_trait| self.ty_contains_trait(ty, &cause, send_trait))\n+            .unwrap_or(false);\n+        let unpin_obligation_should_hold = tcx\n+            .lang_items()\n+            .unpin_trait()\n+            .map(|unpin_trait| self.ty_contains_trait(ty, &cause, unpin_trait))\n+            .unwrap_or(false);\n+        let unwind_safe_obligation_should_hold = tcx\n+            .lang_items()\n+            .unwind_safe_trait()\n+            .map(|unwind_safe_trait| self.ty_contains_trait(ty, &cause, unwind_safe_trait))\n+            .unwrap_or(false);\n+        let ref_unwind_safe_obligation_should_hold = tcx\n+            .lang_items()\n+            .ref_unwind_safe_trait()\n+            .map(|ref_unwind_safe_trait| self.ty_contains_trait(ty, &cause, ref_unwind_safe_trait))\n+            .unwrap_or(false);\n+\n+        // Check whether catpured fields also implement the trait\n+        let mut auto_trait_reasons = FxHashSet::default();\n+\n+        for capture in root_var_min_capture_list.iter() {\n+            let ty = capture.place.ty();\n+\n+            let clone_obligation_holds_for_capture = tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map(|clone_trait| self.ty_contains_trait(ty, &cause, clone_trait))\n+                .unwrap_or(false);\n+            let sync_obligation_holds_for_capture = tcx\n+                .lang_items()\n+                .sync_trait()\n+                .map(|sync_trait| self.ty_contains_trait(ty, &cause, sync_trait))\n+                .unwrap_or(false);\n+            let send_obligation_holds_for_capture = tcx\n+                .lang_items()\n+                .send_trait()\n+                .map(|send_trait| self.ty_contains_trait(ty, &cause, send_trait))\n+                .unwrap_or(false);\n+            let unpin_obligation_holds_for_capture = tcx\n+                .lang_items()\n+                .unpin_trait()\n+                .map(|unpin_trait| self.ty_contains_trait(ty, &cause, unpin_trait))\n+                .unwrap_or(false);\n+            let unwind_safe_obligation_holds_for_capture = tcx\n+                .lang_items()\n+                .unwind_safe_trait()\n+                .map(|unwind_safe| self.ty_contains_trait(ty, &cause, unwind_safe))\n+                .unwrap_or(false);\n+            let ref_unwind_safe_obligation_holds_for_capture = tcx\n+                .lang_items()\n+                .ref_unwind_safe_trait()\n+                .map(|ref_unwind_safe_trait| {\n+                    self.ty_contains_trait(ty, &cause, ref_unwind_safe_trait)\n+                })\n+                .unwrap_or(false);\n+\n+            if !clone_obligation_holds_for_capture && clone_obligation_should_hold {\n+                auto_trait_reasons.insert(\"`Clone`\");\n+            }\n+\n+            if !sync_obligation_holds_for_capture && sync_obligation_should_hold {\n+                auto_trait_reasons.insert(\"`Sync`\");\n+            }\n+\n+            if !send_obligation_holds_for_capture && send_obligation_should_hold {\n+                auto_trait_reasons.insert(\"`Send`\");\n+            }\n+\n+            if !unpin_obligation_holds_for_capture && unpin_obligation_should_hold {\n+                auto_trait_reasons.insert(\"`Unpin`\");\n+            }\n+\n+            if !unwind_safe_obligation_holds_for_capture && unwind_safe_obligation_should_hold {\n+                auto_trait_reasons.insert(\"`UnwindSafe`\");\n+            }\n+\n+            if !ref_unwind_safe_obligation_holds_for_capture\n+                && ref_unwind_safe_obligation_should_hold\n+            {\n+                auto_trait_reasons.insert(\"`RefUnwindSafe`\");\n+            }\n+        }\n+\n+        if auto_trait_reasons.len() > 0 {\n+            return Some(auto_trait_reasons);\n+        }\n+\n+        return None;\n+    }\n+\n     /// Figures out the list of root variables (and their types) that aren't completely\n     /// captured by the closure when `capture_disjoint_fields` is enabled and drop order of\n     /// some path starting at that root variable **might** be affected.\n@@ -536,76 +725,126 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///   enabled, **and**\n     /// - It wasn't completely captured by the closure, **and**\n     /// - One of the paths starting at this root variable, that is not captured needs Drop.\n-    fn compute_2229_migrations(\n+    fn compute_2229_migrations_for_drop(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n-        closure_clause: hir::CaptureBy,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> Vec<hir::HirId> {\n-        let upvars = if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-            upvars\n-        } else {\n-            return vec![];\n-        };\n+        closure_clause: hir::CaptureBy,\n+        var_hir_id: hir::HirId,\n+    ) -> Option<()> {\n+        let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n-        let mut need_migrations = Vec::new();\n+        if !ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+            return None;\n+        }\n \n-        for (&var_hir_id, _) in upvars.iter() {\n-            let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n+        let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n+            min_captures.and_then(|m| m.get(&var_hir_id))\n+        {\n+            root_var_min_capture_list\n+        } else {\n+            // The upvar is mentioned within the closure but no path starting from it is\n+            // used.\n \n-            if !ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n-                continue;\n+            match closure_clause {\n+                // Only migrate if closure is a move closure\n+                hir::CaptureBy::Value => return Some(()),\n+                hir::CaptureBy::Ref => {}\n             }\n \n-            let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n-                min_captures.and_then(|m| m.get(&var_hir_id))\n-            {\n-                root_var_min_capture_list\n-            } else {\n-                // The upvar is mentioned within the closure but no path starting from it is\n-                // used.\n+            return None;\n+        };\n \n-                match closure_clause {\n-                    // Only migrate if closure is a move closure\n-                    hir::CaptureBy::Value => need_migrations.push(var_hir_id),\n+        let projections_list = root_var_min_capture_list\n+            .iter()\n+            .filter_map(|captured_place| match captured_place.info.capture_kind {\n+                // Only care about captures that are moved into the closure\n+                ty::UpvarCapture::ByValue(..) => Some(captured_place.place.projections.as_slice()),\n+                ty::UpvarCapture::ByRef(..) => None,\n+            })\n+            .collect::<Vec<_>>();\n \n-                    hir::CaptureBy::Ref => {}\n-                }\n+        let is_moved = !projections_list.is_empty();\n \n-                continue;\n-            };\n+        let is_not_completely_captured =\n+            root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n \n-            let projections_list = root_var_min_capture_list\n-                .iter()\n-                .filter_map(|captured_place| match captured_place.info.capture_kind {\n-                    // Only care about captures that are moved into the closure\n-                    ty::UpvarCapture::ByValue(..) => {\n-                        Some(captured_place.place.projections.as_slice())\n-                    }\n-                    ty::UpvarCapture::ByRef(..) => None,\n-                })\n-                .collect::<Vec<_>>();\n+        if is_moved\n+            && is_not_completely_captured\n+            && self.has_significant_drop_outside_of_captures(\n+                closure_def_id,\n+                closure_span,\n+                ty,\n+                projections_list,\n+            )\n+        {\n+            return Some(());\n+        }\n \n-            let is_moved = !projections_list.is_empty();\n+        return None;\n+    }\n \n-            let is_not_completely_captured =\n-                root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and either drop\n+    /// order of some path starting at that root variable **might** be affected or auto-traits\n+    /// differ between the root variable and the captured paths.\n+    ///\n+    /// The output list would include a root variable if:\n+    /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n+    ///   enabled, **and**\n+    /// - It wasn't completely captured by the closure, **and**\n+    /// - One of the paths starting at this root variable, that is not captured needs Drop **or**\n+    /// - One of the paths captured does not implement all the auto-traits its root variable\n+    ///   implements.\n+    fn compute_2229_migrations(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        closure_clause: hir::CaptureBy,\n+        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n+    ) -> (Vec<hir::HirId>, String) {\n+        let upvars = if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+            upvars\n+        } else {\n+            return (Vec::new(), format!(\"\"));\n+        };\n \n-            if is_moved\n-                && is_not_completely_captured\n-                && self.has_significant_drop_outside_of_captures(\n-                    closure_def_id,\n-                    closure_span,\n-                    ty,\n-                    projections_list,\n-                )\n+        let mut need_migrations = Vec::new();\n+        let mut auto_trait_reasons = FxHashSet::default();\n+        let mut drop_reorder_reason = false;\n+\n+        // Perform auto-trait analysis\n+        for (&var_hir_id, _) in upvars.iter() {\n+            // println!(\"CHeck auto traits\");\n+            let mut need_some_migrations = false;\n+            if let Some(trait_migration_cause) =\n+                self.compute_2229_migrations_for_trait(min_captures, closure_clause, var_hir_id)\n             {\n+                need_some_migrations = true;\n+                auto_trait_reasons.extend(trait_migration_cause);\n+            }\n+\n+            if let Some(_) = self.compute_2229_migrations_for_drop(\n+                closure_def_id,\n+                closure_span,\n+                min_captures,\n+                closure_clause,\n+                var_hir_id,\n+            ) {\n+                need_some_migrations = true;\n+                drop_reorder_reason = true;\n+            }\n+\n+            if need_some_migrations {\n                 need_migrations.push(var_hir_id);\n             }\n         }\n \n-        need_migrations\n+        (\n+            need_migrations,\n+            self.compute_2229_migrations_reasons(auto_trait_reasons, drop_reorder_reason),\n+        )\n     }\n \n     /// This is a helper function to `compute_2229_migrations_precise_pass`. Provided the type\n@@ -1544,9 +1783,8 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n-fn should_do_migration_analysis(tcx: TyCtxt<'_>, closure_id: hir::HirId) -> bool {\n-    let (level, _) =\n-        tcx.lint_level_at_node(lint::builtin::DISJOINT_CAPTURE_DROP_REORDER, closure_id);\n+fn should_do_disjoint_capture_migration_analysis(tcx: TyCtxt<'_>, closure_id: hir::HirId) -> bool {\n+    let (level, _) = tcx.lint_level_at_node(lint::builtin::DISJOINT_CAPTURE_MIGRATION, closure_id);\n \n     !matches!(level, lint::Level::Allow)\n }"}, {"sha": "2b2404550433ddb6bb9eca9a1ff20d61885e5e35", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -31,6 +31,7 @@ use crate::hash::Hasher;\n /// [ub]: ../../reference/behavior-considered-undefined.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"send_trait\")]\n+#[cfg_attr(not(bootstrap), lang = \"send\")]\n #[rustc_on_unimplemented(\n     message = \"`{Self}` cannot be sent between threads safely\",\n     label = \"`{Self}` cannot be sent between threads safely\""}, {"sha": "0442f70aa65233c846b41d426b80cca36504e154", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -132,6 +132,7 @@ pub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {\n /// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n /// implemented for any closed over variables passed to `catch_unwind`.\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"unwind_safe\")]\n #[rustc_on_unimplemented(\n     message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n     label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n@@ -147,6 +148,7 @@ pub auto trait UnwindSafe {}\n /// This is a \"helper marker trait\" used to provide impl blocks for the\n /// [`UnwindSafe`] trait, for more information see that documentation.\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"ref_unwind_safe\")]\n #[rustc_on_unimplemented(\n     message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n                transferrable across a catch_unwind boundary\","}, {"sha": "fcefbdc425c47f9ee5c80ad6a81241c6f91b4dfb", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -0,0 +1,67 @@\n+// run-rustfix\n+#![deny(disjoint_capture_migration)]\n+\n+use std::thread;\n+\n+/* Test Send Trait */\n+struct SendPointer (*mut i32);\n+unsafe impl Send for SendPointer {}\n+\n+fn test_send_trait() {\n+    let mut f = 10;\n+    let fptr = SendPointer(&mut f as *mut i32);\n+    thread::spawn(move || { let _ = &fptr; unsafe {\n+        //~^ ERROR: `Send` trait implementation affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `fptr` to be fully captured\n+        *fptr.0 = 20;\n+    } });\n+}\n+\n+/* Test Sync Trait */\n+struct CustomInt (*mut i32);\n+struct SyncPointer (CustomInt);\n+unsafe impl Sync for SyncPointer {}\n+unsafe impl Send for CustomInt {}\n+\n+fn test_sync_trait() {\n+    let mut f = 10;\n+    let f = CustomInt(&mut f as *mut i32);\n+    let fptr = SyncPointer(f);\n+    thread::spawn(move || { let _ = &fptr; unsafe {\n+        //~^ ERROR: `Sync`, `Send` trait implementation affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `fptr` to be fully captured\n+        *fptr.0.0 = 20;\n+    } });\n+}\n+\n+/* Test Clone Trait */\n+struct S(String);\n+struct T(i32);\n+\n+struct U(S,T);\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self {\n+        U(S(String::from(\"Hello World\")), T(0))\n+    }\n+}\n+\n+fn test_clone_trait() {\n+    let f = U(S(String::from(\"Hello World\")), T(0));\n+    let c = || { let _ = &f; \n+        //~^ ERROR: `Clone` trait implementation, and drop order affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `f` to be fully captured\n+        let f_1 = f.1;\n+        println!(\"{:?}\", f_1.0);\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+\n+fn main() {\n+    test_send_trait();\n+    test_sync_trait();\n+    test_clone_trait();\n+}"}, {"sha": "3babff1948b0b0e81cded450a4fb754fd7964e31", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -0,0 +1,67 @@\n+// run-rustfix\n+#![deny(disjoint_capture_migration)]\n+\n+use std::thread;\n+\n+/* Test Send Trait */\n+struct SendPointer (*mut i32);\n+unsafe impl Send for SendPointer {}\n+\n+fn test_send_trait() {\n+    let mut f = 10;\n+    let fptr = SendPointer(&mut f as *mut i32);\n+    thread::spawn(move || unsafe {\n+        //~^ ERROR: `Send` trait implementation affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `fptr` to be fully captured\n+        *fptr.0 = 20;\n+    });\n+}\n+\n+/* Test Sync Trait */\n+struct CustomInt (*mut i32);\n+struct SyncPointer (CustomInt);\n+unsafe impl Sync for SyncPointer {}\n+unsafe impl Send for CustomInt {}\n+\n+fn test_sync_trait() {\n+    let mut f = 10;\n+    let f = CustomInt(&mut f as *mut i32);\n+    let fptr = SyncPointer(f);\n+    thread::spawn(move || unsafe {\n+        //~^ ERROR: `Sync`, `Send` trait implementation affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `fptr` to be fully captured\n+        *fptr.0.0 = 20;\n+    });\n+}\n+\n+/* Test Clone Trait */\n+struct S(String);\n+struct T(i32);\n+\n+struct U(S,T);\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self {\n+        U(S(String::from(\"Hello World\")), T(0))\n+    }\n+}\n+\n+fn test_clone_trait() {\n+    let f = U(S(String::from(\"Hello World\")), T(0));\n+    let c = || {\n+        //~^ ERROR: `Clone` trait implementation, and drop order affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `f` to be fully captured\n+        let f_1 = f.1;\n+        println!(\"{:?}\", f_1.0);\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+\n+fn main() {\n+    test_send_trait();\n+    test_sync_trait();\n+    test_clone_trait();\n+}"}, {"sha": "6e3723b8bdb20da46fa839f90a35501b76fe54be", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -0,0 +1,69 @@\n+error: `Send` trait implementation affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/auto_traits.rs:13:19\n+   |\n+LL |       thread::spawn(move || unsafe {\n+   |  ___________________^\n+LL | |\n+LL | |\n+LL | |         *fptr.0 = 20;\n+LL | |     });\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/auto_traits.rs:2:9\n+   |\n+LL | #![deny(disjoint_capture_migration)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: add a dummy let to cause `fptr` to be fully captured\n+   |\n+LL |     thread::spawn(move || { let _ = &fptr; unsafe {\n+LL |\n+LL |\n+LL |         *fptr.0 = 20;\n+LL |     } });\n+   |\n+\n+error: `Sync`, `Send` trait implementation affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/auto_traits.rs:30:19\n+   |\n+LL |       thread::spawn(move || unsafe {\n+   |  ___________________^\n+LL | |\n+LL | |\n+LL | |         *fptr.0.0 = 20;\n+LL | |     });\n+   | |_____^\n+   |\n+help: add a dummy let to cause `fptr` to be fully captured\n+   |\n+LL |     thread::spawn(move || { let _ = &fptr; unsafe {\n+LL |\n+LL |\n+LL |         *fptr.0.0 = 20;\n+LL |     } });\n+   |\n+\n+error: `Clone` trait implementation, and drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/auto_traits.rs:51:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let f_1 = f.1;\n+LL | |         println!(\"{:?}\", f_1.0);\n+LL | |     };\n+   | |_____^\n+   |\n+help: add a dummy let to cause `f` to be fully captured\n+   |\n+LL |     let c = || { let _ = &f; \n+LL |\n+LL |\n+LL |         let f_1 = f.1;\n+LL |         println!(\"{:?}\", f_1.0);\n+LL |     };\n+   |\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "3770e93239a8efde54d3a754109eee92b0667d20", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n //~^ NOTE: the lint level is defined here\n \n // Test cases for types that implement a insignificant drop (stlib defined)"}, {"sha": "2015ab7e9b8cb5b5bb52a2243960b2d84034dfcc", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n //~^ NOTE: the lint level is defined here\n \n // Test cases for types that implement a insignificant drop (stlib defined)"}, {"sha": "69a99f7a53a53a30ff483a6b1d06a405cb1b20fd", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -14,8 +14,8 @@ LL | |     };\n note: the lint level is defined here\n   --> $DIR/insignificant_drop.rs:3:9\n    |\n-LL | #![deny(disjoint_capture_drop_reorder)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(disjoint_capture_migration)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n    |\n LL |     let c = || { let _ = (&t, &t1, &t2); "}, {"sha": "ee3138ea69ee8ac6bb65080b7ad5a4c2e13589fc", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/issue-78720.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-78720.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-78720.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fissue-78720.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-#![warn(disjoint_capture_drop_reorder)]\n+#![warn(disjoint_capture_migration)]\n \n fn main() {\n     if let a = \"\" {"}, {"sha": "979c023fc53ace02c460c10ed526bda026266289", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n //~^ NOTE: the lint level is defined here\n \n // Test the two possible cases for automated migartion using rustfix"}, {"sha": "c2a700bd9caa00be1e8b379d7bd29792eec315c3", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n //~^ NOTE: the lint level is defined here\n \n // Test the two possible cases for automated migartion using rustfix"}, {"sha": "a968d3a093b154b40b219bdb15eee8a723424128", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -12,8 +12,8 @@ LL | |     };\n note: the lint level is defined here\n   --> $DIR/migrations_rustfix.rs:2:9\n    |\n-LL | #![deny(disjoint_capture_drop_reorder)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(disjoint_capture_migration)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: add a dummy let to cause `t` to be fully captured\n    |\n LL |     let c = || { let _ = &t; "}, {"sha": "95463a62185e96f9e6d5b5862a757c4abb5a5605", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.fixed", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -0,0 +1,39 @@\n+// run-rustfix\n+\n+#![deny(disjoint_capture_migration)]\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![feature(fn_traits)]\n+#![feature(never_type)]\n+\n+use std::panic;\n+\n+fn foo_diverges() -> ! { panic!() }\n+\n+fn assert_panics<F>(f: F) where F: FnOnce() {\n+    let f = panic::AssertUnwindSafe(f);\n+    let result = panic::catch_unwind(move || { let _ = &f; \n+        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `f` to be fully captured\n+        f.0()\n+    });\n+    if let Ok(..) = result {\n+        panic!(\"diverging function returned\");\n+    }\n+}\n+\n+fn test_fn_ptr_panic<T>(mut t: T)\n+    where T: Fn() -> !\n+{\n+    let as_fn = <T as Fn<()>>::call;\n+    assert_panics(|| as_fn(&t, ()));\n+    let as_fn_mut = <T as FnMut<()>>::call_mut;\n+    assert_panics(|| as_fn_mut(&mut t, ()));\n+    let as_fn_once = <T as FnOnce<()>>::call_once;\n+    assert_panics(|| as_fn_once(t, ()));\n+}\n+\n+fn main() {\n+    test_fn_ptr_panic(foo_diverges);\n+    test_fn_ptr_panic(foo_diverges as fn() -> !);\n+}"}, {"sha": "fae7fc87c0285e91936eda44ca7cc693854b9763", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -0,0 +1,39 @@\n+// run-rustfix\n+\n+#![deny(disjoint_capture_migration)]\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![feature(fn_traits)]\n+#![feature(never_type)]\n+\n+use std::panic;\n+\n+fn foo_diverges() -> ! { panic!() }\n+\n+fn assert_panics<F>(f: F) where F: FnOnce() {\n+    let f = panic::AssertUnwindSafe(f);\n+    let result = panic::catch_unwind(move || {\n+        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation affected for closure because of `capture_disjoint_fields`\n+        //~| HELP: add a dummy let to cause `f` to be fully captured\n+        f.0()\n+    });\n+    if let Ok(..) = result {\n+        panic!(\"diverging function returned\");\n+    }\n+}\n+\n+fn test_fn_ptr_panic<T>(mut t: T)\n+    where T: Fn() -> !\n+{\n+    let as_fn = <T as Fn<()>>::call;\n+    assert_panics(|| as_fn(&t, ()));\n+    let as_fn_mut = <T as FnMut<()>>::call_mut;\n+    assert_panics(|| as_fn_mut(&mut t, ()));\n+    let as_fn_once = <T as FnOnce<()>>::call_once;\n+    assert_panics(|| as_fn_once(t, ()));\n+}\n+\n+fn main() {\n+    test_fn_ptr_panic(foo_diverges);\n+    test_fn_ptr_panic(foo_diverges as fn() -> !);\n+}"}, {"sha": "bbc8eb9a9cd25064c3899e61f9dee5da66d8b096", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -0,0 +1,27 @@\n+error: `UnwindSafe`, `RefUnwindSafe` trait implementation affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/mir_calls_to_shims.rs:15:38\n+   |\n+LL |       let result = panic::catch_unwind(move || {\n+   |  ______________________________________^\n+LL | |\n+LL | |\n+LL | |         f.0()\n+LL | |     });\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/mir_calls_to_shims.rs:3:9\n+   |\n+LL | #![deny(disjoint_capture_migration)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: add a dummy let to cause `f` to be fully captured\n+   |\n+LL |     let result = panic::catch_unwind(move || { let _ = &f; \n+LL |\n+LL |\n+LL |         f.0()\n+LL |     });\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "420d66fba5e306015460b1fa296755f1c98b71a8", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/no_migrations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fno_migrations.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -2,7 +2,7 @@\n \n // Set of test cases that don't need migrations\n \n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n \n \n // Copy types as copied by the closure instead of being moved into the closure"}, {"sha": "5c93fce92507b8c07dcada0e834ef434559c38f8", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n \n #[derive(Debug)]\n struct Foo(i32);"}, {"sha": "fb4af00aa06166b2b9f9cd777ad70fbaec4493e4", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n \n #[derive(Debug)]\n struct Foo(i32);"}, {"sha": "0cd191e2c98c5a3c9c40db94615b81de1d461b9f", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -13,8 +13,8 @@ LL | |     };\n note: the lint level is defined here\n   --> $DIR/precise.rs:3:9\n    |\n-LL | #![deny(disjoint_capture_drop_reorder)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(disjoint_capture_migration)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: add a dummy let to cause `t` to be fully captured\n    |\n LL |     let c = || { let _ = &t; "}, {"sha": "e3a7220bf09d239fe0e0555bee613fd7946a70f8", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise_no_migrations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n \n #[derive(Debug)]\n struct Foo(i32);"}, {"sha": "1fa0fb3db2f8d9d779dcc182baf812f765d2e0a1", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n //~^ NOTE: the lint level is defined here\n \n // Test cases for types that implement a significant drop (user defined)"}, {"sha": "1f0efbe1ebc43313664dcefa08c6bd755db1e3a4", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(disjoint_capture_drop_reorder)]\n+#![deny(disjoint_capture_migration)]\n //~^ NOTE: the lint level is defined here\n \n // Test cases for types that implement a significant drop (user defined)"}, {"sha": "91e75ffb81a96217e392fad1e8592846962c2935", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9afea614bfbbc3dfb0b87861bdbf1e69a78db897/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=9afea614bfbbc3dfb0b87861bdbf1e69a78db897", "patch": "@@ -14,8 +14,8 @@ LL | |     };\n note: the lint level is defined here\n   --> $DIR/significant_drop.rs:2:9\n    |\n-LL | #![deny(disjoint_capture_drop_reorder)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(disjoint_capture_migration)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n    |\n LL |     let c = || { let _ = (&t, &t1, &t2); "}]}