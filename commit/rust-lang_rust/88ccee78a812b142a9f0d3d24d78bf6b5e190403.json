{"sha": "88ccee78a812b142a9f0d3d24d78bf6b5e190403", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Y2NlZTc4YTgxMmIxNDJhOWYwZDNkMjRkNzhiZjZiNWUxOTA0MDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-23T17:36:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-23T17:36:50Z"}, "message": "auto merge of #6022 : catamorphism/rust/warning-police, r=catamorphism", "tree": {"sha": "8a19cfca03174fb4abf610c4b6fce4612b1c7cd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a19cfca03174fb4abf610c4b6fce4612b1c7cd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88ccee78a812b142a9f0d3d24d78bf6b5e190403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88ccee78a812b142a9f0d3d24d78bf6b5e190403", "html_url": "https://github.com/rust-lang/rust/commit/88ccee78a812b142a9f0d3d24d78bf6b5e190403", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88ccee78a812b142a9f0d3d24d78bf6b5e190403/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cadcc47ee0413bdb1b52a594fbed3a3cae75705", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cadcc47ee0413bdb1b52a594fbed3a3cae75705", "html_url": "https://github.com/rust-lang/rust/commit/8cadcc47ee0413bdb1b52a594fbed3a3cae75705"}, {"sha": "7169907e9f2b0c335b20251c7b4e2aaeb59091d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7169907e9f2b0c335b20251c7b4e2aaeb59091d8", "html_url": "https://github.com/rust-lang/rust/commit/7169907e9f2b0c335b20251c7b4e2aaeb59091d8"}], "stats": {"total": 642, "additions": 312, "deletions": 330}, "files": [{"sha": "26950986f7a09c642a9869cecbfb6953cf56317e", "filename": "src/libcore/rt/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fstdio.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -17,9 +17,9 @@ pub fn stdout() -> StdWriter { fail!() }\n \n pub fn stderr() -> StdReader { fail!() }\n \n-pub fn print(s: &str) { fail!() }\n+pub fn print(_s: &str) { fail!() }\n \n-pub fn println(s: &str) { fail!() }\n+pub fn println(_s: &str) { fail!() }\n \n pub enum StdStream {\n     StdIn,"}, {"sha": "7bf1792baf49b8270aeda30c402a865034cd5c04", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -11,7 +11,7 @@\n use option::*;\n use result::*;\n \n-use super::io::net::ip::{IpAddr, Ipv4};\n+use super::io::net::ip::{IpAddr, Ipv4}; // n.b. Ipv4 is used only in tests\n use super::uv::*;\n use super::rtio::*;\n use ops::Drop;"}, {"sha": "43fdee67b7a8555163a8ae687bac8f8a77af4879", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -549,7 +549,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n     }\n }\n \n-fn spawn_raw_newsched(opts: TaskOpts, f: ~fn()) {\n+fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n     let mut sched = local_sched::take();"}, {"sha": "460da76500428e2358676c17652f8247f3e83cfb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -247,7 +247,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n     }\n }\n \n-pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n+pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }"}, {"sha": "5d5169a5181dc12251a414fff9d7a0ba35ecb1a0", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -279,28 +279,28 @@ fn parse_trait_ref(st: @mut PState, conv: conv_did) -> ty::TraitRef {\n \n fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n-      'n' => return ty::mk_nil(st.tcx),\n-      'z' => return ty::mk_bot(st.tcx),\n-      'b' => return ty::mk_bool(st.tcx),\n-      'i' => return ty::mk_int(st.tcx),\n-      'u' => return ty::mk_uint(st.tcx),\n-      'l' => return ty::mk_float(st.tcx),\n+      'n' => return ty::mk_nil(),\n+      'z' => return ty::mk_bot(),\n+      'b' => return ty::mk_bool(),\n+      'i' => return ty::mk_int(),\n+      'u' => return ty::mk_uint(),\n+      'l' => return ty::mk_float(),\n       'M' => {\n         match next(st) {\n-          'b' => return ty::mk_mach_uint(st.tcx, ast::ty_u8),\n-          'w' => return ty::mk_mach_uint(st.tcx, ast::ty_u16),\n-          'l' => return ty::mk_mach_uint(st.tcx, ast::ty_u32),\n-          'd' => return ty::mk_mach_uint(st.tcx, ast::ty_u64),\n-          'B' => return ty::mk_mach_int(st.tcx, ast::ty_i8),\n-          'W' => return ty::mk_mach_int(st.tcx, ast::ty_i16),\n-          'L' => return ty::mk_mach_int(st.tcx, ast::ty_i32),\n-          'D' => return ty::mk_mach_int(st.tcx, ast::ty_i64),\n-          'f' => return ty::mk_mach_float(st.tcx, ast::ty_f32),\n-          'F' => return ty::mk_mach_float(st.tcx, ast::ty_f64),\n+          'b' => return ty::mk_mach_uint(ast::ty_u8),\n+          'w' => return ty::mk_mach_uint(ast::ty_u16),\n+          'l' => return ty::mk_mach_uint(ast::ty_u32),\n+          'd' => return ty::mk_mach_uint(ast::ty_u64),\n+          'B' => return ty::mk_mach_int(ast::ty_i8),\n+          'W' => return ty::mk_mach_int(ast::ty_i16),\n+          'L' => return ty::mk_mach_int(ast::ty_i32),\n+          'D' => return ty::mk_mach_int(ast::ty_i64),\n+          'f' => return ty::mk_mach_float(ast::ty_f32),\n+          'F' => return ty::mk_mach_float(ast::ty_f64),\n           _ => fail!(~\"parse_ty: bad numeric type\")\n         }\n       }\n-      'c' => return ty::mk_char(st.tcx),\n+      'c' => return ty::mk_char(),\n       't' => {\n         assert!((next(st) == '['));\n         let def = parse_def(st, NominalType, conv);"}, {"sha": "04d47bf5d06d454136b4c753345d39773d28aeff", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -211,7 +211,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     let real_pat = match m.find(|r| r[0].id != 0) {\n       Some(r) => r[0], None => v[0]\n     };\n-    let left_ty = if real_pat.id == 0 { ty::mk_nil(cx.tcx) }\n+    let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n                   else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n \n     match pat_ctor_id(cx, v[0]) {"}, {"sha": "1696e5566e223adbcb53f8fcf0d26a631eb64291", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -749,7 +749,7 @@ pub impl mem_categorization_ctxt {\n     fn cat_index<N:ast_node>(&self,\n                               elt: N,\n                               base_cmt: cmt) -> cmt {\n-        let mt = match ty::index(self.tcx, base_cmt.ty) {\n+        let mt = match ty::index(base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n             self.tcx.sess.span_bug("}, {"sha": "6e84adae6dce053115b82e013e9b2c5a6d937d33", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -1073,8 +1073,7 @@ pub fn compare_values(cx: block,\n \n     match ty::get(rhs_t).sty {\n         ty::ty_estr(ty::vstore_uniq) => {\n-            let scratch_result = scratch_datum(cx, ty::mk_bool(cx.tcx()),\n-                                               false);\n+            let scratch_result = scratch_datum(cx, ty::mk_bool(), false);\n             let scratch_lhs = alloca(cx, val_ty(lhs));\n             Store(cx, lhs, scratch_lhs);\n             let scratch_rhs = alloca(cx, val_ty(rhs));\n@@ -1092,8 +1091,7 @@ pub fn compare_values(cx: block,\n             }\n         }\n         ty::ty_estr(_) => {\n-            let scratch_result = scratch_datum(cx, ty::mk_bool(cx.tcx()),\n-                                               false);\n+            let scratch_result = scratch_datum(cx, ty::mk_bool(), false);\n             let did = cx.tcx().lang_items.str_eq_fn();\n             let bcx = callee::trans_lang_call(cx, did,\n                                                         ~[lhs, rhs],"}, {"sha": "b3e24fcc939519e4515a61340459339b6233cf2b", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -50,7 +50,6 @@ use core::option::{Option, Some, None};\n use core::vec;\n \n use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n-use lib::llvm::llvm::LLVMDumpValue;\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -136,7 +135,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n             let ftys =\n-                if dtor { ftys + [ty::mk_bool(cx.tcx)] } else { ftys };\n+                if dtor { ftys + [ty::mk_bool()] } else { ftys };\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n@@ -204,7 +203,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n             }\n \n             // The general case.\n-            let discr = ~[ty::mk_int(cx.tcx)];\n+            let discr = ~[ty::mk_int()];\n             return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")"}, {"sha": "b86e9a512932a9d18941358c0b5c2eab00dc9ba6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -707,7 +707,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                     substs.tps, f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n-                  cx = f(cx, lldiscrim_a, ty::mk_int(cx.tcx()));\n+                  cx = f(cx, lldiscrim_a, ty::mk_int());\n                   let unr_cx = sub_block(cx, ~\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n@@ -2361,7 +2361,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n     }\n \n     fn create_main(ccx: @CrateContext, main_llfn: ValueRef) -> ValueRef {\n-        let nt = ty::mk_nil(ccx.tcx);\n+        let nt = ty::mk_nil();\n         let llfty = type_of_fn(ccx, ~[], nt);\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n@@ -2407,9 +2407,8 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n-            let crate_map = ccx.crate_map;\n             let start_def_id = ccx.tcx.lang_items.start_fn();\n-            let start_fn = if start_def_id.crate == ast::local_crate {\n+            if start_def_id.crate == ast::local_crate {\n                 ccx.sess.bug(~\"start lang item is never in the local crate\")\n             } else {\n                 let start_fn_type = csearch::get_type(ccx.tcx,\n@@ -2727,7 +2726,7 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n             ]);\n-            let s = @mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n+            let s = @mangle_exported_name(ccx, p, ty::mk_int());\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n             let discrim_gvar = str::as_c_str(*s, |buf| {"}, {"sha": "e532e5e1dfd09db40eaec8770b3a92cf5e366d4a", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -261,8 +261,7 @@ pub fn build_closure(bcx0: block,\n                      include_ret_handle: Option<ValueRef>) -> ClosureResult {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n-    let bcx = bcx0;;\n-    let ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let bcx = bcx0;\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n@@ -290,7 +289,7 @@ pub fn build_closure(bcx0: block,\n     // variables:\n     for include_ret_handle.each |flagptr| {\n         // Flag indicating we have returned (a by-ref bool):\n-        let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(tcx),\n+        let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(),\n                                 mode: ByRef, source: ZeroMem};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: flag_datum});\n@@ -302,7 +301,7 @@ pub fn build_closure(bcx0: block,\n             None => bcx.fcx.llretptr.get()\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n-        let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(tcx),\n+        let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(),\n                                mode: ByRef, source: ZeroMem};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: ret_datum});\n@@ -420,7 +419,7 @@ pub fn trans_expr_fn(bcx: block,\n     }\n \n     let real_return_type = if is_loop_body.is_some() {\n-        ty::mk_bool(bcx.tcx())\n+        ty::mk_bool()\n     } else {\n         ty::ty_fn_ret(fty)\n     };"}, {"sha": "7aade041fbc333d916c734bed8510f61f5e043eb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -999,9 +999,9 @@ pub fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(\n         tcx,\n-        ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm}\n+        ty::mt {ty: ty::mk_nil(), mutbl: ast::m_imm}\n     );\n-    return ty::mk_tup(tcx, ~[ty::mk_uint(tcx), ty::mk_type(tcx),\n+    return ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_type(tcx),\n                          ptr, ptr,\n                          t]);\n }"}, {"sha": "6c1fbff664b6e164428fe954b0ca7cbe63882d09", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -560,7 +560,7 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n-    let int_t = ty::mk_int(cx.tcx);\n+    let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n     let scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n@@ -643,7 +643,7 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n     let vec_scx = create_structure(file_node,\n                                @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n-    let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx), vec_ty_span);\n+    let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n     add_member(vec_scx, ~\"fill\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n     add_member(vec_scx, ~\"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n@@ -666,7 +666,7 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     };\n \n     let box_scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n-    let int_t = ty::mk_int(cx.tcx);\n+    let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n     add_member(box_scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n@@ -692,7 +692,7 @@ fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n-    let uint_type = create_basic_type(cx, ty::mk_uint(cx.tcx), span);\n+    let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n     let scx = create_structure(file_node, @ty_to_str(cx.tcx, vec_t), 0);\n     let (_, ptr_size, ptr_align) = voidptr();\n@@ -744,7 +744,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n         ty::ty_estr(ref vstore) => {\n-            let i8_t = ty::mk_i8(cx.tcx);\n+            let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n                     create_fixed_vec(cx, t, i8_t, len as int + 1, span)"}, {"sha": "21fb11813e8e86e3218f53ef4cacf452c73e2746", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -791,7 +791,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n             let rust_ty = ty::mk_ptr(\n                 bcx.tcx(),\n                 ty::mt {\n-                    ty: ty::mk_mach_uint(bcx.tcx(), ast::ty_u8),\n+                    ty: ty::mk_mach_uint(ast::ty_u8),\n                     mutbl: ast::m_imm\n                 }); // *u8\n             (rust_ty, PointerCast(bcx, fn_data.llfn, T_ptr(T_i8())))"}, {"sha": "22a60a1ed2e3bcbe9941e246086b74d4f1daff2e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -768,7 +768,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n-                ty::mk_mach_uint(bcx.tcx(), ast::ty_u8));\n+                ty::mk_mach_uint(ast::ty_u8));\n             let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n                 purity: ast::impure_fn,\n                 sigil: ast::BorrowedSigil,\n@@ -777,21 +777,21 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n                             inputs: ~[arg {mode: ast::expl(ast::by_copy),\n                                            ty: star_u8}],\n-                            output: ty::mk_nil(bcx.tcx())}\n+                            output: ty::mk_nil()}\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n                                mode: ByRef, ty: fty, source: ZeroMem};\n             let arg_vals = ~[frameaddress_val];\n             bcx = trans_call_inner(\n-                bcx, None, fty, ty::mk_nil(bcx.tcx()),\n+                bcx, None, fty, ty::mk_nil(),\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n                 ArgVals(arg_vals), Ignore, DontAutorefArg);\n         }\n         ~\"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular\n             // native function. There should be a general in-language\n             // way to do this\n-            let llfty = type_of_fn(bcx.ccx(), ~[], ty::mk_nil(bcx.tcx()));\n+            let llfty = type_of_fn(bcx.ccx(), ~[], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, ~\"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr,"}, {"sha": "bdf50619e62d58cbf9b9b14f6d9c2b595f87102c", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -168,19 +168,19 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n         field == abi::tydesc_field_drop_glue ||\n         field == abi::tydesc_field_free_glue) &&\n         ! ty::type_needs_drop(tcx, t) {\n-          return ty::mk_u32(tcx);\n+          return ty::mk_u32();\n     }\n \n     if field == abi::tydesc_field_take_glue {\n         match ty::get(t).sty {\n-          ty::ty_unboxed_vec(*) => { return ty::mk_u32(tcx); }\n+          ty::ty_unboxed_vec(*) => { return ty::mk_u32(); }\n           _ => ()\n         }\n     }\n \n     if field == abi::tydesc_field_take_glue &&\n         ty::type_is_boxed(t) {\n-          return ty::mk_imm_box(tcx, ty::mk_u32(tcx));\n+          return ty::mk_imm_box(tcx, ty::mk_u32());\n     }\n \n     if field == abi::tydesc_field_free_glue {\n@@ -193,7 +193,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n           ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n           ty::ty_opaque_closure_ptr(*) => (),\n-          _ => { return ty::mk_u32(tcx); }\n+          _ => { return ty::mk_u32(); }\n         }\n     }\n \n@@ -203,12 +203,12 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n           ty::ty_box(mt) |\n           ty::ty_evec(mt, ty::vstore_box)\n           if ! ty::type_needs_drop(tcx, mt.ty) =>\n-          return ty::mk_imm_box(tcx, ty::mk_u32(tcx)),\n+          return ty::mk_imm_box(tcx, ty::mk_u32()),\n \n           ty::ty_uniq(mt) |\n           ty::ty_evec(mt, ty::vstore_uniq)\n           if ! ty::type_needs_drop(tcx, mt.ty) =>\n-          return ty::mk_imm_uniq(tcx, ty::mk_u32(tcx)),\n+          return ty::mk_imm_uniq(tcx, ty::mk_u32()),\n \n           _ => ()\n         }\n@@ -736,7 +736,7 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                helper: glue_helper)\n                             -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(ccx.tcx), None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n     // All glue functions take values passed *by alias*; this is a"}, {"sha": "a7221297eca02d1a7d0be4e8109d0e2f10506dee", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -307,7 +307,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n                     abis: AbiSet::Rust(),\n                     sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n                                 inputs: ~[],\n-                                output: ty::mk_nil(tcx)}}))\n+                                output: ty::mk_nil()}}))\n         }\n         ty::ty_closure(ref fty) => {\n             Some(normalized_closure_ty(tcx, fty.sigil))\n@@ -323,7 +323,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n             Some(normalized_closure_ty(tcx, sigil))\n         }\n         ty::ty_ptr(_) => {\n-            Some(ty::mk_uint(tcx))\n+            Some(ty::mk_uint())\n         }\n         _ => {\n             None\n@@ -342,7 +342,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n                 region: ty::re_static,\n                 sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n                                 inputs: ~[],\n-                                output: ty::mk_nil(tcx)}})\n+                                output: ty::mk_nil()}})\n     }\n }\n "}, {"sha": "8d0a043a9a1f45f33f2b2d6132060a2e9fa54dee", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -95,7 +95,7 @@ fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n }\n \n fn traverse_public_item(cx: &ctx, item: @item) {\n-    // XXX: it shouldn't be necessary to do this\n+    // FIXME #6021: naming rmap shouldn't be necessary\n     let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&item.id) { return; }\n     rmap.insert(item.id);\n@@ -150,7 +150,7 @@ fn traverse_public_item(cx: &ctx, item: @item) {\n }\n \n fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n-    // XXX: it shouldn't be necessary to do this\n+    // FIXME #6021: naming rmap shouldn't be necessary\n     let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&ty.id) { return; }\n     rmap.insert(ty.id);"}, {"sha": "741b111b6a0a7d0c6104430c6e64c1d3d01a20b7", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -98,7 +98,7 @@ pub impl Reflector {\n         for args.eachi |i, a| {\n             debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, *a));\n         }\n-        let bool_ty = ty::mk_bool(tcx);\n+        let bool_ty = ty::mk_bool();\n         let scratch = scratch_datum(bcx, bool_ty, false);\n         // XXX: Should not be BoxTraitStore!\n         let bcx = callee::trans_call_inner(\n@@ -283,15 +283,15 @@ pub impl Reflector {\n                 let sym = mangle_internal_name_by_path_and_seq(ccx, sub_path, ~\"get_disr\");\n                 let args = [ty::arg { mode: ast::expl(ast::by_copy),\n                                       ty: opaqueptrty }];\n-                let llfty = type_of_fn(ccx, args, ty::mk_int(ccx.tcx));\n+                let llfty = type_of_fn(ccx, args, ty::mk_int());\n                 let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n                 let arg = unsafe {\n                     llvm::LLVMGetParam(llfdecl, first_real_arg as c_uint)\n                 };\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],\n                                       llfdecl,\n-                                      ty::mk_uint(ccx.tcx),\n+                                      ty::mk_uint(),\n                                       None);\n                 let bcx = top_scope_block(fcx, None);\n                 let arg = BitCast(bcx, arg, llptrty);"}, {"sha": "b487fedf01dbb0b8d546d7061bc7c369a148cc22", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -949,12 +949,12 @@ pub fn mk_ctxt(s: session::Session,\n fn mk_t(cx: ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n-        ty_nil => return mk_nil(cx),\n-        ty_err => return mk_err(cx),\n-        ty_bool => return mk_bool(cx),\n-        ty_int(i) => return mk_mach_int(cx, i),\n-        ty_uint(u) => return mk_mach_uint(cx, u),\n-        ty_float(f) => return mk_mach_float(cx, f),\n+        ty_nil => return mk_nil(),\n+        ty_err => return mk_err(),\n+        ty_bool => return mk_bool(),\n+        ty_int(i) => return mk_mach_int(i),\n+        ty_uint(u) => return mk_mach_uint(u),\n+        ty_float(f) => return mk_mach_float(f),\n         _ => {}\n     };\n \n@@ -1052,94 +1052,94 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n }\n \n #[inline(always)]\n-pub fn mk_prim_t(cx: ctxt, primitive: &'static t_box_) -> t {\n+pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     unsafe {\n         cast::transmute::<&'static t_box_, t>(primitive)\n     }\n }\n \n #[inline(always)]\n-pub fn mk_nil(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_NIL) }\n+pub fn mk_nil() -> t { mk_prim_t(&primitives::TY_NIL) }\n \n #[inline(always)]\n-pub fn mk_err(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_ERR) }\n+pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n \n #[inline(always)]\n-pub fn mk_bot(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_BOT) }\n+pub fn mk_bot() -> t { mk_prim_t(&primitives::TY_BOT) }\n \n #[inline(always)]\n-pub fn mk_bool(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_BOOL) }\n+pub fn mk_bool() -> t { mk_prim_t(&primitives::TY_BOOL) }\n \n #[inline(always)]\n-pub fn mk_int(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_INT) }\n+pub fn mk_int() -> t { mk_prim_t(&primitives::TY_INT) }\n \n #[inline(always)]\n-pub fn mk_i8(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I8) }\n+pub fn mk_i8() -> t { mk_prim_t(&primitives::TY_I8) }\n \n #[inline(always)]\n-pub fn mk_i16(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I16) }\n+pub fn mk_i16() -> t { mk_prim_t(&primitives::TY_I16) }\n \n #[inline(always)]\n-pub fn mk_i32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I32) }\n+pub fn mk_i32() -> t { mk_prim_t(&primitives::TY_I32) }\n \n #[inline(always)]\n-pub fn mk_i64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I64) }\n+pub fn mk_i64() -> t { mk_prim_t(&primitives::TY_I64) }\n \n #[inline(always)]\n-pub fn mk_float(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_FLOAT) }\n+pub fn mk_float() -> t { mk_prim_t(&primitives::TY_FLOAT) }\n \n #[inline(always)]\n-pub fn mk_f32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_F32) }\n+pub fn mk_f32() -> t { mk_prim_t(&primitives::TY_F32) }\n \n #[inline(always)]\n-pub fn mk_f64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_F64) }\n+pub fn mk_f64() -> t { mk_prim_t(&primitives::TY_F64) }\n \n #[inline(always)]\n-pub fn mk_uint(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_UINT) }\n+pub fn mk_uint() -> t { mk_prim_t(&primitives::TY_UINT) }\n \n #[inline(always)]\n-pub fn mk_u8(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U8) }\n+pub fn mk_u8() -> t { mk_prim_t(&primitives::TY_U8) }\n \n #[inline(always)]\n-pub fn mk_u16(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U16) }\n+pub fn mk_u16() -> t { mk_prim_t(&primitives::TY_U16) }\n \n #[inline(always)]\n-pub fn mk_u32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U32) }\n+pub fn mk_u32() -> t { mk_prim_t(&primitives::TY_U32) }\n \n #[inline(always)]\n-pub fn mk_u64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U64) }\n+pub fn mk_u64() -> t { mk_prim_t(&primitives::TY_U64) }\n \n-pub fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t {\n+pub fn mk_mach_int(tm: ast::int_ty) -> t {\n     match tm {\n-        ast::ty_i    => mk_int(cx),\n-        ast::ty_char => mk_char(cx),\n-        ast::ty_i8   => mk_i8(cx),\n-        ast::ty_i16  => mk_i16(cx),\n-        ast::ty_i32  => mk_i32(cx),\n-        ast::ty_i64  => mk_i64(cx),\n+        ast::ty_i    => mk_int(),\n+        ast::ty_char => mk_char(),\n+        ast::ty_i8   => mk_i8(),\n+        ast::ty_i16  => mk_i16(),\n+        ast::ty_i32  => mk_i32(),\n+        ast::ty_i64  => mk_i64(),\n     }\n }\n \n-pub fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t {\n+pub fn mk_mach_uint(tm: ast::uint_ty) -> t {\n     match tm {\n-        ast::ty_u    => mk_uint(cx),\n-        ast::ty_u8   => mk_u8(cx),\n-        ast::ty_u16  => mk_u16(cx),\n-        ast::ty_u32  => mk_u32(cx),\n-        ast::ty_u64  => mk_u64(cx),\n+        ast::ty_u    => mk_uint(),\n+        ast::ty_u8   => mk_u8(),\n+        ast::ty_u16  => mk_u16(),\n+        ast::ty_u32  => mk_u32(),\n+        ast::ty_u64  => mk_u64(),\n     }\n }\n \n-pub fn mk_mach_float(cx: ctxt, tm: ast::float_ty) -> t {\n+pub fn mk_mach_float(tm: ast::float_ty) -> t {\n     match tm {\n-        ast::ty_f    => mk_float(cx),\n-        ast::ty_f32  => mk_f32(cx),\n-        ast::ty_f64  => mk_f64(cx),\n+        ast::ty_f    => mk_float(),\n+        ast::ty_f32  => mk_f32(),\n+        ast::ty_f64  => mk_f64(),\n     }\n }\n \n #[inline(always)]\n-pub fn mk_char(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_CHAR) }\n+pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n@@ -1182,7 +1182,7 @@ pub fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n }\n \n pub fn mk_nil_ptr(cx: ctxt) -> t {\n-    mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::m_imm})\n }\n \n pub fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n@@ -1610,7 +1610,7 @@ pub fn type_is_str(ty: t) -> bool {\n \n pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n-      ty_estr(_) => return mk_mach_uint(cx, ast::ty_u8),\n+      ty_estr(_) => return mk_mach_uint(ast::ty_u8),\n       ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\n           ~\"sequence_element_type called on non-sequence value\"),\n@@ -2614,14 +2614,14 @@ pub fn type_autoderef(cx: ctxt, t: t) -> t {\n }\n \n // Returns the type and mutability of t[i]\n-pub fn index(cx: ctxt, t: t) -> Option<mt> {\n-    index_sty(cx, &get(t).sty)\n+pub fn index(t: t) -> Option<mt> {\n+    index_sty(&get(t).sty)\n }\n \n-pub fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n+pub fn index_sty(sty: &sty) -> Option<mt> {\n     match *sty {\n       ty_evec(mt, _) => Some(mt),\n-      ty_estr(_) => Some(mt {ty: mk_u8(cx), mutbl: ast::m_imm}),\n+      ty_estr(_) => Some(mt {ty: mk_u8(), mutbl: ast::m_imm}),\n       _ => None\n     }\n }\n@@ -4164,14 +4164,6 @@ pub fn lookup_struct_field(cx: ctxt,\n     }\n }\n \n-fn is_public(f: field_ty) -> bool {\n-    // XXX: This is wrong.\n-    match f.vis {\n-        public | inherited => true,\n-        private => false\n-    }\n-}\n-\n fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n     do fields.map |field| {\n         match field.node.kind {"}, {"sha": "f75ec183473c1eac8209b97ca7bcb388307d4c2c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -352,8 +352,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n     let typ = match ast_ty.node {\n-      ast::ty_nil => ty::mk_nil(tcx),\n-      ast::ty_bot => ty::mk_bot(tcx),\n+      ast::ty_nil => ty::mk_nil(),\n+      ast::ty_bot => ty::mk_bot(),\n       ast::ty_box(ref mt) => {\n         mk_pointer(self, rscope, mt, ty::vstore_box,\n                    |tmt| ty::mk_box(tcx, tmt))\n@@ -413,7 +413,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                   fmt!(\"reference to trait `%s` where a type is expected; \\\n                         try `@%s`, `~%s`, or `&%s`\",\n                        path_str, path_str, path_str, path_str));\n-              ty::mk_err(tcx)\n+              ty::mk_err()\n           }\n           ast::def_ty(did) | ast::def_struct(did) => {\n             ast_path_to_ty(self, rscope, did, path).ty\n@@ -422,19 +422,19 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n             match nty {\n               ast::ty_bool => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_bool(tcx)\n+                ty::mk_bool()\n               }\n               ast::ty_int(it) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_int(tcx, it)\n+                ty::mk_mach_int(it)\n               }\n               ast::ty_uint(uit) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_uint(tcx, uit)\n+                ty::mk_mach_uint(uit)\n               }\n               ast::ty_float(ft) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_float(tcx, ft)\n+                ty::mk_mach_float(ft)\n               }\n               ast::ty_str => {\n                 tcx.sess.span_err(ast_ty.span,"}, {"sha": "c52989c5d22cded22a9e84455fd6213e339d8eb2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -56,7 +56,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n         let mut guard_bot = false;\n         match arm.guard {\n           Some(e) => {\n-              check_expr_has_type(fcx, e, ty::mk_bool(tcx));\n+              check_expr_has_type(fcx, e, ty::mk_bool());\n               let e_ty = fcx.expr_ty(e);\n               if ty::type_is_error(e_ty) {\n                   guard_err = true;\n@@ -84,10 +84,10 @@ pub fn check_match(fcx: @mut FnCtxt,\n         demand::suptype(fcx, arm.body.span, result_ty, bty);\n     }\n     if saw_err {\n-        result_ty = ty::mk_err(tcx);\n+        result_ty = ty::mk_err();\n     }\n     else if !arm_non_bot {\n-        result_ty = ty::mk_bot(tcx);\n+        result_ty = ty::mk_bot();\n     }\n     fcx.write_ty(expr.id, result_ty);\n }\n@@ -230,11 +230,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n     }\n \n     if error_happened {\n-        let tcx = pcx.fcx.ccx.tcx;\n-\n         for subpats.each |pats| {\n             for pats.each |pat| {\n-                check_pat(pcx, *pat, ty::mk_err(tcx));\n+                check_pat(pcx, *pat, ty::mk_err());\n             }\n         }\n     }"}, {"sha": "dd147d9e46887bf84935ef93f9b45c3e4a1f579d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 175, "deletions": 176, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -753,13 +753,13 @@ pub impl FnCtxt {\n     }\n \n     fn write_nil(&self, node_id: ast::node_id) {\n-        self.write_ty(node_id, ty::mk_nil(self.tcx()));\n+        self.write_ty(node_id, ty::mk_nil());\n     }\n     fn write_bot(&self, node_id: ast::node_id) {\n-        self.write_ty(node_id, ty::mk_bot(self.tcx()));\n+        self.write_ty(node_id, ty::mk_bot());\n     }\n     fn write_error(@mut self, node_id: ast::node_id) {\n-        self.write_ty(node_id, ty::mk_err(self.tcx()));\n+        self.write_ty(node_id, ty::mk_err());\n     }\n \n     fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n@@ -1008,21 +1008,21 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n \n     match lit.node {\n       ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::re_static)),\n-      ast::lit_int(_, t) => ty::mk_mach_int(tcx, t),\n-      ast::lit_uint(_, t) => ty::mk_mach_uint(tcx, t),\n+      ast::lit_int(_, t) => ty::mk_mach_int(t),\n+      ast::lit_uint(_, t) => ty::mk_mach_uint(t),\n       ast::lit_int_unsuffixed(_) => {\n         // An unsuffixed integer literal could have any integral type,\n         // so we create an integral type variable for it.\n         ty::mk_int_var(tcx, fcx.infcx().next_int_var_id())\n       }\n-      ast::lit_float(_, t) => ty::mk_mach_float(tcx, t),\n+      ast::lit_float(_, t) => ty::mk_mach_float(t),\n       ast::lit_float_unsuffixed(_) => {\n         // An unsuffixed floating point literal could have any floating point\n         // type, so we create a floating point type variable for it.\n         ty::mk_float_var(tcx, fcx.infcx().next_float_var_id())\n       }\n-      ast::lit_nil => ty::mk_nil(tcx),\n-      ast::lit_bool(_) => ty::mk_bool(tcx)\n+      ast::lit_nil => ty::mk_nil(),\n+      ast::lit_bool(_) => ty::mk_bool()\n     }\n }\n \n@@ -1146,7 +1146,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         deref_args: DerefArgs) -> ty::t\n     {\n         if ty::type_is_error(method_fn_ty) {\n-            let err_inputs = err_args(fcx.tcx(), args.len());\n+            let err_inputs = err_args(args.len());\n             check_argument_types(fcx, sp, err_inputs, callee_expr,\n                                  args, sugar, deref_args);\n             method_fn_ty\n@@ -1209,7 +1209,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n             tcx.sess.span_err(sp, msg);\n \n-            vec::from_elem(supplied_arg_count, ty::mk_err(tcx))\n+            vec::from_elem(supplied_arg_count, ty::mk_err())\n         };\n \n         debug!(\"check_argument_types: formal_tys=%?\",\n@@ -1265,9 +1265,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn err_args(tcx: ty::ctxt, len: uint) -> ~[ty::arg] {\n+    fn err_args(len: uint) -> ~[ty::arg] {\n         vec::from_fn(len, |_| ty::arg {mode: ast::expl(ast::by_copy),\n-                                       ty: ty::mk_err(tcx)})\n+                                       ty: ty::mk_err()})\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1278,7 +1278,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n         check_expr_has_type(fcx, rhs, lhs_type);\n-        fcx.write_ty(id, ty::mk_nil(fcx.ccx.tcx));\n+        fcx.write_ty(id, ty::mk_nil());\n         // The callee checks for bot / err, we don't need to\n     }\n \n@@ -1321,8 +1321,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 // check each arg against \"error\", in order to set up\n                 // all the node type bindings\n                 FnSig {bound_lifetime_names: opt_vec::Empty,\n-                       inputs: err_args(fcx.tcx(), args.len()),\n-                       output: ty::mk_err(fcx.tcx())}\n+                       inputs: err_args(args.len()),\n+                       output: ty::mk_err()}\n             }\n         };\n \n@@ -1417,7 +1417,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 None => {\n                     check_block_no_value(fcx, thn);\n-                    ty::mk_nil(fcx.ccx.tcx)\n+                    ty::mk_nil()\n                 }\n             };\n \n@@ -1448,15 +1448,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                             ast::NoSugar, deref_args)\n             }\n             _ => {\n-                let tcx = fcx.tcx();\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n-                let expected_ty = ty::mk_err(tcx);\n+                let expected_ty = ty::mk_err();\n                 check_method_argument_types(fcx, op_ex.span,\n                                             expected_ty, op_ex, args,\n                                             ast::NoSugar, deref_args);\n-                ty::mk_err(tcx)\n+                ty::mk_err()\n             }\n         }\n     }\n@@ -1494,7 +1493,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             let result_t = match op {\n                 ast::eq | ast::ne | ast::lt | ast::le | ast::ge |\n                 ast::gt => {\n-                    ty::mk_bool(tcx)\n+                    ty::mk_bool()\n                 }\n                 _ => {\n                     lhs_t\n@@ -1565,7 +1564,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         }\n \n-        ty::mk_err(tcx)\n+        ty::mk_err()\n     }\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n@@ -1671,11 +1670,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 bound_lifetime_names: opt_vec::Empty,\n                 inputs: fn_ty.sig.inputs.map(|an_arg| {\n                     arg { mode: an_arg.mode,\n-                         ty: ty::mk_err(tcx)\n+                         ty: ty::mk_err()\n                         }}),\n-                output: ty::mk_err(tcx)\n+                output: ty::mk_err()\n             };\n-            ty::mk_err(tcx)\n+            ty::mk_err()\n         }\n         else {\n             let fn_ty_copy = copy fn_ty;\n@@ -1792,7 +1791,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Typecheck each field.\n         for ast_fields.each |field| {\n-            let mut expected_field_type = ty::mk_err(tcx);\n+            let mut expected_field_type = ty::mk_err();\n \n             let pair = class_field_map.find(&field.node.ident).\n                                        map_consume(|x| *x);\n@@ -1934,7 +1933,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            fields,\n                                            base_expr.is_none());\n         if ty::type_is_error(fcx.node_ty(id)) {\n-            struct_type = ty::mk_err(tcx);\n+            struct_type = ty::mk_err();\n         }\n \n         // Check the base expression if necessary.\n@@ -1943,7 +1942,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             Some(base_expr) => {\n                 check_expr_has_type(fcx, base_expr, struct_type);\n                 if ty::type_is_bot(fcx.node_ty(base_expr.id)) {\n-                    struct_type = ty::mk_bot(tcx);\n+                    struct_type = ty::mk_bot();\n                 }\n             }\n         }\n@@ -2040,10 +2039,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let inner_ty = match expected_sty {\n             Some(ty::ty_closure(ref fty)) => {\n                 match fcx.mk_subty(false, expr.span,\n-                                   fty.sig.output, ty::mk_bool(tcx)) {\n+                                   fty.sig.output, ty::mk_bool()) {\n                     result::Ok(_) => {\n                         ty::mk_closure(tcx, ty::ClosureTy {\n-                            sig: FnSig {output: ty::mk_nil(tcx),\n+                            sig: FnSig {output: ty::mk_nil(),\n                                         ..copy fty.sig},\n                             ..copy *fty\n                         })\n@@ -2070,7 +2069,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             None);\n                         err_happened = true;\n                         fcx.write_error(expr.id);\n-                        ty::mk_err(tcx)\n+                        ty::mk_err()\n                     }\n                 }\n             }\n@@ -2085,7 +2084,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                      actual)\n                             },\n                             expected_t, None);\n-                        let err_ty = ty::mk_err(tcx);\n+                        let err_ty = ty::mk_err();\n                         fcx.write_error(expr.id);\n                         err_happened = true;\n                         err_ty\n@@ -2131,7 +2130,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         } else {\n             let loop_body_ty =\n                 ty::replace_closure_return_type(\n-                    tcx, block_ty, ty::mk_bool(tcx));\n+                    tcx, block_ty, ty::mk_bool());\n             fcx.write_ty(expr.id, loop_body_ty);\n         }\n     }\n@@ -2168,18 +2167,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n             }\n             if any_error {\n-                ty::mk_err(tcx)\n+                ty::mk_err()\n             }\n             else if any_bot {\n-                ty::mk_bot(tcx)\n+                ty::mk_bot()\n             }\n             else {\n                 ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let _ = ty::eval_repeat_count(tcx, count_expr);\n-            check_expr_with_hint(fcx, count_expr, ty::mk_uint(tcx));\n+            check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability = match vst {\n                 ast::expr_vstore_mut_box | ast::expr_vstore_mut_slice => {\n@@ -2191,9 +2190,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             check_expr_has_type(fcx, element, t);\n             let arg_t = fcx.expr_ty(element);\n             if ty::type_is_error(arg_t) {\n-                ty::mk_err(tcx)\n+                ty::mk_err()\n             } else if ty::type_is_bot(arg_t) {\n-                ty::mk_bot(tcx)\n+                ty::mk_bot()\n             } else {\n                 ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n@@ -2351,9 +2350,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n-            ty::mk_err(tcx)\n+            ty::mk_err()\n         } else if ty::type_is_bot(tm.ty) {\n-            ty::mk_bot(tcx)\n+            ty::mk_bot()\n         }\n         else {\n             ty::mk_rptr(tcx, region, tm)\n@@ -2387,7 +2386,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         match expr_opt {\n           None => match fcx.mk_eqty(false, expr.span,\n-                                    ret_ty, ty::mk_nil(tcx)) {\n+                                    ret_ty, ty::mk_nil()) {\n             result::Ok(_) => { /* fall through */ }\n             result::Err(_) => {\n                 tcx.sess.span_err(\n@@ -2403,7 +2402,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_log(lv, e) => {\n         check_expr_has_type(fcx, lv,\n-                                  ty::mk_mach_uint(tcx, ast::ty_u32));\n+                                  ty::mk_mach_uint(ast::ty_u32));\n \n         // Note: this does not always execute, so do not propagate bot:\n         check_expr(fcx, e);\n@@ -2451,7 +2450,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::expr_if(cond, ref thn, elsopt) => {\n-        check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n+        check_expr_has_type(fcx, cond, ty::mk_bool());\n         check_then_else(fcx, thn, elsopt, id, expr.span);\n         let cond_ty = fcx.expr_ty(cond);\n         let then_ty = fcx.node_ty(thn.node.id);\n@@ -2471,7 +2470,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           // Other cases were handled by check_then_else\n       }\n       ast::expr_while(cond, ref body) => {\n-        check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n+        check_expr_has_type(fcx, cond, ty::mk_bool());\n         check_block_no_value(fcx, body);\n         let cond_ty = fcx.expr_ty(cond);\n         let body_ty = fcx.node_ty(body.node.id);\n@@ -2539,7 +2538,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                               has non-closure type: %s\",\n                              actual)\n                     }, expected_t, None);\n-                    let err_ty = ty::mk_err(tcx);\n+                    let err_ty = ty::mk_err();\n                     fcx.write_ty(id, err_ty);\n                     err_ty\n                 }\n@@ -2706,7 +2705,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_repeat(element, count_expr, mutbl) => {\n         let count = ty::eval_repeat_count(tcx, count_expr);\n-        check_expr_with_hint(fcx, count_expr, ty::mk_uint(tcx));\n+        check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n         let t: ty::t = fcx.infcx().next_ty_var();\n         check_expr_has_type(fcx, element, t);\n         let element_ty = fcx.expr_ty(element);\n@@ -2782,7 +2781,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           else {\n               let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n               let base_sty = structure_of(fcx, expr.span, base_t);\n-              match ty::index_sty(tcx, &base_sty) {\n+              match ty::index_sty(&base_sty) {\n                   Some(mt) => {\n                       require_integral(fcx, idx.span, idx_t);\n                       fcx.write_ty(id, mt.ty);\n@@ -2886,7 +2885,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n       ast::stmt_expr(expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, expr, ty::mk_nil(fcx.ccx.tcx));\n+        check_expr_has_type(fcx, expr, ty::mk_nil());\n         let expr_ty = fcx.expr_ty(expr);\n         saw_bot = saw_bot || ty::type_is_bot(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n@@ -2912,7 +2911,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n }\n \n pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::blk)  {\n-    check_block_with_expected(fcx, blk, Some(ty::mk_nil(fcx.ccx.tcx)));\n+    check_block_with_expected(fcx, blk, Some(ty::mk_nil()));\n     let blkty = fcx.node_ty(blk.node.id);\n     if ty::type_is_error(blkty) {\n         fcx.write_error(blk.node.id);\n@@ -2921,7 +2920,7 @@ pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::blk)  {\n         fcx.write_bot(blk.node.id);\n     }\n     else {\n-        let nilty = ty::mk_nil(fcx.ccx.tcx);\n+        let nilty = ty::mk_nil();\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n }\n@@ -3054,7 +3053,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 let e = *e_ref;\n                 debug!(\"disr expr, checking %s\",\n                        pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n-                let declty = ty::mk_int(ccx.tcx);\n+                let declty = ty::mk_int();\n                 let fcx = blank_fn_ctxt(ccx, rty, e.id);\n                 check_const_with_ty(fcx, e.span, e, declty);\n                 // check_expr (from check_const pass) doesn't guarantee\n@@ -3173,7 +3172,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n                 ty::mt {\n-                    ty: ty::mk_mach_uint(fcx.ccx.tcx, ast::ty_u8),\n+                    ty: ty::mk_mach_uint(ast::ty_u8),\n                     mutbl: ast::m_imm\n                 })\n         };\n@@ -3296,7 +3295,7 @@ pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: span, tp: ty::t)\n             fcx.type_error_message(sp, |_actual| {\n                 ~\"the type of this value must be known in this context\"\n             }, tp, None);\n-            demand::suptype(fcx, sp, ty::mk_err(fcx.tcx()), tp);\n+            demand::suptype(fcx, sp, ty::mk_err(), tp);\n             tp\n         }\n     }\n@@ -3413,10 +3412,10 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n-      ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint(ccx.tcx)),\n+      ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),\n       ~\"forget\" => (1u, ~[arg(ast::by_copy, param(ccx, 0u))],\n-                    ty::mk_nil(tcx)),\n+                    ty::mk_nil()),\n       ~\"reinterpret_cast\" => (2u, ~[arg(ast::by_ref, param(ccx, 0u))],\n                               param(ccx, 1u)),\n       ~\"addr_of\" => (1u, ~[arg(ast::by_ref, param(ccx, 0u))],\n@@ -3426,41 +3425,41 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                      ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n                                      param(ccx, 0u))),\n                arg(ast::by_copy, param(ccx, 0u))],\n-         ty::mk_nil(tcx))\n+         ty::mk_nil())\n       }\n-      ~\"needs_drop\" => (1u, ~[], ty::mk_bool(tcx)),\n+      ~\"needs_drop\" => (1u, ~[], ty::mk_bool()),\n \n       ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n         (0u, ~[arg(ast::by_copy,\n                    ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                   ty::mk_int(tcx))),\n-               arg(ast::by_copy, ty::mk_int(tcx)),\n-               arg(ast::by_copy, ty::mk_int(tcx))],\n-         ty::mk_int(tcx))\n+                                   ty::mk_int())),\n+               arg(ast::by_copy, ty::mk_int()),\n+               arg(ast::by_copy, ty::mk_int())],\n+         ty::mk_int())\n       }\n       ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n       ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n       ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n         (0u, ~[arg(ast::by_copy,\n                    ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                   ty::mk_int(tcx))),\n-               arg(ast::by_copy, ty::mk_int(tcx))],\n-         ty::mk_int(tcx))\n+                                   ty::mk_int())),\n+               arg(ast::by_copy, ty::mk_int())],\n+         ty::mk_int())\n       }\n \n       ~\"get_tydesc\" => {\n         // FIXME (#3730): return *intrinsic::tydesc, not *()\n-        (1u, ~[], ty::mk_nil_ptr(tcx))\n+        (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n           let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n-          let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n+          let (_, visitor_object_ty) = ty::visitor_object_ty(ccx.tcx);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n                                                    mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_copy, td_ptr),\n-                 arg(ast::by_ref, visitor_object_ty)], ty::mk_nil(tcx))\n+                 arg(ast::by_ref, visitor_object_ty)], ty::mk_nil())\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n@@ -3473,224 +3472,224 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                 inputs: ~[arg {mode: ast::expl(ast::by_copy),\n                                ty: ty::mk_imm_ptr(\n                                    ccx.tcx,\n-                                   ty::mk_mach_uint(ccx.tcx, ast::ty_u8))}],\n-                output: ty::mk_nil(ccx.tcx)\n+                                   ty::mk_mach_uint(ast::ty_u8))}],\n+                output: ty::mk_nil()\n             }\n         });\n-        (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil(tcx))\n+        (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil())\n       }\n       ~\"morestack_addr\" => {\n-        (0u, ~[], ty::mk_nil_ptr(tcx))\n+        (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"memmove32\" => {\n         (0, ~[arg(ast::by_copy,\n                   ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl })),\n+                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_mutbl })),\n               arg(ast::by_copy,\n                   ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(tcx), mutbl: ast::m_imm })),\n+                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_imm })),\n               arg(ast::by_copy,\n-                  ty::mk_u32(tcx))],\n-         ty::mk_nil(tcx))\n+                  ty::mk_u32())],\n+         ty::mk_nil())\n       }\n       ~\"memmove64\" => {\n         (0, ~[arg(ast::by_copy,\n                   ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl })),\n+                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_mutbl })),\n               arg(ast::by_copy,\n                   ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(tcx), mutbl: ast::m_imm })),\n+                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_imm })),\n               arg(ast::by_copy,\n-                  ty::mk_u64(tcx))],\n-         ty::mk_nil(tcx))\n+                  ty::mk_u64())],\n+         ty::mk_nil())\n       }\n      ~\"sqrtf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"sqrtf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"powif32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx)),\n-               arg(ast::by_copy, ty::mk_i32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n+               arg(ast::by_copy, ty::mk_i32())],\n+         ty::mk_f32())\n      }\n      ~\"powif64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx)),\n-               arg(ast::by_copy, ty::mk_i32(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n+               arg(ast::by_copy, ty::mk_i32())],\n+         ty::mk_f64())\n      }\n      ~\"sinf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"sinf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"cosf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"cosf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"powf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx)),\n-               arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n+               arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"powf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx)),\n-               arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n+               arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"expf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"expf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"exp2f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"exp2f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"logf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"logf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"log10f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"log10f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"log2f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"log2f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"fmaf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx)),\n-               arg(ast::by_copy, ty::mk_f32(tcx)),\n-               arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n+               arg(ast::by_copy, ty::mk_f32()),\n+               arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"fmaf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx)),\n-               arg(ast::by_copy, ty::mk_f64(tcx)),\n-               arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n+               arg(ast::by_copy, ty::mk_f64()),\n+               arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"fabsf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"fabsf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"floorf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"floorf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"ceilf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"ceilf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"truncf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n-         ty::mk_f32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n+         ty::mk_f32())\n      }\n      ~\"truncf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n-         ty::mk_f64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n+         ty::mk_f64())\n      }\n      ~\"ctpop8\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i8(tcx))],\n-         ty::mk_i8(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n+         ty::mk_i8())\n      }\n      ~\"ctpop16\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i16(tcx))],\n-         ty::mk_i16(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n+         ty::mk_i16())\n      }\n      ~\"ctpop32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i32(tcx))],\n-         ty::mk_i32(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n+         ty::mk_i32())\n      }\n      ~\"ctpop64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i64(tcx))],\n-         ty::mk_i64(tcx))\n+        (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n+         ty::mk_i64())\n      }\n      ~\"ctlz8\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i8(tcx))],\n-         ty::mk_i8(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n+         ty::mk_i8())\n      }\n      ~\"ctlz16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16(tcx))],\n-         ty::mk_i16(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n+         ty::mk_i16())\n      }\n      ~\"ctlz32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32(tcx))],\n-         ty::mk_i32(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n+         ty::mk_i32())\n      }\n      ~\"ctlz64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64(tcx))],\n-         ty::mk_i64(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n+         ty::mk_i64())\n      }\n      ~\"cttz8\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i8(tcx))],\n-         ty::mk_i8(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n+         ty::mk_i8())\n      }\n      ~\"cttz16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16(tcx))],\n-         ty::mk_i16(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n+         ty::mk_i16())\n      }\n      ~\"cttz32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32(tcx))],\n-         ty::mk_i32(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n+         ty::mk_i32())\n      }\n      ~\"cttz64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64(tcx))],\n-         ty::mk_i64(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n+         ty::mk_i64())\n      }\n      ~\"bswap16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16(tcx))],\n-         ty::mk_i16(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n+         ty::mk_i16())\n      }\n      ~\"bswap32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32(tcx))],\n-         ty::mk_i32(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n+         ty::mk_i32())\n      }\n      ~\"bswap64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64(tcx))],\n-         ty::mk_i64(tcx))\n+         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n+         ty::mk_i64())\n      }\n      ref other => {\n         tcx.sess.span_err(it.span, ~\"unrecognized intrinsic function: `\" +"}, {"sha": "cd10e1f9787cba805c6cc2b41d7fa4da93291005", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -108,7 +108,7 @@ pub impl Rcx {\n         match resolve_type(self.fcx.infcx(), unresolved_ty,\n                            resolve_and_force_all_but_regions) {\n             Ok(t) => t,\n-            Err(_) => ty::mk_err(self.fcx.tcx())\n+            Err(_) => ty::mk_err()\n         }\n     }\n "}, {"sha": "894b508b30965e8d7c9e6728d7b586d3ef0077ff", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -57,7 +57,7 @@ fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: span, tys: &[ty::t])\n     tys.map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n             Some(t1) => t1,\n-            None => ty::mk_err(fcx.ccx.tcx)\n+            None => ty::mk_err()\n         }\n     })\n }"}, {"sha": "3f58a32247245283541af6f1df92ed8bb34fe933", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -613,14 +613,13 @@ pub fn super_tys<C:Combine>(\n         vid: ty::IntVid,\n         val: ty::IntVarValue) -> cres<ty::t>\n     {\n-        let tcx = self.infcx().tcx;\n         if val == IntType(ast::ty_char) {\n             Err(ty::terr_integer_as_char)\n         } else {\n             if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n             match val {\n-                IntType(v) => Ok(ty::mk_mach_int(tcx, v)),\n-                UintType(v) => Ok(ty::mk_mach_uint(tcx, v))\n+                IntType(v) => Ok(ty::mk_mach_int(v)),\n+                UintType(v) => Ok(ty::mk_mach_uint(v))\n             }\n         }\n     }\n@@ -631,9 +630,8 @@ pub fn super_tys<C:Combine>(\n         vid: ty::FloatVid,\n         val: ast::float_ty) -> cres<ty::t>\n     {\n-        let tcx = self.infcx().tcx;\n         if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n-        Ok(ty::mk_mach_float(tcx, val))\n+        Ok(ty::mk_mach_float(val))\n     }\n }\n "}, {"sha": "52a938a34d30f9c47c62dc26ee91de4482788915", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -327,7 +327,7 @@ impl LatticeDir for Glb {\n \n impl TyLatticeDir for Glb {\n     fn ty_bot(&self, _t: ty::t) -> cres<ty::t> {\n-        Ok(ty::mk_bot(self.infcx.tcx))\n+        Ok(ty::mk_bot())\n     }\n }\n "}, {"sha": "53b7b4f19585e43a5c79a0b299099032fe64879d", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -245,12 +245,12 @@ pub impl ResolveState {\n \n         let node = self.infcx.get(vid);\n         match node.possible_types {\n-          Some(IntType(t)) => ty::mk_mach_int(self.infcx.tcx, t),\n-          Some(UintType(t)) => ty::mk_mach_uint(self.infcx.tcx, t),\n+          Some(IntType(t)) => ty::mk_mach_int(t),\n+          Some(UintType(t)) => ty::mk_mach_uint(t),\n           None => {\n             if self.should(force_ivar) {\n                 // As a last resort, default to int.\n-                let ty = ty::mk_int(self.infcx.tcx);\n+                let ty = ty::mk_int();\n                 self.infcx.set(vid,\n                                Root(Some(IntType(ast::ty_i)), node.rank));\n                 ty\n@@ -268,11 +268,11 @@ pub impl ResolveState {\n \n         let node = self.infcx.get(vid);\n         match node.possible_types {\n-          Some(t) => ty::mk_mach_float(self.infcx.tcx, t),\n+          Some(t) => ty::mk_mach_float(t),\n           None => {\n             if self.should(force_fvar) {\n                 // As a last resort, default to float.\n-                let ty = ty::mk_float(self.infcx.tcx);\n+                let ty = ty::mk_float();\n                 self.infcx.set(vid, Root(Some(ast::ty_f), node.rank));\n                 ty\n             } else {"}, {"sha": "ad4938c9869bf048aea459f300d92bac0d9e3307", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ccee78a812b142a9f0d3d24d78bf6b5e190403/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=88ccee78a812b142a9f0d3d24d78bf6b5e190403", "patch": "@@ -363,11 +363,11 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n-                            inputs: ~[arg(ast::by_copy, ty::mk_int(tcx)),\n+                            inputs: ~[arg(ast::by_copy, ty::mk_int()),\n                                       arg(ast::by_copy, ty::mk_imm_ptr(tcx,\n-                                                            ty::mk_imm_ptr(tcx, ty::mk_u8(tcx)))),\n-                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx, ty::mk_u8(tcx)))],\n-                            output: ty::mk_int(tcx)}\n+                                                            ty::mk_imm_ptr(tcx, ty::mk_u8()))),\n+                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx, ty::mk_u8()))],\n+                            output: ty::mk_int()}\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,"}]}