{"sha": "f1dabed82bfed643fbbfc93203473e384c58d20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZGFiZWQ4MmJmZWQ2NDNmYmJmYzkzMjAzNDczZTM4NGM1OGQyMGE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-03-03T23:08:06Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-04-03T12:48:07Z"}, "message": "Introduce trans::declare\n\nWe provide tools to tell what exact symbols to emit for any fn or static, but\ndon\u2019t quite check if that won\u2019t cause any issues later on. Some of the issues\ninclude LLVM mangling our names again and our names pointing to wrong locations,\nus generating dumb foreign call wrappers, linker errors, extern functions\nresolving to different symbols altogether (extern {fn fail();} fail(); in some\ncases calling fail1()), etc.\n\nBefore the commit we had a function called note_unique_llvm_symbol, so it is\nclear somebody was aware of the issue at some point, but the function was barely\nused, mostly in irrelevant locations.\n\nAlong with working on it I took liberty to start refactoring trans/base into\na few smaller modules. The refactoring is incomplete and I hope I will find some\nmotivation to carry on with it.\n\nThis is possibly a [breaking-change] because it makes dumbly written code\nproperly invalid.", "tree": {"sha": "951cfd1da968f64826db56febbae29b11d1c5917", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/951cfd1da968f64826db56febbae29b11d1c5917"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1dabed82bfed643fbbfc93203473e384c58d20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1dabed82bfed643fbbfc93203473e384c58d20a", "html_url": "https://github.com/rust-lang/rust/commit/f1dabed82bfed643fbbfc93203473e384c58d20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1dabed82bfed643fbbfc93203473e384c58d20a/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caea044929decd3901aa64ef01126b32842f1a4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/caea044929decd3901aa64ef01126b32842f1a4e", "html_url": "https://github.com/rust-lang/rust/commit/caea044929decd3901aa64ef01126b32842f1a4e"}], "stats": {"total": 714, "additions": 430, "deletions": 284}, "files": [{"sha": "c7200fc8bb256157c4d0c5f01bcbc995fc175916", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 80, "deletions": 200, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -64,6 +64,7 @@ use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n+use trans::declare;\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n@@ -179,52 +180,14 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n-               ty: Type, output: ty::FnOutput) -> ValueRef {\n-\n-    let buf = CString::new(name).unwrap();\n-    let llfn: ValueRef = unsafe {\n-        llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf.as_ptr(), ty.to_ref())\n-    };\n-\n-    // diverging functions may unwind, but can never return normally\n-    if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n-    }\n-\n-    if ccx.tcx().sess.opts.cg.no_redzone\n-        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n-    }\n-\n-    llvm::SetFunctionCallConv(llfn, cc);\n-    // Function addresses in Rust are never significant, allowing functions to be merged.\n-    llvm::SetUnnamedAddr(llfn, true);\n-\n-    if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {\n-        attributes::split_stack(llfn, true);\n-    }\n-\n-    llfn\n-}\n-\n-// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-pub fn decl_cdecl_fn(ccx: &CrateContext,\n-                     name: &str,\n-                     ty: Type,\n-                     output: Ty) -> ValueRef {\n-    decl_fn(ccx, name, llvm::CCallConv, ty, ty::FnConverging(output))\n-}\n-\n fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n                                 name: &str, did: ast::DefId) -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n     }\n \n-    let f = decl_rust_fn(ccx, fn_ty, name);\n+    let f = declare::declare_rust_fn(ccx, name, fn_ty);\n \n     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n     attributes::from_fn_attrs(ccx, &attrs[..], f);\n@@ -254,63 +217,6 @@ pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::Closu\n     *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n }\n \n-pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    debug!(\"decl_rust_fn(fn_ty={}, name={:?})\",\n-           fn_ty.repr(ccx.tcx()),\n-           name);\n-\n-    let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n-\n-    debug!(\"decl_rust_fn: fn_ty={} (after normalized associated types)\",\n-           fn_ty.repr(ccx.tcx()));\n-\n-    let function_type; // placeholder so that the memory ownership works out ok\n-\n-    let (sig, abi, env) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n-            (&f.sig, f.abi, None)\n-        }\n-        ty::ty_closure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n-            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n-            let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n-            debug!(\"decl_rust_fn: function_type={} self_type={}\",\n-                   function_type.repr(ccx.tcx()),\n-                   self_type.repr(ccx.tcx()));\n-            (&function_type.sig, RustCall, Some(llenvironment_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or fn\")\n-    };\n-\n-    let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n-    let sig = ty::Binder(sig);\n-\n-    debug!(\"decl_rust_fn: sig={} (after erasing regions)\",\n-           sig.repr(ccx.tcx()));\n-\n-    let llfty = type_of_rust_fn(ccx, env, &sig, abi);\n-\n-    debug!(\"decl_rust_fn: llfty={}\",\n-           ccx.tn().type_to_string(llfty));\n-\n-    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output /* (1) */);\n-    let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n-    attrs.apply_llfn(llfn);\n-\n-    // (1) it's ok to directly access sig.0.output because we erased all late-bound-regions above\n-\n-    llfn\n-}\n-\n-pub fn decl_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    let llfn = decl_rust_fn(ccx, fn_ty, name);\n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-    llfn\n-}\n-\n pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n                                   t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n@@ -319,23 +225,22 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         Some(n) => return *n,\n         None => ()\n     }\n-    unsafe {\n-        let buf = CString::new(name.clone()).unwrap();\n-        let c = llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf.as_ptr());\n-        // Thread-local statics in some other crate need to *always* be linked\n-        // against in a thread-local fashion, so we need to be sure to apply the\n-        // thread-local attribute locally if it was present remotely. If we\n-        // don't do this then linker errors can be generated where the linker\n-        // complains that one object files has a thread local version of the\n-        // symbol and another one doesn't.\n-        for attr in &*ty::get_attrs(ccx.tcx(), did) {\n-            if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local(c, true);\n-            }\n+    // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+    // FIXME(nagisa): investigate whether it can be changed into define_global\n+    let c = declare::declare_global(ccx, &name[..], ty);\n+    // Thread-local statics in some other crate need to *always* be linked\n+    // against in a thread-local fashion, so we need to be sure to apply the\n+    // thread-local attribute locally if it was present remotely. If we\n+    // don't do this then linker errors can be generated where the linker\n+    // complains that one object files has a thread local version of the\n+    // symbol and another one doesn't.\n+    for attr in &*ty::get_attrs(ccx.tcx(), did) {\n+        if attr.check_name(\"thread_local\") {\n+            llvm::set_thread_local(c, true);\n         }\n-        ccx.externs().borrow_mut().insert(name.to_string(), c);\n-        return c;\n     }\n+    ccx.externs().borrow_mut().insert(name.to_string(), c);\n+    return c;\n }\n \n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -373,15 +278,6 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n \n-// Double-check that we never ask LLVM to declare the same symbol twice. It\n-// silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n-    if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym));\n-    }\n-    ccx.all_llvm_symbols().borrow_mut().insert(sym);\n-}\n-\n pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: ast::BinOp_, signed: bool)\n                                 -> llvm::IntPredicate {\n     match op {\n@@ -1713,15 +1609,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n     let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n     let abi = ty::ty_fn_abi(fn_ty);\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfndecl,\n-                  param_substs,\n-                  id,\n-                  attrs,\n-                  output_type,\n-                  abi,\n+    trans_closure(ccx, decl, body, llfndecl, param_substs, id, attrs, output_type, abi,\n                   closure::ClosureEnv::NotClosure);\n }\n \n@@ -2066,27 +1954,24 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                 let llfn = get_item_val(ccx, item.id);\n                 let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                 if abi != Rust {\n-                    foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                            &**decl,\n-                                                            &**body,\n-                                                            &item.attrs,\n-                                                            llfn,\n-                                                            empty_substs,\n-                                                            item.id,\n-                                                            None);\n+                    foreign::trans_rust_fn_with_foreign_abi(ccx, &**decl, &**body, &item.attrs,\n+                                                            llfn, empty_substs, item.id, None);\n                 } else {\n-                    trans_fn(ccx,\n-                             &**decl,\n-                             &**body,\n-                             llfn,\n-                             empty_substs,\n-                             item.id,\n-                             &item.attrs);\n+                    trans_fn(ccx, &**decl, &**body, llfn, empty_substs, item.id, &item.attrs);\n                 }\n-                update_linkage(ccx,\n-                               llfn,\n-                               Some(item.id),\n+                update_linkage(ccx, llfn, Some(item.id),\n                                if is_origin { OriginalTranslation } else { InlinedCopy });\n+\n+                if is_entry_fn(ccx.sess(), item.id) {\n+                    create_entry_wrapper(ccx, item.span, llfn);\n+                    // check for the #[rustc_error] annotation, which forces an\n+                    // error in trans. This is used to write compile-fail tests\n+                    // that actually test that compilation succeeds without\n+                    // reporting an error.\n+                    if ty::has_attr(ccx.tcx(), local_def(item.id), \"rustc_error\") {\n+                        ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n+                    }\n+                }\n             }\n         }\n \n@@ -2122,8 +2007,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          consts::trans_static(ccx, m, item.id);\n-          let g = get_item_val(ccx, item.id);\n+          let g = consts::trans_static(ccx, m, item.id);\n           update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n \n           // Do static_assert checking. It can't really be done much earlier\n@@ -2175,7 +2059,25 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     }\n }\n \n-fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::NodeId,\n+\n+// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n+pub fn register_fn_llvmty(ccx: &CrateContext,\n+                          sp: Span,\n+                          sym: String,\n+                          node_id: ast::NodeId,\n+                      cc: llvm::CallConv,\n+                          llfty: Type) -> ValueRef {\n+    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n+\n+    let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n+                                   ty::FnConverging(ty::mk_nil(ccx.tcx()))).unwrap_or_else(||{\n+        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n+    });\n+    finish_register_fn(ccx, sym, node_id, llfn);\n+    llfn\n+}\n+\n+fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n     ccx.item_symbols().borrow_mut().insert(node_id, sym);\n \n@@ -2190,19 +2092,6 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     if ccx.tcx().lang_items.eh_personality() == Some(def) {\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n-\n-\n-    if is_entry_fn(ccx.sess(), node_id) {\n-        // check for the #[rustc_error] annotation, which forces an\n-        // error in trans. This is used to write compile-fail tests\n-        // that actually test that compilation succeeds without\n-        // reporting an error.\n-        if ty::has_attr(ccx.tcx(), local_def(node_id), \"rustc_error\") {\n-            ccx.tcx().sess.span_fatal(sp, \"compilation successful\");\n-        }\n-\n-        create_entry_wrapper(ccx, sp, llfn);\n-    }\n }\n \n fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2221,26 +2110,10 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.sess().span_bug(sp, \"expected bare rust function\")\n     }\n \n-    let llfn = decl_rust_fn(ccx, node_type, &sym[..]);\n-    finish_register_fn(ccx, sp, sym, node_id, llfn);\n-    llfn\n-}\n-\n-// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: &CrateContext,\n-                          sp: Span,\n-                          sym: String,\n-                          node_id: ast::NodeId,\n-                          cc: llvm::CallConv,\n-                          llfty: Type) -> ValueRef {\n-    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n-\n-    let llfn = decl_fn(ccx,\n-                       &sym[..],\n-                       cc,\n-                       llfty,\n-                       ty::FnConverging(ty::mk_nil(ccx.tcx())));\n-    finish_register_fn(ccx, sp, sym, node_id, llfn);\n+    let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(||{\n+        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n+    });\n+    finish_register_fn(ccx, sym, node_id, llfn);\n     llfn\n }\n \n@@ -2251,27 +2124,36 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n     }\n }\n \n-// Create a _rust_main(args: ~[str]) function which will be called from the\n-// runtime rust_start function\n+/// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n+/// function.\n pub fn create_entry_wrapper(ccx: &CrateContext,\n                            _sp: Span,\n                            main_llfn: ValueRef) {\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n-            create_entry_fn(ccx, main_llfn, true);\n+            create_entry_fn(ccx, _sp, main_llfn, true);\n         }\n-        config::EntryStart => create_entry_fn(ccx, main_llfn, false),\n+        config::EntryStart => create_entry_fn(ccx, _sp, main_llfn, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n+    #[inline(never)]\n     fn create_entry_fn(ccx: &CrateContext,\n+                       _sp: Span,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n         let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type());\n \n-        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil(ccx.tcx()));\n+        let llfn = declare::define_cfn(ccx, \"main\", llfty,\n+                                       ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+            ccx.sess().span_err(_sp, \"entry symbol `main` defined multiple times\");\n+            // FIXME: We should be smart and show a better diagnostic here.\n+            ccx.sess().help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\");\n+            ccx.sess().abort_if_errors();\n+            panic!();\n+        });\n \n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n@@ -2407,14 +2289,15 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(&sym[..]) {\n-                            ccx.sess().fatal(\n-                                &format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym));\n-                        }\n-                        let buf = CString::new(sym.clone()).unwrap();\n-                        let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n-                                                    buf.as_ptr());\n+\n+                        // FIXME(nagisa): probably should be declare_global, because no definition\n+                        // is happening here, but we depend on it being defined here from\n+                        // const::trans_static. This all logic should be replaced.\n+                        let g = declare::define_global(ccx, &sym[..],\n+                                                       Type::from_ref(llty)).unwrap_or_else(||{\n+                            ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n+                                                                   sym))\n+                        });\n \n                         if attr::contains_name(&i.attrs,\n                                                \"thread_local\") {\n@@ -2430,10 +2313,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let llfn = if abi == Rust {\n                         register_fn(ccx, i.span, sym, i.id, ty)\n                     } else {\n-                        foreign::register_rust_fn_with_foreign_abi(ccx,\n-                                                                   i.span,\n-                                                                   sym,\n-                                                                   i.id)\n+                        foreign::register_rust_fn_with_foreign_abi(ccx, i.span, sym, i.id)\n                     };\n                     attributes::from_fn_attrs(ccx, &i.attrs, llfn);\n                     llfn"}, {"sha": "604f185f396b81994230f77d4738dd73d1334a0f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -41,6 +41,7 @@ use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n+use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::inline;\n@@ -326,13 +327,9 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n \n     //\n-    let function_name =\n-        link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n-                                                   \"fn_pointer_shim\");\n-    let llfn =\n-        decl_internal_rust_fn(ccx,\n-                              tuple_fn_ty,\n-                              &function_name[..]);\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n+                                                                   \"fn_pointer_shim\");\n+    let llfn = declare::declare_internal_rust_fn(ccx, &function_name[..], tuple_fn_ty);\n \n     //\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());"}, {"sha": "61af5bfaef8dee5db3da83e9ff959fad99ab1963", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -126,6 +126,7 @@ use trans::callee;\n use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeIdAndSpan};\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n+use trans::declare;\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n@@ -844,10 +845,8 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     Some(llpersonality) => llpersonality,\n                     None => {\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = base::decl_cdecl_fn(self.ccx,\n-                                                    \"rust_eh_personality\",\n-                                                    fty,\n-                                                    self.ccx.tcx().types.i32);\n+                        let f = declare::declare_cfn(self.ccx, \"rust_eh_personality\", fty,\n+                                                     self.ccx.tcx().types.i32);\n                         *personality = Some(f);\n                         f\n                     }"}, {"sha": "60d54cdebeb83ff670462d84edea05702ec05453", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n use trans::debuginfo::{self, DebugLoc};\n+use trans::declare;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n@@ -162,7 +163,11 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[..]);\n+    // Currently there\u2019s only a single user of get_or_create_declaration_if_closure and it\n+    // unconditionally defines the function, therefore we use define_* here.\n+    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type).unwrap_or_else(||{\n+        ccx.sess().bug(&format!(\"symbol `{}` already defined\", symbol));\n+    });\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);"}, {"sha": "153242353d49f5e5c9ac2cfefb482df90fc77861", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -31,6 +31,7 @@ use trans::cleanup;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo::{self, DebugLoc};\n+use trans::declare;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -872,9 +873,10 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let buf = CString::new(format!(\"str{}\", gsym.usize()));\n-        let buf = buf.unwrap();\n-        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n+        let sym = format!(\"str{}\", gsym.usize());\n+        let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n+            cx.sess().bug(&format!(\"symbol `{}` is already defined\", sym));\n+        });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);"}, {"sha": "336e68f1e8b496288cb20729e57a9ae93a596b03", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -25,6 +25,7 @@ use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n+use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n@@ -35,6 +36,7 @@ use util::ppaux::{Repr, ty_to_string};\n use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n+use syntax::parse::token;\n use syntax::ptr::P;\n \n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n@@ -96,13 +98,16 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n \n fn addr_of_mut(ccx: &CrateContext,\n                cv: ValueRef,\n-               kind: &str,\n-               id: ast::NodeId)\n+               kind: &str)\n                -> ValueRef {\n     unsafe {\n-        let name = format!(\"{}{}\\0\", kind, id);\n-        let gv = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(cv).to_ref(),\n-                                     name.as_ptr() as *const _);\n+        // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n+        // counter? Also most other uses of gensym in trans.\n+        let gsym = token::gensym(\"_\");\n+        let name = format!(\"{}{}\", kind, gsym.usize());\n+        let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n+            ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n+        });\n         llvm::LLVMSetInitializer(gv, cv);\n         SetLinkage(gv, InternalLinkage);\n         SetUnnamedAddr(gv, true);\n@@ -112,14 +117,13 @@ fn addr_of_mut(ccx: &CrateContext,\n \n pub fn addr_of(ccx: &CrateContext,\n                cv: ValueRef,\n-               kind: &str,\n-               id: ast::NodeId)\n+               kind: &str)\n                -> ValueRef {\n     match ccx.const_globals().borrow().get(&cv) {\n         Some(&gv) => return gv,\n         None => {}\n     }\n-    let gv = addr_of_mut(ccx, cv, kind, id);\n+    let gv = addr_of_mut(ccx, cv, kind);\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gv, True);\n     }\n@@ -233,7 +237,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let lvalue = addr_of(ccx, val, \"const\", expr.id);\n+    let lvalue = addr_of(ccx, val, \"const\");\n     ccx.const_values().borrow_mut().insert(key, lvalue);\n     lvalue\n }\n@@ -284,7 +288,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     if adj.autoderefs == 0 {\n                         // Don't copy data to do a deref+ref\n                         // (i.e., skip the last auto-deref).\n-                        llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                        llconst = addr_of(cx, llconst, \"autoref\");\n                     } else {\n                         // Seeing as we are deref'ing here and take a reference\n                         // again to make the pointer part of the far pointer below,\n@@ -312,7 +316,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 None => {}\n                 Some(box ty::AutoUnsafe(_, None)) |\n                 Some(box ty::AutoPtr(_, _, None)) => {\n-                    llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                    llconst = addr_of(cx, llconst, \"autoref\");\n                 }\n                 Some(box ty::AutoUnsize(ref k)) => {\n                     let info =\n@@ -711,12 +715,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                   // If this isn't the address of a static, then keep going through\n                   // normal constant evaluation.\n                   let (v, _) = const_expr(cx, &**sub, param_substs);\n-                  addr_of(cx, v, \"ref\", e.id)\n+                  addr_of(cx, v, \"ref\")\n               }\n           }\n           ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n               let (v, _) = const_expr(cx, &**sub, param_substs);\n-              addr_of_mut(cx, v, \"ref_mut_slice\", e.id)\n+              addr_of_mut(cx, v, \"ref_mut_slice\")\n           }\n           ast::ExprTup(ref es) => {\n               let repr = adt::represent_type(cx, ety);\n@@ -862,7 +866,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n@@ -888,6 +892,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n             }\n         }\n         debuginfo::create_global_var_metadata(ccx, id, g);\n+        g\n     }\n }\n "}, {"sha": "e54962dc085524e1b41fc337fc453503379c231d", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -20,6 +20,7 @@ use trans::base;\n use trans::builder::Builder;\n use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n+use trans::declare;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -133,7 +134,6 @@ pub struct LocalCrateContext<'tcx> {\n     llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n     type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n-    all_llvm_symbols: RefCell<FnvHashSet<String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n@@ -413,7 +413,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 llsizingtypes: RefCell::new(FnvHashMap()),\n                 adt_reprs: RefCell::new(FnvHashMap()),\n                 type_hashcodes: RefCell::new(FnvHashMap()),\n-                all_llvm_symbols: RefCell::new(FnvHashSet()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n@@ -653,10 +652,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.type_hashcodes\n     }\n \n-    pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n-        &self.local.all_llvm_symbols\n-    }\n-\n     pub fn stats<'a>(&'a self) -> &'a Stats {\n         &self.shared.stats\n     }\n@@ -743,17 +738,16 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(\n-                    ccx, $name, Type::func(&[], &$ret),\n-                    ty::mk_nil(ccx.tcx()));\n+                let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n+                                             ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, $name,\n-                                  Type::func(&[$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n+                let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n+                                             ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -888,9 +882,9 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name, fn($($arg),*) -> $ret);\n             } else if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n-                                      Type::func(&[$($arg),*], &$ret),\n-                                      ty::mk_nil(ccx.tcx()));\n+                let f = declare::declare_cfn(ccx, stringify!($cname),\n+                                             Type::func(&[$($arg),*], &$ret),\n+                                             ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "3ce883af07f6a56e94296a3d238bd2a286e5c024", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -417,8 +417,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx, filename);\n     let line = C_u32(ccx, loc.line as u32);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::addr_of(ccx, expr_file_line_const,\n-                                         \"panic_loc\", call_info.id);\n+    let expr_file_line = consts::addr_of(ccx, expr_file_line_const, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -450,8 +449,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_u32(ccx, loc.line as u32);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::addr_of(ccx, file_line_const,\n-                                    \"panic_bounds_check_loc\", call_info.id);\n+    let file_line = consts::addr_of(ccx, file_line_const, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "a32b40dc2b640b673e70a371c580d856831b24e1", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -196,8 +196,9 @@ use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n-use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n-                    C_bytes, NormalizingClosureTyper};\n+use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block, C_bytes,\n+                    NormalizingClosureTyper};\n+use trans::declare;\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -4071,7 +4072,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext)\n /// section.\n fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n                                                   -> llvm::ValueRef {\n-    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\\0\";\n+    let section_var_name = \"__rustc_debug_gdb_scripts_section__\";\n \n     let section_var = unsafe {\n         llvm::LLVMGetNamedGlobal(ccx.llmod(),\n@@ -4085,10 +4086,11 @@ fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n         unsafe {\n             let llvm_type = Type::array(&Type::i8(ccx),\n                                         section_contents.len() as u64);\n-            let section_var = llvm::LLVMAddGlobal(ccx.llmod(),\n-                                                  llvm_type.to_ref(),\n-                                                  section_var_name.as_ptr()\n-                                                    as *const _);\n+\n+            let section_var = declare::define_global(ccx, section_var_name,\n+                                                     llvm_type).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+            });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);"}, {"sha": "147b5161a4ac2fdca1d9feec8b638b7590a4eb50", "filename": "src/librustc_trans/trans/declare.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -0,0 +1,263 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//! Declare various LLVM values.\n+//!\n+//! Prefer using functions and methods from this module rather than calling LLVM functions\n+//! directly. These functions do some additional work to ensure we do the right thing given\n+//! the preconceptions of trans.\n+//!\n+//! Some useful guidelines:\n+//!\n+//! * Use declare_* family of methods if you are declaring, but are not interested in defining the\n+//! ValueRef they return.\n+//! * Use define_* family of methods when you might be defining the ValueRef.\n+//! * When in doubt, define.\n+#![allow(dead_code)]\n+\n+use llvm::{self, ValueRef};\n+use middle::ty::{self, ClosureTyper};\n+use syntax::abi;\n+use trans::attributes;\n+use trans::base;\n+use trans::common;\n+use trans::context::CrateContext;\n+use trans::monomorphize;\n+use trans::type_::Type;\n+use trans::type_of;\n+use util::ppaux::Repr;\n+\n+use std::ffi::CString;\n+use libc::c_uint;\n+\n+\n+/// Declare a global value.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will return its ValueRef\n+/// instead.\n+pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n+    debug!(\"declare_global(name={:?})\", name);\n+    let namebuf = CString::new(name).unwrap_or_else(|_|{\n+        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+    });\n+    unsafe {\n+        llvm::LLVMGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+    }\n+}\n+\n+\n+/// Declare a function.\n+///\n+/// For rust functions use `declare_rust_fn` instead.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type,\n+                  output: ty::FnOutput) -> ValueRef {\n+    debug!(\"declare_fn(name={:?})\", name);\n+    let namebuf = CString::new(name).unwrap_or_else(|_|{\n+        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+    });\n+    let llfn = unsafe {\n+        llvm::LLVMGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+    };\n+\n+    llvm::SetFunctionCallConv(llfn, callconv);\n+    // Function addresses in Rust are never significant, allowing functions to be merged.\n+    llvm::SetUnnamedAddr(llfn, true);\n+\n+    if output == ty::FnDiverging {\n+        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n+    }\n+\n+    if ccx.tcx().sess.opts.cg.no_redzone\n+        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n+        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n+    }\n+\n+    if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {\n+        attributes::split_stack(llfn, true);\n+    }\n+    llfn\n+}\n+\n+\n+/// Declare a C ABI function.\n+///\n+/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n+/// instead.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type, output: ty::Ty) -> ValueRef {\n+    declare_fn(ccx, name, llvm::CCallConv, fn_type, ty::FnConverging(output))\n+}\n+\n+\n+/// Declare a Rust function.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                 fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name, fn_type.repr(ccx.tcx()));\n+    let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n+    debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n+           fn_type.repr(ccx.tcx()));\n+\n+    let function_type; // placeholder so that the memory ownership works out ok\n+    let (sig, abi, env) = match fn_type.sty {\n+        ty::ty_bare_fn(_, ref f) => {\n+            (&f.sig, f.abi, None)\n+        }\n+        ty::ty_closure(closure_did, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n+            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n+            let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n+            debug!(\"declare_rust_fn function_type={} self_type={}\",\n+                   function_type.repr(ccx.tcx()), self_type.repr(ccx.tcx()));\n+            (&function_type.sig, abi::RustCall, Some(llenvironment_type))\n+        }\n+        _ => ccx.sess().bug(\"expected closure or fn\")\n+    };\n+\n+    let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n+    debug!(\"declare_rust_fn (after region erasure) sig={}\", sig.repr(ccx.tcx()));\n+    let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n+    debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n+\n+    // it is ok to directly access sig.0.output because we erased all late-bound-regions above\n+    let llfn = declare_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output);\n+    attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n+    llfn\n+}\n+\n+\n+/// Declare a Rust function with internal linkage.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                          fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    let llfn = declare_rust_fn(ccx, name, fn_type);\n+    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+    llfn\n+}\n+\n+\n+/// Declare a global with an intention to define it.\n+///\n+/// Use this function when you intend to define a global. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_global(ccx, name, ty))\n+    }\n+}\n+\n+\n+/// Declare a function with an intention to define it.\n+///\n+/// For rust functions use `define_rust_fn` instead.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_type: Type,\n+                 output: ty::FnOutput) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_fn(ccx, name, callconv, fn_type, output))\n+    }\n+}\n+\n+\n+/// Declare a C ABI function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+///\n+/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n+/// instead.\n+pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n+                  output: ty::Ty) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_cfn(ccx, name, fn_type, output))\n+    }\n+}\n+\n+\n+/// Declare a Rust function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_rust_fn(ccx, name, fn_type))\n+    }\n+}\n+\n+\n+/// Declare a Rust function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                         fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_internal_rust_fn(ccx, name, fn_type))\n+    }\n+}\n+\n+\n+/// Get defined or externally defined (AvailableExternally linkage) value by name.\n+fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+    debug!(\"get_defined_value(name={:?})\", name);\n+    let namebuf = CString::new(name).unwrap_or_else(|_|{\n+        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+    });\n+    let val = unsafe { llvm::LLVMGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n+    if val.is_null() {\n+        debug!(\"get_defined_value: {:?} value is null\", name);\n+        None\n+    } else {\n+        let (declaration, aext_link) = unsafe {\n+            let linkage = llvm::LLVMGetLinkage(val);\n+            (llvm::LLVMIsDeclaration(val) != 0,\n+             linkage == llvm::AvailableExternallyLinkage as c_uint)\n+        };\n+        debug!(\"get_defined_value: found {:?} value (declaration: {}, aext_link: {})\", name,\n+               declaration, aext_link);\n+        if !declaration || aext_link {\n+            Some(val)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "8f3a51a5007096984835901d54f13b8f07b21150", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -20,6 +20,7 @@ use trans::build::*;\n use trans::cabi;\n use trans::common::*;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -28,7 +29,6 @@ use trans::type_of;\n use middle::ty::{self, Ty};\n use middle::subst::Substs;\n \n-use std::ffi::CString;\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n@@ -136,9 +136,7 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let buf = CString::new(ident.as_bytes()).unwrap();\n-                let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n-                                             buf.as_ptr());\n+                let g1 = declare::declare_global(ccx, &ident[..], llty2);\n                 llvm::SetLinkage(g1, linkage);\n \n                 // Declare an internal global `extern_with_linkage_foo` which\n@@ -149,19 +147,17 @@ pub fn register_static(ccx: &CrateContext,\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(&ident);\n-                let real_name = CString::new(real_name).unwrap();\n-                let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n-                                             real_name.as_ptr());\n+                let g2 = declare::define_global(ccx, &real_name[..], llty).unwrap_or_else(||{\n+                    ccx.sess().span_fatal(foreign_item.span,\n+                                          &format!(\"symbol `{}` is already defined\", ident))\n+                });\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n                 g2\n             }\n         }\n-        None => unsafe {\n-            // Generate an external declaration.\n-            let buf = CString::new(ident.as_bytes()).unwrap();\n-            llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n-        }\n+        None => // Generate an external declaration.\n+            declare::declare_global(ccx, &ident[..], llty),\n     }\n }\n \n@@ -177,7 +173,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n         Some(n) => return *n,\n         None => {}\n     }\n-    let f = base::decl_fn(ccx, name, cc, ty, ty::FnConverging(output));\n+    let f = declare::declare_fn(ccx, name, cc, ty, ty::FnConverging(output));\n     externs.insert(name.to_string(), f);\n     f\n }\n@@ -534,7 +530,8 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n-    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n+                                   ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n@@ -623,7 +620,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[..]);\n+        let llfn = declare::define_internal_rust_fn(ccx, &ps[..], t).unwrap_or_else(||{\n+            ccx.sess().bug(&format!(\"symbol `{}` already defined\", ps));\n+        });\n         attributes::from_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn"}, {"sha": "abcd2882b173e90e41e4e69dd5409c6c9986d6cc", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -33,6 +33,7 @@ use trans::common::*;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::expr;\n use trans::foreign;\n use trans::inline;\n@@ -184,7 +185,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n     if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n-        let llfn = decl_cdecl_fn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n+        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n         ccx.drop_glues().borrow_mut().insert(t, llfn);\n         return llfn;\n     };\n@@ -294,12 +295,8 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did,\n                                      &[get_drop_glue_type(ccx, t)],\n                                      ty::mk_nil(ccx.tcx()));\n-        foreign::get_extern_fn(ccx,\n-                      &mut *ccx.externs().borrow_mut(),\n-                      &name[..],\n-                      llvm::CCallConv,\n-                      llty,\n-                      dtor_ty)\n+        foreign::get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), &name[..], llvm::CCallConv,\n+                               llty, dtor_ty)\n     }\n }\n "}, {"sha": "e2f965a95fff78f130638f508f322287d2845e2c", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -28,6 +28,7 @@ use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::expr::SaveIn;\n use trans::expr;\n use trans::glue;\n@@ -590,10 +591,10 @@ pub fn trans_object_shim<'a, 'tcx>(\n     //\n     let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n     let method_bare_fn_ty = ty::mk_bare_fn(tcx, None, method_ty);\n-    let function_name =\n-        link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n-    let llfn =\n-        decl_internal_rust_fn(ccx, shim_fn_ty, &function_name);\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n+    let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty).unwrap_or_else(||{\n+        ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n+    });\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n@@ -756,8 +757,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         C_uint(ccx, align)\n     ].into_iter().chain(methods).collect();\n \n-    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false),\n-                                 \"vtable\", trait_ref.def_id().node);\n+    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false), \"vtable\");\n \n     ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable"}, {"sha": "7d568ff90ea43cbc0dbfe078f258000fa807b88b", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -43,6 +43,7 @@ mod context;\n mod controlflow;\n mod datum;\n mod debuginfo;\n+mod declare;\n mod expr;\n mod foreign;\n mod glue;"}, {"sha": "1c8d020494fabfa0788d0c053d3ea0a37d38c3bb", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dabed82bfed643fbbfc93203473e384c58d20a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=f1dabed82bfed643fbbfc93203473e384c58d20a", "patch": "@@ -19,9 +19,10 @@ use middle::traits;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n-use trans::base::{trans_fn, decl_internal_rust_fn};\n+use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n+use trans::declare;\n use trans::foreign;\n use middle::ty::{self, HasProjectionTypes, Ty};\n use util::ppaux::Repr;\n@@ -143,7 +144,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let lldecl = if abi != abi::Rust {\n             foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, &s[..])\n+            // FIXME(nagisa): perhaps needs a more fine grained selection? See setup_lldecl below.\n+            declare::define_internal_rust_fn(ccx, &s[..], mono_ty).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` already defined\", s));\n+            })\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);"}]}