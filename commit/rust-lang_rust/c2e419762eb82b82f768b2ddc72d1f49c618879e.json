{"sha": "c2e419762eb82b82f768b2ddc72d1f49c618879e", "node_id": "C_kwDOAAsO6NoAKGMyZTQxOTc2MmViODJiODJmNzY4YjJkZGM3MmQxZjQ5YzYxODg3OWU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-31T13:19:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-01T13:28:35Z"}, "message": "tighter checks for (some) ScalarPair layouts", "tree": {"sha": "72e21b09bde1f3c6fc385a0adeb78b6bd9732381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72e21b09bde1f3c6fc385a0adeb78b6bd9732381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e419762eb82b82f768b2ddc72d1f49c618879e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e419762eb82b82f768b2ddc72d1f49c618879e", "html_url": "https://github.com/rust-lang/rust/commit/c2e419762eb82b82f768b2ddc72d1f49c618879e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e419762eb82b82f768b2ddc72d1f49c618879e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "html_url": "https://github.com/rust-lang/rust/commit/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9"}], "stats": {"total": 118, "additions": 102, "deletions": 16}, "files": [{"sha": "c79b3e7e350a8683e843703694e542d990d19573", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 102, "deletions": 16, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c2e419762eb82b82f768b2ddc72d1f49c618879e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e419762eb82b82f768b2ddc72d1f49c618879e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c2e419762eb82b82f768b2ddc72d1f49c618879e", "patch": "@@ -240,7 +240,11 @@ fn sanity_check_layout<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLa\n         ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n             (0..layout.layout.fields().count()).filter_map(|i| {\n                 let field = layout.field(cx, i);\n-                let zst = field.is_zst() && field.align.abi.bytes() == 1;\n+                // Also checking `align == 1` here leads to test failures in\n+                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n+                // alignment 4 that still gets ignored during layout computation (which is okay\n+                // since other fields already force alignment 4).\n+                let zst = field.is_zst();\n                 (!zst).then(|| (layout.fields.offset(i), field))\n             })\n         }\n@@ -327,38 +331,120 @@ fn sanity_check_layout<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLa\n                                 field.align.abi, align,\n                                 \"`Scalar` field with bad align in {inner:#?}\",\n                             );\n+                            assert!(\n+                                matches!(field.abi, Abi::Scalar(_)),\n+                                \"`Scalar` field with bad ABI in {inner:#?}\",\n+                            );\n                         }\n                         _ => {\n                             panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n                         }\n                     }\n                 }\n-                Abi::Vector { count, element } => {\n-                    // No padding in vectors. Alignment can be strengthened, though.\n-                    assert!(\n-                        layout.layout.align().abi >= element.align(cx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    let size = element.size(cx) * count;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size.align_to(cx.data_layout().vector_align(size).abi),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                }\n                 Abi::ScalarPair(scalar1, scalar2) => {\n                     // Sanity-check scalar pairs. These are a bit more flexible and support\n                     // padding, but we can at least ensure both fields actually fit into the layout\n                     // and the alignment requirement has not been weakened.\n+                    let size1 = scalar1.size(cx);\n                     let align1 = scalar1.align(cx).abi;\n+                    let size2 = scalar2.size(cx);\n                     let align2 = scalar2.align(cx).abi;\n                     assert!(\n                         layout.layout.align().abi >= cmp::max(align1, align2),\n                         \"alignment mismatch between ABI and layout in {layout:#?}\",\n                     );\n-                    let field2_offset = scalar1.size(cx).align_to(align2);\n+                    let field2_offset = size1.align_to(align2);\n+                    assert!(\n+                        layout.layout.size() >= field2_offset + size2,\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    // Check that the underlying pair of fields matches.\n+                    let inner = skip_newtypes(cx, layout);\n+                    assert!(\n+                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n+                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n+                        layout.ty,\n+                        inner.ty\n+                    );\n+                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n+                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n+                        // to check anything about them.\n+                        return;\n+                    }\n+                    match inner.layout.fields() {\n+                        FieldsShape::Arbitrary { .. } => {\n+                            // Checked below.\n+                        }\n+                        FieldsShape::Union(..) => {\n+                            // FIXME: I guess we could also check something here? Like, look at all fields?\n+                            return;\n+                        }\n+                        _ => {\n+                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n+                        }\n+                    }\n+                    let mut fields = non_zst_fields(cx, &inner);\n+                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n+                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n+                    });\n+                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n+                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n+                    });\n+                    assert!(\n+                        fields.next().is_none(),\n+                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n+                    );\n+                    // The fields might be in opposite order.\n+                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n+                        (offset1, field1, offset2, field2)\n+                    } else {\n+                        (offset2, field2, offset1, field1)\n+                    };\n+                    // The fields should be at the right offset, and match the `scalar` layout.\n+                    assert_eq!(\n+                        offset1,\n+                        Size::ZERO,\n+                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field1.size, size1,\n+                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field1.align.abi, align1,\n+                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n+                    );\n+                    assert!(\n+                        matches!(field1.abi, Abi::Scalar(_)),\n+                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        offset2, field2_offset,\n+                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field2.size, size2,\n+                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field2.align.abi, align2,\n+                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n+                    );\n+                    assert!(\n+                        matches!(field2.abi, Abi::Scalar(_)),\n+                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n+                    );\n+                }\n+                Abi::Vector { count, element } => {\n+                    // No padding in vectors. Alignment can be strengthened, though.\n                     assert!(\n-                        layout.layout.size() >= field2_offset + scalar2.size(cx),\n+                        layout.layout.align().abi >= element.align(cx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    let size = element.size(cx) * count;\n+                    assert_eq!(\n+                        layout.layout.size(),\n+                        size.align_to(cx.data_layout().vector_align(size).abi),\n                         \"size mismatch between ABI and layout in {layout:#?}\"\n                     );\n                 }"}]}