{"sha": "dfb8c80e118a6844e3a7130a884e92dde4ef4694", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYjhjODBlMTE4YTY4NDRlM2E3MTMwYTg4NGU5MmRkZTRlZjQ2OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T11:22:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T11:22:08Z"}, "message": "Auto merge of #42659 - nikomatsakis:issue-42545-type-inference-regression, r=eddyb\n\nIssue 42545 type inference regression\n\nFix an ICE that results from type inference obligations being dropped on the floor. Specifically, when computing the implied bounds, we would sometimes do normalizations that get stored in the cache, but we would *not* try to solve the resulting obligations. This can sometimes leave type variables uninferred. Occurs only rarely because implied bounds are processed in regionck which happens very late, so usually the cache is populated already from somewhere else.\n\nI think that the *proper* fix here is probably lazy normalization. This fix is intentionally very narrow both because this code is on the chopping block and because this needs a beta backport.\n\nr? @eddyb\ncc @arielb1", "tree": {"sha": "01d90b5b421e2e033c9be17dbae129a3b2322dd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d90b5b421e2e033c9be17dbae129a3b2322dd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfb8c80e118a6844e3a7130a884e92dde4ef4694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb8c80e118a6844e3a7130a884e92dde4ef4694", "html_url": "https://github.com/rust-lang/rust/commit/dfb8c80e118a6844e3a7130a884e92dde4ef4694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfb8c80e118a6844e3a7130a884e92dde4ef4694/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff9f2d2ae94fd951229c33ae55076fce4f68fab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9f2d2ae94fd951229c33ae55076fce4f68fab0", "html_url": "https://github.com/rust-lang/rust/commit/ff9f2d2ae94fd951229c33ae55076fce4f68fab0"}, {"sha": "9fec4093df1b31a3d63100922136e7bfb53c0d26", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fec4093df1b31a3d63100922136e7bfb53c0d26", "html_url": "https://github.com/rust-lang/rust/commit/9fec4093df1b31a3d63100922136e7bfb53c0d26"}], "stats": {"total": 376, "additions": 210, "deletions": 166}, "files": [{"sha": "de738fba30e928796ff762229671555fd07360ff", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=dfb8c80e118a6844e3a7130a884e92dde4ef4694", "patch": "@@ -18,7 +18,6 @@\n use hir::def_id::DefId;\n use middle::region::RegionMaps;\n use ty::{self, Lift, TyCtxt, Region};\n-use ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n /// Combines a `RegionMaps` (which governs relationships between\n@@ -136,23 +135,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         self.relation.is_empty()\n     }\n \n-    pub fn relate_free_regions_from_implied_bounds(&mut self,\n-                                                   implied_bounds: &[ImpliedBound<'tcx>])\n-    {\n-        debug!(\"relate_free_regions_from_implied_bounds()\");\n-        for implied_bound in implied_bounds {\n-            debug!(\"implied bound: {:?}\", implied_bound);\n-            match *implied_bound {\n-                ImpliedBound::RegionSubRegion(a, b) => {\n-                    self.relate_regions(a, b);\n-                }\n-                ImpliedBound::RegionSubParam(..) |\n-                ImpliedBound::RegionSubProjection(..) => {\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn relate_free_regions_from_predicates(&mut self,\n                                                predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n@@ -177,7 +159,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n \n     // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n     // (with the exception that `'static: 'x` is not notable)\n-    fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+    pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n             self.relation.add(sub, sup)\n         }"}, {"sha": "2eb0acac4f7ec398b363c62186b43417f76d81b4", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=dfb8c80e118a6844e3a7130a884e92dde4ef4694", "patch": "@@ -10,7 +10,6 @@\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n-use ty::outlives::Component;\n use ty::subst::Substs;\n use traits;\n use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -107,133 +106,6 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     wf.normalize()\n }\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-#[derive(Debug)]\n-pub enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n-/// Compute the implied bounds that a callee/impl can assume based on\n-/// the fact that caller/projector has ensured that `ty` is WF.  See\n-/// the `ImpliedBound` type for more details.\n-pub fn implied_bounds<'a, 'gcx, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body_id: ast::NodeId,\n-    ty: Ty<'tcx>,\n-    span: Span)\n-    -> Vec<ImpliedBound<'tcx>>\n-{\n-    // Sometimes when we ask what it takes for T: WF, we get back that\n-    // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Currently (at least) these resulting\n-    // predicates are always guaranteed to be a subset of the original\n-    // type, so we need not fear non-termination.\n-    let mut wf_types = vec![ty];\n-\n-    let mut implied_bounds = vec![];\n-\n-    while let Some(ty) = wf_types.pop() {\n-        // Compute the obligations for `ty` to be well-formed. If `ty` is\n-        // an unresolved inference variable, just substituted an empty set\n-        // -- because the return type here is going to be things we *add*\n-        // to the environment, it's always ok for this set to be smaller\n-        // than the ultimate set. (Note: normally there won't be\n-        // unresolved inference variables here anyway, but there might be\n-        // during typeck under some circumstances.)\n-        let obligations = obligations(infcx, param_env, body_id, ty, span).unwrap_or(vec![]);\n-\n-        // From the full set of obligations, just filter down to the\n-        // region relationships.\n-        implied_bounds.extend(\n-            obligations\n-            .into_iter()\n-            .flat_map(|obligation| {\n-                assert!(!obligation.has_escaping_regions());\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::ObjectSafe(..) =>\n-                        vec![],\n-\n-                    ty::Predicate::WellFormed(subty) => {\n-                        wf_types.push(subty);\n-                        vec![]\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref data) =>\n-                        match infcx.tcx.no_late_bound_regions(data) {\n-                            None =>\n-                                vec![],\n-                            Some(ty::OutlivesPredicate(r_a, r_b)) =>\n-                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n-                        },\n-\n-                    ty::Predicate::TypeOutlives(ref data) =>\n-                        match infcx.tcx.no_late_bound_regions(data) {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n-                                let components = infcx.tcx.outlives_components(ty_a);\n-                                implied_bounds_from_components(r_b, components)\n-                            }\n-                        },\n-                }}));\n-    }\n-\n-    implied_bounds\n-}\n-\n-/// When we have an implied bound that `T: 'a`, we can further break\n-/// this down to determine what relationships would have to hold for\n-/// `T: 'a` to hold. We get to assume that the caller has validated\n-/// those relationships.\n-fn implied_bounds_from_components<'tcx>(sub_region: ty::Region<'tcx>,\n-                                        sup_components: Vec<Component<'tcx>>)\n-                                        -> Vec<ImpliedBound<'tcx>>\n-{\n-    sup_components\n-        .into_iter()\n-        .flat_map(|component| {\n-            match component {\n-                Component::Region(r) =>\n-                    vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n-                Component::Param(p) =>\n-                    vec![ImpliedBound::RegionSubParam(sub_region, p)],\n-                Component::Projection(p) =>\n-                    vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n-                Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                    vec![],\n-                Component::UnresolvedInferenceVariable(..) =>\n-                    vec![],\n-            }\n-        })\n-        .collect()\n-}\n-\n struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "44d85791f35c542bdea5872c91ebfe422ade6c49", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dfb8c80e118a6844e3a7130a884e92dde4ef4694", "patch": "@@ -614,7 +614,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             .register_predicate_obligation(self, obligation);\n     }\n \n-    fn register_predicates(&self, obligations: Vec<traits::PredicateObligation<'tcx>>) {\n+    fn register_predicates<I>(&self, obligations: I)\n+    where I: IntoIterator<Item = traits::PredicateObligation<'tcx>> {\n         for obligation in obligations {\n             self.register_predicate(obligation);\n         }"}, {"sha": "5e79237da69d46a979b6c9fb325a182e1a91cbe6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 167, "deletions": 18, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=dfb8c80e118a6844e3a7130a884e92dde4ef4694", "patch": "@@ -94,7 +94,8 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n use rustc::ty::adjustment;\n-use rustc::ty::wf::ImpliedBound;\n+use rustc::ty::outlives::Component;\n+use rustc::ty::wf;\n \n use std::mem;\n use std::ops::Deref;\n@@ -196,6 +197,24 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n }\n \n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n     type Target = FnCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -386,11 +405,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds =\n-                ty::wf::implied_bounds(self, self.fcx.param_env, body_id, ty, span);\n-\n-            // Record any relations between free regions that we observe into the free-region-map.\n-            self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n+            let implied_bounds = self.implied_bounds(body_id, ty, span);\n \n             // But also record other relationships, such as `T:'x`,\n             // that don't go into the free-region-map but which we use\n@@ -410,16 +425,18 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n                         self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n                     }\n-                    ImpliedBound::RegionSubRegion(..) => {\n+                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n                         // strictly less that we can successfully type\n-                        // check. (It may also be that we should\n-                        // revise our inference system to be more\n-                        // general and to make use of *every*\n-                        // relationship that arises here, but\n-                        // presently we do not.)\n+                        // check. Right now we only look for things\n+                        // relationships between free regions. (It may\n+                        // also be that we should revise our inference\n+                        // system to be more general and to make use\n+                        // of *every* relationship that arises here,\n+                        // but presently we do not.)\n+                        self.free_region_map.relate_regions(r_a, r_b);\n                     }\n                 }\n             }\n@@ -428,6 +445,138 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"<< relate_free_regions\");\n     }\n \n+    /// Compute the implied bounds that a callee/impl can assume based on\n+    /// the fact that caller/projector has ensured that `ty` is WF.  See\n+    /// the `ImpliedBound` type for more details.\n+    fn implied_bounds(&mut self, body_id: ast::NodeId, ty: Ty<'tcx>, span: Span)\n+                      -> Vec<ImpliedBound<'tcx>> {\n+        // Sometimes when we ask what it takes for T: WF, we get back that\n+        // U: WF is required; in that case, we push U onto this stack and\n+        // process it next. Currently (at least) these resulting\n+        // predicates are always guaranteed to be a subset of the original\n+        // type, so we need not fear non-termination.\n+        let mut wf_types = vec![ty];\n+\n+        let mut implied_bounds = vec![];\n+\n+        while let Some(ty) = wf_types.pop() {\n+            // Compute the obligations for `ty` to be well-formed. If `ty` is\n+            // an unresolved inference variable, just substituted an empty set\n+            // -- because the return type here is going to be things we *add*\n+            // to the environment, it's always ok for this set to be smaller\n+            // than the ultimate set. (Note: normally there won't be\n+            // unresolved inference variables here anyway, but there might be\n+            // during typeck under some circumstances.)\n+            let obligations =\n+                wf::obligations(self, self.fcx.param_env, body_id, ty, span)\n+                .unwrap_or(vec![]);\n+\n+            // NB: All of these predicates *ought* to be easily proven\n+            // true. In fact, their correctness is (mostly) implied by\n+            // other parts of the program. However, in #42552, we had\n+            // an annoying scenario where:\n+            //\n+            // - Some `T::Foo` gets normalized, resulting in a\n+            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+            //   (not sure why it couldn't immediately get\n+            //   solved). This result of `_1` got cached.\n+            // - These obligations were dropped on the floor here,\n+            //   rather than being registered.\n+            // - Then later we would get a request to normalize\n+            //   `T::Foo` which would result in `_1` being used from\n+            //   the cache, but hence without the `T: Trait<Foo=_1>`\n+            //   constraint. As a result, `_1` never gets resolved,\n+            //   and we get an ICE (in dropck).\n+            //\n+            // Therefore, we register any predicates involving\n+            // inference variables. We restrict ourselves to those\n+            // involving inference variables both for efficiency and\n+            // to avoids duplicate errors that otherwise show up.\n+            self.fcx.register_predicates(\n+                obligations.iter()\n+                           .filter(|o| o.predicate.has_infer_types())\n+                           .cloned());\n+\n+            // From the full set of obligations, just filter down to the\n+            // region relationships.\n+            implied_bounds.extend(\n+                obligations\n+                    .into_iter()\n+                    .flat_map(|obligation| {\n+                        assert!(!obligation.has_escaping_regions());\n+                        match obligation.predicate {\n+                            ty::Predicate::Trait(..) |\n+                            ty::Predicate::Equate(..) |\n+                            ty::Predicate::Subtype(..) |\n+                            ty::Predicate::Projection(..) |\n+                            ty::Predicate::ClosureKind(..) |\n+                            ty::Predicate::ObjectSafe(..) =>\n+                                vec![],\n+\n+                            ty::Predicate::WellFormed(subty) => {\n+                                wf_types.push(subty);\n+                                vec![]\n+                            }\n+\n+                            ty::Predicate::RegionOutlives(ref data) =>\n+                                match self.tcx.no_late_bound_regions(data) {\n+                                    None =>\n+                                        vec![],\n+                                    Some(ty::OutlivesPredicate(r_a, r_b)) =>\n+                                        vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n+                                },\n+\n+                            ty::Predicate::TypeOutlives(ref data) =>\n+                                match self.tcx.no_late_bound_regions(data) {\n+                                    None => vec![],\n+                                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                        let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n+                                        let components = self.tcx.outlives_components(ty_a);\n+                                        self.implied_bounds_from_components(r_b, components)\n+                                    }\n+                                },\n+                        }}));\n+        }\n+\n+        implied_bounds\n+    }\n+\n+    /// When we have an implied bound that `T: 'a`, we can further break\n+    /// this down to determine what relationships would have to hold for\n+    /// `T: 'a` to hold. We get to assume that the caller has validated\n+    /// those relationships.\n+    fn implied_bounds_from_components(&self,\n+                                      sub_region: ty::Region<'tcx>,\n+                                      sup_components: Vec<Component<'tcx>>)\n+                                      -> Vec<ImpliedBound<'tcx>>\n+    {\n+        sup_components\n+            .into_iter()\n+            .flat_map(|component| {\n+                match component {\n+                    Component::Region(r) =>\n+                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n+                    Component::Param(p) =>\n+                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n+                    Component::Projection(p) =>\n+                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n+                    Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                        vec![],\n+                    Component::UnresolvedInferenceVariable(..) =>\n+                        vec![],\n+                }\n+            })\n+            .collect()\n+    }\n+\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_maps,\n@@ -1353,25 +1502,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn components_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n-                               components: Vec<ty::outlives::Component<'tcx>>,\n+                               components: Vec<Component<'tcx>>,\n                                region: ty::Region<'tcx>)\n     {\n         for component in components {\n             let origin = origin.clone();\n             match component {\n-                ty::outlives::Component::Region(region1) => {\n+                Component::Region(region1) => {\n                     self.sub_regions(origin, region, region1);\n                 }\n-                ty::outlives::Component::Param(param_ty) => {\n+                Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, param_ty);\n                 }\n-                ty::outlives::Component::Projection(projection_ty) => {\n+                Component::Projection(projection_ty) => {\n                     self.projection_must_outlive(origin, region, projection_ty);\n                 }\n-                ty::outlives::Component::EscapingProjection(subcomponents) => {\n+                Component::EscapingProjection(subcomponents) => {\n                     self.components_must_outlive(origin, subcomponents, region);\n                 }\n-                ty::outlives::Component::UnresolvedInferenceVariable(v) => {\n+                Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error\n                     // later, since if a type variable is not resolved by\n                     // this point it never will be"}, {"sha": "fd1265b7174f6de7668c971f967045f1d8ef3b1e", "filename": "src/test/run-pass/issue-42552.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Ftest%2Frun-pass%2Fissue-42552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb8c80e118a6844e3a7130a884e92dde4ef4694/src%2Ftest%2Frun-pass%2Fissue-42552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-42552.rs?ref=dfb8c80e118a6844e3a7130a884e92dde4ef4694", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for an obscure issue with the projection cache.\n+\n+fn into_iter<I: Iterator>(a: &I) -> Groups<I> {\n+    Groups { _a: a }\n+}\n+\n+pub struct Groups<'a, I: 'a> {\n+    _a: &'a I,\n+}\n+\n+impl<'a, I: Iterator> Iterator for Groups<'a, I> {\n+    type Item = Group<'a, I>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+pub struct Group<'a, I: Iterator + 'a>\n+    where I::Item: 'a       // <-- needed to trigger ICE!\n+{\n+    _phantom: &'a (),\n+    _ice_trigger: I::Item,  // <-- needed to trigger ICE!\n+}\n+\n+\n+fn main() {\n+    let _ = into_iter(&[0].iter().map(|_| 0)).map(|grp| {\n+        let _g = grp;\n+    });\n+}"}]}