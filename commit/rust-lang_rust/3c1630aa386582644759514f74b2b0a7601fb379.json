{"sha": "3c1630aa386582644759514f74b2b0a7601fb379", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMTYzMGFhMzg2NTgyNjQ0NzU5NTE0Zjc0YjJiMGE3NjAxZmIzNzk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-06T07:36:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-06T07:36:39Z"}, "message": "Rollup merge of #64111 - Centril:ast-only-patkind-or, r=petrochenkov\n\nor-patterns: Uniformly use `PatKind::Or` in AST & Fix/Cleanup resolve\n\nFollowing up on work in https://github.com/rust-lang/rust/pull/63693 and https://github.com/rust-lang/rust/pull/61708, in this PR we:\n\n- Uniformly use `PatKind::Or(...)` in AST:\n\n   - Change `ast::Arm.pats: Vec<P<Pat>>` => `ast::Arm.pat: P<Pat>`\n\n   - Change `ast::ExprKind::Let.0: Vec<P<Pat>>` => `ast::ExprKind::Let.0: P<Pat>`\n\n- Adjust `librustc_resolve/late.rs` to correctly handle or-patterns at any level of nesting as a result.\n\n  In particular, the already-bound check which rejects e.g. `let (a, a);` now accounts for or-patterns. The consistency checking (ensures no missing bindings and binding mode consistency) also now accounts for or-patterns. In the process, a bug was found in the current compiler which allowed:\n\n   ```rust\n   enum E<T> { A(T, T), B(T) }\n   use E::*;\n   fn foo() {\n       match A(0, 1) {\n           B(mut a) | A(mut a, mut a) => {}\n       }\n   }\n   ```\n\n   The new algorithms took a few iterations to get right. I tried several clever schemes but ultimately a version based on a stack of hashsets and recording product/sum contexts was chosen since it is more clearly correct.\n\n- Clean up `librustc_resolve/late.rs` by, among other things, using a new `with_rib` function to better ensure stack dicipline.\n\n- Do not push the change in AST to HIR for now to avoid doing too much in this PR. To cope with  this, we introduce a temporary hack in `rustc::hir::lowering` (clearly marked in the diff).\n\ncc https://github.com/rust-lang/rust/issues/54883\ncc @dlrobertson @matthewjasper\nr? @petrochenkov", "tree": {"sha": "d37aefb8ec1e33b0f1292f1743cb623ca37e17e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37aefb8ec1e33b0f1292f1743cb623ca37e17e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c1630aa386582644759514f74b2b0a7601fb379", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdcgyHCRBK7hj4Ov3rIwAAdHIIABGAkjw6oOfZrSIMqYMiRV7K\nD+HA+GDZ5+LOLi80bFfvtJZGMg7viSzgofZSRBlMLQk3Snwoa9jz24liHrkVYBx1\ncrlo+8uHemWIE8cA0pH5RCIFC4t0H5SSNZVrWRKXcI3ASPWQkCVO7M4dgxjO6zx4\n8AqSZL+j/U8E/pFIpEo1rQMXj5BMsCEf725+dNugETpd7BIniAQ5/4m5AImkSevc\n+cFYjOr3kJv3dIowsAPVo/aGnSCMphkEtK2olBbevDDvCwDrMYV/ojB5Idczy6kh\n4Uaw1drTn5TuD0wOEvW/mn+ctxc0kWY4JZHxll5D//W5VKohkbUNV5SGJWrP5ow=\n=6qTr\n-----END PGP SIGNATURE-----\n", "payload": "tree d37aefb8ec1e33b0f1292f1743cb623ca37e17e9\nparent ab75a1713a00e6d61a2bdf4ddc3d36713f03ce19\nparent 16ba5029a19eaa5968e61f4447a2d3ebf3367dc2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567755399 +0200\ncommitter GitHub <noreply@github.com> 1567755399 +0200\n\nRollup merge of #64111 - Centril:ast-only-patkind-or, r=petrochenkov\n\nor-patterns: Uniformly use `PatKind::Or` in AST & Fix/Cleanup resolve\n\nFollowing up on work in https://github.com/rust-lang/rust/pull/63693 and https://github.com/rust-lang/rust/pull/61708, in this PR we:\n\n- Uniformly use `PatKind::Or(...)` in AST:\n\n   - Change `ast::Arm.pats: Vec<P<Pat>>` => `ast::Arm.pat: P<Pat>`\n\n   - Change `ast::ExprKind::Let.0: Vec<P<Pat>>` => `ast::ExprKind::Let.0: P<Pat>`\n\n- Adjust `librustc_resolve/late.rs` to correctly handle or-patterns at any level of nesting as a result.\n\n  In particular, the already-bound check which rejects e.g. `let (a, a);` now accounts for or-patterns. The consistency checking (ensures no missing bindings and binding mode consistency) also now accounts for or-patterns. In the process, a bug was found in the current compiler which allowed:\n\n   ```rust\n   enum E<T> { A(T, T), B(T) }\n   use E::*;\n   fn foo() {\n       match A(0, 1) {\n           B(mut a) | A(mut a, mut a) => {}\n       }\n   }\n   ```\n\n   The new algorithms took a few iterations to get right. I tried several clever schemes but ultimately a version based on a stack of hashsets and recording product/sum contexts was chosen since it is more clearly correct.\n\n- Clean up `librustc_resolve/late.rs` by, among other things, using a new `with_rib` function to better ensure stack dicipline.\n\n- Do not push the change in AST to HIR for now to avoid doing too much in this PR. To cope with  this, we introduce a temporary hack in `rustc::hir::lowering` (clearly marked in the diff).\n\ncc https://github.com/rust-lang/rust/issues/54883\ncc @dlrobertson @matthewjasper\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c1630aa386582644759514f74b2b0a7601fb379", "html_url": "https://github.com/rust-lang/rust/commit/3c1630aa386582644759514f74b2b0a7601fb379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c1630aa386582644759514f74b2b0a7601fb379/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab75a1713a00e6d61a2bdf4ddc3d36713f03ce19", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab75a1713a00e6d61a2bdf4ddc3d36713f03ce19", "html_url": "https://github.com/rust-lang/rust/commit/ab75a1713a00e6d61a2bdf4ddc3d36713f03ce19"}, {"sha": "16ba5029a19eaa5968e61f4447a2d3ebf3367dc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ba5029a19eaa5968e61f4447a2d3ebf3367dc2", "html_url": "https://github.com/rust-lang/rust/commit/16ba5029a19eaa5968e61f4447a2d3ebf3367dc2"}], "stats": {"total": 1896, "additions": 1273, "deletions": 623}, "files": [{"sha": "190b50b10b281635f4ae2cdee1fc4ee9b1f9b5e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -425,19 +425,44 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                match p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) | PatKind::Rest => {},\n-                    _ => {\n-                        if let Some(owner) = self.hir_id_owner {\n-                            self.lctx.lower_node_id_with_owner(p.id, owner);\n-                        }\n-                    }\n-                };\n+                } else if let Some(owner) = self.hir_id_owner {\n+                    self.lctx.lower_node_id_with_owner(p.id, owner);\n+                }\n \n                 visit::walk_pat(self, p)\n             }\n \n+            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n+            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n+            // This is a temporary hack that should go away once we push down\n+            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n+            fn visit_arm(&mut self, arm: &'tcx Arm) {\n+                match &arm.pat.node {\n+                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                    _ => self.visit_pat(&arm.pat),\n+                }\n+                walk_list!(self, visit_expr, &arm.guard);\n+                self.visit_expr(&arm.body);\n+                walk_list!(self, visit_attribute, &arm.attrs);\n+            }\n+\n+            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n+            fn visit_expr(&mut self, e: &'tcx Expr) {\n+                if let ExprKind::Let(pat, scrutinee) = &e.node {\n+                    walk_list!(self, visit_attribute, e.attrs.iter());\n+                    match &pat.node {\n+                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                        _ => self.visit_pat(&pat),\n+                    }\n+                    self.visit_expr(scrutinee);\n+                    self.visit_expr_post(e);\n+                    return;\n+                }\n+                visit::walk_expr(self, e)\n+            }\n+\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n "}, {"sha": "0d8986ddec3c7fe7e0a86d08aecf10dd145878cb", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -68,7 +68,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n             }\n@@ -227,16 +227,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(\n-        &mut self,\n-        span: Span,\n-        pats: &[AstP<Pat>],\n-        scrutinee: &Expr\n-    ) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n         self.sess\n             .struct_span_err(span, \"`let` expressions are not supported here\")\n@@ -246,23 +241,23 @@ impl LoweringContext<'_> {\n \n         // For better recovery, we emit:\n         // ```\n-        // match scrutinee { pats => true, _ => false }\n+        // match scrutinee { pat => true, _ => false }\n         // ```\n         // While this doesn't fully match the user's intent, it has key advantages:\n         // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pats` and `scrutinee`.\n-        // 3. `pats` is allowed to be refutable.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let pat = self.lower_pat_top_hack(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pats, P(expr))\n+            self.arm(pat, P(expr))\n         };\n         let else_arm = {\n-            let pats = hir_vec![self.pat_wild(span)];\n+            let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pats, P(expr))\n+            self.arm(hir_vec![pat], P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -291,13 +286,12 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(then, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar) = match cond.node {\n+        let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                (pats, scrutinee, desugar)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n             _ => {\n@@ -312,13 +306,11 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n     }\n@@ -345,8 +337,8 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(body, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar, source) = match cond.node {\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -356,9 +348,8 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::WhileLetDesugar;\n-                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n                 // We desugar: `'label: while $cond $body` into:\n@@ -383,14 +374,12 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::WhileDesugar;\n                 // `true => <then>`:\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar, hir::LoopSource::While)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n@@ -440,7 +429,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            pats: self.lower_pat_top_hack(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -450,6 +439,16 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n+        match pat.node {\n+            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n+            _ => hir_vec![self.lower_pat(pat)],\n+        }\n+    }\n+\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -1255,7 +1254,6 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-\n             self.arm(hir_vec![ok_pat], val_expr)\n         };\n \n@@ -1486,7 +1484,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}, {"sha": "aecf5c5b52dba5996deb93661ba54091435b4fb2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -772,7 +772,7 @@ impl EarlyLintPass for UnusedDocComment {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        let arm_span = arm.pats[0].span.with_hi(arm.body.span.hi());\n+        let arm_span = arm.pat.span.with_hi(arm.body.span.hi());\n         self.warn_if_doc(cx, arm_span, \"match arms\", false, &arm.attrs);\n     }\n "}, {"sha": "561bf202dfeff07f7b6813aedd97050a4fcbacf4", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -493,10 +493,8 @@ impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n         let (value, msg, followed_by_block, left_pos, right_pos) = match e.node {\n-            Let(ref pats, ..) => {\n-                for p in pats {\n-                    self.check_unused_parens_pat(cx, p, false, false);\n-                }\n+            Let(ref pat, ..) => {\n+                self.check_unused_parens_pat(cx, pat, false, false);\n                 return;\n             }\n \n@@ -594,9 +592,7 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        for p in &arm.pats {\n-            self.check_unused_parens_pat(cx, p, false, false);\n-        }\n+        self.check_unused_parens_pat(cx, &arm.pat, false, false);\n     }\n }\n "}, {"sha": "3ddaf2d94f9c82649e8b56b73c2de3b6b56f8f9c", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 444, "deletions": 368, "changes": 812, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -9,7 +9,7 @@ use GenericParameters::*;\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, NameBindingKind, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use log::debug;\n@@ -18,7 +18,7 @@ use rustc::hir::def::{self, PartialRes, DefKind, CtorKind, PerNS};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::TraitCandidate;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use smallvec::{smallvec, SmallVec};\n use syntax::{unwrap_or, walk_list};\n use syntax::ast::*;\n@@ -35,8 +35,10 @@ mod diagnostics;\n \n type Res = def::Res<NodeId>;\n \n+type IdentMap<T> = FxHashMap<Ident, T>;\n+\n /// Map from the name in a pattern to its binding mode.\n-type BindingMap = FxHashMap<Ident, BindingInfo>;\n+type BindingMap = IdentMap<BindingInfo>;\n \n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n@@ -73,6 +75,16 @@ impl PatternSource {\n     }\n }\n \n+/// Denotes whether the context for the set of already bound bindings is a `Product`\n+/// or `Or` context. This is used in e.g., `fresh_binding` and `resolve_pattern_inner`.\n+/// See those functions for more information.\n+enum PatBoundCtx {\n+    /// A product pattern context, e.g., `Variant(a, b)`.\n+    Product,\n+    /// An or-pattern context, e.g., `p_0 | ... | p_n`.\n+    Or,\n+}\n+\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -143,7 +155,7 @@ impl RibKind<'_> {\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n crate struct Rib<'a, R = Res> {\n-    pub bindings: FxHashMap<Ident, R>,\n+    pub bindings: IdentMap<R>,\n     pub kind: RibKind<'a>,\n }\n \n@@ -406,50 +418,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n-    fn visit_fn(&mut self,\n-                function_kind: FnKind<'tcx>,\n-                declaration: &'tcx FnDecl,\n-                _: Span,\n-                _: NodeId)\n-    {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n         debug!(\"(resolving function) entering function\");\n-        let rib_kind = match function_kind {\n+        let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n             FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n-        self.ribs[ValueNS].push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        let mut bindings_list = FxHashMap::default();\n-        for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n-            self.visit_ty(&argument.ty);\n-\n-            debug!(\"(resolving function) recorded argument\");\n-        }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body, potentially inside the body of an async closure\n-        match function_kind {\n-            FnKind::ItemFn(.., body) |\n-            FnKind::Method(.., body) => {\n-                self.visit_block(body);\n-            }\n-            FnKind::Closure(body) => {\n-                self.visit_expr(body);\n-            }\n-        };\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, rib_kind, |this| {\n+            // Create a label rib for the function.\n+            this.with_label_rib(rib_kind, |this| {\n+                // Add each argument to the rib.\n+                this.resolve_params(&declaration.inputs);\n+\n+                visit::walk_fn_ret_ty(this, &declaration.output);\n+\n+                // Resolve the function body, potentially inside the body of an async closure\n+                match fn_kind {\n+                    FnKind::ItemFn(.., body) |\n+                    FnKind::Method(.., body) => this.visit_block(body),\n+                    FnKind::Closure(body) => this.visit_expr(body),\n+                };\n+\n+                debug!(\"(resolving function) leaving function\");\n+            })\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx Generics) {\n@@ -528,13 +522,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // although it may be useful to track other components as well for diagnostics.\n         let graph_root = resolver.graph_root;\n         let parent_scope = ParentScope::module(graph_root);\n+        let start_rib_kind = ModuleRibKind(graph_root);\n         LateResolutionVisitor {\n             r: resolver,\n             parent_scope,\n             ribs: PerNS {\n-                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                value_ns: vec![Rib::new(start_rib_kind)],\n+                type_ns: vec![Rib::new(start_rib_kind)],\n+                macro_ns: vec![Rib::new(start_rib_kind)],\n             },\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n@@ -588,23 +583,32 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    /// Do some `work` within a new innermost rib of the given `kind` in the given namespace (`ns`).\n+    fn with_rib<T>(\n+        &mut self,\n+        ns: Namespace,\n+        kind: RibKind<'a>,\n+        work: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        self.ribs[ns].push(Rib::new(kind));\n+        let ret = work(self);\n+        self.ribs[ns].pop();\n+        ret\n+    }\n+\n+    fn with_scope<T>(&mut self, id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         let id = self.r.definitions.local_def_id(id);\n         let module = self.r.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.parent_scope.module, module);\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n-\n-            let ret = f(self);\n-\n-            self.parent_scope.module = orig_module;\n-            self.ribs[ValueNS].pop();\n-            self.ribs[TypeNS].pop();\n-            ret\n+            self.with_rib(ValueNS, ModuleRibKind(module), |this| {\n+                this.with_rib(TypeNS, ModuleRibKind(module), |this| {\n+                    let ret = f(this);\n+                    this.parent_scope.module = orig_module;\n+                    ret\n+                })\n+            })\n         } else {\n             f(self)\n         }\n@@ -808,7 +812,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+        where F: FnOnce(&mut Self)\n     {\n         debug!(\"with_generic_param_rib\");\n         match generic_params {\n@@ -894,58 +898,44 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn with_label_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.label_ribs.push(Rib::new(NormalRibKind));\n+    fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n+        self.label_ribs.push(Rib::new(kind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n-        self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n-        f(self);\n-        self.ribs[TypeNS].pop();\n-        self.ribs[ValueNS].pop();\n+    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.with_rib(ValueNS, ItemRibKind, |this| this.with_rib(TypeNS, ItemRibKind, f))\n     }\n \n-    fn with_constant_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_constant_rib(&mut self, f: impl FnOnce(&mut Self)) {\n         debug!(\"with_constant_rib\");\n-        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n-        self.label_ribs.push(Rib::new(ConstantItemRibKind));\n-        f(self);\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, ConstantItemRibKind, |this| {\n+            this.with_label_rib(ConstantItemRibKind, f);\n+        });\n     }\n \n-    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n         let result = f(self);\n         self.current_self_type = previous_value;\n         result\n     }\n \n-    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_current_self_item<T>(&mut self, self_item: &Item, f: impl FnOnce(&mut Self) -> T) -> T {\n         let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n         let result = f(self);\n         self.current_self_item = previous_value;\n         result\n     }\n \n     /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n-    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_trait_items<T>(\n+        &mut self,\n+        trait_items: &Vec<TraitItem>,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n         let trait_assoc_types = replace(\n             &mut self.current_trait_assoc_types,\n             trait_items.iter().filter_map(|item| match &item.node {\n@@ -959,9 +949,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n-    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n-    {\n+    fn with_optional_trait_ref<T>(\n+        &mut self,\n+        opt_trait_ref: Option<&TraitRef>,\n+        f: impl FnOnce(&mut Self, Option<DefId>) -> T\n+    ) -> T {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n@@ -996,27 +988,18 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         result\n     }\n \n-    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_self_rib_ns(&mut self, ns: Namespace, self_res: Res, f: impl FnOnce(&mut Self)) {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n         self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n-        self.ribs[TypeNS].push(self_type_rib);\n+        self.ribs[ns].push(self_type_rib);\n         f(self);\n-        self.ribs[TypeNS].pop();\n+        self.ribs[ns].pop();\n     }\n \n-    fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        let self_res = Res::SelfCtor(impl_id);\n-        let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n-        self.ribs[ValueNS].push(self_type_rib);\n-        f(self);\n-        self.ribs[ValueNS].pop();\n+    fn with_self_rib(&mut self, self_res: Res, f: impl FnOnce(&mut Self)) {\n+        self.with_self_rib_ns(TypeNS, self_res, f)\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -1044,8 +1027,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         this.visit_generics(generics);\n                         // Resolve the items within the impl.\n                         this.with_current_self_type(self_type, |this| {\n-                            this.with_self_struct_ctor_rib(item_def_id, |this| {\n-                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n+                            this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                 for impl_item in impl_items {\n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n@@ -1135,6 +1118,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n+    fn resolve_params(&mut self, params: &[Param]) {\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n+        for Param { pat, ty, .. } in params {\n+            self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+            self.visit_ty(ty);\n+            debug!(\"(resolving function / closure) recorded parameter\");\n+        }\n+    }\n+\n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n         walk_list!(self, visit_ty, &local.ty);\n@@ -1143,72 +1135,93 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap::default());\n+        self.resolve_pattern_top(&local.pat, PatternSource::Let);\n     }\n \n-    // build a map from pattern identifiers to binding-info's.\n-    // this is done hygienically. This could arise for a macro\n-    // that expands into an or-pattern where one 'x' was from the\n-    // user and one 'x' came from the macro.\n+    /// build a map from pattern identifiers to binding-info's.\n+    /// this is done hygienically. This could arise for a macro\n+    /// that expands into an or-pattern where one 'x' was from the\n+    /// user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n-            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.r.partial_res_map.get(&pat.id)\n-                                                                  .map(|res| res.base_res()) {\n-                    Some(Res::Local(..)) => true,\n-                    _ => false,\n-                } {\n-                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(ident, binding_info);\n+            match pat.node {\n+                PatKind::Ident(binding_mode, ident, ref sub_pat)\n+                    if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n+                {\n+                    binding_map.insert(ident, BindingInfo { span: ident.span, binding_mode });\n+                }\n+                PatKind::Or(ref ps) => {\n+                    // Check the consistency of this or-pattern and\n+                    // then add all bindings to the larger map.\n+                    for bm in self.check_consistent_bindings(ps) {\n+                        binding_map.extend(bm);\n+                    }\n+                    return false;\n                 }\n+                _ => {}\n             }\n+\n             true\n         });\n \n         binding_map\n     }\n \n-    // Checks that all of the arms in an or-pattern have exactly the\n-    // same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+    fn is_base_res_local(&self, nid: NodeId) -> bool {\n+        match self.r.partial_res_map.get(&nid).map(|res| res.base_res()) {\n+            Some(Res::Local(..)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Checks that all of the arms in an or-pattern have exactly the\n+    /// same set of bindings, with the same binding modes for each.\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<BindingMap> {\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n \n-        for pat_outer in pats.iter() {\n-            let map_outer = self.binding_mode_map(&pat_outer);\n-\n-            for pat_inner in pats.iter().filter(|pat| pat.id != pat_outer.id) {\n-                let map_inner = self.binding_mode_map(&pat_inner);\n-\n-                for (&key_inner, &binding_inner) in map_inner.iter() {\n-                    match map_outer.get(&key_inner) {\n-                        None => {  // missing binding\n-                            let binding_error = missing_vars\n-                                .entry(key_inner.name)\n-                                .or_insert(BindingError {\n-                                    name: key_inner.name,\n-                                    origin: BTreeSet::new(),\n-                                    target: BTreeSet::new(),\n-                                    could_be_path:\n-                                        key_inner.name.as_str().starts_with(char::is_uppercase)\n-                                });\n-                            binding_error.origin.insert(binding_inner.span);\n-                            binding_error.target.insert(pat_outer.span);\n-                        }\n-                        Some(binding_outer) => {  // check consistent binding\n-                            if binding_outer.binding_mode != binding_inner.binding_mode {\n-                                inconsistent_vars\n-                                    .entry(key_inner.name)\n-                                    .or_insert((binding_inner.span, binding_outer.span));\n-                            }\n+        // 1) Compute the binding maps of all arms.\n+        let maps = pats.iter()\n+            .map(|pat| self.binding_mode_map(pat))\n+            .collect::<Vec<_>>();\n+\n+        // 2) Record any missing bindings or binding mode inconsistencies.\n+        for (map_outer, pat_outer) in pats.iter().enumerate().map(|(idx, pat)| (&maps[idx], pat)) {\n+            // Check against all arms except for the same pattern which is always self-consistent.\n+            let inners = pats.iter().enumerate()\n+                .filter(|(_, pat)| pat.id != pat_outer.id)\n+                .flat_map(|(idx, _)| maps[idx].iter())\n+                .map(|(key, binding)| (key.name, map_outer.get(&key), binding));\n+\n+            for (name, info, &binding_inner) in inners {\n+                match info {\n+                    None => { // The inner binding is missing in the outer.\n+                        let binding_error = missing_vars\n+                            .entry(name)\n+                            .or_insert_with(|| BindingError {\n+                                name,\n+                                origin: BTreeSet::new(),\n+                                target: BTreeSet::new(),\n+                                could_be_path: name.as_str().starts_with(char::is_uppercase),\n+                            });\n+                        binding_error.origin.insert(binding_inner.span);\n+                        binding_error.target.insert(pat_outer.span);\n+                    }\n+                    Some(binding_outer) => {\n+                        if binding_outer.binding_mode != binding_inner.binding_mode {\n+                            // The binding modes in the outer and inner bindings differ.\n+                            inconsistent_vars\n+                                .entry(name)\n+                                .or_insert((binding_inner.span, binding_outer.span));\n                         }\n                     }\n                 }\n             }\n         }\n \n+        // 3) Report all missing variables we found.\n         let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n         missing_vars.sort();\n         for (name, mut v) in missing_vars {\n@@ -1220,212 +1233,245 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 ResolutionError::VariableNotBoundInPattern(v));\n         }\n \n+        // 4) Report all inconsistencies in binding modes we found.\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n             self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n-    }\n \n-    fn resolve_arm(&mut self, arm: &Arm) {\n-        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-\n-        self.resolve_pats(&arm.pats, PatternSource::Match);\n-\n-        if let Some(ref expr) = arm.guard {\n-            self.visit_expr(expr)\n-        }\n-        self.visit_expr(&arm.body);\n-\n-        self.ribs[ValueNS].pop();\n+        // 5) Finally bubble up all the binding maps.\n+        maps\n     }\n \n-    /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n-    fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n-        let mut bindings_list = FxHashMap::default();\n-        for pat in pats {\n-            self.resolve_pattern(pat, source, &mut bindings_list);\n-        }\n-        // This has to happen *after* we determine which pat_idents are variants\n-        if pats.len() > 1 {\n-            self.check_consistent_bindings(pats);\n-        }\n+    /// Check the consistency of the outermost or-patterns.\n+    fn check_consistent_bindings_top(&mut self, pat: &Pat) {\n+        pat.walk(&mut |pat| match pat.node {\n+            PatKind::Or(ref ps) => {\n+                self.check_consistent_bindings(ps);\n+                false\n+            },\n+            _ => true,\n+        })\n     }\n \n-    fn resolve_block(&mut self, block: &Block) {\n-        debug!(\"(resolving block) entering block\");\n-        // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.parent_scope.module;\n-        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n-\n-        let mut num_macro_definition_ribs = 0;\n-        if let Some(anonymous_module) = anonymous_module {\n-            debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.parent_scope.module = anonymous_module;\n-        } else {\n-            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-        }\n-\n-        // Descend into the block.\n-        for stmt in &block.stmts {\n-            if let StmtKind::Item(ref item) = stmt.node {\n-                if let ItemKind::MacroDef(..) = item.node {\n-                    num_macro_definition_ribs += 1;\n-                    let res = self.r.definitions.local_def_id(item.id);\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n-                }\n-            }\n-\n-            self.visit_stmt(stmt);\n-        }\n-\n-        // Move back up.\n-        self.parent_scope.module = orig_module;\n-        for _ in 0 .. num_macro_definition_ribs {\n-            self.ribs[ValueNS].pop();\n-            self.label_ribs.pop();\n-        }\n-        self.ribs[ValueNS].pop();\n-        if anonymous_module.is_some() {\n-            self.ribs[TypeNS].pop();\n-        }\n-        debug!(\"(resolving block) leaving block\");\n+    fn resolve_arm(&mut self, arm: &Arm) {\n+        self.with_rib(ValueNS, NormalRibKind, |this| {\n+            this.resolve_pattern_top(&arm.pat, PatternSource::Match);\n+            walk_list!(this, visit_expr, &arm.guard);\n+            this.visit_expr(&arm.body);\n+        });\n     }\n \n-    fn fresh_binding(&mut self,\n-                     ident: Ident,\n-                     pat_id: NodeId,\n-                     outer_pat_id: NodeId,\n-                     pat_src: PatternSource,\n-                     bindings: &mut FxHashMap<Ident, NodeId>)\n-                     -> Res {\n-        // Add the binding to the local ribs, if it\n-        // doesn't already exist in the bindings map. (We\n-        // must not add it if it's in the bindings map\n-        // because that breaks the assumptions later\n-        // passes make about or-patterns.)\n-        let ident = ident.modern_and_legacy();\n-        let mut res = Res::Local(pat_id);\n-        match bindings.get(&ident).cloned() {\n-            Some(id) if id == outer_pat_id => {\n-                // `Variant(a, a)`, error\n-                self.r.report_error(\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                        &ident.as_str())\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::FnParam => {\n-                // `fn f(a: u8, a: u8)`, error\n-                self.r.report_error(\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                        &ident.as_str())\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::Match ||\n-                        pat_src == PatternSource::Let => {\n-                // `Variant1(a) | Variant2(a)`, ok\n-                // Reuse definition from the first `a`.\n-                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n-            }\n-            Some(..) => {\n-                span_bug!(ident.span, \"two bindings with the same name from \\\n-                                       unexpected pattern source {:?}\", pat_src);\n-            }\n-            None => {\n-                // A completely fresh binding, add to the lists if it's valid.\n-                if ident.name != kw::Invalid {\n-                    bindings.insert(ident, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n-                }\n-            }\n-        }\n+    /// Arising from `source`, resolve a top level pattern.\n+    fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n+        self.resolve_pattern(pat, pat_src, &mut bindings);\n+    }\n \n-        res\n+    fn resolve_pattern(\n+        &mut self,\n+        pat: &Pat,\n+        pat_src: PatternSource,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n+    ) {\n+        self.resolve_pattern_inner(pat, pat_src, bindings);\n+        // This has to happen *after* we determine which pat_idents are variants:\n+        self.check_consistent_bindings_top(pat);\n+        visit::walk_pat(self, pat);\n     }\n \n-    fn resolve_pattern(&mut self,\n-                       pat: &Pat,\n-                       pat_src: PatternSource,\n-                       // Maps idents to the node ID for the\n-                       // outermost pattern that binds them.\n-                       bindings: &mut FxHashMap<Ident, NodeId>) {\n+    /// Resolve bindings in a pattern. This is a helper to `resolve_pattern`.\n+    ///\n+    /// ### `bindings`\n+    ///\n+    /// A stack of sets of bindings accumulated.\n+    ///\n+    /// In each set, `PatBoundCtx::Product` denotes that a found binding in it should\n+    /// be interpreted as re-binding an already bound binding. This results in an error.\n+    /// Meanwhile, `PatBound::Or` denotes that a found binding in the set should result\n+    /// in reusing this binding rather than creating a fresh one.\n+    ///\n+    /// When called at the top level, the stack must have a single element\n+    /// with `PatBound::Product`. Otherwise, pushing to the stack happens as\n+    /// or-patterns (`p_0 | ... | p_n`) are encountered and the context needs\n+    /// to be switched to `PatBoundCtx::Or` and then `PatBoundCtx::Product` for each `p_i`.\n+    /// When each `p_i` has been dealt with, the top set is merged with its parent.\n+    /// When a whole or-pattern has been dealt with, the thing happens.\n+    ///\n+    /// See the implementation and `fresh_binding` for more details.\n+    fn resolve_pattern_inner(\n+        &mut self,\n+        pat: &Pat,\n+        pat_src: PatternSource,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n+    ) {\n         // Visit all direct subpatterns of this pattern.\n-        let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n             match pat.node {\n-                PatKind::Ident(bmode, ident, ref opt_pat) => {\n-                    // First try to resolve the identifier as some existing\n-                    // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n-                                                                      None, pat.span)\n-                                      .and_then(LexicalScopeBinding::item);\n-                    let res = binding.map(NameBinding::res).and_then(|res| {\n-                        let is_syntactic_ambiguity = opt_pat.is_none() &&\n-                            bmode == BindingMode::ByValue(Mutability::Immutable);\n-                        match res {\n-                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n-                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n-                                // Disambiguate in favor of a unit struct/variant\n-                                // or constant pattern.\n-                                self.r.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(res)\n-                            }\n-                            Res::Def(DefKind::Ctor(..), _)\n-                            | Res::Def(DefKind::Const, _)\n-                            | Res::Def(DefKind::Static, _) => {\n-                                // This is unambiguously a fresh binding, either syntactically\n-                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n-                                // to something unusable as a pattern (e.g., constructor function),\n-                                // but we still conservatively report an error, see\n-                                // issues/33118#issuecomment-233962221 for one reason why.\n-                                self.r.report_error(\n-                                    ident.span,\n-                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), ident.name, binding.unwrap())\n-                                );\n-                                None\n-                            }\n-                            Res::Def(DefKind::Fn, _) | Res::Err => {\n-                                // These entities are explicitly allowed\n-                                // to be shadowed by fresh bindings.\n-                                None\n-                            }\n-                            res => {\n-                                span_bug!(ident.span, \"unexpected resolution for an \\\n-                                                       identifier in pattern: {:?}\", res);\n-                            }\n-                        }\n-                    }).unwrap_or_else(|| {\n-                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n-                    });\n-\n+                PatKind::Ident(bmode, ident, ref sub) => {\n+                    // First try to resolve the identifier as some existing entity,\n+                    // then fall back to a fresh binding.\n+                    let has_sub = sub.is_some();\n+                    let res = self.try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n-\n                 PatKind::TupleStruct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n                 }\n-\n                 PatKind::Path(ref qself, ref path) => {\n                     self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n                 }\n-\n                 PatKind::Struct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n-\n+                PatKind::Or(ref ps) => {\n+                    // Add a new set of bindings to the stack. `Or` here records that when a\n+                    // binding already exists in this set, it should not result in an error because\n+                    // `V1(a) | V2(a)` must be allowed and are checked for consistency later.\n+                    bindings.push((PatBoundCtx::Or, Default::default()));\n+                    for p in ps {\n+                        // Now we need to switch back to a product context so that each\n+                        // part of the or-pattern internally rejects already bound names.\n+                        // For example, `V1(a) | V2(a, a)` and `V1(a, a) | V2(a)` are bad.\n+                        bindings.push((PatBoundCtx::Product, Default::default()));\n+                        self.resolve_pattern_inner(p, pat_src, bindings);\n+                        // Move up the non-overlapping bindings to the or-pattern.\n+                        // Existing bindings just get \"merged\".\n+                        let collected = bindings.pop().unwrap().1;\n+                        bindings.last_mut().unwrap().1.extend(collected);\n+                    }\n+                    // This or-pattern itself can itself be part of a product,\n+                    // e.g. `(V1(a) | V2(a), a)` or `(a, V1(a) | V2(a))`.\n+                    // Both cases bind `a` again in a product pattern and must be rejected.\n+                    let collected = bindings.pop().unwrap().1;\n+                    bindings.last_mut().unwrap().1.extend(collected);\n+\n+                    // Prevent visiting `ps` as we've already done so above.\n+                    return false;\n+                }\n                 _ => {}\n             }\n             true\n         });\n+    }\n \n-        visit::walk_pat(self, pat);\n+    fn fresh_binding(\n+        &mut self,\n+        ident: Ident,\n+        pat_id: NodeId,\n+        pat_src: PatternSource,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n+    ) -> Res {\n+        // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n+        // (We must not add it if it's in the bindings map because that breaks the assumptions\n+        // later passes make about or-patterns.)\n+        let ident = ident.modern_and_legacy();\n+\n+        // Walk outwards the stack of products / or-patterns and\n+        // find out if the identifier has been bound in any of these.\n+        let mut already_bound_and = false;\n+        let mut already_bound_or = false;\n+        for (is_sum, set) in bindings.iter_mut().rev() {\n+            match (is_sum, set.get(&ident).cloned()) {\n+                // Already bound in a product pattern, e.g. `(a, a)` which is not allowed.\n+                (PatBoundCtx::Product, Some(..)) => already_bound_and = true,\n+                // Already bound in an or-pattern, e.g. `V1(a) | V2(a)`.\n+                // This is *required* for consistency which is checked later.\n+                (PatBoundCtx::Or, Some(..)) => already_bound_or = true,\n+                // Not already bound here.\n+                _ => {}\n+            }\n+        }\n+\n+        if already_bound_and {\n+            // Overlap in a product pattern somewhere; report an error.\n+            use ResolutionError::*;\n+            let error = match pat_src {\n+                // `fn f(a: u8, a: u8)`:\n+                PatternSource::FnParam => IdentifierBoundMoreThanOnceInParameterList,\n+                // `Variant(a, a)`:\n+                _ => IdentifierBoundMoreThanOnceInSamePattern,\n+            };\n+            self.r.report_error(ident.span, error(&ident.as_str()));\n+        }\n+\n+        // Record as bound if it's valid:\n+        let ident_valid = ident.name != kw::Invalid;\n+        if ident_valid {\n+            bindings.last_mut().unwrap().1.insert(ident);\n+        }\n+\n+        if already_bound_or {\n+            // `Variant1(a) | Variant2(a)`, ok\n+            // Reuse definition from the first `a`.\n+            self.innermost_rib_bindings(ValueNS)[&ident]\n+        } else {\n+            let res = Res::Local(pat_id);\n+            if ident_valid {\n+                // A completely fresh binding add to the set if it's valid.\n+                self.innermost_rib_bindings(ValueNS).insert(ident, res);\n+            }\n+            res\n+        }\n+    }\n+\n+    fn innermost_rib_bindings(&mut self, ns: Namespace) -> &mut IdentMap<Res> {\n+        &mut self.ribs[ns].last_mut().unwrap().bindings\n+    }\n+\n+    fn try_resolve_as_non_binding(\n+        &mut self,\n+        pat_src: PatternSource,\n+        pat: &Pat,\n+        bm: BindingMode,\n+        ident: Ident,\n+        has_sub: bool,\n+    ) -> Option<Res> {\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?.item()?;\n+        let res = binding.res();\n+\n+        // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n+        // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n+        // also be interpreted as a path to e.g. a constant, variant, etc.\n+        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Immutable);\n+\n+        match res {\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n+                // Disambiguate in favor of a unit struct/variant or constant pattern.\n+                self.r.record_use(ident, ValueNS, binding, false);\n+                Some(res)\n+            }\n+            Res::Def(DefKind::Ctor(..), _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::Static, _) => {\n+                // This is unambiguously a fresh binding, either syntactically\n+                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n+                // to something unusable as a pattern (e.g., constructor function),\n+                // but we still conservatively report an error, see\n+                // issues/33118#issuecomment-233962221 for one reason why.\n+                self.r.report_error(\n+                    ident.span,\n+                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                        pat_src.descr(),\n+                        ident.name,\n+                        binding,\n+                    ),\n+                );\n+                None\n+            }\n+            Res::Def(DefKind::Fn, _) | Res::Err => {\n+                // These entities are explicitly allowed to be shadowed by fresh bindings.\n+                None\n+            }\n+            res => {\n+                span_bug!(ident.span, \"unexpected resolution for an \\\n+                                        identifier in pattern: {:?}\", res);\n+            }\n+        }\n     }\n \n     // High-level and context dependent path resolution routine.\n@@ -1723,12 +1769,10 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         Some(result)\n     }\n \n-    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n-            self.with_label_rib(|this| {\n+            self.with_label_rib(NormalRibKind, |this| {\n                 let ident = label.ident.modern_and_legacy();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n@@ -1742,6 +1786,49 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n+    fn resolve_block(&mut self, block: &Block) {\n+        debug!(\"(resolving block) entering block\");\n+        // Move down in the graph, if there's an anonymous module rooted here.\n+        let orig_module = self.parent_scope.module;\n+        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n+\n+        let mut num_macro_definition_ribs = 0;\n+        if let Some(anonymous_module) = anonymous_module {\n+            debug!(\"(resolving block) found anonymous module, moving down\");\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.parent_scope.module = anonymous_module;\n+        } else {\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+        }\n+\n+        // Descend into the block.\n+        for stmt in &block.stmts {\n+            if let StmtKind::Item(ref item) = stmt.node {\n+                if let ItemKind::MacroDef(..) = item.node {\n+                    num_macro_definition_ribs += 1;\n+                    let res = self.r.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n+\n+        // Move back up.\n+        self.parent_scope.module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.ribs[ValueNS].pop();\n+            self.label_ribs.pop();\n+        }\n+        self.ribs[ValueNS].pop();\n+        if anonymous_module.is_some() {\n+            self.ribs[TypeNS].pop();\n+        }\n+        debug!(\"(resolving block) leaving block\");\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -1796,39 +1883,36 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 self.visit_expr(scrutinee);\n-                self.resolve_pats(pats, PatternSource::Let);\n+                self.resolve_pattern_top(pat, PatternSource::Let);\n             }\n \n             ExprKind::If(ref cond, ref then, ref opt_else) => {\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.visit_expr(cond);\n-                self.visit_block(then);\n-                self.ribs[ValueNS].pop();\n-\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    this.visit_expr(cond);\n+                    this.visit_block(then);\n+                });\n                 opt_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n \n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n-            ExprKind::While(ref subexpression, ref block, label) => {\n+            ExprKind::While(ref cond, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n-                    this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    this.visit_expr(subexpression);\n-                    this.visit_block(block);\n-                    this.ribs[ValueNS].pop();\n+                    this.with_rib(ValueNS, NormalRibKind, |this| {\n+                        this.visit_expr(cond);\n+                        this.visit_block(block);\n+                    })\n                 });\n             }\n \n-            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap::default());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n+            ExprKind::ForLoop(ref pat, ref iter_expr, ref block, label) => {\n+                self.visit_expr(iter_expr);\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    this.resolve_pattern_top(pat, PatternSource::For);\n+                    this.resolve_labeled_block(label, expr.id, block);\n+                });\n             }\n \n             ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n@@ -1860,30 +1944,22 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n-            ExprKind::Closure(\n-                _, IsAsync::Async { .. }, _,\n-                ref fn_decl, ref body, _span,\n-            ) => {\n-                let rib_kind = NormalRibKind;\n-                self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                // Resolve arguments:\n-                let mut bindings_list = FxHashMap::default();\n-                for argument in &fn_decl.inputs {\n-                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-                    self.visit_ty(&argument.ty);\n-                }\n-                // No need to resolve return type-- the outer closure return type is\n-                // FunctionRetTy::Default\n-\n-                // Now resolve the inner closure\n-                {\n-                    // No need to resolve arguments: the inner closure has none.\n-                    // Resolve the return type:\n-                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n-                    // Resolve the body\n-                    self.visit_expr(body);\n-                }\n-                self.ribs[ValueNS].pop();\n+            ExprKind::Closure(_, IsAsync::Async { .. }, _, ref fn_decl, ref body, _span) => {\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    // Resolve arguments:\n+                    this.resolve_params(&fn_decl.inputs);\n+                    // No need to resolve return type --\n+                    // the outer closure return type is `FunctionRetTy::Default`.\n+\n+                    // Now resolve the inner closure\n+                    {\n+                        // No need to resolve arguments: the inner closure has none.\n+                        // Resolve the return type:\n+                        visit::walk_fn_ret_ty(this, &fn_decl.output);\n+                        // Resolve the body\n+                        this.visit_expr(body);\n+                    }\n+                });\n             }\n             _ => {\n                 visit::walk_expr(self, expr);"}, {"sha": "9b92bb7698aaa506e5e6a805b4bd4a83c445904d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -9,6 +9,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(inner_deref)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n #![feature(mem_take)]"}, {"sha": "12c5ce12a0e8bc0dce1da59e2051dde180ab8a4c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 14, "deletions": 83, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -897,32 +897,23 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_var_decl_multi(&mut self, pats: &'l [P<ast::Pat>]) {\n+    fn process_var_decl(&mut self, pat: &'l ast::Pat) {\n+        // The pattern could declare multiple new vars,\n+        // we must walk the pattern and collect them all.\n         let mut collector = PathCollector::new();\n-        for pattern in pats {\n-            // collect paths from the arm's patterns\n-            collector.visit_pat(&pattern);\n-            self.visit_pat(&pattern);\n-        }\n+        collector.visit_pat(&pat);\n+        self.visit_pat(&pat);\n \n-        // process collected paths\n-        for (id, ident, immut) in collector.collected_idents {\n+        // Process collected paths.\n+        for (id, ident, _) in collector.collected_idents {\n             match self.save_ctxt.get_path_res(id) {\n                 Res::Local(hir_id) => {\n-                    let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(ident.span)\n-                    } else {\n-                        \"<mutable>\".to_owned()\n-                    };\n                     let id = self.tcx.hir().hir_to_node_id(hir_id);\n-                    let typ = self.save_ctxt\n-                        .tables\n-                        .node_type_opt(hir_id)\n+                    let typ = self.save_ctxt.tables.node_type_opt(hir_id)\n                         .map(|t| t.to_string())\n                         .unwrap_or_default();\n-                    value.push_str(\": \");\n-                    value.push_str(&typ);\n \n+                    // Rust uses the id of the pattern for var lookups, so we'll use it too.\n                     if !self.span.filter_generated(ident.span) {\n                         let qualname = format!(\"{}${}\", ident.to_string(), id);\n                         let id = id_from_node_id(id, &self.save_ctxt);\n@@ -972,61 +963,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_var_decl(&mut self, p: &'l ast::Pat, value: String) {\n-        // The local could declare multiple new vars, we must walk the\n-        // pattern and collect them all.\n-        let mut collector = PathCollector::new();\n-        collector.visit_pat(&p);\n-        self.visit_pat(&p);\n-\n-        for (id, ident, immut) in collector.collected_idents {\n-            let mut value = match immut {\n-                ast::Mutability::Immutable => value.to_string(),\n-                _ => String::new(),\n-            };\n-            let hir_id = self.tcx.hir().node_to_hir_id(id);\n-            let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n-                Some(typ) => {\n-                    let typ = typ.to_string();\n-                    if !value.is_empty() {\n-                        value.push_str(\": \");\n-                    }\n-                    value.push_str(&typ);\n-                    typ\n-                }\n-                None => String::new(),\n-            };\n-\n-            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(ident.span) {\n-                let qualname = format!(\"{}${}\", ident.to_string(), id);\n-                let id = id_from_node_id(id, &self.save_ctxt);\n-                let span = self.span_from_span(ident.span);\n-\n-                self.dumper.dump_def(\n-                    &Access {\n-                        public: false,\n-                        reachable: false,\n-                    },\n-                    Def {\n-                        kind: DefKind::Local,\n-                        id,\n-                        span,\n-                        name: ident.to_string(),\n-                        qualname,\n-                        value: typ,\n-                        parent: None,\n-                        children: vec![],\n-                        decl_id: None,\n-                        docs: String::new(),\n-                        sig: None,\n-                        attributes: vec![],\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n     /// Extracts macro use and definition information from the AST node defined\n     /// by the given NodeId, using the expansion information from the node's\n     /// span.\n@@ -1565,14 +1501,13 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 });\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n-                let value = self.span.snippet(subexpression.span);\n-                self.process_var_decl(pattern, value);\n+                self.process_var_decl(pattern);\n                 debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprKind::Let(ref pats, ref scrutinee) => {\n-                self.process_var_decl_multi(pats);\n+            ast::ExprKind::Let(ref pat, ref scrutinee) => {\n+                self.process_var_decl(pat);\n                 self.visit_expr(scrutinee);\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n@@ -1599,7 +1534,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &'l ast::Arm) {\n-        self.process_var_decl_multi(&arm.pats);\n+        self.process_var_decl(&arm.pat);\n         if let Some(expr) = &arm.guard {\n             self.visit_expr(expr);\n         }\n@@ -1617,11 +1552,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n \n     fn visit_local(&mut self, l: &'l ast::Local) {\n         self.process_macro_use(l.span);\n-        let value = l.init\n-            .as_ref()\n-            .map(|i| self.span.snippet(i.span))\n-            .unwrap_or_default();\n-        self.process_var_decl(&l.pat, value);\n+        self.process_var_decl(&l.pat);\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n         walk_list!(self, visit_ty, &l.ty);"}, {"sha": "4bc098db68611b87ac8677031d100c599dcf50de", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -1,5 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n+#![feature(inner_deref)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "c93e6d11ce711235829704edae3ca43d656db4bf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -561,29 +561,31 @@ impl Pat {\n         }))\n     }\n \n-    pub fn walk<F>(&self, it: &mut F) -> bool\n-    where\n-        F: FnMut(&Pat) -> bool,\n-    {\n+    /// Walk top-down and call `it` in each place where a pattern occurs\n+    /// starting with the root pattern `walk` is called on. If `it` returns\n+    /// false then we will descend no further but siblings will be processed.\n+    pub fn walk(&self, it: &mut impl FnMut(&Pat) -> bool) {\n         if !it(self) {\n-            return false;\n+            return;\n         }\n \n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n-            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n+            PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n             PatKind::TupleStruct(_, s)\n             | PatKind::Tuple(s)\n             | PatKind::Slice(s)\n-            | PatKind::Or(s) => s.iter().all(|p| p.walk(it)),\n-            PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n+            | PatKind::Or(s) => s.iter().for_each(|p| p.walk(it)),\n+            PatKind::Box(s)\n+            | PatKind::Ref(s, _)\n+            | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n             | PatKind::Rest\n             | PatKind::Lit(_)\n             | PatKind::Range(..)\n             | PatKind::Ident(..)\n             | PatKind::Path(..)\n-            | PatKind::Mac(_) => true,\n+            | PatKind::Mac(_) => {},\n         }\n     }\n \n@@ -928,7 +930,7 @@ pub struct Local {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n-    pub pats: Vec<P<Pat>>,\n+    pub pat: P<Pat>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n     pub span: Span,\n@@ -1146,12 +1148,9 @@ pub enum ExprKind {\n     Cast(P<Expr>, P<Ty>),\n     /// A type ascription (e.g., `42: usize`).\n     Type(P<Expr>, P<Ty>),\n-    /// A `let pats = expr` expression that is only semantically allowed in the condition\n+    /// A `let pat = expr` expression that is only semantically allowed in the condition\n     /// of `if` / `while` expressions. (e.g., `if let 0 = x { .. }`).\n-    ///\n-    /// The `Vec<P<Pat>>` is for or-patterns at the top level.\n-    /// FIXME(54883): Change this to just `P<Pat>`.\n-    Let(Vec<P<Pat>>, P<Expr>),\n+    Let(P<Pat>, P<Expr>),\n     /// An `if` block, with an optional `else` block.\n     ///\n     /// `if expr { block } else { expr }`"}, {"sha": "dc6cbfcf6ad5c56f6c22eaa46f04b6a935013830", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -537,9 +537,9 @@ impl<'a> ExtCtxt<'a> {\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n         // `Ok(__try_var) => __try_var`\n-        let ok_arm = self.arm(sp, vec![ok_pat], binding_expr);\n+        let ok_arm = self.arm(sp, ok_pat, binding_expr);\n         // `Err(__try_var) => return Err(__try_var)`\n-        let err_arm = self.arm(sp, vec![err_pat], err_expr);\n+        let err_arm = self.arm(sp, err_pat, err_expr);\n \n         // `match head { Ok() => ..., Err() => ... }`\n         self.expr_match(sp, head, vec![ok_arm, err_arm])\n@@ -606,10 +606,10 @@ impl<'a> ExtCtxt<'a> {\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    pub fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n+    pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec![],\n-            pats,\n+            pat,\n             guard: None,\n             body: expr,\n             span,\n@@ -618,7 +618,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn arm_unreachable(&self, span: Span) -> ast::Arm {\n-        self.arm(span, vec![self.pat_wild(span)], self.expr_unreachable(span))\n+        self.arm(span, self.pat_wild(span), self.expr_unreachable(span))\n     }\n \n     pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {"}, {"sha": "6023c5149d05b5e6b53569f89a25bd02bec3a050", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -402,14 +402,11 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_flat_map_arm<T: MutVisitor>(\n-    mut arm: Arm,\n-    vis: &mut T,\n-) -> SmallVec<[Arm; 1]> {\n-    let Arm { attrs, pats, guard, body, span, id } = &mut arm;\n+pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[Arm; 1]> {\n+    let Arm { attrs, pat, guard, body, span, id } = &mut arm;\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n-    visit_vec(pats, |pat| vis.visit_pat(pat));\n+    vis.visit_pat(pat);\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n     vis.visit_expr(body);\n     vis.visit_span(span);\n@@ -1132,8 +1129,8 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n             vis.visit_ty(ty);\n         }\n         ExprKind::AddrOf(_m, ohs) => vis.visit_expr(ohs),\n-        ExprKind::Let(pats, scrutinee) => {\n-            visit_vec(pats, |pat| vis.visit_pat(pat));\n+        ExprKind::Let(pat, scrutinee) => {\n+            vis.visit_pat(pat);\n             vis.visit_expr(scrutinee);\n         }\n         ExprKind::If(cond, tr, fl) => {"}, {"sha": "3db9c899dba40f12696cf01649ad28721d55d17d", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -1250,8 +1250,7 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n-        // FIXME(or_patterns, Centril | dlrobertson): use `parse_top_pat` instead.\n-        let pat = self.parse_top_pat_unpack(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(\n             Restrictions::NO_STRUCT_LITERAL,\n@@ -1393,8 +1392,7 @@ impl<'a> Parser<'a> {\n     crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        // FIXME(or_patterns, Centril | dlrobertson): use `parse_top_pat` instead.\n-        let pat = self.parse_top_pat_unpack(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No)?;\n         let guard = if self.eat_keyword(kw::If) {\n             Some(self.parse_expr()?)\n         } else {\n@@ -1455,7 +1453,7 @@ impl<'a> Parser<'a> {\n \n         Ok(ast::Arm {\n             attrs,\n-            pats: pat, // FIXME(or_patterns, Centril | dlrobertson): this should just be `pat,`.\n+            pat,\n             guard,\n             body: expr,\n             span: lo.to(hi),"}, {"sha": "669f657160b3e75c8fef3297f23d2da0ff2e7ec4", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -36,16 +36,6 @@ impl<'a> Parser<'a> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n-    // FIXME(or_patterns, Centril | dlrobertson):\n-    // remove this and use `parse_top_pat` everywhere it is used instead.\n-    pub(super) fn parse_top_pat_unpack(&mut self, gate_or: GateOr) -> PResult<'a, Vec<P<Pat>>> {\n-        self.parse_top_pat(gate_or)\n-            .map(|pat| pat.and_then(|pat| match pat.node {\n-                PatKind::Or(pats) => pats,\n-                node => vec![self.mk_pat(pat.span, node)],\n-            }))\n-    }\n-\n     /// Entry point to the main pattern parser.\n     /// Corresponds to `top_pat` in RFC 2535 and allows or-pattern at the top level.\n     pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {"}, {"sha": "6772bbce21b5039710c8298fc810dd0e3421d730", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -1710,11 +1710,11 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n-    /// Print a `let pats = scrutinee` expression.\n-    crate fn print_let(&mut self, pats: &[P<ast::Pat>], scrutinee: &ast::Expr) {\n+    /// Print a `let pat = scrutinee` expression.\n+    crate fn print_let(&mut self, pat: &ast::Pat, scrutinee: &ast::Expr) {\n         self.s.word(\"let \");\n \n-        self.print_pats(pats);\n+        self.print_pat(pat);\n         self.s.space();\n \n         self.word_space(\"=\");\n@@ -2040,8 +2040,8 @@ impl<'a> State<'a> {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Let(ref pats, ref scrutinee) => {\n-                self.print_let(pats, scrutinee);\n+            ast::ExprKind::Let(ref pat, ref scrutinee) => {\n+                self.print_let(pat, scrutinee);\n             }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(test, blk, elseopt.as_ref().map(|e| &**e));\n@@ -2451,21 +2451,16 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    fn print_pats(&mut self, pats: &[P<ast::Pat>]) {\n-        self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n-    }\n-\n     fn print_arm(&mut self, arm: &ast::Arm) {\n-        // I have no idea why this check is necessary, but here it\n-        // is :(\n+        // I have no idea why this check is necessary, but here it is :(\n         if arm.attrs.is_empty() {\n             self.s.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ibox(0);\n-        self.maybe_print_comment(arm.pats[0].span.lo());\n+        self.maybe_print_comment(arm.pat.span.lo());\n         self.print_outer_attributes(&arm.attrs);\n-        self.print_pats(&arm.pats);\n+        self.print_pat(&arm.pat);\n         self.s.space();\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\");"}, {"sha": "421c327aa414dc5b49556424b435b5f7b0bc3ee4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -678,9 +678,8 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n }\n \n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n-    for attr in expression.attrs.iter() {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, expression.attrs.iter());\n+\n     match expression.node {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n@@ -719,8 +718,8 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pats, ref scrutinee) => {\n-            walk_list!(visitor, visit_pat, pats);\n+        ExprKind::Let(ref pat, ref scrutinee) => {\n+            visitor.visit_pat(pat);\n             visitor.visit_expr(scrutinee);\n         }\n         ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n@@ -831,10 +830,10 @@ pub fn walk_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Param) {\n }\n \n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n-    walk_list!(visitor, visit_pat, &arm.pats);\n-    if let Some(ref e) = &arm.guard {\n-        visitor.visit_expr(e);\n-    }\n+    visitor.visit_pat(&arm.pat);\n+    // NOTE(or_patterns; Centril | dlrobertson):\n+    // If you change this, also change the hack in `lowering.rs`.\n+    walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}, {"sha": "1f4f5aa37099fb364ee7b694b180490590765b0d", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -95,11 +95,9 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n                     cx.expr_call_global(span, cmp_path.clone(), args)\n                 };\n \n-                let eq_arm = cx.arm(span,\n-                                    vec![cx.pat_path(span, equals_path.clone())],\n-                                    old);\n+                let eq_arm = cx.arm(span, cx.pat_path(span, equals_path.clone()), old);\n                 let neq_arm = cx.arm(span,\n-                                     vec![cx.pat_ident(span, test_id)],\n+                                     cx.pat_ident(span, test_id),\n                                      cx.expr_ident(span, test_id));\n \n                 cx.expr_match(span, new, vec![eq_arm, neq_arm])"}, {"sha": "debdc300e64955ebebf81864553cddd9d1a1759c", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -160,10 +160,10 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 };\n \n                 let eq_arm = cx.arm(span,\n-                                    vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n+                                    cx.pat_some(span, cx.pat_path(span, ordering.clone())),\n                                     old);\n                 let neq_arm = cx.arm(span,\n-                                    vec![cx.pat_ident(span, test_id)],\n+                                    cx.pat_ident(span, test_id),\n                                     cx.expr_ident(span, test_id));\n \n                 cx.expr_match(span, new, vec![eq_arm, neq_arm])"}, {"sha": "d3d604b72521d40112f1fa5370a3cd2face7fab9", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -119,9 +119,7 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                                                     vec![idx, exprdecode.clone()]))\n                 });\n \n-                arms.push(cx.arm(v_span,\n-                                 vec![cx.pat_lit(v_span, cx.expr_usize(v_span, i))],\n-                                 decoded));\n+                arms.push(cx.arm(v_span, cx.pat_lit(v_span, cx.expr_usize(v_span, i)), decoded));\n             }\n \n             arms.push(cx.arm_unreachable(trait_span));"}, {"sha": "893d89f06a16830859ce57631837e9bf51996b61", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -1071,7 +1071,7 @@ impl<'a> MethodDef<'a> {\n         for (arg_expr, pat) in self_args.iter().zip(patterns) {\n             body = cx.expr_match(trait_.span,\n                                  arg_expr.clone(),\n-                                 vec![cx.arm(trait_.span, vec![pat.clone()], body)])\n+                                 vec![cx.arm(trait_.span, pat.clone(), body)])\n         }\n \n         body\n@@ -1311,7 +1311,7 @@ impl<'a> MethodDef<'a> {\n                                                              nonself_args,\n                                                              &substructure);\n \n-                cx.arm(sp, vec![single_pat], arm_expr)\n+                cx.arm(sp, single_pat, arm_expr)\n             })\n             .collect();\n \n@@ -1337,7 +1337,7 @@ impl<'a> MethodDef<'a> {\n             _ => None,\n         };\n         if let Some(arm) = default {\n-            match_arms.push(cx.arm(sp, vec![cx.pat_wild(sp)], arm));\n+            match_arms.push(cx.arm(sp, cx.pat_wild(sp), arm));\n         }\n \n         // We will usually need the catch-all after matching the"}, {"sha": "e29f12c50c5263560a58671554096373273379b4", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n-        let arm = self.ecx.arm(self.fmtsp, vec![pat], args_array);\n+        let arm = self.ecx.arm(self.fmtsp, pat, args_array);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprKind::Tup(heads));\n         let result = self.ecx.expr_match(self.fmtsp, head, vec![arm]);\n "}, {"sha": "b4c154e5d95f7d6d1f033fc792162ae058d32181", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -150,12 +150,12 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n             },\n             19 => {\n-                let ps = vec![P(Pat {\n+                let pat = P(Pat {\n                     id: DUMMY_NODE_ID,\n                     node: PatKind::Wild,\n                     span: DUMMY_SP,\n-                })];\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(ps.clone(), e)))\n+                });\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e)))\n             },\n             _ => panic!(\"bad counter value in iter_exprs\"),\n         }"}, {"sha": "1d8cce522811682ac264b712c2d275ac288db584", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -33,10 +33,8 @@ fn or_patterns_no_lint() {\n     if let &mut (0 | 1) = &mut 0 {} // Same.\n \n     fn foo((Ok(a) | Err(a)): Result<u8, u8>) {} // Doesn't parse if we remove parens for now.\n-    //~^ ERROR identifier `a` is bound more than once\n \n     let _ = |(Ok(a) | Err(a)): Result<u8, u8>| 1; // `|Ok(a) | Err(a)| 1` parses as bit-or.\n-    //~^ ERROR identifier `a` is bound more than once\n }\n \n fn or_patterns_will_lint() {"}, {"sha": "7d5e286416fe262b58f01617aab248c7a4b0cba0", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.stderr", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -1,15 +1,3 @@\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:35:25\n-   |\n-LL |     fn foo((Ok(a) | Err(a)): Result<u8, u8>) {} // Doesn't parse if we remove parens for now.\n-   |                         ^ used in a pattern more than once\n-\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:38:27\n-   |\n-LL |     let _ = |(Ok(a) | Err(a)): Result<u8, u8>| 1; // `|Ok(a) | Err(a)| 1` parses as bit-or.\n-   |                           ^ used in a pattern more than once\n-\n warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n   --> $DIR/issue-54538-unused-parens-lint.rs:3:12\n    |\n@@ -61,113 +49,112 @@ LL |     let _ = |(a): u8| 0;\n    |              ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:43:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:41:12\n    |\n LL |     if let (0 | 1) = 0 {}\n    |            ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:44:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:42:13\n    |\n LL |     if let ((0 | 1),) = (0,) {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:45:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:43:13\n    |\n LL |     if let [(0 | 1)] = [0] {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:46:16\n+  --> $DIR/issue-54538-unused-parens-lint.rs:44:16\n    |\n LL |     if let 0 | (1 | 2) = 0 {}\n    |                ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:48:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:46:15\n    |\n LL |     if let TS((0 | 1)) = TS(0) {}\n    |               ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:50:20\n+  --> $DIR/issue-54538-unused-parens-lint.rs:48:20\n    |\n LL |     if let NS { f: (0 | 1) } = (NS { f: 0 }) {}\n    |                    ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:60:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:58:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:61:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:59:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:62:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:60:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:63:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:61:9\n    |\n LL |         (e @ 1...2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:69:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:67:9\n    |\n LL |         (e @ &(1...2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:70:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:68:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:81:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:79:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:80:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:83:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:81:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:84:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n    |\n LL |         (e @ 1..=2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:90:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:88:9\n    |\n LL |         (e @ &(1..=2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:91:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:89:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses\n \n-error: aborting due to 26 previous errors\n+error: aborting due to 24 previous errors\n \n-For more information about this error, try `rustc --explain E0416`."}, {"sha": "3ebf59c643735f9dd6570dc56b208d8690f2c31d", "filename": "src/test/ui/or-patterns/already-bound-name.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,46 @@\n+// This test ensures that the \"already bound identifier in a product pattern\"\n+// correctly accounts for or-patterns.\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+enum E<T> { A(T, T), B(T) }\n+\n+use E::*;\n+\n+fn main() {\n+    let (a, a) = (0, 1); // Standard duplication without an or-pattern.\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let (a, A(a, _) | B(a)) = (0, A(1, 2));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let (A(a, _) | B(a), a) = (A(0, 1), 2);\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let A(a, a) | B(a) = A(0, 1);\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let B(a) | A(a, a) = A(0, 1);\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    match A(0, 1) {\n+        B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n+        //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    }\n+\n+    let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR mismatched types\n+\n+    let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR variable `a` is not bound in all patterns\n+\n+    let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+}"}, {"sha": "360699a8739384661db650427a08400aea2f9d8c", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,105 @@\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:12:13\n+   |\n+LL |     let (a, a) = (0, 1); // Standard duplication without an or-pattern.\n+   |             ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:15:15\n+   |\n+LL |     let (a, A(a, _) | B(a)) = (0, A(1, 2));\n+   |               ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:15:25\n+   |\n+LL |     let (a, A(a, _) | B(a)) = (0, A(1, 2));\n+   |                         ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:19:26\n+   |\n+LL |     let (A(a, _) | B(a), a) = (A(0, 1), 2);\n+   |                          ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:22:14\n+   |\n+LL |     let A(a, a) | B(a) = A(0, 1);\n+   |              ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:25:21\n+   |\n+LL |     let B(a) | A(a, a) = A(0, 1);\n+   |                     ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:29:21\n+   |\n+LL |         B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n+   |                     ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:33:36\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+   |                                    ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:33:46\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+   |                                              ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:38:36\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                    ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:38:46\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                              ^ used in a pattern more than once\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/already-bound-name.rs:38:9\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |         ^^^^ pattern doesn't bind `a`        - variable not in all patterns\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:43:49\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                                 ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:43:59\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                                           ^ used in a pattern more than once\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/already-bound-name.rs:4:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/already-bound-name.rs:33:31\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+   |                               ^ expected integer, found enum `E`\n+   |\n+   = note: expected type `{integer}`\n+              found type `E<{integer}>`\n+\n+error: aborting due to 15 previous errors\n+\n+Some errors have detailed explanations: E0308, E0408, E0416.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "0eb539dca4cba86540957d90630c98df19d92b9a", "filename": "src/test/ui/or-patterns/consistent-bindings.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,46 @@\n+// Check that or-patterns with consistent bindings across arms are allowed.\n+\n+// edition:2018\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+fn main() {\n+    // One level:\n+    let Ok(a) | Err(a) = Ok(0);\n+    let Ok(ref a) | Err(ref a) = Ok(0);\n+    let Ok(ref mut a) | Err(ref mut a) = Ok(0);\n+\n+    // Two levels:\n+    enum Tri<S, T, U> { V1(S), V2(T), V3(U) }\n+    use Tri::*;\n+\n+    let Ok((V1(a) | V2(a) | V3(a), b)) | Err(Ok((a, b)) | Err((a, b)))\n+        : Result<_, Result<_, _>>\n+        = Ok((V1(1), 1));\n+\n+    let Ok((V1(a) | V2(a) | V3(a), ref b)) | Err(Ok((a, ref b)) | Err((a, ref b)))\n+        : Result<_, Result<_, _>>\n+        = Ok((V1(1), 1));\n+\n+    // Three levels:\n+    let (\n+            a,\n+            Err((ref mut b, ref c, d)) |\n+            Ok((\n+                Ok(\n+                    V1((ref c, d)) |\n+                    V2((d, ref c)) |\n+                    V3((ref c, Ok((_, d)) | Err((d, _))))\n+                ) |\n+                Err((ref c, d)),\n+                ref mut b\n+            ))\n+        ) =\n+        (1, Ok((Ok(V3((1, Ok((1, 1))))), 1)));\n+\n+    // FIXME(or_patterns; Centril | dlrobertson): remove this line below and\n+    // change this test to check-pass once MIR can handle or-patterns with bindings.\n+    let () = 0;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "7f5e670c257ce1673d60e04b7d7d7f63ef2376db", "filename": "src/test/ui/or-patterns/consistent-bindings.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/consistent-bindings.rs:5:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/consistent-bindings.rs:44:9\n+   |\n+LL |     let () = 0;\n+   |         ^^ expected integer, found ()\n+   |\n+   = note: expected type `{integer}`\n+              found type `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "44836893ea2b2b19b2054d16254eda01eec53a26", "filename": "src/test/ui/or-patterns/inconsistent-modes.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,28 @@\n+// This test ensures that or patterns require binding mode consistency across arms.\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+#![allow(non_camel_case_types)]\n+fn main() {\n+    // One level:\n+    let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    //~| ERROR mismatched types\n+    let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    //~| ERROR variable `b` is bound in inconsistent ways\n+    //~| ERROR mismatched types\n+\n+    // Two levels:\n+    let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+\n+    // Three levels:\n+    let Ok([ Ok((Ok(ref a) | Err(a),)) | Err(a) ]) | Err(a) = Err(&1);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+}"}, {"sha": "0a36ed5548e5b7f6e3a04d5a4960fa5944ce938e", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,80 @@\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:9:25\n+   |\n+LL |     let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n+   |            -            ^ bound in different ways\n+   |            |\n+   |            first binding\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:11:29\n+   |\n+LL |     let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n+   |                    -        ^ bound in different ways\n+   |                    |\n+   |                    first binding\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:13:33\n+   |\n+LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+   |                - first binding  ^ bound in different ways\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:16:39\n+   |\n+LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+   |                 - first binding       ^ bound in different ways\n+\n+error[E0409]: variable `b` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:16:46\n+   |\n+LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+   |                    - first binding           ^ bound in different ways\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:22:38\n+   |\n+LL |     let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n+   |                        -             ^ bound in different ways\n+   |                        |\n+   |                        first binding\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:26:34\n+   |\n+LL |     let Ok([ Ok((Ok(ref a) | Err(a),)) | Err(a) ]) | Err(a) = Err(&1);\n+   |                         -        ^ bound in different ways\n+   |                         |\n+   |                         first binding\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/inconsistent-modes.rs:3:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/inconsistent-modes.rs:13:25\n+   |\n+LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+   |                         ^^^^^^^^^ types differ in mutability\n+   |\n+   = note: expected type `&&u8`\n+              found type `&mut &mut u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/inconsistent-modes.rs:16:31\n+   |\n+LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+   |                               ^^^^^^^^^ types differ in mutability\n+   |\n+   = note: expected type `&{integer}`\n+              found type `&mut _`\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0308, E0409.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "b065028e7a5a4521011c90a84d95b4d469301d9c", "filename": "src/test/ui/or-patterns/missing-bindings.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,84 @@\n+// This test ensures that or patterns do not allow missing bindings in any of the arms.\n+\n+// edition:2018\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+#![allow(non_camel_case_types)]\n+\n+fn main() {}\n+\n+fn check_handling_of_paths() {\n+    mod bar {\n+        pub enum foo {\n+            alpha,\n+            beta,\n+            charlie\n+        }\n+    }\n+\n+    use bar::foo::{alpha, charlie};\n+    let alpha | beta | charlie = alpha; //~  ERROR variable `beta` is not bound in all patterns\n+    match Some(alpha) {\n+        Some(alpha | beta) => {} //~ ERROR variable `beta` is not bound in all patterns\n+    }\n+}\n+\n+fn check_misc_nesting() {\n+    enum E<T> { A(T, T), B(T) }\n+    use E::*;\n+    enum Vars3<S, T, U> { V1(S), V2(T), V3(U) }\n+    use Vars3::*;\n+\n+    // One level:\n+    const X: E<u8> = B(0);\n+    let A(a, _) | _ = X; //~ ERROR variable `a` is not bound in all patterns\n+    let _ | B(a) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(..) | B(a) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(a, _) | B(_) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(_, a) | B(_) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(a, b) | B(a) = X; //~ ERROR variable `b` is not bound in all patterns\n+\n+    // Two levels:\n+    const Y: E<E<u8>> = B(B(0));\n+    let A(A(..) | B(_), _) | B(a) = Y; //~ ERROR variable `a` is not bound in all patterns\n+    let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n+    //~^ ERROR variable `a` is not bound in all patterns\n+    let A(A(a, b) | B(c), d) | B(e) = Y;\n+    //~^ ERROR variable `a` is not bound in all patterns\n+    //~| ERROR variable `a` is not bound in all patterns\n+    //~| ERROR variable `b` is not bound in all patterns\n+    //~| ERROR variable `b` is not bound in all patterns\n+    //~| ERROR variable `c` is not bound in all patterns\n+    //~| ERROR variable `c` is not bound in all patterns\n+    //~| ERROR variable `d` is not bound in all patterns\n+    //~| ERROR variable `e` is not bound in all patterns\n+\n+    // Three levels:\n+    let (\n+            V1(\n+            //~^ ERROR variable `b` is not bound in all patterns\n+            //~| ERROR variable `c` is not bound in all patterns\n+                A(\n+                    Ok(a) | Err(_), //~ ERROR variable `a` is not bound in all patterns\n+                    _\n+                ) |\n+                B(Ok(a) | Err(a))\n+            ) |\n+            V2(\n+                A(\n+                    A(_, a) | //~ ERROR variable `b` is not bound in all patterns\n+                    B(b), //~ ERROR variable `a` is not bound in all patterns\n+                    _\n+                ) |\n+                B(_)\n+                //~^ ERROR variable `a` is not bound in all patterns\n+                //~| ERROR variable `b` is not bound in all patterns\n+            ) |\n+            V3(c),\n+            //~^ ERROR variable `a` is not bound in all patterns\n+        )\n+        : (Vars3<E<Result<u8, u8>>, E<E<u8>>, u8>,)\n+        = (V3(0),);\n+}"}, {"sha": "c73af7a42eec0c8a11030beaa1bade5476dd49a3", "filename": "src/test/ui/or-patterns/missing-bindings.stderr", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -0,0 +1,250 @@\n+error[E0408]: variable `beta` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:22:9\n+   |\n+LL |     let alpha | beta | charlie = alpha;\n+   |         ^^^^^   ----   ^^^^^^^ pattern doesn't bind `beta`\n+   |         |       |\n+   |         |       variable not in all patterns\n+   |         pattern doesn't bind `beta`\n+\n+error[E0408]: variable `beta` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:24:14\n+   |\n+LL |         Some(alpha | beta) => {}\n+   |              ^^^^^   ---- variable not in all patterns\n+   |              |\n+   |              pattern doesn't bind `beta`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:36:19\n+   |\n+LL |     let A(a, _) | _ = X;\n+   |           -       ^ pattern doesn't bind `a`\n+   |           |\n+   |           variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:37:9\n+   |\n+LL |     let _ | B(a) = X;\n+   |         ^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:38:9\n+   |\n+LL |     let A(..) | B(a) = X;\n+   |         ^^^^^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:39:19\n+   |\n+LL |     let A(a, _) | B(_) = X;\n+   |           -       ^^^^ pattern doesn't bind `a`\n+   |           |\n+   |           variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:40:19\n+   |\n+LL |     let A(_, a) | B(_) = X;\n+   |              -    ^^^^ pattern doesn't bind `a`\n+   |              |\n+   |              variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:41:19\n+   |\n+LL |     let A(a, b) | B(a) = X;\n+   |              -    ^^^^ pattern doesn't bind `b`\n+   |              |\n+   |              variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:45:9\n+   |\n+LL |     let A(A(..) | B(_), _) | B(a) = Y;\n+   |         ^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:46:11\n+   |\n+LL |     let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n+   |           ^^^^^     - variable not in all patterns\n+   |           |\n+   |           pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:21\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |             -       ^^^^ pattern doesn't bind `a`\n+   |             |\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:21\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                -    ^^^^ pattern doesn't bind `b`\n+   |                |\n+   |                variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:11\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |           ^^^^^^^     - variable not in all patterns\n+   |           |\n+   |           pattern doesn't bind `c`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |             -                  ^^^^ pattern doesn't bind `a`\n+   |             |\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                -               ^^^^ pattern doesn't bind `b`\n+   |                |\n+   |                variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                       -        ^^^^ pattern doesn't bind `c`\n+   |                       |\n+   |                       variable not in all patterns\n+\n+error[E0408]: variable `d` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                           -    ^^^^ pattern doesn't bind `d`\n+   |                           |\n+   |                           variable not in all patterns\n+\n+error[E0408]: variable `e` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:9\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |         ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `e`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:64:29\n+   |\n+LL |                     Ok(a) | Err(_),\n+   |                        -    ^^^^^^ pattern doesn't bind `a`\n+   |                        |\n+   |                        variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:72:21\n+   |\n+LL |                     A(_, a) |\n+   |                          - variable not in all patterns\n+LL |                     B(b),\n+   |                     ^^^^ pattern doesn't bind `a`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:71:21\n+   |\n+LL |                     A(_, a) |\n+   |                     ^^^^^^^ pattern doesn't bind `b`\n+LL |                     B(b),\n+   |                       - variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:75:17\n+   |\n+LL |                     A(_, a) |\n+   |                          - variable not in all patterns\n+...\n+LL |                 B(_)\n+   |                 ^^^^ pattern doesn't bind `a`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:75:17\n+   |\n+LL |                     B(b),\n+   |                       - variable not in all patterns\n+...\n+LL |                 B(_)\n+   |                 ^^^^ pattern doesn't bind `b`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:79:13\n+   |\n+LL |                 B(Ok(a) | Err(a))\n+   |                               - variable not in all patterns\n+...\n+LL |                     A(_, a) |\n+   |                          - variable not in all patterns\n+...\n+LL |             V3(c),\n+   |             ^^^^^ pattern doesn't bind `a`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:60:13\n+   |\n+LL | /             V1(\n+LL | |\n+LL | |\n+LL | |                 A(\n+...  |\n+LL | |                 B(Ok(a) | Err(a))\n+LL | |             ) |\n+   | |_____________^ pattern doesn't bind `b`\n+...\n+LL |                       B(b),\n+   |                         - variable not in all patterns\n+...\n+LL |               V3(c),\n+   |               ^^^^^ pattern doesn't bind `b`\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:60:13\n+   |\n+LL | /             V1(\n+LL | |\n+LL | |\n+LL | |                 A(\n+...  |\n+LL | |                 B(Ok(a) | Err(a))\n+LL | |             ) |\n+   | |_____________^ pattern doesn't bind `c`\n+LL | /             V2(\n+LL | |                 A(\n+LL | |                     A(_, a) |\n+LL | |                     B(b),\n+...  |\n+LL | |\n+LL | |             ) |\n+   | |_____________^ pattern doesn't bind `c`\n+LL |               V3(c),\n+   |                  - variable not in all patterns\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/missing-bindings.rs:5:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to 26 previous errors\n+\n+For more information about this error, try `rustc --explain E0408`."}, {"sha": "1c51653db6abfeaec21385424ae7186e6011522f", "filename": "src/test/ui/shadowed/shadowing-in-the-same-pattern.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c1630aa386582644759514f74b2b0a7601fb379/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr?ref=3c1630aa386582644759514f74b2b0a7601fb379", "patch": "@@ -1,8 +1,8 @@\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n+error[E0415]: identifier `a` is bound more than once in this parameter list\n   --> $DIR/shadowing-in-the-same-pattern.rs:3:10\n    |\n LL | fn f((a, a): (isize, isize)) {}\n-   |          ^ used in a pattern more than once\n+   |          ^ used as parameter more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n   --> $DIR/shadowing-in-the-same-pattern.rs:6:13\n@@ -12,4 +12,5 @@ LL |     let (a, a) = (1, 1);\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0416`.\n+Some errors have detailed explanations: E0415, E0416.\n+For more information about an error, try `rustc --explain E0415`."}]}