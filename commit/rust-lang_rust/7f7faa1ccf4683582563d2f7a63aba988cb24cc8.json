{"sha": "7f7faa1ccf4683582563d2f7a63aba988cb24cc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmN2ZhYTFjY2Y0NjgzNTgyNTYzZDJmN2E2M2FiYTk4OGNiMjRjYzg=", "commit": {"author": {"name": "Urcra", "email": "urcra@urcra.com", "date": "2020-10-25T23:51:18Z"}, "committer": {"name": "Urcra", "email": "urcra@urcra.com", "date": "2020-10-25T23:51:18Z"}, "message": "Move implementation into len_zero.rs", "tree": {"sha": "b250c1c473474e67310bd9c2fbf9e4b91d9a2762", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b250c1c473474e67310bd9c2fbf9e4b91d9a2762"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f7faa1ccf4683582563d2f7a63aba988cb24cc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7faa1ccf4683582563d2f7a63aba988cb24cc8", "html_url": "https://github.com/rust-lang/rust/commit/7f7faa1ccf4683582563d2f7a63aba988cb24cc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f7faa1ccf4683582563d2f7a63aba988cb24cc8/comments", "author": {"login": "Urcra", "id": 9095312, "node_id": "MDQ6VXNlcjkwOTUzMTI=", "avatar_url": "https://avatars.githubusercontent.com/u/9095312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urcra", "html_url": "https://github.com/Urcra", "followers_url": "https://api.github.com/users/Urcra/followers", "following_url": "https://api.github.com/users/Urcra/following{/other_user}", "gists_url": "https://api.github.com/users/Urcra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urcra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urcra/subscriptions", "organizations_url": "https://api.github.com/users/Urcra/orgs", "repos_url": "https://api.github.com/users/Urcra/repos", "events_url": "https://api.github.com/users/Urcra/events{/privacy}", "received_events_url": "https://api.github.com/users/Urcra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urcra", "id": 9095312, "node_id": "MDQ6VXNlcjkwOTUzMTI=", "avatar_url": "https://avatars.githubusercontent.com/u/9095312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urcra", "html_url": "https://github.com/Urcra", "followers_url": "https://api.github.com/users/Urcra/followers", "following_url": "https://api.github.com/users/Urcra/following{/other_user}", "gists_url": "https://api.github.com/users/Urcra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urcra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urcra/subscriptions", "organizations_url": "https://api.github.com/users/Urcra/orgs", "repos_url": "https://api.github.com/users/Urcra/repos", "events_url": "https://api.github.com/users/Urcra/events{/privacy}", "received_events_url": "https://api.github.com/users/Urcra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de5a6d3420d9f2f2c4c995e325412e862a9dc583", "url": "https://api.github.com/repos/rust-lang/rust/commits/de5a6d3420d9f2f2c4c995e325412e862a9dc583", "html_url": "https://github.com/rust-lang/rust/commit/de5a6d3420d9f2f2c4c995e325412e862a9dc583"}], "stats": {"total": 247, "additions": 86, "deletions": 161}, "files": [{"sha": "3b55336722c1cfda53f3c1db519e31f8e49d91d8", "filename": "clippy_lints/src/comparison_to_empty.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/de5a6d3420d9f2f2c4c995e325412e862a9dc583/clippy_lints%2Fsrc%2Fcomparison_to_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5a6d3420d9f2f2c4c995e325412e862a9dc583/clippy_lints%2Fsrc%2Fcomparison_to_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_to_empty.rs?ref=de5a6d3420d9f2f2c4c995e325412e862a9dc583", "patch": "@@ -1,155 +0,0 @@\n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, ItemKind, TraitItemRef};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::{Span, Spanned};\n-\n-declare_clippy_lint! {\n-    /// **What it does:**\n-    ///\n-    /// **Why is this bad?**\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// // example code where clippy issues a warning\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// // example code which does not raise clippy warning\n-    /// ```\n-    pub COMPARISON_TO_EMPTY,\n-    style,\n-    \"default lint description\"\n-}\n-\n-declare_lint_pass!(ComparisonToEmpty => [COMPARISON_TO_EMPTY]);\n-\n-impl LateLintPass<'_> for ComparisonToEmpty {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.kind {\n-            match cmp {\n-                BinOpKind::Eq => {\n-                    check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n-                    check_cmp(cx, expr.span, right, left, \"\", 0); // 0 == len\n-                },\n-                BinOpKind::Ne => {\n-                    check_cmp(cx, expr.span, left, right, \"!\", 0); // len != 0\n-                    check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 != len\n-                },\n-                BinOpKind::Gt => {\n-                    check_cmp(cx, expr.span, left, right, \"!\", 0); // len > 0\n-                    check_cmp(cx, expr.span, right, left, \"\", 1); // 1 > len\n-                },\n-                BinOpKind::Lt => {\n-                    check_cmp(cx, expr.span, left, right, \"\", 1); // len < 1\n-                    check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 < len\n-                },\n-                BinOpKind::Ge => check_cmp(cx, expr.span, left, right, \"!\", 1), // len >= 1\n-                BinOpKind::Le => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 <= len\n-                _ => (),\n-            }\n-        }\n-    }\n-\n-}\n-\n-\n-fn check_cmp(cx: &LateContext<'_>, span: Span, lit1: &Expr<'_>, lit2: &Expr<'_>, op: &str, compare_to: u32) {\n-    check_empty_expr(cx, span, lit1, lit2, op)\n-}\n-\n-fn check_empty_expr(\n-    cx: &LateContext<'_>,\n-    span: Span,\n-    lit1: &Expr<'_>,\n-    lit2: &Expr<'_>,\n-    op: &str\n-) {\n-    if (is_empty_array(lit2) || is_empty_string(lit2)) && has_is_empty(cx, lit1) {\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            COMPARISON_TO_EMPTY,\n-            span,\n-            &format!(\"comparison to empty slice\"),\n-            &format!(\"using `{}is_empty` is clearer and more explicit\", op),\n-            format!(\n-                \"{}{}.is_empty()\",\n-                op,\n-                snippet_with_applicability(cx, lit1.span, \"_\", &mut applicability)\n-            ),\n-            applicability,\n-        );\n-    }\n-}\n-\n-fn is_empty_string(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Lit(ref lit) = expr.kind {\n-        if let LitKind::Str(lit, _) = lit.node {\n-            let lit = lit.as_str();\n-            return lit == \"\";\n-        }\n-    }\n-    false\n-}\n-\n-fn is_empty_array(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Array(ref arr) = expr.kind {\n-        return arr.is_empty();\n-    }\n-    false\n-}\n-\n-\n-/// Checks if this type has an `is_empty` method.\n-fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n-    fn is_is_empty(cx: &LateContext<'_>, item: &ty::AssocItem) -> bool {\n-        if let ty::AssocKind::Fn = item.kind {\n-            if item.ident.name.as_str() == \"is_empty\" {\n-                let sig = cx.tcx.fn_sig(item.def_id);\n-                let ty = sig.skip_binder();\n-                ty.inputs().len() == 1\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Checks the inherent impl's items for an `is_empty(self)` method.\n-    fn has_is_empty_impl(cx: &LateContext<'_>, id: DefId) -> bool {\n-        cx.tcx.inherent_impls(id).iter().any(|imp| {\n-            cx.tcx\n-                .associated_items(*imp)\n-                .in_definition_order()\n-                .any(|item| is_is_empty(cx, &item))\n-        })\n-    }\n-\n-    let ty = &cx.typeck_results().expr_ty(expr).peel_refs();\n-    match ty.kind() {\n-        ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n-            cx.tcx\n-                .associated_items(principal.def_id())\n-                .in_definition_order()\n-                .any(|item| is_is_empty(cx, &item))\n-        }),\n-        ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n-        ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n-        ty::Array(..) | ty::Slice(..) | ty::Str => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "75e9c5c973b824568362e6fa59b91321d016bd8d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7f7faa1ccf4683582563d2f7a63aba988cb24cc8/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7faa1ccf4683582563d2f7a63aba988cb24cc8/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=7f7faa1ccf4683582563d2f7a63aba988cb24cc8", "patch": "@@ -68,7 +68,45 @@ declare_clippy_lint! {\n     \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n }\n \n-declare_lint_pass!(LenZero => [LEN_ZERO, LEN_WITHOUT_IS_EMPTY]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparing to an empty slice such as \"\" or [],`\n+    /// and suggests using `.is_empty()` where applicable.\n+    ///\n+    /// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n+    /// than checking for equality. So it is good to get into the habit of using\n+    /// `.is_empty()`, and having it is cheap.\n+    /// Besides, it makes the intent clearer than a manual comparison in some contexts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// if s == \"\" {\n+    ///     ..\n+    /// }\n+\n+    /// if arr == [] {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```ignore\n+    /// if s.is_empty() {\n+    ///     ..\n+    /// }\n+\n+    /// if arr.is_empty() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub COMPARISON_TO_EMPTY,\n+    style,\n+    \"default lint description\"\n+}\n+\n+\n+declare_lint_pass!(LenZero => [LEN_ZERO, LEN_WITHOUT_IS_EMPTY, COMPARISON_TO_EMPTY]);\n \n impl<'tcx> LateLintPass<'tcx> for LenZero {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -221,6 +259,8 @@ fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>\n         }\n \n         check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to)\n+    } else {\n+        check_empty_expr(cx, span, method, lit, op)\n     }\n }\n \n@@ -258,6 +298,48 @@ fn check_len(\n     }\n }\n \n+fn check_empty_expr(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    lit1: &Expr<'_>,\n+    lit2: &Expr<'_>,\n+    op: &str\n+) {\n+    if (is_empty_array(lit2) || is_empty_string(lit2)) && has_is_empty(cx, lit1) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            COMPARISON_TO_EMPTY,\n+            span,\n+            &format!(\"comparison to empty slice\"),\n+            &format!(\"using `{}is_empty` is clearer and more explicit\", op),\n+            format!(\n+                \"{}{}.is_empty()\",\n+                op,\n+                snippet_with_applicability(cx, lit1.span, \"_\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}\n+\n+fn is_empty_string(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Lit(ref lit) = expr.kind {\n+        if let LitKind::Str(lit, _) = lit.node {\n+            let lit = lit.as_str();\n+            return lit == \"\";\n+        }\n+    }\n+    false\n+}\n+\n+fn is_empty_array(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Array(ref arr) = expr.kind {\n+        return arr.is_empty();\n+    }\n+    false\n+}\n+\n /// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`."}, {"sha": "3ad2e1e9d5765f7edf37b28f7ed24cfbaad29637", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f7faa1ccf4683582563d2f7a63aba988cb24cc8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7faa1ccf4683582563d2f7a63aba988cb24cc8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7f7faa1ccf4683582563d2f7a63aba988cb24cc8", "patch": "@@ -171,7 +171,6 @@ mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n mod comparison_chain;\n-mod comparison_to_empty;\n mod copies;\n mod copy_iterator;\n mod create_dir;\n@@ -524,7 +523,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n         &collapsible_if::COLLAPSIBLE_IF,\n         &comparison_chain::COMPARISON_CHAIN,\n-        &comparison_to_empty::COMPARISON_TO_EMPTY,\n+        &len_zero::COMPARISON_TO_EMPTY,\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n         &copies::MATCH_SAME_ARMS,\n@@ -1141,7 +1140,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n-    store.register_late_pass(|| box comparison_to_empty::ComparisonToEmpty);\n \n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n@@ -1302,7 +1300,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n-        LintId::of(&comparison_to_empty::COMPARISON_TO_EMPTY),\n+        LintId::of(&len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n@@ -1559,7 +1557,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n-        LintId::of(&comparison_to_empty::COMPARISON_TO_EMPTY),\n+        LintId::of(&len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n         LintId::of(&doc::NEEDLESS_DOCTEST_MAIN),\n         LintId::of(&enum_variants::ENUM_VARIANT_NAMES),"}]}