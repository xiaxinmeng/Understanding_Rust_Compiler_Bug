{"sha": "e2273d945640442224a09e532865e4a58257a851", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMjczZDk0NTY0MDQ0MjIyNGEwOWU1MzI4NjVlNGE1ODI1N2E4NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-12T18:16:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-12T18:16:33Z"}, "message": "auto merge of #16081 : luqmana/rust/nr, r=pcwalton\n\nFixes #15763", "tree": {"sha": "a972d7a068f7b2df789f29617501440394aa2fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a972d7a068f7b2df789f29617501440394aa2fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2273d945640442224a09e532865e4a58257a851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2273d945640442224a09e532865e4a58257a851", "html_url": "https://github.com/rust-lang/rust/commit/e2273d945640442224a09e532865e4a58257a851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2273d945640442224a09e532865e4a58257a851/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7d0b5259d95ab4ef821bdf93a434538c3a84dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d0b5259d95ab4ef821bdf93a434538c3a84dad", "html_url": "https://github.com/rust-lang/rust/commit/c7d0b5259d95ab4ef821bdf93a434538c3a84dad"}, {"sha": "71e19d528633a470d2d93580651a922e21d7a512", "url": "https://api.github.com/repos/rust-lang/rust/commits/71e19d528633a470d2d93580651a922e21d7a512", "html_url": "https://github.com/rust-lang/rust/commit/71e19d528633a470d2d93580651a922e21d7a512"}], "stats": {"total": 458, "additions": 406, "deletions": 52}, "files": [{"sha": "1dd3d6ce9db9d409df80a7aa3018bac432e6f311", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -310,6 +310,13 @@ extern \"rust-intrinsic\" {\n     /// ```\n     pub fn transmute<T,U>(e: T) -> U;\n \n+    /// Gives the address for the return value of the enclosing function.\n+    ///\n+    /// Using this instrinsic in a function that does not use an out pointer\n+    /// will trigger a compiler error.\n+    #[cfg(not(stage0))]\n+    pub fn return_address() -> *const u8;\n+\n     /// Returns `true` if a type requires drop glue.\n     pub fn needs_drop<T>() -> bool;\n "}, {"sha": "0860f84dbef47a4375ab844e162ab7f061141090", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 162, "deletions": 28, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -1122,7 +1122,7 @@ pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n         let llalign = llalign_of_min(ccx, llty);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n     } else {\n-        Store(bcx, Load(bcx, src), dst);\n+        store_ty(bcx, Load(bcx, src), dst, t);\n     }\n }\n \n@@ -1210,15 +1210,120 @@ pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n     p\n }\n \n-// Creates and returns space for, or returns the argument representing, the\n-// slot where the return value of the function must go.\n-pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n-                           -> ValueRef {\n-    if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-        get_param(fcx.llfn, 0)\n+// Creates the alloca slot which holds the pointer to the slot for the final return value\n+pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: ty::t) -> ValueRef {\n+    let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n+\n+    // We create an alloca to hold a pointer of type `output_type`\n+    // which will hold the pointer to the right alloca which has the\n+    // final ret value\n+    if fcx.needs_ret_allocas {\n+        // Let's create the stack slot\n+        let slot = AllocaFcx(fcx, lloutputtype.ptr_to(), \"llretslotptr\");\n+\n+        // and if we're using an out pointer, then store that in our newly made slot\n+        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n+            let outptr = get_param(fcx.llfn, 0);\n+\n+            let b = fcx.ccx.builder();\n+            b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+            b.store(outptr, slot);\n+        }\n+\n+        slot\n+\n+    // But if there are no nested returns, we skip the indirection and have a single\n+    // retslot\n     } else {\n-        let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-        AllocaFcx(fcx, lloutputtype, \"__make_return_pointer\")\n+        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n+            get_param(fcx.llfn, 0)\n+        } else {\n+            AllocaFcx(fcx, lloutputtype, \"sret_slot\")\n+        }\n+    }\n+}\n+\n+struct CheckForNestedReturnsVisitor {\n+    found: bool\n+}\n+\n+impl Visitor<bool> for CheckForNestedReturnsVisitor {\n+    fn visit_expr(&mut self, e: &ast::Expr, in_return: bool) {\n+        match e.node {\n+            ast::ExprRet(..) if in_return => {\n+                self.found = true;\n+                return;\n+            }\n+            ast::ExprRet(..) => visit::walk_expr(self, e, true),\n+            _ => visit::walk_expr(self, e, in_return)\n+        }\n+    }\n+}\n+\n+fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n+    match tcx.map.find(id) {\n+        Some(ast_map::NodeItem(i)) => {\n+            match i.node {\n+                ast::ItemFn(_, _, _, _, blk) => {\n+                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                    visit::walk_item(&mut explicit, &*i, false);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    explicit.found || implicit.found\n+                }\n+                _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n+            }\n+        }\n+        Some(ast_map::NodeTraitMethod(trait_method)) => {\n+            match *trait_method {\n+                ast::Provided(m) => {\n+                    match m.node {\n+                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                            let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                            let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                            visit::walk_method_helper(&mut explicit, &*m, false);\n+                            visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                            explicit.found || implicit.found\n+                        }\n+                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n+                    }\n+                }\n+                ast::Required(_) => tcx.sess.bug(\"unexpected variant: required trait method in \\\n+                                                  has_nested_returns\")\n+            }\n+        }\n+        Some(ast_map::NodeMethod(m)) => {\n+            match m.node {\n+                ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                    visit::walk_method_helper(&mut explicit, &*m, false);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    explicit.found || implicit.found\n+                }\n+                ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n+            }\n+        }\n+        Some(ast_map::NodeExpr(e)) => {\n+            match e.node {\n+                ast::ExprFnBlock(_, blk) | ast::ExprProc(_, blk) | ast::ExprUnboxedFn(_, blk) => {\n+                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                    visit::walk_expr(&mut explicit, &*e, false);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    explicit.found || implicit.found\n+                }\n+                _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n+            }\n+        }\n+\n+        Some(ast_map::NodeVariant(..)) | Some(ast_map::NodeStructCtor(..)) => false,\n+\n+        // glue, shims, etc\n+        None if id == ast::DUMMY_NODE_ID => false,\n+\n+        _ => tcx.sess.bug(format!(\"unexpected variant in has_nested_returns: {}\",\n+                                  tcx.map.path_to_string(id)).as_slice())\n     }\n }\n \n@@ -1254,13 +1359,15 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n     let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n+    let nested_returns = has_nested_returns(ccx.tcx(), id);\n \n     let mut fcx = FunctionContext {\n           llfn: llfndecl,\n           llenv: None,\n-          llretptr: Cell::new(None),\n+          llretslotptr: Cell::new(None),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n+          needs_ret_allocas: nested_returns,\n           personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n           llargs: RefCell::new(NodeMap::new()),\n@@ -1303,12 +1410,12 @@ pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n \n     if !return_type_is_void(fcx.ccx, substd_output_type) {\n         // If the function returns nil/bot, there is no real return\n-        // value, so do not set `llretptr`.\n+        // value, so do not set `llretslotptr`.\n         if !skip_retptr || fcx.caller_expects_out_pointer {\n-            // Otherwise, we normally allocate the llretptr, unless we\n+            // Otherwise, we normally allocate the llretslotptr, unless we\n             // have been instructed to skip it for immediate return\n             // values.\n-            fcx.llretptr.set(Some(make_return_pointer(fcx, substd_output_type)));\n+            fcx.llretslotptr.set(Some(make_return_slot_pointer(fcx, substd_output_type)));\n         }\n     }\n \n@@ -1533,13 +1640,18 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n \n // Builds the return block for a function.\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n-    // Return the value if this function immediate; otherwise, return void.\n-    if fcx.llretptr.get().is_none() || fcx.caller_expects_out_pointer {\n+    if fcx.llretslotptr.get().is_none() ||\n+       (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n     }\n \n-    let retptr = Value(fcx.llretptr.get().unwrap());\n-    let retval = match retptr.get_dominating_store(ret_cx) {\n+    let retslot = if fcx.needs_ret_allocas {\n+        Load(ret_cx, fcx.llretslotptr.get().unwrap())\n+    } else {\n+        fcx.llretslotptr.get().unwrap()\n+    };\n+    let retptr = Value(retslot);\n+    match retptr.get_dominating_store(ret_cx) {\n         // If there's only a single store to the ret slot, we can directly return\n         // the value that was stored and omit the store and the alloca\n         Some(s) => {\n@@ -1550,17 +1662,29 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n                 retptr.erase_from_parent();\n             }\n \n-            if ty::type_is_bool(retty) {\n+            let retval = if ty::type_is_bool(retty) {\n                 Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n             } else {\n                 retval\n+            };\n+\n+            if fcx.caller_expects_out_pointer {\n+                store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n+                return RetVoid(ret_cx);\n+            } else {\n+                return Ret(ret_cx, retval);\n             }\n         }\n-        // Otherwise, load the return value from the ret slot\n-        None => load_ty(ret_cx, fcx.llretptr.get().unwrap(), retty)\n-    };\n-\n-    Ret(ret_cx, retval);\n+        // Otherwise, copy the return value to the ret slot\n+        None => {\n+            if fcx.caller_expects_out_pointer {\n+                memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n+                return RetVoid(ret_cx);\n+            } else {\n+                return Ret(ret_cx, load_ty(ret_cx, retslot, retty));\n+            }\n+        }\n+    }\n }\n \n #[deriving(Clone, Eq, PartialEq)]\n@@ -1658,10 +1782,10 @@ pub fn trans_closure(ccx: &CrateContext,\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(&fcx);\n \n-    let dest = match fcx.llretptr.get() {\n-        Some(e) => {expr::SaveIn(e)}\n+    let dest = match fcx.llretslotptr.get() {\n+        Some(_) => expr::SaveIn(fcx.get_ret_slot(bcx, block_ty, \"iret_slot\")),\n         None => {\n-            assert!(type_is_zero_size(bcx.ccx(), block_ty))\n+            assert!(type_is_zero_size(bcx.ccx(), block_ty));\n             expr::Ignore\n         }\n     };\n@@ -1672,6 +1796,13 @@ pub fn trans_closure(ccx: &CrateContext,\n     // (trans_block, trans_expr, et cetera).\n     bcx = controlflow::trans_block(bcx, body, dest);\n \n+    match dest {\n+        expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n+            Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n+        }\n+        _ => {}\n+    }\n+\n     match fcx.llreturn.get() {\n         Some(_) => {\n             Br(bcx, fcx.return_exit_block());\n@@ -1836,21 +1967,24 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                           param_substs, None, &arena, TranslateItems);\n     let bcx = init_function(&fcx, false, result_ty);\n \n+    assert!(!fcx.needs_ret_allocas);\n+\n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n+        let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n         let repr = adt::represent_type(ccx, result_ty);\n         for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n-                                                 fcx.llretptr.get().unwrap(),\n+                                                 dest,\n                                                  disr,\n                                                  i);\n             arg_datum.store_to(bcx, lldestptr);\n         }\n-        adt::trans_set_discr(bcx, &*repr, fcx.llretptr.get().unwrap(), disr);\n+        adt::trans_set_discr(bcx, &*repr, dest, disr);\n     }\n \n     finish_fn(&fcx, bcx, result_ty);"}, {"sha": "8e6ff0cdb3e115e61e0fa1742975a1d0f23a420e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -334,7 +334,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     let return_type = ty::ty_fn_ret(boxed_function_type);\n     let fcx = new_fn_ctxt(ccx,\n                           llfn,\n-                          -1,\n+                          ast::DUMMY_NODE_ID,\n                           false,\n                           return_type,\n                           &empty_param_substs,\n@@ -389,6 +389,11 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     for i in range(1, arg_types.len()) {\n         llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n     }\n+    assert!(!fcx.needs_ret_allocas);\n+    let dest = match fcx.llretslotptr.get() {\n+        Some(_) => Some(expr::SaveIn(fcx.get_ret_slot(bcx, return_type, \"ret_slot\"))),\n+        None => None\n+    };\n     bcx = trans_call_inner(bcx,\n                            None,\n                            function_type,\n@@ -399,10 +404,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n                                }\n                            },\n                            ArgVals(llshimmedargs.as_slice()),\n-                           match fcx.llretptr.get() {\n-                               None => None,\n-                               Some(llretptr) => Some(expr::SaveIn(llretptr)),\n-                           }).bcx;\n+                           dest).bcx;\n \n     bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n     finish_fn(&fcx, bcx, return_type);\n@@ -758,9 +760,11 @@ pub fn trans_call_inner<'a>(\n             assert!(abi == synabi::RustIntrinsic);\n             assert!(dest.is_some());\n \n+            let call_info = call_info.expect(\"no call info for intrinsic call?\");\n             return intrinsic::trans_intrinsic_call(bcx, node, callee_ty,\n                                                    arg_cleanup_scope, args,\n-                                                   dest.unwrap(), substs);\n+                                                   dest.unwrap(), substs,\n+                                                   call_info);\n         }\n         NamedTupleConstructor(substs, disr) => {\n             assert!(dest.is_some());"}, {"sha": "eeff0609a56dd2658f2071958762a982d40b5a36", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -574,24 +574,25 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output,\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.output,\n                           &empty_param_substs, None, &arena, TranslateItems);\n     let bcx = init_function(&fcx, true, f.sig.output);\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)\n                                             .as_slice());\n     let mut llargs = Vec::new();\n-    match fcx.llretptr.get() {\n+    match fcx.llretslotptr.get() {\n         Some(llretptr) => {\n+            assert!(!fcx.needs_ret_allocas);\n             llargs.push(llretptr);\n         }\n         None => {}\n     }\n     llargs.extend(args.iter().map(|arg| arg.val));\n \n     let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n-    if type_is_zero_size(ccx, f.sig.output) || fcx.llretptr.get().is_some() {\n+    if type_is_zero_size(ccx, f.sig.output) || fcx.llretslotptr.get().is_some() {\n         RetVoid(bcx);\n     } else {\n         Ret(bcx, retval);"}, {"sha": "5e46550eccba561191200c6d9c35f2fe8876c6af", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -21,11 +21,13 @@ use middle::def;\n use middle::lang_items::LangItem;\n use middle::subst;\n use middle::subst::Subst;\n+use middle::trans::base;\n use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n+use middle::trans::type_of;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n@@ -240,11 +242,11 @@ pub struct FunctionContext<'a> {\n     // The environment argument in a closure.\n     pub llenv: Option<ValueRef>,\n \n-    // The place to store the return value. If the return type is immediate,\n-    // this is an alloca in the function. Otherwise, it's the hidden first\n-    // parameter to the function. After function construction, this should\n-    // always be Some.\n-    pub llretptr: Cell<Option<ValueRef>>,\n+    // A pointer to where to store the return value. If the return type is\n+    // immediate, this points to an alloca in the function. Otherwise, it's a\n+    // pointer to the hidden first parameter of the function. After function\n+    // construction, this should always be Some.\n+    pub llretslotptr: Cell<Option<ValueRef>>,\n \n     // These pub elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -254,13 +256,18 @@ pub struct FunctionContext<'a> {\n     pub alloca_insert_pt: Cell<Option<ValueRef>>,\n     pub llreturn: Cell<Option<BasicBlockRef>>,\n \n+    // If the function has any nested return's, including something like:\n+    // fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n+    // we use a separate alloca for each return\n+    pub needs_ret_allocas: bool,\n+\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     pub personality: Cell<Option<ValueRef>>,\n \n     // True if the caller expects this fn to use the out pointer to\n-    // return. Either way, your code should write into llretptr, but if\n-    // this value is false, llretptr will be a local alloca.\n+    // return. Either way, your code should write into the slot llretslotptr\n+    // points to, but if this value is false, that slot will be a local alloca.\n     pub caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n@@ -345,6 +352,14 @@ impl<'a> FunctionContext<'a> {\n         self.llreturn.get().unwrap()\n     }\n \n+    pub fn get_ret_slot(&self, bcx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+        if self.needs_ret_allocas {\n+            base::alloca_no_lifetime(bcx, type_of::type_of(bcx.ccx(), ty), name)\n+        } else {\n+            self.llretslotptr.get().unwrap()\n+        }\n+    }\n+\n     pub fn new_block(&'a self,\n                      is_lpad: bool,\n                      name: &str,"}, {"sha": "02a5f715ecb230e2132c08e5f2605ba2c54901c3", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -462,13 +462,22 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match bcx.fcx.llretptr.get() {\n-        None => expr::Ignore,\n-        Some(retptr) => expr::SaveIn(retptr),\n+    let dest = match (fcx.llretslotptr.get(), e) {\n+        (Some(_), Some(e)) => {\n+            let ret_ty = expr_ty(bcx, &*e);\n+            expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\"))\n+        }\n+        _ => expr::Ignore,\n     };\n     match e {\n         Some(x) => {\n             bcx = expr::trans_into(bcx, &*x, dest);\n+            match dest {\n+                expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n+                    Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n+                }\n+                _ => {}\n+            }\n         }\n         _ => {}\n     }"}, {"sha": "1d016f6db265933472562f77c9c386164226b0a1", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -467,7 +467,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, -1, false, ty::mk_nil(),\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false, ty::mk_nil(),\n                           &empty_param_substs, None, &arena, TranslateItems);\n \n     let bcx = init_function(&fcx, false, ty::mk_nil());"}, {"sha": "359c8d24f72705c6ef0aa6098400c5680d8d3a38", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -126,7 +126,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n                                 callee_ty: ty::t, cleanup_scope: cleanup::CustomScopeIndex,\n                                 args: callee::CallArgs, dest: expr::Dest,\n-                                substs: subst::Substs) -> Result<'a> {\n+                                substs: subst::Substs, call_info: NodeInfo) -> Result<'a> {\n \n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n@@ -425,6 +425,17 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i64\", ret_ty,\n                                     *llargs.get(0), *llargs.get(1)),\n \n+        (_, \"return_address\") => {\n+            if !fcx.caller_expects_out_pointer {\n+                tcx.sess.span_err(call_info.span,\n+                                  \"invalid use of `return_address` intrinsic: function \\\n+                                   does not use out pointer\");\n+                C_null(Type::i8p(ccx))\n+            } else {\n+                PointerCast(bcx, llvm::get_param(fcx.llfn, 0), Type::i8p(ccx))\n+            }\n+        }\n+\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n         (_, name) if name.starts_with(\"atomic_\") => {"}, {"sha": "e49d483e8d93d29b5608ae9f9369e25ce45b07b0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                                                     sym.as_slice());\n                 let arena = TypedArena::new();\n                 let empty_param_substs = param_substs::empty();\n-                let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,\n+                let fcx = new_fn_ctxt(ccx, llfdecl, ast::DUMMY_NODE_ID, false,\n                                       ty::mk_u64(), &empty_param_substs,\n                                       None, &arena, TranslateItems);\n                 let bcx = init_function(&fcx, false, ty::mk_u64());\n@@ -321,7 +321,9 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let arg = get_param(llfdecl, fcx.arg_pos(0u) as c_uint);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n-                Store(bcx, ret, fcx.llretptr.get().unwrap());\n+                assert!(!fcx.needs_ret_allocas);\n+                let ret_slot = fcx.get_ret_slot(bcx, ty::mk_u64(), \"ret_slot\");\n+                Store(bcx, ret, ret_slot);\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n                     None => {}"}, {"sha": "aa38ff68f24e6c901ed3510b14dbf1a7a7fe824f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -4986,6 +4986,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (0, vec!(ty::mk_u64(), ty::mk_u64()),\n                 ty::mk_tup(tcx, vec!(ty::mk_u64(), ty::mk_bool()))),\n \n+            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, ty::mk_u8())),\n+\n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,\n                     \"unrecognized intrinsic function: `{}`\", *other);"}, {"sha": "51b8985e655a577ba8bbccb760898651b17716a2", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -2800,7 +2800,6 @@ mod tests {\n         }\n     }\n     #[test]\n-    #[ignore] // FIXME(#15763)\n     fn test_decode_errors_struct() {\n         check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\","}, {"sha": "9c1db4057c6cd47043727a699b2a7736e3caa9fd", "filename": "src/test/compile-fail/intrinsic-return-address.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn return_address() -> *const u8;\n+}\n+\n+unsafe fn f() {\n+    let _ = return_address();\n+    //~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n+}\n+\n+unsafe fn g() -> int {\n+    let _ = return_address();\n+    //~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n+    0\n+}\n+\n+fn main() {}\n+\n+"}, {"sha": "91af669340d61a95448406e5bb6021d24264f45d", "filename": "src/test/run-pass/intrinsic-return-address.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Ftest%2Frun-pass%2Fintrinsic-return-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Ftest%2Frun-pass%2Fintrinsic-return-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-return-address.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(intrinsics)]\n+\n+use std::ptr;\n+\n+struct Point {\n+    x: f32,\n+    y: f32,\n+    z: f32,\n+}\n+\n+extern \"rust-intrinsic\" {\n+    fn return_address() -> *const u8;\n+}\n+\n+fn f(result: &mut uint) -> Point {\n+    unsafe {\n+        *result = return_address() as uint;\n+        Point {\n+            x: 1.0,\n+            y: 2.0,\n+            z: 3.0,\n+        }\n+    }\n+\n+}\n+\n+fn main() {\n+    let mut intrinsic_reported_address = 0;\n+    let pt = f(&mut intrinsic_reported_address);\n+    let actual_address = &pt as *const Point as uint;\n+    assert_eq!(intrinsic_reported_address, actual_address);\n+}\n+"}, {"sha": "6e3599bda149acf5c9621061bc05c960842424bd", "filename": "src/test/run-pass/issue-15763.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e2273d945640442224a09e532865e4a58257a851/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2273d945640442224a09e532865e4a58257a851/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15763.rs?ref=e2273d945640442224a09e532865e4a58257a851", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#[deriving(PartialEq, Show)]\n+struct Bar {\n+    x: int\n+}\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        assert_eq!(self.x, 22);\n+    }\n+}\n+\n+#[deriving(PartialEq, Show)]\n+struct Foo {\n+    x: Bar,\n+    a: int\n+}\n+\n+fn foo() -> Result<Foo, int> {\n+    return Ok(Foo {\n+        x: Bar { x: 22 },\n+        a: return Err(32)\n+    });\n+}\n+\n+fn baz() -> Result<Foo, int> {\n+    Ok(Foo {\n+        x: Bar { x: 22 },\n+        a: return Err(32)\n+    })\n+}\n+\n+// explicit immediate return\n+fn aa() -> int {\n+    return 3;\n+}\n+\n+// implicit immediate return\n+fn bb() -> int {\n+    3\n+}\n+\n+// implicit outptr return\n+fn cc() -> Result<int, int> {\n+    Ok(3)\n+}\n+\n+// explicit outptr return\n+fn dd() -> Result<int, int> {\n+    return Ok(3);\n+}\n+\n+trait A {\n+    fn aaa(self) -> int {\n+        3\n+    }\n+    fn bbb(self) -> int {\n+        return 3;\n+    }\n+    fn ccc(self) -> Result<int, int> {\n+        Ok(3)\n+    }\n+    fn ddd(self) -> Result<int, int> {\n+        return Ok(3);\n+    }\n+}\n+\n+impl A for int {}\n+\n+fn main() {\n+    assert_eq!(foo(), Err(32));\n+    assert_eq!(baz(), Err(32));\n+\n+    assert_eq!(aa(), 3);\n+    assert_eq!(bb(), 3);\n+    assert_eq!(cc().unwrap(), 3);\n+    assert_eq!(dd().unwrap(), 3);\n+\n+    let i = box 32i as Box<A>;\n+    assert_eq!(i.aaa(), 3);\n+    let i = box 32i as Box<A>;\n+    assert_eq!(i.bbb(), 3);\n+    let i = box 32i as Box<A>;\n+    assert_eq!(i.ccc().unwrap(), 3);\n+    let i = box 32i as Box<A>;\n+    assert_eq!(i.ddd().unwrap(), 3);\n+}"}]}