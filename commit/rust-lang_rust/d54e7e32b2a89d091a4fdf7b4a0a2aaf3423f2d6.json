{"sha": "d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NGU3ZTMyYjJhODlkMDkxYTRmZGY3YjRhMGEyYWFmMzQyM2YyZDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-01T10:11:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-12T04:38:38Z"}, "message": "introduce `ConstraintGraph`, stop mutating constraints in place\n\nEncapsulate the dependencies more cleanly.", "tree": {"sha": "15ee5ac809db521cc7f432a99c6627ba3e6ba4b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ee5ac809db521cc7f432a99c6627ba3e6ba4b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "html_url": "https://github.com/rust-lang/rust/commit/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fa24bbc5729f356ea372b196f019b7568e17158", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa24bbc5729f356ea372b196f019b7568e17158", "html_url": "https://github.com/rust-lang/rust/commit/8fa24bbc5729f356ea372b196f019b7568e17158"}], "stats": {"total": 170, "additions": 76, "deletions": 94}, "files": [{"sha": "eab1de073116f5395ee76217dbdd6877857f7265", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "patch": "@@ -32,39 +32,6 @@ impl ConstraintSet {\n         }\n         self.constraints.push(constraint);\n     }\n-\n-    /// Once all constraints have been added, `link()` is used to thread together the constraints\n-    /// based on which would be affected when a particular region changes. See the next field of\n-    /// `OutlivesContraint` for more details.\n-    /// link returns a map that is needed later by `each_affected_by_dirty`.\n-    pub fn link(&mut self, len: usize) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n-        let mut map = IndexVec::from_elem_n(None, len);\n-\n-        for (idx, constraint) in self.constraints.iter_enumerated_mut().rev() {\n-            let mut head = &mut map[constraint.sub];\n-            debug_assert!(constraint.next.is_none());\n-            constraint.next = *head;\n-            *head = Some(idx);\n-        }\n-\n-        map\n-    }\n-\n-    /// When a region R1 changes, we need to reprocess all constraints R2: R1 to take into account\n-    /// any new elements that R1 now has. This method will quickly enumerate all such constraints\n-    /// (that is, constraints where R1 is in the \"subregion\" position).\n-    /// To use it, invoke with `map[R1]` where map is the map returned by `link`;\n-    /// the callback op will be invoked for each affected constraint.\n-    pub fn each_affected_by_dirty(\n-        &self,\n-        mut opt_dep_idx: Option<ConstraintIndex>,\n-        mut op: impl FnMut(ConstraintIndex),\n-    ) {\n-        while let Some(dep_idx) = opt_dep_idx {\n-            op(dep_idx);\n-            opt_dep_idx = self.constraints[dep_idx].next;\n-        }\n-    }\n }\n \n impl Deref for ConstraintSet {\n@@ -85,16 +52,6 @@ pub struct OutlivesConstraint {\n     /// Region that must be outlived.\n     pub sub: RegionVid,\n \n-    /// Later on, we thread the constraints onto a linked list\n-    /// grouped by their `sub` field. So if you had:\n-    ///\n-    /// Index | Constraint | Next Field\n-    /// ----- | ---------- | ----------\n-    /// 0     | `'a: 'b`   | Some(2)\n-    /// 1     | `'b: 'c`   | None\n-    /// 2     | `'c: 'b`   | None\n-    pub next: Option<ConstraintIndex>,\n-\n     /// Where did this constraint arise?\n     pub locations: Locations,\n }\n@@ -110,3 +67,46 @@ impl fmt::Debug for OutlivesConstraint {\n }\n \n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n+\n+crate struct ConstraintGraph {\n+    first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n+    next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n+}\n+\n+impl ConstraintGraph {\n+    /// Constraint a graph where each region constraint `R1: R2` is\n+    /// treated as an edge `R2 -> R1`. This is useful for cheaply\n+    /// finding dirty constraints.\n+    crate fn new(set: &ConstraintSet, num_region_vars: usize) -> Self {\n+        let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n+        let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n+\n+        for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n+            let mut head = &mut first_constraints[constraint.sub];\n+            let mut next = &mut next_constraints[idx];\n+            debug_assert!(next.is_none());\n+            *next = *head;\n+            *head = Some(idx);\n+        }\n+\n+        ConstraintGraph { first_constraints, next_constraints }\n+    }\n+\n+    /// Invokes `op` with the index of any constraints of the form\n+    /// `region_sup: region_sub`.  These are the constraints that must\n+    /// be reprocessed when the value of `R1` changes. If you think of\n+    /// each constraint `R1: R2` as an edge `R2 -> R1`, then this\n+    /// gives the set of successors to R2.\n+    crate fn for_each_dependent(\n+        &self,\n+        region_sub: RegionVid,\n+        mut op: impl FnMut(ConstraintIndex),\n+    ) {\n+        let mut p = self.first_constraints[region_sub];\n+        while let Some(dep_idx) = p {\n+            op(dep_idx);\n+            p = self.next_constraints[dep_idx];\n+        }\n+    }\n+}\n+"}, {"sha": "3c73203706dcb633f019328719ea51c2be7a647e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "patch": "@@ -83,7 +83,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 sup,\n                 sub,\n                 locations,\n-                next: _,\n             } = constraint;\n             with_msg(&format!(\n                 \"{:?}: {:?} due to {:?}\","}, {"sha": "5405ad91296a2cfdec7145742be9d4ac11430dc0", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "patch": "@@ -89,8 +89,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         stack: &mut Vec<ConstraintIndex>,\n         results: &mut Vec<Vec<ConstraintIndex>>,\n     ) {\n-        let dependency_map = self.dependency_map.as_ref().unwrap();\n-\n         // Check if we already visited this region.\n         if !visited.insert(current_region) {\n             return;\n@@ -105,20 +103,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return;\n         }\n \n-        self.constraints\n-            .each_affected_by_dirty(dependency_map[current_region], |constraint| {\n-                assert_eq!(self.constraints[constraint].sub, current_region);\n-                stack.push(constraint);\n-                self.find_constraint_paths_between_regions_helper(\n-                    from_region,\n-                    self.constraints[constraint].sup,\n-                    target_test,\n-                    visited,\n-                    stack,\n-                    results,\n-                );\n-                stack.pop();\n-            });\n+        self.constraint_graph.for_each_dependent(current_region, |constraint| {\n+            assert_eq!(self.constraints[constraint].sub, current_region);\n+            stack.push(constraint);\n+            self.find_constraint_paths_between_regions_helper(\n+                from_region,\n+                self.constraints[constraint].sup,\n+                target_test,\n+                visited,\n+                stack,\n+                results,\n+            );\n+            stack.pop();\n+        });\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint"}, {"sha": "f0ada4a85a146b03ca31dea4ecd776c90a85f05e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n-use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraint_set::{\n+    ConstraintIndex, ConstraintGraph, ConstraintSet, OutlivesConstraint\n+};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -57,16 +59,12 @@ pub struct RegionInferenceContext<'tcx> {\n     /// until `solve` is invoked.\n     inferred_values: Option<RegionValues>,\n \n-    /// For each variable, stores the index of the first constraint\n-    /// where that variable appears on the RHS. This is the start of a\n-    /// 'linked list' threaded by the `next` field in `Constraint`.\n-    ///\n-    /// This map is build when values are inferred.\n-    dependency_map: Option<IndexVec<RegionVid, Option<ConstraintIndex>>>,\n-\n     /// The constraints we have accumulated and used during solving.\n     constraints: ConstraintSet,\n \n+    /// The constraint-set, but organized by regions.\n+    constraint_graph: ConstraintGraph,\n+\n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n \n@@ -203,27 +201,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n-        // The `next` field should not yet have been initialized:\n-        debug_assert!(outlives_constraints.iter().all(|c| c.next.is_none()));\n-\n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n         let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n-        let definitions = var_infos\n+        let definitions: IndexVec<_, _> = var_infos\n             .into_iter()\n             .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n+        let constraint_graph = ConstraintGraph::new(&outlives_constraints, definitions.len());\n+\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n-            dependency_map: None,\n             constraints: outlives_constraints,\n+            constraint_graph,\n             type_tests,\n             universal_regions,\n         };\n@@ -392,7 +389,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        self.dependency_map = Some(self.build_dependency_map());\n+        assert!(self.inferred_values.is_none());\n         let inferred_values = self.compute_region_values(mir);\n         self.inferred_values = Some(inferred_values);\n     }\n@@ -409,8 +406,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraints we have accumulated.\n         let mut inferred_values = self.liveness_constraints.clone();\n \n-        let dependency_map = self.dependency_map.as_ref().unwrap();\n-\n         // Constraints that may need to be repropagated (initially all):\n         let mut dirty_list: Vec<_> = self.constraints.indices().collect();\n \n@@ -428,14 +423,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                 debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n-                self.constraints.each_affected_by_dirty(\n-                    dependency_map[constraint.sup],\n-                    |dep_idx| {\n-                        if clean_bit_vec.remove(dep_idx.index()) {\n-                            dirty_list.push(dep_idx);\n-                        }\n-                    },\n-                );\n+                // The region of `constraint.sup` changed, so find all\n+                // constraints of the form `R: constriant.sup` and\n+                // enqueue them as dirty.  We will have to reprocess\n+                // them.\n+                self.constraint_graph.for_each_dependent(constraint.sup, |dep_idx| {\n+                    if clean_bit_vec.remove(dep_idx.index()) {\n+                        dirty_list.push(dep_idx);\n+                    }\n+                });\n             }\n \n             debug!(\"\\n\");\n@@ -444,14 +440,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         inferred_values\n     }\n \n-    /// Builds up a map from each region variable X to a vector with the\n-    /// indices of constraints that need to be re-evaluated when X changes.\n-    /// These are constraints like Y: X @ P -- so if X changed, we may\n-    /// need to grow Y.\n-    fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n-        self.constraints.link(self.definitions.len())\n-    }\n-\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:"}, {"sha": "a5a159fbb1c3d434ba720f55572905522cf1e1d5", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "patch": "@@ -186,7 +186,6 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             locations: self.locations,\n             sub,\n             sup,\n-            next: None,\n         });\n     }\n "}, {"sha": "97a74e0d3365bbc701e823985ce4ae2980f7500c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d54e7e32b2a89d091a4fdf7b4a0a2aaf3423f2d6", "patch": "@@ -1537,7 +1537,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                     sup: ref_region.to_region_vid(),\n                                     sub: borrow_region.to_region_vid(),\n                                     locations: location.boring(),\n-                                    next: None,\n                                 });\n \n                             if let Some(all_facts) = all_facts {"}]}