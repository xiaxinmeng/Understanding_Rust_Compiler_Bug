{"sha": "90c2d641ebacdb286b0813715ba17983a811a3b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYzJkNjQxZWJhY2RiMjg2YjA4MTM3MTViYTE3OTgzYTgxMWEzYjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-26T08:05:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-26T08:05:40Z"}, "message": "Rollup merge of #59232 - saleemjaffer:mir_place_refactor, r=oli-obk\n\nMerge `Promoted` and `Static` in `mir::Place`\n\nfixes #53848", "tree": {"sha": "00cb270d6a611520704b6874b76cec0c69a5e5e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00cb270d6a611520704b6874b76cec0c69a5e5e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c2d641ebacdb286b0813715ba17983a811a3b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcmd1VCRBK7hj4Ov3rIwAAdHIIAK/i5R99+my1Pyb1oFmGvjC1\nVTrS0LKGF0YDAsg1pwQ7drBtKi1E2AjRVmEkBufm9RQ5PrYKS43slQXJvSN6bbmm\nlDM3RjFbU2db88lWXQDuQGQ7urNa1q8tjtAU5fc7Q+De17OnhaoBmfx04vn9KWX7\n1xM9+a2PnFk3aWLQMANYgmPoFPrW3jJJ/ebqXmDFEyFcRTTOHBYfPc6cRO0/301b\ntMTLuC30TrNnaoaTzP5+CiC64lXxrF/P6VVqZXQ8J933NExZ4aZmgOzA17fQSXt4\nIDVt4Ul33ZiqT4z9i1sUFxZ1qY06lg31ycGwFUdKL8O0lxy4q7EPpl3duLFPUEI=\n=iFK5\n-----END PGP SIGNATURE-----\n", "payload": "tree 00cb270d6a611520704b6874b76cec0c69a5e5e9\nparent b316514dbd716d7885cb5d5f4be43e3b63441b49\nparent fb93f10dac46376b706643a74f3ebbabaf46c48f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553587540 +0100\ncommitter GitHub <noreply@github.com> 1553587540 +0100\n\nRollup merge of #59232 - saleemjaffer:mir_place_refactor, r=oli-obk\n\nMerge `Promoted` and `Static` in `mir::Place`\n\nfixes #53848\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c2d641ebacdb286b0813715ba17983a811a3b3", "html_url": "https://github.com/rust-lang/rust/commit/90c2d641ebacdb286b0813715ba17983a811a3b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c2d641ebacdb286b0813715ba17983a811a3b3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b316514dbd716d7885cb5d5f4be43e3b63441b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/b316514dbd716d7885cb5d5f4be43e3b63441b49", "html_url": "https://github.com/rust-lang/rust/commit/b316514dbd716d7885cb5d5f4be43e3b63441b49"}, {"sha": "fb93f10dac46376b706643a74f3ebbabaf46c48f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb93f10dac46376b706643a74f3ebbabaf46c48f", "html_url": "https://github.com/rust-lang/rust/commit/fb93f10dac46376b706643a74f3ebbabaf46c48f"}], "stats": {"total": 443, "additions": 233, "deletions": 210}, "files": [{"sha": "d35ee1e57d5ce35d72f23ea3af7830cf37a62525", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -1913,22 +1913,24 @@ pub enum PlaceBase<'tcx> {\n \n     /// static or static mut variable\n     Static(Box<Static<'tcx>>),\n-\n-    /// Constant code promoted to an injected static\n-    Promoted(Box<(Promoted, Ty<'tcx>)>),\n }\n \n-/// The `DefId` of a static, along with its normalized type (which is\n-/// stored to avoid requiring normalization when reading MIR).\n+/// We store the normalized type to avoid requiring normalization when reading MIR\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n-    pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n+    pub kind: StaticKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable)]\n+pub enum StaticKind {\n+    Promoted(Promoted),\n+    Static(DefId),\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n-    def_id,\n-    ty\n+    ty,\n+    kind\n });\n \n /// The `Projection` data structure defines things of the form `B.x`\n@@ -2048,7 +2050,7 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place::Base(PlaceBase::Local(local)) => Some(*local),\n             Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n-            Place::Base(PlaceBase::Promoted(..)) | Place::Base(PlaceBase::Static(..)) => None,\n+            Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n }\n@@ -2059,18 +2061,24 @@ impl<'tcx> Debug for Place<'tcx> {\n \n         match *self {\n             Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n-            Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n-                fmt,\n-                \"({}: {:?})\",\n-                ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                ty\n-            ),\n-            Base(PlaceBase::Promoted(ref promoted)) => write!(\n-                fmt,\n-                \"({:?}: {:?})\",\n-                promoted.0,\n-                promoted.1\n-            ),\n+            Base(PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) })) => {\n+                write!(\n+                    fmt,\n+                    \"({}: {:?})\",\n+                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n+                    ty\n+                )\n+            },\n+            Base(PlaceBase::Static(\n+                box self::Static { ty, kind: StaticKind::Promoted(promoted) })\n+            ) => {\n+                write!(\n+                    fmt,\n+                    \"({:?}: {:?})\",\n+                    promoted,\n+                    ty\n+                )\n+            },\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n                     write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)"}, {"sha": "ac42eacacd7bfff0adbdd96c5f1f4f5446727de8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -160,7 +160,6 @@ impl<'tcx> Place<'tcx> {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n                 PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n-            Place::Base(PlaceBase::Promoted(ref data)) => PlaceTy::Ty { ty: data.1 },\n             Place::Base(PlaceBase::Static(ref data)) =>\n                 PlaceTy::Ty { ty: data.ty },\n             Place::Projection(ref proj) =>"}, {"sha": "54e5bfc4397e8be33144ebceb7d3235c55b30ae1", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -156,13 +156,6 @@ macro_rules! make_mir_visitor {\n                 self.super_place(place, context, location);\n             }\n \n-            fn visit_static(&mut self,\n-                            static_: & $($mutability)? Static<'tcx>,\n-                            context: PlaceContext<'tcx>,\n-                            location: Location) {\n-                self.super_static(static_, context, location);\n-            }\n-\n             fn visit_projection(&mut self,\n                                 place: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n@@ -736,27 +729,18 @@ macro_rules! make_mir_visitor {\n                     Place::Base(PlaceBase::Local(local)) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Base(PlaceBase::Static(static_)) => {\n-                        self.visit_static(static_, context, location);\n+                    Place::Base(PlaceBase::Static(box Static { kind, ty })) => {\n+                        if let StaticKind::Static(def_id) = kind {\n+                            self.visit_def_id(& $($mutability)? *def_id, location)\n+                        }\n+                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n-                    Place::Base(PlaceBase::Promoted(promoted)) => {\n-                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n-                    },\n                     Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n-            fn super_static(&mut self,\n-                            static_: & $($mutability)? Static<'tcx>,\n-                            _context: PlaceContext<'tcx>,\n-                            location: Location) {\n-                let Static { def_id, ty } = static_;\n-                self.visit_def_id(def_id, location);\n-                self.visit_ty(ty, TyContext::Location(location));\n-            }\n-\n             fn super_projection(&mut self,\n                                 proj: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,"}, {"sha": "4774f8fe5a380b97bc4aad9a406e50bd8d27d8bf", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -1,7 +1,7 @@\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n-use rustc::mir;\n+use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::EvalErrorKind;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n@@ -621,15 +621,23 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n                         mir::Operand::Copy(\n-                            mir::Place::Base(mir::PlaceBase::Promoted(box(index, ty)))\n+                            Place::Base(\n+                                PlaceBase::Static(\n+                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n+                                )\n+                            )\n                         ) |\n                         mir::Operand::Move(\n-                            mir::Place::Base(mir::PlaceBase::Promoted(box(index, ty)))\n+                            Place::Base(\n+                                PlaceBase::Static(\n+                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n+                                )\n+                            )\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n                             let cid = mir::interpret::GlobalId {\n                                 instance: self.instance,\n-                                promoted: Some(index),\n+                                promoted: Some(promoted),\n                             };\n                             let c = bx.tcx().const_eval(param_env.and(cid));\n                             let (llval, ty) = self.simd_shuffle_indices("}, {"sha": "7cafa0088a01270961b763c7827f0822fb7f8f5f", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -408,11 +408,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let result = match *place {\n             mir::Place::Base(mir::PlaceBase::Local(_)) => bug!(), // handled above\n-            mir::Place::Base(mir::PlaceBase::Promoted(box (index, ty))) => {\n+            mir::Place::Base(\n+                mir::PlaceBase::Static(\n+                    box mir::Static { ty, kind: mir::StaticKind::Promoted(promoted) }\n+                )\n+            ) => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let cid = mir::interpret::GlobalId {\n                     instance: self.instance,\n-                    promoted: Some(index),\n+                    promoted: Some(promoted),\n                 };\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n@@ -435,7 +439,11 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n             }\n-            mir::Place::Base(mir::PlaceBase::Static(box mir::Static { def_id, ty })) => {\n+            mir::Place::Base(\n+                mir::PlaceBase::Static(\n+                    box mir::Static { ty, kind: mir::StaticKind::Static(def_id) }\n+                )\n+            ) => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));"}, {"sha": "fac75989aa59034d7f0e15fc4eea912a2f15222a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -10,7 +10,7 @@ use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Constant,\n     ConstraintCategory, Field, Local, LocalDecl, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceProjection, ProjectionElem, Rvalue, Statement, StatementKind,\n-    TerminatorKind, VarBindingForm,\n+    Static, StaticKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n use rustc::ty::print::Print;\n@@ -1598,14 +1598,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match *place {\n-            Place::Base(PlaceBase::Promoted(_)) => {\n-                buf.push_str(\"promoted\");\n-            }\n             Place::Base(PlaceBase::Local(local)) => {\n                 self.append_local_to_string(local, buf)?;\n             }\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                buf.push_str(\"promoted\");\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                buf.push_str(&self.infcx.tcx.item_name(def_id).to_string());\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1744,8 +1744,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field)\n             }\n-            Place::Base(PlaceBase::Promoted(ref prom)) =>\n-                self.describe_field_from_ty(&prom.1, field),\n             Place::Base(PlaceBase::Static(ref static_)) =>\n                 self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n@@ -1809,8 +1807,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Checks if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n-        if let Place::Base(PlaceBase::Static(statik)) = place {\n-            let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n+        if let Place::Base(\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n+        ) = place {\n+            let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n             debug!(\n@@ -1828,8 +1828,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match place {\n             Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Static(_)) |\n-            Place::Base(PlaceBase::Promoted(_)) => {\n+            Place::Base(PlaceBase::Static(_)) => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n             Place::Projection(box PlaceProjection { base, elem }) => {"}, {"sha": "5c159cda141a517923cde5bf5af04d82ed740021", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -8,7 +8,9 @@ use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase};\n+use rustc::mir::{\n+    ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase, Static, StaticKind\n+};\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n@@ -1226,8 +1228,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 Operand::Move(Place::Base(PlaceBase::Static(..)))\n                                 | Operand::Copy(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Move(Place::Base(PlaceBase::Promoted(..)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Promoted(..)))\n                                 | Operand::Constant(..) => {}\n                             }\n                         }\n@@ -1310,12 +1310,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n-            Place::Base(PlaceBase::Promoted(_)) => (true, false),\n-            Place::Base(PlaceBase::Static(_)) => {\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                (true, false)\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(_), .. })) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n-                let is_thread_local = self.is_place_thread_local(&root_place);\n-                (true, is_thread_local)\n+                (true, self.is_place_thread_local(&root_place))\n             }\n             Place::Base(PlaceBase::Local(_)) => {\n                 // Locals are always dropped at function exit, and if they\n@@ -1578,7 +1579,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *last_prefix {\n             Place::Base(PlaceBase::Local(_)) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n-            Place::Base(PlaceBase::Promoted(_)) |\n             Place::Base(PlaceBase::Static(_)) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n@@ -1605,7 +1605,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut place = place;\n         loop {\n             match *place {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n@@ -1953,10 +1952,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n-            RootPlace {\n-                place: Place::Base(PlaceBase::Promoted(..)),\n-                is_local_mutation_allowed: _,\n-            } => {}\n             RootPlace {\n                 place: Place::Base(PlaceBase::Static(..)),\n                 is_local_mutation_allowed: _,\n@@ -1994,12 +1989,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            Place::Base(PlaceBase::Promoted(_)) => Ok(RootPlace {\n-                place,\n-                is_local_mutation_allowed,\n-            }),\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+            Place::Base(PlaceBase::Static(box Static{kind: StaticKind::Promoted(_), ..})) =>\n+                Ok(RootPlace {\n+                    place,\n+                    is_local_mutation_allowed,\n+                }),\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                if self.infcx.tcx.is_static(def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n                     Ok(RootPlace {"}, {"sha": "f351212e9d5876f990c4d2d1896c05faa3450534", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -1,7 +1,9 @@\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Mir};\n-use rustc::mir::{Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static};\n+use rustc::mir::{\n+    Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind,\n+};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::{self, Const, DefIdTree, TyS, TyKind, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -129,9 +131,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Place::Base(PlaceBase::Promoted(_)) => unreachable!(),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) =>\n+                unreachable!(),\n \n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })) => {\n                 if let Place::Base(PlaceBase::Static(_)) = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();"}, {"sha": "a3561515aaa31f3e7ebaae3092b748f7bb5c0528", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -449,53 +449,49 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         context: PlaceContext<'_>,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n-        let place_ty = match *place {\n+        let place_ty = match place {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n-                ty: self.mir.local_decls[index].ty,\n+                ty: self.mir.local_decls[*index].ty,\n             },\n-            Place::Base(PlaceBase::Promoted(box (index, sty))) => {\n+            Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n-\n-                if !self.errors_reported {\n-                    let promoted_mir = &self.mir.promoted[index];\n-                    self.sanitize_promoted(promoted_mir, location);\n-\n-                    let promoted_ty = promoted_mir.return_ty();\n-\n-                    if let Err(terr) = self.cx.eq_types(\n-                        sty,\n-                        promoted_ty,\n-                        location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n+                let check_err =\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                     place: &Place<'tcx>,\n+                     ty,\n+                     sty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            sty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                            verifier,\n                             place,\n                             \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            promoted_ty,\n+                            ty,\n                             sty,\n                             terr\n                         );\n+                        };\n                     };\n-                }\n-                PlaceTy::Ty { ty: sty }\n-            }\n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: sty })) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) =\n-                    self.cx\n-                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n-                {\n-                    span_mirbug!(\n-                        self,\n-                        place,\n-                        \"bad static type ({:?}: {:?}): {:?}\",\n-                        ty,\n-                        sty,\n-                        terr\n-                    );\n+                match kind {\n+                    StaticKind::Promoted(promoted) => {\n+                        if !self.errors_reported {\n+                            let promoted_mir = &self.mir.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_mir, location);\n+\n+                            let promoted_ty = promoted_mir.return_ty();\n+                            check_err(self, place, promoted_ty, sty);\n+                        }\n+                    }\n+                    StaticKind::Static(def_id) => {\n+                        let ty = self.tcx().type_of(*def_id);\n+                        let ty = self.cx.normalize(ty, location);\n+\n+                        check_err(self, place, ty, sty);\n+                    }\n                 }\n                 PlaceTy::Ty { ty: sty }\n             }"}, {"sha": "42eb502b9076d6636d42d3c7d61904e6e13f1e92", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -138,7 +138,6 @@ pub(super) fn is_active<'tcx>(\n /// This is called for all Yield statements on movable generators\n pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n     match place {\n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Static(..)) => false,\n         Place::Base(PlaceBase::Local(..)) => true,\n         Place::Projection(box proj) => {"}, {"sha": "6bc56ab721f985711792ff270cd5bb920c5a8657", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability};\n+use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability, Static, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -30,8 +30,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n         match self {\n-            Place::Base(PlaceBase::Promoted(_)) => false,\n-\n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n             // * The variable being dropped while still borrowed (e.g., because the fn returns\n@@ -51,8 +49,10 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     }\n                 }\n             }\n-            Place::Base(PlaceBase::Static(static_)) => {\n-                tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n+                false,\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                tcx.is_static(*def_id) == Some(hir::Mutability::MutMutable)\n             }\n             Place::Projection(proj) => match proj.elem {\n                 ProjectionElem::Field(..)\n@@ -88,7 +88,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         loop {\n             match p {\n                 Place::Projection(pi) => p = &pi.base,\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Static(_)) => return None,\n                 Place::Base(PlaceBase::Local(l)) => return Some(*l),\n             }"}, {"sha": "52119d6b19bc06d5d4dc48cd8f1cf814de9b2548", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem};\n+use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -338,7 +338,6 @@ fn unroll_place<'tcx, R>(\n             op,\n         ),\n \n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n             let list = PlaceComponents {\n                 component: place,\n@@ -371,41 +370,45 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Static(static1)), Place::Base(PlaceBase::Static(static2))) => {\n-            if static1.def_id != static2.def_id {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (Place::Base(PlaceBase::Promoted(p1)), Place::Base(PlaceBase::Promoted(p2))) => {\n-            if p1.0 == p2.0 {\n-                if let ty::Array(_, size) = p1.1.sty {\n-                    if size.unwrap_usize(tcx) == 0 {\n-                        // Ignore conflicts with promoted [T; 0].\n-                        debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n-                        return Overlap::Disjoint;\n+        (Place::Base(PlaceBase::Static(s1)), Place::Base(PlaceBase::Static(s2))) => {\n+            match (&s1.kind, &s2.kind) {\n+                (StaticKind::Static(def_id_1), StaticKind::Static(def_id_2)) => {\n+                    if def_id_1 != def_id_2 {\n+                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                        Overlap::Disjoint\n+                    } else if tcx.is_static(*def_id_1) == Some(hir::Mutability::MutMutable) {\n+                        // We ignore mutable statics - they can only be unsafe code.\n+                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                        Overlap::Disjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                        Overlap::EqualOrDisjoint\n                     }\n+                },\n+                (StaticKind::Promoted(promoted_1), StaticKind::Promoted(promoted_2)) => {\n+                    if promoted_1 == promoted_2 {\n+                        if let ty::Array(_, size) = s1.ty.sty {\n+                            if size.unwrap_usize(tcx) == 0 {\n+                                // Ignore conflicts with promoted [T; 0].\n+                                debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n+                                return Overlap::Disjoint;\n+                            }\n+                        }\n+                        // the same promoted - base case, equal\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        // different promoteds - base case, disjoint\n+                        debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n+                        Overlap::Disjoint\n+                    }\n+                },\n+                (_, _) => {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC-PROMOTED\");\n+                    Overlap::Disjoint\n                 }\n-                // the same promoted - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different promoteds - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n-                Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Promoted(_))) |\n-        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Local(_))) |\n-        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Static(_))) |\n-        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Promoted(_))) |\n         (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n         (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");"}, {"sha": "e70c9e81ebd16b8beff33970851e172eb2d2eaef", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -26,7 +26,6 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n             }\n \n             match *cursor {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) |\n                 Place::Base(PlaceBase::Static(_)) => return false,\n                 Place::Projection(ref proj) => {\n@@ -87,7 +86,6 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n         'cursor: loop {\n             let proj = match *cursor {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) | // search yielded this leaf\n                 Place::Base(PlaceBase::Static(_)) => {\n                     self.next = None;"}, {"sha": "199d03ac445ba51441bcd877e9d5b392a81a5ac0", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -126,8 +126,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(place)\n             }\n             ExprKind::StaticRef { id } => block.and(Place::Base(PlaceBase::Static(Box::new(Static {\n-                def_id: id,\n                 ty: expr.ty,\n+                kind: StaticKind::Static(id),\n             })))),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {"}, {"sha": "9d4600d13ac138a169daf3cb6476abdb2a797f50", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -93,7 +93,6 @@ struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n     match *place {\n         Place::Base(PlaceBase::Local(l)) => Some(l),\n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Static(..)) => None,\n         Place::Projection(ref proj) => {\n             match proj.elem {"}, {"sha": "71805fd02b85714e650ced49e7e590a363c91996", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -97,7 +97,6 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         debug!(\"lookup({:?})\", place);\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Place::Base(PlaceBase::Promoted(..)) |\n             Place::Base(PlaceBase::Static(..)) => {\n                 Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }"}, {"sha": "7eef68e5f807350dcd59491eaf314a03e7a822be", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -286,7 +286,6 @@ impl<'tcx> MovePathLookup<'tcx> {\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => LookupResult::Exact(self.locals[local]),\n-            Place::Base(PlaceBase::Promoted(_)) |\n             Place::Base(PlaceBase::Static(..)) => LookupResult::Parent(None),\n             Place::Projection(ref proj) => {\n                 match self.find(&proj.base) {"}, {"sha": "d2c279e48fe280669638c817e7fab7c76216157d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -582,19 +582,20 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n+        use rustc::mir::{Static, StaticKind};\n         Ok(match *mir_place {\n-            Base(PlaceBase::Promoted(ref promoted)) => {\n+            Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })) => {\n                 let instance = self.frame().instance;\n                 self.const_eval_raw(GlobalId {\n                     instance,\n-                    promoted: Some(promoted.0),\n+                    promoted: Some(promoted),\n                 })?\n             }\n \n-            Base(PlaceBase::Static(ref static_)) => {\n-                assert!(!static_.ty.needs_subst());\n-                let layout = self.layout_of(static_.ty)?;\n-                let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n+            Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), ty })) => {\n+                assert!(!ty.needs_subst());\n+                let layout = self.layout_of(ty)?;\n+                let instance = ty::Instance::mono(*self.tcx, def_id);\n                 let cid = GlobalId {\n                     instance,\n                     promoted: None"}, {"sha": "0ad6962cc4ac57b6fdd495650bcab44785395dac", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -184,7 +184,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::session::config::EntryFnType;\n-use rustc::mir::{self, Location, Promoted};\n+use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n use rustc::mir::interpret::{Scalar, GlobalId, AllocKind, ErrorHandled};\n@@ -650,19 +650,26 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_terminator_kind(block, kind, location);\n     }\n \n-    fn visit_static(&mut self,\n-                    static_: &mir::Static<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &mir::Place<'tcx>,\n                     context: mir::visit::PlaceContext<'tcx>,\n                     location: Location) {\n-        debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n+        match place {\n+            Place::Base(\n+                PlaceBase::Static(box Static{ kind:StaticKind::Static(def_id), .. })\n+            ) => {\n+                debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n \n-        let tcx = self.tcx;\n-        let instance = Instance::mono(tcx, static_.def_id);\n-        if should_monomorphize_locally(tcx, &instance) {\n-            self.output.push(MonoItem::Static(static_.def_id));\n+                let tcx = self.tcx;\n+                let instance = Instance::mono(tcx, *def_id);\n+                if should_monomorphize_locally(tcx, &instance) {\n+                    self.output.push(MonoItem::Static(*def_id));\n+                }\n+            }\n+            _ => {}\n         }\n \n-        self.super_static(static_, context, location);\n+        self.super_place(place, context, location);\n     }\n }\n "}, {"sha": "b13a5fd2fd1c0994fc1c603539504472b04b73f1", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -22,7 +22,6 @@ fn is_stable<'tcx>(\n     match *place {\n         // Locals and statics have stable addresses, for sure\n         Base(PlaceBase::Local { .. }) |\n-        Base(PlaceBase::Promoted { .. }) |\n         Base(PlaceBase::Static { .. }) =>\n             true,\n         // Recurse for projections"}, {"sha": "0e31515e4af9038fc7a6dbc75e28fccc3a112d2a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -300,10 +300,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             &Place::Base(PlaceBase::Local(..)) => {\n                 // locals are safe\n             }\n-            &Place::Base(PlaceBase::Promoted(_)) => {\n+            &Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => {\n                 bug!(\"unsafety checking should happen before promotion\")\n             }\n-            &Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n+            &Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })\n+            ) => {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\",\n                         \"mutable statics can be mutated by multiple threads: aliasing violations \\"}, {"sha": "102d03d7baac4bce4cefb00c44b7b13dd804b7fb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -4,7 +4,7 @@\n \n use rustc::hir::def::Def;\n use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local};\n-use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n+use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind, Static, StaticKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::interpret::{EvalErrorKind, Scalar, GlobalId, EvalResult};\n@@ -283,7 +283,9 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n-            Place::Base(PlaceBase::Promoted(ref promoted)) => {\n+            Place::Base(\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..})\n+            ) => {\n                 let generics = self.tcx.generics_of(self.source.def_id());\n                 if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n@@ -293,7 +295,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 let instance = Instance::new(self.source.def_id(), substs);\n                 let cid = GlobalId {\n                     instance,\n-                    promoted: Some(promoted.0),\n+                    promoted: Some(promoted),\n                 };\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now"}, {"sha": "1063381d6aa57899fac01a7c113399fa3953c9a7", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -692,12 +692,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place::Base(PlaceBase::Promoted(ref mut promoted)) => {\n-                if let Some(p) = self.promoted_map.get(promoted.0).cloned() {\n-                    promoted.0 = p;\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })\n+            ) => {\n+                if let Some(p) = self.promoted_map.get(*promoted).cloned() {\n+                    *promoted = p;\n                 }\n             },\n-            _ => self.super_place(place, _ctxt, _location),\n+            _ => self.super_place(place, _ctxt, _location)\n         }\n     }\n "}, {"sha": "73b88e9904bf23cbd1a202343eb0d0acf5406faa", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -292,9 +292,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let promoted_id = Promoted::new(self.source.promoted.len());\n             let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n-                promoted.local_decls[RETURN_PLACE] =\n-                    LocalDecl::new_return_place(ty, span);\n-                Place::Base(PlaceBase::Promoted(box (promoted_id, ty)))\n+                promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n+                Place::Base(\n+                    PlaceBase::Static(box Static{ kind: StaticKind::Promoted(promoted_id), ty })\n+                )\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {"}, {"sha": "0b9ad85e6b1c7c3585744e6e29ea0e84535926a0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -188,8 +188,11 @@ trait Qualif {\n     fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n-            Place::Base(PlaceBase::Promoted(_)) => bug!(\"qualifying already promoted MIR\"),\n-            Place::Base(PlaceBase::Static(ref static_)) => Self::in_static(cx, static_),\n+            Place::Base(PlaceBase::Static(box Static {kind: StaticKind::Promoted(_), .. })) =>\n+                bug!(\"qualifying already promoted MIR\"),\n+            Place::Base(PlaceBase::Static(ref static_)) => {\n+                Self::in_static(cx, static_)\n+            },\n             Place::Projection(ref proj) => Self::in_projection(cx, proj),\n         }\n     }\n@@ -370,11 +373,18 @@ impl Qualif for IsNotConst {\n     const IDX: usize = 2;\n \n     fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n-        // Only allow statics (not consts) to refer to other statics.\n-        let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n+        match static_.kind {\n+            StaticKind::Promoted(_) => unreachable!(),\n+            StaticKind::Static(def_id) => {\n+                // Only allow statics (not consts) to refer to other statics.\n+                let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n \n-        !allowed ||\n-            cx.tcx.get_attrs(static_.def_id).iter().any(|attr| attr.check_name(\"thread_local\"))\n+                !allowed ||\n+                    cx.tcx.get_attrs(def_id).iter().any(\n+                        |attr| attr.check_name(\"thread_local\"\n+                    ))\n+            }\n+        }\n     }\n \n     fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n@@ -768,9 +778,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     );\n                     dest = &proj.base;\n                 },\n-                Place::Base(PlaceBase::Promoted(..)) =>\n+                Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n                     bug!(\"promoteds don't exist yet during promotion\"),\n-                Place::Base(PlaceBase::Static(..)) => {\n+                Place::Base(PlaceBase::Static(box Static{ kind: _, .. })) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n                     self.visit_place(\n@@ -919,11 +929,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n         self.super_place(place, context, location);\n         match *place {\n-            Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Promoted(_)) => {}\n-            Place::Base(PlaceBase::Static(ref global)) => {\n+            Place::Base(PlaceBase::Local(_)) => {}\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                unreachable!()\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n                 if self.tcx\n-                       .get_attrs(global.def_id)\n+                       .get_attrs(def_id)\n                        .iter()\n                        .any(|attr| attr.check_name(\"thread_local\")) {\n                     if self.mode != Mode::Fn {"}, {"sha": "8742c5d759c8f33feace505aee318a8d5c336a78", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2d641ebacdb286b0813715ba17983a811a3b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=90c2d641ebacdb286b0813715ba17983a811a3b3", "patch": "@@ -257,8 +257,8 @@ fn check_place(\n     match place {\n         Place::Base(PlaceBase::Local(_)) => Ok(()),\n         // promoteds are always fine, they are essentially constants\n-        Place::Base(PlaceBase::Promoted(_)) => Ok(()),\n-        Place::Base(PlaceBase::Static(_)) =>\n+        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => Ok(()),\n+        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })) =>\n             Err((span, \"cannot access `static` items in const fn\".into())),\n         Place::Projection(proj) => {\n             match proj.elem {"}]}