{"sha": "aefc0a223a0022a156be07b18feb45cd07e517e0", "node_id": "C_kwDOAAsO6NoAKGFlZmMwYTIyM2EwMDIyYTE1NmJlMDdiMThmZWI0NWNkMDdlNTE3ZTA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-15T03:01:56Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-03-03T21:01:35Z"}, "message": "make generic projection types print correctly", "tree": {"sha": "487a3f9fdb3f76ee623c7aecb9b5caa69eca3ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/487a3f9fdb3f76ee623c7aecb9b5caa69eca3ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aefc0a223a0022a156be07b18feb45cd07e517e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aefc0a223a0022a156be07b18feb45cd07e517e0", "html_url": "https://github.com/rust-lang/rust/commit/aefc0a223a0022a156be07b18feb45cd07e517e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aefc0a223a0022a156be07b18feb45cd07e517e0/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "html_url": "https://github.com/rust-lang/rust/commit/ca6e06efba2201da6be9d48f3f922fbb4e90af5f"}], "stats": {"total": 148, "additions": 107, "deletions": 41}, "files": [{"sha": "62f3527525e0e49bf2bbf32841683d6e2bb2028a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -546,11 +546,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 WherePredicate::EqPredicate { lhs, rhs } => {\n                     match lhs {\n-                        Type::QPath { name: left_name, ref self_type, ref trait_, .. } => {\n+                        Type::QPath { ref assoc, ref self_type, ref trait_, .. } => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();\n \n-                            if self.is_fn_trait(trait_) && left_name == sym::Output {\n+                            if self.is_fn_trait(trait_) && assoc.name == sym::Output {\n                                 ty_to_fn\n                                     .entry(*ty.clone())\n                                     .and_modify(|e| {\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 // to 'T: Iterator<Item=u8>'\n                                 GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n                                     bindings.push(TypeBinding {\n-                                        name: left_name,\n+                                        assoc: *assoc.clone(),\n                                         kind: TypeBindingKind::Equality { term: rhs },\n                                     });\n                                 }"}, {"sha": "2a32432d4e607da637e305896382af648f7237ba", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -636,7 +636,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, name: _, .. },\n+            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, .. },\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "fb88b9f7895f9d02a8fd2b654a86b2ea501603da", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -388,14 +388,35 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n         let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n         let self_type = self.self_ty().clean(cx);\n         Type::QPath {\n-            name: cx.tcx.associated_item(self.item_def_id).name,\n+            assoc: Box::new(projection_to_path_segment(*self, cx)),\n             self_def_id: self_type.def_id(&cx.cache),\n             self_type: box self_type,\n             trait_,\n         }\n     }\n }\n \n+fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>) -> PathSegment {\n+    let item = cx.tcx.associated_item(ty.item_def_id);\n+    let generics = cx.tcx.generics_of(ty.item_def_id);\n+    PathSegment {\n+        name: item.name,\n+        args: GenericArgs::AngleBracketed {\n+            args: ty.substs[generics.parent_count..]\n+                .iter()\n+                .map(|ty| match ty.unpack() {\n+                    ty::subst::GenericArgKind::Lifetime(lt) => {\n+                        GenericArg::Lifetime(lt.clean(cx).unwrap())\n+                    }\n+                    ty::subst::GenericArgKind::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                    ty::subst::GenericArgKind::Const(c) => GenericArg::Const(Box::new(c.clean(cx))),\n+                })\n+                .collect(),\n+            bindings: Default::default(),\n+        },\n+    }\n+}\n+\n impl Clean<GenericParamDef> for ty::GenericParamDef {\n     fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n@@ -601,8 +622,8 @@ fn clean_ty_generics(\n         })\n         .collect::<Vec<GenericParamDef>>();\n \n-    // param index -> [(DefId of trait, associated type name, type)]\n-    let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'_>)>>::default();\n+    // param index -> [(DefId of trait, associated type name and generics, type)]\n+    let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, PathSegment, Ty<'_>)>>::default();\n \n     let where_predicates = preds\n         .predicates\n@@ -648,8 +669,9 @@ fn clean_ty_generics(\n \n                     let proj = projection\n                         .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().term));\n-                    if let Some(((_, trait_did, name), rhs)) =\n-                        proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n+                    if let Some(((_, trait_did, name), rhs)) = proj\n+                        .as_ref()\n+                        .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n                     {\n                         // FIXME(...): Remove this unwrap()\n                         impl_trait_proj.entry(param_idx).or_default().push((\n@@ -985,7 +1007,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(bounds, ref default) => {\n-                    let generics = self.generics.clean(cx);\n+                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n                     let default = default.map(|t| t.clean(cx));\n                     AssocTypeItem(Box::new(generics), bounds, default)\n@@ -1136,6 +1158,27 @@ impl Clean<Item> for ty::AssocItem {\n             ty::AssocKind::Type => {\n                 let my_name = self.name;\n \n+                fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {\n+                    match (&param.kind, arg) {\n+                        (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))\n+                            if *ty == param.name =>\n+                        {\n+                            true\n+                        }\n+                        (\n+                            GenericParamDefKind::Lifetime { .. },\n+                            GenericArg::Lifetime(Lifetime(lt)),\n+                        ) if *lt == param.name => true,\n+                        (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => {\n+                            match &c.kind {\n+                                ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n+                                _ => false,\n+                            }\n+                        }\n+                        _ => false,\n+                    }\n+                }\n+\n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = tcx.explicit_item_bounds(self.def_id);\n                     let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n@@ -1147,10 +1190,10 @@ impl Clean<Item> for ty::AssocItem {\n                         .where_predicates\n                         .drain_filter(|pred| match *pred {\n                             WherePredicate::BoundPredicate {\n-                                ty: QPath { name, ref self_type, ref trait_, .. },\n+                                ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n                                 ..\n                             } => {\n-                                if name != my_name {\n+                                if assoc.name != my_name {\n                                     return false;\n                                 }\n                                 if trait_.def_id() != self.container.id() {\n@@ -1267,7 +1310,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             };\n             register_res(cx, trait_.res);\n             Type::QPath {\n-                name: p.segments.last().expect(\"segments were empty\").ident.name,\n+                assoc: Box::new(p.segments.last().expect(\"segments were empty\").clean(cx)),\n                 self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n                 self_type: box qself.clean(cx),\n                 trait_,\n@@ -1284,7 +1327,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n             register_res(cx, trait_.res);\n             Type::QPath {\n-                name: segment.ident.name,\n+                assoc: Box::new(segment.clean(cx)),\n                 self_def_id: res.opt_def_id(),\n                 self_type: box qself.clean(cx),\n                 trait_,\n@@ -1557,7 +1600,16 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut bindings = vec![];\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n-                        name: cx.tcx.associated_item(pb.item_def_id()).name,\n+                        assoc: projection_to_path_segment(\n+                            pb.skip_binder()\n+                                .lift_to_tcx(cx.tcx)\n+                                .unwrap()\n+                                // HACK(compiler-errors): Doesn't actually matter what self\n+                                // type we put here, because we're only using the GAT's substs.\n+                                .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n+                                .projection_ty,\n+                            cx,\n+                        ),\n                         kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n                     });\n                 }\n@@ -1623,10 +1675,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                         == trait_ref.skip_binder()\n                                     {\n                                         Some(TypeBinding {\n-                                            name: cx\n-                                                .tcx\n-                                                .associated_item(proj.projection_ty.item_def_id)\n-                                                .name,\n+                                            assoc: projection_to_path_segment(\n+                                                proj.projection_ty,\n+                                                cx,\n+                                            ),\n                                             kind: TypeBindingKind::Equality {\n                                                 term: proj.term.clean(cx),\n                                             },\n@@ -2169,7 +2221,10 @@ fn clean_maybe_renamed_foreign_item(\n \n impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n-        TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }\n+        TypeBinding {\n+            assoc: PathSegment { name: self.ident.name, args: self.gen_args.clean(cx) },\n+            kind: self.kind.clean(cx),\n+        }\n     }\n }\n "}, {"sha": "dd8e1132572fc6a1c728fd430fafafe08a35d6b9", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -89,7 +89,7 @@ crate fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,\n-    name: Symbol,\n+    assoc: clean::PathSegment,\n     rhs: &clean::Term,\n ) -> bool {\n     !bounds.iter_mut().any(|b| {\n@@ -107,7 +107,7 @@ crate fn merge_bounds(\n         match last.args {\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {\n-                    name,\n+                    assoc: assoc.clone(),\n                     kind: clean::TypeBindingKind::Equality { term: rhs.clone() },\n                 });\n             }"}, {"sha": "78928fb4059bad35a3a9fa8a0f60cab4088e0e9c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -1397,7 +1397,7 @@ crate enum Type {\n \n     /// A qualified path to an associated item: `<Type as Trait>::Name`\n     QPath {\n-        name: Symbol,\n+        assoc: Box<PathSegment>,\n         self_type: Box<Type>,\n         /// FIXME: This is a hack that should be removed; see [this discussion][1].\n         ///\n@@ -1415,7 +1415,7 @@ crate enum Type {\n \n // `Type` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Type, 72);\n+rustc_data_structures::static_assert_size!(Type, 80);\n \n impl Type {\n     /// When comparing types for equality, it can help to ignore `&` wrapping.\n@@ -1505,12 +1505,12 @@ impl Type {\n         self.primitive_type().is_some()\n     }\n \n-    crate fn projection(&self) -> Option<(&Type, DefId, Symbol)> {\n-        let (self_, trait_, name) = match self {\n-            QPath { self_type, trait_, name, .. } => (self_type, trait_, name),\n+    crate fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n+        let (self_, trait_, assoc) = match self {\n+            QPath { self_type, trait_, assoc, .. } => (self_type, trait_, assoc),\n             _ => return None,\n         };\n-        Some((&self_, trait_.def_id(), *name))\n+        Some((&self_, trait_.def_id(), *assoc.clone()))\n     }\n \n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n@@ -2018,7 +2018,7 @@ crate enum GenericArg {\n // `GenericArg` can occur many times in a single `Path`, so make sure it\n // doesn't increase in size unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericArg, 80);\n+rustc_data_structures::static_assert_size!(GenericArg, 88);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum GenericArgs {\n@@ -2256,7 +2256,7 @@ crate struct ProcMacro {\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct TypeBinding {\n-    crate name: Symbol,\n+    crate assoc: PathSegment,\n     crate kind: TypeBindingKind,\n }\n "}, {"sha": "78965712dfa1843f98f5cc91534b4e04e7a3a92f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -961,7 +961,7 @@ fn fmt_type<'cx>(\n                 write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n-        clean::QPath { ref name, ref self_type, ref trait_, ref self_def_id } => {\n+        clean::QPath { ref assoc, ref self_type, ref trait_, ref self_def_id } => {\n             let should_show_cast = !trait_.segments.is_empty()\n                 && self_def_id\n                     .zip(Some(trait_.def_id()))\n@@ -994,14 +994,15 @@ fn fmt_type<'cx>(\n                     write!(\n                         f,\n                         \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n-                                    title=\\\"type {path}::{name}\\\">{name}</a>\",\n+                                    title=\\\"type {path}::{name}\\\">{name}</a>{args}\",\n                         url = url,\n                         shortty = ItemType::AssocType,\n-                        name = name,\n+                        name = assoc.name,\n                         path = join_with_double_colon(path),\n+                        args = assoc.args.print(cx),\n                     )?;\n                 }\n-                _ => write!(f, \"{}\", name)?,\n+                _ => write!(f, \"{}{:#}\", assoc.name, assoc.args.print(cx))?,\n             }\n             Ok(())\n         }\n@@ -1457,7 +1458,12 @@ impl clean::TypeBinding {\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n-            f.write_str(self.name.as_str())?;\n+            f.write_str(self.assoc.name.as_str())?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", self.assoc.args.print(cx))?;\n+            } else {\n+                write!(f, \"{}\", self.assoc.args.print(cx))?;\n+            }\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref term } => {\n                     if f.alternate() {"}, {"sha": "4358dc8980f2f6b322903d99a5bb7faf40f240b1", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -154,7 +154,11 @@ impl FromWithTcx<clean::Constant> for Constant {\n \n impl FromWithTcx<clean::TypeBinding> for TypeBinding {\n     fn from_tcx(binding: clean::TypeBinding, tcx: TyCtxt<'_>) -> Self {\n-        TypeBinding { name: binding.name.to_string(), binding: binding.kind.into_tcx(tcx) }\n+        TypeBinding {\n+            name: binding.assoc.name.to_string(),\n+            args: binding.assoc.args.into_tcx(tcx),\n+            binding: binding.kind.into_tcx(tcx),\n+        }\n     }\n }\n \n@@ -445,11 +449,12 @@ impl FromWithTcx<clean::Type> for Type {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n-            QPath { name, self_type, trait_, .. } => {\n+            QPath { assoc, self_type, trait_, .. } => {\n                 // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n                 let trait_ = clean::Type::Path { path: trait_ }.into_tcx(tcx);\n                 Type::QualifiedPath {\n-                    name: name.to_string(),\n+                    name: assoc.name.to_string(),\n+                    args: Box::new(assoc.args.clone().into_tcx(tcx)),\n                     self_type: Box::new((*self_type).into_tcx(tcx)),\n                     trait_: Box::new(trait_),\n                 }"}, {"sha": "40b0de448293ac5fada8edd894b74104a65cf5c9", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefc0a223a0022a156be07b18feb45cd07e517e0/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=aefc0a223a0022a156be07b18feb45cd07e517e0", "patch": "@@ -9,7 +9,7 @@ use std::path::PathBuf;\n use serde::{Deserialize, Serialize};\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 11;\n+pub const FORMAT_VERSION: u32 = 12;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -145,6 +145,7 @@ pub struct Constant {\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct TypeBinding {\n     pub name: String,\n+    pub args: GenericArgs,\n     pub binding: TypeBindingKind,\n }\n \n@@ -233,9 +234,7 @@ pub enum ItemEnum {\n         default: Option<String>,\n     },\n     AssocType {\n-        /// generics and `where` clause\n         generics: Generics,\n-        /// e.g. `: Sized`\n         bounds: Vec<GenericBound>,\n         /// e.g. `type X = usize;`\n         default: Option<Type>,\n@@ -435,6 +434,7 @@ pub enum Type {\n     /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n     QualifiedPath {\n         name: String,\n+        args: Box<GenericArgs>,\n         self_type: Box<Type>,\n         #[serde(rename = \"trait\")]\n         trait_: Box<Type>,"}]}