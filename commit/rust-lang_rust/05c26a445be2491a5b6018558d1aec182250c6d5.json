{"sha": "05c26a445be2491a5b6018558d1aec182250c6d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YzI2YTQ0NWJlMjQ5MWE1YjYwMTg1NThkMWFlYzE4MjI1MGM2ZDU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-07T03:59:08Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T12:55:45Z"}, "message": "refactor assoc op parsing", "tree": {"sha": "087d2af78cce216cd0b0af341a6eb0adc699bb82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/087d2af78cce216cd0b0af341a6eb0adc699bb82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05c26a445be2491a5b6018558d1aec182250c6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05c26a445be2491a5b6018558d1aec182250c6d5", "html_url": "https://github.com/rust-lang/rust/commit/05c26a445be2491a5b6018558d1aec182250c6d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05c26a445be2491a5b6018558d1aec182250c6d5/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e43a7ef1d440f3f70ca37e8abb32545366b0009f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e43a7ef1d440f3f70ca37e8abb32545366b0009f", "html_url": "https://github.com/rust-lang/rust/commit/e43a7ef1d440f3f70ca37e8abb32545366b0009f"}], "stats": {"total": 51, "additions": 31, "deletions": 20}, "files": [{"sha": "ff85c8a5300d207655832cfc10b023e24fb50700", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/05c26a445be2491a5b6018558d1aec182250c6d5/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c26a445be2491a5b6018558d1aec182250c6d5/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=05c26a445be2491a5b6018558d1aec182250c6d5", "patch": "@@ -210,30 +210,12 @@ impl<'a> Parser<'a> {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue;\n             } else if op == AssocOp::Colon {\n-                let maybe_path = self.could_ascription_be_path(&lhs.kind);\n-                self.last_type_ascription = Some((self.prev_span, maybe_path));\n-\n-                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n+                lhs = self.parse_assoc_op_ascribe(lhs, lhs_span)?;\n                 continue;\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n-                //\n-                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n-                // two variants are handled with `parse_prefix_range_expr` call above.\n-                let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                    Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n-                } else {\n-                    None\n-                };\n-                let (lhs_span, rhs_span) =\n-                    (lhs.span, if let Some(ref x) = rhs { x.span } else { cur_op_span });\n-                let limits =\n-                    if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n-\n-                let r = self.mk_range(Some(lhs), rhs, limits)?;\n-                lhs = self.mk_expr(lhs_span.to(rhs_span), r, AttrVec::new());\n+                lhs = self.parse_range_expr(prec, lhs, op, cur_op_span)?;\n                 break;\n             }\n \n@@ -393,6 +375,27 @@ impl<'a> Parser<'a> {\n             && !classify::expr_requires_semi_to_be_stmt(e)\n     }\n \n+    /// Parses `x..y`, `x..=y`, and `x..`/`x..=`.\n+    /// The other two variants are handled in `parse_prefix_range_expr` below.\n+    fn parse_range_expr(\n+        &mut self,\n+        prec: usize,\n+        lhs: P<Expr>,\n+        op: AssocOp,\n+        cur_op_span: Span,\n+    ) -> PResult<'a, P<Expr>> {\n+        let rhs = if self.is_at_start_of_range_notation_rhs() {\n+            Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n+        } else {\n+            None\n+        };\n+        let rhs_span = rhs.as_ref().map_or(cur_op_span, |x| x.span);\n+        let span = lhs.span.to(rhs_span);\n+        let limits =\n+            if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n+        Ok(self.mk_expr(span, self.mk_range(Some(lhs), rhs, limits)?, AttrVec::new()))\n+    }\n+\n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n         if self.token.can_begin_expr() {\n             // Parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n@@ -615,6 +618,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n+        let maybe_path = self.could_ascription_be_path(&lhs.kind);\n+        self.last_type_ascription = Some((self.prev_span, maybe_path));\n+        let lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n+        self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n+        Ok(lhs)\n+    }\n+\n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n     fn parse_borrow_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;"}]}