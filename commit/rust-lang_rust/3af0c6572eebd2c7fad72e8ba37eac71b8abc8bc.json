{"sha": "3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZjBjNjU3MmVlYmQyYzdmYWQ3MmU4YmEzN2VhYzcxYjhhYmM4YmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-02T01:44:23Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-07T22:12:30Z"}, "message": "Refactor code out of the folder implementation for `StripUnconfigured`.", "tree": {"sha": "81241a978f6e5fd31d4f134e96852cc63b049793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81241a978f6e5fd31d4f134e96852cc63b049793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "html_url": "https://github.com/rust-lang/rust/commit/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c88b4b7908b8451e9c3a3c8d9c8ea43fa78c52a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c88b4b7908b8451e9c3a3c8d9c8ea43fa78c52a", "html_url": "https://github.com/rust-lang/rust/commit/2c88b4b7908b8451e9c3a3c8d9c8ea43fa78c52a"}], "stats": {"total": 130, "additions": 75, "deletions": 55}, "files": [{"sha": "07604bffa1c6674714daaafe999b7bdea6162d64", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 69, "deletions": 55, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "patch": "@@ -13,7 +13,7 @@ use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_fea\n use {fold, attr};\n use ast;\n use codemap::{Spanned, respan};\n-use parse::{ParseSess, token};\n+use parse::ParseSess;\n use ptr::P;\n \n use util::small_vector::SmallVector;\n@@ -60,6 +60,15 @@ pub fn features(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)\n     (krate, features)\n }\n \n+macro_rules! configure {\n+    ($this:ident, $node:ident) => {\n+        match $this.configure($node) {\n+            Some(node) => node,\n+            None => return Default::default(),\n+        }\n+    }\n+}\n+\n impl<'a> StripUnconfigured<'a> {\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         let node = self.process_cfg_attrs(node);\n@@ -156,37 +165,35 @@ impl<'a> StripUnconfigured<'a> {\n             }\n         }\n     }\n-}\n \n-impl<'a> fold::Folder for StripUnconfigured<'a> {\n-    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+    fn configure_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n-            items: foreign_mod.items.into_iter().filter_map(|item| {\n-                self.configure(item).map(|item| fold::noop_fold_foreign_item(item, self))\n-            }).collect(),\n+            items: foreign_mod.items.into_iter().filter_map(|item| self.configure(item)).collect(),\n         }\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        let fold_struct = |this: &mut Self, vdata| match vdata {\n+    fn configure_variant_data(&mut self, vdata: ast::VariantData) -> ast::VariantData {\n+        match vdata {\n             ast::VariantData::Struct(fields, id) => {\n-                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                let fields = fields.into_iter().filter_map(|field| self.configure(field));\n                 ast::VariantData::Struct(fields.collect(), id)\n             }\n             ast::VariantData::Tuple(fields, id) => {\n-                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                let fields = fields.into_iter().filter_map(|field| self.configure(field));\n                 ast::VariantData::Tuple(fields.collect(), id)\n             }\n             ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n-        };\n+        }\n+    }\n \n-        let item = match item {\n+    fn configure_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        match item {\n             ast::ItemKind::Struct(def, generics) => {\n-                ast::ItemKind::Struct(fold_struct(self, def), generics)\n+                ast::ItemKind::Struct(self.configure_variant_data(def), generics)\n             }\n             ast::ItemKind::Union(def, generics) => {\n-                ast::ItemKind::Union(fold_struct(self, def), generics)\n+                ast::ItemKind::Union(self.configure_variant_data(def), generics)\n             }\n             ast::ItemKind::Enum(def, generics) => {\n                 let variants = def.variants.into_iter().filter_map(|v| {\n@@ -195,7 +202,7 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n                             node: ast::Variant_ {\n                                 name: v.node.name,\n                                 attrs: v.node.attrs,\n-                                data: fold_struct(self, v.node.data),\n+                                data: self.configure_variant_data(v.node.data),\n                                 disr_expr: v.node.disr_expr,\n                             },\n                             span: v.span\n@@ -207,12 +214,19 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n                 }, generics)\n             }\n             item => item,\n-        };\n+        }\n+    }\n \n-        fold::noop_fold_item_kind(item, self)\n+    fn configure_expr_kind(&mut self, expr_kind: ast::ExprKind) -> ast::ExprKind {\n+        if let ast::ExprKind::Match(m, arms) = expr_kind {\n+            let arms = arms.into_iter().filter_map(|a| self.configure(a)).collect();\n+            ast::ExprKind::Match(m, arms)\n+        } else {\n+            expr_kind\n+        }\n     }\n \n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         self.visit_stmt_or_expr_attrs(expr.attrs());\n \n         // If an expr is valid to cfg away it will have been removed by the\n@@ -227,64 +241,64 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n             self.sess.span_diagnostic.span_err(attr.span, msg);\n         }\n \n-        let expr = self.process_cfg_attrs(expr);\n-        fold_expr(self, expr)\n+        self.process_cfg_attrs(expr)\n     }\n \n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        self.configure(expr).map(|expr| fold_expr(self, expr))\n+    fn configure_stmt(&mut self, stmt: ast::Stmt) -> Option<ast::Stmt> {\n+        self.visit_stmt_or_expr_attrs(stmt.attrs());\n+        self.configure(stmt)\n+    }\n+}\n+\n+impl<'a> fold::Folder for StripUnconfigured<'a> {\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+        let foreign_mod = self.configure_foreign_mod(foreign_mod);\n+        fold::noop_fold_foreign_mod(foreign_mod, self)\n     }\n \n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        self.visit_stmt_or_expr_attrs(stmt.attrs());\n-        self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))\n-                            .unwrap_or(SmallVector::zero())\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        let item = self.configure_item_kind(item);\n+        fold::noop_fold_item_kind(item, self)\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        let mut expr = self.configure_expr(expr).unwrap();\n+        expr.node = self.configure_expr_kind(expr.node);\n+        P(fold::noop_fold_expr(expr, self))\n+    }\n+\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr).unwrap();\n+        expr.node = self.configure_expr_kind(expr.node);\n+        Some(P(fold::noop_fold_expr(expr, self)))\n+    }\n+\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        match self.configure_stmt(stmt) {\n+            Some(stmt) => fold::noop_fold_stmt(stmt, self),\n+            None => return SmallVector::zero(),\n+        }\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        self.configure(item).map(|item| fold::noop_fold_item(item, self))\n-                            .unwrap_or(SmallVector::zero())\n+        fold::noop_fold_item(configure!(self, item), self)\n     }\n \n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        self.configure(item).map(|item| fold::noop_fold_impl_item(item, self))\n-                            .unwrap_or(SmallVector::zero())\n+        fold::noop_fold_impl_item(configure!(self, item), self)\n     }\n \n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        self.configure(item).map(|item| fold::noop_fold_trait_item(item, self))\n-                            .unwrap_or(SmallVector::zero())\n+        fold::noop_fold_trait_item(configure!(self, item), self)\n     }\n \n-    fn fold_interpolated(&mut self, nt: token::Nonterminal) -> token::Nonterminal {\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         // Don't configure interpolated AST (c.f. #34171).\n         // Interpolated AST will get configured once the surrounding tokens are parsed.\n-        nt\n+        mac\n     }\n }\n \n-fn fold_expr(folder: &mut StripUnconfigured, expr: P<ast::Expr>) -> P<ast::Expr> {\n-    expr.map(|ast::Expr {id, span, node, attrs}| {\n-        fold::noop_fold_expr(ast::Expr {\n-            id: id,\n-            node: match node {\n-                ast::ExprKind::Match(m, arms) => {\n-                    ast::ExprKind::Match(m, arms.into_iter()\n-                                        .filter_map(|a| folder.configure(a))\n-                                        .collect())\n-                }\n-                _ => node\n-            },\n-            span: span,\n-            attrs: attrs,\n-        }, folder)\n-    })\n-}\n-\n fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }"}, {"sha": "373dfc4ddfac5c0dfcbd796101279515eee1087c", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=3af0c6572eebd2c7fad72e8ba37eac71b8abc8bc", "patch": "@@ -29,6 +29,12 @@ enum SmallVectorRepr<T> {\n     Many(Vec<T>),\n }\n \n+impl<T> Default for SmallVector<T> {\n+    fn default() -> Self {\n+        SmallVector { repr: Zero }\n+    }\n+}\n+\n impl<T> Into<Vec<T>> for SmallVector<T> {\n     fn into(self) -> Vec<T> {\n         match self.repr {"}]}