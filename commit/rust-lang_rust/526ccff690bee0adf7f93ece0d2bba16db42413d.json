{"sha": "526ccff690bee0adf7f93ece0d2bba16db42413d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNmNjZmY2OTBiZWUwYWRmN2Y5M2VjZTBkMmJiYTE2ZGI0MjQxM2Q=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-10-19T21:09:04Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-10-19T21:09:04Z"}, "message": "Merge pull request #445 from marcusklaas/comments\n\nFormat more comments", "tree": {"sha": "ef25957af70c6c97892048a8b052158c5116cd18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef25957af70c6c97892048a8b052158c5116cd18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/526ccff690bee0adf7f93ece0d2bba16db42413d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/526ccff690bee0adf7f93ece0d2bba16db42413d", "html_url": "https://github.com/rust-lang/rust/commit/526ccff690bee0adf7f93ece0d2bba16db42413d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/526ccff690bee0adf7f93ece0d2bba16db42413d/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0148c16b64b7d3eb004398b0081ea6fa1b514c24", "url": "https://api.github.com/repos/rust-lang/rust/commits/0148c16b64b7d3eb004398b0081ea6fa1b514c24", "html_url": "https://github.com/rust-lang/rust/commit/0148c16b64b7d3eb004398b0081ea6fa1b514c24"}, {"sha": "e8447a82104d5f9da2802af1e8530aba7ad6512a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8447a82104d5f9da2802af1e8530aba7ad6512a", "html_url": "https://github.com/rust-lang/rust/commit/e8447a82104d5f9da2802af1e8530aba7ad6512a"}], "stats": {"total": 447, "additions": 371, "deletions": 76}, "files": [{"sha": "c00a673ebf626f072638a9c45a75228c2b645b5b", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -7,7 +7,7 @@ dependencies = [\n  \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (git+https://github.com/nrc/strings.rs.git)\",\n  \"term 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.1.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -93,7 +93,7 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.1.22\"\n+version = \"0.1.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "e4ce5a7ed3583dcca6380cc7b65cd723472b64f8", "filename": "src/comment.rs", "status": "modified", "additions": 136, "deletions": 11, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -81,11 +81,11 @@ pub fn rewrite_comment(orig: &str,\n             let rewrite = try_opt!(rewrite_string(line, &fmt));\n             result.push_str(&rewrite);\n         } else {\n-            if line.len() == 0 {\n-                result.pop(); // Remove space if this is an empty comment.\n-            } else {\n-                result.push_str(line);\n+            if line.len() == 0 || line.starts_with('!') {\n+                // Remove space if this is an empty comment or a doc comment.\n+                result.pop();\n             }\n+            result.push_str(line);\n         }\n \n         first = false;\n@@ -195,17 +195,17 @@ enum CharClassesStatus {\n     LitCharEscape,\n     // The u32 is the nesting deepness of the comment\n     BlockComment(u32),\n-    // Status when the '/' has been consumed, but not yet the '*', deepness is the new deepness\n-    // (after the comment opening).\n+    // Status when the '/' has been consumed, but not yet the '*', deepness is\n+    // the new deepness (after the comment opening).\n     BlockCommentOpening(u32),\n-    // Status when the '*' has been consumed, but not yet the '/', deepness is the new deepness\n-    // (after the comment closing).\n+    // Status when the '*' has been consumed, but not yet the '/', deepness is\n+    // the new deepness (after the comment closing).\n     BlockCommentClosing(u32),\n     LineComment,\n }\n \n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-enum CodeCharKind {\n+pub enum CodeCharKind {\n     Normal,\n     Comment,\n }\n@@ -298,11 +298,137 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n     }\n }\n \n+/// Iterator over an alternating sequence of functional and commented parts of\n+/// a string. The first item is always a, possibly zero length, subslice of\n+/// functional text. Line style comments contain their ending newlines.\n+pub struct CommentCodeSlices<'a> {\n+    slice: &'a str,\n+    last_slice_kind: CodeCharKind,\n+    last_slice_end: usize,\n+}\n+\n+impl<'a> CommentCodeSlices<'a> {\n+    pub fn new(slice: &'a str) -> CommentCodeSlices<'a> {\n+        CommentCodeSlices {\n+            slice: slice,\n+            last_slice_kind: CodeCharKind::Comment,\n+            last_slice_end: 0,\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for CommentCodeSlices<'a> {\n+    type Item = (CodeCharKind, usize, &'a str);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.last_slice_end == self.slice.len() {\n+            return None;\n+        }\n+\n+        let mut sub_slice_end = self.last_slice_end;\n+        let mut first_whitespace = None;\n+        let subslice = &self.slice[self.last_slice_end..];\n+        let mut iter = CharClasses::new(subslice.char_indices());\n+\n+        for (kind, (i, c)) in &mut iter {\n+            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal &&\n+                                       &subslice[..2] == \"//\" &&\n+                                       [' ', '\\t'].contains(&c);\n+\n+            if is_comment_connector && first_whitespace.is_none() {\n+                first_whitespace = Some(i);\n+            }\n+\n+            if kind == self.last_slice_kind && !is_comment_connector {\n+                let last_index = match first_whitespace {\n+                    Some(j) => j,\n+                    None => i,\n+                };\n+                sub_slice_end = self.last_slice_end + last_index;\n+                break;\n+            }\n+\n+            if !is_comment_connector {\n+                first_whitespace = None;\n+            }\n+        }\n+\n+        if let (None, true) = (iter.next(), sub_slice_end == self.last_slice_end) {\n+            // This was the last subslice.\n+            sub_slice_end = match first_whitespace {\n+                Some(i) => self.last_slice_end + i,\n+                None => self.slice.len(),\n+            };\n+        }\n+\n+        let kind = match self.last_slice_kind {\n+            CodeCharKind::Comment => CodeCharKind::Normal,\n+            CodeCharKind::Normal => CodeCharKind::Comment,\n+        };\n+        let res = (kind,\n+                   self.last_slice_end,\n+                   &self.slice[self.last_slice_end..sub_slice_end]);\n+        self.last_slice_end = sub_slice_end;\n+        self.last_slice_kind = kind;\n+\n+        Some(res)\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented};\n+    use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented,\n+                CommentCodeSlices};\n     use Indent;\n \n+    #[test]\n+    fn char_classes() {\n+        let mut iter = CharClasses::new(\"//\\n\\n\".chars());\n+\n+        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, '\\n'), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, '\\n'), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices() {\n+        let input = \"code(); /* test */ 1 + 1\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"code(); \"), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, 8, \"/* test */\"),\n+                   iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, 18, \" 1 + 1\"), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices_two() {\n+        let input = \"// comment\\n    test();\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"\"), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, 0, \"// comment\\n\"),\n+                   iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, 11, \"    test();\"),\n+                   iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices_three() {\n+        let input = \"1 // comment\\n    // comment2\\n\\n\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"1 \"), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, 2, \"// comment\\n    // comment2\\n\"),\n+                   iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, 29, \"\\n\"), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n     #[test]\n     #[rustfmt_skip]\n     fn format_comments() {\n@@ -362,7 +488,6 @@ mod test {\n     #[test]\n     fn test_find_uncommented() {\n         fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n-            println!(\"haystack {:?}, needle: {:?}\", haystack, needle);\n             assert_eq!(expected, haystack.find_uncommented(needle));\n         }\n "}, {"sha": "f0a877db2158c66ccf80fea0ea0f069f02a6af13", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -423,7 +423,7 @@ impl Rewrite for ast::Block {\n         }\n \n         let mut visitor = FmtVisitor::from_codemap(context.codemap, context.config);\n-        visitor.block_indent = context.block_indent + context.overflow_indent;\n+        visitor.block_indent = context.block_indent;\n \n         let prefix = match self.rules {\n             ast::BlockCheckMode::UnsafeBlock(..) => {\n@@ -471,10 +471,6 @@ impl Rewrite for ast::Block {\n \n         visitor.visit_block(self);\n \n-        // Push text between last block item and end of block\n-        let snippet = visitor.snippet(mk_sp(visitor.last_pos, self.span.hi));\n-        visitor.buffer.push_str(&snippet);\n-\n         Some(format!(\"{}{}\", prefix, visitor.buffer))\n     }\n }\n@@ -751,7 +747,7 @@ fn rewrite_match(context: &RewriteContext,\n     let mut result = format!(\"match {} {{\", cond_str);\n \n     let nested_context = context.nested_context();\n-    let arm_indent = nested_context.block_indent + context.overflow_indent;\n+    let arm_indent = nested_context.block_indent;\n     let arm_indent_str = arm_indent.to_string(context.config);\n \n     let open_brace_pos = span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n@@ -795,7 +791,7 @@ fn rewrite_match(context: &RewriteContext,\n                                                      &arm_indent_str));\n     result.push_str(&comment);\n     result.push('\\n');\n-    result.push_str(&(context.block_indent + context.overflow_indent).to_string(context.config));\n+    result.push_str(&context.block_indent.to_string(context.config));\n     result.push('}');\n     Some(result)\n }\n@@ -1534,12 +1530,11 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n             let new_offset = offset.block_indent(context.config);\n             result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n \n-            // FIXME: we probably should related max_width to width instead of config.max_width\n-            // where is the 1 coming from anyway?\n+            // FIXME: we probably should related max_width to width instead of\n+            // config.max_width where is the 1 coming from anyway?\n             let max_width = try_opt!(context.config.max_width.checked_sub(new_offset.width() + 1));\n-            let rhs_indent = Indent::new(context.config.tab_spaces, 0);\n-            let overflow_context = context.overflow_context(rhs_indent);\n-            let rhs = ex.rewrite(&overflow_context, max_width, new_offset);\n+            let inner_context = context.nested_context();\n+            let rhs = ex.rewrite(&inner_context, max_width, new_offset);\n \n             result.push_str(&&try_opt!(rhs));\n         }"}, {"sha": "c8054b8d01fb5785ca9e2b29c7b1a70df339b5cf", "filename": "src/items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -287,8 +287,8 @@ impl<'a> FmtVisitor<'a> {\n                        has_body: bool)\n                        -> Option<(String, bool)> {\n         let mut force_new_line_for_brace = false;\n-        // FIXME we'll lose any comments in between parts of the function decl, but anyone\n-        // who comments there probably deserves what they get.\n+        // FIXME we'll lose any comments in between parts of the function decl, but\n+        // anyone who comments there probably deserves what they get.\n \n         let where_clause = &generics.where_clause;\n \n@@ -1008,7 +1008,8 @@ impl<'a> FmtVisitor<'a> {\n                                  span_start,\n                                  span_end);\n         let item_vec = items.collect::<Vec<_>>();\n-        // FIXME: we don't need to collect here if the where_layout isnt horizontalVertical\n+        // FIXME: we don't need to collect here if the where_layout isnt\n+        // HorizontalVertical.\n         let tactic = definitive_tactic(&item_vec, self.config.where_layout, budget);\n \n         let fmt = ListFormatting {"}, {"sha": "04d3ac3366a248371aaf2a6a92c0497e0d72224f", "filename": "src/missed_spans.rs", "status": "modified", "additions": 111, "deletions": 21, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -10,7 +10,8 @@\n \n use visitor::FmtVisitor;\n \n-use syntax::codemap::{self, BytePos};\n+use syntax::codemap::{self, BytePos, Span, Pos};\n+use comment::{CodeCharKind, CommentCodeSlices, rewrite_comment};\n \n impl<'a> FmtVisitor<'a> {\n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n@@ -37,16 +38,12 @@ impl<'a> FmtVisitor<'a> {\n                                                                 end: BytePos,\n                                                                 process_last_snippet: F) {\n         let start = self.last_pos;\n-        debug!(\"format_missing_inner: {:?} to {:?}\",\n-               self.codemap.lookup_char_pos(start),\n-               self.codemap.lookup_char_pos(end));\n \n         if start == end {\n             // Do nothing if this is the beginning of the file.\n-            if start == self.codemap.lookup_char_pos(start).file.start_pos {\n-                return;\n+            if start != self.codemap.lookup_char_pos(start).file.start_pos {\n+                process_last_snippet(self, \"\", \"\");\n             }\n-            process_last_snippet(self, \"\", \"\");\n             return;\n         }\n \n@@ -57,24 +54,117 @@ impl<'a> FmtVisitor<'a> {\n \n         self.last_pos = end;\n         let span = codemap::mk_sp(start, end);\n+\n+        self.write_snippet(span, &process_last_snippet);\n+    }\n+\n+    fn write_snippet<F>(&mut self, span: Span, process_last_snippet: F)\n+        where F: Fn(&mut FmtVisitor, &str, &str)\n+    {\n+        // Get a snippet from the file start to the span's hi without allocating.\n+        // We need it to determine what precedes the current comment. If the comment\n+        // follows code on the same line, we won't touch it.\n+        let big_span_lo = self.codemap.lookup_char_pos(span.lo).file.start_pos;\n+        let local_begin = self.codemap.lookup_byte_offset(big_span_lo);\n+        let local_end = self.codemap.lookup_byte_offset(span.hi);\n+        let start_index = local_begin.pos.to_usize();\n+        let end_index = local_end.pos.to_usize();\n+        let big_snippet = &local_begin.fm.src.as_ref().unwrap()[start_index..end_index];\n+\n+        let big_diff = (span.lo - big_span_lo).to_usize();\n         let snippet = self.snippet(span);\n \n-        self.write_snippet(&snippet, &process_last_snippet);\n+        self.write_snippet_inner(big_snippet, big_diff, &snippet, process_last_snippet);\n     }\n \n-    fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n-                                                         snippet: &str,\n-                                                         process_last_snippet: F) {\n-        let mut lines: Vec<&str> = snippet.lines().collect();\n-        let last_snippet = if snippet.ends_with(\"\\n\") {\n-            \"\"\n-        } else {\n-            lines.pop().unwrap()\n-        };\n-        for line in lines.iter() {\n-            self.buffer.push_str(line.trim_right());\n-            self.buffer.push_str(\"\\n\");\n+    fn write_snippet_inner<F>(&mut self,\n+                              big_snippet: &str,\n+                              big_diff: usize,\n+                              snippet: &str,\n+                              process_last_snippet: F)\n+        where F: Fn(&mut FmtVisitor, &str, &str)\n+    {\n+        // Trim whitespace from the right hand side of each line.\n+        // Annoyingly, the library functions for splitting by lines etc. are not\n+        // quite right, so we must do it ourselves.\n+        let mut line_start = 0;\n+        let mut last_wspace = None;\n+        let mut rewrite_next_comment = true;\n+\n+        for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n+            if let CodeCharKind::Comment = kind {\n+                let last_char = big_snippet[..(offset + big_diff)]\n+                                    .chars()\n+                                    .rev()\n+                                    .skip_while(|rev_c| [' ', '\\t'].contains(&rev_c))\n+                                    .next();\n+\n+                let fix_indent = last_char.map(|rev_c| ['{', '\\n'].contains(&rev_c))\n+                                          .unwrap_or(true);\n+\n+                if rewrite_next_comment && fix_indent {\n+                    if let Some('{') = last_char {\n+                        self.buffer.push_str(\"\\n\");\n+                    }\n+\n+                    let comment_width = ::std::cmp::min(self.config.ideal_width,\n+                                                        self.config.max_width -\n+                                                        self.block_indent.width());\n+\n+                    self.buffer.push_str(&self.block_indent.to_string(self.config));\n+                    self.buffer.push_str(&rewrite_comment(subslice,\n+                                                          false,\n+                                                          comment_width,\n+                                                          self.block_indent,\n+                                                          self.config)\n+                                              .unwrap());\n+\n+                    last_wspace = None;\n+                    line_start = offset + subslice.len();\n+\n+                    if let Some('/') = subslice.chars().skip(1).next() {\n+                        self.buffer.push_str(\"\\n\");\n+                    } else if line_start < snippet.len() {\n+                        let x = (&snippet[line_start..]).chars().next().unwrap() != '\\n';\n+\n+                        if x {\n+                            self.buffer.push_str(\"\\n\");\n+                        }\n+                    }\n+\n+                    continue;\n+                } else {\n+                    rewrite_next_comment = false;\n+                }\n+            }\n+\n+            for (mut i, c) in subslice.char_indices() {\n+                i += offset;\n+\n+                if c == '\\n' {\n+                    if let Some(lw) = last_wspace {\n+                        self.buffer.push_str(&snippet[line_start..lw]);\n+                        self.buffer.push_str(\"\\n\");\n+                    } else {\n+                        self.buffer.push_str(&snippet[line_start..i + 1]);\n+                    }\n+\n+                    line_start = i + 1;\n+                    last_wspace = None;\n+                    rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n+                } else {\n+                    if c.is_whitespace() {\n+                        if last_wspace.is_none() {\n+                            last_wspace = Some(i);\n+                        }\n+                    } else {\n+                        rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n+                        last_wspace = None;\n+                    }\n+                }\n+            }\n         }\n-        process_last_snippet(self, &last_snippet, snippet);\n+\n+        process_last_snippet(self, &snippet[line_start..], &snippet);\n     }\n }"}, {"sha": "cf8be8004e1bc636138de3f4a9f789e16cdb96a6", "filename": "src/rewrite.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -29,14 +29,8 @@ pub trait Rewrite {\n pub struct RewriteContext<'a> {\n     pub codemap: &'a CodeMap,\n     pub config: &'a Config,\n-\n     // Indentation due to nesting of blocks.\n     pub block_indent: Indent,\n-    // *Extra* indentation due to overflowing to the next line, e.g.,\n-    // let foo =\n-    //     bar();\n-    // The extra 4 spaces when formatting `bar()` is overflow_indent.\n-    pub overflow_indent: Indent,\n }\n \n impl<'a> RewriteContext<'a> {\n@@ -45,16 +39,6 @@ impl<'a> RewriteContext<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent.block_indent(self.config),\n-            overflow_indent: self.overflow_indent,\n-        }\n-    }\n-\n-    pub fn overflow_context(&self, overflow: Indent) -> RewriteContext<'a> {\n-        RewriteContext {\n-            codemap: self.codemap,\n-            config: self.config,\n-            block_indent: self.block_indent,\n-            overflow_indent: overflow,\n         }\n     }\n "}, {"sha": "b8de0fc7189f6f3313c35dc2f40437f0c15a9b45", "filename": "src/visitor.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -101,11 +101,22 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n         }\n \n-        self.block_indent = self.block_indent.block_unindent(self.config);\n         // TODO: we should compress any newlines here to just one\n         self.format_missing_with_indent(b.span.hi - brace_compensation);\n+        // FIXME: this is a terrible hack to indent the comments between the last\n+        // item in the block and the closing brace to the block's level.\n+        // The closing brace itself, however, should be indented at a shallower\n+        // level.\n+        let total_len = self.buffer.len;\n+        let chars_too_many = if self.config.hard_tabs {\n+            1\n+        } else {\n+            self.config.tab_spaces\n+        };\n+        self.buffer.truncate(total_len - chars_too_many);\n         self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n+        self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n \n     // Note that this only gets called for function definitions. Required methods\n@@ -177,6 +188,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             // FIXME(#78): format traits and impl definitions.\n             ast::Item_::ItemImpl(..) |\n             ast::Item_::ItemTrait(..) => {\n+                self.format_missing_with_indent(item.span.lo);\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 visit::walk_item(self, item);\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n@@ -215,6 +227,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemMac(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n+                let snippet = self.snippet(item.span);\n+                self.buffer.push_str(&snippet);\n+                self.last_pos = item.span.hi;\n                 // FIXME: we cannot format these yet, because of a bad span.\n                 // See rust lang issue #28424.\n                 // visit::walk_item(self, item);\n@@ -387,7 +402,6 @@ impl<'a> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent,\n-            overflow_indent: Indent::empty(),\n         };\n         // 1 = \";\"\n         match vp.rewrite(&context, self.config.max_width - offset.width() - 1, offset) {\n@@ -419,7 +433,6 @@ impl<'a> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent,\n-            overflow_indent: Indent::empty(),\n         }\n     }\n }"}, {"sha": "34b5de79b754c3bec36e3dcd6216dd5621577bd2", "filename": "tests/source/comment.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Fsource%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Fsource%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcomment.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -0,0 +1,39 @@\n+//! Doc comment\n+fn test() {\n+// comment\n+        // comment2\n+\n+    code(); /* leave this comment alone!\n+             * ok? */\n+\n+        /* Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a\n+         * diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam\n+         * viverra nec consectetur ante hendrerit. Donec et mollis dolor.\n+         * Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam\n+         * tincidunt congue enim, ut porta lorem lacinia consectetur. Donec ut\n+         * libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit\n+         * amet, consectetur adipiscing elit. Aenean ut gravida lorem. Ut turpis\n+         * felis, pulvinar a semper sed, adipiscing id dolor. */\n+\n+    // Very looooooooooooooooooooooooooooooooooooooooooooooooooooooooong comment that should be split\n+\n+                    // println!(\"{:?}\", rewrite_comment(subslice,\n+                    //                                       false,\n+                    //                                       comment_width,\n+                    //                                       self.block_indent,\n+                    //                                       self.config)\n+                    //                           .unwrap());\n+\n+    funk(); //dontchangeme\n+            // or me\n+}\n+\n+  /// test123\n+fn doc_comment() {\n+}\n+\n+fn chains() {\n+                foo.bar(|| { \n+                let x = 10;\n+                /* comment */ x })\n+}"}, {"sha": "6ab217ed6c48c5f0e8aab685b55b5196a95a6ea6", "filename": "tests/target/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -19,7 +19,7 @@ fn main() {\n     };\n \n     let loooooooooooooong_name = |field| {\n-             // TODO(#27): format comments.\n+        // TODO(#27): format comments.\n         if field.node.attrs.len() > 0 {\n             field.node.attrs[0].span.lo\n         } else {\n@@ -39,7 +39,8 @@ fn main() {\n \n     let empty = |arg| {};\n \n-    let simple = |arg| { /* TODO(#27): comment formatting */\n+    let simple = |arg| {\n+        // TODO(#27): comment formatting\n         foo(arg)\n     };\n "}, {"sha": "575631cd3be12a041828658a26a14fb125d27145", "filename": "tests/target/comment.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -0,0 +1,42 @@\n+//! Doc comment\n+fn test() {\n+    // comment\n+    // comment2\n+\n+    code(); /* leave this comment alone!\n+             * ok? */\n+\n+    // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a\n+    // diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam\n+    // viverra nec consectetur ante hendrerit. Donec et mollis dolor.\n+    // Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam\n+    // tincidunt congue enim, ut porta lorem lacinia consectetur. Donec ut\n+    // libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit\n+    // amet, consectetur adipiscing elit. Aenean ut gravida lorem. Ut turpis\n+    // felis, pulvinar a semper sed, adipiscing id dolor.\n+\n+    // Very looooooooooooooooooooooooooooooooooooooooooooooooooooooooong comment\n+    // that should be split\n+\n+    // println!(\"{:?}\", rewrite_comment(subslice,\n+    //                                       false,\n+    //                                       comment_width,\n+    //                                       self.block_indent,\n+    //                                       self.config)\n+    //                           .unwrap());\n+\n+    funk(); //dontchangeme\n+            // or me\n+}\n+\n+/// test123\n+fn doc_comment() {\n+}\n+\n+fn chains() {\n+    foo.bar(|| {\n+        let x = 10;\n+        // comment\n+        x\n+    })\n+}"}, {"sha": "9e883c50afa19b19710e95cf367d995a24718554", "filename": "tests/target/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fdoc.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -1,3 +1,3 @@\n \n // sadfsdfa\n-//sdffsdfasdf\n+// sdffsdfasdf"}, {"sha": "4b4afaa99e555a8a754095d36bda919516211e0b", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -142,7 +142,8 @@ fn baz() {\n fn qux() {\n     {}\n     // FIXME this one could be done better.\n-    { /* a block with a comment */\n+    {\n+        // a block with a comment\n     }\n     {\n "}, {"sha": "7202b0e0c80702c9cb92dda850cd0da357b099f7", "filename": "tests/target/match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -6,7 +6,8 @@ fn foo() {\n         // Some comment.\n         a => foo(),\n         b if 0 < 42 => foo(),\n-        c => { // Another comment.\n+        c => {\n+            // Another comment.\n             // Comment.\n             an_expression;\n             foo()\n@@ -112,7 +113,8 @@ fn issue339() {\n         // collapsing here exceeds line length\n         ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg => {\n         }\n-        h => { // comment above block\n+        h => {\n+            // comment above block\n         }\n         i => {} // comment below block\n         j => {\n@@ -133,7 +135,8 @@ fn issue339() {\n         m => {}\n         n => {}\n         o => {}\n-        p => { // Dont collapse me\n+        p => {\n+            // Dont collapse me\n         }\n         q => {}\n         r => {}"}, {"sha": "7d6513f70b72f00d52fd2aa33abfd914d507a7d2", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526ccff690bee0adf7f93ece0d2bba16db42413d/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=526ccff690bee0adf7f93ece0d2bba16db42413d", "patch": "@@ -22,7 +22,8 @@ mod doc;\n mod other;\n \n \n-// sfdgfffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffff\n+// sfdgfffffffffffffffffffffffffffffffffffffffffffffffffffffff\n+// ffffffffffffffffffffffffffffffffffffffffff\n \n fn foo(a: isize, b: u32 /* blah blah */, c: f64) {\n "}]}