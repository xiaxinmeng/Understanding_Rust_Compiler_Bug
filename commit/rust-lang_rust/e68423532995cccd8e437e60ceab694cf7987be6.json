{"sha": "e68423532995cccd8e437e60ceab694cf7987be6", "node_id": "C_kwDOAAsO6NoAKGU2ODQyMzUzMjk5NWNjY2Q4ZTQzN2U2MGNlYWI2OTRjZjc5ODdiZTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-03T11:52:40Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-03T11:52:40Z"}, "message": "Move module private logic down", "tree": {"sha": "6c549564018bcdeccd5cd922f8de73b39980d375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c549564018bcdeccd5cd922f8de73b39980d375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e68423532995cccd8e437e60ceab694cf7987be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e68423532995cccd8e437e60ceab694cf7987be6", "html_url": "https://github.com/rust-lang/rust/commit/e68423532995cccd8e437e60ceab694cf7987be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e68423532995cccd8e437e60ceab694cf7987be6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0943c4be8b141fd9164e50b591a4219bd2939923", "url": "https://api.github.com/repos/rust-lang/rust/commits/0943c4be8b141fd9164e50b591a4219bd2939923", "html_url": "https://github.com/rust-lang/rust/commit/0943c4be8b141fd9164e50b591a4219bd2939923"}], "stats": {"total": 153, "additions": 76, "deletions": 77}, "files": [{"sha": "9889dd772ea7f20ec6eb7d59b24cc36b17748f03", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e68423532995cccd8e437e60ceab694cf7987be6/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68423532995cccd8e437e60ceab694cf7987be6/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=e68423532995cccd8e437e60ceab694cf7987be6", "patch": "@@ -1,4 +1,4 @@\n-//! Handle syntactic aspects of inserting a new `use`.\n+//! Handle syntactic aspects of inserting a new `use` item.\n #[cfg(test)]\n mod tests;\n \n@@ -103,81 +103,6 @@ impl ImportScope {\n             ImportScope::Block(block) => ImportScope::Block(block.clone_for_update()),\n         }\n     }\n-\n-    fn guess_granularity_from_scope(&self) -> ImportGranularityGuess {\n-        // The idea is simple, just check each import as well as the import and its precedent together for\n-        // whether they fulfill a granularity criteria.\n-        let use_stmt = |item| match item {\n-            ast::Item::Use(use_) => {\n-                let use_tree = use_.use_tree()?;\n-                Some((use_tree, use_.visibility(), use_.attrs()))\n-            }\n-            _ => None,\n-        };\n-        let mut use_stmts = match self {\n-            ImportScope::File(f) => f.items(),\n-            ImportScope::Module(m) => m.items(),\n-            ImportScope::Block(b) => b.items(),\n-        }\n-        .filter_map(use_stmt);\n-        let mut res = ImportGranularityGuess::Unknown;\n-        let (mut prev, mut prev_vis, mut prev_attrs) = match use_stmts.next() {\n-            Some(it) => it,\n-            None => return res,\n-        };\n-        loop {\n-            if let Some(use_tree_list) = prev.use_tree_list() {\n-                if use_tree_list.use_trees().any(|tree| tree.use_tree_list().is_some()) {\n-                    // Nested tree lists can only occur in crate style, or with no proper style being enforced in the file.\n-                    break ImportGranularityGuess::Crate;\n-                } else {\n-                    // Could still be crate-style so continue looking.\n-                    res = ImportGranularityGuess::CrateOrModule;\n-                }\n-            }\n-\n-            let (curr, curr_vis, curr_attrs) = match use_stmts.next() {\n-                Some(it) => it,\n-                None => break res,\n-            };\n-            if eq_visibility(prev_vis, curr_vis.clone()) && eq_attrs(prev_attrs, curr_attrs.clone())\n-            {\n-                if let Some((prev_path, curr_path)) = prev.path().zip(curr.path()) {\n-                    if let Some((prev_prefix, _)) = common_prefix(&prev_path, &curr_path) {\n-                        if prev.use_tree_list().is_none() && curr.use_tree_list().is_none() {\n-                            let prefix_c = prev_prefix.qualifiers().count();\n-                            let curr_c = curr_path.qualifiers().count() - prefix_c;\n-                            let prev_c = prev_path.qualifiers().count() - prefix_c;\n-                            if curr_c == 1 && prev_c == 1 {\n-                                // Same prefix, only differing in the last segment and no use tree lists so this has to be of item style.\n-                                break ImportGranularityGuess::Item;\n-                            } else {\n-                                // Same prefix and no use tree list but differs in more than one segment at the end. This might be module style still.\n-                                res = ImportGranularityGuess::ModuleOrItem;\n-                            }\n-                        } else {\n-                            // Same prefix with item tree lists, has to be module style as it\n-                            // can't be crate style since the trees wouldn't share a prefix then.\n-                            break ImportGranularityGuess::Module;\n-                        }\n-                    }\n-                }\n-            }\n-            prev = curr;\n-            prev_vis = curr_vis;\n-            prev_attrs = curr_attrs;\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq, PartialOrd, Debug, Clone, Copy)]\n-enum ImportGranularityGuess {\n-    Unknown,\n-    Item,\n-    Module,\n-    ModuleOrItem,\n-    Crate,\n-    CrateOrModule,\n }\n \n /// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n@@ -189,7 +114,7 @@ pub fn insert_use(scope: &ImportScope, path: ast::Path, cfg: &InsertUseConfig) {\n         ImportGranularity::Item | ImportGranularity::Preserve => None,\n     };\n     if !cfg.enforce_granularity {\n-        let file_granularity = scope.guess_granularity_from_scope();\n+        let file_granularity = guess_granularity_from_scope(scope);\n         mb = match file_granularity {\n             ImportGranularityGuess::Unknown => mb,\n             ImportGranularityGuess::Item => None,\n@@ -271,6 +196,80 @@ impl ImportGroup {\n     }\n }\n \n+#[derive(PartialEq, PartialOrd, Debug, Clone, Copy)]\n+enum ImportGranularityGuess {\n+    Unknown,\n+    Item,\n+    Module,\n+    ModuleOrItem,\n+    Crate,\n+    CrateOrModule,\n+}\n+\n+fn guess_granularity_from_scope(scope: &ImportScope) -> ImportGranularityGuess {\n+    // The idea is simple, just check each import as well as the import and its precedent together for\n+    // whether they fulfill a granularity criteria.\n+    let use_stmt = |item| match item {\n+        ast::Item::Use(use_) => {\n+            let use_tree = use_.use_tree()?;\n+            Some((use_tree, use_.visibility(), use_.attrs()))\n+        }\n+        _ => None,\n+    };\n+    let mut use_stmts = match scope {\n+        ImportScope::File(f) => f.items(),\n+        ImportScope::Module(m) => m.items(),\n+        ImportScope::Block(b) => b.items(),\n+    }\n+    .filter_map(use_stmt);\n+    let mut res = ImportGranularityGuess::Unknown;\n+    let (mut prev, mut prev_vis, mut prev_attrs) = match use_stmts.next() {\n+        Some(it) => it,\n+        None => return res,\n+    };\n+    loop {\n+        if let Some(use_tree_list) = prev.use_tree_list() {\n+            if use_tree_list.use_trees().any(|tree| tree.use_tree_list().is_some()) {\n+                // Nested tree lists can only occur in crate style, or with no proper style being enforced in the file.\n+                break ImportGranularityGuess::Crate;\n+            } else {\n+                // Could still be crate-style so continue looking.\n+                res = ImportGranularityGuess::CrateOrModule;\n+            }\n+        }\n+\n+        let (curr, curr_vis, curr_attrs) = match use_stmts.next() {\n+            Some(it) => it,\n+            None => break res,\n+        };\n+        if eq_visibility(prev_vis, curr_vis.clone()) && eq_attrs(prev_attrs, curr_attrs.clone()) {\n+            if let Some((prev_path, curr_path)) = prev.path().zip(curr.path()) {\n+                if let Some((prev_prefix, _)) = common_prefix(&prev_path, &curr_path) {\n+                    if prev.use_tree_list().is_none() && curr.use_tree_list().is_none() {\n+                        let prefix_c = prev_prefix.qualifiers().count();\n+                        let curr_c = curr_path.qualifiers().count() - prefix_c;\n+                        let prev_c = prev_path.qualifiers().count() - prefix_c;\n+                        if curr_c == 1 && prev_c == 1 {\n+                            // Same prefix, only differing in the last segment and no use tree lists so this has to be of item style.\n+                            break ImportGranularityGuess::Item;\n+                        } else {\n+                            // Same prefix and no use tree list but differs in more than one segment at the end. This might be module style still.\n+                            res = ImportGranularityGuess::ModuleOrItem;\n+                        }\n+                    } else {\n+                        // Same prefix with item tree lists, has to be module style as it\n+                        // can't be crate style since the trees wouldn't share a prefix then.\n+                        break ImportGranularityGuess::Module;\n+                    }\n+                }\n+            }\n+        }\n+        prev = curr;\n+        prev_vis = curr_vis;\n+        prev_attrs = curr_attrs;\n+    }\n+}\n+\n fn insert_use_(\n     scope: &ImportScope,\n     insert_path: &ast::Path,"}]}