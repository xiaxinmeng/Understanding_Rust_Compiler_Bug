{"sha": "d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZjBhOTQ5ZmQ2Yjc0NjQxYjEyYWZjMGY4YTE3ZjAwOTE5ZWJjZWY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-20T01:55:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T16:35:26Z"}, "message": "rustc_const_eval: demand that the MIR qualify_consts ran on each evaluated body.", "tree": {"sha": "6e05dba800cf05a891648e074cf6cd8782a0813f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e05dba800cf05a891648e074cf6cd8782a0813f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "html_url": "https://github.com/rust-lang/rust/commit/d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "html_url": "https://github.com/rust-lang/rust/commit/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a"}], "stats": {"total": 260, "additions": 148, "deletions": 112}, "files": [{"sha": "fd1403b15bc892fb4414aec38e9891dae1080d5c", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -361,6 +361,11 @@ define_maps! { <'tcx>\n     /// (in the `RefCell` sense) to prevent accidental mutation.\n     pub mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n+    /// Maps DefId's that have an associated Mir to the result\n+    /// of the MIR qualify_consts pass. The actual meaning of\n+    /// the value isn't known except to the pass itself.\n+    pub mir_const_qualif: Mir(DefId) -> u8,\n+\n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     pub closure_kind: ItemSignature(DefId) -> ty::ClosureKind,"}, {"sha": "c5d577ce571d40aceb664dd8d190a19f4efb709d", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -27,7 +27,7 @@ use rustc::util::nodemap::DefIdMap;\n use graphviz::IntoCow;\n use syntax::ast;\n use rustc::hir::{self, Expr};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -228,6 +228,7 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n         let def_id = tcx.hir.body_owner_def_id(body);\n+        ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n         ConstContext::with_tables(tcx, tcx.item_tables(def_id))\n     }\n "}, {"sha": "ddf09f5cfe0e08dd5cb61d10e2af4bcf7d6391d7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -872,7 +872,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let index = stability::Index::new(&hir_map);\n \n     let mut local_providers = ty::maps::Providers::default();\n-    mir::mir_map::provide(&mut local_providers);\n+    mir::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n@@ -958,8 +958,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             // in stage 4 below.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n             passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(\n-                box mir::transform::qualify_consts::QualifyAndPromoteConstants::default());\n+            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));"}, {"sha": "7b02280ef904bda504369b93dd1bb07a42428fa4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -101,6 +101,7 @@ provide! { <'tcx> tcx, def_id, cdata\n \n         mir\n     }\n+    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }"}, {"sha": "b4b9966cbe47b98138d8ad1afe0e3b047d5537a6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -411,8 +411,8 @@ impl<'a, 'tcx> MetadataBlob {\n impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            EntryKind::Const => Def::Const(did),\n-            EntryKind::AssociatedConst(_) => Def::AssociatedConst(did),\n+            EntryKind::Const(_) => Def::Const(did),\n+            EntryKind::AssociatedConst(..) => Def::AssociatedConst(did),\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n             EntryKind::MutStatic |\n@@ -825,14 +825,25 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+        match self.entry(id).kind {\n+            EntryKind::Const(qualif) |\n+            EntryKind::AssociatedConst(AssociatedContainer::ImplDefault, qualif) |\n+            EntryKind::AssociatedConst(AssociatedContainer::ImplFinal, qualif) => {\n+                qualif\n+            }\n+            _ => bug!(),\n+        }\n+    }\n+\n     pub fn get_associated_item(&self, id: DefIndex) -> ty::AssociatedItem {\n         let item = self.entry(id);\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n         let (kind, container, has_self) = match item.kind {\n-            EntryKind::AssociatedConst(container) => {\n+            EntryKind::AssociatedConst(container, _) => {\n                 (ty::AssociatedKind::Const, container, false)\n             }\n             EntryKind::Method(data) => {"}, {"sha": "af0edab7a83bd9eee79893a85d7b8c3d40b9189b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -457,7 +457,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         let kind = match trait_item.kind {\n-            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Const => {\n+                EntryKind::AssociatedConst(container, 0)\n+            }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n                     let arg_names = match *m {\n@@ -533,7 +535,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         let kind = match impl_item.kind {\n-            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Const => {\n+                EntryKind::AssociatedConst(container,\n+                    ty::queries::mir_const_qualif::get(self.tcx, ast_item.span, def_id))\n+            }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n@@ -637,7 +642,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let kind = match item.node {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n-            hir::ItemConst(..) => EntryKind::Const,\n+            hir::ItemConst(..) => {\n+                EntryKind::Const(ty::queries::mir_const_qualif::get(tcx, item.span, def_id))\n+            }\n             hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n                     constness: constness,"}, {"sha": "4a20913d0b3fd19e16cef779f1817c42880f1a81", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -221,7 +221,7 @@ pub struct Entry<'tcx> {\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum EntryKind<'tcx> {\n-    Const,\n+    Const(u8),\n     ImmStatic,\n     MutStatic,\n     ForeignImmStatic,\n@@ -243,7 +243,7 @@ pub enum EntryKind<'tcx> {\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n     Method(Lazy<MethodData>),\n     AssociatedType(AssociatedContainer),\n-    AssociatedConst(AssociatedContainer),\n+    AssociatedConst(AssociatedContainer, u8),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "a97495a0ebcc43d09599dc6606455b2bc28477d4", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -53,3 +53,9 @@ pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n \n+use rustc::ty::maps::Providers;\n+\n+pub fn provide(providers: &mut Providers) {\n+    mir_map::provide(providers);\n+    transform::qualify_consts::provide(providers);\n+}"}, {"sha": "441a9add883ddfe9ca668f2704e99116aa335e24", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 71, "deletions": 76, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -16,61 +16,57 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n+use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n-use rustc::util::nodemap::DefIdMap;\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n-use std::collections::hash_map::Entry;\n use std::fmt;\n use std::usize;\n \n use super::promote_consts::{self, Candidate, TempState};\n \n bitflags! {\n     flags Qualif: u8 {\n-        // Const item's qualification while recursing.\n-        // Recursive consts are an error.\n-        const RECURSIVE         = 1 << 0,\n-\n         // Constant containing interior mutability (UnsafeCell).\n-        const MUTABLE_INTERIOR  = 1 << 1,\n+        const MUTABLE_INTERIOR  = 1 << 0,\n \n         // Constant containing an ADT that implements Drop.\n-        const NEEDS_DROP        = 1 << 2,\n+        const NEEDS_DROP        = 1 << 1,\n \n         // Function argument.\n-        const FN_ARGUMENT       = 1 << 3,\n+        const FN_ARGUMENT       = 1 << 2,\n \n         // Static lvalue or move from a static.\n-        const STATIC            = 1 << 4,\n+        const STATIC            = 1 << 3,\n \n         // Reference to a static.\n-        const STATIC_REF        = 1 << 5,\n+        const STATIC_REF        = 1 << 4,\n \n         // Not constant at all - non-`const fn` calls, asm!,\n         // pointer comparisons, ptr-to-int casts, etc.\n-        const NOT_CONST         = 1 << 6,\n+        const NOT_CONST         = 1 << 5,\n \n         // Refers to temporaries which cannot be promoted as\n         // promote_consts decided they weren't simple enough.\n-        const NOT_PROMOTABLE    = 1 << 7,\n+        const NOT_PROMOTABLE    = 1 << 6,\n \n         // Borrows of temporaries can be promoted only\n         // if they have none of the above qualifications.\n-        const NEVER_PROMOTE     = !0,\n+        const NEVER_PROMOTE     = 0b111_1111,\n \n         // Const items can only have MUTABLE_INTERIOR\n         // and NOT_PROMOTABLE without producing an error.\n@@ -134,7 +130,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     rpo: ReversePostorder<'a, 'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParameterEnvironment<'tcx>,\n-    qualif_map: &'a mut DefIdMap<Qualif>,\n     temp_qualif: IndexVec<Local, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n@@ -146,7 +141,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            param_env: ty::ParameterEnvironment<'tcx>,\n-           qualif_map: &'a mut DefIdMap<Qualif>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n@@ -162,7 +156,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             rpo: rpo,\n             tcx: tcx,\n             param_env: param_env,\n-            qualif_map: qualif_map,\n             temp_qualif: IndexVec::from_elem(None, &mir.local_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n@@ -585,17 +578,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if substs.types().next().is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n-                        let qualif = qualify_const_item_cached(self.tcx,\n-                                                               self.qualif_map,\n-                                                               def_id);\n-                        self.add(qualif);\n-                    }\n+                        let bits = ty::queries::mir_const_qualif::get(self.tcx,\n+                                                                      constant.span,\n+                                                                      def_id);\n \n-                    // FIXME(eddyb) check recursive constants here,\n-                    // instead of rustc_passes::static_recursion.\n-                    if self.qualif.intersects(Qualif::RECURSIVE) {\n-                        span_bug!(constant.span,\n-                                  \"recursive constant wasn't caught earlier\");\n+                        let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n+                        self.add(qualif);\n                     }\n \n                     // Let `const fn` transitively have destructors,\n@@ -944,41 +932,64 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n }\n \n-fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       qualif_map: &mut DefIdMap<Qualif>,\n-                                       def_id: DefId)\n-                                       -> Qualif {\n-    match qualif_map.entry(def_id) {\n-        Entry::Occupied(entry) => return *entry.get(),\n-        Entry::Vacant(entry) => {\n-            // Guard against `const` recursion.\n-            entry.insert(Qualif::RECURSIVE);\n-        }\n+pub fn provide(providers: &mut Providers) {\n+    providers.mir_const_qualif = qualify_const_item;\n+}\n+\n+fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                def_id: DefId)\n+                                -> u8 {\n+    let mir = &tcx.item_mir(def_id);\n+    if mir.return_ty.references_error() {\n+        return Qualif::NOT_CONST.bits();\n     }\n \n-    let param_env = if def_id.is_local() {\n-        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        ty::ParameterEnvironment::for_item(tcx, node_id)\n-    } else {\n-        // These should only be monomorphic constants.\n-        tcx.empty_parameter_environment()\n-    };\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n \n-    let mir = &tcx.item_mir(def_id);\n-    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, def_id, mir, Mode::Const);\n-    let qualif = qualifier.qualify_const();\n-    qualifier.qualif_map.insert(def_id, qualif);\n-    qualif\n+    let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, Mode::Const);\n+    qualifier.qualify_const().bits()\n }\n \n-#[derive(Default)]\n-pub struct QualifyAndPromoteConstants {\n-    qualif_map: DefIdMap<Qualif>\n-}\n+pub struct QualifyAndPromoteConstants;\n \n impl Pass for QualifyAndPromoteConstants {}\n \n-impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n+impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n+    fn run_pass<'a>(&mut self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n+    {\n+        let def_ids = tcx.maps.mir.borrow().keys();\n+        for def_id in def_ids {\n+            if !def_id.is_local() {\n+                continue;\n+            }\n+\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let src = MirSource::from_node(tcx, id);\n+\n+            if let MirSource::Const(_) = src {\n+                ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+                continue;\n+            }\n+\n+            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n+\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, false);\n+            }\n+            self.run_pass(tcx, src, mir);\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, true);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> QualifyAndPromoteConstants {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     src: MirSource, mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n@@ -991,18 +1002,9 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n                     Mode::Fn\n                 }\n             }\n-            MirSource::Const(_) => {\n-                match self.qualif_map.entry(def_id) {\n-                    Entry::Occupied(_) => return,\n-                    Entry::Vacant(entry) => {\n-                        // Guard against `const` recursion.\n-                        entry.insert(Qualif::RECURSIVE);\n-                        Mode::Const\n-                    }\n-                }\n-            }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+            MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n@@ -1012,7 +1014,6 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {\n                 let mut qualifier = Qualifier::new(tcx, param_env,\n-                                                   &mut self.qualif_map,\n                                                    def_id, mir, mode);\n                 if mode == Mode::ConstFn {\n                     // Enforce a constant-like CFG for `const fn`.\n@@ -1029,14 +1030,8 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n             // Do the actual promotion, now that we know what's viable.\n             promote_consts::promote_candidates(mir, tcx, temps, candidates);\n         } else {\n-            let mut qualifier = Qualifier::new(tcx, param_env,\n-                                               &mut self.qualif_map,\n-                                               def_id, mir, mode);\n-            let qualif = qualifier.qualify_const();\n-\n-            if mode == Mode::Const {\n-                qualifier.qualif_map.insert(def_id, qualif);\n-            }\n+            let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, mode);\n+            qualifier.qualify_const();\n         }\n \n         // Statics must be Sync."}, {"sha": "83166c9bd4b5e312c9dfab308c2c55c887abde15", "filename": "src/test/compile-fail/const-block-non-item-statement-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-2.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const A: usize = { 1; 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+const B: usize = { { } 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+macro_rules! foo {\n+    () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n+}\n+const C: usize = { foo!(); 2 };\n+\n+const D: usize = { let x = 4; 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+pub fn main() {}"}, {"sha": "bdc69c937c63780031f431cef0289674891359c8", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -8,21 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: usize = { 1; 2 };\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-\n-const B: usize = { { } 2 };\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-\n-macro_rules! foo {\n-    () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n-}\n-const C: usize = { foo!(); 2 };\n-\n-const D: usize = { let x = 4; 2 };\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-//~^^ ERROR: blocks in constants are limited to items and tail expressions\n-\n enum Foo {\n     Bar = { let x = 1; 3 }\n     //~^ ERROR: blocks in constants are limited to items and tail expressions\n@@ -33,8 +18,4 @@ type Array = [u32; {  let x = 2; 5 }];\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n //~^^ ERROR: blocks in constants are limited to items and tail expressions\n \n-pub fn main() {\n-    let _: Array = [0; { let x = 3; 5 }];\n-    //~^ ERROR: blocks in constants are limited to items and tail expressions\n-    //~^^ ERROR: blocks in constants are limited to items and tail expressions\n-}\n+pub fn main() {}"}, {"sha": "ff83dd004a257ccb2a9f9b76911bf796d89bd844", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -15,6 +15,8 @@ fn f(x: usize) -> usize {\n }\n \n fn main() {\n-    let _ = [0; f(2)]; //~ ERROR constant evaluation error [E0080]\n-                       //~| non-constant path in constant expression\n+    let _ = [0; f(2)];\n+    //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR constant evaluation error [E0080]\n+    //~| non-constant path in constant expression\n }"}, {"sha": "06e8406cbc0bd15c3b7d531cc82058a71ec82eef", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f0a949fd6b74641b12afc0f8a17f00919ebcef/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=d9f0a949fd6b74641b12afc0f8a17f00919ebcef", "patch": "@@ -27,9 +27,11 @@ pub struct Vector<T, D: Dim> {\n \n fn main() {\n     let array: [usize; Dim3::dim()]\n-    //~^ ERROR constant evaluation error\n+    //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR constant evaluation error\n     //~| non-constant path in constant expression\n         = [0; Dim3::dim()];\n-        //~^ ERROR constant evaluation error\n+        //~^ ERROR calls in constants are limited to constant functions\n+        //~| ERROR constant evaluation error\n         //~| non-constant path in constant expression\n }"}]}