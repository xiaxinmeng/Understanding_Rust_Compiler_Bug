{"sha": "fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZGNkMzE2YWY5ODU4M2ViZWJmYzQwZjZhMjViZWMzZjRlNWZjY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-05T19:32:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-05T19:32:14Z"}, "message": "Auto merge of #54743 - ljedrz:cleanup_ty_p2, r=zackmdavis\n\nCleanup rustc/ty part 2\n\nThe second part of cleanups and minor improvements for rustc/ty.\n- improve allocations\n- calculate span after a possible early continue\n- simplify some patterns\n- mark a comment as FIXME\n- whitespace fixes\n\nThe PR is independent from from the first part.", "tree": {"sha": "3dc67e106bb437f4cc63b4197e9681969db26ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dc67e106bb437f4cc63b4197e9681969db26ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "html_url": "https://github.com/rust-lang/rust/commit/fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2155f27b640c14d2f518a4585f7419ab9a334374", "url": "https://api.github.com/repos/rust-lang/rust/commits/2155f27b640c14d2f518a4585f7419ab9a334374", "html_url": "https://github.com/rust-lang/rust/commit/2155f27b640c14d2f518a4585f7419ab9a334374"}, {"sha": "04b99bc10390514832197b30c34a3993cd028092", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b99bc10390514832197b30c34a3993cd028092", "html_url": "https://github.com/rust-lang/rust/commit/04b99bc10390514832197b30c34a3993cd028092"}], "stats": {"total": 324, "additions": 146, "deletions": 178}, "files": [{"sha": "f54dcfa37e944021697c6275ed7a8373ec64d34d", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -782,11 +782,10 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match *r {\n-            ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n+        if let ty::ReLateBound(debruijn, br) = *r {\n+             if debruijn == self.current_index {\n                 self.regions.insert(br);\n             }\n-            _ => { }\n         }\n         false\n     }"}, {"sha": "3d205215d64c60ef121690b25703720520b1bc1d", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -231,11 +231,11 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_closure(\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    def_id: DefId,\n-                    substs: ty::ClosureSubsts<'tcx>,\n-                    requested_kind: ty::ClosureKind)\n-    -> Instance<'tcx>\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        def_id: DefId,\n+        substs: ty::ClosureSubsts<'tcx>,\n+        requested_kind: ty::ClosureKind)\n+        -> Instance<'tcx>\n     {\n         let actual_kind = substs.closure_kind(def_id, tcx);\n \n@@ -255,8 +255,8 @@ fn resolve_associated_item<'a, 'tcx>(\n ) -> Option<Instance<'tcx>> {\n     let def_id = trait_item.def_id;\n     debug!(\"resolve_associated_item(trait_item={:?}, \\\n-                                    trait_id={:?}, \\\n-           rcvr_substs={:?})\",\n+            trait_id={:?}, \\\n+            rcvr_substs={:?})\",\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n@@ -280,7 +280,7 @@ fn resolve_associated_item<'a, 'tcx>(\n         traits::VtableClosure(closure_data) => {\n             let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n             Some(Instance::resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n-                                 trait_closure_kind))\n+                                           trait_closure_kind))\n         }\n         traits::VtableFnPointer(ref data) => {\n             Some(Instance {\n@@ -310,7 +310,7 @@ fn resolve_associated_item<'a, 'tcx>(\n }\n \n fn needs_fn_once_adapter_shim<'a, 'tcx>(actual_closure_kind: ty::ClosureKind,\n-                              trait_closure_kind: ty::ClosureKind)\n+                                        trait_closure_kind: ty::ClosureKind)\n     -> Result<bool, ()>\n {\n     match (actual_closure_kind, trait_closure_kind) {\n@@ -344,13 +344,14 @@ fn needs_fn_once_adapter_shim<'a, 'tcx>(actual_closure_kind: ty::ClosureKind,\n }\n \n fn fn_once_adapter_instance<'a, 'tcx>(\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            closure_did: DefId,\n-                            substs: ty::ClosureSubsts<'tcx>,\n-                            ) -> Instance<'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    closure_did: DefId,\n+    substs: ty::ClosureSubsts<'tcx>)\n+    -> Instance<'tcx>\n+{\n     debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n-    closure_did,\n-    substs);\n+           closure_did,\n+           substs);\n     let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n     let call_once = tcx.associated_items(fn_once)\n         .find(|it| it.kind == ty::AssociatedKind::Method)"}, {"sha": "ab0813240364c687c855d7108da3ec9ef268e4a6", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             let data = cur_def_key.disambiguated_data.data;\n             let symbol = data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                if let DefPathData::CrateRoot = data {  // reexported `extern crate` (#43189)\n+                if let DefPathData::CrateRoot = data { // reexported `extern crate` (#43189)\n                     self.original_crate_name(cur_def.krate).as_str()\n                 } else {\n                     Symbol::intern(\"<unnamed>\").as_str()\n@@ -365,9 +365,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(trait_ref) = impl_trait_ref {\n             // Trait impls.\n-            buffer.push(&format!(\"<{} as {}>\",\n-                                 self_ty,\n-                                 trait_ref));\n+            buffer.push(&format!(\"<{} as {}>\", self_ty, trait_ref));\n             return;\n         }\n "}, {"sha": "05d4aeb6ddec4b0fa2964e409f52860a50d623bf", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -32,11 +32,11 @@ pub trait IntegerExt {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: C, ity: attr::IntType) -> Integer;\n     fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                  ty: Ty<'tcx>,\n-                  repr: &ReprOptions,\n-                  min: i128,\n-                  max: i128)\n-                  -> (Integer, bool);\n+                            ty: Ty<'tcx>,\n+                            repr: &ReprOptions,\n+                            min: i128,\n+                            max: i128)\n+                            -> (Integer, bool);\n }\n \n impl IntegerExt for Integer {\n@@ -76,11 +76,11 @@ impl IntegerExt for Integer {\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n     fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                  ty: Ty<'tcx>,\n-                  repr: &ReprOptions,\n-                  min: i128,\n-                  max: i128)\n-                  -> (Integer, bool) {\n+                            ty: Ty<'tcx>,\n+                            repr: &ReprOptions,\n+                            min: i128,\n+                            max: i128)\n+                            -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u128\n@@ -96,7 +96,7 @@ impl IntegerExt for Integer {\n             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n             if discr < fit {\n                 bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                  discriminant range of enum `{}\", ty)\n+                      discriminant range of enum `{}\", ty)\n             }\n             return (discr, ity.is_signed());\n         }\n@@ -106,7 +106,7 @@ impl IntegerExt for Integer {\n                 // WARNING: the ARM EABI has two variants; the one corresponding\n                 // to `at_least == I32` appears to be used on Linux and NetBSD,\n                 // but some systems may use the variant corresponding to no\n-                // lower bound.  However, we don't run on those yet...?\n+                // lower bound. However, we don't run on those yet...?\n                 \"arm\" => min_from_extern = Some(I32),\n                 _ => min_from_extern = Some(I32),\n             }\n@@ -250,6 +250,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n             Prefixed(Size, Align),\n         }\n+\n         let univariant_uninterned = |fields: &[TyLayout<'_>], repr: &ReprOptions, kind| {\n             let packed = repr.packed();\n             if packed && repr.align > 0 {\n@@ -324,7 +325,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let field = fields[i as usize];\n                 if !sized {\n                     bug!(\"univariant: field #{} of `{}` comes after unsized field\",\n-                        offsets.len(), ty);\n+                         offsets.len(), ty);\n                 }\n \n                 if field.is_unsized() {\n@@ -628,7 +629,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 };\n \n                 univariant(&tys.iter().map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(), kind)?\n+                           &ReprOptions::default(), kind)?\n             }\n \n             // SIMD vector types.\n@@ -640,7 +641,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     Abi::Scalar(ref scalar) => scalar.clone(),\n                     _ => {\n                         tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                                a non-machine element type `{}`\",\n+                                                 a non-machine element type `{}`\",\n                                                 ty, element.ty));\n                     }\n                 };\n@@ -743,7 +744,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     // Only one variant is present.\n                     (present_second.is_none() &&\n                     // Representation optimizations are allowed.\n-                     !def.repr.inhibit_enum_layout_opt());\n+                    !def.repr.inhibit_enum_layout_opt());\n                 if is_struct {\n                     // Struct, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n@@ -755,7 +756,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         let param_env = tcx.param_env(def.did);\n                         let last_field = def.variants[v].fields.last().unwrap();\n                         let always_sized = tcx.type_of(last_field.did)\n-                          .is_sized(tcx.at(DUMMY_SP), param_env);\n+                                              .is_sized(tcx.at(DUMMY_SP), param_env);\n                         if !always_sized { StructKind::MaybeUnsized }\n                         else { StructKind::AlwaysSized }\n                     };\n@@ -1258,8 +1259,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         let fields: Vec<_> =\n                             variant_def.fields.iter().map(|f| f.ident.name).collect();\n                         build_variant_info(Some(variant_def.name),\n-                                            &fields,\n-                                            layout.for_variant(self, i))\n+                                           &fields,\n+                                           layout.for_variant(self, i))\n                     })\n                     .collect();\n                 record(adt_kind.into(), adt_packed, match layout.variants {"}, {"sha": "2e8734a6aa8ebf730e5979b8ed7a40a0f65a7dd8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -862,24 +862,22 @@ pub struct GenericParamDef {\n \n impl GenericParamDef {\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n-        match self.kind {\n-            GenericParamDefKind::Lifetime => {\n-                ty::EarlyBoundRegion {\n-                    def_id: self.def_id,\n-                    index: self.index,\n-                    name: self.name,\n-                }\n+        if let GenericParamDefKind::Lifetime = self.kind {\n+            ty::EarlyBoundRegion {\n+                def_id: self.def_id,\n+                index: self.index,\n+                name: self.name,\n             }\n-            _ => bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n+        } else {\n+            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n \n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        match self.kind {\n-            GenericParamDefKind::Lifetime => {\n-                self.to_early_bound_region_data().to_bound_region()\n-            }\n-            _ => bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n+        if let GenericParamDefKind::Lifetime = self.kind {\n+            self.to_early_bound_region_data().to_bound_region()\n+        } else {\n+            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n }\n@@ -957,7 +955,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n             }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n-                .region_param(param, tcx)\n+               .region_param(param, tcx)\n         }\n     }\n \n@@ -974,7 +972,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n             }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n-                .type_param(param, tcx)\n+               .type_param(param, tcx)\n         }\n     }\n }\n@@ -1376,7 +1374,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n         };\n \n-        // The only reason to collect into a vector here is that I was\n+        // FIXME: The only reason to collect into a vector here is that I was\n         // too lazy to make the full (somewhat complicated) iterator\n         // type that would be needed here. But I wanted this fn to\n         // return an iterator conceptually, rather than a `Vec`, so as\n@@ -2224,7 +2222,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 if !expr_did.is_local() {\n                     span_bug!(tcx.def_span(expr_did),\n                         \"variant discriminant evaluation succeeded \\\n-                            in its crate but failed locally\");\n+                         in its crate but failed locally\");\n                 }\n                 None\n             }\n@@ -2360,9 +2358,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_tys);\n                 adt_tys.iter()\n-                    .map(|ty| ty.subst(tcx, substs))\n-                    .flat_map(|ty| self.sized_constraint_for_ty(tcx, ty))\n-                    .collect()\n+                       .map(|ty| ty.subst(tcx, substs))\n+                       .flat_map(|ty| self.sized_constraint_for_ty(tcx, ty))\n+                       .collect()\n             }\n \n             Projection(..) | Opaque(..) => {\n@@ -2903,9 +2901,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> AssociatedItem\n-{\n+fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssociatedItem {\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let parent_id = tcx.hir.get_parent(id);\n     let parent_def_id = tcx.hir.local_def_id(parent_id);\n@@ -3019,8 +3015,8 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n /// See `ParamEnv` struct def'n for details.\n fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        def_id: DefId)\n-                       -> ParamEnv<'tcx> {\n-\n+                       -> ParamEnv<'tcx>\n+{\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n         return param_env(tcx, parent);"}, {"sha": "b49664b6247332a16e7c799a43428ad2fd6bd8ac", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -73,7 +73,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // projection).\n         match ty.sty {\n             ty::Closure(def_id, ref substs) => {\n-\n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n@@ -183,9 +182,5 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n-    for r in regions {\n-        if !r.is_late_bound() {\n-            out.push(Component::Region(r));\n-        }\n-    }\n+    out.extend(regions.iter().filter(|&r| !r.is_late_bound()).map(|r| Component::Region(r)));\n }"}, {"sha": "082c1bd5fea441be7f8d46f01d92b1dbb2f109ee", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -274,9 +274,10 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n         if a.len() != b.len() {\n             Err(TypeError::ProjectionBoundsLength(expected_found(relation, &a.len(), &b.len())))\n         } else {\n-            a.iter().zip(b)\n-                .map(|(a, b)| relation.relate(a, b))\n-                .collect()\n+            a.iter()\n+             .zip(b)\n+             .map(|(a, b)| relation.relate(a, b))\n+             .collect()\n         }\n     }\n }\n@@ -331,7 +332,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n                            -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        assert!(a.0.len() == b.0.len());\n+        assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n         let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n         Ok(GeneratorWitness(types))\n@@ -478,27 +479,24 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                     ConstValue::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty();\n-                        match tcx.lift_to_global(&substs) {\n-                            Some(substs) => {\n-                                let instance = ty::Instance::resolve(\n-                                    tcx.global_tcx(),\n-                                    param_env,\n-                                    def_id,\n-                                    substs,\n-                                );\n-                                if let Some(instance) = instance {\n-                                    let cid = GlobalId {\n-                                        instance,\n-                                        promoted: None\n-                                    };\n-                                    if let Some(s) = tcx.const_eval(param_env.and(cid))\n-                                                        .ok()\n-                                                        .map(|c| c.unwrap_usize(tcx)) {\n-                                        return Ok(s)\n-                                    }\n+                        if let Some(substs) = tcx.lift_to_global(&substs) {\n+                            let instance = ty::Instance::resolve(\n+                                tcx.global_tcx(),\n+                                param_env,\n+                                def_id,\n+                                substs,\n+                            );\n+                            if let Some(instance) = instance {\n+                                let cid = GlobalId {\n+                                    instance,\n+                                    promoted: None\n+                                };\n+                                if let Some(s) = tcx.const_eval(param_env.and(cid))\n+                                                    .ok()\n+                                                    .map(|c| c.unwrap_usize(tcx)) {\n+                                    return Ok(s)\n                                 }\n-                            },\n-                            None => {}\n+                            }\n                         }\n                         tcx.sess.delay_span_bug(tcx.def_span(def_id),\n                             \"array length could not be evaluated\");"}, {"sha": "83a9491cf4673c57cc6629775a8d9c0c3a6d9b0c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -386,12 +386,12 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.yield_ty, self.return_ty))\n-            .map(|(yield_ty, return_ty)| {\n-                ty::GenSig {\n-                    yield_ty,\n-                    return_ty,\n-                }\n-            })\n+           .map(|(yield_ty, return_ty)| {\n+               ty::GenSig {\n+                   yield_ty,\n+                   return_ty,\n+               }\n+           })\n     }\n }\n \n@@ -452,7 +452,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n-\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             OldStyleLUB(ref x) => return tcx.lift(x).map(OldStyleLUB),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n@@ -817,22 +816,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n         use ty::InstanceDef::*;\n         self.substs.visit_with(visitor) ||\n         match self.def {\n-            Item(did) => did.visit_with(visitor),\n-            Intrinsic(did) => did.visit_with(visitor),\n-            FnPtrShim(did, ty) => {\n-                did.visit_with(visitor) ||\n-                ty.visit_with(visitor)\n+            Item(did) | Intrinsic(did) | Virtual(did, _) => {\n+                did.visit_with(visitor)\n             },\n-            Virtual(did, _) => did.visit_with(visitor),\n-            ClosureOnceShim { call_once } => call_once.visit_with(visitor),\n-            DropGlue(did, ty) => {\n-                did.visit_with(visitor) ||\n-                ty.visit_with(visitor)\n+            FnPtrShim(did, ty) | CloneShim(did, ty) => {\n+                did.visit_with(visitor) || ty.visit_with(visitor)\n             },\n-            CloneShim(did, ty) => {\n-                did.visit_with(visitor) ||\n-                ty.visit_with(visitor)\n+            DropGlue(did, ty) => {\n+                did.visit_with(visitor) || ty.visit_with(visitor)\n             },\n+            ClosureOnceShim { call_once } => call_once.visit_with(visitor),\n         }\n     }\n }"}, {"sha": "8a3e853a822d7fb2e562cd81ae586cfab77f7c77", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -992,11 +992,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `idx != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        if self.name == keywords::SelfType.name().as_str() && self.idx == 0 {\n-            true\n-        } else {\n-            false\n-        }\n+        self.name == keywords::SelfType.name().as_str() && self.idx == 0\n     }\n }\n \n@@ -2043,18 +2039,14 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'_, '_, '_>,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> u128 {\n-        match self.assert_bits(tcx, ty) {\n-            Some(val) => val,\n-            None => bug!(\"expected bits of {}, got {:#?}\", ty.value, self),\n-        }\n+        self.assert_bits(tcx, ty).unwrap_or_else(||\n+            bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n     }\n \n     #[inline]\n     pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n-        match self.assert_usize(tcx) {\n-            Some(val) => val,\n-            None => bug!(\"expected constant usize, got {:#?}\", self),\n-        }\n+        self.assert_usize(tcx).unwrap_or_else(||\n+            bug!(\"expected constant usize, got {:#?}\", self))\n     }\n }\n "}, {"sha": "c0a42fd5854822a0b49a1d3cb97536f32d136248", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -205,10 +205,9 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n         Substs::for_item(tcx, def_id, |param, substs| {\n-            match self.get(param.index as usize) {\n-                Some(&kind) => kind,\n-                None => mk_kind(param, substs),\n-            }\n+            self.get(param.index as usize)\n+                .cloned()\n+                .unwrap_or_else(|| mk_kind(param, substs))\n         })\n     }\n \n@@ -230,6 +229,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                       mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n+        substs.reserve(defs.params.len());\n         for param in &defs.params {\n             let kind = mk_kind(param, substs);\n             assert_eq!(param.index as usize, substs.len());\n@@ -361,7 +361,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n pub trait Subst<'tcx> : Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      substs: &[Kind<'tcx>]) -> Self {\n+                       substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n                 span_bug!(\n                     span,\n                     \"Type parameter `{:?}` ({:?}/{}) out of range \\\n-                         when substituting (root type={:?}) substs={:?}\",\n+                     when substituting (root type={:?}) substs={:?}\",\n                     p,\n                     source_ty,\n                     p.idx,"}, {"sha": "af678c3e9924b7d20fca9cfb46225b3a7c8d3f90", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -138,10 +138,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         } else {\n-            for v in impls.non_blanket_impls.values() {\n-                for &impl_def_id in v {\n-                    f(impl_def_id);\n-                }\n+            for &impl_def_id in impls.non_blanket_impls.values().flatten() {\n+                f(impl_def_id);\n             }\n         }\n     }\n@@ -173,9 +171,9 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 fast_reject::simplify_type(tcx, impl_self_ty, false)\n             {\n                 impls.non_blanket_impls\n-                    .entry(simplified_self_ty)\n-                    .or_default()\n-                    .push(impl_def_id);\n+                     .entry(simplified_self_ty)\n+                     .or_default()\n+                     .push(impl_def_id);\n             } else {\n                 impls.blanket_impls.push(impl_def_id);\n             }"}, {"sha": "dfe42e0c6610904e579161e2cc5e6b2d27c0bcc3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -119,17 +119,17 @@ pub trait IntTypeExt {\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n-            SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n-            SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n-            SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n-            SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::I8)       => tcx.types.i8,\n+            SignedInt(ast::IntTy::I16)      => tcx.types.i16,\n+            SignedInt(ast::IntTy::I32)      => tcx.types.i32,\n+            SignedInt(ast::IntTy::I64)      => tcx.types.i64,\n             SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n-            SignedInt(ast::IntTy::Isize)   => tcx.types.isize,\n+            SignedInt(ast::IntTy::Isize)    => tcx.types.isize,\n             UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n             UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n             UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n             UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n-            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n+            UnsignedInt(ast::UintTy::U128)  => tcx.types.u128,\n             UnsignedInt(ast::UintTy::Usize) => tcx.types.usize,\n         }\n     }\n@@ -205,11 +205,11 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n             let mut infringing = Vec::new();\n             for variant in &adt.variants {\n                 for field in &variant.fields {\n-                    let span = tcx.def_span(field.did);\n                     let ty = field.ty(tcx, substs);\n                     if ty.references_error() {\n                         continue;\n                     }\n+                    let span = tcx.def_span(field.did);\n                     let cause = ObligationCause { span, ..ObligationCause::dummy() };\n                     let ctx = traits::FulfillmentContext::new();\n                     match traits::fully_normalize(&infcx, ctx, cause, self, &ty) {\n@@ -257,16 +257,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::Adt(def, substs) => {\n-                for field in def.all_fields() {\n-                    let field_ty = field.ty(self, substs);\n-                    if let Error = field_ty.sty {\n-                        return true;\n-                    }\n+        if let ty::Adt(def, substs) = ty.sty {\n+            for field in def.all_fields() {\n+                let field_ty = field.ty(self, substs);\n+                if let Error = field_ty.sty {\n+                    return true;\n                 }\n             }\n-            _ => (),\n         }\n         false\n     }\n@@ -421,7 +418,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let ty = self.type_of(adt_did);\n         self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n             if let Some(item) = self.associated_items(impl_did).next() {\n-                if let Ok(()) = validate(self, impl_did) {\n+                if validate(self, impl_did).is_ok() {\n                     dtor_did = Some(item.def_id);\n                 }\n             }\n@@ -513,7 +510,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         false\n                     }\n                 }\n-            }).map(|(&item_param, _)| item_param).collect();\n+            })\n+            .map(|(&item_param, _)| item_param)\n+            .collect();\n         debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n         result\n     }\n@@ -674,8 +673,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn is_representable(&'tcx self,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span)\n-                            -> Representability {\n-\n+                            -> Representability\n+    {\n         // Iterate until something non-representable is found\n         fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n             iter.fold(Representability::Representable, |r1, r2| {\n@@ -904,20 +903,17 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {\n-        match tcx.try_needs_drop_raw(DUMMY_SP, param_env.and(ty)) {\n-            Ok(v) => v,\n-            Err(mut bug) => {\n-                // Cycles should be reported as an error by `check_representable`.\n-                //\n-                // Consider the type as not needing drop in the meanwhile to\n-                // avoid further errors.\n-                //\n-                // In case we forgot to emit a bug elsewhere, delay our\n-                // diagnostic to get emitted as a compiler bug.\n-                bug.delay_as_bug();\n-                false\n-            }\n-        }\n+        tcx.try_needs_drop_raw(DUMMY_SP, param_env.and(ty)).unwrap_or_else(|mut bug| {\n+            // Cycles should be reported as an error by `check_representable`.\n+            //\n+            // Consider the type as not needing drop in the meanwhile to\n+            // avoid further errors.\n+            //\n+            // In case we forgot to emit a bug elsewhere, delay our\n+            // diagnostic to get emitted as a compiler bug.\n+            bug.delay_as_bug();\n+            false\n+        })\n     };\n \n     assert!(!ty.needs_infer());"}, {"sha": "47fbfba87748ba073270d06b01e64e0db7ce2cb2", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n         debug!(\"next(): stack={:?}\", self.stack);\n         match self.stack.pop() {\n             None => {\n-                return None;\n+                None\n             }\n             Some(ty) => {\n                 self.last_subtree = self.stack.len();"}, {"sha": "7af838845cd61ee916677ff32ad37619bd5a3b4f", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddcd316af98583ebebfc40f6a25bec3f4e5fccc/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=fddcd316af98583ebebfc40f6a25bec3f4e5fccc", "patch": "@@ -223,8 +223,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n             let predicate = ty::Predicate::ConstEvaluatable(def_id, substs);\n             let cause = self.cause(traits::MiscObligation);\n             self.out.push(traits::Obligation::new(cause,\n-                                                    self.param_env,\n-                                                    predicate));\n+                                                  self.param_env,\n+                                                  predicate));\n         }\n     }\n \n@@ -495,6 +495,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n             let explicit_bound = region;\n \n+            self.out.reserve(implicit_bounds.len());\n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives = ty::Binder::dummy("}]}