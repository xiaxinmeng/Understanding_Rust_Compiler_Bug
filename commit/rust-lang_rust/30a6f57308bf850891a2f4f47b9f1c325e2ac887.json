{"sha": "30a6f57308bf850891a2f4f47b9f1c325e2ac887", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTZmNTczMDhiZjg1MDg5MWEyZjRmNDdiOWYxYzMyNWUyYWM4ODc=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-07-15T07:03:53Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-07-30T11:59:02Z"}, "message": "Handle structs with zst members.", "tree": {"sha": "29bd3b755ab95e2d60d4b11ae5a9f90446f2a46a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29bd3b755ab95e2d60d4b11ae5a9f90446f2a46a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a6f57308bf850891a2f4f47b9f1c325e2ac887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a6f57308bf850891a2f4f47b9f1c325e2ac887", "html_url": "https://github.com/rust-lang/rust/commit/30a6f57308bf850891a2f4f47b9f1c325e2ac887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a6f57308bf850891a2f4f47b9f1c325e2ac887/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "060666d0a4cb814328990d271ae9741f2d20cb0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/060666d0a4cb814328990d271ae9741f2d20cb0d", "html_url": "https://github.com/rust-lang/rust/commit/060666d0a4cb814328990d271ae9741f2d20cb0d"}], "stats": {"total": 51, "additions": 28, "deletions": 23}, "files": [{"sha": "de750010ed1e6e1af3a4557d615508191e424809", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/30a6f57308bf850891a2f4f47b9f1c325e2ac887/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a6f57308bf850891a2f4f47b9f1c325e2ac887/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=30a6f57308bf850891a2f4f47b9f1c325e2ac887", "patch": "@@ -11,7 +11,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n@@ -556,25 +556,26 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n         _ => false,\n     }\n }\n-/// Given a potentially non-null type `ty`, return its default, nullable type.\n-fn get_nullable_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.kind {\n+/// Given a non-null scalar (or transparent) type `ty`, return the nullable version of that type.\n+/// If the type passed in was not scalar, returns None.\n+fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    let tcx = cx.tcx;\n+    Some(match ty.kind {\n         ty::Adt(field_def, field_substs) => {\n-            let field_variants = &field_def.variants;\n-            // We hit this case for #[repr(transparent)] structs with a single\n-            // field.\n-            debug_assert!(\n-                field_variants.len() == 1 && field_variants[VariantIdx::new(0)].fields.len() == 1,\n-                \"inner ty not a newtype struct\"\n-            );\n-            debug_assert!(field_def.repr.transparent(), \"inner ty not transparent\");\n-            // As it's easy to get this wrong, it's worth noting that\n-            // `inner_field_ty` is not the same as `field_ty`: Given Option<S>,\n-            // where S is a transparent newtype of some type T, `field_ty`\n-            // gives us S, while `inner_field_ty` is T.\n-            let inner_field_ty =\n-                field_def.variants[VariantIdx::new(0)].fields[0].ty(tcx, field_substs);\n-            get_nullable_type(tcx, inner_field_ty)\n+            let inner_field_ty = {\n+                let first_non_zst_ty =\n+                    field_def.variants.iter().filter_map(|v| v.transparent_newtype_field(tcx));\n+                debug_assert_eq!(\n+                    first_non_zst_ty.clone().count(),\n+                    1,\n+                    \"Wrong number of fields for transparent type\"\n+                );\n+                first_non_zst_ty\n+                    .last()\n+                    .expect(\"No non-zst fields in transparent type.\")\n+                    .ty(tcx, field_substs)\n+            };\n+            return get_nullable_type(cx, inner_field_ty);\n         }\n         ty::Int(ty) => tcx.mk_mach_int(ty),\n         ty::Uint(ty) => tcx.mk_mach_uint(ty),\n@@ -591,9 +592,13 @@ fn get_nullable_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         // We should only ever reach this case if ty_is_known_nonnull is extended\n         // to other types.\n         ref unhandled => {\n-            unreachable!(\"Unhandled scalar kind: {:?} while checking {:?}\", unhandled, ty)\n+            debug!(\n+                \"get_nullable_type: Unhandled scalar kind: {:?} while checking {:?}\",\n+                unhandled, ty\n+            );\n+            return None;\n         }\n-    }\n+    })\n }\n \n /// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If it\n@@ -643,9 +648,9 @@ crate fn repr_nullable_ptr<'tcx>(\n         let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n         if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n             match (field_ty_scalar.valid_range.start(), field_ty_scalar.valid_range.end()) {\n-                (0, _) => bug!(\"Non-null optimisation extended to a non-zero value.\"),\n+                (0, _) => unreachable!(\"Non-null optimisation extended to a non-zero value.\"),\n                 (1, _) => {\n-                    return Some(get_nullable_type(cx.tcx, field_ty));\n+                    return Some(get_nullable_type(cx, field_ty).unwrap());\n                 }\n                 (start, end) => unreachable!(\"Unhandled start and end range: ({}, {})\", start, end),\n             };"}]}