{"sha": "5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNjlhNGY2MTlmYjRmNzFmMjQ5N2Y3ZWU0YTI1YTM0YTM3NGRhNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-12T08:06:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-12T08:06:34Z"}, "message": "Auto merge of #34755 - jonas-schievink:minor-differences, r=eddyb\n\nMove variant_size_differences out of trans\n\nAlso enhances the error message a bit, fixes #30505 on the way, and adds\na test (which was missing).\n\nCloses #34018", "tree": {"sha": "8f963605d1c5da5cb3ec933e2e09c36f8b2aea49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f963605d1c5da5cb3ec933e2e09c36f8b2aea49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "html_url": "https://github.com/rust-lang/rust/commit/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2539c15b49530e882a3e8803b3f53a7914d367be", "url": "https://api.github.com/repos/rust-lang/rust/commits/2539c15b49530e882a3e8803b3f53a7914d367be", "html_url": "https://github.com/rust-lang/rust/commit/2539c15b49530e882a3e8803b3f53a7914d367be"}, {"sha": "fd2b65ee701d424f0f2dbdbb89b5eba5fb9bace4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd2b65ee701d424f0f2dbdbb89b5eba5fb9bace4", "html_url": "https://github.com/rust-lang/rust/commit/fd2b65ee701d424f0f2dbdbb89b5eba5fb9bace4"}], "stats": {"total": 389, "additions": 135, "deletions": 254}, "files": [{"sha": "3230a08c27630bbbd4095a1792d24630265350a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -94,12 +94,6 @@ declare_lint! {\n     \"unknown crate type found in #[crate_type] directive\"\n }\n \n-declare_lint! {\n-    pub VARIANT_SIZE_DIFFERENCES,\n-    Allow,\n-    \"detects enums with widely varying variant sizes\"\n-}\n-\n declare_lint! {\n     pub FAT_PTR_TRANSMUTES,\n     Allow,\n@@ -230,7 +224,6 @@ impl LintPass for HardwiredLints {\n             UNUSED_FEATURES,\n             STABLE_FEATURES,\n             UNKNOWN_CRATE_TYPES,\n-            VARIANT_SIZE_DIFFERENCES,\n             FAT_PTR_TRANSMUTES,\n             TRIVIAL_CASTS,\n             TRIVIAL_NUMERIC_CASTS,"}, {"sha": "ce3d72de9ae99a5378cfbbf598833ae4e7cda408", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -29,13 +29,12 @@ use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n use ty::TyCtxt;\n use session::{config, early_error, Session};\n-use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass};\n-use lint::{EarlyLintPassObject, LateLintPass, LateLintPassObject};\n+use lint::{Level, LevelSource, Lint, LintId, LintPass};\n+use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n use util::nodemap::FnvHashMap;\n \n-use std::cell::RefCell;\n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n@@ -311,10 +310,6 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// levels, this stack keeps track of the previous lint levels of whatever\n     /// was modified.\n     level_stack: Vec<(LintId, LevelSource)>,\n-\n-    /// Level of lints for certain NodeIds, stored here because the body of\n-    /// the lint needs to run in trans.\n-    node_levels: RefCell<FnvHashMap<(ast::NodeId, LintId), LevelSource>>,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -664,7 +659,6 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             access_levels: access_levels,\n             lints: lint_store,\n             level_stack: vec![],\n-            node_levels: RefCell::new(FnvHashMap()),\n         }\n     }\n \n@@ -1064,38 +1058,6 @@ impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n     }\n }\n \n-// This lint pass is defined here because it touches parts of the `LateContext`\n-// that we don't want to expose. It records the lint level at certain AST\n-// nodes, so that the variant size difference check in trans can call\n-// `raw_emit_lint`.\n-\n-pub struct GatherNodeLevels;\n-\n-impl LintPass for GatherNodeLevels {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!()\n-    }\n-}\n-\n-impl LateLintPass for GatherNodeLevels {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match it.node {\n-            hir::ItemEnum(..) => {\n-                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n-                let lvlsrc = cx.lints.get_level_source(lint_id);\n-                match lvlsrc {\n-                    (lvl, _) if lvl != Allow => {\n-                        cx.node_levels.borrow_mut()\n-                            .insert((it.id, lint_id), lvlsrc);\n-                    },\n-                    _ => { }\n-                }\n-            },\n-            _ => { }\n-        }\n-    }\n-}\n-\n enum CheckLintNameResult {\n     Ok,\n     // Lint doesn't exist\n@@ -1234,8 +1196,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n-\n     // Put the lint store back in the session.\n     mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), cx.lints);\n }"}, {"sha": "121033549c0d5b0554c208a6551dca5d6e2bf766", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -41,7 +41,7 @@ use hir;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        raw_struct_lint, GatherNodeLevels, FutureIncompatibleInfo};\n+                        raw_struct_lint, FutureIncompatibleInfo};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "ab9a0fcb19b97eff6f16872d5d7e519b7600a1ed", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -727,8 +727,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"load extra plugins\"),\n     unstable_options: bool = (false, parse_bool,\n           \"adds unstable command line options to rustc interface\"),\n-    print_enum_sizes: bool = (false, parse_bool,\n-          \"print the size of enums and their variants\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n           \"force overflow checks on or off\"),\n     force_dropflag_checks: Option<bool> = (None, parse_opt_bool,"}, {"sha": "0e516bdc21194b3c9d5ce473d0e8a9228f871aab", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -304,9 +304,6 @@ impl Session {\n     pub fn unstable_options(&self) -> bool {\n         self.opts.debugging_opts.unstable_options\n     }\n-    pub fn print_enum_sizes(&self) -> bool {\n-        self.opts.debugging_opts.print_enum_sizes\n-    }\n     pub fn nonzeroing_move_hints(&self) -> bool {\n         self.opts.debugging_opts.enable_nonzeroing_move_hints\n     }"}, {"sha": "56938a7a838588d0e0c5d757b1eab9e877e4b763", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -12,7 +12,6 @@\n \n use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n-use lint;\n use middle;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::DefMap;\n@@ -415,9 +414,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Cache used by const_eval when decoding extern const fns\n     pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n \n-    pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n-                                              lint::LevelSource>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -726,7 +722,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n-            node_lint_levels: RefCell::new(FnvHashMap()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),"}, {"sha": "7b0ee91b69ed0848b82a16252df2905469e3976c", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -108,6 +108,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  HardwiredLints,\n                  WhileTrue,\n                  ImproperCTypes,\n+                 VariantSizeDifferences,\n                  BoxPointers,\n                  UnusedAttributes,\n                  PathStatements,\n@@ -209,9 +210,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         },\n         ]);\n \n-    // We have one lint pass defined specially\n-    store.register_late_pass(sess, false, box lint::GatherNodeLevels);\n-\n     // Register renamed and removed lints\n     store.register_renamed(\"unknown_features\", \"unused_features\");\n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");"}, {"sha": "9b08ddcafab8e7d9e773a2d81e85dd15f2549a21", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -13,6 +13,8 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{Layout, Primitive};\n+use rustc::traits::ProjectionMode;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n@@ -76,6 +78,12 @@ declare_lint! {\n     \"shift exceeds the type's number of bits\"\n }\n \n+declare_lint! {\n+    VARIANT_SIZE_DIFFERENCES,\n+    Allow,\n+    \"detects enums with widely varying variant sizes\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n@@ -675,3 +683,64 @@ impl LateLintPass for ImproperCTypes {\n         }\n     }\n }\n+\n+pub struct VariantSizeDifferences;\n+\n+impl LintPass for VariantSizeDifferences {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(VARIANT_SIZE_DIFFERENCES)\n+    }\n+}\n+\n+impl LateLintPass for VariantSizeDifferences {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n+            if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n+                let t = cx.tcx.node_id_to_type(it.id);\n+                let layout = cx.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+                    t.layout(&infcx).unwrap_or_else(|e| {\n+                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n+                    })\n+                });\n+\n+                if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n+                    let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n+\n+                    debug!(\"enum `{}` is {} bytes large\", t, size.bytes());\n+\n+                    let (largest, slargest, largest_index) = enum_definition.variants\n+                        .iter()\n+                        .zip(variants)\n+                        .map(|(variant, variant_layout)| {\n+                            // Subtract the size of the enum discriminant\n+                            let bytes = variant_layout.min_size().bytes()\n+                                                                 .saturating_sub(discr_size);\n+\n+                            debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n+                            bytes\n+                        })\n+                        .enumerate()\n+                        .fold((0, 0, 0),\n+                            |(l, s, li), (idx, size)|\n+                                if size > l {\n+                                    (size, l, idx)\n+                                } else if size > s {\n+                                    (l, size, li)\n+                                } else {\n+                                    (l, s, li)\n+                                }\n+                        );\n+\n+                    // we only warn if the largest variant is at least thrice as large as\n+                    // the second-largest.\n+                    if largest > slargest * 3 && slargest > 0 {\n+                        cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n+                                     enum_definition.variants[largest_index].span,\n+                                     &format!(\"enum variant is more than three times larger \\\n+                                               ({} bytes) than the next largest\", largest));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "ee3eeefc124a54b541e9aaa2875851f2b5c24de4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 183, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -30,7 +30,6 @@ use super::ModuleTranslation;\n \n use back::link;\n use back::linker::LinkerInfo;\n-use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use rustc::cfg;\n@@ -75,7 +74,7 @@ use expr;\n use glue;\n use inline;\n use machine;\n-use machine::{llalign_of_min, llsize_of, llsize_of_real};\n+use machine::{llalign_of_min, llsize_of};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -86,7 +85,6 @@ use trans_item::TransItem;\n use tvec;\n use type_::Type;\n use type_of;\n-use type_of::*;\n use value::Value;\n use Disr;\n use util::common::indenter;\n@@ -2074,87 +2072,6 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(bcx, DebugLoc::None);\n }\n \n-fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span, id: ast::NodeId) {\n-    let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n-\n-    let print_info = ccx.sess().print_enum_sizes();\n-\n-    let levels = ccx.tcx().node_lint_levels.borrow();\n-    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n-    let lvlsrc = levels.get(&(id, lint_id));\n-    let is_allow = lvlsrc.map_or(true, |&(lvl, _)| lvl == lint::Allow);\n-\n-    if is_allow && !print_info {\n-        // we're not interested in anything here\n-        return;\n-    }\n-\n-    let ty = ccx.tcx().node_id_to_type(id);\n-    let avar = adt::represent_type(ccx, ty);\n-    match *avar {\n-        adt::General(_, ref variants, _) => {\n-            for var in variants {\n-                let mut size = 0;\n-                for field in var.fields.iter().skip(1) {\n-                    // skip the discriminant\n-                    size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n-                }\n-                sizes.push(size);\n-            }\n-        },\n-        _ => { /* its size is either constant or unimportant */ }\n-    }\n-\n-    let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n-        |(l, s, li), (idx, &size)|\n-            if size > l {\n-                (size, l, idx)\n-            } else if size > s {\n-                (l, size, li)\n-            } else {\n-                (l, s, li)\n-            }\n-    );\n-\n-    // FIXME(#30505) Should use logging for this.\n-    if print_info {\n-        let llty = type_of::sizing_type_of(ccx, ty);\n-\n-        let sess = &ccx.tcx().sess;\n-        sess.span_note_without_error(sp,\n-                                     &format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n-        match *avar {\n-            adt::General(..) => {\n-                for (i, var) in enum_def.variants.iter().enumerate() {\n-                    ccx.tcx()\n-                       .sess\n-                       .span_note_without_error(var.span,\n-                                                &format!(\"variant data: {} bytes\", sizes[i]));\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    // we only warn if the largest variant is at least thrice as large as\n-    // the second-largest.\n-    if !is_allow && largest > slargest * 3 && slargest > 0 {\n-        // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n-        // pass for the latter already ran.\n-        lint::raw_struct_lint(&ccx.tcx().sess,\n-                              &ccx.tcx().sess.lint_store.borrow(),\n-                              lint::builtin::VARIANT_SIZE_DIFFERENCES,\n-                              *lvlsrc.unwrap(),\n-                              Some(sp),\n-                              &format!(\"enum variant is more than three times larger ({} bytes) \\\n-                                        than the next largest (ignoring padding)\",\n-                                       largest))\n-            .span_note(enum_def.variants[largest_index].span,\n-                       \"this variant is the largest\")\n-            .emit();\n-    }\n-}\n-\n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -2194,26 +2111,6 @@ pub fn set_link_section(ccx: &CrateContext,\n     }\n }\n \n-fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n-    let _icx = push_ctxt(\"trans_item\");\n-\n-    match item.node {\n-        hir::ItemEnum(ref enum_definition, ref gens) => {\n-            if gens.ty_params.is_empty() {\n-                // sizes only make sense for non-generic types\n-                enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n-            }\n-        }\n-        hir::ItemFn(..) |\n-        hir::ItemImpl(..) |\n-        hir::ItemStatic(..) => {\n-            // Don't do anything here. Translation has been moved to\n-            // being \"collector-driven\".\n-        }\n-        _ => {}\n-    }\n-}\n-\n /// Create the `main` function which will initialise the rust runtime and call\n /// users\u2019 main function.\n pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n@@ -2659,19 +2556,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     symbol_names_test::report_symbol_names(&shared_ccx);\n \n-    {\n-        let ccx = crate_context_list.get_ccx(0);\n-\n-        // FIXME: #34018\n-        // At this point, we only walk the HIR for running\n-        // enum_variant_size_lint(). This should arguably be moved somewhere\n-        // else.\n-        {\n-            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n-            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n-        }\n-    }\n-\n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n@@ -2758,72 +2642,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// We visit all the items in the krate and translate them.  We do\n-/// this in two walks. The first walk just finds module items. It then\n-/// walks the full contents of those module items and translates all\n-/// the items within. Note that this entire process is O(n). The\n-/// reason for this two phased walk is that each module is\n-/// (potentially) placed into a distinct codegen-unit. This walk also\n-/// ensures that the immediate contents of each module is processed\n-/// entirely before we proceed to find more modules, helping to ensure\n-/// an equitable distribution amongst codegen-units.\n-pub struct TransModVisitor<'a, 'tcx: 'a> {\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TransModVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        match i.node {\n-            hir::ItemMod(_) => {\n-                let item_ccx = self.ccx.rotate();\n-                intravisit::walk_item(&mut TransItemsWithinModVisitor { ccx: &item_ccx }, i);\n-            }\n-            _ => { }\n-        }\n-    }\n-}\n-\n-/// Translates all the items within a given module. Expects owner to\n-/// invoke `walk_item` on a module item. Ignores nested modules.\n-pub struct TransItemsWithinModVisitor<'a, 'tcx: 'a> {\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n-    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n-        self.visit_item(self.ccx.tcx().map.expect_item(item_id.id));\n-    }\n-\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        match i.node {\n-            hir::ItemMod(..) => {\n-                // skip modules, they will be uncovered by the TransModVisitor\n-            }\n-            _ => {\n-                let def_id = self.ccx.tcx().map.local_def_id(i.id);\n-                let tcx = self.ccx.tcx();\n-\n-                // Create a subtask for trans'ing a particular item. We are\n-                // giving `trans_item` access to this item, so also record a read.\n-                tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n-                    tcx.dep_graph.read(DepNode::Hir(def_id));\n-\n-                    // We are going to be accessing various tables\n-                    // generated by TypeckItemBody; we also assume\n-                    // that the body passes type check. These tables\n-                    // are not individually tracked, so just register\n-                    // a read here.\n-                    tcx.dep_graph.read(DepNode::TypeckItemBody(def_id));\n-\n-                    trans_item(self.ccx, i);\n-                });\n-\n-                intravisit::walk_item(self, i);\n-            }\n-        }\n-    }\n-}\n-\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();"}, {"sha": "88903726d64f7bbee90ed58128e6ec7391d566eb", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -219,14 +219,6 @@ impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_ccx<'b>(&'b self, index: usize) -> CrateContext<'b, 'tcx> {\n-        CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: &self.local_ccxs[..],\n-        }\n-    }\n-\n     pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n         self.shared\n     }"}, {"sha": "d3271e6d44c3a71877b948dd30fbcee4f2ac5890", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -28,6 +28,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n+use rustc::dep_graph::DepNode;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::{attr,errors};\n@@ -73,6 +74,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                   self.to_raw_string(),\n                   ccx.codegen_unit().name);\n \n+        self.register_reads(ccx);\n+\n         match *self {\n             TransItem::Static(node_id) => {\n                 let item = ccx.tcx().map.expect_item(node_id);\n@@ -99,6 +102,46 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                ccx.codegen_unit().name);\n     }\n \n+    /// If necessary, creates a subtask for trans'ing a particular item and registers reads on\n+    /// `TypeckItemBody` and `Hir`.\n+    fn register_reads(&self, ccx: &CrateContext<'a, 'tcx>) {\n+        let tcx = ccx.tcx();\n+        let def_id = match *self {\n+            TransItem::Static(node_id) => {\n+                tcx.map.local_def_id(node_id)\n+            }\n+            TransItem::Fn(instance) => {\n+                if let Some(node) = tcx.map.as_local_node_id(instance.def) {\n+                    if let hir_map::Node::NodeItem(_) = tcx.map.get(node) {\n+                        // This already is a \"real\" item\n+                        instance.def\n+                    } else {\n+                        // Get the enclosing item and register a read on it\n+                        tcx.map.get_parent_did(node)\n+                    }\n+                } else {\n+                    // Translating an inlined item from another crate? Don't track anything.\n+                    return;\n+                }\n+            }\n+            TransItem::DropGlue(_) => {\n+                // Nothing to track for drop glue\n+                return;\n+            }\n+        };\n+\n+        tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n+            tcx.dep_graph.read(DepNode::Hir(def_id));\n+\n+            // We are going to be accessing various tables\n+            // generated by TypeckItemBody; we also assume\n+            // that the body passes type check. These tables\n+            // are not individually tracked, so just register\n+            // a read here.\n+            tcx.dep_graph.read(DepNode::TypeckItemBody(def_id));\n+        });\n+    }\n+\n     pub fn predefine(&self,\n                      ccx: &CrateContext<'a, 'tcx>,\n                      linkage: llvm::Linkage) {"}, {"sha": "f2cffeefe9080ca9a1bf1ebdb2eea0e7af4b389a", "filename": "src/test/compile-fail/variant-size-differences.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Ftest%2Fcompile-fail%2Fvariant-size-differences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c69a4f619fb4f71f2497f7ee4a25a34a374da4d/src%2Ftest%2Fcompile-fail%2Fvariant-size-differences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariant-size-differences.rs?ref=5c69a4f619fb4f71f2497f7ee4a25a34a374da4d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(variant_size_differences)]\n+\n+enum _En {\n+    V0(u8),\n+    VBig([u8; 1024]),   //~ ERROR variant is more than three times larger\n+}\n+\n+fn main() {}"}]}