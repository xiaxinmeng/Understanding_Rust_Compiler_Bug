{"sha": "005bc49d744f6a7c2ef38a4abd3327b0804709d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNWJjNDlkNzQ0ZjZhN2MyZWYzOGE0YWJkMzMyN2IwODA0NzA5ZDE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-20T21:32:21Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:58:32Z"}, "message": "Test and initial refactoring", "tree": {"sha": "9a971daee4d175859b454d7edf20e630982fa69b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a971daee4d175859b454d7edf20e630982fa69b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/005bc49d744f6a7c2ef38a4abd3327b0804709d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/005bc49d744f6a7c2ef38a4abd3327b0804709d1", "html_url": "https://github.com/rust-lang/rust/commit/005bc49d744f6a7c2ef38a4abd3327b0804709d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/005bc49d744f6a7c2ef38a4abd3327b0804709d1/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac", "html_url": "https://github.com/rust-lang/rust/commit/c48478621fe9b50cb19bfd0ea4a5c2ff0de5d6ac"}], "stats": {"total": 226, "additions": 101, "deletions": 125}, "files": [{"sha": "5fe3f47fd9f3db3824cb7e3cf5f752e43d4a5242", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=005bc49d744f6a7c2ef38a4abd3327b0804709d1", "patch": "@@ -220,41 +220,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn auto_imports_are_merged() {\n-        check_assist(\n-            auto_import,\n-            r\"\n-            use PubMod::PubStruct1;\n-\n-            struct Test {\n-                test: Pub$0Struct2<u8>,\n-            }\n-\n-            pub mod PubMod {\n-                pub struct PubStruct1;\n-                pub struct PubStruct2<T> {\n-                    _t: T,\n-                }\n-            }\n-            \",\n-            r\"\n-            use PubMod::{PubStruct1, PubStruct2};\n-\n-            struct Test {\n-                test: PubStruct2<u8>,\n-            }\n-\n-            pub mod PubMod {\n-                pub struct PubStruct1;\n-                pub struct PubStruct2<T> {\n-                    _t: T,\n-                }\n-            }\n-            \",\n-        );\n-    }\n-\n     #[test]\n     fn applicable_when_found_multiple_imports() {\n         check_assist("}, {"sha": "1fb4931cd0b41da8ec5e279221cbc7acd2de836b", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=005bc49d744f6a7c2ef38a4abd3327b0804709d1", "patch": "@@ -45,7 +45,7 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let qualify_candidate = match candidate {\n         ImportCandidate::Path(candidate) => {\n-            if candidate.qualifier.is_some() {\n+            if candidate.unresolved_qualifier.is_some() {\n                 cov_mark::hit!(qualify_path_qualifier_start);\n                 let path = ast::Path::cast(syntax_under_caret)?;\n                 let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n@@ -192,7 +192,7 @@ fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n     match candidate {\n         ImportCandidate::Path(candidate) => {\n-            if candidate.qualifier.is_some() {\n+            if candidate.unresolved_qualifier.is_some() {\n                 format!(\"Qualify with `{}`\", &import)\n             } else {\n                 format!(\"Qualify as `{}`\", &import)"}, {"sha": "16384551cfdcf369ed93e3a43d70d9370f8a731b", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=005bc49d744f6a7c2ef38a4abd3327b0804709d1", "patch": "@@ -168,15 +168,15 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n             ctx.path_qual.clone(),\n             fuzzy_name,\n             &ctx.sema,\n-        );\n+        )?;\n \n-        if matches!(assets_for_path.as_ref()?.import_candidate(), ImportCandidate::Path(_))\n+        if matches!(assets_for_path.import_candidate(), ImportCandidate::Path(_))\n             && fuzzy_name_length < 2\n         {\n             cov_mark::hit!(ignore_short_input_for_path);\n             None\n         } else {\n-            assets_for_path\n+            Some(assets_for_path)\n         }\n     }\n }\n@@ -773,4 +773,35 @@ fn main() {\n }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn unresolved_qualifiers() {\n+        check_edit(\n+            \"Item\",\n+            r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+fn main() {\n+    bar::Ite$0\n+}\n+\"#,\n+            r#\"\n+use foo::bar;\n+\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+fn main() {\n+    bar::Item\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "513128eae23c9c465809addd01636ebd746b9bce", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 65, "deletions": 85, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005bc49d744f6a7c2ef38a4abd3327b0804709d1/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=005bc49d744f6a7c2ef38a4abd3327b0804709d1", "patch": "@@ -31,7 +31,7 @@ pub struct TraitImportCandidate {\n \n #[derive(Debug)]\n pub struct PathImportCandidate {\n-    pub qualifier: Option<ast::Path>,\n+    pub unresolved_qualifier: Option<ast::Path>,\n     pub name: NameToImport,\n }\n \n@@ -82,38 +82,14 @@ impl ImportAssets {\n     }\n \n     pub fn for_fuzzy_path(\n-        module_with_path: Module,\n+        module_with_candidate: Module,\n         qualifier: Option<ast::Path>,\n         fuzzy_name: String,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n-        Some(match qualifier {\n-            Some(qualifier) => {\n-                let qualifier_resolution = sema.resolve_path(&qualifier)?;\n-                match qualifier_resolution {\n-                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => Self {\n-                        import_candidate: ImportCandidate::TraitAssocItem(TraitImportCandidate {\n-                            receiver_ty: assoc_item_path.ty(sema.db),\n-                            name: NameToImport::Fuzzy(fuzzy_name),\n-                        }),\n-                        module_with_candidate: module_with_path,\n-                    },\n-                    _ => Self {\n-                        import_candidate: ImportCandidate::Path(PathImportCandidate {\n-                            qualifier: Some(qualifier),\n-                            name: NameToImport::Fuzzy(fuzzy_name),\n-                        }),\n-                        module_with_candidate: module_with_path,\n-                    },\n-                }\n-            }\n-            None => Self {\n-                import_candidate: ImportCandidate::Path(PathImportCandidate {\n-                    qualifier: None,\n-                    name: NameToImport::Fuzzy(fuzzy_name),\n-                }),\n-                module_with_candidate: module_with_path,\n-            },\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_fuzzy_path(qualifier, fuzzy_name, sema)?,\n+            module_with_candidate,\n         })\n     }\n \n@@ -169,8 +145,9 @@ impl ImportAssets {\n         prefixed: Option<hir::PrefixKind>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let current_crate = self.module_with_candidate.krate();\n+        let import_candidate = &self.import_candidate;\n \n-        let unfiltered_imports = match self.name_to_import() {\n+        let imports_for_candidate_name = match self.name_to_import() {\n             NameToImport::Exact(exact_name) => {\n                 imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n             }\n@@ -180,11 +157,10 @@ impl ImportAssets {\n             // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n             // for the details\n             NameToImport::Fuzzy(fuzzy_name) => {\n-                let (assoc_item_search, limit) = match self.import_candidate {\n-                    ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n-                        (AssocItemSearch::AssocItemsOnly, None)\n-                    }\n-                    _ => (AssocItemSearch::Exclude, Some(DEFAULT_QUERY_SEARCH_LIMIT)),\n+                let (assoc_item_search, limit) = if import_candidate.is_trait_candidate() {\n+                    (AssocItemSearch::AssocItemsOnly, None)\n+                } else {\n+                    (AssocItemSearch::Exclude, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n                 };\n                 imports_locator::find_similar_imports(\n                     sema,\n@@ -198,33 +174,32 @@ impl ImportAssets {\n \n         let db = sema.db;\n         let mut res =\n-            applicable_defs(self.import_candidate(), current_crate, db, unfiltered_imports)\n+            applicable_defs(import_candidate, current_crate, db, imports_for_candidate_name)\n                 .filter_map(|candidate| {\n                     let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n \n-                    let item_to_search = match self.import_candidate {\n-                        ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n-                            let canidate_trait = match candidate {\n-                                Either::Left(module_def) => {\n-                                    module_def.as_assoc_item(db)?.containing_trait(db)\n-                                }\n-                                _ => None,\n-                            }?;\n-                            ModuleDef::from(canidate_trait).into()\n-                        }\n-                        _ => item,\n+                    let item_to_search = if import_candidate.is_trait_candidate() {\n+                        let canidate_trait = match candidate {\n+                            Either::Left(module_def) => {\n+                                module_def.as_assoc_item(db)?.containing_trait(db)\n+                            }\n+                            _ => None,\n+                        }?;\n+                        ModuleDef::from(canidate_trait).into()\n+                    } else {\n+                        item\n                     };\n-\n-                    if let Some(prefix_kind) = prefixed {\n+                    let mod_path = if let Some(prefix_kind) = prefixed {\n                         self.module_with_candidate.find_use_path_prefixed(\n                             db,\n                             item_to_search,\n                             prefix_kind,\n                         )\n                     } else {\n                         self.module_with_candidate.find_use_path(db, item_to_search)\n-                    }\n-                    .map(|path| (path, item))\n+                    };\n+\n+                    mod_path.zip(Some(item))\n                 })\n                 .filter(|(use_path, _)| use_path.len() > 1)\n                 .collect::<Vec<_>>();\n@@ -239,6 +214,7 @@ fn applicable_defs<'a>(\n     db: &RootDatabase,\n     unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n ) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n+    // TODO kb this needs to consider various path prefixes, etc.\n     let receiver_ty = match import_candidate {\n         ImportCandidate::Path(_) => return unfiltered_imports,\n         ImportCandidate::TraitAssocItem(candidate) | ImportCandidate::TraitMethod(candidate) => {\n@@ -325,41 +301,45 @@ impl ImportCandidate {\n         if sema.resolve_path(path).is_some() {\n             return None;\n         }\n+        path_import_candidate(\n+            sema,\n+            path.qualifier(),\n+            NameToImport::Exact(path.segment()?.name_ref()?.to_string()),\n+        )\n+    }\n \n-        let segment = path.segment()?;\n-        let candidate = if let Some(qualifier) = path.qualifier() {\n-            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n-            let qualifier_start_path =\n-                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n-            if let Some(qualifier_start_resolution) = sema.resolve_path(&qualifier_start_path) {\n-                let qualifier_resolution = if qualifier_start_path == qualifier {\n-                    qualifier_start_resolution\n-                } else {\n-                    sema.resolve_path(&qualifier)?\n-                };\n-                match qualifier_resolution {\n-                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n-                        ImportCandidate::TraitAssocItem(TraitImportCandidate {\n-                            receiver_ty: assoc_item_path.ty(sema.db),\n-                            name: NameToImport::Exact(segment.name_ref()?.to_string()),\n-                        })\n-                    }\n-                    _ => return None,\n-                }\n-            } else {\n-                ImportCandidate::Path(PathImportCandidate {\n-                    qualifier: Some(qualifier),\n-                    name: NameToImport::Exact(qualifier_start.to_string()),\n+    fn for_fuzzy_path(\n+        qualifier: Option<ast::Path>,\n+        fuzzy_name: String,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        path_import_candidate(sema, qualifier, NameToImport::Fuzzy(fuzzy_name))\n+    }\n+\n+    fn is_trait_candidate(&self) -> bool {\n+        matches!(self, ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_))\n+    }\n+}\n+\n+fn path_import_candidate(\n+    sema: &Semantics<RootDatabase>,\n+    qualifier: Option<ast::Path>,\n+    name: NameToImport,\n+) -> Option<ImportCandidate> {\n+    Some(match qualifier {\n+        Some(qualifier) => match sema.resolve_path(&qualifier) {\n+            None => ImportCandidate::Path(PathImportCandidate {\n+                unresolved_qualifier: Some(qualifier),\n+                name,\n+            }),\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path))) => {\n+                ImportCandidate::TraitAssocItem(TraitImportCandidate {\n+                    receiver_ty: assoc_item_path.ty(sema.db),\n+                    name,\n                 })\n             }\n-        } else {\n-            ImportCandidate::Path(PathImportCandidate {\n-                qualifier: None,\n-                name: NameToImport::Exact(\n-                    segment.syntax().descendants().find_map(ast::NameRef::cast)?.to_string(),\n-                ),\n-            })\n-        };\n-        Some(candidate)\n-    }\n+            Some(_) => return None,\n+        },\n+        None => ImportCandidate::Path(PathImportCandidate { unresolved_qualifier: None, name }),\n+    })\n }"}]}