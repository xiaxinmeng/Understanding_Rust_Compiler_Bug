{"sha": "0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "node_id": "C_kwDOAAsO6NoAKDBkZDdlMTAyODJhYWE3YTNlMWY1NjYwZjhiYjA0M2VlNGVhMDczNTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-09T17:23:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-09T17:23:34Z"}, "message": "Auto merge of #96877 - matthiaskrgr:rollup-evlh6ot, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #95483 (Improve floating point documentation)\n - #96008 (Warn on unused `#[doc(hidden)]` attributes on trait impl items)\n - #96841 (Revert \"Implement [OsStr]::join\", which was merged without FCP.)\n - #96844 (Actually fix ICE from #96583)\n - #96854 (Some subst cleanup)\n - #96858 (Remove unused param from search.js::checkPath)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1fd25c23e04b5fd4a72d40f9113a726e1e12d88e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fd25c23e04b5fd4a72d40f9113a726e1e12d88e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "html_url": "https://github.com/rust-lang/rust/commit/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e345b76a5550d82caff5540649ee0ba6e3b4f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e345b76a5550d82caff5540649ee0ba6e3b4f3f", "html_url": "https://github.com/rust-lang/rust/commit/0e345b76a5550d82caff5540649ee0ba6e3b4f3f"}, {"sha": "59722228b981f86d5540a43d9eb2cd2c66da92e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/59722228b981f86d5540a43d9eb2cd2c66da92e9", "html_url": "https://github.com/rust-lang/rust/commit/59722228b981f86d5540a43d9eb2cd2c66da92e9"}], "stats": {"total": 687, "additions": 472, "deletions": 215}, "files": [{"sha": "5b1fb70872988c0787dc2bfe4d49ab0167c65969", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -498,34 +498,14 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Public trait `Subst`\n-//\n-// Just call `foo.subst(tcx, substs)` to perform a substitution across\n-// `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n-// there is more information available (for better errors).\n-\n+// Just call `foo.subst(tcx, substs)` to perform a substitution across `foo`.\n pub trait Subst<'tcx>: Sized {\n-    fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self {\n-        self.subst_spanned(tcx, substs, None)\n-    }\n-\n-    fn subst_spanned(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: &[GenericArg<'tcx>],\n-        span: Option<Span>,\n-    ) -> Self;\n+    fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self;\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: &[GenericArg<'tcx>],\n-        span: Option<Span>,\n-    ) -> T {\n-        let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };\n+    fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> T {\n+        let mut folder = SubstFolder { tcx, substs, binders_passed: 0 };\n         self.fold_with(&mut folder)\n     }\n }\n@@ -537,9 +517,6 @@ struct SubstFolder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     substs: &'a [GenericArg<'tcx>],\n \n-    /// The location for which the substitution is performed, if available.\n-    span: Option<Span>,\n-\n     /// Number of region binders we have passed through while doing the substitution\n     binders_passed: u32,\n }\n@@ -571,13 +548,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 match rk {\n                     Some(GenericArgKind::Lifetime(lt)) => self.shift_region_through_binders(lt),\n                     _ => {\n-                        let span = self.span.unwrap_or(DUMMY_SP);\n                         let msg = format!(\n                             \"Region parameter out of range \\\n                              when substituting in region {} (index={})\",\n                             data.name, data.index\n                         );\n-                        span_bug!(span, \"{}\", msg);\n+                        span_bug!(DUMMY_SP, \"{}\", msg);\n                     }\n                 }\n             }\n@@ -617,9 +593,8 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n         let ty = match opt_ty {\n             Some(GenericArgKind::Type(ty)) => ty,\n             Some(kind) => {\n-                let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n-                    span,\n+                    DUMMY_SP,\n                     \"expected type for `{:?}` ({:?}/{}) but found {:?} \\\n                      when substituting, substs={:?}\",\n                     p,\n@@ -630,9 +605,8 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n                 );\n             }\n             None => {\n-                let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n-                    span,\n+                    DUMMY_SP,\n                     \"type parameter `{:?}` ({:?}/{}) out of range \\\n                      when substituting, substs={:?}\",\n                     p,\n@@ -652,9 +626,8 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n         let ct = match opt_ct {\n             Some(GenericArgKind::Const(ct)) => ct,\n             Some(kind) => {\n-                let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n-                    span,\n+                    DUMMY_SP,\n                     \"expected const for `{:?}` ({:?}/{}) but found {:?} \\\n                      when substituting substs={:?}\",\n                     p,\n@@ -665,9 +638,8 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n                 );\n             }\n             None => {\n-                let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n-                    span,\n+                    DUMMY_SP,\n                     \"const parameter `{:?}` ({:?}/{}) out of range \\\n                      when substituting substs={:?}\",\n                     p,"}, {"sha": "2b0fa57cba8b1f7d2695a7664e76ae217cca1038", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -4,7 +4,8 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::tokenstream::DelimSpan;\n+use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MacArgs, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n@@ -810,6 +811,68 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Checks `#[doc(hidden)]` attributes. Returns `true` if valid.\n+    fn check_doc_hidden(\n+        &self,\n+        attr: &Attribute,\n+        meta_index: usize,\n+        meta: &NestedMetaItem,\n+        hir_id: HirId,\n+        target: Target,\n+    ) -> bool {\n+        if let Target::AssocConst\n+        | Target::AssocTy\n+        | Target::Method(MethodKind::Trait { body: true }) = target\n+        {\n+            let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n+            let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n+\n+            if Target::from_item(containing_item) == Target::Impl {\n+                let meta_items = attr.meta_item_list().unwrap();\n+\n+                let (span, replacement_span) = if meta_items.len() == 1 {\n+                    (attr.span, attr.span)\n+                } else {\n+                    let meta_span = meta.span();\n+                    (\n+                        meta_span,\n+                        meta_span.until(match meta_items.get(meta_index + 1) {\n+                            Some(next_item) => next_item.span(),\n+                            None => match attr.get_normal_item().args {\n+                                MacArgs::Delimited(DelimSpan { close, .. }, ..) => close,\n+                                _ => unreachable!(),\n+                            },\n+                        }),\n+                    )\n+                };\n+\n+                // FIXME: #[doc(hidden)] was previously erroneously allowed on trait impl items,\n+                // so for backward compatibility only emit a warning and do not mark it as invalid.\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, span, |lint| {\n+                    lint.build(\"`#[doc(hidden)]` is ignored on trait impl items\")\n+                        .warn(\n+                            \"this was previously accepted by the compiler but is \\\n+                             being phased out; it will become a hard error in \\\n+                             a future release!\",\n+                        )\n+                        .note(\n+                            \"whether the impl item is `doc(hidden)` or not \\\n+                             entirely depends on the corresponding trait item\",\n+                        )\n+                        .span_suggestion(\n+                            replacement_span,\n+                            \"remove this attribute\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n+            }\n+        }\n+\n+        true\n+    }\n+\n     /// Checks that an attribute is *not* used at the crate level. Returns `true` if valid.\n     fn check_attr_not_crate_level(\n         &self,\n@@ -928,7 +991,7 @@ impl CheckAttrVisitor<'_> {\n         let mut is_valid = true;\n \n         if let Some(mi) = attr.meta() && let Some(list) = mi.meta_item_list() {\n-            for meta in list {\n+            for (meta_index, meta) in list.into_iter().enumerate() {\n                 if let Some(i_meta) = meta.meta_item() {\n                     match i_meta.name_or_empty() {\n                         sym::alias\n@@ -969,6 +1032,15 @@ impl CheckAttrVisitor<'_> {\n                             is_valid = false;\n                         }\n \n+                        sym::hidden if !self.check_doc_hidden(attr,\n+                            meta_index,\n+                            meta,\n+                            hir_id,\n+                            target,\n+                            ) => {\n+                            is_valid = false;\n+                        }\n+\n                         // no_default_passes: deprecated\n                         // passes: deprecated\n                         // plugins: removed, but rustdoc warns about it itself"}, {"sha": "3c1676b1aac67909f1c0c043abcd229ca4e34f83", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -523,11 +523,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 self.astconv\n                                     .normalize_ty(\n                                         self.span,\n-                                        tcx.at(self.span).type_of(param.def_id).subst_spanned(\n-                                            tcx,\n-                                            substs,\n-                                            Some(self.span),\n-                                        ),\n+                                        tcx.at(self.span).type_of(param.def_id).subst(tcx, substs),\n                                     )\n                                     .into()\n                             }\n@@ -547,9 +543,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     GenericParamDefKind::Const { has_default } => {\n                         let ty = tcx.at(self.span).type_of(param.def_id);\n                         if !infer_args && has_default {\n-                            tcx.const_param_default(param.def_id)\n-                                .subst_spanned(tcx, substs.unwrap(), Some(self.span))\n-                                .into()\n+                            tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             if infer_args {\n                                 self.astconv.ct_infer(ty, Some(param), self.span).into()"}, {"sha": "f3a5b9f13dd1bac3c123a487f1b366e178bfa2bf", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -44,7 +44,7 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TypeFoldable};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -2034,17 +2034,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         def_id: DefId,\n     ) {\n-        let local_id = def_id.expect_local();\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_id);\n-        let node = self.tcx.hir().get(hir_id);\n-\n-        if let Some(fields) = node.tuple_fields() {\n-            let kind = match self.tcx.opt_def_kind(local_id) {\n-                Some(DefKind::Ctor(of, _)) => of,\n-                _ => return,\n-            };\n+        if let Some(local_id) = def_id.as_local() {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_id);\n+            let node = self.tcx.hir().get(hir_id);\n+\n+            if let Some(fields) = node.tuple_fields() {\n+                let kind = match self.tcx.opt_def_kind(local_id) {\n+                    Some(DefKind::Ctor(of, _)) => of,\n+                    _ => return,\n+                };\n \n-            suggest_call_constructor(base.span, kind, fields.len(), err);\n+                suggest_call_constructor(base.span, kind, fields.len(), err);\n+            }\n+        } else {\n+            // The logic here isn't smart but `associated_item_def_ids`\n+            // doesn't work nicely on local.\n+            if let DefKind::Ctor(of, _) = self.tcx.def_kind(def_id) {\n+                let parent_def_id = self.tcx.parent(def_id);\n+                let fields = self.tcx.associated_item_def_ids(parent_def_id);\n+                suggest_call_constructor(base.span, of, fields.len(), err);\n+            }\n         }\n     }\n "}, {"sha": "d824c1d7cf252a6b2da48ff43a9165876817b89d", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -1403,10 +1403,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // is missing.\n                             let default = tcx.type_of(param.def_id);\n                             self.fcx\n-                                .normalize_ty(\n-                                    self.span,\n-                                    default.subst_spanned(tcx, substs.unwrap(), Some(self.span)),\n-                                )\n+                                .normalize_ty(self.span, default.subst(tcx, substs.unwrap()))\n                                 .into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n@@ -1418,9 +1415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n                         if !infer_args && has_default {\n-                            tcx.const_param_default(param.def_id)\n-                                .subst_spanned(tcx, substs.unwrap(), Some(self.span))\n-                                .into()\n+                            tcx.const_param_default(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             self.fcx.var_for_def(self.span, param)\n                         }"}, {"sha": "1b619776b857c3f4e0208d776d322c0d7d02b8b4", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -462,19 +462,13 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         let sig = self.tcx.fn_sig(def_id);\n \n-        // Instantiate late-bound regions and substitute the trait\n-        // parameters into the method type to get the actual method type.\n-        //\n-        // N.B., instantiate late-bound regions first so that\n-        // `instantiate_type_scheme` can normalize associated types that\n-        // may reference those regions.\n-        let method_sig = self.replace_bound_vars_with_fresh_vars(sig);\n-        debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\", method_sig);\n+        let sig = sig.subst(self.tcx, all_substs);\n+        debug!(\"type scheme substituted, sig={:?}\", sig);\n \n-        let method_sig = method_sig.subst(self.tcx, all_substs);\n-        debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n+        let sig = self.replace_bound_vars_with_fresh_vars(sig);\n+        debug!(\"late-bound lifetimes from method instantiated, sig={:?}\", sig);\n \n-        (method_sig, method_predicates)\n+        (sig, method_predicates)\n     }\n \n     fn add_obligations("}, {"sha": "1dd5e45fdc174026066730f9671bb4246dc4f00a", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -461,8 +461,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n         let fn_sig = tcx.fn_sig(def_id);\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig).0;\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n+        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig).0;\n \n         let InferOk { value, obligations: o } = if is_op {\n             self.normalize_op_associated_types_in_as_infer_ok(span, fn_sig, opt_input_expr)"}, {"sha": "c28ab9fa1ee40cfae6c0292a68fcf5661dd67bd2", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -1784,12 +1784,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let generics = self.tcx.generics_of(method);\n         assert_eq!(substs.len(), generics.parent_count as usize);\n \n-        // Erase any late-bound regions from the method and substitute\n-        // in the values from the substitution.\n-        let xform_fn_sig = self.erase_late_bound_regions(fn_sig);\n-\n-        if generics.params.is_empty() {\n-            xform_fn_sig.subst(self.tcx, substs)\n+        let xform_fn_sig = if generics.params.is_empty() {\n+            fn_sig.subst(self.tcx, substs)\n         } else {\n             let substs = InternalSubsts::for_item(self.tcx, method, |param, _| {\n                 let i = param.index as usize;\n@@ -1807,8 +1803,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     }\n                 }\n             });\n-            xform_fn_sig.subst(self.tcx, substs)\n-        }\n+            fn_sig.subst(self.tcx, substs)\n+        };\n+\n+        self.erase_late_bound_regions(xform_fn_sig)\n     }\n \n     /// Gets the type of an impl and generate substitutions with placeholders."}, {"sha": "19198ab3aa1b53f562628ea16a2ffbcd3062667d", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -122,7 +122,6 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     #[inline]\n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds."}, {"sha": "b78c0d5e1b3cfdbeb68dfd134e8c3aa02c144b66", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -100,7 +100,6 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n \n     #[inline]\n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds."}, {"sha": "a7df6f59b59894270fffd5fd005c5e06024365eb", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -202,7 +202,6 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         self.len()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "4fa5d129bc6af6ccfa6853c8cc16cf76ea1839dc", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -25,7 +25,6 @@ macro_rules! impl_float_to_int {\n         $(\n             #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n             impl FloatToInt<$Int> for $Float {\n-                #[doc(hidden)]\n                 #[inline]\n                 unsafe fn to_int_unchecked(self) -> $Int {\n                     // SAFETY: the safety contract must be upheld by the caller."}, {"sha": "aba24a79dcf7920595ed1f1a70a73f4540011853", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -60,7 +60,6 @@ where\n         self.it.map(T::clone).fold(init, f)\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "f9bfd77d7fbbff40bd337cc9e97eb199dc215207", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -81,7 +81,6 @@ where\n         self.it.advance_by(n)\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "14a126951115cd156891c48407431d74beb20af8", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -128,7 +128,6 @@ where\n     }\n \n     #[rustc_inherit_overflow_checks]\n-    #[doc(hidden)]\n     #[inline]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n     where"}, {"sha": "8adb53c6714284c1d6376c3114c6f15c92e1d243", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -129,7 +129,6 @@ where\n     }\n \n     #[inline]\n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "9e25dbe462c91eb3648dd7fd09af0ba99de3b248", "filename": "library/core/src/iter/adapters/map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -124,7 +124,6 @@ where\n         self.iter.fold(init, map_fold(self.f, g))\n     }\n \n-    #[doc(hidden)]\n     #[inline]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n     where"}, {"sha": "8153c8cfef133aa0c2d246d4b4169335dbeaf965", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -95,7 +95,6 @@ where\n     }\n \n     #[inline]\n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "f7aeee8c9adc6f36ec1f989441ae897b94b4763c", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -752,7 +752,6 @@ impl<A: Step> Iterator for ops::Range<A> {\n     }\n \n     #[inline]\n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "6548ad2e514fbacd9d2f25825c8c5726c7c3a0ff", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -393,6 +393,15 @@ impl f32 {\n     pub const MAX_10_EXP: i32 = 38;\n \n     /// Not a Number (NaN).\n+    ///\n+    /// Note that IEEE-745 doesn't define just a single NaN value;\n+    /// a plethora of bit patterns are considered to be NaN.\n+    /// Furthermore, the standard makes a difference\n+    /// between a \"signaling\" and a \"quiet\" NaN,\n+    /// and allows inspecting its \"payload\" (the unspecified bits in the bit pattern).\n+    /// This constant isn't guaranteed to equal to any specific NaN bitpattern,\n+    /// and the stability of its representation over Rust versions\n+    /// and target platforms isn't guaranteed.\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n     /// Infinity (\u221e).\n@@ -402,7 +411,7 @@ impl f32 {\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n \n-    /// Returns `true` if this value is `NaN`.\n+    /// Returns `true` if this value is NaN.\n     ///\n     /// ```\n     /// let nan = f32::NAN;\n@@ -455,7 +464,7 @@ impl f32 {\n         (self == f32::INFINITY) | (self == f32::NEG_INFINITY)\n     }\n \n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    /// Returns `true` if this number is neither infinite nor NaN.\n     ///\n     /// ```\n     /// let f = 7.0f32;\n@@ -506,7 +515,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal], or `NaN`.\n+    /// [subnormal], or NaN.\n     ///\n     /// ```\n     /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n@@ -622,8 +631,12 @@ impl f32 {\n         }\n     }\n \n-    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n+    /// positive sign bit and positive infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0_f32;\n@@ -640,8 +653,12 @@ impl f32 {\n         !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n+    /// negative sign bit and negative infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0f32;\n@@ -713,47 +730,47 @@ impl f32 {\n         self * (value / 180.0f32)\n     }\n \n-    /// Returns the maximum of the two numbers.\n+    /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmax.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmax.\n     ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n     ///\n     /// assert_eq!(x.max(y), y);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f32) -> f32 {\n         intrinsics::maxnumf32(self, other)\n     }\n \n-    /// Returns the minimum of the two numbers.\n+    /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmin.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmin.\n     ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n     ///\n     /// assert_eq!(x.min(y), x);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f32) -> f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n-    /// Returns the maximum of the two numbers, propagating NaNs.\n+    /// Returns the maximum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f32::max`] which only returns NaN when *both* arguments are NaN.\n@@ -770,6 +787,9 @@ impl f32 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -785,7 +805,7 @@ impl f32 {\n         }\n     }\n \n-    /// Returns the minimum of the two numbers, propagating NaNs.\n+    /// Returns the minimum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f32::min`] which only returns NaN when *both* arguments are NaN.\n@@ -802,6 +822,9 @@ impl f32 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -1009,6 +1032,9 @@ impl f32 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// big-endian (network) byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1027,6 +1053,9 @@ impl f32 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// little-endian byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1051,6 +1080,9 @@ impl f32 {\n     /// [`to_be_bytes`]: f32::to_be_bytes\n     /// [`to_le_bytes`]: f32::to_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1075,6 +1107,9 @@ impl f32 {\n \n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1091,6 +1126,9 @@ impl f32 {\n \n     /// Create a floating point value from its representation as a byte array in little endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1114,6 +1152,9 @@ impl f32 {\n     /// [`from_be_bytes`]: f32::from_be_bytes\n     /// [`from_le_bytes`]: f32::from_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "75c92c2f8834a215fcbefa75c4d89f50e7fa79a6", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -392,6 +392,15 @@ impl f64 {\n     pub const MAX_10_EXP: i32 = 308;\n \n     /// Not a Number (NaN).\n+    ///\n+    /// Note that IEEE-745 doesn't define just a single NaN value;\n+    /// a plethora of bit patterns are considered to be NaN.\n+    /// Furthermore, the standard makes a difference\n+    /// between a \"signaling\" and a \"quiet\" NaN,\n+    /// and allows inspecting its \"payload\" (the unspecified bits in the bit pattern).\n+    /// This constant isn't guaranteed to equal to any specific NaN bitpattern,\n+    /// and the stability of its representation over Rust versions\n+    /// and target platforms isn't guaranteed.\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n     /// Infinity (\u221e).\n@@ -401,7 +410,7 @@ impl f64 {\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n \n-    /// Returns `true` if this value is `NaN`.\n+    /// Returns `true` if this value is NaN.\n     ///\n     /// ```\n     /// let nan = f64::NAN;\n@@ -456,7 +465,7 @@ impl f64 {\n         (self == f64::INFINITY) | (self == f64::NEG_INFINITY)\n     }\n \n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    /// Returns `true` if this number is neither infinite nor NaN.\n     ///\n     /// ```\n     /// let f = 7.0f64;\n@@ -507,7 +516,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal], or `NaN`.\n+    /// [subnormal], or NaN.\n     ///\n     /// ```\n     /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n@@ -614,8 +623,12 @@ impl f64 {\n         }\n     }\n \n-    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n+    /// positive sign bit and positive infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0_f64;\n@@ -641,8 +654,12 @@ impl f64 {\n         self.is_sign_positive()\n     }\n \n-    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n+    /// negative sign bit and negative infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0_f64;\n@@ -724,47 +741,47 @@ impl f64 {\n         self * (value / 180.0)\n     }\n \n-    /// Returns the maximum of the two numbers.\n+    /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmax.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmax.\n     ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n     ///\n     /// assert_eq!(x.max(y), y);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f64) -> f64 {\n         intrinsics::maxnumf64(self, other)\n     }\n \n-    /// Returns the minimum of the two numbers.\n+    /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmin.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmin.\n     ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n     ///\n     /// assert_eq!(x.min(y), x);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f64) -> f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n-    /// Returns the maximum of the two numbers, propagating NaNs.\n+    /// Returns the maximum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f64::max`] which only returns NaN when *both* arguments are NaN.\n@@ -781,6 +798,9 @@ impl f64 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -796,7 +816,7 @@ impl f64 {\n         }\n     }\n \n-    /// Returns the minimum of the two numbers, propagating NaNs.\n+    /// Returns the minimum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f64::min`] which only returns NaN when *both* arguments are NaN.\n@@ -813,6 +833,9 @@ impl f64 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -1007,6 +1030,9 @@ impl f64 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// big-endian (network) byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1025,6 +1051,9 @@ impl f64 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// little-endian byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1049,6 +1078,9 @@ impl f64 {\n     /// [`to_be_bytes`]: f64::to_be_bytes\n     /// [`to_le_bytes`]: f64::to_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1073,6 +1105,9 @@ impl f64 {\n \n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1089,6 +1124,9 @@ impl f64 {\n \n     /// Create a floating point value from its representation as a byte array in little endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1112,6 +1150,9 @@ impl f64 {\n     /// [`from_be_bytes`]: f64::from_be_bytes\n     /// [`from_le_bytes`]: f64::from_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "ac4e668112b94a1248a4141353e033682123eb14", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -977,10 +977,22 @@ mod prim_tuple {}\n ///   like `1.0 / 0.0`.\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n-///   behavior: it is unequal to any float, including itself! It is also neither\n-///   smaller nor greater than any float, making it impossible to sort. Lastly,\n-///   it is considered infectious as almost all calculations where one of the\n-///   operands is NaN will also result in NaN.\n+///   behavior:\n+///   - It is unequal to any float, including itself! This is the reason `f32`\n+///     doesn't implement the `Eq` trait.\n+///   - It is also neither smaller nor greater than any float, making it\n+///     impossible to sort by the default comparison operation, which is the\n+///     reason `f32` doesn't implement the `Ord` trait.\n+///   - It is also considered *infectious* as almost all calculations where one\n+///     of the operands is NaN will also result in NaN. The explanations on this\n+///     page only explicitly document behavior on NaN operands if this default\n+///     is deviated from.\n+///   - Lastly, there are multiple bit patterns that are considered NaN.\n+///     Rust does not currently guarantee that the bit patterns of NaN are\n+///     preserved over arithmetic operations, and they are not guaranteed to be\n+///     portable or even fully deterministic! This means that there may be some\n+///     surprising results upon inspecting the bit patterns,\n+///     as the same calculations might produce NaNs with different bit patterns.\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///"}, {"sha": "772a9698d84cc9b930d2e73f1cfe8125d33e027c", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -1322,7 +1322,6 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         }\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         // SAFETY: since the caller guarantees that `i` is in bounds,\n         // which means that `i` cannot overflow an `isize`, and the\n@@ -1478,7 +1477,6 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n         }\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n         // SAFETY: the caller guarantees that `i` is in bounds,\n@@ -1657,7 +1655,6 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n         }\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n         // SAFETY: see comments for `Chunks::__iterator_get_unchecked`.\n@@ -1830,7 +1827,6 @@ impl<'a, T> Iterator for ChunksExact<'a, T> {\n         self.next_back()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n         // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.\n@@ -1984,7 +1980,6 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n         self.next_back()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n         // SAFETY: see comments for `ChunksMut::__iterator_get_unchecked`.\n@@ -2248,7 +2243,6 @@ impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n         self.iter.last()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n         // SAFETY: The safety guarantees of `__iterator_get_unchecked` are\n         // transferred to the caller.\n@@ -2367,7 +2361,6 @@ impl<'a, T, const N: usize> Iterator for ArrayChunksMut<'a, T, N> {\n         self.iter.last()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {\n         // SAFETY: The safety guarantees of `__iterator_get_unchecked` are transferred to\n         // the caller.\n@@ -2520,7 +2513,6 @@ impl<'a, T> Iterator for RChunks<'a, T> {\n         }\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = match end.checked_sub(self.chunk_size) {\n@@ -2689,7 +2681,6 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n         }\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = match end.checked_sub(self.chunk_size) {\n@@ -2856,7 +2847,6 @@ impl<'a, T> Iterator for RChunksExact<'a, T> {\n         self.next_back()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n@@ -3016,7 +3006,6 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n         self.next_back()\n     }\n \n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;"}, {"sha": "c05242222dde7e54c1b4b5477a2efb397073593b", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -325,7 +325,6 @@ macro_rules! iterator {\n                 None\n             }\n \n-            #[doc(hidden)]\n             #[inline]\n             unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                 // SAFETY: the caller must guarantee that `i` is in bounds of"}, {"sha": "24083ee6af44f34f2362df3913445b5c906a0aae", "filename": "library/core/src/str/iter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -298,7 +298,6 @@ impl Iterator for Bytes<'_> {\n     }\n \n     #[inline]\n-    #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> u8 {\n         // SAFETY: the caller must uphold the safety contract\n         // for `Iterator::__iterator_get_unchecked`."}, {"sha": "933b52b4dccbb2b4d810b0485a7279590f6aa18a", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -29,7 +29,7 @@ pub use core::f32::{\n \n #[cfg(not(test))]\n impl f32 {\n-    /// Returns the largest integer less than or equal to a number.\n+    /// Returns the largest integer less than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -50,7 +50,7 @@ impl f32 {\n         unsafe { intrinsics::floorf32(self) }\n     }\n \n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Returns the smallest integer greater than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -69,7 +69,7 @@ impl f32 {\n         unsafe { intrinsics::ceilf32(self) }\n     }\n \n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Returns the nearest integer to `self`. Round half-way cases away from\n     /// `0.0`.\n     ///\n     /// # Examples\n@@ -89,7 +89,8 @@ impl f32 {\n         unsafe { intrinsics::roundf32(self) }\n     }\n \n-    /// Returns the integer part of a number.\n+    /// Returns the integer part of `self`.\n+    /// This means that non-integer numbers are always truncated towards zero.\n     ///\n     /// # Examples\n     ///\n@@ -110,7 +111,7 @@ impl f32 {\n         unsafe { intrinsics::truncf32(self) }\n     }\n \n-    /// Returns the fractional part of a number.\n+    /// Returns the fractional part of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -131,8 +132,7 @@ impl f32 {\n         self - self.trunc()\n     }\n \n-    /// Computes the absolute value of `self`. Returns `NAN` if the\n-    /// number is `NAN`.\n+    /// Computes the absolute value of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -160,7 +160,7 @@ impl f32 {\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is `NAN`\n+    /// - NaN if the number is NaN\n     ///\n     /// # Examples\n     ///\n@@ -184,8 +184,10 @@ impl f32 {\n     /// `sign`.\n     ///\n     /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n-    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n-    /// `sign` is returned.\n+    /// equal to `-self`. If `self` is a NaN, then a NaN with the sign bit of\n+    /// `sign` is returned. Note, however, that conserving the sign bit on NaN\n+    /// across arithmetical operations is not generally guaranteed.\n+    /// See [explanation of NaN as a special value](primitive@f32) for more info.\n     ///\n     /// # Examples\n     ///\n@@ -298,7 +300,9 @@ impl f32 {\n \n     /// Raises a number to an integer power.\n     ///\n-    /// Using this function is generally faster than using `powf`\n+    /// Using this function is generally faster than using `powf`.\n+    /// It might have a different sequence of rounding operations than `powf`,\n+    /// so the results are not guaranteed to agree.\n     ///\n     /// # Examples\n     ///"}, {"sha": "a9aa84f70d19e08fcc4341a2a52ffb984afe43d4", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -29,7 +29,7 @@ pub use core::f64::{\n \n #[cfg(not(test))]\n impl f64 {\n-    /// Returns the largest integer less than or equal to a number.\n+    /// Returns the largest integer less than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -50,7 +50,7 @@ impl f64 {\n         unsafe { intrinsics::floorf64(self) }\n     }\n \n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Returns the smallest integer greater than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -69,7 +69,7 @@ impl f64 {\n         unsafe { intrinsics::ceilf64(self) }\n     }\n \n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Returns the nearest integer to `self`. Round half-way cases away from\n     /// `0.0`.\n     ///\n     /// # Examples\n@@ -89,7 +89,8 @@ impl f64 {\n         unsafe { intrinsics::roundf64(self) }\n     }\n \n-    /// Returns the integer part of a number.\n+    /// Returns the integer part of `self`.\n+    /// This means that non-integer numbers are always truncated towards zero.\n     ///\n     /// # Examples\n     ///\n@@ -110,7 +111,7 @@ impl f64 {\n         unsafe { intrinsics::truncf64(self) }\n     }\n \n-    /// Returns the fractional part of a number.\n+    /// Returns the fractional part of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -131,8 +132,7 @@ impl f64 {\n         self - self.trunc()\n     }\n \n-    /// Computes the absolute value of `self`. Returns `NAN` if the\n-    /// number is `NAN`.\n+    /// Computes the absolute value of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -160,7 +160,7 @@ impl f64 {\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is `NAN`\n+    /// - NaN if the number is NaN\n     ///\n     /// # Examples\n     ///\n@@ -184,8 +184,10 @@ impl f64 {\n     /// `sign`.\n     ///\n     /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n-    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n-    /// `sign` is returned.\n+    /// equal to `-self`. If `self` is a NaN, then a NaN with the sign bit of\n+    /// `sign` is returned. Note, however, that conserving the sign bit on NaN\n+    /// across arithmetical operations is not generally guaranteed.\n+    /// See [explanation of NaN as a special value](primitive@f32) for more info.\n     ///\n     /// # Examples\n     ///\n@@ -298,7 +300,9 @@ impl f64 {\n \n     /// Raises a number to an integer power.\n     ///\n-    /// Using this function is generally faster than using `powf`\n+    /// Using this function is generally faster than using `powf`.\n+    /// It might have a different sequence of rounding operations than `powf`,\n+    /// so the results are not guaranteed to agree.\n     ///\n     /// # Examples\n     ///"}, {"sha": "9b5e5d6c0cc4b1d377896ba1ba8d7dc444a2bfe3", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -1222,23 +1222,6 @@ impl OsStr {\n     }\n }\n \n-#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n-impl<S: Borrow<OsStr>> alloc::slice::Join<&OsStr> for [S] {\n-    type Output = OsString;\n-\n-    fn join(slice: &Self, sep: &OsStr) -> OsString {\n-        let Some(first) = slice.first() else {\n-            return OsString::new();\n-        };\n-        let first = first.borrow().to_owned();\n-        slice[1..].iter().fold(first, |mut a, b| {\n-            a.push(sep);\n-            a.push(b.borrow());\n-            a\n-        })\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<OsStr> for OsString {\n     #[inline]"}, {"sha": "283f2b577e89607bdd9940cc8b4c4d4300b35888", "filename": "library/std/src/ffi/os_str/tests.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Fffi%2Fos_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Fffi%2Fos_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str%2Ftests.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -84,20 +84,6 @@ fn test_os_string_reserve_exact() {\n     assert!(os_string.capacity() >= 33)\n }\n \n-#[test]\n-fn test_os_string_join() {\n-    let strings = [OsStr::new(\"hello\"), OsStr::new(\"dear\"), OsStr::new(\"world\")];\n-    assert_eq!(\"hello\", strings[..1].join(OsStr::new(\" \")));\n-    assert_eq!(\"hello dear world\", strings.join(OsStr::new(\" \")));\n-    assert_eq!(\"hellodearworld\", strings.join(OsStr::new(\"\")));\n-    assert_eq!(\"hello.\\n dear.\\n world\", strings.join(OsStr::new(\".\\n \")));\n-\n-    assert_eq!(\"dear world\", strings[1..].join(&OsString::from(\" \")));\n-\n-    let strings_abc = [OsString::from(\"a\"), OsString::from(\"b\"), OsString::from(\"c\")];\n-    assert_eq!(\"a b c\", strings_abc.join(OsStr::new(\" \")));\n-}\n-\n #[test]\n fn test_os_string_default() {\n     let os_string: OsString = Default::default();"}, {"sha": "8ee50925f85f8e1ac04cf059c738e0093624a930", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -241,7 +241,6 @@\n #![feature(intra_doc_pointers)]\n #![feature(lang_items)]\n #![feature(let_chains)]\n-#![feature(let_else)]\n #![feature(linkage)]\n #![feature(min_specialization)]\n #![feature(must_not_suspend)]\n@@ -302,7 +301,6 @@\n #![feature(toowned_clone_into)]\n #![feature(try_reserve_kind)]\n #![feature(vec_into_raw_parts)]\n-#![feature(slice_concat_trait)]\n //\n // Library features (unwind):\n #![feature(panic_unwind)]"}, {"sha": "ac4e668112b94a1248a4141353e033682123eb14", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -977,10 +977,22 @@ mod prim_tuple {}\n ///   like `1.0 / 0.0`.\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n-///   behavior: it is unequal to any float, including itself! It is also neither\n-///   smaller nor greater than any float, making it impossible to sort. Lastly,\n-///   it is considered infectious as almost all calculations where one of the\n-///   operands is NaN will also result in NaN.\n+///   behavior:\n+///   - It is unequal to any float, including itself! This is the reason `f32`\n+///     doesn't implement the `Eq` trait.\n+///   - It is also neither smaller nor greater than any float, making it\n+///     impossible to sort by the default comparison operation, which is the\n+///     reason `f32` doesn't implement the `Ord` trait.\n+///   - It is also considered *infectious* as almost all calculations where one\n+///     of the operands is NaN will also result in NaN. The explanations on this\n+///     page only explicitly document behavior on NaN operands if this default\n+///     is deviated from.\n+///   - Lastly, there are multiple bit patterns that are considered NaN.\n+///     Rust does not currently guarantee that the bit patterns of NaN are\n+///     preserved over arithmetic operations, and they are not guaranteed to be\n+///     portable or even fully deterministic! This means that there may be some\n+///     surprising results upon inspecting the bit patterns,\n+///     as the same calculations might produce NaNs with different bit patterns.\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///"}, {"sha": "677e9b5f03ab25ce369fe2495a8eab245043f08c", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -1089,7 +1089,7 @@ window.initSearch = rawSearchIndex => {\n             return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n-        function checkPath(contains, lastElem, ty) {\n+        function checkPath(contains, ty) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n@@ -1306,7 +1306,7 @@ window.initSearch = rawSearchIndex => {\n             }\n \n             if (elem.fullPath.length > 1) {\n-                lev = checkPath(elem.pathWithoutLast, elem.pathLast, row);\n+                lev = checkPath(elem.pathWithoutLast, row);\n                 if (lev > MAX_LEV_DISTANCE || (parsedQuery.literalSearch && lev !== 0)) {\n                     return;\n                 } else if (lev > 0) {"}, {"sha": "36a14097ac308d2cca4e49768a6ba0d7e46a397a", "filename": "src/test/ui/lint/unused/unused-attr-doc-hidden.fixed", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.fixed?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -0,0 +1,42 @@\n+#![deny(unused_attributes)]\n+#![crate_type = \"lib\"]\n+// run-rustfix\n+\n+pub trait Trait {\n+    type It;\n+    const IT: ();\n+    fn it0();\n+    fn it1();\n+    fn it2();\n+}\n+\n+pub struct Implementor;\n+\n+impl Trait for Implementor {\n+    \n+    type It = ();\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    \n+    const IT: () = ();\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc(alias = \"aka\")]\n+    fn it0() {}\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc(alias = \"this\", )]\n+    fn it1() {}\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc()]\n+    fn it2() {}\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+    //~|  ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+}"}, {"sha": "e58c4f22f31abe275e8ef51e80f8aaebb386858e", "filename": "src/test/ui/lint/unused/unused-attr-doc-hidden.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -0,0 +1,42 @@\n+#![deny(unused_attributes)]\n+#![crate_type = \"lib\"]\n+// run-rustfix\n+\n+pub trait Trait {\n+    type It;\n+    const IT: ();\n+    fn it0();\n+    fn it1();\n+    fn it2();\n+}\n+\n+pub struct Implementor;\n+\n+impl Trait for Implementor {\n+    #[doc(hidden)]\n+    type It = ();\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc(hidden)]\n+    const IT: () = ();\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc(hidden, alias = \"aka\")]\n+    fn it0() {}\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc(alias = \"this\", hidden,)]\n+    fn it1() {}\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+\n+    #[doc(hidden, hidden)]\n+    fn it2() {}\n+    //~^^ ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+    //~|  ERROR `#[doc(hidden)]` is ignored\n+    //~|  WARNING this was previously accepted\n+}"}, {"sha": "fd1202a29de2ecab36d08c376856709a09ca1428", "filename": "src/test/ui/lint/unused/unused-attr-doc-hidden.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-doc-hidden.stderr?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -0,0 +1,67 @@\n+error: `#[doc(hidden)]` is ignored on trait impl items\n+  --> $DIR/unused-attr-doc-hidden.rs:16:5\n+   |\n+LL |     #[doc(hidden)]\n+   |     ^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused-attr-doc-hidden.rs:1:9\n+   |\n+LL | #![deny(unused_attributes)]\n+   |         ^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: whether the impl item is `doc(hidden)` or not entirely depends on the corresponding trait item\n+\n+error: `#[doc(hidden)]` is ignored on trait impl items\n+  --> $DIR/unused-attr-doc-hidden.rs:21:5\n+   |\n+LL |     #[doc(hidden)]\n+   |     ^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: whether the impl item is `doc(hidden)` or not entirely depends on the corresponding trait item\n+\n+error: `#[doc(hidden)]` is ignored on trait impl items\n+  --> $DIR/unused-attr-doc-hidden.rs:26:11\n+   |\n+LL |     #[doc(hidden, alias = \"aka\")]\n+   |           ^^^^^^--\n+   |           |\n+   |           help: remove this attribute\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: whether the impl item is `doc(hidden)` or not entirely depends on the corresponding trait item\n+\n+error: `#[doc(hidden)]` is ignored on trait impl items\n+  --> $DIR/unused-attr-doc-hidden.rs:31:27\n+   |\n+LL |     #[doc(alias = \"this\", hidden,)]\n+   |                           ^^^^^^-\n+   |                           |\n+   |                           help: remove this attribute\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: whether the impl item is `doc(hidden)` or not entirely depends on the corresponding trait item\n+\n+error: `#[doc(hidden)]` is ignored on trait impl items\n+  --> $DIR/unused-attr-doc-hidden.rs:36:11\n+   |\n+LL |     #[doc(hidden, hidden)]\n+   |           ^^^^^^--\n+   |           |\n+   |           help: remove this attribute\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: whether the impl item is `doc(hidden)` or not entirely depends on the corresponding trait item\n+\n+error: `#[doc(hidden)]` is ignored on trait impl items\n+  --> $DIR/unused-attr-doc-hidden.rs:36:19\n+   |\n+LL |     #[doc(hidden, hidden)]\n+   |                   ^^^^^^ help: remove this attribute\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: whether the impl item is `doc(hidden)` or not entirely depends on the corresponding trait item\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "ce2556f869c7c13e942e64c3017813f30a60cbed", "filename": "src/test/ui/typeck/issue-96738.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.rs?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -1,3 +1,4 @@\n fn main() {\n     Some.nonexistent_method(); //~ ERROR: no method named `nonexistent_method` found\n+    Some.nonexistent_field; //~ ERROR: no field `nonexistent_field`\n }"}, {"sha": "32f53849848c75abd5e599818799c2fa87215c99", "filename": "src/test/ui/typeck/issue-96738.stderr", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr?ref=0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "patch": "@@ -11,6 +11,20 @@ help: call the constructor\n LL |     (Some)(_).nonexistent_method();\n    |     +    ++++\n \n-error: aborting due to previous error\n+error[E0609]: no field `nonexistent_field` on type `fn(_) -> Option<_> {Option::<_>::Some}`\n+  --> $DIR/issue-96738.rs:3:10\n+   |\n+LL |     Some.nonexistent_field;\n+   |     ---- ^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     this is the constructor of an enum variant\n+   |\n+help: call the constructor\n+   |\n+LL |     (Some)(_).nonexistent_field;\n+   |     +    ++++\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0599`.\n+Some errors have detailed explanations: E0599, E0609.\n+For more information about an error, try `rustc --explain E0599`."}]}