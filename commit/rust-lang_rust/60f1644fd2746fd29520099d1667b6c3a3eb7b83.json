{"sha": "60f1644fd2746fd29520099d1667b6c3a3eb7b83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZjE2NDRmZDI3NDZmZDI5NTIwMDk5ZDE2NjdiNmMzYTNlYjdiODM=", "commit": {"author": {"name": "Denys Zariaiev", "email": "denys.zariaiev@gmail.com", "date": "2019-03-16T22:40:43Z"}, "committer": {"name": "Denys Zariaiev", "email": "denys.zariaiev@gmail.com", "date": "2019-03-16T22:40:43Z"}, "message": "Merge remote-tracking branch 'upstream/master' into asm-compile-tests", "tree": {"sha": "1bb0bf5adc583c13833e1cafd65954c6ab5c0f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bb0bf5adc583c13833e1cafd65954c6ab5c0f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60f1644fd2746fd29520099d1667b6c3a3eb7b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60f1644fd2746fd29520099d1667b6c3a3eb7b83", "html_url": "https://github.com/rust-lang/rust/commit/60f1644fd2746fd29520099d1667b6c3a3eb7b83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60f1644fd2746fd29520099d1667b6c3a3eb7b83/comments", "author": {"login": "denzp", "id": 747869, "node_id": "MDQ6VXNlcjc0Nzg2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/747869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denzp", "html_url": "https://github.com/denzp", "followers_url": "https://api.github.com/users/denzp/followers", "following_url": "https://api.github.com/users/denzp/following{/other_user}", "gists_url": "https://api.github.com/users/denzp/gists{/gist_id}", "starred_url": "https://api.github.com/users/denzp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denzp/subscriptions", "organizations_url": "https://api.github.com/users/denzp/orgs", "repos_url": "https://api.github.com/users/denzp/repos", "events_url": "https://api.github.com/users/denzp/events{/privacy}", "received_events_url": "https://api.github.com/users/denzp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "denzp", "id": 747869, "node_id": "MDQ6VXNlcjc0Nzg2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/747869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denzp", "html_url": "https://github.com/denzp", "followers_url": "https://api.github.com/users/denzp/followers", "following_url": "https://api.github.com/users/denzp/following{/other_user}", "gists_url": "https://api.github.com/users/denzp/gists{/gist_id}", "starred_url": "https://api.github.com/users/denzp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denzp/subscriptions", "organizations_url": "https://api.github.com/users/denzp/orgs", "repos_url": "https://api.github.com/users/denzp/repos", "events_url": "https://api.github.com/users/denzp/events{/privacy}", "received_events_url": "https://api.github.com/users/denzp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeb5f171da2486c34e4e473c97a1468279d05e7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5f171da2486c34e4e473c97a1468279d05e7c", "html_url": "https://github.com/rust-lang/rust/commit/eeb5f171da2486c34e4e473c97a1468279d05e7c"}, {"sha": "2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "html_url": "https://github.com/rust-lang/rust/commit/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff"}], "stats": {"total": 9530, "additions": 5342, "deletions": 4188}, "files": [{"sha": "27f7f59165b1bd0daa08ac465b0b22f03cbfd949", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -251,7 +251,7 @@ dependencies = [\n  \"fwdansi 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2-curl 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1009,7 +1009,7 @@ dependencies = [\n \n [[package]]\n name = \"glob\"\n-version = \"0.2.11\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -4083,7 +4083,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b900c08c1939860ce8b54dc6a89e26e00c04c380fd0e09796799bd7f12861e05\"\n \"checksum git2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7339329bfa14a00223244311560d11f8f489b453fb90092af97f267a6090ab0\"\n \"checksum git2-curl 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d58551e903ed7e2d6fe3a2f3c7efa3a784ec29b19d0fbb035aaf0497c183fbdd\"\n-\"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n+\"checksum glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n \"checksum globset 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4743617a7464bbda3c8aec8558ff2f9429047e025771037df561d383337ff865\"\n \"checksum handlebars 0.32.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d89ec99d1594f285d4590fc32bac5f75cdab383f1123d504d27862c644a807dd\"\n \"checksum handlebars 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d82e5750d8027a97b9640e3fefa66bbaf852a35228e1c90790efd13c4b09c166\""}, {"sha": "a49e072e9eaa7efa8389daf63c5bd121d84f2e99", "filename": "RELEASES.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -110,8 +110,11 @@ Compatibility Notes\n   methods instead.\n - The `Error::cause` method has been deprecated in favor of `Error::source` which supports\n   downcasting.\n+- [Libtest no longer creates a new thread for each test when\n+  `--test-threads=1`.  It also runs the tests in deterministic order][56243]\n \n [55982]: https://github.com/rust-lang/rust/pull/55982/\n+[56243]: https://github.com/rust-lang/rust/pull/56243\n [56303]: https://github.com/rust-lang/rust/pull/56303/\n [56351]: https://github.com/rust-lang/rust/pull/56351/\n [56362]: https://github.com/rust-lang/rust/pull/56362"}, {"sha": "2abf723de496e46f9c23a337dc649bb1e57b3b12", "filename": "appveyor.yml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,7 @@\n environment:\n+  # This is required for at least an AArch64 compiler in one image, and is also\n+  # going to soon be required for compiling LLVM.\n+  APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n \n   # By default schannel checks revocation of certificates unlike some other SSL\n   # backends, but we've historically had problems on CI where a revocation\n@@ -81,7 +84,6 @@ environment:\n     DIST_REQUIRE_ALL_TOOLS: 1\n     DEPLOY: 1\n     CI_JOB_NAME: dist-x86_64-msvc\n-    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc"}, {"sha": "085f243785cbeb3270d9f3d6c32f371c720f3e3d", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -35,7 +35,7 @@ fn main() {\n         .arg(\"--cfg\")\n         .arg(\"dox\")\n         .arg(\"--sysroot\")\n-        .arg(sysroot)\n+        .arg(&sysroot)\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n \n@@ -72,7 +72,13 @@ fn main() {\n     }\n \n     if verbose > 1 {\n-        eprintln!(\"rustdoc command: {:?}\", cmd);\n+        eprintln!(\n+            \"rustdoc command: {:?}={:?} {:?}\",\n+            bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap(),\n+            cmd,\n+        );\n+        eprintln!(\"sysroot: {:?}\", sysroot);\n         eprintln!(\"libdir: {:?}\", libdir);\n     }\n "}, {"sha": "fd5038ccb9528ccbb6ddb63511b5ba6d50eea431", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -374,6 +374,7 @@ impl<'a> Builder<'a> {\n                 test::MirOpt,\n                 test::Codegen,\n                 test::CodegenUnits,\n+                test::Assembly,\n                 test::Incremental,\n                 test::Debuginfo,\n                 test::UiFullDeps,\n@@ -408,12 +409,11 @@ impl<'a> Builder<'a> {\n                 test::RustdocJSStd,\n                 test::RustdocJSNotStd,\n                 test::RustdocTheme,\n+                test::RustdocUi,\n                 // Run bootstrap close to the end as it's unlikely to fail\n                 test::Bootstrap,\n                 // Run run-make last, since these won't pass without make on Windows\n                 test::RunMake,\n-                test::RustdocUi,\n-                test::Assembly,\n             ),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!("}, {"sha": "976b30a55c94b7d8db3e09a705069622ebfc9ade", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -241,6 +241,8 @@ pub struct Build {\n     clippy_info: channel::GitInfo,\n     miri_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n+    in_tree_llvm_info: channel::GitInfo,\n+    emscripten_llvm_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n     doc_tests: DocTests,\n@@ -363,6 +365,8 @@ impl Build {\n         let clippy_info = channel::GitInfo::new(&config, &src.join(\"src/tools/clippy\"));\n         let miri_info = channel::GitInfo::new(&config, &src.join(\"src/tools/miri\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n+        let in_tree_llvm_info = channel::GitInfo::new(&config, &src.join(\"src/llvm-project\"));\n+        let emscripten_llvm_info = channel::GitInfo::new(&config, &src.join(\"src/llvm-emscripten\"));\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n@@ -386,6 +390,8 @@ impl Build {\n             clippy_info,\n             miri_info,\n             rustfmt_info,\n+            in_tree_llvm_info,\n+            emscripten_llvm_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             ar: HashMap::new(),"}, {"sha": "07be27c2f5a0238a24a2523989a836139b87a434", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -48,7 +48,6 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/pretty \\\n \t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\"}, {"sha": "3babbc9e102310b372112691091d0d3593564eb8", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -18,6 +18,7 @@ use build_helper::output;\n use cmake;\n use cc;\n \n+use crate::channel;\n use crate::util::{self, exe};\n use build_helper::up_to_date;\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -231,7 +232,26 @@ impl Step for Llvm {\n         }\n \n         if let Some(ref suffix) = builder.config.llvm_version_suffix {\n-            cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n+            // Allow version-suffix=\"\" to not define a version suffix at all.\n+            if !suffix.is_empty() {\n+                cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n+            }\n+        } else {\n+            let mut default_suffix = format!(\n+                \"-rust-{}-{}\",\n+                channel::CFG_RELEASE_NUM,\n+                builder.config.channel,\n+            );\n+            let llvm_info = if self.emscripten {\n+                &builder.emscripten_llvm_info\n+            } else {\n+                &builder.in_tree_llvm_info\n+            };\n+            if let Some(sha) = llvm_info.sha_short() {\n+                default_suffix.push_str(\"-\");\n+                default_suffix.push_str(sha);\n+            }\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", default_suffix);\n         }\n \n         if let Some(ref linker) = builder.config.llvm_use_linker {"}, {"sha": "b348ed980f425436575c7135fe88c15af4796d49", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -897,12 +897,10 @@ host_test!(Rustdoc {\n     suite: \"rustdoc\"\n });\n \n-test!(Pretty {\n+host_test!(Pretty {\n     path: \"src/test/pretty\",\n     mode: \"pretty\",\n-    suite: \"pretty\",\n-    default: false,\n-    host: true\n+    suite: \"pretty\"\n });\n test!(RunPassPretty {\n     path: \"src/test/run-pass/pretty\",\n@@ -999,11 +997,7 @@ impl Step for Compiletest {\n             });\n         }\n \n-        if suite.ends_with(\"fulldeps\") ||\n-            // FIXME: Does pretty need librustc compiled? Note that there are\n-            // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\"\n-        {\n+        if suite.ends_with(\"fulldeps\") {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n "}, {"sha": "560df2f3a5700b6d521aa27667150a929a8dfef5", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -4,6 +4,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   make \\\n   file \\\n+  wget \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n@@ -18,19 +19,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n WORKDIR /build/\n \n-COPY scripts/musl.sh /build/\n+COPY scripts/musl-toolchain.sh /build/\n # We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n-RUN CC=gcc \\\n-    CFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n-    CXX=g++ \\\n+RUN CFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n     CXXFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n-    bash musl.sh x86_64 && rm -rf /build\n+    bash musl-toolchain.sh x86_64 && rm -rf build\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --musl-root-x86_64=/musl-x86_64 \\\n+      --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n       --enable-extended \\\n       --disable-docs\n \n@@ -41,6 +40,12 @@ ENV RUST_CONFIGURE_ARGS \\\n # See: https://github.com/rust-lang/rust/issues/34978\n ENV CFLAGS_x86_64_unknown_linux_musl=-Wa,-mrelax-relocations=no\n \n-ENV SCRIPT \\\n-      python2.7 ../x.py test --target x86_64-unknown-linux-musl && \\\n-      python2.7 ../x.py dist --target x86_64-unknown-linux-musl\n+ENV HOSTS=x86_64-unknown-linux-musl \\\n+    CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n+    CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n+\n+# Musl defaults to static libs but we need them to be dynamic for host toolchain.\n+# The toolchain will produce static libs by default.\n+ENV RUSTFLAGS=\"-C target-feature=-crt-static\"\n+\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "95b7c2869c91f97906f2bc44fd70d543bf54fcf8", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,70 @@\n+# This script runs `musl-cross-make` to prepare C toolchain (Binutils, GCC, musl itself)\n+# and builds static libunwind that we distribute for static target.\n+#\n+# Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n+# musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n+# Right now we have: Binutils 2.27, GCC 6.3.0, musl 1.1.18\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  rm /tmp/build.log\n+  set -x\n+}\n+\n+ARCH=$1\n+TARGET=$ARCH-linux-musl\n+\n+OUTPUT=/usr/local\n+shift\n+\n+git clone https://github.com/richfelker/musl-cross-make -b v0.9.7\n+cd musl-cross-make\n+\n+hide_output make -j$(nproc) TARGET=$TARGET\n+hide_output make install TARGET=$TARGET OUTPUT=$OUTPUT\n+\n+cd -\n+\n+# Install musl library to make binaries executable\n+ln -s $OUTPUT/$TARGET/lib/libc.so /lib/ld-musl-$ARCH.so.1\n+echo $OUTPUT/$TARGET/lib >> /etc/ld-musl-$ARCH.path\n+\n+\n+export CC=$TARGET-gcc\n+export CXX=$TARGET-g++\n+\n+LLVM=70\n+\n+# may have been downloaded in a previous run\n+if [ ! -d libunwind-release_$LLVM ]; then\n+  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n+  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n+fi\n+\n+# fixme(mati865): Replace it with https://github.com/rust-lang/rust/pull/59089\n+mkdir libunwind-build\n+cd libunwind-build\n+cmake ../libunwind-release_$LLVM \\\n+          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n+          -DLIBUNWIND_ENABLE_SHARED=0 \\\n+          -DCMAKE_C_COMPILER=$CC \\\n+          -DCMAKE_CXX_COMPILER=$CXX \\\n+          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n+          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n+\n+hide_output make -j$(nproc)\n+cp lib/libunwind.a $OUTPUT/$TARGET/lib\n+cd - && rm -rf libunwind-build\n+"}, {"sha": "611a24a69bd37e4b94850e21fc84484dc55a0ba7", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -11,7 +11,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  xz-utils\n+  xz-utils \\\n+  wget \\\n+  patch\n \n # FIXME: build the `ptx-linker` instead.\n RUN curl -sL https://github.com/denzp/rust-ptx-linker/releases/download/v0.9.0-alpha.2/rust-ptx-linker.linux64.tar.gz | \\\n@@ -20,10 +22,16 @@ RUN curl -sL https://github.com/denzp/rust-ptx-linker/releases/download/v0.9.0-a\n RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n   tar -xJ\n \n+WORKDIR /build/\n+COPY scripts/musl-toolchain.sh /build/\n+RUN bash musl-toolchain.sh x86_64 && rm -rf build\n+WORKDIR /\n+\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n+  --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n   --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n   --set rust.lld\n \n@@ -48,4 +56,9 @@ ENV NVPTX_SCRIPT python2.7 /checkout/x.py test --target $NVPTX_TARGETS \\\n   src/test/run-make \\\n   src/test/assembly\n \n-ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT\n+ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n+    CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n+    CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n+ENV MUSL_SCRIPT python2.7 /checkout/x.py test --target $MUSL_TARGETS\n+\n+ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "6767cf89f73ba2ce205cd784050eda5b9be72e5f", "filename": "src/liballoc/prelude.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Fliballoc%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,19 +0,0 @@\n-//! The alloc Prelude\n-//!\n-//! The purpose of this module is to alleviate imports of commonly-used\n-//! items of the `alloc` crate by adding a glob import to the top of modules:\n-//!\n-//! ```\n-//! # #![allow(unused_imports)]\n-//! # #![feature(alloc)]\n-//! extern crate alloc;\n-//! use alloc::prelude::*;\n-//! ```\n-\n-#![unstable(feature = \"alloc\", issue = \"27783\")]\n-\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::slice::SliceConcatExt;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::vec::Vec;"}, {"sha": "33cc51d173203172a8e74aaa175491ccd4412a06", "filename": "src/liballoc/prelude/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,16 @@\n+//! The alloc Prelude\n+//!\n+//! The purpose of this module is to alleviate imports of commonly-used\n+//! items of the `alloc` crate by adding a glob import to the top of modules:\n+//!\n+//! ```\n+//! # #![allow(unused_imports)]\n+//! # #![feature(alloc)]\n+//! #![feature(alloc_prelude)]\n+//! extern crate alloc;\n+//! use alloc::prelude::v1::*;\n+//! ```\n+\n+#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+\n+pub mod v1;"}, {"sha": "b6b01395ad63225f114dc23e756e310172856f61", "filename": "src/liballoc/prelude/v1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,11 @@\n+//! The first version of the prelude of `alloc` crate.\n+//!\n+//! See the [module-level documentation](../index.html) for more.\n+\n+#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::slice::SliceConcatExt;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;"}, {"sha": "0930f8dacd494e7e6619989f086eca2c3a5405e2", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -282,7 +282,7 @@ fn assert_covariance() {\n //\n // Destructors must be called exactly once per element.\n #[test]\n-#[cfg(not(miri))] // Miri does not support panics\n+#[cfg(not(miri))] // Miri does not support panics nor entropy\n fn panic_safe() {\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "844afe870766ba1d2c161ecd9af933d96ee0890a", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -226,39 +226,34 @@ fn test_range_equal_empty_cases() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_equal_excluded() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_1() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_2() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_3() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_4() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Excluded(2)));"}, {"sha": "b54c128a0249a59d7d00c77b5f2efcf2249027b7", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -258,7 +258,6 @@ fn test_swap_remove() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_fail() {\n     let mut v = vec![1];\n     let _ = v.swap_remove(0);\n@@ -632,7 +631,6 @@ fn test_insert() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_insert_oob() {\n     let mut a = vec![1, 2, 3];\n     a.insert(4, 5);\n@@ -657,7 +655,6 @@ fn test_remove() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_remove_fail() {\n     let mut a = vec![1];\n     let _ = a.remove(0);\n@@ -939,7 +936,6 @@ fn test_windowsator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_windowsator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.windows(0);\n@@ -964,7 +960,6 @@ fn test_chunksator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_chunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks(0);\n@@ -989,7 +984,6 @@ fn test_chunks_exactator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_chunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks_exact(0);\n@@ -1014,7 +1008,6 @@ fn test_rchunksator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks(0);\n@@ -1039,7 +1032,6 @@ fn test_rchunks_exactator() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks_exact(0);\n@@ -1092,7 +1084,6 @@ fn test_vec_default() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault() {\n     let mut v = vec![];\n     v.reserve_exact(!0);\n@@ -1102,7 +1093,6 @@ fn test_overflow_does_not_cause_segfault() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault_managed() {\n     let mut v = vec![Rc::new(1)];\n     v.reserve_exact(!0);\n@@ -1278,7 +1268,6 @@ fn test_mut_chunks_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_mut(0);\n@@ -1311,7 +1300,6 @@ fn test_mut_chunks_exact_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_exact_mut(0);\n@@ -1344,7 +1332,6 @@ fn test_mut_rchunks_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_mut(0);\n@@ -1377,7 +1364,6 @@ fn test_mut_rchunks_exact_rev() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_exact_mut(0);\n@@ -1411,7 +1397,7 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support panics\n+#[cfg(not(miri))] // Miri does not support threads nor entropy\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -1476,7 +1462,6 @@ fn test_copy_from_slice() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_longer() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 5];\n@@ -1485,7 +1470,6 @@ fn test_copy_from_slice_dst_longer() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_shorter() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 3];\n@@ -1605,7 +1589,7 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-#[cfg(not(miri))] // Miri does not support panics\n+#[cfg(not(miri))] // Miri does not support threads nor entropy\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {"}, {"sha": "b197516403f7818e6a6b9b7a0f2cc08fb5dc799f", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -7,7 +7,7 @@ fn test_le() {\n     assert!(\"\" <= \"\");\n     assert!(\"\" <= \"foo\");\n     assert!(\"foo\" <= \"foo\");\n-    assert!(\"foo\" != \"bar\");\n+    assert_ne!(\"foo\", \"bar\");\n }\n \n #[test]\n@@ -351,7 +351,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of bounds\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!(\"abc\", 0..5, \"abc\");\n     }\n@@ -361,7 +360,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!(\"abc\", 0..2, \"abc\");\n     }\n@@ -409,7 +407,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v: String = $data.into();\n                     let v: &str = &v;\n@@ -418,7 +415,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v: String = $data.into();\n                     let v: &mut str = &mut v;\n@@ -514,7 +510,6 @@ mod slice_index {\n \n     #[test]\n     #[should_panic]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail() {\n         &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n     }\n@@ -666,14 +661,12 @@ mod slice_index {\n     // check the panic includes the prefix of the sliced string\n     #[test]\n     #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_1() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n     // check the truncation in the panic message\n     #[test]\n     #[should_panic(expected=\"luctus, im`[...]\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_2() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n@@ -688,7 +681,6 @@ fn test_str_slice_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slice_rangetoinclusive_notok() {\n     let s = \"abc\u03b1\u03b2\u03b3\";\n     &s[..=3];\n@@ -704,7 +696,6 @@ fn test_str_slicemut_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slicemut_rangetoinclusive_notok() {\n     let mut s = \"abc\u03b1\u03b2\u03b3\".to_owned();\n     let s: &mut str = &mut s;\n@@ -894,7 +885,6 @@ fn test_as_bytes() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_as_bytes_fail() {\n     // Don't double free. (I'm not sure if this exercises the\n     // original problem code path anymore.)\n@@ -984,7 +974,6 @@ fn test_split_at_mut() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     s.split_at(1);"}, {"sha": "7e75b8c4f28c80687b2e77a22c5fa69d1c7e06da", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -231,7 +231,6 @@ fn test_split_off_empty() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_past_end() {\n     let orig = \"Hello, world!\";\n     let mut split = String::from(orig);\n@@ -240,7 +239,6 @@ fn test_split_off_past_end() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_mid_char() {\n     let mut orig = String::from(\"\u5c71\");\n     orig.split_off(1);\n@@ -289,7 +287,6 @@ fn test_str_truncate_invalid_len() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_str_truncate_split_codepoint() {\n     let mut s = String::from(\"\\u{FC}\"); // \u00fc\n     s.truncate(1);\n@@ -324,7 +321,6 @@ fn remove() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn remove_bad() {\n     \"\u0e28\".to_string().remove(1);\n }\n@@ -360,13 +356,11 @@ fn insert() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad1() {\n     \"\".to_string().insert(1, 't');\n }\n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad2() {\n     \"\u1ec7\".to_string().insert(1, 't');\n }\n@@ -447,7 +441,6 @@ fn test_replace_range() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_char_boundary() {\n     let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n     s.replace_range(..8, \"\");\n@@ -464,15 +457,13 @@ fn test_replace_range_inclusive_range() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..6, \"789\");\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..=5, \"789\");"}, {"sha": "545332bcd6a2f3985c5243bcb08b7f3417e7ce7f", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -368,7 +368,6 @@ fn test_vec_truncate_drop() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_vec_truncate_fail() {\n     struct BadElem(i32);\n     impl Drop for BadElem {\n@@ -392,55 +391,48 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let vec = vec![1, 2, 3];\n     let _ = vec[3];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_1() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_2() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[..6];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_3() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..4];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_4() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[1..6];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_5() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[3..2];\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_empty() {\n     let mut vec = Vec::<i32>::new();\n     vec.swap_remove(0);\n@@ -511,7 +503,6 @@ fn test_drain_items_zero_sized() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..6);\n@@ -585,7 +576,6 @@ fn test_drain_max_vec_size() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..=5);\n@@ -615,7 +605,6 @@ fn test_splice_inclusive_range() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n@@ -624,7 +613,6 @@ fn test_splice_out_of_bounds() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];"}, {"sha": "e0fe10a55f55c5623692cb5a3ef310de9f5d6100", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -108,7 +108,6 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let mut deq = VecDeque::new();\n     for i in 1..4 {"}, {"sha": "7de94d25c7618f7b0e32b2e8bedefb58013102fd", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -567,6 +567,32 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     where Self: Sized {\n         if self <= other { self } else { other }\n     }\n+\n+    /// Returns max if self is greater than max, and min if self is less than min.\n+    /// Otherwise this will return self.  Panics if min > max.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(clamp)]\n+    ///\n+    /// assert!((-3).clamp(-2, 1) == -2);\n+    /// assert!(0.clamp(-2, 1) == 0);\n+    /// assert!(2.clamp(-2, 1) == 1);\n+    /// ```\n+    #[unstable(feature = \"clamp\", issue = \"44095\")]\n+    fn clamp(self, min: Self, max: Self) -> Self\n+    where Self: Sized {\n+        assert!(min <= max);\n+        if self < min {\n+            min\n+        }\n+        else if self > max {\n+            max\n+        } else {\n+            self\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5cc9c25c21e0f81044eeac7d1f39a16601343edb", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -79,9 +79,9 @@ impl fmt::Debug for VaListImpl {\n                      all supported platforms\",\n            issue = \"44930\")]\n struct VaListImpl {\n-    stack: *mut (),\n-    gr_top: *mut (),\n-    vr_top: *mut (),\n+    stack: *mut c_void,\n+    gr_top: *mut c_void,\n+    vr_top: *mut c_void,\n     gr_offs: i32,\n     vr_offs: i32,\n }\n@@ -98,8 +98,8 @@ struct VaListImpl {\n     gpr: u8,\n     fpr: u8,\n     reserved: u16,\n-    overflow_arg_area: *mut (),\n-    reg_save_area: *mut (),\n+    overflow_arg_area: *mut c_void,\n+    reg_save_area: *mut c_void,\n }\n \n /// x86_64 ABI implementation of a `va_list`.\n@@ -113,8 +113,8 @@ struct VaListImpl {\n struct VaListImpl {\n     gp_offset: i32,\n     fp_offset: i32,\n-    overflow_arg_area: *mut (),\n-    reg_save_area: *mut (),\n+    overflow_arg_area: *mut c_void,\n+    reg_save_area: *mut c_void,\n }\n \n /// A wrapper for a `va_list`"}, {"sha": "cccd51b577930c78a6e6bc452ec60b011c8dd070", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1198,7 +1198,7 @@ impl<I: Iterator> Peekable<I> {\n     }\n }\n \n-/// An iterator that rejects elements while `predicate` is true.\n+/// An iterator that rejects elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n /// documentation for more.\n@@ -1286,7 +1286,7 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n impl<I, P> FusedIterator for SkipWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n-/// An iterator that only accepts elements while `predicate` is true.\n+/// An iterator that only accepts elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n /// documentation for more."}, {"sha": "ffc24df3ed42e2cc0e07ef6b712afd438d90f3ba", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -39,8 +39,7 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n \n /// Creates a new iterator that endlessly repeats a single element.\n ///\n-/// The `repeat()` function repeats a single value over and over and over and\n-/// over and over and \ud83d\udd01.\n+/// The `repeat()` function repeats a single value over and over again.\n ///\n /// Infinite iterators like `repeat()` are often used with adapters like\n /// [`take`], in order to make them finite.\n@@ -128,8 +127,7 @@ unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n /// Creates a new iterator that repeats elements of type `A` endlessly by\n /// applying the provided closure, the repeater, `F: FnMut() -> A`.\n ///\n-/// The `repeat_with()` function calls the repeater over and over and over and\n-/// over and over and \ud83d\udd01.\n+/// The `repeat_with()` function calls the repeater over and over again.\n ///\n /// Infinite iterators like `repeat_with()` are often used with adapters like\n /// [`take`], in order to make them finite."}, {"sha": "3d2fcdc97937701fc8c16a27b21e47ff88bf3612", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1111,11 +1111,12 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n+//\n // FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n #[derive(Copy)]\n-// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::uninitialized`.\n+// NOTE: after stabilizing `MaybeUninit`, proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n@@ -1125,13 +1126,13 @@ pub union MaybeUninit<T> {\n impl<T: Copy> Clone for MaybeUninit<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n-        // Not calling T::clone(), we cannot know if we are initialized enough for that.\n+        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n         *self\n     }\n }\n \n impl<T> MaybeUninit<T> {\n-    /// Create a new `MaybeUninit<T>` initialized with the given value.\n+    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1239,6 +1240,7 @@ impl<T> MaybeUninit<T> {\n     /// let x_vec = unsafe { &*x.as_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n+    ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n@@ -1277,6 +1279,7 @@ impl<T> MaybeUninit<T> {\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n+    ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]"}, {"sha": "a83134a6b2ca49694ee4a2e0373dc2f29289f4a2", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -326,7 +326,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n     round_by_remainder(v, rem, q, z)\n }\n \n-/// Skip over most Algorithm M iterations by checking the bit length.\n+/// Skips over most Algorithm M iterations by checking the bit length.\n fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n     // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n     // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)"}, {"sha": "d62cdae0688bea5f6c7bb8261d53b796afbd89e7", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -304,8 +304,8 @@ fn simplify(decimal: &mut Decimal) {\n     }\n }\n \n-/// Quick and dirty upper bound on the size (log10) of the largest value that Algorithm R and\n-/// Algorithm M will compute while working on the given decimal.\n+/// Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R\n+/// and Algorithm M will compute while working on the given decimal.\n fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n     // We don't need to worry too much about overflow here thanks to trivial_cases() and the\n     // parser, which filter out the most extreme inputs for us.\n@@ -324,7 +324,7 @@ fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n     }\n }\n \n-/// Detect obvious overflows and underflows without even looking at the decimal digits.\n+/// Detects obvious overflows and underflows without even looking at the decimal digits.\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {"}, {"sha": "f970595452ec9c8ab4f2899bd775212761cab104", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -78,7 +78,7 @@ pub fn parse_decimal(s: &str) -> ParseResult {\n     }\n }\n \n-/// Carve off decimal digits up to the first non-digit character.\n+/// Carves off decimal digits up to the first non-digit character.\n fn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n     let mut i = 0;\n     while i < s.len() && b'0' <= s[i] && s[i] <= b'9' {"}, {"sha": "a8da31d3e4858c6eb0cb74494dbf59ff1c863f2b", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -10,7 +10,7 @@ use num::dec2flt::rawfp::RawFloat;\n ///\n /// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n ///   round to the original value. The range is inclusive only when\n-///   `inclusive` is true.\n+///   `inclusive` is `true`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Decoded {\n     /// The scaled mantissa."}, {"sha": "defd4247f4ea49b747d7fbc297ebf78bfa0176f1", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -315,15 +315,15 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n     }\n }\n \n-/// Formats given decimal digits `0.<...buf...> * 10^exp` into the exponential form\n-/// with at least given number of significant digits. When `upper` is true,\n+/// Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n+/// form with at least the given number of significant digits. When `upper` is `true`,\n /// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n /// stored to the supplied parts array and a slice of written parts is returned.\n ///\n /// `min_digits` can be less than the number of actual significant digits in `buf`;\n /// it will be ignored and full digits will be printed. It is only used to print\n-/// additional zeroes after rendered digits. Thus `min_digits` of 0 means that\n-/// it will only print given digits and nothing else.\n+/// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n+/// it will only print the given digits and nothing else.\n fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n                          parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n@@ -384,7 +384,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n     }\n }\n \n-/// Formats given floating point number into the decimal form with at least\n+/// Formats the given floating point number into the decimal form with at least\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n@@ -438,7 +438,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n     }\n }\n \n-/// Formats given floating point number into the decimal form or\n+/// Formats the given floating point number into the decimal form or\n /// the exponential form, depending on the resulting exponent. The result is\n /// stored to the supplied parts array while utilizing given byte buffer\n /// as a scratch. `upper` is used to determine the case of non-finite values\n@@ -497,7 +497,7 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n     }\n }\n \n-/// Returns rather crude approximation (upper bound) for the maximum buffer size\n+/// Returns a rather crude approximation (upper bound) for the maximum buffer size\n /// calculated from the given decoded exponent.\n ///\n /// The exact limit is:"}, {"sha": "4f71c8e794954157c8a9d3354b581661aa2d8b9a", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -71,7 +71,7 @@ impl fmt::Debug for RangeFull {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n #[doc(alias = \"..\")]\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -95,8 +95,6 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!(!(3..5).contains(&2));\n@@ -112,7 +110,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(0.0..f32::NAN).contains(&0.5));\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -175,7 +173,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n #[doc(alias = \"..\")]\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -196,8 +194,6 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!(!(3..).contains(&2));\n@@ -208,7 +204,7 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!(!(0.0..).contains(&f32::NAN));\n     /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -280,8 +276,6 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!( (..5).contains(&-1_000_000_000));\n@@ -292,7 +286,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!(!(..1.0).contains(&f32::NAN));\n     /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -329,7 +323,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n-#[derive(Clone)]  // not Copy -- see #27186\n+#[derive(Clone)] // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n     pub(crate) start: Idx,\n@@ -365,7 +359,8 @@ impl<T: PartialOrd> RangeInclusiveEquality for T {\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start && self.end == other.end\n+        self.start == other.start\n+            && self.end == other.end\n             && RangeInclusiveEquality::canonicalized_is_empty(self)\n                 == RangeInclusiveEquality::canonicalized_is_empty(other)\n     }\n@@ -397,7 +392,11 @@ impl<Idx> RangeInclusive<Idx> {\n     #[inline]\n     #[rustc_promotable]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end, is_empty: None }\n+        Self {\n+            start,\n+            end,\n+            is_empty: None,\n+        }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -478,8 +477,6 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!(!(3..=5).contains(&2));\n@@ -496,7 +493,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n     /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -609,15 +606,12 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!( (..=5).contains(&-1_000_000_000));\n@@ -628,7 +622,7 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!(!(..=1.0).contains(&f32::NAN));\n     /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n         Idx: PartialOrd<U>,\n@@ -730,14 +724,11 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n     fn end_bound(&self) -> Bound<&T>;\n \n-\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains)]\n-    ///\n     /// use std::f32;\n     ///\n     /// assert!( (3..5).contains(&4));\n@@ -747,7 +738,7 @@ pub trait RangeBounds<T: ?Sized> {\n     /// assert!(!(0.0..1.0).contains(&f32::NAN));\n     /// assert!(!(0.0..f32::NAN).contains(&0.5));\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n-    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     fn contains<U>(&self, item: &U) -> bool\n     where\n         T: PartialOrd<U>,\n@@ -757,9 +748,7 @@ pub trait RangeBounds<T: ?Sized> {\n             Included(ref start) => *start <= item,\n             Excluded(ref start) => *start < item,\n             Unbounded => true,\n-        })\n-        &&\n-        (match self.end_bound() {\n+        }) && (match self.end_bound() {\n             Included(ref end) => item <= *end,\n             Excluded(ref end) => item < *end,\n             Unbounded => true,\n@@ -835,15 +824,15 @@ impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n         match *self {\n             (Included(ref start), _) => Included(start),\n             (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _)           => Unbounded,\n+            (Unbounded, _) => Unbounded,\n         }\n     }\n \n     fn end_bound(&self) -> Bound<&T> {\n         match *self {\n             (_, Included(ref end)) => Included(end),\n             (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded)         => Unbounded,\n+            (_, Unbounded) => Unbounded,\n         }\n     }\n }"}, {"sha": "dfc388409a84b53744287394c1428ab37639fe47", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -210,7 +210,7 @@ impl<T> Option<T> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Option<T>` to `Option<&T>`.\n+    /// Converts from `&Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n     ///\n@@ -239,7 +239,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<&mut T>`.\n+    /// Converts from `&mut Option<T>` to `Option<&mut T>`.\n     ///\n     /// # Examples\n     ///\n@@ -881,15 +881,13 @@ impl<T: Copy> Option<&T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(copied)]\n-    ///\n     /// let x = 12;\n     /// let opt_x = Some(&x);\n     /// assert_eq!(opt_x, Some(&12));\n     /// let copied = opt_x.copied();\n     /// assert_eq!(copied, Some(12));\n     /// ```\n-    #[unstable(feature = \"copied\", issue = \"57126\")]\n+    #[stable(feature = \"copied\", since = \"1.35.0\")]\n     pub fn copied(self) -> Option<T> {\n         self.map(|&t| t)\n     }\n@@ -902,15 +900,13 @@ impl<T: Copy> Option<&mut T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(copied)]\n-    ///\n     /// let mut x = 12;\n     /// let opt_x = Some(&mut x);\n     /// assert_eq!(opt_x, Some(&mut 12));\n     /// let copied = opt_x.copied();\n     /// assert_eq!(copied, Some(12));\n     /// ```\n-    #[unstable(feature = \"copied\", issue = \"57126\")]\n+    #[stable(feature = \"copied\", since = \"1.35.0\")]\n     pub fn copied(self) -> Option<T> {\n         self.map(|&mut t| t)\n     }"}, {"sha": "cf55b6c379d047482a0df491bf422ed1ee9f838f", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-//! Types which pin data to its location in memory\n+//! Types that pin data to its location in memory.\n //!\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon."}, {"sha": "967f7e3e2fe72fc9cbbc2a80b3e44f13c412af74", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -369,7 +369,7 @@ impl<T, E> Result<T, E> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Result<T, E>` to `Result<&T, &E>`.\n+    /// Converts from `&Result<T, E>` to `Result<&T, &E>`.\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n@@ -394,7 +394,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.\n+    /// Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "528281d317be34b23797774023d5bb58b1c2ac57", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2968,7 +2968,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3143,7 +3143,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3326,7 +3326,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n@@ -3402,7 +3402,7 @@ impl str {\n     ///\n     /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n     /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    /// elements. This is true for, e.g., [`char`], but not for `&str`.\n     ///\n     /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///"}, {"sha": "12f812d3bed3eb6582519d1dab8ff6bdd7a407c9", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -108,7 +108,7 @@ impl Waker {\n         unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n+    /// Returns `true` if this `Waker` and another `Waker` have awoken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function"}, {"sha": "7bd7d1874101af0083f3ff9432cf67f6a0b059f8", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -5,15 +5,15 @@ use std::mem::drop;\n #[test]\n fn smoketest_cell() {\n     let x = Cell::new(10);\n-    assert!(x == Cell::new(10));\n-    assert!(x.get() == 10);\n+    assert_eq!(x, Cell::new(10));\n+    assert_eq!(x.get(), 10);\n     x.set(20);\n-    assert!(x == Cell::new(20));\n-    assert!(x.get() == 20);\n+    assert_eq!(x, Cell::new(20));\n+    assert_eq!(x.get(), 20);\n \n     let y = Cell::new((30, 40));\n-    assert!(y == Cell::new((30, 40)));\n-    assert!(y.get() == (30, 40));\n+    assert_eq!(y, Cell::new((30, 40)));\n+    assert_eq!(y.get(), (30, 40));\n }\n \n #[test]\n@@ -109,7 +109,6 @@ fn double_borrow_single_release_no_borrow_mut() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn discard_doesnt_unborrow() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -350,7 +349,6 @@ fn refcell_ref_coercion() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn refcell_swap_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -360,7 +358,6 @@ fn refcell_swap_borrows() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn refcell_replace_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();"}, {"sha": "a3f0b02e2fe33f76b042cfb9ba445831cb2c2013", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -253,7 +253,6 @@ fn test_iterator_step_by_nth_overflow() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_iterator_step_by_zero() {\n     let mut it = (0..).step_by(0);\n     it.next();\n@@ -1442,7 +1441,6 @@ fn test_rposition() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_rposition_panic() {\n     let v: [(Box<_>, Box<_>); 4] =\n         [(box 0, box 0), (box 0, box 0),"}, {"sha": "a50310e195f0d81e37fa537afecbac71f3c49157", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,6 +1,5 @@\n #![feature(box_syntax)]\n #![feature(cell_update)]\n-#![feature(copied)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]"}, {"sha": "b873f1dd0652f82855570caaf898692f2bac3354", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,7 +3,6 @@ use core::num::bignum::tests::Big8x3 as Big;\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_from_u64_overflow() {\n     Big::from_u64(0x1000000);\n }\n@@ -20,14 +19,12 @@ fn test_add() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_1() {\n     Big::from_small(1).add(&Big::from_u64(0xffffff));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_2() {\n     Big::from_u64(0xffffff).add(&Big::from_small(1));\n }\n@@ -45,7 +42,6 @@ fn test_add_small() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_add_small_overflow() {\n     Big::from_u64(0xffffff).add_small(1);\n }\n@@ -61,14 +57,12 @@ fn test_sub() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_1() {\n     Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_2() {\n     Big::from_small(0).sub(&Big::from_u64(0x123456));\n }\n@@ -82,7 +76,6 @@ fn test_mul_small() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_small_overflow() {\n     Big::from_u64(0x800000).mul_small(2);\n }\n@@ -101,14 +94,12 @@ fn test_mul_pow2() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_1() {\n     Big::from_u64(0x1).mul_pow2(24);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_2() {\n     Big::from_u64(0x123).mul_pow2(16);\n }\n@@ -127,14 +118,12 @@ fn test_mul_pow5() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_1() {\n     Big::from_small(1).mul_pow5(12);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_2() {\n     Big::from_small(230).mul_pow5(8);\n }\n@@ -152,14 +141,12 @@ fn test_mul_digits() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_1() {\n     Big::from_u64(0x800000).mul_digits(&[2]);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_2() {\n     Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n }\n@@ -219,7 +206,6 @@ fn test_get_bit() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_get_bit_out_of_range() {\n     Big::from_small(42).get_bit(24);\n }"}, {"sha": "4881f79ec248aee8d20c00f4e91a6fd7b8dee2ec", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -12,7 +12,7 @@ mod tests {\n     fn test_overflows() {\n         assert!(MAX > 0);\n         assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n+        assert_eq!(MIN + MAX + 1, 0);\n     }\n \n     #[test]\n@@ -22,22 +22,22 @@ mod tests {\n \n     #[test]\n     fn test_rem_euclid() {\n-        assert!((-1 as $T).rem_euclid(MIN) == MAX);\n+        assert_eq!((-1 as $T).rem_euclid(MIN), MAX);\n     }\n \n     #[test]\n     pub fn test_abs() {\n-        assert!((1 as $T).abs() == 1 as $T);\n-        assert!((0 as $T).abs() == 0 as $T);\n-        assert!((-1 as $T).abs() == 1 as $T);\n+        assert_eq!((1 as $T).abs(), 1 as $T);\n+        assert_eq!((0 as $T).abs(), 0 as $T);\n+        assert_eq!((-1 as $T).abs(), 1 as $T);\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert!((1 as $T).signum() == 1 as $T);\n-        assert!((0 as $T).signum() == 0 as $T);\n-        assert!((-0 as $T).signum() == 0 as $T);\n-        assert!((-1 as $T).signum() == -1 as $T);\n+        assert_eq!((1 as $T).signum(), 1 as $T);\n+        assert_eq!((0 as $T).signum(), 0 as $T);\n+        assert_eq!((-0 as $T).signum(), 0 as $T);\n+        assert_eq!((-1 as $T).signum(), -1 as $T);\n     }\n \n     #[test]\n@@ -58,12 +58,12 @@ mod tests {\n \n     #[test]\n     fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(1));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(1));\n-        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n+        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(0b1010 as $T));\n+        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(0b1010 as $T));\n+        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(0b1010 as $T));\n+        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(1));\n+        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(1));\n+        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n     }\n \n     const A: $T = 0b0101100;\n@@ -75,17 +75,17 @@ mod tests {\n \n     #[test]\n     fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n+        assert_eq!(A.count_ones(), 3);\n+        assert_eq!(B.count_ones(), 2);\n+        assert_eq!(C.count_ones(), 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n         let bits = mem::size_of::<$T>() * 8;\n-        assert!(A.count_zeros() == bits as u32 - 3);\n-        assert!(B.count_zeros() == bits as u32 - 2);\n-        assert!(C.count_zeros() == bits as u32 - 5);\n+        assert_eq!(A.count_zeros(), bits as u32 - 3);\n+        assert_eq!(B.count_zeros(), bits as u32 - 2);\n+        assert_eq!(C.count_zeros(), bits as u32 - 5);\n     }\n \n     #[test]\n@@ -148,9 +148,9 @@ mod tests {\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!((10 as $T).checked_div(2) == Some(5));\n-        assert!((5 as $T).checked_div(0) == None);\n-        assert!(isize::MIN.checked_div(-1) == None);\n+        assert_eq!((10 as $T).checked_div(2), Some(5));\n+        assert_eq!((5 as $T).checked_div(0), None);\n+        assert_eq!(isize::MIN.checked_div(-1), None);\n     }\n \n     #[test]"}, {"sha": "78cf07119e729770a6c1ecf83c77efc912474651", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -7,23 +7,23 @@ fn test_range() {\n     let r = Range { start: 2, end: 10 };\n     let mut count = 0;\n     for (i, ri) in r.enumerate() {\n-        assert!(ri == i + 2);\n+        assert_eq!(ri, i + 2);\n         assert!(ri >= 2 && ri < 10);\n         count += 1;\n     }\n-    assert!(count == 8);\n+    assert_eq!(count, 8);\n }\n \n #[test]\n fn test_range_from() {\n     let r = RangeFrom { start: 2 };\n     let mut count = 0;\n     for (i, ri) in r.take(10).enumerate() {\n-        assert!(ri == i + 2);\n+        assert_eq!(ri, i + 2);\n         assert!(ri >= 2 && ri < 12);\n         count += 1;\n     }\n-    assert!(count == 10);\n+    assert_eq!(count, 10);\n }\n \n #[test]"}, {"sha": "b059b134868d999fae75fe4e75eba3c2ea03a3a7", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -69,7 +69,6 @@ fn test_option_dance() {\n }\n \n #[test] #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_option_too_much_dance() {\n     struct A;\n     let mut y = Some(A);\n@@ -130,15 +129,13 @@ fn test_unwrap() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic1() {\n     let x: Option<isize> = None;\n     x.unwrap();\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic2() {\n     let x: Option<String> = None;\n     x.unwrap();"}, {"sha": "1fab07526a07f7f3954a1faa84b802cb4751e795", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -117,7 +117,6 @@ fn test_unwrap_or_else() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n@@ -139,7 +138,6 @@ pub fn test_expect_ok() {\n }\n #[test]\n #[should_panic(expected=\"Got expected error: \\\"All good\\\"\")]\n-#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err() {\n     let err: Result<isize, &'static str> = Err(\"All good\");\n     err.expect(\"Got expected error\");\n@@ -153,7 +151,6 @@ pub fn test_expect_err_err() {\n }\n #[test]\n #[should_panic(expected=\"Got expected ok: \\\"All good\\\"\")]\n-#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err_ok() {\n     let err: Result<&'static str, isize> = Ok(\"All good\");\n     err.expect_err(\"Got expected ok\");"}, {"sha": "ac9c17a0f7c356ec4962927297b2490ad09044d5", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -782,7 +782,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of range\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n     }\n@@ -792,7 +791,6 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n-    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n@@ -842,7 +840,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v = $data;\n                     let v: &[_] = &v;\n@@ -851,7 +848,6 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n-                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v = $data;\n                     let v: &mut [_] = &mut v;\n@@ -1304,7 +1300,6 @@ fn test_copy_within() {\n \n #[test]\n #[should_panic(expected = \"src is out of bounds\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1313,15 +1308,13 @@ fn test_copy_within_panics_src_too_long() {\n \n #[test]\n #[should_panic(expected = \"dest is out of bounds\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_dest_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n #[should_panic(expected = \"src end is before src start\")]\n-#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}, {"sha": "6efd22572dc185d57fe9b06062cfccd93754e48a", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -107,14 +107,12 @@ fn checked_sub() {\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad1() {\n     let _ = Duration::new(0, 0) - Duration::new(0, 1);\n }\n \n #[test]\n #[should_panic]\n-#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad2() {\n     let _ = Duration::new(0, 0) - Duration::new(1, 0);\n }"}, {"sha": "ae6d8078fd2366ecb8452cac364b325cf619fae7", "filename": "src/libcore/time.rs", "status": "modified", "additions": 129, "deletions": 11, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -21,7 +21,6 @@ const NANOS_PER_MILLI: u32 = 1_000_000;\n const NANOS_PER_MICRO: u32 = 1_000;\n const MILLIS_PER_SEC: u64 = 1_000;\n const MICROS_PER_SEC: u64 = 1_000_000;\n-const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n \n /// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n@@ -510,15 +509,34 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// assert_eq!(dur.as_float_secs(), 2.7);\n+    /// assert_eq!(dur.as_secs_f64(), 2.7);\n     /// ```\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n-    pub const fn as_float_secs(&self) -> f64 {\n+    pub const fn as_secs_f64(&self) -> f64 {\n         (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)\n     }\n \n-    /// Creates a new `Duration` from the specified number of seconds.\n+    /// Returns the number of seconds contained by this `Duration` as `f32`.\n+    ///\n+    /// The returned value does include the fractional (nanosecond) part of the duration.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::new(2, 700_000_000);\n+    /// assert_eq!(dur.as_secs_f32(), 2.7);\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub const fn as_secs_f32(&self) -> f32 {\n+        (self.secs as f32) + (self.nanos as f32) / (NANOS_PER_SEC as f32)\n+    }\n+\n+    /// Creates a new `Duration` from the specified number of seconds represented\n+    /// as `f64`.\n     ///\n     /// # Panics\n     /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n@@ -528,12 +546,14 @@ impl Duration {\n     /// #![feature(duration_float)]\n     /// use std::time::Duration;\n     ///\n-    /// let dur = Duration::from_float_secs(2.7);\n+    /// let dur = Duration::from_secs_f64(2.7);\n     /// assert_eq!(dur, Duration::new(2, 700_000_000));\n     /// ```\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n-    pub fn from_float_secs(secs: f64) -> Duration {\n+    pub fn from_secs_f64(secs: f64) -> Duration {\n+        const MAX_NANOS_F64: f64 =\n+            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n         let nanos =  secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n@@ -551,6 +571,42 @@ impl Duration {\n         }\n     }\n \n+    /// Creates a new `Duration` from the specified number of seconds represented\n+    /// as `f32`.\n+    ///\n+    /// # Panics\n+    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::from_secs_f32(2.7);\n+    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn from_secs_f32(secs: f32) -> Duration {\n+        const MAX_NANOS_F32: f32 =\n+            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f32;\n+        let nanos =  secs * (NANOS_PER_SEC as f32);\n+        if !nanos.is_finite() {\n+            panic!(\"got non-finite value when converting float to duration\");\n+        }\n+        if nanos >= MAX_NANOS_F32 {\n+            panic!(\"overflow when converting float to duration\");\n+        }\n+        if nanos < 0.0 {\n+            panic!(\"underflow when converting float to duration\");\n+        }\n+        let nanos =  nanos as u128;\n+        Duration {\n+            secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n+            nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n+        }\n+    }\n+\n     /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n@@ -568,7 +624,29 @@ impl Duration {\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n     pub fn mul_f64(self, rhs: f64) -> Duration {\n-        Duration::from_float_secs(rhs * self.as_float_secs())\n+        Duration::from_secs_f64(rhs * self.as_secs_f64())\n+    }\n+\n+    /// Multiplies `Duration` by `f32`.\n+    ///\n+    /// # Panics\n+    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::new(2, 700_000_000);\n+    /// // note that due to rounding errors result is slightly different\n+    /// // from 8.478 and 847800.0\n+    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n+    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847799, 969_120_256));\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn mul_f32(self, rhs: f32) -> Duration {\n+        Duration::from_secs_f32(rhs * self.as_secs_f32())\n     }\n \n     /// Divide `Duration` by `f64`.\n@@ -589,7 +667,30 @@ impl Duration {\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n     pub fn div_f64(self, rhs: f64) -> Duration {\n-        Duration::from_float_secs(self.as_float_secs() / rhs)\n+        Duration::from_secs_f64(self.as_secs_f64() / rhs)\n+    }\n+\n+    /// Divide `Duration` by `f32`.\n+    ///\n+    /// # Panics\n+    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::new(2, 700_000_000);\n+    /// // note that due to rounding errors result is slightly\n+    /// // different from 0.859_872_611\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_576));\n+    /// // note that truncation is used, not rounding\n+    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn div_f32(self, rhs: f32) -> Duration {\n+        Duration::from_secs_f32(self.as_secs_f32() / rhs)\n     }\n \n     /// Divide `Duration` by `Duration` and return `f64`.\n@@ -601,12 +702,29 @@ impl Duration {\n     ///\n     /// let dur1 = Duration::new(2, 700_000_000);\n     /// let dur2 = Duration::new(5, 400_000_000);\n-    /// assert_eq!(dur1.div_duration(dur2), 0.5);\n+    /// assert_eq!(dur1.div_duration_f64(dur2), 0.5);\n+    /// ```\n+    #[unstable(feature = \"duration_float\", issue = \"54361\")]\n+    #[inline]\n+    pub fn div_duration_f64(self, rhs: Duration) -> f64 {\n+        self.as_secs_f64() / rhs.as_secs_f64()\n+    }\n+\n+    /// Divide `Duration` by `Duration` and return `f32`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_float)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur1 = Duration::new(2, 700_000_000);\n+    /// let dur2 = Duration::new(5, 400_000_000);\n+    /// assert_eq!(dur1.div_duration_f32(dur2), 0.5);\n     /// ```\n     #[unstable(feature = \"duration_float\", issue = \"54361\")]\n     #[inline]\n-    pub fn div_duration(self, rhs: Duration) -> f64 {\n-        self.as_float_secs() / rhs.as_float_secs()\n+    pub fn div_duration_f32(self, rhs: Duration) -> f32 {\n+        self.as_secs_f32() / rhs.as_secs_f32()\n     }\n }\n "}, {"sha": "eb75e624d34b2982ebff060f9ed42d609de36548", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -724,7 +724,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(*self)\n+        tcx.def_path_str(*self)\n     }\n }\n \n@@ -736,7 +736,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(DefId::local(*self))\n+        tcx.def_path_str(DefId::local(*self))\n     }\n }\n "}, {"sha": "397843fd75afa1d7f118af8002f58bb9e5608727", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -249,7 +249,7 @@ impl DefId {\n         if self.is_local() && self.index == CRATE_DEF_INDEX {\n             format!(\"top-level module\")\n         } else {\n-            format!(\"module `{}`\", tcx.item_path_str(*self))\n+            format!(\"module `{}`\", tcx.def_path_str(*self))\n         }\n     }\n }"}, {"sha": "dca4ce4aef81773e9ac5879a6fd0e750560f53f9", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -679,13 +679,13 @@ impl DefPathData {\n                 return name\n             }\n             // note that this does not show up in user printouts\n-            CrateRoot => \"{{root}}\",\n+            CrateRoot => \"{{crate}}\",\n             Impl => \"{{impl}}\",\n-            Misc => \"{{?}}\",\n+            Misc => \"{{misc}}\",\n             ClosureExpr => \"{{closure}}\",\n             StructCtor => \"{{constructor}}\",\n             AnonConst => \"{{constant}}\",\n-            ImplTrait => \"{{impl-Trait}}\",\n+            ImplTrait => \"{{opaque}}\",\n         };\n \n         Symbol::intern(s).as_interned_str()"}, {"sha": "151c5413dcf6058cd084d36ed5e5003c59a43d6a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -541,15 +541,17 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get_by_hir_id(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n             _ => bug!(\"ty_param_owner: {} not a type parameter\", self.hir_to_string(id))\n         }\n     }\n \n     pub fn ty_param_name(&self, id: HirId) -> Name {\n         match self.get_by_hir_id(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n         }\n@@ -1019,6 +1021,7 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find(id) {\n+            Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n             Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n@@ -1350,7 +1353,8 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         // the user-friendly path, otherwise fall back to stringifying DefPath.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n-                tcx.node_path_str(id)\n+                let def_id = map.local_def_id(id);\n+                tcx.def_path_str(def_id)\n             } else if let Some(path) = map.def_path_from_id(id) {\n                 path.data.into_iter().map(|elem| {\n                     elem.data.to_string()"}, {"sha": "2810b5a8e6ada5cad0922392a80cd56c44f0dd5b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 114, "deletions": 15, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     self.hir().span_by_hir_id(node),\n                 ),\n                 _ => (\n-                    format!(\"the lifetime {} as defined on\", fr.bound_region),\n+                    format!(\"the lifetime {} as defined on\", region),\n                     cm.def_span(self.hir().span_by_hir_id(node)),\n                 ),\n             },\n@@ -444,17 +444,109 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         terr: &TypeError<'tcx>,\n         sp: Span,\n     ) {\n+        use hir::def_id::CrateNum;\n+        use hir::map::DisambiguatedDefPathData;\n+        use ty::print::Printer;\n+        use ty::subst::Kind;\n+\n+        struct AbsolutePathPrinter<'a, 'gcx, 'tcx> {\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        }\n+\n+        struct NonTrivialPath;\n+\n+        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'_, 'gcx, 'tcx> {\n+            type Error = NonTrivialPath;\n+\n+            type Path = Vec<String>;\n+            type Region = !;\n+            type Type = !;\n+            type DynExistential = !;\n+\n+            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+                self.tcx\n+            }\n+\n+            fn print_region(\n+                self,\n+                _region: ty::Region<'_>,\n+            ) -> Result<Self::Region, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn print_type(\n+                self,\n+                _ty: Ty<'tcx>,\n+            ) -> Result<Self::Type, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn print_dyn_existential(\n+                self,\n+                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+            ) -> Result<Self::DynExistential, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn path_crate(\n+                self,\n+                cnum: CrateNum,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n+            }\n+            fn path_qualified(\n+                self,\n+                _self_ty: Ty<'tcx>,\n+                _trait_ref: Option<ty::TraitRef<'tcx>>,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n+            fn path_append_impl(\n+                self,\n+                _print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _disambiguated_data: &DisambiguatedDefPathData,\n+                _self_ty: Ty<'tcx>,\n+                _trait_ref: Option<ty::TraitRef<'tcx>>,\n+            ) -> Result<Self::Path, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+            fn path_append(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                disambiguated_data: &DisambiguatedDefPathData,\n+            ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+                path.push(disambiguated_data.data.as_interned_str().to_string());\n+                Ok(path)\n+            }\n+            fn path_generic_args(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _args: &[Kind<'tcx>],\n+            ) -> Result<Self::Path, Self::Error> {\n+                print_prefix(self)\n+            }\n+        }\n+\n         let report_path_match = |err: &mut DiagnosticBuilder<'_>, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n-                let exp_path = self.tcx.item_path_str(did1);\n-                let found_path = self.tcx.item_path_str(did2);\n-                let exp_abs_path = self.tcx.absolute_item_path_str(did1);\n-                let found_abs_path = self.tcx.absolute_item_path_str(did2);\n+                let abs_path = |def_id| {\n+                    AbsolutePathPrinter { tcx: self.tcx }\n+                        .print_def_path(def_id, &[])\n+                };\n+\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n-                if exp_path == found_path || exp_abs_path == found_abs_path {\n+                let same_path = || -> Result<_, NonTrivialPath> {\n+                    Ok(\n+                        self.tcx.def_path_str(did1) == self.tcx.def_path_str(did2) ||\n+                        abs_path(did1)? == abs_path(did2)?\n+                    )\n+                };\n+                if same_path().unwrap_or(false) {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n                     err.span_note(\n                         sp,\n@@ -658,7 +750,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 return Some(());\n             }\n             if let &ty::Adt(def, _) = &ta.sty {\n-                let path_ = self.tcx.item_path_str(def.did.clone());\n+                let path_ = self.tcx.def_path_str(def.did.clone());\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n                     return Some(());\n@@ -683,7 +775,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// For generic types with parameters with defaults, remove the parameters corresponding to\n-    /// the defaults. This repeats a lot of the logic found in `PrintContext::parameterized`.\n+    /// the defaults. This repeats a lot of the logic found in `ty::print::pretty`.\n     fn strip_generic_default_params(\n         &self,\n         def_id: DefId,\n@@ -742,11 +834,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n         ) {\n-            let r = &r.to_string();\n+            let mut r = r.to_string();\n+            if r == \"'_\" {\n+                r.clear();\n+            } else {\n+                r.push(' ');\n+            }\n             s.push_highlighted(format!(\n-                \"&{}{}{}\",\n+                \"&{}{}\",\n                 r,\n-                if r == \"\" { \"\" } else { \" \" },\n                 if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n             ));\n             s.push_normal(ty.to_string());\n@@ -757,8 +853,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n                 let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                let path1 = self.tcx.item_path_str(def1.did.clone());\n-                let path2 = self.tcx.item_path_str(def2.did.clone());\n+                let path1 = self.tcx.def_path_str(def1.did.clone());\n+                let path2 = self.tcx.def_path_str(def2.did.clone());\n                 if def1.did == def2.did {\n                     // Easy case. Replace same types with `_` to shorten the output and highlight\n                     // the differing ones.\n@@ -1013,7 +1109,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             if exp_is_struct && &exp_found.expected == ret_ty.skip_binder() {\n                                 let message = format!(\n                                     \"did you mean `{}(/* fields */)`?\",\n-                                    self.tcx.item_path_str(def_id)\n+                                    self.tcx.def_path_str(def_id)\n                                 );\n                                 diag.span_label(span, message);\n                             }\n@@ -1425,7 +1521,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         var_origin: RegionVariableOrigin,\n     ) -> DiagnosticBuilder<'tcx> {\n         let br_string = |br: ty::BoundRegion| {\n-            let mut s = br.to_string();\n+            let mut s = match br {\n+                ty::BrNamed(_, name) => name.to_string(),\n+                _ => String::new(),\n+            };\n             if !s.is_empty() {\n                 s.push_str(\" \");\n             }"}, {"sha": "0a83b839201ed299557903253fd250e8b7c47e70", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,8 +1,10 @@\n+use crate::hir::def::Namespace;\n use crate::hir::{self, Local, Pat, Body, HirId};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOrigin;\n use crate::ty::{self, Ty, Infer, TyVar};\n+use crate::ty::print::Print;\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -64,18 +66,26 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n \n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n+    pub fn extract_type_name(\n+        &self,\n+        ty: &'a Ty<'tcx>,\n+        highlight: Option<ty::print::RegionHighlightMode>,\n+    ) -> String {\n         if let ty::Infer(ty::TyVar(ty_vid)) = (*ty).sty {\n             let ty_vars = self.type_variables.borrow();\n             if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n                 *ty_vars.var_origin(ty_vid) {\n-                name.to_string()\n-            } else {\n-                ty.to_string()\n+                return name.to_string();\n             }\n-        } else {\n-            ty.to_string()\n         }\n+\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n+        if let Some(highlight) = highlight {\n+            printer.region_highlight_mode = highlight;\n+        }\n+        let _ = ty.print(printer);\n+        s\n     }\n \n     pub fn need_type_info_err(&self,\n@@ -84,7 +94,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ty: Ty<'tcx>)\n                             -> DiagnosticBuilder<'gcx> {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty);\n+        let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n         let mut labels = vec![("}, {"sha": "e708454b5b672fcd936f3c0e42ef53059ba6bbc8", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 125, "deletions": 108, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,14 +1,17 @@\n use errors::DiagnosticBuilder;\n+use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty;\n+use crate::ty::{self, TyCtxt};\n use crate::ty::error::ExpectedFound;\n use crate::ty::subst::SubstsRef;\n-use crate::util::ppaux::RegionHighlightMode;\n+use crate::ty::print::{Print, RegionHighlightMode, FmtPrinter};\n+\n+use std::fmt::{self, Write};\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -193,15 +196,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             cause.span(&self.tcx()),\n             &format!(\n                 \"implementation of `{}` is not general enough\",\n-                self.tcx().item_path_str(trait_def_id),\n+                self.tcx().def_path_str(trait_def_id),\n             ),\n         );\n \n         match cause.code {\n             ObligationCauseCode::ItemObligation(def_id) => {\n                 err.note(&format!(\n                     \"Due to a where-clause on `{}`,\",\n-                    self.tcx().item_path_str(def_id),\n+                    self.tcx().def_path_str(def_id),\n                 ));\n             }\n             _ => (),\n@@ -309,13 +312,46 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         sup_placeholder: Option<ty::Region<'tcx>>,\n         has_sub: Option<usize>,\n         has_sup: Option<usize>,\n-        expected_trait_ref: ty::TraitRef<'_>,\n-        actual_trait_ref: ty::TraitRef<'_>,\n+        expected_trait_ref: ty::TraitRef<'tcx>,\n+        actual_trait_ref: ty::TraitRef<'tcx>,\n         vid: Option<ty::Region<'tcx>>,\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n     ) {\n+        // HACK(eddyb) maybe move this in a more central location.\n+        #[derive(Copy, Clone)]\n+        struct Highlighted<'a, 'gcx, 'tcx, T> {\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            highlight: RegionHighlightMode,\n+            value: T,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx, T> Highlighted<'a, 'gcx, 'tcx, T> {\n+            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'a, 'gcx, 'tcx, U> {\n+                Highlighted {\n+                    tcx: self.tcx,\n+                    highlight: self.highlight,\n+                    value: f(self.value),\n+                }\n+            }\n+        }\n+\n+        impl<'a, 'gcx, 'tcx, T> fmt::Display for Highlighted<'a, 'gcx, 'tcx, T>\n+            where T: for<'b, 'c> Print<'gcx, 'tcx,\n+                FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n+                Error = fmt::Error,\n+            >,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, f, Namespace::TypeNS);\n+                printer.region_highlight_mode = self.highlight;\n+\n+                self.value.print(printer)?;\n+                Ok(())\n+            }\n+        }\n+\n         // The weird thing here with the `maybe_highlighting_region` calls and the\n         // the match inside is meant to be like this:\n         //\n@@ -331,112 +367,93 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         // None, an then we check again inside the closure, but this\n         // setup sort of minimized the number of calls and so form.\n \n-        RegionHighlightMode::maybe_highlighting_region(sub_placeholder, has_sub, || {\n-            RegionHighlightMode::maybe_highlighting_region(sup_placeholder, has_sup, || {\n-                match (has_sub, has_sup) {\n-                    (Some(n1), Some(n2)) => {\n-                        if any_self_ty_has_vid {\n-                            err.note(&format!(\n-                                \"`{}` would have to be implemented for the type `{}`, \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref,\n-                                expected_trait_ref.self_ty(),\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`, \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        }\n-                    }\n-                    (Some(n), _) | (_, Some(n)) => {\n-                        if any_self_ty_has_vid {\n-                            err.note(&format!(\n-                                \"`{}` would have to be implemented for the type `{}`, \\\n-                                 for any lifetime `'{}`\",\n-                                expected_trait_ref,\n-                                expected_trait_ref.self_ty(),\n-                                n,\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`, for any lifetime `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                n,\n-                            ));\n-                        }\n-                    }\n-                    (None, None) => RegionHighlightMode::maybe_highlighting_region(\n-                        vid,\n-                        expected_has_vid,\n-                        || {\n-                            if let Some(n) = expected_has_vid {\n-                                err.note(&format!(\n-                                    \"`{}` would have to be implemented for the type `{}`, \\\n-                                     for some specific lifetime `'{}`\",\n-                                    expected_trait_ref,\n-                                    expected_trait_ref.self_ty(),\n-                                    n,\n-                                ));\n-                            } else {\n-                                if any_self_ty_has_vid {\n-                                    err.note(&format!(\n-                                        \"`{}` would have to be implemented for the type `{}`\",\n-                                        expected_trait_ref,\n-                                        expected_trait_ref.self_ty(),\n-                                    ));\n-                                } else {\n-                                    err.note(&format!(\n-                                        \"`{}` must implement `{}`\",\n-                                        expected_trait_ref.self_ty(),\n-                                        expected_trait_ref,\n-                                    ));\n-                                }\n-                            }\n-                        },\n-                    ),\n-                }\n-            })\n-        });\n+        let highlight_trait_ref = |trait_ref| Highlighted {\n+            tcx: self.tcx(),\n+            highlight: RegionHighlightMode::default(),\n+            value: trait_ref,\n+        };\n \n-        RegionHighlightMode::maybe_highlighting_region(\n-            vid,\n-            actual_has_vid,\n-            || match actual_has_vid {\n-                Some(n) => {\n-                    if any_self_ty_has_vid {\n-                        err.note(&format!(\n-                            \"but `{}` is actually implemented for the type `{}`, \\\n-                             for some specific lifetime `'{}`\",\n-                            actual_trait_ref,\n-                            actual_trait_ref.self_ty(),\n-                            n\n-                        ));\n-                    } else {\n-                        err.note(&format!(\n-                            \"but `{}` actually implements `{}`, for some specific lifetime `'{}`\",\n-                            actual_trait_ref.self_ty(),\n-                            actual_trait_ref,\n-                            n\n-                        ));\n+        let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n+        expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n+        expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n+        err.note(&{\n+            let passive_voice = match (has_sub, has_sup) {\n+                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+                (None, None) => {\n+                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                    match expected_has_vid {\n+                        Some(_) => true,\n+                        None => any_self_ty_has_vid,\n                     }\n                 }\n+            };\n \n-                _ => {\n-                    err.note(&format!(\n-                        \"but `{}` is actually implemented for the type `{}`\",\n-                        actual_trait_ref,\n-                        actual_trait_ref.self_ty(),\n-                    ));\n+            let mut note = if passive_voice {\n+                format!(\n+                    \"`{}` would have to be implemented for the type `{}`\",\n+                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                )\n+            } else {\n+                format!(\n+                    \"`{}` must implement `{}`\",\n+                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                    expected_trait_ref,\n+                )\n+            };\n+\n+            match (has_sub, has_sup) {\n+                (Some(n1), Some(n2)) => {\n+                    let _ = write!(note,\n+                        \", for any two lifetimes `'{}` and `'{}`\",\n+                        std::cmp::min(n1, n2),\n+                        std::cmp::max(n1, n2),\n+                    );\n                 }\n-            },\n-        );\n+                (Some(n), _) | (_, Some(n)) => {\n+                    let _ = write!(note,\n+                        \", for any lifetime `'{}`\",\n+                        n,\n+                    );\n+                }\n+                (None, None) => if let Some(n) = expected_has_vid {\n+                    let _ = write!(note,\n+                        \", for some specific lifetime `'{}`\",\n+                        n,\n+                    );\n+                },\n+            }\n+\n+            note\n+        });\n+\n+        let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n+        actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+        err.note(&{\n+            let passive_voice = match actual_has_vid {\n+                Some(_) => any_self_ty_has_vid,\n+                None => true,\n+            };\n+\n+            let mut note = if passive_voice {\n+                format!(\n+                    \"but `{}` is actually implemented for the type `{}`\",\n+                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.self_ty()),\n+                )\n+            } else {\n+                format!(\n+                    \"but `{}` actually implements `{}`\",\n+                    actual_trait_ref.map(|tr| tr.self_ty()),\n+                    actual_trait_ref,\n+                )\n+            };\n+\n+            if let Some(n) = actual_has_vid {\n+                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n+            }\n+\n+            note\n+        });\n     }\n }"}, {"sha": "3ed28a1f9882562f495db732b2052a5dc41f46b9", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,7 +3,7 @@\n \n use crate::hir;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::ty::{self, Region, Ty};\n+use crate::ty::{self, DefIdTree, Region, Ty};\n use crate::hir::def_id::DefId;\n use syntax_pos::Span;\n \n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ref ebr) => (\n-                self.tcx().parent_def_id(ebr.def_id).unwrap(),\n+                self.tcx().parent(ebr.def_id).unwrap(),\n                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region"}, {"sha": "5349e990a77613781b2916e30530251ba0f0218b", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -91,7 +91,7 @@ impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n+        self.relation.maybe_map(|&fr| tcx.lift(&fr))\n                      .map(|relation| FreeRegionMap { relation })\n     }\n }"}, {"sha": "b6677326227f4e00b365a36b7f53509f240bfa56", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -31,6 +31,7 @@\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n \n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n@@ -134,9 +135,7 @@ pub mod ty;\n pub mod util {\n     pub mod captures;\n     pub mod common;\n-    pub mod ppaux;\n     pub mod nodemap;\n-    pub mod time_graph;\n     pub mod profiling;\n     pub mod bug;\n }"}, {"sha": "3c6635c03413152e979bad18b8aa7829aac5cfff", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -157,6 +157,7 @@ pub struct LintLevelsBuilder<'a> {\n \n pub struct BuilderPush {\n     prev: u32,\n+    pub(super) changed: bool,\n }\n \n impl<'a> LintLevelsBuilder<'a> {\n@@ -454,6 +455,7 @@ impl<'a> LintLevelsBuilder<'a> {\n \n         BuilderPush {\n             prev: prev,\n+            changed: prev != self.cur,\n         }\n     }\n \n@@ -512,11 +514,6 @@ impl LintLevelMap {\n             self.sets.get_lint_level(lint, *idx, None, session)\n         })\n     }\n-\n-    /// Returns if this `id` has lint level information.\n-    pub fn lint_level_set(&self, id: HirId) -> Option<u32> {\n-        self.id_to_set.get(&id).cloned()\n-    }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {"}, {"sha": "c01b0ae2ccc1db6cdc97e433ac267122cf6e8ce4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -721,6 +721,16 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n     return err\n }\n \n+pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n+    let attrs = tcx.hir().attrs_by_hir_id(id);\n+    for attr in attrs {\n+        if Level::from_str(&attr.name().as_str()).is_some() {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     -> Lrc<LintLevelMap>\n {\n@@ -731,9 +741,10 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     };\n     let krate = tcx.hir().krate();\n \n-    builder.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |builder| {\n-        intravisit::walk_crate(builder, krate);\n-    });\n+    let push = builder.levels.push(&krate.attrs);\n+    builder.levels.register_id(hir::CRATE_HIR_ID);\n+    intravisit::walk_crate(&mut builder, krate);\n+    builder.levels.pop(push);\n \n     Lrc::new(builder.levels.build_map())\n }\n@@ -751,7 +762,9 @@ impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n         where F: FnOnce(&mut Self)\n     {\n         let push = self.levels.push(attrs);\n-        self.levels.register_id(id);\n+        if push.changed {\n+            self.levels.register_id(id);\n+        }\n         f(self);\n         self.levels.pop(push);\n     }"}, {"sha": "3da82d728c0c4b96dd2201563668ed55fe456a8b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -12,7 +12,7 @@ use crate::hir::CodegenFnAttrFlags;\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::lint;\n use crate::middle::privacy;\n-use crate::ty::{self, TyCtxt};\n+use crate::ty::{self, DefIdTree, TyCtxt};\n use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n             Def::Local(..) | Def::Upvar(..) => {}\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n+                if let Some(enum_id) = self.tcx.parent(variant_id) {\n                     self.check_def_id(enum_id);\n                 }\n                 if !self.ignore_variant_stack.contains(&variant_id) {"}, {"sha": "b36d2a57cb3b1d3f4043e86599eaaa4c1c60242f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -64,7 +64,7 @@ use crate::hir::Node;\n use crate::infer::InferCtxt;\n use crate::hir::def::{Def, CtorKind};\n use crate::ty::adjustment;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::layout::VariantIdx;\n \n@@ -786,7 +786,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n-        let kind = match self.node_ty(fn_hir_id)?.sty {\n+        let ty = self.node_ty(fn_hir_id)?;\n+        let kind = match ty.sty {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n             ty::Closure(closure_def_id, closure_substs) => {\n                 match self.infcx {\n@@ -803,7 +804,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                 .closure_kind(closure_def_id, self.tcx.global_tcx()),\n                 }\n             }\n-            ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),\n+            _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n \n         let closure_expr_def_id = self.tcx.hir().local_def_id(fn_node_id);\n@@ -1064,7 +1065,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 let bk = ty::BorrowKind::from_mutbl(mutbl);\n                 BorrowedPtr(bk, r)\n             }\n-            ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n+            _ => bug!(\"unexpected type in cat_deref: {:?}\", base_cmt.ty)\n         };\n         let ret = cmt_ {\n             hir_id: node.hir_id(),\n@@ -1132,7 +1133,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                              variant_did: DefId)\n                                              -> cmt<'tcx> {\n         // univariant enums do not need downcasts\n-        let base_did = self.tcx.parent_def_id(variant_did).unwrap();\n+        let base_did = self.tcx.parent(variant_did).unwrap();\n         if self.tcx.adt_def(base_did).variants.len() != 1 {\n             let base_ty = base_cmt.ty;\n             let ret = Rc::new(cmt_ {\n@@ -1274,16 +1275,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         return Err(())\n                     }\n                     Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                        let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n+                        let enum_def = self.tcx.parent(def_id).unwrap();\n                         (self.cat_downcast_if_needed(pat, cmt, def_id),\n                         self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n                     }\n                     Def::StructCtor(_, CtorKind::Fn) | Def::SelfCtor(..) => {\n-                        match self.pat_ty_unadjusted(&pat)?.sty {\n+                        let ty = self.pat_ty_unadjusted(&pat)?;\n+                        match ty.sty {\n                             ty::Adt(adt_def, _) => {\n                                 (cmt, adt_def.non_enum_variant().fields.len())\n                             }\n-                            ref ty => {\n+                            _ => {\n                                 span_bug!(pat.span,\n                                           \"tuple struct pattern unexpected type {:?}\", ty);\n                             }\n@@ -1334,9 +1336,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             PatKind::Tuple(ref subpats, ddpos) => {\n                 // (p1, ..., pN)\n-                let expected_len = match self.pat_ty_unadjusted(&pat)?.sty {\n+                let ty = self.pat_ty_unadjusted(&pat)?;\n+                let expected_len = match ty.sty {\n                     ty::Tuple(ref tys) => tys.len(),\n-                    ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n+                    _ => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n                 };\n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)"}, {"sha": "2b3802388106a89e5fc689ae33febf33b0f108a6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -17,7 +17,7 @@ use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::TyCtxt;\n+use crate::ty::{DefIdTree, TyCtxt};\n use crate::ty::query::Providers;\n \n use crate::hir;\n@@ -650,7 +650,7 @@ impl<'tcx> ScopeTree {\n     pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       br: &ty::EarlyBoundRegion)\n                                       -> Scope {\n-        let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n+        let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n         let scope = tcx.hir().maybe_body_owned_by_by_hir_id(param_owner_id).map(|body_id| {\n@@ -679,7 +679,7 @@ impl<'tcx> ScopeTree {\n                                  -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n-                tcx.parent_def_id(def_id).unwrap()\n+                tcx.parent(def_id).unwrap()\n             }\n             _ => fr.scope\n         };"}, {"sha": "ab105360388722bdd72c378d7a935153362a3592", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2299,19 +2299,26 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n+        let mut lifetime_names = FxHashSet::default();\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n                 Scope::Body { .. } => return,\n \n                 Scope::Root => break None,\n \n-                Scope::Binder { s, .. } => {\n+                Scope::Binder { s, ref lifetimes, .. } => {\n+                    // collect named lifetimes for suggestions\n+                    for name in lifetimes.keys() {\n+                        if let hir::ParamName::Plain(name) = name {\n+                            lifetime_names.insert(*name);\n+                        }\n+                    }\n                     late_depth += 1;\n                     scope = s;\n                 }\n \n-                Scope::Elision { ref elide, .. } => {\n+                Scope::Elision { ref elide, ref s, .. } => {\n                     let lifetime = match *elide {\n                         Elide::FreshLateAnon(ref counter) => {\n                             for lifetime_ref in lifetime_refs {\n@@ -2321,7 +2328,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             return;\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n-                        Elide::Error(ref e) => break Some(e),\n+                        Elide::Error(ref e) => {\n+                            if let Scope::Binder { ref lifetimes, .. } = s {\n+                                // collect named lifetimes for suggestions\n+                                for name in lifetimes.keys() {\n+                                    if let hir::ParamName::Plain(name) = name {\n+                                        lifetime_names.insert(*name);\n+                                    }\n+                                }\n+                            }\n+                            break Some(e);\n+                        }\n                     };\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n@@ -2344,7 +2361,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n         if add_label {\n-            add_missing_lifetime_specifiers_label(&mut err, span, lifetime_refs.len());\n+            add_missing_lifetime_specifiers_label(\n+                &mut err,\n+                span,\n+                lifetime_refs.len(),\n+                &lifetime_names,\n+                self.tcx.sess.source_map().span_to_snippet(span).ok().as_ref().map(|s| s.as_str()),\n+            );\n         }\n \n         err.emit();\n@@ -2885,10 +2908,23 @@ fn add_missing_lifetime_specifiers_label(\n     err: &mut DiagnosticBuilder<'_>,\n     span: Span,\n     count: usize,\n+    lifetime_names: &FxHashSet<ast::Ident>,\n+    snippet: Option<&str>,\n ) {\n     if count > 1 {\n         err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n+    } else if let (1, Some(name), Some(\"&\")) = (\n+        lifetime_names.len(),\n+        lifetime_names.iter().next(),\n+        snippet,\n+    ) {\n+        err.span_suggestion(\n+            span,\n+            \"consider using the named lifetime\",\n+            format!(\"&{} \", name),\n+            Applicability::MaybeIncorrect,\n+        );\n     } else {\n         err.span_label(span, \"expected lifetime parameter\");\n-    };\n+    }\n }"}, {"sha": "0a2a375e1b2c154e37fedad45e0c4853581b7baf", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -593,7 +593,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n                 if !skip {\n-                    let path = self.item_path_str(def_id);\n+                    let path = self.def_path_str(def_id);\n                     let message = format!(\"use of deprecated item '{}'\", path);\n                     lint_deprecated(def_id,\n                                     id,\n@@ -620,7 +620,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = id {\n             if let Some(stability) = stability {\n                 if let Some(depr) = &stability.rustc_depr {\n-                    let path = self.item_path_str(def_id);\n+                    let path = self.def_path_str(def_id);\n                     if deprecation_in_effect(&depr.since.as_str()) {\n                         let message = format!(\"use of deprecated item '{}'\", path);\n                         lint_deprecated(def_id,"}, {"sha": "80fef910cc71811e98ea867c67b7dec3ef251d76", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -101,8 +101,7 @@ impl AllocationExtra<(), ()> for () {\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes(slice: &[u8], align: Align, extra: Extra) -> Self {\n-        let mut undef_mask = UndefMask::new(Size::ZERO);\n-        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n+        let undef_mask = UndefMask::new(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n             relocations: Relocations::new(),\n@@ -122,7 +121,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n-            undef_mask: UndefMask::new(size),\n+            undef_mask: UndefMask::new(size, false),\n             align,\n             mutability: Mutability::Mutable,\n             extra,\n@@ -614,8 +613,9 @@ impl<Tag> DerefMut for Relocations<Tag> {\n ////////////////////////////////////////////////////////////////////////////////\n \n type Block = u64;\n-const BLOCK_SIZE: u64 = 64;\n \n+/// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n+/// is defined. If it is `false` the byte is undefined.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UndefMask {\n     blocks: Vec<Block>,\n@@ -625,12 +625,14 @@ pub struct UndefMask {\n impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n \n impl UndefMask {\n-    pub fn new(size: Size) -> Self {\n+    pub const BLOCK_SIZE: u64 = 64;\n+\n+    pub fn new(size: Size, state: bool) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n             len: Size::ZERO,\n         };\n-        m.grow(size, false);\n+        m.grow(size, state);\n         m\n     }\n \n@@ -644,6 +646,7 @@ impl UndefMask {\n             return Err(self.len);\n         }\n \n+        // FIXME(oli-obk): optimize this for allocations larger than a block.\n         let idx = (start.bytes()..end.bytes())\n             .map(|i| Size::from_bytes(i))\n             .find(|&i| !self.get(i));\n@@ -663,20 +666,63 @@ impl UndefMask {\n     }\n \n     pub fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n-        for i in start.bytes()..end.bytes() {\n-            self.set(Size::from_bytes(i), new_state);\n+        let (blocka, bita) = bit_index(start);\n+        let (blockb, bitb) = bit_index(end);\n+        if blocka == blockb {\n+            // first set all bits but the first `bita`\n+            // then unset the last `64 - bitb` bits\n+            let range = if bitb == 0 {\n+                u64::max_value() << bita\n+            } else {\n+                (u64::max_value() << bita) & (u64::max_value() >> (64 - bitb))\n+            };\n+            if new_state {\n+                self.blocks[blocka] |= range;\n+            } else {\n+                self.blocks[blocka] &= !range;\n+            }\n+            return;\n+        }\n+        // across block boundaries\n+        if new_state {\n+            // set bita..64 to 1\n+            self.blocks[blocka] |= u64::max_value() << bita;\n+            // set 0..bitb to 1\n+            if bitb != 0 {\n+                self.blocks[blockb] |= u64::max_value() >> (64 - bitb);\n+            }\n+            // fill in all the other blocks (much faster than one bit at a time)\n+            for block in (blocka + 1) .. blockb {\n+                self.blocks[block] = u64::max_value();\n+            }\n+        } else {\n+            // set bita..64 to 0\n+            self.blocks[blocka] &= !(u64::max_value() << bita);\n+            // set 0..bitb to 0\n+            if bitb != 0 {\n+                self.blocks[blockb] &= !(u64::max_value() >> (64 - bitb));\n+            }\n+            // fill in all the other blocks (much faster than one bit at a time)\n+            for block in (blocka + 1) .. blockb {\n+                self.blocks[block] = 0;\n+            }\n         }\n     }\n \n     #[inline]\n     pub fn get(&self, i: Size) -> bool {\n         let (block, bit) = bit_index(i);\n-        (self.blocks[block] & 1 << bit) != 0\n+        (self.blocks[block] & (1 << bit)) != 0\n     }\n \n     #[inline]\n     pub fn set(&mut self, i: Size, new_state: bool) {\n         let (block, bit) = bit_index(i);\n+        self.set_bit(block, bit, new_state);\n+    }\n+\n+    #[inline]\n+    fn set_bit(&mut self, block: usize, bit: usize, new_state: bool) {\n         if new_state {\n             self.blocks[block] |= 1 << bit;\n         } else {\n@@ -685,11 +731,15 @@ impl UndefMask {\n     }\n \n     pub fn grow(&mut self, amount: Size, new_state: bool) {\n-        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len.bytes();\n+        if amount.bytes() == 0 {\n+            return;\n+        }\n+        let unused_trailing_bits = self.blocks.len() as u64 * Self::BLOCK_SIZE - self.len.bytes();\n         if amount.bytes() > unused_trailing_bits {\n-            let additional_blocks = amount.bytes() / BLOCK_SIZE + 1;\n+            let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n+                // FIXME(oli-obk): optimize this by repeating `new_state as Block`\n                 iter::repeat(0).take(additional_blocks as usize),\n             );\n         }\n@@ -702,8 +752,8 @@ impl UndefMask {\n #[inline]\n fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n-    let a = bits / BLOCK_SIZE;\n-    let b = bits % BLOCK_SIZE;\n+    let a = bits / UndefMask::BLOCK_SIZE;\n+    let b = bits % UndefMask::BLOCK_SIZE;\n     assert_eq!(a as usize as u64, a);\n     assert_eq!(b as usize as u64, b);\n     (a as usize, b as usize)"}, {"sha": "718b506d051135e188b6cc68e2febf9a307dde62", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n \n-use crate::hir::def::CtorKind;\n+use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, HirId, InlineAsm};\n use crate::mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n@@ -34,7 +34,7 @@ use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n-use crate::util::ppaux;\n+use crate::ty::print::{FmtPrinter, Printer};\n \n pub use crate::mir::interpret::AssertMessage;\n \n@@ -2062,7 +2062,7 @@ impl<'tcx> Debug for Place<'tcx> {\n             Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n                 fmt,\n                 \"({}: {:?})\",\n-                ty::tls::with(|tcx| tcx.item_path_str(def_id)),\n+                ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n                 ty\n             ),\n             Base(PlaceBase::Promoted(ref promoted)) => write!(\n@@ -2369,7 +2369,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 };\n \n                 // When printing regions, add trailing space if necessary.\n-                let region = if ppaux::verbose() || ppaux::identify_regions() {\n+                let print_region = ty::tls::with(|tcx| {\n+                    tcx.sess.verbose() || tcx.sess.opts.debugging_opts.identify_regions\n+                });\n+                let region = if print_region {\n                     let mut region = region.to_string();\n                     if region.len() > 0 {\n                         region.push(' ');\n@@ -2403,7 +2406,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Adt(adt_def, variant, substs, _user_ty, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n-                        ppaux::parameterized(fmt, substs, variant_def.did, &[])?;\n+                        let f = &mut *fmt;\n+                        ty::tls::with(|tcx| {\n+                            let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n+                            FmtPrinter::new(tcx, f, Namespace::ValueNS)\n+                                .print_def_path(variant_def.did, substs)?;\n+                            Ok(())\n+                        })?;\n \n                         match variant_def.ctor_kind {\n                             CtorKind::Const => Ok(()),\n@@ -2729,7 +2738,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Resul\n     }\n     // print function definitions\n     if let FnDef(did, _) = ty.sty {\n-        return write!(f, \"{}\", item_path_str(did));\n+        return write!(f, \"{}\", def_path_str(did));\n     }\n     // print string literals\n     if let ConstValue::Slice(ptr, len) = value {\n@@ -2754,8 +2763,8 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Resul\n     write!(f, \"{:?}:{}\", value, ty)\n }\n \n-fn item_path_str(def_id: DefId) -> String {\n-    ty::tls::with(|tcx| tcx.item_path_str(def_id))\n+fn def_path_str(def_id: DefId) -> String {\n+    ty::tls::with(|tcx| tcx.def_path_str(def_id))\n }\n \n impl<'tcx> graph::DirectedGraph for Mir<'tcx> {"}, {"sha": "ff18678f091b90f108e23c504364f49cff33b23e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -800,6 +800,7 @@ macro_rules! options {\n         pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n         pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n         pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_comma_list: Option<&str> = Some(\"a comma-separated list of strings\");\n         pub const parse_uint: Option<&str> = Some(\"a number\");\n         pub const parse_passes: Option<&str> =\n             Some(\"a space-separated list of passes, or `all`\");\n@@ -926,6 +927,18 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.split(',').map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n         fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n             match v.and_then(|s| s.parse().ok()) {\n                 Some(i) => { *slot = i; true },\n@@ -1427,6 +1440,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking\n          the same values as the target option of the same name\"),\n+    allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n+        \"only allow the listed language features to be enabled in code (space separated)\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -3273,6 +3288,10 @@ mod tests {\n         opts = reference.clone();\n         opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]"}, {"sha": "6c8fe0875b60c232a0cac7db751294a696901cfb", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -854,10 +854,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => vec![ArgKind::empty()],\n                 };\n \n-                let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.sty {\n                     ty::Tuple(ref tys) => tys.iter()\n                         .map(|t| ArgKind::from_expected_ty(t, Some(span))).collect(),\n-                    ref sty => vec![ArgKind::Arg(\"_\".to_owned(), sty.to_string())],\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n                 };\n \n                 if found.len() == expected.len() {\n@@ -1284,11 +1285,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n-                                       self.item_path_str(type_def_id));\n+                                       self.def_path_str(type_def_id));\n         err.span_label(span, \"recursive type has infinite size\");\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n-                          self.item_path_str(type_def_id)));\n+                          self.def_path_str(type_def_id)));\n         err\n     }\n \n@@ -1298,7 +1299,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                       violations: Vec<ObjectSafetyViolation>)\n                                       -> DiagnosticBuilder<'tcx>\n     {\n-        let trait_str = self.item_path_str(trait_def_id);\n+        let trait_str = self.def_path_str(trait_def_id);\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(\n             self.sess, span, E0038,\n@@ -1523,7 +1524,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   region, object_ty));\n             }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n-                let item_name = tcx.item_path_str(item_def_id);\n+                let item_name = tcx.def_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n@@ -1686,10 +1687,10 @@ impl ArgKind {\n             ty::Tuple(ref tys) => ArgKind::Tuple(\n                 span,\n                 tys.iter()\n-                   .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))\n+                   .map(|ty| (\"_\".to_owned(), ty.to_string()))\n                    .collect::<Vec<_>>()\n             ),\n-            _ => ArgKind::Arg(\"_\".to_owned(), t.sty.to_string()),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n         }\n     }\n }"}, {"sha": "78c80b48ee80d9756f6b15ada676db838c25e650", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -650,7 +650,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n ) -> bool {\n     debug!(\"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n            ty,\n-           infcx.tcx.item_path_str(def_id));\n+           infcx.tcx.def_path_str(def_id));\n \n     let trait_ref = ty::TraitRef {\n         def_id,\n@@ -665,7 +665,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n     debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-           ty, infcx.tcx.item_path_str(def_id), result);\n+           ty, infcx.tcx.def_path_str(def_id), result);\n \n     if result && (ty.has_infer_types() || ty.has_closure_types()) {\n         // Because of inference \"guessing\", selection can sometimes claim\n@@ -692,13 +692,13 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n             Ok(()) => {\n                 debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n                        ty,\n-                       infcx.tcx.item_path_str(def_id));\n+                       infcx.tcx.def_path_str(def_id));\n                 true\n             }\n             Err(e) => {\n                 debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n                        ty,\n-                       infcx.tcx.item_path_str(def_id),\n+                       infcx.tcx.def_path_str(def_id),\n                        e);\n                 false\n             }"}, {"sha": "1c8ea5c7b9c5b0dd437301f536a24c15e19472f9", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                         hir::CRATE_HIR_ID,\n                         *span,\n                         &format!(\"the trait `{}` cannot be made into an object\",\n-                                 self.item_path_str(trait_def_id)),\n+                                 self.def_path_str(trait_def_id)),\n                         &violation.error_msg());\n                     false\n                 } else {"}, {"sha": "fc0058a1df5ffebc19bd4be54718ed7e5ef40d51", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                   -> String\n     {\n         let name = tcx.item_name(trait_ref.def_id);\n-        let trait_str = tcx.item_path_str(trait_ref.def_id);\n+        let trait_str = tcx.def_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.params.iter().filter_map(|param| {\n             let value = match param.kind {"}, {"sha": "ab6acc662131b4663c57c06978cb2eeafa531ae2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1549,7 +1549,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n         // should have failed in astconv.\n         bug!(\"No associated type `{}` for {}\",\n              assoc_ty_name,\n-             tcx.item_path_str(impl_def_id))\n+             tcx.def_path_str(impl_def_id))\n     }\n }\n "}, {"sha": "c576586fcad8ea21aa178266d64810988a11a281", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -411,7 +411,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_, '_, '_>, impl_def_id: DefId) -> Option<\n         w.push('<');\n         w.push_str(&substs.iter()\n             .map(|k| k.to_string())\n-            .filter(|k| &k[..] != \"'_\")\n+            .filter(|k| k != \"'_\")\n             .collect::<Vec<_>>().join(\", \"));\n         w.push('>');\n     }"}, {"sha": "f3a800bf46d87e8f8cfafeec0218032aed18dfc9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -165,7 +165,8 @@ impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use crate::traits::WhereClause::*;\n \n-        // Bypass ppaux because it does not print out anonymous regions.\n+        // Bypass `ty::print` because it does not print out anonymous regions.\n+        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n         fn write_region_name<'tcx>(\n             r: ty::Region<'tcx>,\n             fmt: &mut fmt::Formatter<'_>\n@@ -256,7 +257,7 @@ impl fmt::Display for traits::QuantifierKind {\n }\n \n /// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in ppaux, it's just used\n+/// This collector does not try to do anything clever like in `ty::print`, it's just used\n /// for debug output in tests anyway.\n struct BoundNamesCollector {\n     // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway."}, {"sha": "1942f98abff17ab58e6dcb2b79ad140421138f22", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -26,7 +26,7 @@ use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n-use crate::ty::{self, Ty, TypeAndMut};\n+use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{TyS, TyKind, List};\n use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n@@ -1594,7 +1594,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ref ebr) => (\n-                self.parent_def_id(ebr.def_id).unwrap(),\n+                self.parent(ebr.def_id).unwrap(),\n                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region\n@@ -2886,30 +2886,44 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.emit()\n     }\n \n-    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: hir::HirId)\n-        -> (lint::Level, lint::LintSource)\n-    {\n-        // Right now we insert a `with_ignore` node in the dep graph here to\n-        // ignore the fact that `lint_levels` below depends on the entire crate.\n-        // For now this'll prevent false positives of recompiling too much when\n-        // anything changes.\n-        //\n-        // Once red/green incremental compilation lands we should be able to\n-        // remove this because while the crate changes often the lint level map\n-        // will change rarely.\n-        self.dep_graph.with_ignore(|| {\n-            let sets = self.lint_levels(LOCAL_CRATE);\n-            loop {\n-                if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n-                    return pair\n-                }\n-                let next = self.hir().get_parent_node_by_hir_id(id);\n-                if next == id {\n-                    bug!(\"lint traversal reached the root of the crate\");\n-                }\n-                id = next;\n+    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n+    /// It stops at `bound` and just returns it if reached.\n+    pub fn maybe_lint_level_root_bounded(\n+        self,\n+        mut id: hir::HirId,\n+        bound: hir::HirId,\n+    ) -> hir::HirId {\n+        loop {\n+            if id == bound {\n+                return bound;\n             }\n-        })\n+            if lint::maybe_lint_level_root(self, id) {\n+                return id;\n+            }\n+            let next = self.hir().get_parent_node_by_hir_id(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n+    }\n+\n+    pub fn lint_level_at_node(\n+        self,\n+        lint: &'static Lint,\n+        mut id: hir::HirId\n+    ) -> (lint::Level, lint::LintSource) {\n+        let sets = self.lint_levels(LOCAL_CRATE);\n+        loop {\n+            if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n+                return pair\n+            }\n+            let next = self.hir().get_parent_node_by_hir_id(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n     }\n \n     pub fn struct_span_lint_hir<S: Into<MultiSpan>>(self,"}, {"sha": "fa3c76a817a4fbc22a0c814df380d6bf170d0f4e", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -71,6 +71,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         }\n \n+        let br_string = |br: ty::BoundRegion| {\n+            match br {\n+                ty::BrNamed(_, name) => format!(\" {}\", name),\n+                _ => String::new(),\n+            }\n+        };\n+\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -105,15 +112,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n             RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n-                       \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n-                       if br.is_named() { \" \" } else { \"\" },\n-                       br)\n+                       \"expected bound lifetime parameter{}, found concrete lifetime\",\n+                       br_string(br))\n             }\n             RegionsOverlyPolymorphic(br, _) => {\n                 write!(f,\n-                       \"expected concrete lifetime, found bound lifetime parameter{}{}\",\n-                       if br.is_named() { \" \" } else { \"\" },\n-                       br)\n+                       \"expected concrete lifetime, found bound lifetime parameter{}\",\n+                       br_string(br))\n             }\n             RegionsPlaceholderMismatch => {\n                 write!(f, \"one type is more general than the other\")\n@@ -125,9 +130,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             Traits(values) => ty::tls::with(|tcx| {\n                 report_maybe_different(f,\n                                        &format!(\"trait `{}`\",\n-                                                tcx.item_path_str(values.expected)),\n+                                                tcx.def_path_str(values.expected)),\n                                        &format!(\"trait `{}`\",\n-                                                tcx.item_path_str(values.found)))\n+                                                tcx.def_path_str(values.found)))\n             }),\n             IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n@@ -146,8 +151,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n             ProjectionMismatched(ref values) => ty::tls::with(|tcx| {\n                 write!(f, \"expected {}, found {}\",\n-                       tcx.item_path_str(values.expected),\n-                       tcx.item_path_str(values.found))\n+                       tcx.def_path_str(values.expected),\n+                       tcx.def_path_str(values.found))\n             }),\n             ProjectionBoundsLength(ref values) => {\n                 write!(f, \"expected {} associated type bindings, found {}\",\n@@ -169,8 +174,8 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n             ty::Tuple(ref tys) if tys.is_empty() => self.to_string().into(),\n \n-            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)).into(),\n-            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)).into(),\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n+            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(_, n) => match n {\n                 ty::LazyConst::Evaluated(n) => match n.assert_usize(tcx) {\n                     Some(n) => format!(\"array of {} elements\", n).into(),\n@@ -185,7 +190,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                 let tymut_string = tymut.to_string();\n                 if tymut_string == \"_\" ||         //unknown type name,\n                    tymut_string.len() > 10 ||     //name longer than saying \"reference\",\n-                   region.to_string() != \"\"       //... or a complex type\n+                   region.to_string() != \"'_\"     //... or a complex type\n                 {\n                     format!(\"{}reference\", match mutbl {\n                         hir::Mutability::MutMutable => \"mutable \",\n@@ -199,7 +204,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n                 if let Some(principal) = inner.principal() {\n-                    format!(\"trait {}\", tcx.item_path_str(principal.def_id())).into()\n+                    format!(\"trait {}\", tcx.def_path_str(principal.def_id())).into()\n                 } else {\n                     \"trait\".into()\n                 }"}, {"sha": "995e85fc5f4db557cf54dd8d0729986985a12bc5", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,10 +1,11 @@\n use crate::hir::Unsafety;\n+use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n+use crate::ty::print::{FmtPrinter, Printer};\n use crate::traits;\n use rustc_target::spec::abi::Abi;\n use rustc_macros::HashStable;\n-use crate::util::ppaux;\n \n use std::fmt;\n use std::iter;\n@@ -175,7 +176,13 @@ impl<'tcx> InstanceDef<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ppaux::parameterized(f, self.substs, self.def_id(), &[])?;\n+        ty::tls::with(|tcx| {\n+            let substs = tcx.lift(&self.substs).expect(\"could not lift for printing\");\n+            FmtPrinter::new(tcx, &mut *f, Namespace::ValueNS)\n+                .print_def_path(self.def_id(), substs)?;\n+            Ok(())\n+        })?;\n+\n         match self.def {\n             InstanceDef::Item(_) => Ok(()),\n             InstanceDef::VtableShim(_) => {"}, {"sha": "26e2705a7a0346feeb955f066e8b5a6405541afd", "filename": "src/librustc/ty/item_path.rs", "status": "removed", "additions": 0, "deletions": 573, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,573 +0,0 @@\n-use crate::hir::map::DefPathData;\n-use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n-use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use syntax::ast;\n-use syntax::symbol::{keywords, LocalInternedString, Symbol};\n-\n-use std::cell::Cell;\n-use std::fmt::Debug;\n-\n-thread_local! {\n-    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n-    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n-    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n-}\n-\n-/// Enforces that item_path_str always returns an absolute path and\n-/// also enables \"type-based\" impl paths. This is used when building\n-/// symbols that contain types, where we want the crate name to be\n-/// part of the symbol.\n-pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_ABSOLUTE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Force us to name impls with just the filename/line number. We\n-/// normally try to use types. But at some points, notably while printing\n-/// cycle errors, this can result in extra or suboptimal error output,\n-/// so this variable disables that check.\n-pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n-    FORCE_IMPL_FILENAME_LINE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n-        let result = f();\n-        force.set(old);\n-        result\n-    })\n-}\n-\n-/// Adds the `crate::` prefix to paths where appropriate.\n-pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n-    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-        let old = flag.get();\n-        flag.set(true);\n-        let result = f();\n-        flag.set(old);\n-        result\n-    })\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns a string identifying this `DefId`. This string is\n-    /// suitable for user output. It is relative to the current crate\n-    /// root, unless with_forced_absolute_paths was used.\n-    pub fn item_path_str(self, def_id: DefId) -> String {\n-        let mode = FORCE_ABSOLUTE.with(|force| {\n-            if force.get() {\n-                RootMode::Absolute\n-            } else {\n-                RootMode::Local\n-            }\n-        });\n-        let mut buffer = LocalPathBuffer::new(mode);\n-        debug!(\"item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id, false);\n-        buffer.into_string()\n-    }\n-\n-    /// Returns a string identifying this local node-id.\n-    pub fn node_path_str(self, id: ast::NodeId) -> String {\n-        self.item_path_str(self.hir().local_def_id(id))\n-    }\n-\n-    /// Returns a string identifying this def-id. This string is\n-    /// suitable for user output. It always begins with a crate identifier.\n-    pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n-        let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n-        debug!(\"absolute_item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id, false);\n-        buffer.into_string()\n-    }\n-\n-    /// Returns the \"path\" to a particular crate. This can proceed in\n-    /// various ways, depending on the `root_mode` of the `buffer`.\n-    /// (See `RootMode` enum for more details.)\n-    ///\n-    /// `pushed_prelude_crate` argument should be `true` when the buffer\n-    /// has had a prelude crate pushed to it. If this is the case, then\n-    /// we do not want to prepend `crate::` (as that would not be a valid\n-    /// path).\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum, pushed_prelude_crate: bool)\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\n-            \"push_krate_path: buffer={:?} cnum={:?} LOCAL_CRATE={:?}\",\n-            buffer, cnum, LOCAL_CRATE\n-        );\n-        match *buffer.root_mode() {\n-            RootMode::Local => {\n-                // In local mode, when we encounter a crate other than\n-                // LOCAL_CRATE, execution proceeds in one of two ways:\n-                //\n-                // 1. for a direct dependency, where user added an\n-                //    `extern crate` manually, we put the `extern\n-                //    crate` as the parent. So you wind up with\n-                //    something relative to the current crate.\n-                // 2. for an extern inferred from a path or an indirect crate,\n-                //    where there is no explicit `extern crate`, we just prepend\n-                //    the crate name.\n-                //\n-                // Returns `None` for the local crate.\n-                if cnum != LOCAL_CRATE {\n-                    let opt_extern_crate = self.extern_crate(cnum.as_def_id());\n-                    if let Some(ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n-                        direct: true,\n-                        ..\n-                    }) = *opt_extern_crate\n-                    {\n-                        debug!(\"push_krate_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n-                    } else {\n-                        let name = self.crate_name(cnum).as_str();\n-                        debug!(\"push_krate_path: name={:?}\", name);\n-                        buffer.push(&name);\n-                    }\n-                } else if self.sess.rust_2018() && !pushed_prelude_crate {\n-                    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-                        // We only add the `crate::` keyword where appropriate. In particular,\n-                        // when we've not previously pushed a prelude crate to this path.\n-                        if flag.get() {\n-                            buffer.push(&keywords::Crate.name().as_str())\n-                        }\n-                    })\n-                }\n-            }\n-            RootMode::Absolute => {\n-                // In absolute mode, just write the crate name\n-                // unconditionally.\n-                let name = self.original_crate_name(cnum).as_str();\n-                debug!(\"push_krate_path: original_name={:?}\", name);\n-                buffer.push(&name);\n-            }\n-        }\n-    }\n-\n-    /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `external_def_id` is\n-    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(\n-        self,\n-        buffer: &mut T,\n-        external_def_id: DefId,\n-        pushed_prelude_crate: bool,\n-    ) -> bool\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\n-            \"try_push_visible_item_path: buffer={:?} external_def_id={:?}\",\n-            buffer, external_def_id\n-        );\n-        let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n-\n-        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<LocalInternedString>::new());\n-        loop {\n-            debug!(\n-                \"try_push_visible_item_path: cur_def={:?} cur_path={:?} CRATE_DEF_INDEX={:?}\",\n-                cur_def, cur_path, CRATE_DEF_INDEX,\n-            );\n-            // If `cur_def` is a direct or injected extern crate, push the path to the crate\n-            // followed by the path to the item within the crate and return.\n-            if cur_def.index == CRATE_DEF_INDEX {\n-                match *self.extern_crate(cur_def) {\n-                    Some(ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n-                        direct: true,\n-                        ..\n-                    }) => {\n-                        debug!(\"try_push_visible_item_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n-                        cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n-                        return true;\n-                    }\n-                    None => {\n-                        buffer.push(&self.crate_name(cur_def.krate).as_str());\n-                        cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n-                        return true;\n-                    }\n-                    _ => {},\n-                }\n-            }\n-\n-            let mut cur_def_key = self.def_key(cur_def);\n-            debug!(\"try_push_visible_item_path: cur_def_key={:?}\", cur_def_key);\n-\n-            // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-            if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-                let parent = DefId {\n-                    krate: cur_def.krate,\n-                    index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-                };\n-\n-                cur_def_key = self.def_key(parent);\n-            }\n-\n-            let visible_parent = visible_parent_map.get(&cur_def).cloned();\n-            let actual_parent = self.parent(cur_def);\n-\n-            let data = cur_def_key.disambiguated_data.data;\n-            debug!(\n-                \"try_push_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n-                data, visible_parent, actual_parent,\n-            );\n-            let symbol = match data {\n-                // In order to output a path that could actually be imported (valid and visible),\n-                // we need to handle re-exports correctly.\n-                //\n-                // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n-                // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n-                //\n-                // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n-                // private so the \"true\" path to `CommandExt` isn't accessible.\n-                //\n-                // In this case, the `visible_parent_map` will look something like this:\n-                //\n-                // (child) -> (parent)\n-                // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n-                // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n-                // `std::sys::unix::ext` -> `std::os`\n-                //\n-                // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n-                // `std::os`.\n-                //\n-                // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n-                // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n-                // to the parent - resulting in a mangled path like\n-                // `std::os::ext::process::CommandExt`.\n-                //\n-                // Instead, we must detect that there was a re-export and instead print `unix`\n-                // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n-                // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n-                // the visible parent (`std::os`). If these do not match, then we iterate over\n-                // the children of the visible parent (as was done when computing\n-                // `visible_parent_map`), looking for the specific child we currently have and then\n-                // have access to the re-exported name.\n-                DefPathData::Module(actual_name) |\n-                DefPathData::TypeNs(actual_name) if visible_parent != actual_parent => {\n-                    visible_parent\n-                        .and_then(|parent| {\n-                            self.item_children(parent)\n-                                .iter()\n-                                .find(|child| child.def.def_id() == cur_def)\n-                                .map(|child| child.ident.as_str())\n-                        })\n-                        .unwrap_or_else(|| actual_name.as_str())\n-                },\n-                _ => {\n-                    data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                        // Re-exported `extern crate` (#43189).\n-                        if let DefPathData::CrateRoot = data {\n-                            self.original_crate_name(cur_def.krate).as_str()\n-                        } else {\n-                            Symbol::intern(\"<unnamed>\").as_str()\n-                        }\n-                    })\n-                },\n-            };\n-            debug!(\"try_push_visible_item_path: symbol={:?}\", symbol);\n-            cur_path.push(symbol);\n-\n-            match visible_parent {\n-                Some(def) => cur_def = def,\n-                None => return false,\n-            };\n-        }\n-    }\n-\n-    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId, pushed_prelude_crate: bool)\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\n-            \"push_item_path: buffer={:?} def_id={:?} pushed_prelude_crate={:?}\",\n-            buffer, def_id, pushed_prelude_crate\n-        );\n-        match *buffer.root_mode() {\n-            RootMode::Local if !def_id.is_local() =>\n-                if self.try_push_visible_item_path(buffer, def_id, pushed_prelude_crate) { return },\n-            _ => {}\n-        }\n-\n-        let key = self.def_key(def_id);\n-        debug!(\"push_item_path: key={:?}\", key);\n-        match key.disambiguated_data.data {\n-            DefPathData::CrateRoot => {\n-                assert!(key.parent.is_none());\n-                self.push_krate_path(buffer, def_id.krate, pushed_prelude_crate);\n-            }\n-\n-            DefPathData::Impl => {\n-                self.push_impl_path(buffer, def_id, pushed_prelude_crate);\n-            }\n-\n-            // Unclear if there is any value in distinguishing these.\n-            // Probably eventually (and maybe we would even want\n-            // finer-grained distinctions, e.g., between enum/struct).\n-            data @ DefPathData::Misc |\n-            data @ DefPathData::TypeNs(..) |\n-            data @ DefPathData::Trait(..) |\n-            data @ DefPathData::TraitAlias(..) |\n-            data @ DefPathData::AssocTypeInTrait(..) |\n-            data @ DefPathData::AssocTypeInImpl(..) |\n-            data @ DefPathData::AssocExistentialInImpl(..) |\n-            data @ DefPathData::ValueNs(..) |\n-            data @ DefPathData::Module(..) |\n-            data @ DefPathData::TypeParam(..) |\n-            data @ DefPathData::LifetimeParam(..) |\n-            data @ DefPathData::ConstParam(..) |\n-            data @ DefPathData::EnumVariant(..) |\n-            data @ DefPathData::Field(..) |\n-            data @ DefPathData::AnonConst |\n-            data @ DefPathData::MacroDef(..) |\n-            data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::ImplTrait |\n-            data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_did = self.parent_def_id(def_id).unwrap();\n-\n-                // Keep track of whether we are one recursion away from the `CrateRoot` and\n-                // pushing the name of a prelude crate. If we are, we'll want to know this when\n-                // printing the `CrateRoot` so we don't prepend a `crate::` to paths.\n-                let mut is_prelude_crate = false;\n-                if let DefPathData::CrateRoot = self.def_key(parent_did).disambiguated_data.data {\n-                    if self.extern_prelude.contains_key(&data.as_interned_str().as_symbol()) {\n-                        is_prelude_crate = true;\n-                    }\n-                }\n-\n-                self.push_item_path(\n-                    buffer, parent_did, pushed_prelude_crate || is_prelude_crate\n-                );\n-                buffer.push(&data.as_interned_str().as_symbol().as_str());\n-            },\n-\n-            DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n-                let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-            }\n-        }\n-    }\n-\n-    fn push_impl_path<T>(\n-        self,\n-         buffer: &mut T,\n-         impl_def_id: DefId,\n-         pushed_prelude_crate: bool,\n-    )\n-        where T: ItemPathBuffer + Debug\n-    {\n-        debug!(\"push_impl_path: buffer={:?} impl_def_id={:?}\", buffer, impl_def_id);\n-        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-\n-        // Always use types for non-local impls, where types are always\n-        // available, and filename/line-number is mostly uninteresting.\n-        let use_types = !impl_def_id.is_local() || {\n-            // Otherwise, use filename/line-number if forced.\n-            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-            !force_no_types\n-        };\n-\n-        if !use_types {\n-            return self.push_impl_path_fallback(buffer, impl_def_id, pushed_prelude_crate);\n-        }\n-\n-        // Decide whether to print the parent path for the impl.\n-        // Logically, since impls are global, it's never needed, but\n-        // users may find it useful. Currently, we omit the parent if\n-        // the impl is either in the same module as the self-type or\n-        // as the trait.\n-        let self_ty = self.type_of(impl_def_id);\n-        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n-            None => false,\n-            Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),\n-        };\n-\n-        let impl_trait_ref = self.impl_trait_ref(impl_def_id);\n-        let in_trait_mod = match impl_trait_ref {\n-            None => false,\n-            Some(trait_ref) => self.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n-        };\n-\n-        if !in_self_mod && !in_trait_mod {\n-            // If the impl is not co-located with either self-type or\n-            // trait-type, then fallback to a format that identifies\n-            // the module more clearly.\n-            self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-            if let Some(trait_ref) = impl_trait_ref {\n-                buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n-            } else {\n-                buffer.push(&format!(\"<impl {}>\", self_ty));\n-            }\n-            return;\n-        }\n-\n-        // Otherwise, try to give a good form that would be valid language\n-        // syntax. Preferably using associated item notation.\n-\n-        if let Some(trait_ref) = impl_trait_ref {\n-            // Trait impls.\n-            buffer.push(&format!(\"<{} as {}>\", self_ty, trait_ref));\n-            return;\n-        }\n-\n-        // Inherent impls. Try to print `Foo::bar` for an inherent\n-        // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n-        // anything other than a simple path.\n-        match self_ty.sty {\n-            ty::Adt(adt_def, substs) => {\n-                if substs.types().next().is_none() { // ignore regions\n-                    self.push_item_path(buffer, adt_def.did, pushed_prelude_crate);\n-                } else {\n-                    buffer.push(&format!(\"<{}>\", self_ty));\n-                }\n-            }\n-\n-            ty::Foreign(did) => self.push_item_path(buffer, did, pushed_prelude_crate),\n-\n-            ty::Bool |\n-            ty::Char |\n-            ty::Int(_) |\n-            ty::Uint(_) |\n-            ty::Float(_) |\n-            ty::Str => {\n-                buffer.push(&self_ty.to_string());\n-            }\n-\n-            _ => {\n-                buffer.push(&format!(\"<{}>\", self_ty));\n-            }\n-        }\n-    }\n-\n-    fn push_impl_path_fallback<T>(\n-        self,\n-        buffer: &mut T,\n-        impl_def_id: DefId,\n-        pushed_prelude_crate: bool,\n-    )\n-        where T: ItemPathBuffer + Debug\n-    {\n-        // If no type info is available, fall back to\n-        // pretty printing some span information. This should\n-        // only occur very early in the compiler pipeline.\n-        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-        let hir_id = self.hir().as_local_hir_id(impl_def_id).unwrap();\n-        let item = self.hir().expect_item_by_hir_id(hir_id);\n-        let span_str = self.sess.source_map().span_to_string(item.span);\n-        buffer.push(&format!(\"<impl at {}>\", span_str));\n-    }\n-\n-    /// Returns the `DefId` of `def_id`'s parent in the def tree. If\n-    /// this returns `None`, then `def_id` represents a crate root or\n-    /// inlined root.\n-    pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n-        let key = self.def_key(def_id);\n-        key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n-    }\n-}\n-\n-/// As a heuristic, when we see an impl, if we see that the\n-/// 'self type' is a type defined in the same module as the impl,\n-/// we can omit including the path to the impl itself. This\n-/// function tries to find a \"characteristic `DefId`\" for a\n-/// type. It's just a heuristic so it makes some questionable\n-/// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n-    match ty.sty {\n-        ty::Adt(adt_def, _) => Some(adt_def.did),\n-\n-        ty::Dynamic(data, ..) => data.principal_def_id(),\n-\n-        ty::Array(subty, _) |\n-        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n-\n-        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n-\n-        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n-\n-        ty::Tuple(ref tys) => tys.iter()\n-                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n-                                   .next(),\n-\n-        ty::FnDef(def_id, _) |\n-        ty::Closure(def_id, _) |\n-        ty::Generator(def_id, _, _) |\n-        ty::Foreign(def_id) => Some(def_id),\n-\n-        ty::Bool |\n-        ty::Char |\n-        ty::Int(_) |\n-        ty::Uint(_) |\n-        ty::Str |\n-        ty::FnPtr(_) |\n-        ty::Projection(_) |\n-        ty::Placeholder(..) |\n-        ty::UnnormalizedProjection(..) |\n-        ty::Param(_) |\n-        ty::Opaque(..) |\n-        ty::Infer(_) |\n-        ty::Bound(..) |\n-        ty::Error |\n-        ty::GeneratorWitness(..) |\n-        ty::Never |\n-        ty::Float(_) => None,\n-    }\n-}\n-\n-/// Unifying Trait for different kinds of item paths we might\n-/// construct. The basic interface is that components get pushed: the\n-/// instance can also customize how we handle the root of a crate.\n-pub trait ItemPathBuffer {\n-    fn root_mode(&self) -> &RootMode;\n-    fn push(&mut self, text: &str);\n-}\n-\n-#[derive(Debug)]\n-pub enum RootMode {\n-    /// Try to make a path relative to the local crate. In\n-    /// particular, local paths have no prefix, and if the path comes\n-    /// from an extern crate, start with the path to the `extern\n-    /// crate` declaration.\n-    Local,\n-\n-    /// Always prepend the crate name to the path, forming an absolute\n-    /// path from within a given set of crates.\n-    Absolute,\n-}\n-\n-#[derive(Debug)]\n-struct LocalPathBuffer {\n-    root_mode: RootMode,\n-    str: String,\n-}\n-\n-impl LocalPathBuffer {\n-    fn new(root_mode: RootMode) -> LocalPathBuffer {\n-        LocalPathBuffer {\n-            root_mode,\n-            str: String::new(),\n-        }\n-    }\n-\n-    fn into_string(self) -> String {\n-        self.str\n-    }\n-}\n-\n-impl ItemPathBuffer for LocalPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        &self.root_mode\n-    }\n-\n-    fn push(&mut self, text: &str) {\n-        if !self.str.is_empty() {\n-            self.str.push_str(\"::\");\n-        }\n-        self.str.push_str(text);\n-    }\n-}"}, {"sha": "882e2dc62b1c376b55a25c94002102d624da35e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -95,10 +95,10 @@ mod erase_regions;\n pub mod fast_reject;\n pub mod fold;\n pub mod inhabitedness;\n-pub mod item_path;\n pub mod layout;\n pub mod _match;\n pub mod outlives;\n+pub mod print;\n pub mod query;\n pub mod relate;\n pub mod steal;\n@@ -1000,7 +1000,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Default, HashStable)]\n+#[derive(Clone, Default, Debug, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<(Predicate<'tcx>, Span)>,\n@@ -1505,7 +1505,7 @@ impl<'tcx> Predicate<'tcx> {\n /// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n@@ -2055,7 +2055,7 @@ impl ReprOptions {\n         }\n \n         // This is here instead of layout because the choice must make it into metadata.\n-        if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n+        if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.def_path_str(did))) {\n             flags.insert(ReprFlags::IS_LINEAR);\n         }\n         ReprOptions { int: size, align: max_align, pack: min_pack, flags: flags }\n@@ -2892,14 +2892,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n             Def::Variant(did) | Def::VariantCtor(did, ..) => {\n-                let enum_did = self.parent_def_id(did).unwrap();\n+                let enum_did = self.parent(did).unwrap();\n                 self.adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n                 self.adt_def(did).non_enum_variant()\n             }\n             Def::StructCtor(ctor_did, ..) => {\n-                let did = self.parent_def_id(ctor_did).expect(\"struct ctor has no parent\");\n+                let did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n                 self.adt_def(did).non_enum_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)"}, {"sha": "ef30a4032d8fabbe5d57007909c4d32028263c49", "filename": "src/librustc/ty/print/mod.rs", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,327 @@\n+use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use crate::hir::def_id::{CrateNum, DefId};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n+use crate::ty::subst::{Kind, Subst};\n+\n+use rustc_data_structures::fx::FxHashSet;\n+\n+// `pretty` is a separate module only for organization.\n+mod pretty;\n+pub use self::pretty::*;\n+\n+pub trait Print<'gcx, 'tcx, P> {\n+    type Output;\n+    type Error;\n+\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error>;\n+}\n+\n+/// Interface for outputting user-facing \"type-system entities\"\n+/// (paths, types, lifetimes, constants, etc.) as a side-effect\n+/// (e.g. formatting, like `PrettyPrinter` implementors do) or by\n+/// constructing some alternative representation (e.g. an AST),\n+/// which the associated types allow passing through the methods.\n+///\n+/// For pretty-printing/formatting in particular, see `PrettyPrinter`.\n+// FIXME(eddyb) find a better name, this is more general than \"printing\".\n+pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n+    type Error;\n+\n+    type Path;\n+    type Region;\n+    type Type;\n+    type DynExistential;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+\n+    fn print_def_path(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.default_print_def_path(def_id, substs)\n+    }\n+    fn print_impl_path(\n+        self,\n+        impl_def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.default_print_impl_path(impl_def_id, substs, self_ty, trait_ref)\n+    }\n+\n+    fn print_region(\n+        self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error>;\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error>;\n+\n+    fn print_dyn_existential(\n+        self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error>;\n+\n+    fn path_crate(\n+        self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error>;\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error>;\n+    fn path_generic_args(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error>;\n+\n+    // Defaults (should not be overriden):\n+\n+    fn default_print_def_path(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n+        let key = self.tcx().def_key(def_id);\n+        debug!(\"default_print_def_path: key={:?}\", key);\n+\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                self.path_crate(def_id.krate)\n+            }\n+\n+            DefPathData::Impl => {\n+                let generics = self.tcx().generics_of(def_id);\n+                let mut self_ty = self.tcx().type_of(def_id);\n+                let mut impl_trait_ref = self.tcx().impl_trait_ref(def_id);\n+                if substs.len() >= generics.count() {\n+                    self_ty = self_ty.subst(self.tcx(), substs);\n+                    impl_trait_ref = impl_trait_ref.subst(self.tcx(), substs);\n+                }\n+                self.print_impl_path(def_id, substs, self_ty, impl_trait_ref)\n+            }\n+\n+            _ => {\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+\n+                let mut parent_substs = substs;\n+                let mut trait_qualify_parent = false;\n+                if !substs.is_empty() {\n+                    let generics = self.tcx().generics_of(def_id);\n+                    parent_substs = &substs[..generics.parent_count.min(substs.len())];\n+\n+                    match key.disambiguated_data.data {\n+                        // Closures' own generics are only captures, don't print them.\n+                        DefPathData::ClosureExpr => {}\n+\n+                        // If we have any generic arguments to print, we do that\n+                        // on top of the same path, but without its own generics.\n+                        _ => if !generics.params.is_empty() && substs.len() >= generics.count() {\n+                            let args = self.generic_args_to_print(generics, substs);\n+                            return self.path_generic_args(\n+                                |cx| cx.print_def_path(def_id, parent_substs),\n+                                args,\n+                            );\n+                        }\n+                    }\n+\n+                    // FIXME(eddyb) try to move this into the parent's printing\n+                    // logic, instead of doing it when printing the child.\n+                    trait_qualify_parent =\n+                        generics.has_self &&\n+                        generics.parent == Some(parent_def_id) &&\n+                        parent_substs.len() == generics.parent_count &&\n+                        self.tcx().generics_of(parent_def_id).parent_count == 0;\n+                }\n+\n+                self.path_append(\n+                    |cx: Self| if trait_qualify_parent {\n+                        let trait_ref = ty::TraitRef::new(\n+                            parent_def_id,\n+                            cx.tcx().intern_substs(parent_substs),\n+                        );\n+                        cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n+                    } else {\n+                        cx.print_def_path(parent_def_id, parent_substs)\n+                    },\n+                    &key.disambiguated_data,\n+                )\n+            }\n+        }\n+    }\n+\n+    fn generic_args_to_print(\n+        &self,\n+        generics: &'tcx ty::Generics,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> &'tcx [Kind<'tcx>] {\n+        let mut own_params = generics.parent_count..generics.count();\n+\n+        // Don't print args for `Self` parameters (of traits).\n+        if generics.has_self && own_params.start == 0 {\n+            own_params.start = 1;\n+        }\n+\n+        // Don't print args that are the defaults of their respective parameters.\n+        own_params.end -= generics.params.iter().rev().take_while(|param| {\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => false,\n+                ty::GenericParamDefKind::Type { has_default, .. } => {\n+                    has_default && substs[param.index as usize] == Kind::from(\n+                        self.tcx().type_of(param.def_id).subst(self.tcx(), substs)\n+                    )\n+                }\n+                ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n+            }\n+        }).count();\n+\n+        &substs[own_params]\n+    }\n+\n+    fn default_print_impl_path(\n+        self,\n+        impl_def_id: DefId,\n+        _substs: &'tcx [Kind<'tcx>],\n+        self_ty: Ty<'tcx>,\n+        impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        debug!(\"default_print_impl_path: impl_def_id={:?}, self_ty={}, impl_trait_ref={:?}\",\n+               impl_def_id, self_ty, impl_trait_ref);\n+\n+        let key = self.tcx().def_key(impl_def_id);\n+        let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n+\n+        // Decide whether to print the parent path for the impl.\n+        // Logically, since impls are global, it's never needed, but\n+        // users may find it useful. Currently, we omit the parent if\n+        // the impl is either in the same module as the self-type or\n+        // as the trait.\n+        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n+            None => false,\n+            Some(ty_def_id) => self.tcx().parent(ty_def_id) == Some(parent_def_id),\n+        };\n+        let in_trait_mod = match impl_trait_ref {\n+            None => false,\n+            Some(trait_ref) => self.tcx().parent(trait_ref.def_id) == Some(parent_def_id),\n+        };\n+\n+        if !in_self_mod && !in_trait_mod {\n+            // If the impl is not co-located with either self-type or\n+            // trait-type, then fallback to a format that identifies\n+            // the module more clearly.\n+            self.path_append_impl(\n+                |cx| cx.print_def_path(parent_def_id, &[]),\n+                &key.disambiguated_data,\n+                self_ty,\n+                impl_trait_ref,\n+            )\n+        } else {\n+            // Otherwise, try to give a good form that would be valid language\n+            // syntax. Preferably using associated item notation.\n+            self.path_qualified(self_ty, impl_trait_ref)\n+        }\n+    }\n+}\n+\n+/// As a heuristic, when we see an impl, if we see that the\n+/// 'self type' is a type defined in the same module as the impl,\n+/// we can omit including the path to the impl itself. This\n+/// function tries to find a \"characteristic `DefId`\" for a\n+/// type. It's just a heuristic so it makes some questionable\n+/// decisions and we may want to adjust it later.\n+pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+    match ty.sty {\n+        ty::Adt(adt_def, _) => Some(adt_def.did),\n+\n+        ty::Dynamic(data, ..) => data.principal_def_id(),\n+\n+        ty::Array(subty, _) |\n+        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n+\n+        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n+\n+        ty::Tuple(ref tys) => tys.iter()\n+                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n+                                   .next(),\n+\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) |\n+        ty::Generator(def_id, _, _) |\n+        ty::Foreign(def_id) => Some(def_id),\n+\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(_) |\n+        ty::Uint(_) |\n+        ty::Str |\n+        ty::FnPtr(_) |\n+        ty::Projection(_) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) |\n+        ty::Param(_) |\n+        ty::Opaque(..) |\n+        ty::Infer(_) |\n+        ty::Bound(..) |\n+        ty::Error |\n+        ty::GeneratorWitness(..) |\n+        ty::Never |\n+        ty::Float(_) => None,\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::RegionKind {\n+    type Output = P::Region;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_region(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for ty::Region<'_> {\n+    type Output = P::Region;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_region(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for Ty<'tcx> {\n+    type Output = P::Type;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_type(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, P: Printer<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n+{\n+    type Output = P::DynExistential;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.print_dyn_existential(self)\n+    }\n+}"}, {"sha": "fa57e0b96745ae1f751a06c4c657cb9e939a6b49", "filename": "src/librustc/ty/print/pretty.rs", "status": "added", "additions": 1621, "deletions": 0, "changes": 1621, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,1621 @@\n+use crate::hir;\n+use crate::hir::def::Namespace;\n+use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n+use crate::middle::region;\n+use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::subst::{Kind, Subst, UnpackedKind};\n+use crate::mir::interpret::ConstValue;\n+use syntax::symbol::{keywords, Symbol};\n+\n+use rustc_target::spec::abi::Abi;\n+use syntax::symbol::InternedString;\n+\n+use std::cell::Cell;\n+use std::fmt::{self, Write as _};\n+use std::ops::{Deref, DerefMut};\n+\n+// `pretty` is a separate module only for organization.\n+use super::*;\n+\n+macro_rules! p {\n+    (@write($($data:expr),+)) => {\n+        write!(scoped_cx!(), $($data),+)?\n+    };\n+    (@print($x:expr)) => {\n+        scoped_cx!() = $x.print(scoped_cx!())?\n+    };\n+    (@$method:ident($($arg:expr),*)) => {\n+        scoped_cx!() = scoped_cx!().$method($($arg),*)?\n+    };\n+    ($($kind:ident $data:tt),+) => {{\n+        $(p!(@$kind $data);)+\n+    }};\n+}\n+macro_rules! define_scoped_cx {\n+    ($cx:ident) => {\n+        #[allow(unused_macros)]\n+        macro_rules! scoped_cx {\n+            () => ($cx)\n+        }\n+    };\n+}\n+\n+thread_local! {\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n+    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n+/// Adds the `crate::` prefix to paths where appropriate.\n+pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n+    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n+        let old = flag.get();\n+        flag.set(true);\n+        let result = f();\n+        flag.set(old);\n+        result\n+    })\n+}\n+\n+/// The \"region highlights\" are used to control region printing during\n+/// specific error messages. When a \"region highlight\" is enabled, it\n+/// gives an alternate way to print specific regions. For now, we\n+/// always print those regions using a number, so something like \"`'0`\".\n+///\n+/// Regions not selected by the region highlight mode are presently\n+/// unaffected.\n+#[derive(Copy, Clone, Default)]\n+pub struct RegionHighlightMode {\n+    /// If enabled, when we see the selected region, use \"`'N`\"\n+    /// instead of the ordinary behavior.\n+    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n+\n+    /// If enabled, when printing a \"free region\" that originated from\n+    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n+    /// have names print as normal.\n+    ///\n+    /// This is used when you have a signature like `fn foo(x: &u32,\n+    /// y: &'a u32)` and we want to give a name to the region of the\n+    /// reference `x`.\n+    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+}\n+\n+impl RegionHighlightMode {\n+    /// If `region` and `number` are both `Some`, invokes\n+    /// `highlighting_region`.\n+    pub fn maybe_highlighting_region(\n+        &mut self,\n+        region: Option<ty::Region<'_>>,\n+        number: Option<usize>,\n+    ) {\n+        if let Some(k) = region {\n+            if let Some(n) = number {\n+                self.highlighting_region(k, n);\n+            }\n+        }\n+    }\n+\n+    /// Highlights the region inference variable `vid` as `'N`.\n+    pub fn highlighting_region(\n+        &mut self,\n+        region: ty::Region<'_>,\n+        number: usize,\n+    ) {\n+        let num_slots = self.highlight_regions.len();\n+        let first_avail_slot = self.highlight_regions.iter_mut()\n+            .filter(|s| s.is_none())\n+            .next()\n+            .unwrap_or_else(|| {\n+                bug!(\n+                    \"can only highlight {} placeholders at a time\",\n+                    num_slots,\n+                )\n+            });\n+        *first_avail_slot = Some((*region, number));\n+    }\n+\n+    /// Convenience wrapper for `highlighting_region`.\n+    pub fn highlighting_region_vid(\n+        &mut self,\n+        vid: ty::RegionVid,\n+        number: usize,\n+    ) {\n+        self.highlighting_region(&ty::ReVar(vid), number)\n+    }\n+\n+    /// Returns `Some(n)` with the number to use for the given region, if any.\n+    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+        self\n+            .highlight_regions\n+            .iter()\n+            .filter_map(|h| match h {\n+                Some((r, n)) if r == region => Some(*n),\n+                _ => None,\n+            })\n+            .next()\n+    }\n+\n+    /// Highlight the given bound region.\n+    /// We can only highlight one bound region at a time. See\n+    /// the field `highlight_bound_region` for more detailed notes.\n+    pub fn highlighting_bound_region(\n+        &mut self,\n+        br: ty::BoundRegion,\n+        number: usize,\n+    ) {\n+        assert!(self.highlight_bound_region.is_none());\n+        self.highlight_bound_region = Some((br, number));\n+    }\n+}\n+\n+/// Trait for printers that pretty-print using `fmt::Write` to the printer.\n+pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n+    Printer<'gcx, 'tcx,\n+        Error = fmt::Error,\n+        Path = Self,\n+        Region = Self,\n+        Type = Self,\n+        DynExistential = Self,\n+    > +\n+    fmt::Write\n+{\n+    /// Like `print_def_path` but for value paths.\n+    fn print_value_path(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.print_def_path(def_id, substs)\n+    }\n+\n+    fn in_binder<T>(\n+        self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        value.skip_binder().print(self)\n+    }\n+\n+    /// Print comma-separated elements.\n+    fn comma_sep<T>(\n+        mut self,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = first.print(self)?;\n+            for elem in elems {\n+                self.write_str(\", \")?;\n+                self = elem.print(self)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    /// Print `<...>` around what `f` prints.\n+    fn generic_delimiters(\n+        self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error>;\n+\n+    /// Return `true` if the region should be printed in\n+    /// optional positions, e.g. `&'a T` or `dyn Tr + 'b`.\n+    /// This is typically the case for all non-`'_` regions.\n+    fn region_should_not_be_omitted(\n+        &self,\n+        region: ty::Region<'_>,\n+    ) -> bool;\n+\n+    // Defaults (should not be overriden):\n+\n+    /// If possible, this returns a global path resolving to `def_id` that is visible\n+    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n+    fn try_print_visible_def_path(\n+        mut self,\n+        def_id: DefId,\n+    ) -> Result<(Self, bool), Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+\n+        // If `def_id` is a direct or injected extern crate, return the\n+        // path to the crate followed by the path to the item within the crate.\n+        if def_id.index == CRATE_DEF_INDEX {\n+            let cnum = def_id.krate;\n+\n+            if cnum == LOCAL_CRATE {\n+                return Ok((self.path_crate(cnum)?, true));\n+            }\n+\n+            // In local mode, when we encounter a crate other than\n+            // LOCAL_CRATE, execution proceeds in one of two ways:\n+            //\n+            // 1. for a direct dependency, where user added an\n+            //    `extern crate` manually, we put the `extern\n+            //    crate` as the parent. So you wind up with\n+            //    something relative to the current crate.\n+            // 2. for an extern inferred from a path or an indirect crate,\n+            //    where there is no explicit `extern crate`, we just prepend\n+            //    the crate name.\n+            match *self.tcx().extern_crate(def_id) {\n+                Some(ExternCrate {\n+                    src: ExternCrateSource::Extern(def_id),\n+                    direct: true,\n+                    span,\n+                    ..\n+                }) => {\n+                    debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n+                    return Ok((if !span.is_dummy() {\n+                        self.print_def_path(def_id, &[])?\n+                    } else {\n+                        self.path_crate(cnum)?\n+                    }, true));\n+                }\n+                None => {\n+                    return Ok((self.path_crate(cnum)?, true));\n+                }\n+                _ => {},\n+            }\n+        }\n+\n+        if def_id.is_local() {\n+            return Ok((self, false));\n+        }\n+\n+        let visible_parent_map = self.tcx().visible_parent_map(LOCAL_CRATE);\n+\n+        let mut cur_def_key = self.tcx().def_key(def_id);\n+        debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n+\n+        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n+        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n+            let parent = DefId {\n+                krate: def_id.krate,\n+                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n+            };\n+\n+            cur_def_key = self.tcx().def_key(parent);\n+        }\n+\n+        let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n+            Some(parent) => parent,\n+            None => return Ok((self, false)),\n+        };\n+        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n+        // knowing ahead of time whether the entire path will succeed or not.\n+        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n+        // linked list on the stack would need to be built, before any printing.\n+        match self.try_print_visible_def_path(visible_parent)? {\n+            (cx, false) => return Ok((cx, false)),\n+            (cx, true) => self = cx,\n+        }\n+        let actual_parent = self.tcx().parent(def_id);\n+        debug!(\n+            \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n+            visible_parent, actual_parent,\n+        );\n+\n+        let mut data = cur_def_key.disambiguated_data.data;\n+        debug!(\n+            \"try_print_visible_def_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+            data, visible_parent, actual_parent,\n+        );\n+\n+        match data {\n+            // In order to output a path that could actually be imported (valid and visible),\n+            // we need to handle re-exports correctly.\n+            //\n+            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+            //\n+            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+            // private so the \"true\" path to `CommandExt` isn't accessible.\n+            //\n+            // In this case, the `visible_parent_map` will look something like this:\n+            //\n+            // (child) -> (parent)\n+            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+            // `std::sys::unix::ext` -> `std::os`\n+            //\n+            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+            // `std::os`.\n+            //\n+            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+            // to the parent - resulting in a mangled path like\n+            // `std::os::ext::process::CommandExt`.\n+            //\n+            // Instead, we must detect that there was a re-export and instead print `unix`\n+            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+            // the visible parent (`std::os`). If these do not match, then we iterate over\n+            // the children of the visible parent (as was done when computing\n+            // `visible_parent_map`), looking for the specific child we currently have and then\n+            // have access to the re-exported name.\n+            DefPathData::Module(ref mut name) |\n+            DefPathData::TypeNs(ref mut name) if Some(visible_parent) != actual_parent => {\n+                let reexport = self.tcx().item_children(visible_parent)\n+                    .iter()\n+                    .find(|child| child.def.def_id() == def_id)\n+                    .map(|child| child.ident.as_interned_str());\n+                if let Some(reexport) = reexport {\n+                    *name = reexport;\n+                }\n+            }\n+            // Re-exported `extern crate` (#43189).\n+            DefPathData::CrateRoot => {\n+                data = DefPathData::Module(\n+                    self.tcx().original_crate_name(def_id.krate).as_interned_str(),\n+                );\n+            }\n+            _ => {}\n+        }\n+        debug!(\"try_print_visible_def_path: data={:?}\", data);\n+\n+        Ok((self.path_append(Ok, &DisambiguatedDefPathData {\n+            data,\n+            disambiguator: 0,\n+        })?, true))\n+    }\n+\n+    fn pretty_path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        if trait_ref.is_none() {\n+            // Inherent impls. Try to print `Foo::bar` for an inherent\n+            // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n+            // anything other than a simple path.\n+            match self_ty.sty {\n+                ty::Adt(..) | ty::Foreign(_) |\n+                ty::Bool | ty::Char | ty::Str |\n+                ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n+                    return self_ty.print(self);\n+                }\n+\n+                _ => {}\n+            }\n+        }\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            p!(print(self_ty));\n+            if let Some(trait_ref) = trait_ref {\n+                p!(write(\" as \"), print(trait_ref));\n+            }\n+            Ok(cx)\n+        })\n+    }\n+\n+    fn pretty_path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        self.generic_delimiters(|mut cx| {\n+            define_scoped_cx!(cx);\n+\n+            p!(write(\"impl \"));\n+            if let Some(trait_ref) = trait_ref {\n+                p!(print(trait_ref), write(\" for \"));\n+            }\n+            p!(print(self_ty));\n+\n+            Ok(cx)\n+        })\n+    }\n+\n+    fn pretty_print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        match ty.sty {\n+            ty::Bool => p!(write(\"bool\")),\n+            ty::Char => p!(write(\"char\")),\n+            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::RawPtr(ref tm) => {\n+                p!(write(\"*{} \", match tm.mutbl {\n+                    hir::MutMutable => \"mut\",\n+                    hir::MutImmutable => \"const\",\n+                }));\n+                p!(print(tm.ty))\n+            }\n+            ty::Ref(r, ty, mutbl) => {\n+                p!(write(\"&\"));\n+                if self.region_should_not_be_omitted(r) {\n+                    p!(print(r), write(\" \"));\n+                }\n+                p!(print(ty::TypeAndMut { ty, mutbl }))\n+            }\n+            ty::Never => p!(write(\"!\")),\n+            ty::Tuple(ref tys) => {\n+                p!(write(\"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    p!(print(ty), write(\",\"));\n+                    if let Some(&ty) = tys.next() {\n+                        p!(write(\" \"), print(ty));\n+                        for &ty in tys {\n+                            p!(write(\", \"), print(ty));\n+                        }\n+                    }\n+                }\n+                p!(write(\")\"))\n+            }\n+            ty::FnDef(def_id, substs) => {\n+                let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n+                p!(print(sig), write(\" {{\"), print_value_path(def_id, substs), write(\"}}\"));\n+            }\n+            ty::FnPtr(ref bare_fn) => {\n+                p!(print(bare_fn))\n+            }\n+            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n+            ty::Error => p!(write(\"[type error]\")),\n+            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n+            ty::Bound(debruijn, bound_ty) => {\n+                match bound_ty.kind {\n+                    ty::BoundTyKind::Anon => {\n+                        if debruijn == ty::INNERMOST {\n+                            p!(write(\"^{}\", bound_ty.var.index()))\n+                        } else {\n+                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n+                        }\n+                    }\n+\n+                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n+                }\n+            }\n+            ty::Adt(def, substs) => {\n+                p!(print_def_path(def.did, substs));\n+            }\n+            ty::Dynamic(data, r) => {\n+                let print_r = self.region_should_not_be_omitted(r);\n+                if print_r {\n+                    p!(write(\"(\"));\n+                }\n+                p!(write(\"dyn \"), print(data));\n+                if print_r {\n+                    p!(write(\" + \"), print(r), write(\")\"));\n+                }\n+            }\n+            ty::Foreign(def_id) => {\n+                p!(print_def_path(def_id, &[]));\n+            }\n+            ty::Projection(ref data) => p!(print(data)),\n+            ty::UnnormalizedProjection(ref data) => {\n+                p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n+            }\n+            ty::Placeholder(placeholder) => {\n+                p!(write(\"Placeholder({:?})\", placeholder))\n+            }\n+            ty::Opaque(def_id, substs) => {\n+                // FIXME(eddyb) print this with `print_def_path`.\n+                if self.tcx().sess.verbose() {\n+                    p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                    return Ok(self);\n+                }\n+\n+                let def_key = self.tcx().def_key(def_id);\n+                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                    p!(write(\"{}\", name));\n+                    let mut substs = substs.iter();\n+                    // FIXME(eddyb) print this with `print_def_path`.\n+                    if let Some(first) = substs.next() {\n+                        p!(write(\"::<\"));\n+                        p!(print(first));\n+                        for subst in substs {\n+                            p!(write(\", \"), print(subst));\n+                        }\n+                        p!(write(\">\"));\n+                    }\n+                    return Ok(self);\n+                }\n+                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                // by looking up the projections associated with the def_id.\n+                let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+                let mut first = true;\n+                let mut is_sized = false;\n+                p!(write(\"impl\"));\n+                for predicate in bounds.predicates {\n+                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                        // Don't print +Sized, but rather +?Sized if absent.\n+                        if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                            is_sized = true;\n+                            continue;\n+                        }\n+\n+                        p!(\n+                                write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                print(trait_ref));\n+                        first = false;\n+                    }\n+                }\n+                if !is_sized {\n+                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                } else if first {\n+                    p!(write(\" Sized\"));\n+                }\n+            }\n+            ty::Str => p!(write(\"str\")),\n+            ty::Generator(did, substs, movability) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx());\n+                let witness = substs.witness(did, self.tcx());\n+                if movability == hir::GeneratorMovability::Movable {\n+                    p!(write(\"[generator\"));\n+                } else {\n+                    p!(write(\"[static generator\"));\n+                }\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                    p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx().hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                p!(write(\" \"), print(witness), write(\"]\"))\n+            },\n+            ty::GeneratorWitness(types) => {\n+                p!(in_binder(&types));\n+            }\n+            ty::Closure(did, substs) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx());\n+                p!(write(\"[closure\"));\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                    if self.tcx().sess.opts.debugging_opts.span_free_formats {\n+                        p!(write(\"@{:?}\", hir_id));\n+                    } else {\n+                        p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                    }\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx().hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                if self.tcx().sess.verbose() {\n+                    p!(write(\n+                        \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n+                        substs.closure_kind_ty(did, self.tcx()),\n+                        substs.closure_sig_ty(did, self.tcx())\n+                    ));\n+                }\n+\n+                p!(write(\"]\"))\n+            },\n+            ty::Array(ty, sz) => {\n+                p!(write(\"[\"), print(ty), write(\"; \"));\n+                match sz {\n+                    ty::LazyConst::Unevaluated(_def_id, _substs) => {\n+                        p!(write(\"_\"));\n+                    }\n+                    ty::LazyConst::Evaluated(c) => {\n+                        match c.val {\n+                            ConstValue::Infer(..) => p!(write(\"_\")),\n+                            ConstValue::Param(ParamConst { name, .. }) =>\n+                                p!(write(\"{}\", name)),\n+                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx()))),\n+                        }\n+                    }\n+                }\n+                p!(write(\"]\"))\n+            }\n+            ty::Slice(ty) => {\n+                p!(write(\"[\"), print(ty), write(\"]\"))\n+            }\n+        }\n+\n+        Ok(self)\n+    }\n+\n+    fn pretty_print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Generate the main trait ref, including associated types.\n+        let mut first = true;\n+\n+        if let Some(principal) = predicates.principal() {\n+            p!(print_def_path(principal.def_id, &[]));\n+\n+            let mut resugared = false;\n+\n+            // Special-case `Fn(...) -> ...` and resugar it.\n+            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n+                if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n+                    let mut projections = predicates.projection_bounds();\n+                    if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                        p!(pretty_fn_sig(args, false, proj.ty));\n+                        resugared = true;\n+                    }\n+                }\n+            }\n+\n+            // HACK(eddyb) this duplicates `FmtPrinter`'s `path_generic_args`,\n+            // in order to place the projections inside the `<...>`.\n+            if !resugared {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = self.tcx().mk_infer(ty::FreshTy(0));\n+                let principal = principal.with_self_ty(self.tcx(), dummy_self);\n+\n+                let args = self.generic_args_to_print(\n+                    self.tcx().generics_of(principal.def_id),\n+                    principal.substs,\n+                );\n+\n+                // Don't print `'_` if there's no unerased regions.\n+                let print_regions = args.iter().any(|arg| {\n+                    match arg.unpack() {\n+                        UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                        _ => false,\n+                    }\n+                });\n+                let mut args = args.iter().cloned().filter(|arg| {\n+                    match arg.unpack() {\n+                        UnpackedKind::Lifetime(_) => print_regions,\n+                        _ => true,\n+                    }\n+                });\n+                let mut projections = predicates.projection_bounds();\n+\n+                let arg0 = args.next();\n+                let projection0 = projections.next();\n+                if arg0.is_some() || projection0.is_some() {\n+                    let args = arg0.into_iter().chain(args);\n+                    let projections = projection0.into_iter().chain(projections);\n+\n+                    p!(generic_delimiters(|mut cx| {\n+                        cx = cx.comma_sep(args)?;\n+                        if arg0.is_some() && projection0.is_some() {\n+                            write!(cx, \", \")?;\n+                        }\n+                        cx.comma_sep(projections)\n+                    }));\n+                }\n+            }\n+            first = false;\n+        }\n+\n+        // Builtin bounds.\n+        // FIXME(eddyb) avoid printing twice (needed to ensure\n+        // that the auto traits are sorted *and* printed via cx).\n+        let mut auto_traits: Vec<_> = predicates.auto_traits().map(|did| {\n+            (self.tcx().def_path_str(did), did)\n+        }).collect();\n+\n+        // The auto traits come ordered by `DefPathHash`. While\n+        // `DefPathHash` is *stable* in the sense that it depends on\n+        // neither the host nor the phase of the moon, it depends\n+        // \"pseudorandomly\" on the compiler version and the target.\n+        //\n+        // To avoid that causing instabilities in compiletest\n+        // output, sort the auto-traits alphabetically.\n+        auto_traits.sort();\n+\n+        for (_, def_id) in auto_traits {\n+            if !first {\n+                p!(write(\" + \"));\n+            }\n+            first = false;\n+\n+            p!(print_def_path(def_id, &[]));\n+        }\n+\n+        Ok(self)\n+    }\n+\n+    fn pretty_fn_sig(\n+        mut self,\n+        inputs: &[Ty<'tcx>],\n+        c_variadic: bool,\n+        output: Ty<'tcx>,\n+    ) -> Result<Self, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        p!(write(\"(\"));\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            p!(print(ty));\n+            for &ty in inputs {\n+                p!(write(\", \"), print(ty));\n+            }\n+            if c_variadic {\n+                p!(write(\", ...\"));\n+            }\n+        }\n+        p!(write(\")\"));\n+        if !output.is_unit() {\n+            p!(write(\" -> \"), print(output));\n+        }\n+\n+        Ok(self)\n+    }\n+}\n+\n+// HACK(eddyb) boxed to avoid moving around a large struct by-value.\n+pub struct FmtPrinter<'a, 'gcx, 'tcx, F>(Box<FmtPrinterData<'a, 'gcx, 'tcx, F>>);\n+\n+pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fmt: F,\n+\n+    empty_path: bool,\n+    in_value: bool,\n+\n+    used_region_names: FxHashSet<InternedString>,\n+    region_index: usize,\n+    binder_depth: usize,\n+\n+    pub region_highlight_mode: RegionHighlightMode,\n+}\n+\n+impl<F> Deref for FmtPrinter<'a, 'gcx, 'tcx, F> {\n+    type Target = FmtPrinterData<'a, 'gcx, 'tcx, F>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<F> DerefMut for FmtPrinter<'_, '_, '_, F> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n+        FmtPrinter(Box::new(FmtPrinterData {\n+            tcx,\n+            fmt,\n+            empty_path: false,\n+            in_value: ns == Namespace::ValueNS,\n+            used_region_names: Default::default(),\n+            region_index: 0,\n+            binder_depth: 0,\n+            region_highlight_mode: RegionHighlightMode::default(),\n+        }))\n+    }\n+}\n+\n+impl TyCtxt<'_, '_, '_> {\n+    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n+    // (but also some things just print a `DefId` generally so maybe we need this?)\n+    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n+        match self.def_key(def_id).disambiguated_data.data {\n+            DefPathData::ValueNs(..) |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::Field(..) |\n+            DefPathData::AnonConst |\n+            DefPathData::ConstParam(..) |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor => Namespace::ValueNS,\n+\n+            DefPathData::MacroDef(..) => Namespace::MacroNS,\n+\n+            _ => Namespace::TypeNS,\n+        }\n+    }\n+\n+    /// Returns a string identifying this `DefId`. This string is\n+    /// suitable for user output.\n+    pub fn def_path_str(self, def_id: DefId) -> String {\n+        let ns = self.guess_def_namespace(def_id);\n+        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        let mut s = String::new();\n+        let _ = FmtPrinter::new(self, &mut s, ns)\n+            .print_def_path(def_id, &[]);\n+        s\n+    }\n+}\n+\n+impl<F: fmt::Write> fmt::Write for FmtPrinter<'_, '_, '_, F> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.fmt.write_str(s)\n+    }\n+}\n+\n+impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_def_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        if substs.is_empty() {\n+            match self.try_print_visible_def_path(def_id)? {\n+                (cx, true) => return Ok(cx),\n+                (cx, false) => self = cx,\n+            }\n+        }\n+\n+        let key = self.tcx.def_key(def_id);\n+        if let DefPathData::Impl = key.disambiguated_data.data {\n+            // Always use types for non-local impls, where types are always\n+            // available, and filename/line-number is mostly uninteresting.\n+            let use_types =\n+                !def_id.is_local() || {\n+                    // Otherwise, use filename/line-number if forced.\n+                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+                    !force_no_types\n+                };\n+\n+            if !use_types {\n+                // If no type info is available, fall back to\n+                // pretty printing some span information. This should\n+                // only occur very early in the compiler pipeline.\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let span = self.tcx.def_span(def_id);\n+\n+                self = self.print_def_path(parent_def_id, &[])?;\n+\n+                // HACK(eddyb) copy of `path_append` to avoid\n+                // constructing a `DisambiguatedDefPathData`.\n+                if !self.empty_path {\n+                    write!(self, \"::\")?;\n+                }\n+                write!(self, \"<impl at {:?}>\", span)?;\n+                self.empty_path = false;\n+\n+                return Ok(self);\n+            }\n+        }\n+\n+        self.default_print_def_path(def_id, substs)\n+    }\n+\n+    fn print_region(\n+        self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        self.pretty_print_region(region)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        self.pretty_print_type(ty)\n+    }\n+\n+    fn print_dyn_existential(\n+        self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        self.pretty_print_dyn_existential(predicates)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.empty_path = true;\n+        if cnum == LOCAL_CRATE {\n+            if self.tcx.sess.rust_2018() {\n+                // We add the `crate::` keyword on Rust 2018, only when desired.\n+                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                    write!(self, \"{}\", keywords::Crate.name())?;\n+                    self.empty_path = false;\n+                }\n+            }\n+        } else {\n+            write!(self, \"{}\", self.tcx.crate_name(cnum))?;\n+            self.empty_path = false;\n+        }\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        mut self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = self.pretty_path_qualified(self_ty, trait_ref)?;\n+        self.empty_path = false;\n+        Ok(self)\n+    }\n+\n+    fn path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = self.pretty_path_append_impl(|mut cx| {\n+            cx = print_prefix(cx)?;\n+            if !cx.empty_path {\n+                write!(cx, \"::\")?;\n+            }\n+\n+            Ok(cx)\n+        }, self_ty, trait_ref)?;\n+        self.empty_path = false;\n+        Ok(self)\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        match disambiguated_data.data {\n+            DefPathData::StructCtor => return Ok(self),\n+            _ => {}\n+        }\n+\n+        // FIXME(eddyb) `name` should never be empty, but it\n+        // currently is for `extern { ... }` \"foreign modules\".\n+        let name = disambiguated_data.data.as_interned_str().as_str();\n+        if !name.is_empty() {\n+            if !self.empty_path {\n+                write!(self, \"::\")?;\n+            }\n+            write!(self, \"{}\", name)?;\n+\n+            // FIXME(eddyb) this will print e.g. `{{closure}}#3`, but it\n+            // might be nicer to use something else, e.g. `{closure#3}`.\n+            let dis = disambiguated_data.disambiguator;\n+            let print_dis =\n+                disambiguated_data.data.get_opt_name().is_none() ||\n+                dis != 0 && self.tcx.sess.verbose();\n+            if print_dis {\n+                write!(self, \"#{}\", dis)?;\n+            }\n+\n+            self.empty_path = false;\n+        }\n+\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Don't print `'_` if there's no unerased regions.\n+        let print_regions = args.iter().any(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            if self.in_value {\n+                write!(self, \"::\")?;\n+            }\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    fn print_value_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        let was_in_value = std::mem::replace(&mut self.in_value, true);\n+        self = self.print_def_path(def_id, substs)?;\n+        self.in_value = was_in_value;\n+\n+        Ok(self)\n+    }\n+\n+    fn in_binder<T>(\n+        self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        self.pretty_in_binder(value)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let was_in_value = std::mem::replace(&mut self.in_value, false);\n+        let mut inner = f(self)?;\n+        inner.in_value = was_in_value;\n+\n+        write!(inner, \">\")?;\n+        Ok(inner)\n+    }\n+\n+    fn region_should_not_be_omitted(\n+        &self,\n+        region: ty::Region<'_>,\n+    ) -> bool {\n+        let highlight = self.region_highlight_mode;\n+        if highlight.region_highlighted(region).is_some() {\n+            return true;\n+        }\n+\n+        if self.tcx.sess.verbose() {\n+            return true;\n+        }\n+\n+        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n+\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                data.name != \"\" && data.name != \"'_\"\n+            }\n+\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some((region, _)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            ty::ReScope(_) |\n+            ty::ReVar(_) if identify_regions => true,\n+\n+            ty::ReVar(_) |\n+            ty::ReScope(_) |\n+            ty::ReErased => false,\n+\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReClosureBound(_) => true,\n+        }\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`.\n+impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n+    pub fn pretty_print_region(\n+        mut self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self, fmt::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Watch out for region highlights.\n+        let highlight = self.region_highlight_mode;\n+        if let Some(n) = highlight.region_highlighted(region) {\n+            p!(write(\"'{}\", n));\n+            return Ok(self);\n+        }\n+\n+        if self.tcx.sess.verbose() {\n+            p!(write(\"{:?}\", region));\n+            return Ok(self);\n+        }\n+\n+        let identify_regions = self.tcx.sess.opts.debugging_opts.identify_regions;\n+\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n+        match *region {\n+            ty::ReEarlyBound(ref data) => {\n+                if data.name != \"\" {\n+                    p!(write(\"{}\", data.name));\n+                    return Ok(self);\n+                }\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+                if let ty::BrNamed(_, name) = br {\n+                    if name != \"\" && name != \"'_\" {\n+                        p!(write(\"{}\", name));\n+                        return Ok(self);\n+                    }\n+                }\n+\n+                if let Some((region, counter)) = highlight.highlight_bound_region {\n+                    if br == region {\n+                        p!(write(\"'{}\", counter));\n+                        return Ok(self);\n+                    }\n+                }\n+            }\n+            ty::ReScope(scope) if identify_regions => {\n+                match scope.data {\n+                    region::ScopeData::Node =>\n+                        p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::CallSite =>\n+                        p!(write(\"'{}cs\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Arguments =>\n+                        p!(write(\"'{}as\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Destruction =>\n+                        p!(write(\"'{}ds\", scope.item_local_id().as_usize())),\n+                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n+                        \"'{}_{}rs\",\n+                        scope.item_local_id().as_usize(),\n+                        first_statement_index.index()\n+                    )),\n+                }\n+                return Ok(self);\n+            }\n+            ty::ReVar(region_vid) if identify_regions => {\n+                p!(write(\"{:?}\", region_vid));\n+                return Ok(self);\n+            }\n+            ty::ReVar(_) => {}\n+            ty::ReScope(_) |\n+            ty::ReErased => {}\n+            ty::ReStatic => {\n+                p!(write(\"'static\"));\n+                return Ok(self);\n+            }\n+            ty::ReEmpty => {\n+                p!(write(\"'<empty>\"));\n+                return Ok(self);\n+            }\n+\n+            // The user should never encounter these in unsubstituted form.\n+            ty::ReClosureBound(vid) => {\n+                p!(write(\"{:?}\", vid));\n+                return Ok(self);\n+            }\n+        }\n+\n+        p!(write(\"'_\"));\n+\n+        Ok(self)\n+    }\n+}\n+\n+// HACK(eddyb) limited to `FmtPrinter` because of `binder_depth`,\n+// `region_index` and `used_region_names`.\n+impl<F: fmt::Write> FmtPrinter<'_, 'gcx, 'tcx, F> {\n+    pub fn pretty_in_binder<T>(\n+        mut self,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, fmt::Error>\n+        where T: Print<'gcx, 'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>\n+    {\n+        fn name_by_region_index(index: usize) -> InternedString {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }.as_interned_str()\n+        }\n+\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        if self.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(value);\n+        }\n+\n+        let mut empty = true;\n+        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n+            write!(cx, \"{}\", if empty {\n+                empty = false;\n+                start\n+            } else {\n+                cont\n+            })\n+        };\n+\n+        define_scoped_cx!(self);\n+\n+        let old_region_index = self.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n+            let _ = start_or_continue(&mut self, \"for<\", \", \");\n+            let br = match br {\n+                ty::BrNamed(_, name) => {\n+                    let _ = write!(self, \"{}\", name);\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = loop {\n+                        let name = name_by_region_index(region_index);\n+                        region_index += 1;\n+                        if !self.used_region_names.contains(&name) {\n+                            break name;\n+                        }\n+                    };\n+                    let _ = write!(self, \"{}\", name);\n+                    ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n+                }\n+            };\n+            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n+        }).0;\n+        start_or_continue(&mut self, \"\", \"> \")?;\n+\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let mut inner = new_value.print(self)?;\n+        inner.region_index = old_region_index;\n+        inner.binder_depth -= 1;\n+        Ok(inner)\n+    }\n+\n+    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n+        where T: TypeFoldable<'tcx>\n+    {\n+\n+        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<InternedString>);\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+                match *r {\n+                    ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                        self.0.insert(name);\n+                    },\n+                    _ => {},\n+                }\n+                r.super_visit_with(self)\n+            }\n+        }\n+\n+        self.used_region_names.clear();\n+        let mut collector = LateBoundRegionNameCollector(&mut self.used_region_names);\n+        value.visit_with(&mut collector);\n+        self.region_index = 0;\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, T, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for ty::Binder<T>\n+    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n+{\n+    type Output = P;\n+    type Error = P::Error;\n+    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n+        cx.in_binder(self)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, T, U, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P>\n+    for ty::OutlivesPredicate<T, U>\n+    where T: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n+          U: Print<'gcx, 'tcx, P, Output = P, Error = P::Error>,\n+{\n+    type Output = P;\n+    type Error = P::Error;\n+    fn print(&self, mut cx: P) -> Result<Self::Output, Self::Error> {\n+        define_scoped_cx!(cx);\n+        p!(print(self.0), write(\" : \"), print(self.1));\n+        Ok(cx)\n+    }\n+}\n+\n+macro_rules! forward_display_to_print {\n+    ($($ty:ty),+) => {\n+        $(impl fmt::Display for $ty {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                ty::tls::with(|tcx| {\n+                    tcx.lift(self)\n+                        .expect(\"could not lift for printing\")\n+                        .print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n+                    Ok(())\n+                })\n+            }\n+        })+\n+    };\n+}\n+\n+macro_rules! define_print_and_forward_display {\n+    (($self:ident, $cx:ident): $($ty:ty $print:block)+) => {\n+        $(impl<'gcx: 'tcx, 'tcx, P: PrettyPrinter<'gcx, 'tcx>> Print<'gcx, 'tcx, P> for $ty {\n+            type Output = P;\n+            type Error = fmt::Error;\n+            fn print(&$self, $cx: P) -> Result<Self::Output, Self::Error> {\n+                #[allow(unused_mut)]\n+                let mut $cx = $cx;\n+                define_scoped_cx!($cx);\n+                let _: () = $print;\n+                #[allow(unreachable_code)]\n+                Ok($cx)\n+            }\n+        })+\n+\n+        forward_display_to_print!($($ty),+);\n+    };\n+}\n+\n+// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n+impl fmt::Display for ty::RegionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            self.print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+forward_display_to_print! {\n+    Ty<'tcx>,\n+    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+\n+    // HACK(eddyb) these are exhaustive instead of generic,\n+    // because `for<'gcx: 'tcx, 'tcx>` isn't possible yet.\n+    ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+    ty::Binder<ty::TraitRef<'tcx>>,\n+    ty::Binder<ty::FnSig<'tcx>>,\n+    ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n+\n+    ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n+    ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+}\n+\n+define_print_and_forward_display! {\n+    (self, cx):\n+\n+    &'tcx ty::List<Ty<'tcx>> {\n+        p!(write(\"{{\"));\n+        let mut tys = self.iter();\n+        if let Some(&ty) = tys.next() {\n+            p!(print(ty));\n+            for &ty in tys {\n+                p!(write(\", \"), print(ty));\n+            }\n+        }\n+        p!(write(\"}}\"))\n+    }\n+\n+    ty::TypeAndMut<'tcx> {\n+        p!(write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+            print(self.ty))\n+    }\n+\n+    ty::ExistentialTraitRef<'tcx> {\n+        // Use a type that can't appear in defaults of type parameters.\n+        let dummy_self = cx.tcx().mk_infer(ty::FreshTy(0));\n+        let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n+        p!(print(trait_ref))\n+    }\n+\n+    ty::ExistentialProjection<'tcx> {\n+        let name = cx.tcx().associated_item(self.item_def_id).ident;\n+        p!(write(\"{} = \", name), print(self.ty))\n+    }\n+\n+    ty::ExistentialPredicate<'tcx> {\n+        match *self {\n+            ty::ExistentialPredicate::Trait(x) => p!(print(x)),\n+            ty::ExistentialPredicate::Projection(x) => p!(print(x)),\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                p!(print_def_path(def_id, &[]));\n+            }\n+        }\n+    }\n+\n+    ty::FnSig<'tcx> {\n+        if self.unsafety == hir::Unsafety::Unsafe {\n+            p!(write(\"unsafe \"));\n+        }\n+\n+        if self.abi != Abi::Rust {\n+            p!(write(\"extern {} \", self.abi));\n+        }\n+\n+        p!(write(\"fn\"), pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+    }\n+\n+    ty::InferTy {\n+        if cx.tcx().sess.verbose() {\n+            p!(write(\"{:?}\", self));\n+            return Ok(cx);\n+        }\n+        match *self {\n+            ty::TyVar(_) => p!(write(\"_\")),\n+            ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n+            ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n+            ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n+            ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n+            ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n+        }\n+    }\n+\n+    ty::TraitRef<'tcx> {\n+        p!(print_def_path(self.def_id, self.substs));\n+    }\n+\n+    ConstValue<'tcx> {\n+        match self {\n+            ConstValue::Infer(..) => p!(write(\"_\")),\n+            ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n+            _ => p!(write(\"{:?}\", self)),\n+        }\n+    }\n+\n+    ty::Const<'tcx> {\n+        p!(write(\"{} : {}\", self.val, self.ty))\n+    }\n+\n+    &'tcx ty::LazyConst<'tcx> {\n+        match self {\n+            // FIXME(const_generics) this should print at least the type.\n+            ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n+            ty::LazyConst::Evaluated(c) => p!(write(\"{}\", c)),\n+        }\n+    }\n+\n+    ty::ParamTy {\n+        p!(write(\"{}\", self.name))\n+    }\n+\n+    ty::ParamConst {\n+        p!(write(\"{}\", self.name))\n+    }\n+\n+    ty::SubtypePredicate<'tcx> {\n+        p!(print(self.a), write(\" <: \"), print(self.b))\n+    }\n+\n+    ty::TraitPredicate<'tcx> {\n+        p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+    }\n+\n+    ty::ProjectionPredicate<'tcx> {\n+        p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n+    }\n+\n+    ty::ProjectionTy<'tcx> {\n+        p!(print_def_path(self.item_def_id, self.substs));\n+    }\n+\n+    ty::ClosureKind {\n+        match *self {\n+            ty::ClosureKind::Fn => p!(write(\"Fn\")),\n+            ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n+            ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n+        }\n+    }\n+\n+    ty::Predicate<'tcx> {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => p!(print(data)),\n+            ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                p!(write(\"the trait `\"),\n+                   print_def_path(trait_def_id, &[]),\n+                   write(\"` is object-safe\"))\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+                p!(write(\"the closure `\"),\n+                   print_value_path(closure_def_id, &[]),\n+                   write(\"` implements the trait `{}`\", kind))\n+            }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                p!(write(\"the constant `\"),\n+                   print_value_path(def_id, substs),\n+                   write(\"` can be evaluated\"))\n+            }\n+        }\n+    }\n+\n+    Kind<'tcx> {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => p!(print(lt)),\n+            UnpackedKind::Type(ty) => p!(print(ty)),\n+            UnpackedKind::Const(ct) => p!(print(ct)),\n+        }\n+    }\n+}"}, {"sha": "395b288df141e11410998d712d061e22ed730053", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -71,7 +71,7 @@ pub(super) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n-            format!(\"processing `{}`\", tcx.item_path_str(def_id)).into()\n+            format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()\n         } else {\n             let name = unsafe { ::std::intrinsics::type_name::<M>() };\n             format!(\"processing {:?} with query `{}`\", def_id, name).into()\n@@ -301,7 +301,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"computing the supertraits of `{}`\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n@@ -322,7 +322,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n@@ -359,7 +359,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n         format!(\"generating MIR shim for `{}`\",\n-                tcx.item_path_str(def.def_id())).into()\n+                tcx.def_path_str(def.def_id())).into()\n     }\n }\n \n@@ -394,7 +394,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n     ) -> Cow<'static, str> {\n         format!(\n             \"const-evaluating + checking `{}`\",\n-            tcx.item_path_str(key.value.instance.def.def_id()),\n+            tcx.def_path_str(key.value.instance.def.def_id()),\n         ).into()\n     }\n \n@@ -415,7 +415,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval_raw<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n         -> Cow<'static, str>\n     {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id())).into()\n+        format!(\"const-evaluating `{}`\", tcx.def_path_str(key.value.instance.def.def_id())).into()\n     }\n \n     #[inline]\n@@ -513,7 +513,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.item_path_str(def_id)).into()\n+            tcx.def_path_str(def_id)).into()\n     }\n \n     #[inline]\n@@ -532,21 +532,21 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_sta\n impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking which parts of `{}` are promotable to static\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking if item is mir available: `{}`\",\n-                tcx.item_path_str(def_id)).into()\n+                tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>,\n                 key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+        format!(\"checking if `{}` fulfills its obligations\", tcx.def_path_str(key.1.def_id()))\n             .into()\n     }\n \n@@ -565,19 +565,19 @@ impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx>\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id)).into()\n+        format!(\"trait impls of `{}`\", tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id)).into()\n+        format!(\"determine object safety of trait `{}`\", tcx.def_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn_raw<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id)).into()\n+        format!(\"checking if item is const fn: `{}`\", tcx.def_path_str(def_id)).into()\n     }\n }\n \n@@ -883,7 +883,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> Cow<'static, str> {\n-        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id())).into()\n+        format!(\"finding all methods for trait {}\", tcx.def_path_str(key.def_id())).into()\n     }\n }\n \n@@ -927,7 +927,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, SubstsRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0)).into()\n+        format!(\"testing substituted normalized predicates:`{}`\", tcx.def_path_str(key.0)).into()\n     }\n }\n \n@@ -945,7 +945,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n-        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id())).into()\n+        format!(\"estimating size for `{}`\", tcx.def_path_str(def.def_id())).into()\n     }\n }\n "}, {"sha": "cff99f23d0e95176d5765cadb6f847f3419d47d0", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -4,11 +4,10 @@\n \n use crate::dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n use crate::ty::tls;\n-use crate::ty::{TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use crate::ty::query::Query;\n use crate::ty::query::config::{QueryConfig, QueryDescription};\n use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n-use crate::ty::item_path;\n \n use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n@@ -299,7 +298,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // sometimes cycles itself, leading to extra cycle errors.\n         // (And cycle errors around impls tend to occur during the\n         // collect/coherence phases anyhow.)\n-        item_path::with_forced_impl_filename_line(|| {\n+        ty::print::with_forced_impl_filename_line(|| {\n             let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n             let mut err = struct_span_err!(self.sess,\n                                            span,"}, {"sha": "b245d90379996951f6775dcac6ff099f77ebf859", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -351,10 +351,8 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n-    let a_sty = &a.sty;\n-    let b_sty = &b.sty;\n-    debug!(\"super_relate_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n-    match (a_sty, b_sty) {\n+    debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n+    match (&a.sty, &b.sty) {\n         (&ty::Infer(_), _) |\n         (_, &ty::Infer(_)) =>\n         {"}, {"sha": "ecfb034e4f2fed45f066f5b820f727514473751e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,17 +3,288 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n+use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::print::{FmtPrinter, Printer};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n \n+use std::fmt;\n use std::marker::PhantomData;\n use std::rc::Rc;\n \n+impl fmt::Debug for ty::GenericParamDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let type_name = match self.kind {\n+            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n+            ty::GenericParamDefKind::Type {..} => \"Type\",\n+            ty::GenericParamDefKind::Const => \"Const\",\n+        };\n+        write!(f, \"{}({}, {:?}, {})\",\n+               type_name,\n+               self.name,\n+               self.def_id,\n+               self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            FmtPrinter::new(tcx, f, Namespace::TypeNS)\n+                .print_def_path(self.def_id, &[])?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::AdtDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            FmtPrinter::new(tcx, f, Namespace::TypeNS)\n+                .print_def_path(self.did, &[])?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n+    }\n+}\n+\n+impl fmt::Debug for ty::UpvarId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let name = ty::tls::with(|tcx| {\n+            tcx.hir().name_by_hir_id(self.var_path.hir_id)\n+        });\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+            self.var_path.hir_id,\n+            name,\n+            self.closure_expr_id)\n+    }\n+}\n+\n+impl fmt::Debug for ty::UpvarBorrow<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+    }\n+}\n+\n+impl fmt::Debug for ty::BoundRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+            ty::BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+            ty::BrNamed(did, name) => {\n+                write!(f, \"BrNamed({:?}:{:?}, {})\",\n+                        did.krate, did.index, name)\n+            }\n+            ty::BrEnv => write!(f, \"BrEnv\"),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::ReEarlyBound(ref data) => {\n+                write!(f, \"ReEarlyBound({}, {})\",\n+                        data.index,\n+                        data.name)\n+            }\n+\n+            ty::ReClosureBound(ref vid) => {\n+                write!(f, \"ReClosureBound({:?})\", vid)\n+            }\n+\n+            ty::ReLateBound(binder_id, ref bound_region) => {\n+                write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n+            }\n+\n+            ty::ReFree(ref fr) => fr.fmt(f),\n+\n+            ty::ReScope(id) => write!(f, \"ReScope({:?})\", id),\n+\n+            ty::ReStatic => write!(f, \"ReStatic\"),\n+\n+            ty::ReVar(ref vid) => vid.fmt(f),\n+\n+            ty::RePlaceholder(placeholder) => {\n+                write!(f, \"RePlaceholder({:?})\", placeholder)\n+            }\n+\n+            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+            ty::ReErased => write!(f, \"ReErased\"),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::FreeRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+    }\n+}\n+\n+impl fmt::Debug for ty::Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            ty::Covariant => \"+\",\n+            ty::Contravariant => \"-\",\n+            ty::Invariant => \"o\",\n+            ty::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"({:?}; c_variadic: {})->{:?}\",\n+                self.inputs(), self.c_variadic, self.output())\n+    }\n+}\n+\n+impl fmt::Debug for ty::TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}c\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"'_#{}r\", self.index())\n+    }\n+}\n+\n+impl fmt::Debug for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::TyVar(ref v) => v.fmt(f),\n+            ty::IntVar(ref v) => v.fmt(f),\n+            ty::FloatVar(ref v) => v.fmt(f),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::IntType(ref v) => v.fmt(f),\n+            ty::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // FIXME(#59188) this is used across the compiler to print\n+        // a `TraitRef` qualified (with the Self type explicit),\n+        // instead of having a different way to make that choice.\n+        write!(f, \"<{} as {}>\", self.self_ty(), self)\n+    }\n+}\n+\n+impl fmt::Debug for Ty<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}/#{}\", self.name, self.idx)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ParamConst {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}/#{}\", self.name, self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"TraitPredicate({:?})\", self.trait_ref)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ProjectionPredicate({:?}, {:?})\", self.projection_ty, self.ty)\n+    }\n+}\n+\n+impl fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::Predicate::Trait(ref a) => a.fmt(f),\n+            ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n+            ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::Predicate::Projection(ref pair) => pair.fmt(f),\n+            ty::Predicate::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                write!(f, \"ClosureKind({:?}, {:?}, {:?})\",\n+                    closure_def_id, closure_substs, kind)\n+            }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Atomic structs\n //\n@@ -48,10 +319,14 @@ CloneTypeFoldableAndLiftImpls! {\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n     crate::ty::BoundRegion,\n+    crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::ClosureKind,\n+    crate::ty::FreeRegion,\n+    crate::ty::InferTy,\n     crate::ty::IntVarValue,\n     crate::ty::ParamConst,\n     crate::ty::ParamTy,\n+    crate::ty::RegionVid,\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n     ::syntax_pos::Span,\n@@ -60,6 +335,7 @@ CloneTypeFoldableAndLiftImpls! {\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n+// FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -156,6 +432,23 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n+    type Lifted = ty::ExistentialPredicate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::ExistentialPredicate::Trait(x) => {\n+                tcx.lift(x).map(ty::ExistentialPredicate::Trait)\n+            }\n+            ty::ExistentialPredicate::Projection(x) => {\n+                tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n+            }\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                Some(ty::ExistentialPredicate::AutoTrait(*def_id))\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -480,6 +773,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     }\n }\n \n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ty::TypeAndMut<'a> {\n+        type Lifted = ty::TypeAndMut<'tcx>;\n+        ty, mutbl\n+    }\n+}\n+\n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for ty::Instance<'a> {\n         type Lifted = ty::Instance<'tcx>;"}, {"sha": "7b6a51c01845980bc9764e623050f0e702efa972", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -9,7 +9,7 @@ use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n-use crate::ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtDef, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, Pointer};\n@@ -84,7 +84,7 @@ impl BoundRegion {\n \n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `libsyntax/ast.rs` as well.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable)]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n@@ -383,9 +383,10 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     ///\n     /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n-        match self.closure_sig_ty(def_id, tcx).sty {\n+        let ty = self.closure_sig_ty(def_id, tcx);\n+        match ty.sty {\n             ty::FnPtr(sig) => sig,\n-            ref t => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", t),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty),\n         }\n     }\n }\n@@ -1590,7 +1591,7 @@ impl RegionKind {\n     pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_, '_>) -> DefId {\n         match self {\n             ty::ReEarlyBound(br) => {\n-                tcx.parent_def_id(br.def_id).unwrap()\n+                tcx.parent(br.def_id).unwrap()\n             }\n             ty::ReFree(fr) => fr.scope,\n             _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),\n@@ -1910,7 +1911,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n-            Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => false,\n             Int(..) | Uint(..) | Float(..) => true,\n             _ => false,\n         }"}, {"sha": "846428656146917250b4104c0ff83bd09710e45b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -12,8 +12,8 @@ use smallvec::SmallVec;\n use rustc_macros::HashStable;\n \n use core::intrinsics;\n-use std::cmp::Ordering;\n use std::fmt;\n+use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n@@ -70,6 +70,16 @@ impl<'tcx> UnpackedKind<'tcx> {\n     }\n }\n \n+impl fmt::Debug for Kind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.fmt(f),\n+            UnpackedKind::Type(ty) => ty.fmt(f),\n+            UnpackedKind::Const(ct) => ct.fmt(f),\n+        }\n+    }\n+}\n+\n impl<'tcx> Ord for Kind<'tcx> {\n     fn cmp(&self, other: &Kind<'_>) -> Ordering {\n         self.unpack().cmp(&other.unpack())\n@@ -115,34 +125,14 @@ impl<'tcx> Kind<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for Kind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n-            UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n-            UnpackedKind::Const(ct) => write!(f, \"{:?}\", ct),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for Kind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n-            UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n-            UnpackedKind::Const(ct) => write!(f, \"{}\", ct),\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n     type Lifted = Kind<'tcx>;\n \n     fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => lt.lift_to_tcx(tcx).map(|lt| lt.into()),\n-            UnpackedKind::Type(ty) => ty.lift_to_tcx(tcx).map(|ty| ty.into()),\n-            UnpackedKind::Const(ct) => ct.lift_to_tcx(tcx).map(|ct| ct.into()),\n+            UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n+            UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n+            UnpackedKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n         }\n     }\n }"}, {"sha": "65918a90821022cc4048dec58718657950ec4eba", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -7,7 +7,7 @@ use crate::hir::{self, Node};\n use crate::mir::interpret::{sign_extend, truncate};\n use crate::ich::NodeIdHashingMode;\n use crate::traits::{self, ObligationCause};\n-use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::TyKind::*;\n@@ -563,7 +563,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n         let mut def_id = def_id;\n         while self.is_closure(def_id) {\n-            def_id = self.parent_def_id(def_id).unwrap_or_else(|| {\n+            def_id = self.parent(def_id).unwrap_or_else(|| {\n                 bug!(\"closure {:?} has no parent\", def_id);\n             });\n         }"}, {"sha": "a1398c69ff0c59ea69732cbe4f5c269c948f914e", "filename": "src/librustc/util/ppaux.rs", "status": "removed", "additions": 0, "deletions": 1667, "changes": 1667, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,1667 +0,0 @@\n-use crate::hir::def_id::DefId;\n-use crate::hir::map::definitions::DefPathData;\n-use crate::middle::region;\n-use crate::ty::subst::{self, Subst, SubstsRef};\n-use crate::ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use crate::ty::{Bool, Char, Adt};\n-use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n-use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n-use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n-use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n-use crate::mir::interpret::ConstValue;\n-use crate::util::nodemap::FxHashSet;\n-\n-use std::cell::Cell;\n-use std::fmt;\n-use std::usize;\n-\n-use rustc_target::spec::abi::Abi;\n-use syntax::ast::CRATE_NODE_ID;\n-use syntax::symbol::{Symbol, InternedString};\n-use crate::hir;\n-\n-/// The \"region highlights\" are used to control region printing during\n-/// specific error messages. When a \"region highlight\" is enabled, it\n-/// gives an alternate way to print specific regions. For now, we\n-/// always print those regions using a number, so something like \"`'0`\".\n-///\n-/// Regions not selected by the region highlight mode are presently\n-/// unaffected.\n-#[derive(Copy, Clone, Default)]\n-pub struct RegionHighlightMode {\n-    /// If enabled, when we see the selected region, use \"`'N`\"\n-    /// instead of the ordinary behavior.\n-    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n-\n-    /// If enabled, when printing a \"free region\" that originated from\n-    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n-    /// have names print as normal.\n-    ///\n-    /// This is used when you have a signature like `fn foo(x: &u32,\n-    /// y: &'a u32)` and we want to give a name to the region of the\n-    /// reference `x`.\n-    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n-}\n-\n-thread_local! {\n-    /// Mechanism for highlighting of specific regions for display in NLL region inference errors.\n-    /// Contains region to highlight and counter for number to use when highlighting.\n-    static REGION_HIGHLIGHT_MODE: Cell<RegionHighlightMode> =\n-        Cell::new(RegionHighlightMode::default())\n-}\n-\n-impl RegionHighlightMode {\n-    /// Reads and returns the current region highlight settings (accesses thread-local state).\n-    pub fn get() -> Self {\n-        REGION_HIGHLIGHT_MODE.with(|c| c.get())\n-    }\n-\n-    // Internal helper to update current settings during the execution of `op`.\n-    fn set<R>(\n-        old_mode: Self,\n-        new_mode: Self,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        REGION_HIGHLIGHT_MODE.with(|c| {\n-            c.set(new_mode);\n-            let result = op();\n-            c.set(old_mode);\n-            result\n-        })\n-    }\n-\n-    /// If `region` and `number` are both `Some`, invokes\n-    /// `highlighting_region`; otherwise, just invokes `op` directly.\n-    pub fn maybe_highlighting_region<R>(\n-        region: Option<ty::Region<'_>>,\n-        number: Option<usize>,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        if let Some(k) = region {\n-            if let Some(n) = number {\n-                return Self::highlighting_region(k, n, op);\n-            }\n-        }\n-\n-        op()\n-    }\n-\n-    /// During the execution of `op`, highlights the region inference\n-    /// variable `vid` as `'N`. We can only highlight one region `vid`\n-    /// at a time.\n-    pub fn highlighting_region<R>(\n-        region: ty::Region<'_>,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        let mut new_mode = old_mode;\n-        let first_avail_slot = new_mode.highlight_regions.iter_mut()\n-            .filter(|s| s.is_none())\n-            .next()\n-            .unwrap_or_else(|| {\n-                panic!(\n-                    \"can only highlight {} placeholders at a time\",\n-                    old_mode.highlight_regions.len(),\n-                )\n-            });\n-        *first_avail_slot = Some((*region, number));\n-        Self::set(old_mode, new_mode, op)\n-    }\n-\n-    /// Convenience wrapper for `highlighting_region`.\n-    pub fn highlighting_region_vid<R>(\n-        vid: ty::RegionVid,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        Self::highlighting_region(&ty::ReVar(vid), number, op)\n-    }\n-\n-    /// Returns `true` if any placeholders are highlighted, and `false` otherwise.\n-    fn any_region_vids_highlighted(&self) -> bool {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .any(|h| match h {\n-                Some((ty::ReVar(_), _)) => true,\n-                _ => false,\n-            })\n-    }\n-\n-    /// Returns `Some(n)` with the number to use for the given region, if any.\n-    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .filter_map(|h| match h {\n-                Some((r, n)) if r == region => Some(*n),\n-                _ => None,\n-            })\n-            .next()\n-    }\n-\n-    /// During the execution of `op`, highlight the given bound\n-    /// region. We can only highlight one bound region at a time. See\n-    /// the field `highlight_bound_region` for more detailed notes.\n-    pub fn highlighting_bound_region<R>(\n-        br: ty::BoundRegion,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        assert!(old_mode.highlight_bound_region.is_none());\n-        Self::set(\n-            old_mode,\n-            Self {\n-                highlight_bound_region: Some((br, number)),\n-                ..old_mode\n-            },\n-            op,\n-        )\n-    }\n-\n-    /// Returns `true` if any placeholders are highlighted, and `false` otherwise.\n-    pub fn any_placeholders_highlighted(&self) -> bool {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .any(|h| match h {\n-                Some((ty::RePlaceholder(_), _)) => true,\n-                _ => false,\n-            })\n-    }\n-\n-    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as \"`'N`\".\n-    pub fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n-        self.region_highlighted(&ty::RePlaceholder(p))\n-    }\n-}\n-\n-macro_rules! gen_display_debug_body {\n-    ( $with:path ) => {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let mut cx = PrintContext::new();\n-            $with(self, f, &mut cx)\n-        }\n-    };\n-}\n-macro_rules! gen_display_debug {\n-    ( ($($x:tt)+) $target:ty, display yes ) => {\n-        impl<$($x)+> fmt::Display for $target {\n-            gen_display_debug_body! { Print::print_display }\n-        }\n-    };\n-    ( () $target:ty, display yes ) => {\n-        impl fmt::Display for $target {\n-            gen_display_debug_body! { Print::print_display }\n-        }\n-    };\n-    ( ($($x:tt)+) $target:ty, debug yes ) => {\n-        impl<$($x)+> fmt::Debug for $target {\n-            gen_display_debug_body! { Print::print_debug }\n-        }\n-    };\n-    ( () $target:ty, debug yes ) => {\n-        impl fmt::Debug for $target {\n-            gen_display_debug_body! { Print::print_debug }\n-        }\n-    };\n-    ( $generic:tt $target:ty, $t:ident no ) => {};\n-}\n-macro_rules! gen_print_impl {\n-    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n-        impl<$($x)+> Print for $target {\n-            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n-                if $cx.is_debug $dbg\n-                else $disp\n-            }\n-        }\n-    };\n-    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n-        impl Print for $target {\n-            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n-                if $cx.is_debug $dbg\n-                else $disp\n-            }\n-        }\n-    };\n-    ( $generic:tt $target:ty,\n-      $vars:tt $gendisp:ident $disp:block $gendbg:ident $dbg:block ) => {\n-        gen_print_impl! { $generic $target, $vars $disp $dbg }\n-        gen_display_debug! { $generic $target, display $gendisp }\n-        gen_display_debug! { $generic $target, debug $gendbg }\n-    }\n-}\n-macro_rules! define_print {\n-    ( $generic:tt $target:ty,\n-      $vars:tt { display $disp:block debug $dbg:block } ) => {\n-        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n-    };\n-    ( $generic:tt $target:ty,\n-      $vars:tt { debug $dbg:block display $disp:block } ) => {\n-        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n-    };\n-    ( $generic:tt $target:ty,\n-      $vars:tt { debug $dbg:block } ) => {\n-        gen_print_impl! { $generic $target, $vars no {\n-            bug!(concat!(\"display not implemented for \", stringify!($target)));\n-        } yes $dbg }\n-    };\n-    ( $generic:tt $target:ty,\n-      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n-        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n-            write!($f, \"{:?}\", $self)\n-        } }\n-    };\n-}\n-macro_rules! define_print_multi {\n-    ( [ $($generic:tt $target:ty),* ] $vars:tt $def:tt ) => {\n-        $(define_print! { $generic $target, $vars $def })*\n-    };\n-}\n-macro_rules! print_inner {\n-    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n-        write!($f, $($data),+)\n-    };\n-    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n-        $data.$kind($f, $cx)\n-    };\n-}\n-macro_rules! print {\n-    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n-        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n-    };\n-}\n-\n-\n-struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n-impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match *r {\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n-                self.0.insert(name);\n-            },\n-            _ => {},\n-        }\n-        r.super_visit_with(self)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct PrintContext {\n-    is_debug: bool,\n-    is_verbose: bool,\n-    identify_regions: bool,\n-    used_region_names: Option<FxHashSet<InternedString>>,\n-    region_index: usize,\n-    binder_depth: usize,\n-}\n-impl PrintContext {\n-    fn new() -> Self {\n-        ty::tls::with_opt(|tcx| {\n-            let (is_verbose, identify_regions) = tcx.map(\n-                |tcx| (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions)\n-            ).unwrap_or((false, false));\n-            PrintContext {\n-                is_debug: false,\n-                is_verbose: is_verbose,\n-                identify_regions: identify_regions,\n-                used_region_names: None,\n-                region_index: 0,\n-                binder_depth: 0,\n-            }\n-        })\n-    }\n-    fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n-    where T: TypeFoldable<'tcx>\n-    {\n-        let mut collector = LateBoundRegionNameCollector(Default::default());\n-        value.visit_with(&mut collector);\n-        self.used_region_names = Some(collector.0);\n-        self.region_index = 0;\n-    }\n-}\n-\n-pub trait Print {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result;\n-    fn print_to_string(&self, cx: &mut PrintContext) -> String {\n-        let mut result = String::new();\n-        let _ = self.print(&mut result, cx);\n-        result\n-    }\n-    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n-        let old_debug = cx.is_debug;\n-        cx.is_debug = false;\n-        let result = self.print(f, cx);\n-        cx.is_debug = old_debug;\n-        result\n-    }\n-    fn print_display_to_string(&self, cx: &mut PrintContext) -> String {\n-        let mut result = String::new();\n-        let _ = self.print_display(&mut result, cx);\n-        result\n-    }\n-    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n-        let old_debug = cx.is_debug;\n-        cx.is_debug = true;\n-        let result = self.print(f, cx);\n-        cx.is_debug = old_debug;\n-        result\n-    }\n-    fn print_debug_to_string(&self, cx: &mut PrintContext) -> String {\n-        let mut result = String::new();\n-        let _ = self.print_debug(&mut result, cx);\n-        result\n-    }\n-}\n-\n-impl PrintContext {\n-    fn fn_sig<F: fmt::Write>(&mut self,\n-                             f: &mut F,\n-                             inputs: &[Ty<'_>],\n-                             c_variadic: bool,\n-                             output: Ty<'_>)\n-                             -> fmt::Result {\n-        write!(f, \"(\")?;\n-        let mut inputs = inputs.iter();\n-        if let Some(&ty) = inputs.next() {\n-            print!(f, self, print_display(ty))?;\n-            for &ty in inputs {\n-                print!(f, self, write(\", \"), print_display(ty))?;\n-            }\n-            if c_variadic {\n-                write!(f, \", ...\")?;\n-            }\n-        }\n-        write!(f, \")\")?;\n-        if !output.is_unit() {\n-            print!(f, self, write(\" -> \"), print_display(output))?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn parameterized<F: fmt::Write>(&mut self,\n-                                    f: &mut F,\n-                                    substs: SubstsRef<'_>,\n-                                    did: DefId,\n-                                    projections: &[ty::ProjectionPredicate<'_>])\n-                                    -> fmt::Result {\n-        let key = ty::tls::with(|tcx| tcx.def_key(did));\n-\n-        let verbose = self.is_verbose;\n-        let mut num_supplied_defaults = 0;\n-        let mut has_self = false;\n-        let mut own_counts: GenericParamCount = Default::default();\n-        let mut is_value_path = false;\n-        let mut item_name = Some(key.disambiguated_data.data.as_interned_str());\n-        let fn_trait_kind = ty::tls::with(|tcx| {\n-            // Unfortunately, some kinds of items (e.g., closures) don't have\n-            // generics. So walk back up the find the closest parent that DOES\n-            // have them.\n-            let mut item_def_id = did;\n-            loop {\n-                let key = tcx.def_key(item_def_id);\n-                match key.disambiguated_data.data {\n-                    DefPathData::AssocTypeInTrait(_) |\n-                    DefPathData::AssocTypeInImpl(_) |\n-                    DefPathData::AssocExistentialInImpl(_) |\n-                    DefPathData::Trait(_) |\n-                    DefPathData::TraitAlias(_) |\n-                    DefPathData::Impl |\n-                    DefPathData::TypeNs(_) => {\n-                        break;\n-                    }\n-                    DefPathData::ValueNs(_) |\n-                    DefPathData::EnumVariant(_) => {\n-                        is_value_path = true;\n-                        break;\n-                    }\n-                    DefPathData::CrateRoot |\n-                    DefPathData::Misc |\n-                    DefPathData::Module(_) |\n-                    DefPathData::MacroDef(_) |\n-                    DefPathData::ClosureExpr |\n-                    DefPathData::TypeParam(_) |\n-                    DefPathData::LifetimeParam(_) |\n-                    DefPathData::ConstParam(_) |\n-                    DefPathData::Field(_) |\n-                    DefPathData::StructCtor |\n-                    DefPathData::AnonConst |\n-                    DefPathData::ImplTrait |\n-                    DefPathData::GlobalMetaData(_) => {\n-                        // if we're making a symbol for something, there ought\n-                        // to be a value or type-def or something in there\n-                        // *somewhere*\n-                        item_def_id.index = key.parent.unwrap_or_else(|| {\n-                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                                 parent\", did, item_def_id);\n-                        });\n-                    }\n-                }\n-            }\n-            let mut generics = tcx.generics_of(item_def_id);\n-            let child_own_counts = generics.own_counts();\n-            let mut path_def_id = did;\n-            has_self = generics.has_self;\n-\n-            let mut child_types = 0;\n-            if let Some(def_id) = generics.parent {\n-                // Methods.\n-                assert!(is_value_path);\n-                child_types = child_own_counts.types;\n-                generics = tcx.generics_of(def_id);\n-                own_counts = generics.own_counts();\n-\n-                if has_self {\n-                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n-                }\n-\n-                path_def_id = def_id;\n-            } else {\n-                item_name = None;\n-\n-                if is_value_path {\n-                    // Functions.\n-                    assert_eq!(has_self, false);\n-                } else {\n-                    // Types and traits.\n-                    own_counts = child_own_counts;\n-                }\n-            }\n-\n-            if !verbose {\n-                let mut type_params =\n-                    generics.params.iter().rev().filter_map(|param| match param.kind {\n-                        GenericParamDefKind::Lifetime => None,\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            Some((param.def_id, has_default))\n-                        }\n-                        GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n-                    }).peekable();\n-                let has_default = {\n-                    let has_default = type_params.peek().map(|(_, has_default)| has_default);\n-                    *has_default.unwrap_or(&false)\n-                };\n-                if has_default {\n-                    if let Some(substs) = tcx.lift(&substs) {\n-                        let types = substs.types().rev().skip(child_types);\n-                        for ((def_id, has_default), actual) in type_params.zip(types) {\n-                            if !has_default {\n-                                break;\n-                            }\n-                            if tcx.type_of(def_id).subst(tcx, substs) != actual {\n-                                break;\n-                            }\n-                            num_supplied_defaults += 1;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n-            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-        })?;\n-\n-        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-            let projection_ty = projections[0].ty;\n-            if let Tuple(ref args) = substs.type_at(1).sty {\n-                return self.fn_sig(f, args, false, projection_ty);\n-            }\n-        }\n-\n-        let empty = Cell::new(true);\n-        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n-            if empty.get() {\n-                empty.set(false);\n-                write!(f, \"{}\", start)\n-            } else {\n-                write!(f, \"{}\", cont)\n-            }\n-        };\n-\n-        let print_regions = |f: &mut F, start: &str, skip, count| {\n-            // Don't print any regions if they're all erased.\n-            let regions = || substs.regions().skip(skip).take(count);\n-            if regions().all(|r: ty::Region<'_>| *r == ty::ReErased) {\n-                return Ok(());\n-            }\n-\n-            for region in regions() {\n-                let region: ty::Region<'_> = region;\n-                start_or_continue(f, start, \", \")?;\n-                if verbose {\n-                    write!(f, \"{:?}\", region)?;\n-                } else {\n-                    let s = region.to_string();\n-                    if s.is_empty() {\n-                        // This happens when the value of the region\n-                        // parameter is not easily serialized. This may be\n-                        // because the user omitted it in the first place,\n-                        // or because it refers to some block in the code,\n-                        // etc. I'm not sure how best to serialize this.\n-                        write!(f, \"'_\")?;\n-                    } else {\n-                        write!(f, \"{}\", s)?;\n-                    }\n-                }\n-            }\n-\n-            Ok(())\n-        };\n-\n-        print_regions(f, \"<\", 0, own_counts.lifetimes)?;\n-\n-        let tps = substs.types()\n-                        .take(own_counts.types - num_supplied_defaults)\n-                        .skip(has_self as usize);\n-\n-        for ty in tps {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ty.print_display(f, self)?;\n-        }\n-\n-        for projection in projections {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ty::tls::with(|tcx|\n-                print!(f, self,\n-                       write(\"{}=\",\n-                             tcx.associated_item(projection.projection_ty.item_def_id).ident),\n-                       print_display(projection.ty))\n-            )?;\n-        }\n-\n-        // FIXME(const_generics::defaults)\n-        let consts = substs.consts();\n-\n-        for ct in consts {\n-            start_or_continue(f, \"<\", \", \")?;\n-            ct.print_display(f, self)?;\n-        }\n-\n-        start_or_continue(f, \"\", \">\")?;\n-\n-        // For values, also print their name and type parameters.\n-        if is_value_path {\n-            empty.set(true);\n-\n-            if has_self {\n-                write!(f, \">\")?;\n-            }\n-\n-            if let Some(item_name) = item_name {\n-                write!(f, \"::{}\", item_name)?;\n-            }\n-\n-            print_regions(f, \"::<\", own_counts.lifetimes, usize::MAX)?;\n-\n-            // FIXME: consider being smart with defaults here too\n-            for ty in substs.types().skip(own_counts.types) {\n-                start_or_continue(f, \"::<\", \", \")?;\n-                ty.print_display(f, self)?;\n-            }\n-\n-            start_or_continue(f, \"\", \">\")?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn in_binder<'a, 'gcx, 'tcx, T, U, F>(&mut self,\n-                                          f: &mut F,\n-                                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                          original: &ty::Binder<T>,\n-                                          lifted: Option<ty::Binder<U>>) -> fmt::Result\n-        where T: Print, U: Print + TypeFoldable<'tcx>, F: fmt::Write\n-    {\n-        fn name_by_region_index(index: usize) -> InternedString {\n-            match index {\n-                0 => Symbol::intern(\"'r\"),\n-                1 => Symbol::intern(\"'s\"),\n-                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n-            }.as_interned_str()\n-        }\n-\n-        // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n-        // clearly differentiate between named and unnamed regions in\n-        // the output. We'll probably want to tweak this over time to\n-        // decide just how much information to give.\n-        let value = if let Some(v) = lifted {\n-            v\n-        } else {\n-            return original.skip_binder().print_display(f, self);\n-        };\n-\n-        if self.binder_depth == 0 {\n-            self.prepare_late_bound_region_info(&value);\n-        }\n-\n-        let mut empty = true;\n-        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n-            if empty {\n-                empty = false;\n-                write!(f, \"{}\", start)\n-            } else {\n-                write!(f, \"{}\", cont)\n-            }\n-        };\n-\n-        let old_region_index = self.region_index;\n-        let mut region_index = old_region_index;\n-        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n-            let _ = start_or_continue(f, \"for<\", \", \");\n-            let br = match br {\n-                ty::BrNamed(_, name) => {\n-                    let _ = write!(f, \"{}\", name);\n-                    br\n-                }\n-                ty::BrAnon(_) |\n-                ty::BrFresh(_) |\n-                ty::BrEnv => {\n-                    let name = loop {\n-                        let name = name_by_region_index(region_index);\n-                        region_index += 1;\n-                        if !self.is_name_used(&name) {\n-                            break name;\n-                        }\n-                    };\n-                    let _ = write!(f, \"{}\", name);\n-                    ty::BrNamed(tcx.hir().local_def_id(CRATE_NODE_ID), name)\n-                }\n-            };\n-            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n-        }).0;\n-        start_or_continue(f, \"\", \"> \")?;\n-\n-        // Push current state to gcx, and restore after writing new_value.\n-        self.binder_depth += 1;\n-        self.region_index = region_index;\n-        let result = new_value.print_display(f, self);\n-        self.region_index = old_region_index;\n-        self.binder_depth -= 1;\n-        result\n-    }\n-\n-    fn is_name_used(&self, name: &InternedString) -> bool {\n-        match self.used_region_names {\n-            Some(ref names) => names.contains(name),\n-            None => false,\n-        }\n-    }\n-}\n-\n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n-}\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n-}\n-\n-pub fn parameterized<F: fmt::Write>(f: &mut F,\n-                                    substs: SubstsRef<'_>,\n-                                    did: DefId,\n-                                    projections: &[ty::ProjectionPredicate<'_>])\n-                                    -> fmt::Result {\n-    PrintContext::new().parameterized(f, substs, did, projections)\n-}\n-\n-impl<'a, T: Print> Print for &'a T {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n-        (*self).print(f, cx)\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n-        display {\n-            // Generate the main trait ref, including associated types.\n-            ty::tls::with(|tcx| {\n-                // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-                let mut first = true;\n-\n-                if let Some(principal) = self.principal() {\n-                    let principal = tcx\n-                        .lift(&principal)\n-                        .expect(\"could not lift TraitRef for printing\")\n-                        .with_self_ty(tcx, dummy_self);\n-                    let projections = self.projection_bounds().map(|p| {\n-                        tcx.lift(&p)\n-                            .expect(\"could not lift projection for printing\")\n-                            .with_self_ty(tcx, dummy_self)\n-                    }).collect::<Vec<_>>();\n-                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n-                    first = false;\n-                }\n-\n-                // Builtin bounds.\n-                let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n-                    tcx.item_path_str(did)\n-                }).collect();\n-\n-                // The auto traits come ordered by `DefPathHash`. While\n-                // `DefPathHash` is *stable* in the sense that it depends on\n-                // neither the host nor the phase of the moon, it depends\n-                // \"pseudorandomly\" on the compiler version and the target.\n-                //\n-                // To avoid that causing instabilities in compiletest\n-                // output, sort the auto-traits alphabetically.\n-                auto_traits.sort();\n-\n-                for auto_trait in auto_traits {\n-                    if !first {\n-                        write!(f, \" + \")?;\n-                    }\n-                    first = false;\n-\n-                    write!(f, \"{}\", auto_trait)?;\n-                }\n-\n-                Ok(())\n-            })?;\n-\n-            Ok(())\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = match self.kind {\n-            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n-            ty::GenericParamDefKind::Type { .. } => \"Type\",\n-            ty::GenericParamDefKind::Const => \"Const\",\n-        };\n-        write!(f, \"{}({}, {:?}, {})\",\n-               type_name,\n-               self.name,\n-               self.def_id,\n-               self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::TraitDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            write!(f, \"{}\", tcx.item_path_str(self.def_id))\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for ty::AdtDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            write!(f, \"{}\", tcx.item_path_str(self.did))\n-        })\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_path.hir_id,\n-               ty::tls::with(|tcx| tcx.hir().name_by_hir_id(self.var_path.hir_id)),\n-               self.closure_expr_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, f, cx) {\n-        display {\n-            write!(f, \"{{\")?;\n-            let mut tys = self.iter();\n-            if let Some(&ty) = tys.next() {\n-                print!(f, cx, print(ty))?;\n-                for &ty in tys {\n-                    print!(f, cx, write(\", \"), print(ty))?;\n-                }\n-            }\n-            write!(f, \"}}\")\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n-        display {\n-            print!(f, cx,\n-                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n-                   print(self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n-        display {\n-            cx.parameterized(f, self.substs, self.def_id, &[])\n-        }\n-        debug {\n-            ty::tls::with(|tcx| {\n-                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-                let trait_ref = *tcx.lift(&ty::Binder::bind(*self))\n-                                   .expect(\"could not lift TraitRef for printing\")\n-                                   .with_self_ty(tcx, dummy_self).skip_binder();\n-                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-            })\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n-        debug {\n-            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::BoundRegion, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                return self.print_debug(f, cx);\n-            }\n-\n-            if let Some((region, counter)) = RegionHighlightMode::get().highlight_bound_region {\n-                if *self == region {\n-                    return match *self {\n-                        BrNamed(_, name) => write!(f, \"{}\", name),\n-                        BrAnon(_) | BrFresh(_) | BrEnv => write!(f, \"'{}\", counter)\n-                    };\n-                }\n-            }\n-\n-            match *self {\n-                BrNamed(_, name) => write!(f, \"{}\", name),\n-                BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n-            }\n-        }\n-        debug {\n-            return match *self {\n-                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-                BrNamed(did, name) => {\n-                    write!(f, \"BrNamed({:?}:{:?}, {})\",\n-                           did.krate, did.index, name)\n-                }\n-                BrEnv => write!(f, \"BrEnv\"),\n-            };\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::PlaceholderRegion, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                return self.print_debug(f, cx);\n-            }\n-\n-            let highlight = RegionHighlightMode::get();\n-            if let Some(counter) = highlight.placeholder_highlight(*self) {\n-                write!(f, \"'{}\", counter)\n-            } else if highlight.any_placeholders_highlighted() {\n-                write!(f, \"'_\")\n-            } else {\n-                write!(f, \"{}\", self.name)\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::RegionKind, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                return self.print_debug(f, cx);\n-            }\n-\n-            // Watch out for region highlights.\n-            if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n-                return write!(f, \"'{:?}\", n);\n-            }\n-\n-            // These printouts are concise.  They do not contain all the information\n-            // the user might want to diagnose an error, but there is basically no way\n-            // to fit that into a short string.  Hence the recommendation to use\n-            // `explain_region()` or `note_and_explain_region()`.\n-            match *self {\n-                ty::ReEarlyBound(ref data) => {\n-                    write!(f, \"{}\", data.name)\n-                }\n-                ty::ReLateBound(_, br) |\n-                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) => {\n-                    write!(f, \"{}\", br)\n-                }\n-                ty::RePlaceholder(p) => {\n-                    write!(f, \"{}\", p)\n-                }\n-                ty::ReScope(scope) if cx.identify_regions => {\n-                    match scope.data {\n-                        region::ScopeData::Node =>\n-                            write!(f, \"'{}s\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::CallSite =>\n-                            write!(f, \"'{}cs\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Arguments =>\n-                            write!(f, \"'{}as\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Destruction =>\n-                            write!(f, \"'{}ds\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Remainder(first_statement_index) => write!(\n-                            f,\n-                            \"'{}_{}rs\",\n-                            scope.item_local_id().as_usize(),\n-                            first_statement_index.index()\n-                        ),\n-                    }\n-                }\n-                ty::ReVar(region_vid) => {\n-                    if RegionHighlightMode::get().any_region_vids_highlighted() {\n-                        write!(f, \"{:?}\", region_vid)\n-                    } else if cx.identify_regions {\n-                        write!(f, \"'{}rv\", region_vid.index())\n-                    } else {\n-                        Ok(())\n-                    }\n-                }\n-                ty::ReScope(_) |\n-                ty::ReErased => Ok(()),\n-                ty::ReStatic => write!(f, \"'static\"),\n-                ty::ReEmpty => write!(f, \"'<empty>\"),\n-\n-                // The user should never encounter these in unsubstituted form.\n-                ty::ReClosureBound(vid) => write!(f, \"{:?}\", vid),\n-            }\n-        }\n-        debug {\n-            match *self {\n-                ty::ReEarlyBound(ref data) => {\n-                    write!(f, \"ReEarlyBound({}, {})\",\n-                           data.index,\n-                           data.name)\n-                }\n-\n-                ty::ReClosureBound(ref vid) => {\n-                    write!(f, \"ReClosureBound({:?})\",\n-                           vid)\n-                }\n-\n-                ty::ReLateBound(binder_id, ref bound_region) => {\n-                    write!(f, \"ReLateBound({:?}, {:?})\",\n-                           binder_id,\n-                           bound_region)\n-                }\n-\n-                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n-\n-                ty::ReScope(id) => {\n-                    write!(f, \"ReScope({:?})\", id)\n-                }\n-\n-                ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-                ty::ReVar(ref vid) => {\n-                    write!(f, \"{:?}\", vid)\n-                }\n-\n-                ty::RePlaceholder(placeholder) => {\n-                    write!(f, \"RePlaceholder({:?})\", placeholder)\n-                }\n-\n-                ty::ReEmpty => write!(f, \"ReEmpty\"),\n-\n-                ty::ReErased => write!(f, \"ReErased\")\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::FreeRegion, (self, f, cx) {\n-        debug {\n-            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::Variance, (self, f, cx) {\n-        debug {\n-            f.write_str(match *self {\n-                ty::Covariant => \"+\",\n-                ty::Contravariant => \"-\",\n-                ty::Invariant => \"o\",\n-                ty::Bivariant => \"*\",\n-            })\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"GenericPredicates({:?})\", self.predicates)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n-        display {\n-            if self.unsafety == hir::Unsafety::Unsafe {\n-                write!(f, \"unsafe \")?;\n-            }\n-\n-            if self.abi != Abi::Rust {\n-                write!(f, \"extern {} \", self.abi)?;\n-            }\n-\n-            write!(f, \"fn\")?;\n-            cx.fn_sig(f, self.inputs(), self.c_variadic, self.output())\n-        }\n-        debug {\n-            write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}t\", self.index)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}i\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::RegionVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(counter) = RegionHighlightMode::get().region_highlighted(&ty::ReVar(*self)) {\n-            return write!(f, \"'{:?}\", counter);\n-        } else if RegionHighlightMode::get().any_region_vids_highlighted() {\n-            return write!(f, \"'_\");\n-        }\n-\n-        write!(f, \"'_#{}r\", self.index())\n-    }\n-}\n-\n-define_print! {\n-    () ty::InferTy, (self, f, cx) {\n-        display {\n-            if cx.is_verbose {\n-                print!(f, cx, print_debug(self))\n-            } else {\n-                match *self {\n-                    ty::TyVar(_) => write!(f, \"_\"),\n-                    ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-                    ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-                    ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-                    ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-                    ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n-                }\n-            }\n-        }\n-        debug {\n-            match *self {\n-                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::IntType(ref v) => v.fmt(f),\n-            ty::UintType(ref v) => v.fmt(f),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-// The generic impl doesn't work yet because projections are not\n-// normalized under HRTB.\n-/*impl<T> fmt::Display for ty::Binder<T>\n-    where T: fmt::Display + for<'a> ty::Lift<'a>,\n-          for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}*/\n-\n-define_print_multi! {\n-    [\n-    ('tcx) ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n-    ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n-    ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n-    ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n-    ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n-    ]\n-    (self, f, cx) {\n-        display {\n-            ty::tls::with(|tcx| cx.in_binder(f, tcx, self, tcx.lift(self)))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n-        display {\n-            cx.parameterized(f, self.substs, self.def_id, &[])\n-        }\n-        debug {\n-            // when printing out the debug representation, we don't need\n-            // to enumerate the `for<...>` etc because the debruijn index\n-            // tells you everything you need to know.\n-            print!(f, cx,\n-                   write(\"<\"),\n-                   print(self.self_ty()),\n-                   write(\" as \"))?;\n-            cx.parameterized(f, self.substs, self.def_id, &[])?;\n-            write!(f, \">\")\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TyKind<'tcx>, (self, f, cx) {\n-        display {\n-            match *self {\n-                Bool => write!(f, \"bool\"),\n-                Char => write!(f, \"char\"),\n-                Int(t) => write!(f, \"{}\", t.ty_to_string()),\n-                Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n-                Float(t) => write!(f, \"{}\", t.ty_to_string()),\n-                RawPtr(ref tm) => {\n-                    write!(f, \"*{} \", match tm.mutbl {\n-                        hir::MutMutable => \"mut\",\n-                        hir::MutImmutable => \"const\",\n-                    })?;\n-                    tm.ty.print(f, cx)\n-                }\n-                Ref(r, ty, mutbl) => {\n-                    write!(f, \"&\")?;\n-                    let s = r.print_to_string(cx);\n-                    if s != \"'_\" {\n-                        write!(f, \"{}\", s)?;\n-                        if !s.is_empty() {\n-                            write!(f, \" \")?;\n-                        }\n-                    }\n-                    ty::TypeAndMut { ty, mutbl }.print(f, cx)\n-                }\n-                Never => write!(f, \"!\"),\n-                Tuple(ref tys) => {\n-                    write!(f, \"(\")?;\n-                    let mut tys = tys.iter();\n-                    if let Some(&ty) = tys.next() {\n-                        print!(f, cx, print(ty), write(\",\"))?;\n-                        if let Some(&ty) = tys.next() {\n-                            print!(f, cx, write(\" \"), print(ty))?;\n-                            for &ty in tys {\n-                                print!(f, cx, write(\", \"), print(ty))?;\n-                            }\n-                        }\n-                    }\n-                    write!(f, \")\")\n-                }\n-                FnDef(def_id, substs) => {\n-                    ty::tls::with(|tcx| {\n-                        let mut sig = tcx.fn_sig(def_id);\n-                        if let Some(substs) = tcx.lift(&substs) {\n-                            sig = sig.subst(tcx, substs);\n-                        }\n-                        print!(f, cx, print(sig), write(\" {{\"))\n-                    })?;\n-                    cx.parameterized(f, substs, def_id, &[])?;\n-                    write!(f, \"}}\")\n-                }\n-                FnPtr(ref bare_fn) => {\n-                    bare_fn.print(f, cx)\n-                }\n-                Infer(infer_ty) => write!(f, \"{}\", infer_ty),\n-                Error => write!(f, \"[type error]\"),\n-                Param(ref param_ty) => write!(f, \"{}\", param_ty),\n-                Bound(debruijn, bound_ty) => {\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Anon => {\n-                            if debruijn == ty::INNERMOST {\n-                                write!(f, \"^{}\", bound_ty.var.index())\n-                            } else {\n-                                write!(f, \"^{}_{}\", debruijn.index(), bound_ty.var.index())\n-                            }\n-                        }\n-\n-                        ty::BoundTyKind::Param(p) => write!(f, \"{}\", p),\n-                    }\n-                }\n-                Adt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n-                Dynamic(data, r) => {\n-                    let r = r.print_to_string(cx);\n-                    if !r.is_empty() {\n-                        write!(f, \"(\")?;\n-                    }\n-                    write!(f, \"dyn \")?;\n-                    data.print(f, cx)?;\n-                    if !r.is_empty() {\n-                        write!(f, \" + {})\", r)\n-                    } else {\n-                        Ok(())\n-                    }\n-                }\n-                Foreign(def_id) => parameterized(f, subst::InternalSubsts::empty(), def_id, &[]),\n-                Projection(ref data) => data.print(f, cx),\n-                UnnormalizedProjection(ref data) => {\n-                    write!(f, \"Unnormalized(\")?;\n-                    data.print(f, cx)?;\n-                    write!(f, \")\")\n-                }\n-                Placeholder(placeholder) => {\n-                    write!(f, \"Placeholder({:?})\", placeholder)\n-                }\n-                Opaque(def_id, substs) => {\n-                    if cx.is_verbose {\n-                        return write!(f, \"Opaque({:?}, {:?})\", def_id, substs);\n-                    }\n-\n-                    ty::tls::with(|tcx| {\n-                        let def_key = tcx.def_key(def_id);\n-                        if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                            write!(f, \"{}\", name)?;\n-                            let mut substs = substs.iter();\n-                            if let Some(first) = substs.next() {\n-                                write!(f, \"::<\")?;\n-                                write!(f, \"{}\", first)?;\n-                                for subst in substs {\n-                                    write!(f, \", {}\", subst)?;\n-                                }\n-                                write!(f, \">\")?;\n-                            }\n-                            return Ok(());\n-                        }\n-                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                        // by looking up the projections associated with the def_id.\n-                        let predicates_of = tcx.predicates_of(def_id);\n-                        let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                            tcx.intern_substs(&[])\n-                        });\n-                        let bounds = predicates_of.instantiate(tcx, substs);\n-\n-                        let mut first = true;\n-                        let mut is_sized = false;\n-                        write!(f, \"impl\")?;\n-                        for predicate in bounds.predicates {\n-                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                                // Don't print +Sized, but rather +?Sized if absent.\n-                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                    is_sized = true;\n-                                    continue;\n-                                }\n-\n-                                print!(f, cx,\n-                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                       print(trait_ref))?;\n-                                first = false;\n-                            }\n-                        }\n-                        if !is_sized {\n-                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                        } else if first {\n-                            write!(f, \" Sized\")?;\n-                        }\n-                        Ok(())\n-                    })\n-                }\n-                Str => write!(f, \"str\"),\n-                Generator(did, substs, movability) => ty::tls::with(|tcx| {\n-                    let upvar_tys = substs.upvar_tys(did, tcx);\n-                    let witness = substs.witness(did, tcx);\n-                    if movability == hir::GeneratorMovability::Movable {\n-                        write!(f, \"[generator\")?;\n-                    } else {\n-                        write!(f, \"[static generator\")?;\n-                    }\n-\n-                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n-                        let mut sep = \" \";\n-                        tcx.with_freevars(hir_id, |freevars| {\n-                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(f, cx,\n-                                       write(\"{}{}:\",\n-                                             sep,\n-                                             tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty))?;\n-                                sep = \", \";\n-                            }\n-                            Ok(())\n-                        })?\n-                    } else {\n-                        // cross-crate closure types should only be\n-                        // visible in codegen bug reports, I imagine.\n-                        write!(f, \"@{:?}\", did)?;\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(f, cx,\n-                                   write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty))?;\n-                            sep = \", \";\n-                        }\n-                    }\n-\n-                    print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n-                }),\n-                GeneratorWitness(types) => {\n-                    ty::tls::with(|tcx| cx.in_binder(f, tcx, &types, tcx.lift(&types)))\n-                }\n-                Closure(did, substs) => ty::tls::with(|tcx| {\n-                    let upvar_tys = substs.upvar_tys(did, tcx);\n-                    write!(f, \"[closure\")?;\n-\n-                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-                        if tcx.sess.opts.debugging_opts.span_free_formats {\n-                            write!(f, \"@{:?}\", hir_id)?;\n-                        } else {\n-                            write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n-                        }\n-                        let mut sep = \" \";\n-                        tcx.with_freevars(hir_id, |freevars| {\n-                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(f, cx,\n-                                       write(\"{}{}:\",\n-                                             sep,\n-                                             tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty))?;\n-                                sep = \", \";\n-                            }\n-                            Ok(())\n-                        })?\n-                    } else {\n-                        // cross-crate closure types should only be\n-                        // visible in codegen bug reports, I imagine.\n-                        write!(f, \"@{:?}\", did)?;\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(f, cx,\n-                                   write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty))?;\n-                            sep = \", \";\n-                        }\n-                    }\n-\n-                    if cx.is_verbose {\n-                        write!(\n-                            f,\n-                            \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                            substs.closure_kind_ty(did, tcx),\n-                            substs.closure_sig_ty(did, tcx),\n-                        )?;\n-                    }\n-\n-                    write!(f, \"]\")\n-                }),\n-                Array(ty, sz) => {\n-                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n-                    match sz {\n-                        ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                            write!(f, \"_\")?;\n-                        }\n-                        ty::LazyConst::Evaluated(c) => ty::tls::with(|tcx| {\n-                            match c.val {\n-                                ConstValue::Infer(..) => write!(f, \"_\"),\n-                                ConstValue::Param(ParamConst { name, .. }) =>\n-                                    write!(f, \"{}\", name),\n-                                _ => write!(f, \"{}\", c.unwrap_usize(tcx)),\n-                            }\n-                        })?,\n-                    }\n-                    write!(f, \"]\")\n-                }\n-                Slice(ty) => {\n-                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TyS<'tcx>, (self, f, cx) {\n-        display {\n-            self.sty.print(f, cx)\n-        }\n-        debug {\n-            self.sty.print_display(f, cx)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ConstValue<'tcx>, (self, f, cx) {\n-        display {\n-            match self {\n-                ConstValue::Infer(..) => write!(f, \"_\"),\n-                ConstValue::Param(ParamConst { name, .. }) => write!(f, \"{}\", name),\n-                _ => write!(f, \"{:?}\", self),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::Const<'tcx>, (self, f, cx) {\n-        display {\n-            write!(f, \"{} : {}\", self.val, self.ty)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::LazyConst<'tcx>, (self, f, cx) {\n-        display {\n-            match self {\n-                ty::LazyConst::Unevaluated(..) => write!(f, \"_ : _\"),\n-                ty::LazyConst::Evaluated(c) => write!(f, \"{}\", c),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::ParamTy, (self, f, cx) {\n-        display {\n-            write!(f, \"{}\", self.name)\n-        }\n-        debug {\n-            write!(f, \"{}/#{}\", self.name, self.idx)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::ParamConst, (self, f, cx) {\n-        display {\n-            write!(f, \"{}\", self.name)\n-        }\n-        debug {\n-            write!(f, \"{}/#{}\", self.name, self.index)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n-    (self, f, cx) {\n-        display {\n-            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n-        display {\n-            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"TraitPredicate({:?})\",\n-                   self.trait_ref)\n-        }\n-        display {\n-            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n-        debug {\n-            print!(f, cx,\n-                   write(\"ProjectionPredicate(\"),\n-                   print(self.projection_ty),\n-                   write(\", \"),\n-                   print(self.ty),\n-                   write(\")\"))\n-        }\n-        display {\n-            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n-        display {\n-            // FIXME(tschottdorf): use something like\n-            //   parameterized(f, self.substs, self.item_def_id, &[])\n-            // (which currently ICEs).\n-            let (trait_ref, item_name) = ty::tls::with(|tcx|\n-                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).ident)\n-            );\n-            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    () ty::ClosureKind, (self, f, cx) {\n-        display {\n-            match *self {\n-                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n-        display {\n-            match *self {\n-                ty::Predicate::Trait(ref data) => data.print(f, cx),\n-                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n-                ty::Predicate::ObjectSafe(trait_def_id) =>\n-                    ty::tls::with(|tcx| {\n-                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                    }),\n-                ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) =>\n-                    ty::tls::with(|tcx| {\n-                        write!(f, \"the closure `{}` implements the trait `{}`\",\n-                               tcx.item_path_str(closure_def_id), kind)\n-                    }),\n-                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    write!(f, \"the constant `\")?;\n-                    cx.parameterized(f, substs, def_id, &[])?;\n-                    write!(f, \"` can be evaluated\")\n-                }\n-            }\n-        }\n-        debug {\n-            match *self {\n-                ty::Predicate::Trait(ref a) => a.print(f, cx),\n-                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n-                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n-                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n-                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n-                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n-                ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n-                }\n-                ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                    write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n-                }\n-                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "2739a30a291352e79bdca861ae5b6ea1d2335002", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,3 +1,4 @@\n+use std::borrow::Cow;\n use std::fs;\n use std::io::{BufWriter, Write};\n use std::mem;\n@@ -20,12 +21,12 @@ pub enum ProfileCategory {\n     Other,\n }\n \n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Clone, Debug, Eq, PartialEq)]\n pub enum ProfilerEvent {\n     QueryStart { query_name: &'static str, category: ProfileCategory, time: u64 },\n     QueryEnd { query_name: &'static str, category: ProfileCategory, time: u64 },\n-    GenericActivityStart { category: ProfileCategory, time: u64 },\n-    GenericActivityEnd { category: ProfileCategory, time: u64 },\n+    GenericActivityStart { category: ProfileCategory, label: Cow<'static, str>, time: u64 },\n+    GenericActivityEnd { category: ProfileCategory, label: Cow<'static, str>, time: u64 },\n     IncrementalLoadResultStart { query_name: &'static str, time: u64 },\n     IncrementalLoadResultEnd { query_name: &'static str, time: u64 },\n     QueryCacheHit { query_name: &'static str, category: ProfileCategory, time: u64 },\n@@ -75,17 +76,27 @@ impl SelfProfiler {\n     }\n \n     #[inline]\n-    pub fn start_activity(&mut self, category: ProfileCategory) {\n+    pub fn start_activity(\n+        &mut self,\n+        category: ProfileCategory,\n+        label: impl Into<Cow<'static, str>>,\n+    ) {\n         self.record(ProfilerEvent::GenericActivityStart {\n             category,\n+            label: label.into(),\n             time: self.get_time_from_start(),\n         })\n     }\n \n     #[inline]\n-    pub fn end_activity(&mut self, category: ProfileCategory) {\n+    pub fn end_activity(\n+        &mut self,\n+        category: ProfileCategory,\n+        label: impl Into<Cow<'static, str>>,\n+    ) {\n         self.record(ProfilerEvent::GenericActivityEnd {\n             category,\n+            label: label.into(),\n             time: self.get_time_from_start(),\n         })\n     }\n@@ -273,11 +284,12 @@ impl SelfProfiler {\n                             nanos,\n                             thread_id,\n                         ).unwrap(),\n-                    GenericActivityStart { category, time: _ } =>\n+                    GenericActivityStart { category, label, time: _ } =>\n                         write!(file,\n                             \"{{\n                                 \\\"GenericActivityStart\\\": {{\\\n                                     \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"label\\\": \\\"{}\\\",\\\n                                     \\\"time\\\": {{\\\n                                         \\\"secs\\\": {},\\\n                                         \\\"nanos\\\": {}\\\n@@ -286,15 +298,17 @@ impl SelfProfiler {\n                                 }}\\\n                             }}\",\n                             category,\n+                            label,\n                             secs,\n                             nanos,\n                             thread_id,\n                         ).unwrap(),\n-                    GenericActivityEnd { category, time: _ } =>\n+                    GenericActivityEnd { category, label, time: _ } =>\n                         write!(file,\n                             \"{{\\\n                                 \\\"GenericActivityEnd\\\": {{\\\n                                     \\\"category\\\": \\\"{:?}\\\",\\\n+                                    \\\"label\\\": \\\"{}\\\",\\\n                                     \\\"time\\\": {{\\\n                                         \\\"secs\\\": {},\\\n                                         \\\"nanos\\\": {}\\\n@@ -303,6 +317,7 @@ impl SelfProfiler {\n                                 }}\\\n                             }}\",\n                             category,\n+                            label,\n                             secs,\n                             nanos,\n                             thread_id,\n@@ -418,7 +433,7 @@ impl SelfProfiler {\n                             secs,\n                             nanos,\n                             thread_id,\n-                        ).unwrap()\n+                        ).unwrap(),\n                 }\n             }\n         }"}, {"sha": "4dd383fd234ac693861008330a89dcbc1e80662d", "filename": "src/librustc/util/time_graph.rs", "status": "removed", "additions": 0, "deletions": 268, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Flibrustc%2Futil%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ftime_graph.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,268 +0,0 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::marker::PhantomData;\n-use std::mem;\n-use std::sync::{Arc, Mutex};\n-use std::time::Instant;\n-\n-const OUTPUT_WIDTH_IN_PX: u64 = 1000;\n-const TIME_LINE_HEIGHT_IN_PX: u64 = 20;\n-const TIME_LINE_HEIGHT_STRIDE_IN_PX: usize = 30;\n-\n-#[derive(Clone)]\n-struct Timing {\n-    start: Instant,\n-    end: Instant,\n-    work_package_kind: WorkPackageKind,\n-    name: String,\n-    events: Vec<(String, Instant)>,\n-}\n-\n-#[derive(Clone, Copy, Hash, Eq, PartialEq, Debug)]\n-pub struct TimelineId(pub usize);\n-\n-#[derive(Clone)]\n-struct PerThread {\n-    timings: Vec<Timing>,\n-    open_work_package: Option<(Instant, WorkPackageKind, String)>,\n-}\n-\n-#[derive(Clone)]\n-pub struct TimeGraph {\n-    data: Arc<Mutex<FxHashMap<TimelineId, PerThread>>>,\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct WorkPackageKind(pub &'static [&'static str]);\n-\n-pub struct Timeline {\n-    token: Option<RaiiToken>,\n-}\n-\n-struct RaiiToken {\n-    graph: TimeGraph,\n-    timeline: TimelineId,\n-    events: Vec<(String, Instant)>,\n-    // The token must not be Send:\n-    _marker: PhantomData<*const ()>\n-}\n-\n-\n-impl Drop for RaiiToken {\n-    fn drop(&mut self) {\n-        self.graph.end(self.timeline, mem::replace(&mut self.events, Vec::new()));\n-    }\n-}\n-\n-impl TimeGraph {\n-    pub fn new() -> TimeGraph {\n-        TimeGraph {\n-            data: Arc::new(Mutex::new(FxHashMap::default()))\n-        }\n-    }\n-\n-    pub fn start(&self,\n-                 timeline: TimelineId,\n-                 work_package_kind: WorkPackageKind,\n-                 name: &str) -> Timeline {\n-        {\n-            let mut table = self.data.lock().unwrap();\n-\n-            let data = table.entry(timeline).or_insert(PerThread {\n-                timings: Vec::new(),\n-                open_work_package: None,\n-            });\n-\n-            assert!(data.open_work_package.is_none());\n-            data.open_work_package = Some((Instant::now(), work_package_kind, name.to_string()));\n-        }\n-\n-        Timeline {\n-            token: Some(RaiiToken {\n-                graph: self.clone(),\n-                timeline,\n-                events: Vec::new(),\n-                _marker: PhantomData,\n-            }),\n-        }\n-    }\n-\n-    fn end(&self, timeline: TimelineId, events: Vec<(String, Instant)>) {\n-        let end = Instant::now();\n-\n-        let mut table = self.data.lock().unwrap();\n-        let data = table.get_mut(&timeline).unwrap();\n-\n-        if let Some((start, work_package_kind, name)) = data.open_work_package.take() {\n-            data.timings.push(Timing {\n-                start,\n-                end,\n-                work_package_kind,\n-                name,\n-                events,\n-            });\n-        } else {\n-            bug!(\"end timing without start?\")\n-        }\n-    }\n-\n-    pub fn dump(&self, output_filename: &str) {\n-        let table = self.data.lock().unwrap();\n-\n-        for data in table.values() {\n-            assert!(data.open_work_package.is_none());\n-        }\n-\n-        let mut threads: Vec<PerThread> =\n-            table.values().map(|data| data.clone()).collect();\n-\n-        threads.sort_by_key(|timeline| timeline.timings[0].start);\n-\n-        let earliest_instant = threads[0].timings[0].start;\n-        let latest_instant = threads.iter()\n-                                       .map(|timeline| timeline.timings\n-                                                               .last()\n-                                                               .unwrap()\n-                                                               .end)\n-                                       .max()\n-                                       .unwrap();\n-        let max_distance = distance(earliest_instant, latest_instant);\n-\n-        let mut file = File::create(format!(\"{}.html\", output_filename)).unwrap();\n-\n-        writeln!(file, \"\n-            <html>\n-            <head>\n-                <style>\n-                    #threads a {{\n-                        position: absolute;\n-                        overflow: hidden;\n-                    }}\n-                    #threads {{\n-                        height: {total_height}px;\n-                        width: {width}px;\n-                    }}\n-\n-                    .timeline {{\n-                        display: none;\n-                        width: {width}px;\n-                        position: relative;\n-                    }}\n-\n-                    .timeline:target {{\n-                        display: block;\n-                    }}\n-\n-                    .event {{\n-                        position: absolute;\n-                    }}\n-                </style>\n-            </head>\n-            <body>\n-                <div id='threads'>\n-        \",\n-            total_height = threads.len() * TIME_LINE_HEIGHT_STRIDE_IN_PX,\n-            width = OUTPUT_WIDTH_IN_PX,\n-        ).unwrap();\n-\n-        let mut color = 0;\n-        for (line_index, thread) in threads.iter().enumerate() {\n-            let line_top = line_index * TIME_LINE_HEIGHT_STRIDE_IN_PX;\n-\n-            for span in &thread.timings {\n-                let start = distance(earliest_instant, span.start);\n-                let end = distance(earliest_instant, span.end);\n-\n-                let start = normalize(start, max_distance, OUTPUT_WIDTH_IN_PX);\n-                let end = normalize(end, max_distance, OUTPUT_WIDTH_IN_PX);\n-\n-                let colors = span.work_package_kind.0;\n-\n-                writeln!(file, \"<a href='#timing{}'\n-                                   style='top:{}px; \\\n-                                          left:{}px; \\\n-                                          width:{}px; \\\n-                                          height:{}px; \\\n-                                          background:{};'>{}</a>\",\n-                    color,\n-                    line_top,\n-                    start,\n-                    end - start,\n-                    TIME_LINE_HEIGHT_IN_PX,\n-                    colors[color % colors.len()],\n-                    span.name,\n-                    ).unwrap();\n-\n-                color += 1;\n-            }\n-        }\n-\n-        writeln!(file, \"\n-            </div>\n-        \").unwrap();\n-\n-        let mut idx = 0;\n-        for thread in threads.iter() {\n-            for timing in &thread.timings {\n-                let colors = timing.work_package_kind.0;\n-                let height = TIME_LINE_HEIGHT_STRIDE_IN_PX * timing.events.len();\n-                writeln!(file, \"<div class='timeline'\n-                                     id='timing{}'\n-                                     style='background:{};height:{}px;'>\",\n-                         idx,\n-                         colors[idx % colors.len()],\n-                         height).unwrap();\n-                idx += 1;\n-                let max = distance(timing.start, timing.end);\n-                for (i, &(ref event, time)) in timing.events.iter().enumerate() {\n-                    let i = i as u64;\n-                    let time = distance(timing.start, time);\n-                    let at = normalize(time, max, OUTPUT_WIDTH_IN_PX);\n-                    writeln!(file, \"<span class='event'\n-                                          style='left:{}px;\\\n-                                                 top:{}px;'>{}</span>\",\n-                             at,\n-                             TIME_LINE_HEIGHT_IN_PX * i,\n-                             event).unwrap();\n-                }\n-                writeln!(file, \"</div>\").unwrap();\n-            }\n-        }\n-\n-        writeln!(file, \"\n-            </body>\n-            </html>\n-        \").unwrap();\n-    }\n-}\n-\n-impl Timeline {\n-    pub fn noop() -> Timeline {\n-        Timeline { token: None }\n-    }\n-\n-    /// Record an event which happened at this moment on this timeline.\n-    ///\n-    /// Events are displayed in the eventual HTML output where you can click on\n-    /// a particular timeline and it'll expand to all of the events that\n-    /// happened on that timeline. This can then be used to drill into a\n-    /// particular timeline and see what events are happening and taking the\n-    /// most time.\n-    pub fn record(&mut self, name: &str) {\n-        if let Some(ref mut token) = self.token {\n-            token.events.push((name.to_string(), Instant::now()));\n-        }\n-    }\n-}\n-\n-fn distance(zero: Instant, x: Instant) -> u64 {\n-\n-    let duration = x.duration_since(zero);\n-    (duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64) // / div\n-}\n-\n-fn normalize(distance: u64, max: u64, max_pixels: u64) -> u64 {\n-    (max_pixels * distance) / max\n-}\n-"}, {"sha": "01bfe5d5af70697e5bb902df86122675247c5565", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1406,7 +1406,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.item_path_str(variant_def_id));\n+                out.push_str(&self.tcx.def_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1443,7 +1443,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.item_path_str(variant_def_id));\n+                out.push_str(&self.tcx.def_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n@@ -1523,7 +1523,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n+                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };\n@@ -1558,7 +1558,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.item_path_str(variant_def_id))\n+                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n                 } else {\n                     format!(\"{:?}\", variant_def_id)\n                 };"}, {"sha": "84c652ff238afb4914a1f96e12cc814287554eb9", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,7 +3,6 @@ use crate::back::write::{self, DiagnosticHandlers, with_llvm_pmb, save_temp_bitc\n     to_llvm_opt_settings};\n use crate::llvm::archive_ro::ArchiveRO;\n use crate::llvm::{self, True, False};\n-use crate::time_graph::Timeline;\n use crate::{ModuleLlvm, LlvmCodegenBackend};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{ModuleConfig, CodegenContext, FatLTOInput};\n@@ -16,6 +15,7 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n+use rustc::util::profiling::ProfileCategory;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n \n@@ -37,7 +37,6 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n }\n \n fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-               timeline: &mut Timeline,\n                diag_handler: &Handler)\n     -> Result<(Vec<CString>, Vec<(SerializedModule<ModuleBuffer>, CString)>), FatalError>\n {\n@@ -68,7 +67,8 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         .iter()\n         .filter_map(symbol_filter)\n         .collect::<Vec<CString>>();\n-    timeline.record(\"whitelist\");\n+    let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n+                                       \"generate_symbol_white_list_for_thinlto\");\n     info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n \n     // If we're performing LTO for the entire crate graph, then for each of our\n@@ -97,6 +97,8 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n \n         for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n+            let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n+                                               format!(\"load: {}\", path.display()));\n             let exported_symbols = cgcx.exported_symbols\n                 .as_ref().expect(\"needs exported symbols for LTO\");\n             symbol_white_list.extend(\n@@ -121,7 +123,6 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 let bc = SerializedModule::FromRlib(bc);\n                 upstream_modules.push((bc, CString::new(id).unwrap()));\n             }\n-            timeline.record(&format!(\"load: {}\", path.display()));\n         }\n     }\n \n@@ -132,12 +133,11 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n /// for further optimization.\n pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                       modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n-                      cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-                      timeline: &mut Timeline)\n+                      cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>)\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, &diag_handler)?;\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n@@ -148,7 +148,6 @@ pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         cached_modules,\n         upstream_modules,\n         &symbol_white_list,\n-        timeline,\n     )\n }\n \n@@ -157,12 +156,11 @@ pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n /// can simply be copied over from the incr. comp. cache.\n pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                        modules: Vec<(String, ThinBuffer)>,\n-                       cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-                       timeline: &mut Timeline)\n+                       cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>)\n     -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, &diag_handler)?;\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n@@ -175,8 +173,7 @@ pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n              modules,\n              upstream_modules,\n              cached_modules,\n-             &symbol_white_list,\n-             timeline)\n+             &symbol_white_list)\n }\n \n pub(crate) fn prepare_thin(\n@@ -192,8 +189,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n-           symbol_white_list: &[*const libc::c_char],\n-           timeline: &mut Timeline)\n+           symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n@@ -303,7 +299,6 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     write::llvm_err(&diag_handler, &msg)\n                 })\n             })?;\n-            timeline.record(&format!(\"link {:?}\", name));\n             serialized_bitcode.push(bc_decoded);\n         }\n         drop(linker);\n@@ -325,7 +320,6 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n             save_temp_bitcode(&cgcx, &module, \"lto.after-nounwind\");\n         }\n-        timeline.record(\"passes\");\n     }\n \n     Ok(LtoModuleCodegen::Fat {\n@@ -395,8 +389,7 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             modules: Vec<(String, ThinBuffer)>,\n             serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n             cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-            symbol_white_list: &[*const libc::c_char],\n-            timeline: &mut Timeline)\n+            symbol_white_list: &[*const libc::c_char])\n     -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n {\n     unsafe {\n@@ -422,7 +415,6 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             });\n             thin_buffers.push(buffer);\n             module_names.push(cname);\n-            timeline.record(&name);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the\n@@ -475,7 +467,6 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         })?;\n \n         info!(\"thin LTO data created\");\n-        timeline.record(\"data\");\n \n         let import_map = if cgcx.incr_comp_session_dir.is_some() {\n             ThinLTOImports::from_thin_lto_data(data)\n@@ -486,7 +477,6 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             ThinLTOImports::default()\n         };\n         info!(\"thin LTO import map loaded\");\n-        timeline.record(\"import-map-loaded\");\n \n         let data = ThinData(data);\n \n@@ -691,7 +681,6 @@ impl Drop for ThinBuffer {\n pub unsafe fn optimize_thin_module(\n     thin_module: &mut ThinModule<LlvmCodegenBackend>,\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n-    timeline: &mut Timeline\n ) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n     let tm = (cgcx.tm_factory.0)().map_err(|e| {\n@@ -738,9 +727,10 @@ pub unsafe fn optimize_thin_module(\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n+            let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n+                                               \"LLVM_remove_landing_pads\");\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n-            timeline.record(\"nounwind\");\n         }\n \n         // Up next comes the per-module local analyses that we do for Thin LTO.\n@@ -756,25 +746,21 @@ pub unsafe fn optimize_thin_module(\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n         save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n-        timeline.record(\"rename\");\n         if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n             let msg = \"failed to prepare thin LTO module\";\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n         save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n-        timeline.record(\"resolve\");\n         if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n             let msg = \"failed to prepare thin LTO module\";\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n         save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n-        timeline.record(\"internalize\");\n         if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n             let msg = \"failed to prepare thin LTO module\";\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n         save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n-        timeline.record(\"import\");\n \n         // Ok now this is a bit unfortunate. This is also something you won't\n         // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n@@ -807,7 +793,6 @@ pub unsafe fn optimize_thin_module(\n         // fixed in LLVM.\n         llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n         save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n-        timeline.record(\"patch\");\n \n         // Alright now that we've done everything related to the ThinLTO\n         // analysis it's time to run some optimizations! Here we use the same\n@@ -818,7 +803,6 @@ pub unsafe fn optimize_thin_module(\n         let config = cgcx.config(module.kind);\n         run_pass_manager(cgcx, &module, config, true);\n         save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n-        timeline.record(\"thin-done\");\n     }\n     Ok(module)\n }"}, {"sha": "dc4dd4e39e17b502da7a0213e9ef92dceb03d150", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,7 +3,6 @@ use crate::back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n use crate::back::lto::ThinBuffer;\n use crate::base;\n use crate::consts;\n-use crate::time_graph::Timeline;\n use crate::llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use crate::llvm_util;\n use crate::ModuleLlvm;\n@@ -19,6 +18,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n use rustc::util::common::time_ext;\n+use rustc::util::profiling::ProfileCategory;\n use rustc_fs_util::{path_to_c_string, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n use errors::{Handler, FatalError};\n@@ -305,8 +305,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                    diag_handler: &Handler,\n                    module: &ModuleCodegen<ModuleLlvm>,\n-                   config: &ModuleConfig,\n-                   timeline: &mut Timeline)\n+                   config: &ModuleConfig)\n     -> Result<(), FatalError>\n {\n     let llmod = module.module_llvm.llmod();\n@@ -415,19 +414,24 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         diag_handler.abort_if_errors();\n \n         // Finally, run the actual optimization passes\n-        time_ext(config.time_passes,\n-                 None,\n-                 &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n-                 || {\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n-        });\n-        timeline.record(\"fpm\");\n-        time_ext(config.time_passes,\n-                 None,\n-                 &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n-                 || {\n-            llvm::LLVMRunPassManager(mpm, llmod)\n-        });\n+        {\n+            let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_function_passes\");\n+            time_ext(config.time_passes,\n+                        None,\n+                        &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n+                        || {\n+                llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n+            });\n+        }\n+        {\n+            let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_module_passes\");\n+            time_ext(config.time_passes,\n+                    None,\n+                    &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n+                    || {\n+                llvm::LLVMRunPassManager(mpm, llmod)\n+            });\n+        }\n \n         // Deallocate managers that we're now done with\n         llvm::LLVMDisposePassManager(fpm);\n@@ -439,11 +443,10 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                   diag_handler: &Handler,\n                   module: ModuleCodegen<ModuleLlvm>,\n-                  config: &ModuleConfig,\n-                  timeline: &mut Timeline)\n+                  config: &ModuleConfig)\n     -> Result<CompiledModule, FatalError>\n {\n-    timeline.record(\"codegen\");\n+    let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"codegen\");\n     {\n         let llmod = module.module_llvm.llmod();\n         let llcx = &*module.module_llvm.llcx;\n@@ -494,29 +497,30 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n+            let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_make_bitcode\");\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n-            timeline.record(\"make-bc\");\n \n             if write_bc {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_bitcode\");\n                 if let Err(e) = fs::write(&bc_out, data) {\n                     diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n                 }\n-                timeline.record(\"write-bc\");\n             }\n \n             if config.embed_bitcode {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_embed_bitcode\");\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n-                timeline.record(\"embed-bc\");\n             }\n \n             if config.emit_bc_compressed {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n+                                                   \"LLVM_compress_bitcode\");\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n                 let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n                     diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n                 }\n-                timeline.record(\"compress-bc\");\n             }\n         } else if config.embed_bitcode_marker {\n             embed_bitcode(cgcx, llcx, llmod, None);\n@@ -525,6 +529,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_ir\");\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n                 let out = path_to_c_string(&out);\n \n@@ -563,10 +568,10 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n                     llvm::LLVMDisposePassManager(cpm);\n                 });\n-                timeline.record(\"ir\");\n             }\n \n             if config.emit_asm || asm_to_obj {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_asm\");\n                 let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n                 // We can't use the same module for asm and binary output, because that triggers\n@@ -581,19 +586,18 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     write_output_file(diag_handler, tm, cpm, llmod, &path,\n                                       llvm::FileType::AssemblyFile)\n                 })?;\n-                timeline.record(\"asm\");\n             }\n \n             if write_obj {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_obj\");\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                       llvm::FileType::ObjectFile)\n                 })?;\n-                timeline.record(\"obj\");\n             } else if asm_to_obj {\n+                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_asm_to_obj\");\n                 let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n                 run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-                timeline.record(\"asm_to_obj\");\n \n                 if !config.emit_asm && !cgcx.save_temps {\n                     drop(fs::remove_file(&assembly));"}, {"sha": "ceb08f943678b15a97aa5273effc4741dd962229", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -513,8 +513,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n             },\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-                let sty = &arg_tys[0].sty;\n-                match float_type_width(sty) {\n+                match float_type_width(arg_tys[0]) {\n                     Some(_width) =>\n                         match name {\n                             \"fadd_fast\" => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n@@ -528,7 +527,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         span_invalid_monomorphization_error(\n                             tcx.sess, span,\n                             &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\", name, sty));\n+                                      expected basic float type, found `{}`\", name, arg_tys[0]));\n                         return;\n                     }\n                 }\n@@ -1473,8 +1472,8 @@ fn generic_simd_intrinsic(\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n                                  to be a pointer to the element type `{}` of the first \\\n                                  argument `{}`, found `{}` != `*_ {}`\",\n-                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n-                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                         arg_tys[1].simd_type(tcx), arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx), in_elem);\n                 unreachable!();\n             }\n         };\n@@ -1488,7 +1487,7 @@ fn generic_simd_intrinsic(\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n-                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+                         arg_tys[2].simd_type(tcx), arg_tys[2]);\n             }\n         }\n \n@@ -1573,8 +1572,8 @@ fn generic_simd_intrinsic(\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n                                  to be a pointer to the element type `{}` of the first \\\n                                  argument `{}`, found `{}` != `*mut {}`\",\n-                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n-                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                         arg_tys[1].simd_type(tcx), arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx), in_elem);\n                 unreachable!();\n             }\n         };\n@@ -1588,7 +1587,7 @@ fn generic_simd_intrinsic(\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n-                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+                         arg_tys[2].simd_type(tcx), arg_tys[2]);\n             }\n         }\n \n@@ -1904,7 +1903,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 return_error!(\n                     \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_type(tcx).sty, arg_tys[0]\n+                    arg_tys[0].simd_type(tcx), arg_tys[0]\n                 );\n             }\n         };\n@@ -1954,10 +1953,10 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n     }\n }\n \n-// Returns the width of a float TypeVariant\n+// Returns the width of a float Ty\n // Returns None if the type is not a float\n-fn float_type_width<'tcx>(sty: &ty::TyKind<'tcx>) -> Option<u64> {\n-    match *sty {\n+fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n+    match ty.sty {\n         ty::Float(t) => Some(t.bit_width() as u64),\n         _ => None,\n     }"}, {"sha": "c75788ecb4fbd3da5de704208f12ef88e160347f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -15,7 +15,6 @@\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(nll)]\n-#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]\n@@ -53,7 +52,6 @@ use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModul\n use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n-use rustc::util::time_graph::Timeline;\n use syntax_pos::symbol::InternedString;\n use rustc::mir::mono::Stats;\n pub use llvm_util::target_features;\n@@ -66,7 +64,6 @@ use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::time_graph;\n use rustc::util::profiling::ProfileCategory;\n use rustc::util::common::ErrorReported;\n use rustc_mir::monomorphize;\n@@ -167,42 +164,37 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<FatLTOInput<Self>>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n-        timeline: &mut Timeline\n     ) -> Result<LtoModuleCodegen<Self>, FatalError> {\n-        back::lto::run_fat(cgcx, modules, cached_modules, timeline)\n+        back::lto::run_fat(cgcx, modules, cached_modules)\n     }\n     fn run_thin_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n-        timeline: &mut Timeline\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n-        back::lto::run_thin(cgcx, modules, cached_modules, timeline)\n+        back::lto::run_thin(cgcx, modules, cached_modules)\n     }\n     unsafe fn optimize(\n         cgcx: &CodegenContext<Self>,\n         diag_handler: &Handler,\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n-        timeline: &mut Timeline\n     ) -> Result<(), FatalError> {\n-        back::write::optimize(cgcx, diag_handler, module, config, timeline)\n+        back::write::optimize(cgcx, diag_handler, module, config)\n     }\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n         thin: &mut ThinModule<Self>,\n-        timeline: &mut Timeline\n     ) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n-        back::lto::optimize_thin_module(thin, cgcx, timeline)\n+        back::lto::optimize_thin_module(thin, cgcx)\n     }\n     unsafe fn codegen(\n         cgcx: &CodegenContext<Self>,\n         diag_handler: &Handler,\n         module: ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n-        timeline: &mut Timeline\n     ) -> Result<CompiledModule, FatalError> {\n-        back::write::codegen(cgcx, diag_handler, module, config, timeline)\n+        back::write::codegen(cgcx, diag_handler, module, config)\n     }\n     fn prepare_thin(\n         module: ModuleCodegen<Self::Module>\n@@ -336,12 +328,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.profiler(|p| p.start_activity(ProfileCategory::Linking));\n+        sess.profiler(|p| p.start_activity(ProfileCategory::Linking, \"link_crate\"));\n         time(sess, \"linking\", || {\n             back::link::link_binary(sess, &codegen_results,\n                                     outputs, &codegen_results.crate_name.as_str());\n         });\n-        sess.profiler(|p| p.end_activity(ProfileCategory::Linking));\n+        sess.profiler(|p| p.end_activity(ProfileCategory::Linking, \"link_crate\"));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)"}, {"sha": "e6470dbb61ce18649625555d582ede8430586b6a", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -382,29 +382,27 @@ impl<'a> Linker for GccLinker<'a> {\n \n         if self.sess.target.target.options.is_like_osx {\n             // Write a plain, newline-separated list of symbols\n-            let res = (|| -> io::Result<()> {\n+            let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n                 for sym in self.info.exports[&crate_type].iter() {\n                     debug!(\"  _{}\", sym);\n                     writeln!(f, \"_{}\", sym)?;\n                 }\n-                Ok(())\n-            })();\n+            };\n             if let Err(e) = res {\n                 self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n             }\n         } else {\n             // Write an LD version script\n-            let res = (|| -> io::Result<()> {\n+            let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n                 writeln!(f, \"{{\\n  global:\")?;\n                 for sym in self.info.exports[&crate_type].iter() {\n                     debug!(\"    {};\", sym);\n                     writeln!(f, \"    {};\", sym)?;\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n-                Ok(())\n-            })();\n+            };\n             if let Err(e) = res {\n                 self.sess.fatal(&format!(\"failed to write version script: {}\", e));\n             }\n@@ -644,7 +642,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n                       tmpdir: &Path,\n                       crate_type: CrateType) {\n         let path = tmpdir.join(\"lib.def\");\n-        let res = (|| -> io::Result<()> {\n+        let res: io::Result<()> = try {\n             let mut f = BufWriter::new(File::create(&path)?);\n \n             // Start off with the standard module name header and then go\n@@ -655,8 +653,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n                 debug!(\"  _{}\", symbol);\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n-            Ok(())\n-        })();\n+        };\n         if let Err(e) = res {\n             self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n         }"}, {"sha": "47e5d9af33ba40d2e9c39300ef30825ddbe178af", "filename": "src/librustc_codegen_ssa/back/lto.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2,7 +2,6 @@ use super::write::CodegenContext;\n use crate::traits::*;\n use crate::ModuleCodegen;\n \n-use rustc::util::time_graph::Timeline;\n use rustc_errors::FatalError;\n \n use std::sync::Arc;\n@@ -67,19 +66,17 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n     pub unsafe fn optimize(\n         &mut self,\n         cgcx: &CodegenContext<B>,\n-        timeline: &mut Timeline\n     ) -> Result<ModuleCodegen<B::Module>, FatalError> {\n         match *self {\n             LtoModuleCodegen::Fat { ref mut module, .. } => {\n                 let module = module.take().unwrap();\n                 {\n                     let config = cgcx.config(module.kind);\n                     B::run_lto_pass_manager(cgcx, &module, config, false);\n-                    timeline.record(\"fat-done\");\n                 }\n                 Ok(module)\n             }\n-            LtoModuleCodegen::Thin(ref mut thin) => B::optimize_thin(cgcx, thin, timeline),\n+            LtoModuleCodegen::Thin(ref mut thin) => B::optimize_thin(cgcx, thin),\n         }\n     }\n "}, {"sha": "859dfb99d92b8598306d5af13c6fdfef1c218ed8", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -15,11 +15,10 @@ use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitizer, Lto};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n-use rustc::util::time_graph::{self, TimeGraph, Timeline};\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n-use rustc::util::profiling::SelfProfiler;\n+use rustc::util::profiling::{ProfileCategory, SelfProfiler};\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n use rustc_errors::{Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n@@ -33,6 +32,7 @@ use jobserver::{Client, Acquired};\n use parking_lot::Mutex as PlMutex;\n \n use std::any::Any;\n+use std::borrow::Cow;\n use std::fs;\n use std::io;\n use std::mem;\n@@ -197,6 +197,40 @@ impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n     }\n }\n \n+pub struct ProfileGenericActivityTimer {\n+    profiler: Option<Arc<PlMutex<SelfProfiler>>>,\n+    category: ProfileCategory,\n+    label: Cow<'static, str>,\n+}\n+\n+impl ProfileGenericActivityTimer {\n+    pub fn start(\n+        profiler: Option<Arc<PlMutex<SelfProfiler>>>,\n+        category: ProfileCategory,\n+        label: Cow<'static, str>,\n+    ) -> ProfileGenericActivityTimer {\n+        if let Some(profiler) = &profiler {\n+            let mut p = profiler.lock();\n+            p.start_activity(category, label.clone());\n+        }\n+\n+        ProfileGenericActivityTimer {\n+            profiler,\n+            category,\n+            label,\n+        }\n+    }\n+}\n+\n+impl Drop for ProfileGenericActivityTimer {\n+    fn drop(&mut self) {\n+        if let Some(profiler) = &self.profiler {\n+            let mut p = profiler.lock();\n+            p.end_activity(self.category, self.label.clone());\n+        }\n+    }\n+}\n+\n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n pub struct CodegenContext<B: WriteBackendMethods> {\n@@ -238,9 +272,6 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub cgu_reuse_tracker: CguReuseTracker,\n     // Channel back to the main control thread to send messages to\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n-    // A reference to the TimeGraph so we can register timings. None means that\n-    // measuring is disabled.\n-    pub time_graph: Option<TimeGraph>,\n     // The assembler command if no_integrated_as option is enabled, None otherwise\n     pub assembler_cmd: Option<Arc<AssemblerCommand>>\n }\n@@ -277,6 +308,14 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n             self.profiler_active(f)\n         }\n     }\n+\n+    pub fn profile_activity(\n+        &self,\n+        category: ProfileCategory,\n+        label: impl Into<Cow<'static, str>>,\n+    ) -> ProfileGenericActivityTimer {\n+        ProfileGenericActivityTimer::start(self.profiler.clone(), category, label.into())\n+    }\n }\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n@@ -285,37 +324,36 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n-    let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n-        tg.start(CODEGEN_WORKER_TIMELINE,\n-                 CODEGEN_WORK_PACKAGE_KIND,\n-                 \"generate lto\")\n-    }).unwrap_or(Timeline::noop());\n+    cgcx.profile(|p| p.start_activity(ProfileCategory::Linking, \"codegen_run_lto\"));\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n         let lto_module = B::run_fat_lto(\n             cgcx,\n             needs_fat_lto,\n             import_only_modules,\n-            &mut timeline,\n         )\n         .unwrap_or_else(|e| e.raise());\n         (vec![lto_module], vec![])\n     } else {\n         assert!(needs_fat_lto.is_empty());\n-        B::run_thin_lto(cgcx, needs_thin_lto, import_only_modules, &mut timeline)\n+        B::run_thin_lto(cgcx, needs_thin_lto, import_only_modules)\n             .unwrap_or_else(|e| e.raise())\n     };\n \n-    lto_modules.into_iter().map(|module| {\n+    let result = lto_modules.into_iter().map(|module| {\n         let cost = module.cost();\n         (WorkItem::LTO(module), cost)\n     }).chain(copy_jobs.into_iter().map(|wp| {\n         (WorkItem::CopyPostLtoArtifacts(CachedModuleCodegen {\n             name: wp.cgu_name.clone(),\n             source: wp,\n         }), 0)\n-    })).collect()\n+    })).collect();\n+\n+    cgcx.profile(|p| p.end_activity(ProfileCategory::Linking, \"codegen_run_lto\"));\n+\n+    result\n }\n \n pub struct CompiledModules {\n@@ -345,7 +383,6 @@ fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n pub fn start_async_codegen<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'_, '_, '_>,\n-    time_graph: Option<TimeGraph>,\n     metadata: EncodedMetadata,\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n     total_cgus: usize\n@@ -469,7 +506,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n                                                   coordinator_receive,\n                                                   total_cgus,\n                                                   sess.jobserver.clone(),\n-                                                  time_graph.clone(),\n                                                   Arc::new(modules_config),\n                                                   Arc::new(metadata_config),\n                                                   Arc::new(allocator_config));\n@@ -483,7 +519,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         linker_info,\n         crate_info,\n \n-        time_graph,\n         coordinator_send: tcx.tx_to_llvm_workers.lock().clone(),\n         codegen_worker_receive,\n         shared_emitter_main,\n@@ -728,19 +763,18 @@ pub enum FatLTOInput<B: WriteBackendMethods> {\n fn execute_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     work_item: WorkItem<B>,\n-    timeline: &mut Timeline\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let module_config = cgcx.config(work_item.module_kind());\n \n     match work_item {\n         WorkItem::Optimize(module) => {\n-            execute_optimize_work_item(cgcx, module, module_config, timeline)\n+            execute_optimize_work_item(cgcx, module, module_config)\n         }\n         WorkItem::CopyPostLtoArtifacts(module) => {\n-            execute_copy_from_cache_work_item(cgcx, module, module_config, timeline)\n+            execute_copy_from_cache_work_item(cgcx, module, module_config)\n         }\n         WorkItem::LTO(module) => {\n-            execute_lto_work_item(cgcx, module, module_config, timeline)\n+            execute_lto_work_item(cgcx, module, module_config)\n         }\n     }\n }\n@@ -756,12 +790,11 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: ModuleCodegen<B::Module>,\n     module_config: &ModuleConfig,\n-    timeline: &mut Timeline\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n     unsafe {\n-        B::optimize(cgcx, &diag_handler, &module, module_config, timeline)?;\n+        B::optimize(cgcx, &diag_handler, &module, module_config)?;\n     }\n \n     // After we've done the initial round of optimizations we need to\n@@ -818,7 +851,7 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     Ok(match lto_type {\n         ComputedLtoType::No => {\n             let module = unsafe {\n-                B::codegen(cgcx, &diag_handler, module, module_config, timeline)?\n+                B::codegen(cgcx, &diag_handler, module, module_config)?\n             };\n             WorkItemResult::Compiled(module)\n         }\n@@ -854,7 +887,6 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: CachedModuleCodegen,\n     module_config: &ModuleConfig,\n-    _: &mut Timeline\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir\n                                     .as_ref()\n@@ -916,13 +948,12 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     mut module: lto::LtoModuleCodegen<B>,\n     module_config: &ModuleConfig,\n-    timeline: &mut Timeline\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n     unsafe {\n-        let module = module.optimize(cgcx, timeline)?;\n-        let module = B::codegen(cgcx, &diag_handler, module, module_config, timeline)?;\n+        let module = module.optimize(cgcx)?;\n+        let module = B::codegen(cgcx, &diag_handler, module, module_config)?;\n         Ok(WorkItemResult::Compiled(module))\n     }\n }\n@@ -977,7 +1008,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n     total_cgus: usize,\n     jobserver: Client,\n-    time_graph: Option<TimeGraph>,\n     modules_config: Arc<ModuleConfig>,\n     metadata_config: Arc<ModuleConfig>,\n     allocator_config: Arc<ModuleConfig>\n@@ -1065,7 +1095,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         cgu_reuse_tracker: sess.cgu_reuse_tracker.clone(),\n         coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n-        time_graph,\n         output_filenames: tcx.output_filenames(LOCAL_CRATE),\n         regular_module_config: modules_config,\n         metadata_module_config: metadata_config,\n@@ -1570,12 +1599,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n }\n \n pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n-pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n-    time_graph::TimelineId(CODEGEN_WORKER_ID);\n-pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n-    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n-const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n-    time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n \n fn spawn_work<B: ExtraBackendMethods>(\n     cgcx: CodegenContext<B>,\n@@ -1625,13 +1648,12 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let timeline = cgcx.time_graph.as_ref().map(|tg| {\n-                tg.start(time_graph::TimelineId(cgcx.worker),\n-                         LLVM_WORK_PACKAGE_KIND,\n-                         &work.name())\n-            });\n-            let mut timeline = timeline.unwrap_or(Timeline::noop());\n-            execute_work_item(&cgcx, work, &mut timeline).ok()\n+            let label = work.name();\n+            cgcx.profile(|p| p.start_activity(ProfileCategory::Codegen, label.clone()));\n+            let result = execute_work_item(&cgcx, work).ok();\n+            cgcx.profile(|p| p.end_activity(ProfileCategory::Codegen, label));\n+\n+            result\n         };\n     });\n }\n@@ -1785,7 +1807,6 @@ pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub windows_subsystem: Option<String>,\n     pub linker_info: LinkerInfo,\n     pub crate_info: CrateInfo,\n-    pub time_graph: Option<TimeGraph>,\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n     pub codegen_worker_receive: Receiver<Message<B>>,\n     pub shared_emitter_main: SharedEmitterMain,\n@@ -1814,10 +1835,6 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         sess.abort_if_errors();\n \n-        if let Some(time_graph) = self.time_graph {\n-            time_graph.dump(&format!(\"{}-timings\", self.crate_name));\n-        }\n-\n         let work_products =\n             copy_all_cgu_workproducts_to_incr_comp_cache_dir(sess,\n                                                              &compiled_modules);"}, {"sha": "48743be3a2551375d48fe74ae674c6306265a949", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -29,7 +29,6 @@ use rustc::util::profiling::ProfileCategory;\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n-use rustc::util::time_graph;\n use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc::util::nodemap::FxHashMap;\n@@ -528,11 +527,6 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n }\n \n pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n-pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n-    time_graph::TimelineId(CODEGEN_WORKER_ID);\n-pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n-    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n-\n \n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n@@ -545,7 +539,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n \n     // Codegen the metadata.\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen, \"codegen crate metadata\"));\n \n     let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n                                                             &[\"crate\"],\n@@ -555,27 +549,20 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     let metadata = time(tcx.sess, \"write metadata\", || {\n         backend.write_metadata(tcx, &mut metadata_llvm_module)\n     });\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen, \"codegen crate metadata\"));\n \n     let metadata_module = ModuleCodegen {\n         name: metadata_cgu_name,\n         module_llvm: metadata_llvm_module,\n         kind: ModuleKind::Metadata,\n     };\n \n-    let time_graph = if tcx.sess.opts.debugging_opts.codegen_time_graph {\n-        Some(time_graph::TimeGraph::new())\n-    } else {\n-        None\n-    };\n-\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen ||\n        !tcx.sess.opts.output_types.should_codegen() {\n         let ongoing_codegen = start_async_codegen(\n             backend,\n             tcx,\n-            time_graph,\n             metadata,\n             rx,\n             1);\n@@ -609,7 +596,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     let ongoing_codegen = start_async_codegen(\n         backend.clone(),\n         tcx,\n-        time_graph.clone(),\n         metadata,\n         rx,\n         codegen_units.len());\n@@ -676,15 +662,14 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let _timing_guard = time_graph.as_ref().map(|time_graph| {\n-                    time_graph.start(CODEGEN_WORKER_TIMELINE,\n-                                     CODEGEN_WORK_PACKAGE_KIND,\n-                                     &format!(\"codegen {}\", cgu.name()))\n-                });\n+                tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen,\n+                                                       format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n                 let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n                 all_stats.extend(stats);\n                 total_codegen_time += start_time.elapsed();\n+                tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen,\n+                                                     format!(\"codegen {}\", cgu.name())));\n                 false\n             }\n             CguReuse::PreLto => {"}, {"sha": "fe9b88c85f009fc5507ef57390d94284287a9e8a", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -7,6 +7,7 @@\n #![feature(libc)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(stmt_expr_attributes)]\n+#![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![allow(unused_attributes)]"}, {"sha": "2bb68dc687ca9c849661450dabc8eb91eba5e215", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n                     ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n-                    ref other => bug!(\"invalid simd shuffle type: {}\", other),\n+                    _ => bug!(\"invalid simd shuffle type: {}\", c.ty),\n                 };\n                 let values: Vec<_> = (0..fields).map(|field| {\n                     let field = const_field("}, {"sha": "fe00276a55a45f25ae7064ea417f45f7cc7d071b", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -148,7 +148,7 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         match tail.sty {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n-            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+            _ => bug!(\"unexpected unsized tail: {:?}\", tail),\n         }\n     }\n }"}, {"sha": "23bb7179557b910540b148dbaad92e497fa6af21", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,7 +3,6 @@ use crate::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n use crate::{CompiledModule, ModuleCodegen};\n \n use rustc::dep_graph::WorkProduct;\n-use rustc::util::time_graph::Timeline;\n use rustc_errors::{FatalError, Handler};\n \n pub trait WriteBackendMethods: 'static + Sized + Clone {\n@@ -20,7 +19,6 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<FatLTOInput<Self>>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n-        timeline: &mut Timeline,\n     ) -> Result<LtoModuleCodegen<Self>, FatalError>;\n     /// Performs thin LTO by performing necessary global analysis and returning two\n     /// lists, one of the modules that need optimization and another for modules that\n@@ -29,27 +27,23 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n-        timeline: &mut Timeline,\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError>;\n     fn print_pass_timings(&self);\n     unsafe fn optimize(\n         cgcx: &CodegenContext<Self>,\n         diag_handler: &Handler,\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n-        timeline: &mut Timeline,\n     ) -> Result<(), FatalError>;\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n         thin: &mut ThinModule<Self>,\n-        timeline: &mut Timeline,\n     ) -> Result<ModuleCodegen<Self::Module>, FatalError>;\n     unsafe fn codegen(\n         cgcx: &CodegenContext<Self>,\n         diag_handler: &Handler,\n         module: ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n-        timeline: &mut Timeline,\n     ) -> Result<CompiledModule, FatalError>;\n     fn prepare_thin(\n         module: ModuleCodegen<Self::Module>"}, {"sha": "466cf40a15795b85bb4376764bf0cc69031b3a3a", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -4,6 +4,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(custom_attribute)]"}, {"sha": "0fa935199f97b412e2d9125121b73e6c1d39495f", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 277, "deletions": 87, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -87,14 +87,14 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::map::definitions::DefPathData;\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::print::{PrettyPrinter, Printer, Print};\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::SubstsRef;\n+use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::record_time;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -105,8 +105,8 @@ use syntax_pos::symbol::Symbol;\n \n use log::debug;\n \n-use std::fmt::Write;\n-use std::mem::discriminant;\n+use std::fmt::{self, Write};\n+use std::mem::{self, discriminant};\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n@@ -223,11 +223,11 @@ fn get_symbol_hash<'a, 'tcx>(\n }\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    let mut buffer = SymbolPathBuffer::new(tcx);\n-    item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id, false);\n-    });\n-    buffer.into_interned()\n+    SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::new(),\n+        keep_within_component: false,\n+    }.print_def_path(def_id, &[]).unwrap().path.into_interned()\n }\n \n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n@@ -319,13 +319,17 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n \n-    let mut buf = SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id), tcx);\n+    let mut printer = SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::from_interned(tcx.def_symbol_name(def_id)),\n+        keep_within_component: false,\n+    };\n \n     if instance.is_vtable_shim() {\n-        buf.push(\"{{vtable-shim}}\");\n+        let _ = printer.write_str(\"{{vtable-shim}}\");\n     }\n \n-    buf.finish(hash)\n+    printer.path.finish(hash)\n }\n \n // Follow C++ namespace-mangling style, see\n@@ -342,126 +346,312 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n // To be able to work on all platforms and get *some* reasonable output, we\n // use C++ name-mangling.\n #[derive(Debug)]\n-struct SymbolPathBuffer {\n+struct SymbolPath {\n     result: String,\n     temp_buf: String,\n-    strict_naming: bool,\n }\n \n-impl SymbolPathBuffer {\n-    fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n-        let mut result = SymbolPathBuffer {\n+impl SymbolPath {\n+    fn new() -> Self {\n+        let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            strict_naming: tcx.has_strict_asm_symbol_naming(),\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n     }\n \n-    fn from_interned(symbol: ty::SymbolName, tcx: TyCtxt<'_, '_, '_>) -> Self {\n-        let mut result = SymbolPathBuffer {\n+    fn from_interned(symbol: ty::SymbolName) -> Self {\n+        let mut result = SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            strict_naming: tcx.has_strict_asm_symbol_naming(),\n         };\n         result.result.push_str(&symbol.as_str());\n         result\n     }\n \n-    fn into_interned(self) -> ty::SymbolName {\n+    fn into_interned(mut self) -> ty::SymbolName {\n+        self.finalize_pending_component();\n         ty::SymbolName {\n             name: Symbol::intern(&self.result).as_interned_str(),\n         }\n     }\n \n+    fn finalize_pending_component(&mut self) {\n+        if !self.temp_buf.is_empty() {\n+            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n+            self.temp_buf.clear();\n+        }\n+    }\n+\n     fn finish(mut self, hash: u64) -> String {\n+        self.finalize_pending_component();\n         // E = end name-sequence\n         let _ = write!(self.result, \"17h{:016x}E\", hash);\n         self.result\n     }\n+}\n+\n+struct SymbolPrinter<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    path: SymbolPath,\n+\n+    // When `true`, `finalize_pending_component` isn't used.\n+    // This is needed when recursing into `path_qualified`,\n+    // or `path_generic_args`, as any nested paths are\n+    // logically within one component.\n+    keep_within_component: bool,\n+}\n \n-    // Name sanitation. LLVM will happily accept identifiers with weird names, but\n-    // gas doesn't!\n-    // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-    // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-    // are replaced with '$' there.\n-    fn sanitize_and_append(&mut self, s: &str) {\n-        self.temp_buf.clear();\n+// HACK(eddyb) this relies on using the `fmt` interface to get\n+// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n+// symbol names should have their own printing machinery.\n+\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_region(\n+        self,\n+        _region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        Ok(self)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        match ty.sty {\n+            // Print all nominal types as paths (unlike `pretty_print_type`).\n+            ty::FnDef(def_id, substs) |\n+            ty::Opaque(def_id, substs) |\n+            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self.print_def_path(def_id, substs)\n+            }\n+            _ => self.pretty_print_type(ty),\n+        }\n+    }\n+\n+    fn print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        let mut first = false;\n+        for p in predicates {\n+            if !first {\n+                write!(self, \"+\")?;\n+            }\n+            first = false;\n+            self = p.print(self)?;\n+        }\n+        Ok(self)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        // Similar to `pretty_path_qualified`, but for the other\n+        // types that are printed as paths (see `print_type` above).\n+        match self_ty.sty {\n+            ty::FnDef(..) |\n+            ty::Opaque(..) |\n+            ty::Projection(_) |\n+            ty::UnnormalizedProjection(_) |\n+            ty::Closure(..) |\n+            ty::Generator(..)\n+                if trait_ref.is_none() =>\n+            {\n+                self.print_type(self_ty)\n+            }\n+\n+            _ => self.pretty_path_qualified(self_ty, trait_ref)\n+        }\n+    }\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_append_impl(\n+            |mut cx| {\n+                cx = print_prefix(cx)?;\n+\n+                if cx.keep_within_component {\n+                    // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+                    cx.write_str(\"::\")?;\n+                } else {\n+                    cx.path.finalize_pending_component();\n+                }\n+\n+                Ok(cx)\n+            },\n+            self_ty,\n+            trait_ref,\n+        )\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        match disambiguated_data.data {\n+            DefPathData::StructCtor => return Ok(self),\n+            _ => {}\n+        }\n+\n+        if self.keep_within_component {\n+            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+            self.write_str(\"::\")?;\n+        } else {\n+            self.path.finalize_pending_component();\n+        }\n+\n+        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    )  -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => false,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    fn region_should_not_be_omitted(\n+        &self,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n+    }\n+    fn comma_sep<T>(\n+        mut self,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = first.print(self)?;\n+            for elem in elems {\n+                self.write_str(\",\")?;\n+                self = elem.print(self)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let kept_within_component =\n+            mem::replace(&mut self.keep_within_component, true);\n+        self = f(self)?;\n+        self.keep_within_component = kept_within_component;\n+\n+        write!(self, \">\")?;\n+\n+        Ok(self)\n+    }\n+}\n+\n+impl fmt::Write for SymbolPrinter<'_, '_> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n+        // gas doesn't!\n+        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+        // are replaced with '$' there.\n \n         for c in s.chars() {\n+            if self.path.temp_buf.is_empty() {\n+                match c {\n+                    'a'..='z' | 'A'..='Z' | '_' => {}\n+                    _ => {\n+                        // Underscore-qualify anything that didn't start as an ident.\n+                        self.path.temp_buf.push('_');\n+                    }\n+                }\n+            }\n             match c {\n                 // Escape these with $ sequences\n-                '@' => self.temp_buf.push_str(\"$SP$\"),\n-                '*' => self.temp_buf.push_str(\"$BP$\"),\n-                '&' => self.temp_buf.push_str(\"$RF$\"),\n-                '<' => self.temp_buf.push_str(\"$LT$\"),\n-                '>' => self.temp_buf.push_str(\"$GT$\"),\n-                '(' => self.temp_buf.push_str(\"$LP$\"),\n-                ')' => self.temp_buf.push_str(\"$RP$\"),\n-                ',' => self.temp_buf.push_str(\"$C$\"),\n-\n-                '-' | ':' => if self.strict_naming {\n+                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.path.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n                     // NVPTX doesn't support these characters in symbol names.\n-                    self.temp_buf.push('$')\n-                }\n-                else {\n-                    // '.' doesn't occur in types and functions, so reuse it\n-                    // for ':' and '-'\n-                    self.temp_buf.push('.')\n-                },\n-\n-                '.' => if self.strict_naming {\n-                    self.temp_buf.push('$')\n+                    self.path.temp_buf.push('$')\n                 }\n-                else {\n-                    self.temp_buf.push('.')\n-                },\n+\n+                // '.' doesn't occur in types and functions, so reuse it\n+                // for ':' and '-'\n+                '-' | ':' => self.path.temp_buf.push('.'),\n \n                 // These are legal symbols\n-                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '$' => self.temp_buf.push(c),\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n \n                 _ => {\n-                    self.temp_buf.push('$');\n+                    self.path.temp_buf.push('$');\n                     for c in c.escape_unicode().skip(1) {\n                         match c {\n                             '{' => {}\n-                            '}' => self.temp_buf.push('$'),\n-                            c => self.temp_buf.push(c),\n+                            '}' => self.path.temp_buf.push('$'),\n+                            c => self.path.temp_buf.push(c),\n                         }\n                     }\n                 }\n             }\n         }\n \n-        let need_underscore = {\n-            // Underscore-qualify anything that didn't start as an ident.\n-            !self.temp_buf.is_empty()\n-                && self.temp_buf.as_bytes()[0] != '_' as u8\n-                && !(self.temp_buf.as_bytes()[0] as char).is_xid_start()\n-        };\n-\n-        let _ = write!(\n-            self.result,\n-            \"{}\",\n-            self.temp_buf.len() + (need_underscore as usize)\n-        );\n-\n-        if need_underscore {\n-            self.result.push('_');\n-        }\n-\n-        self.result.push_str(&self.temp_buf);\n-    }\n-}\n-\n-impl ItemPathBuffer for SymbolPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n-        ABSOLUTE\n-    }\n-\n-    fn push(&mut self, text: &str) {\n-        self.sanitize_and_append(text);\n+        Ok(())\n     }\n }"}, {"sha": "6a2b6f1321b88a9420fed6add0f5e1965b7686d1", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,7 +1,7 @@\n //! Walks the crate looking for items/impl-items/trait-items that have\n-//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! either a `rustc_symbol_name` or `rustc_def_path` attribute and\n //! generates an error giving, respectively, the symbol name or\n-//! item-path. This is used for unit testing the code that generates\n+//! def-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n use rustc::hir;\n@@ -10,7 +10,7 @@ use rustc::ty::TyCtxt;\n use rustc_mir::monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n-const ITEM_PATH: &'static str = \"rustc_item_path\";\n+const DEF_PATH: &'static str = \"rustc_def_path\";\n \n pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n@@ -41,9 +41,9 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n                 let instance = Instance::mono(tcx, def_id);\n                 let name = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n-            } else if attr.check_name(ITEM_PATH) {\n-                let path = tcx.item_path_str(def_id);\n-                tcx.sess.span_err(attr.span, &format!(\"item-path({})\", path));\n+            } else if attr.check_name(DEF_PATH) {\n+                let path = tcx.def_path_str(def_id);\n+                tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }\n \n             // (*) The formatting of `tag({})` is chosen so that tests can elect"}, {"sha": "dde88a212408deee9f443ca006401849f905f1d0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -471,7 +471,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n-        Some(self.tcx.node_path_str(id))\n+        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id)))\n     }\n }\n "}, {"sha": "6b4b437930d2609b642b4bc20036a0b059c71d29", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2,7 +2,6 @@\n \n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n-#![feature(range_contains)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]"}, {"sha": "9fe9a60b9aaa97885d12779d62c1019b23347d49", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -206,7 +206,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.sess.span_err(\n                     target_span,\n                     &format!(\"no path from `{}` to `{}`\",\n-                             tcx.item_path_str(source_def_id),\n+                             tcx.def_path_str(source_def_id),\n                              target_pass));\n             } else {\n                 tcx.sess.span_err("}, {"sha": "633e61a0034ab075c7a179edbb11143ccc2db429", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -463,7 +463,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n             format!(\"{:?}({})\",\n                     dep_node.kind,\n-                    self.tcx.item_path_str(def_id))\n+                    self.tcx.def_path_str(def_id))\n         } else {\n             format!(\"{:?}({:?})\", dep_node.kind, dep_node.hash)\n         }"}, {"sha": "0c710fd283be83fd37608a1190d770c7c89f49d3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -67,15 +67,15 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n         .set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n     hygiene::set_default_edition(sess.edition());\n \n-    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing));\n+    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing, \"parsing\"));\n     let krate = time(sess, \"parsing\", || match *input {\n         Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n         Input::Str {\n             ref input,\n             ref name,\n         } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n     })?;\n-    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing));\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing, \"parsing\"));\n \n     sess.diagnostic().set_continue_after_error(true);\n \n@@ -243,6 +243,7 @@ pub fn register_plugins<'a>(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n+        &sess.opts.debugging_opts.allow_features,\n     );\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n@@ -374,7 +375,7 @@ fn configure_and_expand_inner<'a>(\n     syntax_ext::register_builtins(&mut resolver, plugin_info.syntax_exts);\n \n     // Expand all macros\n-    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion));\n+    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion, \"macro expansion\"));\n     krate = time(sess, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -449,7 +450,7 @@ fn configure_and_expand_inner<'a>(\n         }\n         krate\n     });\n-    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion));\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion, \"macro expansion\"));\n \n     time(sess, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(\n@@ -1018,9 +1019,9 @@ pub fn start_codegen<'tcx>(\n         ::rustc::middle::dependency_format::calculate(tcx)\n     });\n \n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen, \"codegen crate\"));\n     let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen, \"codegen crate\"));\n \n     if log_enabled!(::log::Level::Info) {\n         println!(\"Post-codegen\");"}, {"sha": "7d61547527f76d6f8953652963b6720c311b8237", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(\"must_use\") {\n                     let msg = format!(\"unused {}`{}`{} that must be used\",\n-                        descr_pre_path, cx.tcx.item_path_str(def_id), descr_post_path);\n+                        descr_pre_path, cx.tcx.def_path_str(def_id), descr_post_path);\n                     let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n                     // check for #[must_use = \"...\"]\n                     if let Some(note) = attr.value_str() {"}, {"sha": "861346473245729c3ad44b1b800b56de8d4edc99", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -3,6 +3,7 @@ use crate::borrow_check::nll::region_infer::{RegionName, RegionNameSource};\n use crate::borrow_check::prefixes::IsPrefixOf;\n use crate::borrow_check::WriteKind;\n use rustc::hir;\n+use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n@@ -12,7 +13,7 @@ use rustc::mir::{\n     TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n-use rustc::util::ppaux::RegionHighlightMode;\n+use rustc::ty::print::Print;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n@@ -831,7 +832,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n-            let region_name = annotation.emit(&mut err);\n+            let region_name = annotation.emit(self, &mut err);\n \n             err.span_label(\n                 borrow_span,\n@@ -1799,7 +1800,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // (https://github.com/rust-lang/rfcs/pull/1546)\n                     bug!(\n                         \"End-user description not implemented for field access on `{:?}`\",\n-                        ty.sty\n+                        ty\n                     );\n                 }\n             }\n@@ -1875,7 +1876,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn annotate_argument_and_return_for_borrow(\n         &self,\n         borrow: &BorrowData<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n             let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n@@ -2099,7 +2100,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         did: DefId,\n         sig: ty::PolyFnSig<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n         let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n@@ -2245,29 +2246,33 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// Annotate the provided diagnostic with information about borrow from the fn signature that\n     /// helps explain.\n-    fn emit(&self, diag: &mut DiagnosticBuilder<'_>) -> String {\n+    fn emit(\n+        &self,\n+        cx: &mut MirBorrowckCtxt<'_, '_, 'tcx>,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> String {\n         match self {\n             AnnotatedBorrowFnSignature::Closure {\n                 argument_ty,\n                 argument_span,\n             } => {\n                 diag.span_label(\n                     *argument_span,\n-                    format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n+                    format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n                 );\n \n-                self.get_region_name_for_ty(argument_ty, 0)\n+                cx.get_region_name_for_ty(argument_ty, 0)\n             }\n             AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n-                let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n+                let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n                 diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n-                let return_ty_name = self.get_name_for_ty(return_ty, 0);\n+                let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n                 diag.span_label(\n                     *return_span,\n@@ -2286,15 +2291,15 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                      lifetime-syntax.html#lifetime-elision>\",\n                 );\n \n-                self.get_region_name_for_ty(return_ty, 0)\n+                cx.get_region_name_for_ty(return_ty, 0)\n             }\n             AnnotatedBorrowFnSignature::NamedFunction {\n                 arguments,\n                 return_ty,\n                 return_span,\n             } => {\n                 // Region of return type and arguments checked to be the same earlier.\n-                let region_name = self.get_region_name_for_ty(return_ty, 0);\n+                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n                 for (_, argument_span) in arguments {\n                     diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }\n@@ -2314,10 +2319,15 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             }\n         }\n     }\n+}\n \n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n     /// name where required.\n     fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n+\n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n@@ -2327,28 +2337,37 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n-            ) => RegionHighlightMode::highlighting_bound_region(*br, counter, || ty.to_string()),\n-            _ => ty.to_string(),\n+            ) => printer.region_highlight_mode.highlighting_bound_region(*br, counter),\n+            _ => {}\n         }\n+\n+        let _ = ty.print(printer);\n+        s\n     }\n \n     /// Returns the name of the provided `Ty` (that must be a reference)'s region with a\n     /// synthesized lifetime name where required.\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n-        match ty.sty {\n-            ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br)\n-                | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                    RegionHighlightMode::highlighting_bound_region(\n-                        *br,\n-                        counter,\n-                        || region.to_string(),\n-                    )\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n+\n+        let region = match ty.sty {\n+            ty::TyKind::Ref(region, _, _) => {\n+                match region {\n+                    ty::RegionKind::ReLateBound(_, br)\n+                    | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n+                        printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n+                    }\n+                    _ => {}\n                 }\n-                _ => region.to_string(),\n-            },\n+\n+                region\n+            }\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n-        }\n+        };\n+\n+        let _ = region.print(printer);\n+        s\n     }\n }\n "}, {"sha": "c4e371d5afedb58e45d0b5864c71f5b656cb4447", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -68,7 +68,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n-    debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n+    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n     let mut return_early;\n "}, {"sha": "dfa5af444d37ec76be09ddd0b2dd3ea3f5f42b65", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -93,7 +93,7 @@ impl BorrowExplanation {\n                     // simplify output by reporting just the ADT name.\n                     ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => (\n                         \"`Drop` code\",\n-                        format!(\"type `{}`\", tcx.item_path_str(adt.did)),\n+                        format!(\"type `{}`\", tcx.def_path_str(adt.did)),\n                     ),\n \n                     // Otherwise, just report the whole type (and use"}, {"sha": "362214d3257123d5b54de71737686a0f60fd5160", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -8,7 +8,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n-use rustc::util::ppaux::RegionHighlightMode;\n+use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::Name;\n use syntax::symbol::keywords;\n@@ -396,9 +396,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let type_name = RegionHighlightMode::highlighting_region_vid(needle_fr, *counter, || {\n-            infcx.extract_type_name(&argument_ty)\n-        });\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(needle_fr, *counter);\n+        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight));\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -680,9 +680,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        let type_name = RegionHighlightMode::highlighting_region_vid(\n-            fr, *counter, || infcx.extract_type_name(&return_ty),\n-        );\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(fr, *counter);\n+        let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n \n         let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n "}, {"sha": "77978d7d38ff79b14fc22ffe355e99653638a43f", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -114,14 +114,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }\n                     ty::Int(ity) => {\n-                        // FIXME(49937): refactor these bit manipulations into interpret.\n                         let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n                         let max = truncate(u128::max_value(), size);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n-                        // FIXME(49937): refactor these bit manipulations into interpret.\n                         let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n                         let max = truncate(u128::max_value(), size);\n                         (Some((0, max, size)), 0)"}, {"sha": "4aa463b37ab779f74e02fe432dc44ac89f0db4be", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -82,7 +82,6 @@ use crate::hair::LintLevel;\n use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::mir::*;\n use syntax_pos::{Span};\n use rustc_data_structures::fx::FxHashMap;\n@@ -309,16 +308,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_scope = self.source_scope;\n         let tcx = self.hir.tcx();\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n-            let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n-                let sets = tcx.lint_levels(LOCAL_CRATE);\n-                let parent_hir_id = self.source_scope_local_data[source_scope].lint_root;\n-                sets.lint_level_set(parent_hir_id) == sets.lint_level_set(current_hir_id)\n-            });\n-\n-            if !same_lint_scopes {\n-                self.source_scope =\n-                    self.new_source_scope(region_scope.1.span, lint_level,\n-                                          None);\n+            // Use `maybe_lint_level_root_bounded` with `root_lint_level` as a bound\n+            // to avoid adding Hir dependences on our parents.\n+            // We estimate the true lint roots here to avoid creating a lot of source scopes.\n+\n+            let parent_root = tcx.maybe_lint_level_root_bounded(\n+                self.source_scope_local_data[source_scope].lint_root,\n+                self.hir.root_lint_level,\n+            );\n+            let current_root = tcx.maybe_lint_level_root_bounded(\n+                current_hir_id,\n+                self.hir.root_lint_level\n+            );\n+\n+            if parent_root != current_root {\n+                self.source_scope = self.new_source_scope(\n+                    region_scope.1.span,\n+                    LintLevel::Explicit(current_root),\n+                    None\n+                );\n             }\n         }\n         self.push_scope(region_scope);"}, {"sha": "71d9398c686b7ac3818385db02bd9965a8b45fa3", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -65,12 +65,12 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n fn mplace_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     mplace: MPlaceTy<'tcx>,\n-) -> EvalResult<'tcx, ty::Const<'tcx>> {\n+) -> ty::Const<'tcx> {\n     let MemPlace { ptr, align, meta } = *mplace;\n     // extract alloc-offset pair\n     assert!(meta.is_none());\n-    let ptr = ptr.to_ptr()?;\n-    let alloc = ecx.memory.get(ptr.alloc_id)?;\n+    let ptr = ptr.to_ptr().unwrap();\n+    let alloc = ecx.memory.get(ptr.alloc_id).unwrap();\n     assert!(alloc.align >= align);\n     assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n     let mut alloc = alloc.clone();\n@@ -79,16 +79,16 @@ fn mplace_to_const<'tcx>(\n     // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n     let alloc = ecx.tcx.intern_const_alloc(alloc);\n     let val = ConstValue::ByRef(ptr, alloc);\n-    Ok(ty::Const { val, ty: mplace.layout.ty })\n+    ty::Const { val, ty: mplace.layout.ty }\n }\n \n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n-) -> EvalResult<'tcx, ty::Const<'tcx>> {\n-    // We do not normalize just any data.  Only scalar layout and slices.\n+) -> ty::Const<'tcx> {\n+    // We do not normalize just any data.  Only non-union scalars and slices.\n     let normalize = match op.layout.abi {\n-        layout::Abi::Scalar(..) => true,\n+        layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n         layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n         _ => false,\n     };\n@@ -100,11 +100,11 @@ fn op_to_const<'tcx>(\n     let val = match normalized_op {\n         Ok(mplace) => return mplace_to_const(ecx, mplace),\n         Err(Immediate::Scalar(x)) =>\n-            ConstValue::Scalar(x.not_undef()?),\n+            ConstValue::Scalar(x.not_undef().unwrap()),\n         Err(Immediate::ScalarPair(a, b)) =>\n-            ConstValue::Slice(a.not_undef()?, b.to_usize(ecx)?),\n+            ConstValue::Slice(a.not_undef().unwrap(), b.to_usize(ecx).unwrap()),\n     };\n-    Ok(ty::Const { val, ty: op.layout.ty })\n+    ty::Const { val, ty: op.layout.ty }\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n@@ -142,7 +142,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n \n-    let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n     trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n     assert!(mir.arg_count == 0);\n@@ -488,7 +488,7 @@ pub fn const_field<'a, 'tcx>(\n     let field = ecx.operand_field(down, field.index() as u64).unwrap();\n     // and finally move back to the const world, always normalizing because\n     // this is not called for statics.\n-    op_to_const(&ecx, field).unwrap()\n+    op_to_const(&ecx, field)\n }\n \n // this function uses `unwrap` copiously, because an already validated constant must have valid\n@@ -534,9 +534,9 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n         // Now that we validated, turn this into a proper constant.\n         let def_id = cid.instance.def.def_id();\n         if tcx.is_static(def_id).is_some() || cid.promoted.is_some() {\n-            mplace_to_const(&ecx, mplace)\n+            Ok(mplace_to_const(&ecx, mplace))\n         } else {\n-            op_to_const(&ecx, mplace.into())\n+            Ok(op_to_const(&ecx, mplace.into()))\n         }\n     })();\n \n@@ -602,14 +602,15 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n             other => return other,\n         }\n     }\n-    // the first trace is for replicating an ice\n-    // There's no tracking issue, but the next two lines concatenated link to the discussion on\n-    // zulip. It's not really possible to test this, because it doesn't show up in diagnostics\n-    // or MIR.\n-    // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n-    // subject/anon_const_instance_printing/near/135980032\n-    trace!(\"const eval: {}\", key.value.instance);\n-    trace!(\"const eval: {:?}\", key);\n+    if cfg!(debug_assertions) {\n+        // Make sure we format the instance even if we do not print it.\n+        // This serves as a regression test against an ICE on printing.\n+        // The next two lines concatenated contain some discussion:\n+        // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n+        // subject/anon_const_instance_printing/near/135980032\n+        let instance = key.value.instance.to_string();\n+        trace!(\"const eval: {:?} ({})\", key, instance);\n+    }\n \n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();"}, {"sha": "17fab6c5ddcff02e9272b605a8b308510304517e", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -103,7 +103,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         },\n                         pattern,\n                         initializer: local.init.to_ref(),\n-                        lint_level: cx.lint_level_of(local.hir_id),\n+                        lint_level: LintLevel::Explicit(local.hir_id),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n                     span: stmt_span,"}, {"sha": "c8c6d73d4536a4267b2537f990a55c867ec248d3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n                 value: expr.to_ref(),\n-                lint_level: cx.lint_level_of(self.hir_id),\n+                lint_level: LintLevel::Explicit(self.hir_id),\n             },\n         };\n \n@@ -955,7 +955,8 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n-            match cx.tables().node_type(expr.hir_id).sty {\n+            let ty = cx.tables().node_type(expr.hir_id);\n+            match ty.sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::Adt(adt_def, substs) => {\n@@ -968,7 +969,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         base: None,\n                     }\n                 }\n-                ref sty => bug!(\"unexpected sty: {:?}\", sty),\n+                _ => bug!(\"unexpected ty: {:?}\", ty),\n             }\n         }\n "}, {"sha": "c0f3989b4ba9735c4e2bbcc9cf0ea3e9daf083f8", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -6,7 +6,7 @@ use crate::hair::*;\n use crate::hair::util::UserAnnotatedTyHelpers;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::Node;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n@@ -76,11 +76,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        let lint_level = lint_level_for_hir_id(tcx, src_id);\n         Cx {\n             tcx,\n             infcx,\n-            root_lint_level: lint_level,\n+            root_lint_level: src_id,\n             param_env: tcx.param_env(src_def_id),\n             identity_substs: InternalSubsts::identity_for_item(tcx.global_tcx(), src_def_id),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n@@ -197,18 +196,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n-    fn lint_level_of(&self, hir_id: hir::HirId) -> LintLevel {\n-        let has_lint_level = self.tcx.dep_graph.with_ignore(|| {\n-            self.tcx.lint_levels(LOCAL_CRATE).lint_level_set(hir_id).is_some()\n-        });\n-\n-        if has_lint_level {\n-            LintLevel::Explicit(hir_id)\n-        } else {\n-            LintLevel::Inherited\n-        }\n-    }\n-\n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n@@ -236,30 +223,6 @@ impl UserAnnotatedTyHelpers<'gcx, 'tcx> for Cx<'_, 'gcx, 'tcx> {\n     }\n }\n \n-fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: hir::HirId) -> hir::HirId {\n-    // Right now we insert a `with_ignore` node in the dep graph here to\n-    // ignore the fact that `lint_levels` below depends on the entire crate.\n-    // For now this'll prevent false positives of recompiling too much when\n-    // anything changes.\n-    //\n-    // Once red/green incremental compilation lands we should be able to\n-    // remove this because while the crate changes often the lint level map\n-    // will change rarely.\n-    tcx.dep_graph.with_ignore(|| {\n-        let sets = tcx.lint_levels(LOCAL_CRATE);\n-        loop {\n-            if sets.lint_level_set(id).is_some() {\n-                return id\n-            }\n-            let next = tcx.hir().get_parent_node_by_hir_id(id);\n-            if next == id {\n-                bug!(\"lint traversal reached the root of the crate\");\n-            }\n-            id = next;\n-        }\n-    })\n-}\n-\n mod block;\n mod expr;\n mod to_ref;"}, {"sha": "44bcb9de0e1578dee06dbe23542bd3f116c55033", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, subst::SubstsRef, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar};\n+use rustc::mir::interpret::{ConstValue, Scalar, truncate};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -678,16 +678,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             ]\n         }\n         ty::Int(ity) => {\n-            // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n-            let max = (1u128 << (bits - 1)) - 1;\n+            let max = min - 1;\n             vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n         }\n         ty::Uint(uty) => {\n-            // FIXME(49937): refactor these bit manipulations into interpret.\n-            let bits = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n-            let max = !0u128 >> (128 - bits);\n+            let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n+            let max = truncate(u128::max_value(), size);\n             vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n         }\n         _ => {"}, {"sha": "49967df08891b3c4f77d372e2d7dd635ef27606f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -319,7 +319,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                     if edef.is_enum() && edef.variants.iter().any(|variant| {\n                         variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                     }) {\n-                        let ty_path = cx.tcx.item_path_str(edef.did);\n+                        let ty_path = cx.tcx.def_path_str(edef.did);\n                         let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                             \"pattern binding `{}` is named the same as one \\\n                             of the variants of the type `{}`\","}, {"sha": "ad7b45d89453acb390b794ac8d314286d0f1db89", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -13,7 +13,7 @@ use crate::hair::constant::*;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift, UserType};\n+use rustc::ty::{self, DefIdTree, Region, TyCtxt, AdtDef, Ty, Lift, UserType};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n use rustc::ty::layout::VariantIdx;\n@@ -529,11 +529,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::Error => { // Avoid ICE\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n-                    ref sty =>\n+                    _ =>\n                         span_bug!(\n                             pat.span,\n                             \"unexpanded type for vector pattern: {:?}\",\n-                            sty),\n+                            ty),\n                 }\n             }\n \n@@ -554,7 +554,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::Error => { // Avoid ICE (#50577)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n-                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n+                    _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n                 }\n             }\n \n@@ -608,7 +608,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     }\n                     _ => span_bug!(pat.span,\n                                    \"tuple struct pattern not applied to an ADT {:?}\",\n-                                   ty.sty),\n+                                   ty),\n                 };\n                 let variant_def = adt_def.variant_of_def(def);\n \n@@ -735,7 +735,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     ) -> PatternKind<'tcx> {\n         let mut kind = match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n+                let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n                     let substs = match ty.sty {\n@@ -744,7 +744,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         ty::Error => {  // Avoid ICE (#50585)\n                             return PatternKind::Wild;\n                         }\n-                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n+                        _ => bug!(\"inappropriate type for def: {:?}\", ty),\n                     };\n                     PatternKind::Variant {\n                         adt_def,\n@@ -969,8 +969,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n                 let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n                                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                    self.tcx.item_path_str(adt_def.did),\n-                                    self.tcx.item_path_str(adt_def.did));\n+                                    self.tcx.def_path_str(adt_def.did),\n+                                    self.tcx.def_path_str(adt_def.did));\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             }"}, {"sha": "c9dae6990795be5276853a93cb49bfff621cb810", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -16,16 +16,20 @@ crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n         let user_provided_types = self.tables().user_provided_types();\n         let mut user_ty = *user_provided_types.get(hir_id)?;\n         debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n-        match &self.tables().node_type(hir_id).sty {\n+        let ty = self.tables().node_type(hir_id);\n+        match ty.sty {\n             ty::Adt(adt_def, ..) => {\n                 if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {\n                     *did = adt_def.did;\n                 }\n                 Some(user_ty)\n             }\n             ty::FnDef(..) => Some(user_ty),\n-            sty =>\n-                bug!(\"sty: {:?} should not have user provided type {:?} recorded \", sty, user_ty),\n+            _ => bug!(\n+                \"ty: {:?} should not have user provided type {:?} recorded \",\n+                ty,\n+                user_ty\n+            ),\n         }\n     }\n }"}, {"sha": "7543dd678d032fdd9a3f730ea0845ae4708a52e4", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         let fn_ptr = self.memory.create_fn_alloc(instance?).with_default_tag();\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n-                    ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                    _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n                 }\n             }\n \n@@ -101,7 +101,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n                     }\n-                    ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n+                    _ => bug!(\"fn to unsafe fn cast on {:?}\", dest.layout.ty),\n                 }\n             }\n \n@@ -120,7 +120,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_immediate(val, dest)?;\n                     }\n-                    ref other => bug!(\"closure fn pointer on {:?}\", other),\n+                    _ => bug!(\"closure fn pointer on {:?}\", src.layout.ty),\n                 }\n             }\n         }"}, {"sha": "e81d0a56b2b051758212c1f4bc2353648dcddef8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                err!(NoMirFor(self.tcx.item_path_str(def_id)))\n+                err!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -450,7 +450,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n-        if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n+        if self.stack.len() > 0 {\n             info!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n         }\n         ::log_settings::settings().indentation += 1;\n@@ -525,9 +525,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             self.frame_mut().locals = locals;\n         }\n \n-        if self.stack.len() > 1 { // FIXME no check should be needed, but some instances ICE\n-            info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n-        }\n+        info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n             err!(StackFrameLimitReached)\n@@ -537,9 +535,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n-        if self.stack.len() > 1 { // FIXME no check should be needed, but some instances ICE\n-            info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n-        }\n+        info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n@@ -591,7 +587,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             StackPopCleanup::None { .. } => {}\n         }\n \n-        if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n+        if self.stack.len() > 0 {\n             info!(\"CONTINUING({}) {}\", self.cur_frame(), self.frame().instance);\n         }\n "}, {"sha": "6ea200d4e4fad3519335096d9b912e41c95e31a6", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -700,24 +700,29 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations = {\n             let relocations = self.get(src.alloc_id)?.relocations(self, src, size);\n-            let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n-            for i in 0..length {\n-                new_relocations.extend(\n-                    relocations\n-                    .iter()\n-                    .map(|&(offset, reloc)| {\n-                        // compute offset for current repetition\n-                        let dest_offset = dest.offset + (i * size);\n-                        (\n-                            // shift offsets from source allocation to destination allocation\n-                            offset + dest_offset - src.offset,\n-                            reloc,\n-                        )\n-                    })\n-                );\n-            }\n+            if relocations.is_empty() {\n+                // nothing to copy, ignore even the `length` loop\n+                Vec::new()\n+            } else {\n+                let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+                for i in 0..length {\n+                    new_relocations.extend(\n+                        relocations\n+                        .iter()\n+                        .map(|&(offset, reloc)| {\n+                            // compute offset for current repetition\n+                            let dest_offset = dest.offset + (i * size);\n+                            (\n+                                // shift offsets from source allocation to destination allocation\n+                                offset + dest_offset - src.offset,\n+                                reloc,\n+                            )\n+                        })\n+                    );\n+                }\n \n-            new_relocations\n+                new_relocations\n+            }\n         };\n \n         let tcx = self.tcx.tcx;\n@@ -784,20 +789,65 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let undef_mask = self.get(src.alloc_id)?.undef_mask.clone();\n-        let dest_allocation = self.get_mut(dest.alloc_id)?;\n+        let undef_mask = &self.get(src.alloc_id)?.undef_mask;\n+\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefor we precompute a compressed version of the undef mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // a precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // [5, 1, 2, 1, 3, 3, 1]\n+        // where each element toggles the state\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let first = undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = first;\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n+            if undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n \n-        for i in 0..size.bytes() {\n-            let defined = undef_mask.get(src.offset + Size::from_bytes(i));\n+        // now fill in all the data\n+        let dest_allocation = self.get_mut(dest.alloc_id)?;\n+        // an optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if ranges.is_empty() {\n+            dest_allocation.undef_mask.set_range_inbounds(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                first,\n+            );\n+            return Ok(())\n+        }\n \n-            for j in 0..repeat {\n-                dest_allocation.undef_mask.set(\n-                    dest.offset + Size::from_bytes(i + (size.bytes() * j)),\n-                    defined\n+        // remember to fill in the trailing bits\n+        ranges.push(cur_len);\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = first;\n+            for range in &ranges {\n+                let old_j = j;\n+                j += range;\n+                dest_allocation.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n                 );\n+                cur = !cur;\n             }\n         }\n-\n         Ok(())\n     }\n }"}, {"sha": "944e393d296fc9e172d3205d660c21e4475b1988", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n         let layout = val.layout;\n         let val = val.to_scalar()?;\n-        trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty.sty);\n+        trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty);\n \n         match layout.ty.sty {\n             ty::Bool => {"}, {"sha": "755bbd96b02f9131b1d75b2e8020bb643c1f265d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -354,7 +354,7 @@ where\n             ty::Ref(_, _, mutbl) => Some(mutbl),\n             ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n             ty::RawPtr(_) => None,\n-            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n+            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty),\n         };\n         place.mplace.ptr = M::tag_dereference(self, place, mutbl)?;\n         Ok(place)"}, {"sha": "c45e694ebf832a65371b9981329dd85b0207a730", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -14,7 +14,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(const_fn)]\n #![feature(decl_macro)]\n #![feature(exhaustive_patterns)]\n-#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_attrs)]\n #![feature(never_type)]"}, {"sha": "307cee5d97217c1ae55e730bc5421574ad94a9ce", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -198,6 +198,8 @@ use crate::monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMod\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};\n \n+use std::iter;\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum MonoItemCollectionMode {\n     Eager,\n@@ -487,21 +489,33 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We include the const length in the type length, as it's better\n     // to be overly conservative.\n     if type_length + const_length > type_length_limit {\n-        // The instance name is already known to be too long for rustc. Use\n-        // `{:.64}` to avoid blasting the user's terminal with thousands of\n-        // lines of type-name.\n-        let instance_name = instance.to_string();\n-        let msg = format!(\"reached the type-length limit while instantiating `{:.64}...`\",\n-                          instance_name);\n-        let mut diag = if let Some(hir_id) = tcx.hir().as_local_hir_id(instance.def_id()) {\n-            tcx.sess.struct_span_fatal(tcx.hir().span_by_hir_id(hir_id), &msg)\n-        } else {\n-            tcx.sess.struct_fatal(&msg)\n+        // The instance name is already known to be too long for rustc.\n+        // Show only the first and last 32 characters to avoid blasting\n+        // the user's terminal with thousands of lines of type-name.\n+        let shrink = |s: String, before: usize, after: usize| {\n+            // An iterator of all byte positions including the end of the string.\n+            let positions = || s.char_indices().map(|(i, _)| i).chain(iter::once(s.len()));\n+\n+            let shrunk = format!(\n+                \"{before}...{after}\",\n+                before = &s[..positions().nth(before).unwrap_or(s.len())],\n+                after = &s[positions().rev().nth(after).unwrap_or(0)..],\n+            );\n+\n+            // Only use the shrunk version if it's really shorter.\n+            // This also avoids the case where before and after slices overlap.\n+            if shrunk.len() < s.len() {\n+                shrunk\n+            } else {\n+                s\n+            }\n         };\n-\n+        let msg = format!(\"reached the type-length limit while instantiating `{}`\",\n+                          shrink(instance.to_string(), 32, 32));\n+        let mut diag = tcx.sess.struct_span_fatal(tcx.def_span(instance.def_id()), &msg);\n         diag.note(&format!(\n             \"consider adding a `#![type_length_limit=\\\"{}\\\"]` attribute to your crate\",\n-            type_length_limit * 2));\n+            type_length));\n         diag.emit();\n         tcx.sess.abort_if_errors();\n     }\n@@ -836,7 +850,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match tail.sty {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n-                _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+                _ => bug!(\"unexpected unsized tail: {:?}\", tail),\n             }\n         };\n         if type_has_metadata(inner_source) {"}, {"sha": "68d13bf2dcb24b52eba68fa89569bfd253c9ea80", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -216,9 +216,8 @@ impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n // These keys are used by the handwritten auto-tests, so they need to be\n // predictable and human-readable.\n //\n-// Note: A lot of this could looks very similar to what's already in the\n-//       ppaux module. It would be good to refactor things so we only have one\n-//       parameterizable implementation for printing types.\n+// Note: A lot of this could looks very similar to what's already in `ty::print`.\n+// FIXME(eddyb) implement a custom `PrettyPrinter` for this.\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter."}, {"sha": "4a2c05b2013286f0b263b0c7781272efd9d7e8e6", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -104,7 +104,7 @@ use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n-use rustc::ty::item_path::characteristic_def_id_of_type;\n+use rustc::ty::print::characteristic_def_id_of_type;\n use rustc::ty::query::Providers;\n use rustc::util::common::time;\n use rustc::util::nodemap::{DefIdSet, FxHashMap, FxHashSet};"}, {"sha": "001a61959c2dd75caf3a97626b38c475e6dfa211", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1253,7 +1253,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     if !self.span.allows_unstable(&feature.as_str()) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n-                                                    self.tcx.item_path_str(def_id)));\n+                                                    self.tcx.def_path_str(def_id)));\n                                         if nightly_options::is_nightly_build() {\n                                             help!(&mut err,\n                                                   \"add `#![feature({})]` to the \\"}, {"sha": "f9f8abbe6c06519874cea41b4ae164dda1431480", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -29,10 +29,10 @@ impl MirPass for SanityCheck {\n         let def_id = src.def_id();\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         if !tcx.has_attr(def_id, \"rustc_mir\") {\n-            debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n+            debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n             return;\n         } else {\n-            debug!(\"running rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n+            debug!(\"running rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n         }\n \n         let attributes = tcx.get_attrs(def_id);"}, {"sha": "69a2adcfce026e2587e2392af894103ed707acae", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -127,7 +127,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                mir: &Mir<'_>,\n                                                w: &mut W)\n                                                -> io::Result<()> {\n-    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.item_path_str(def_id)))?;\n+    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types.\n     for (i, arg) in mir.args_iter().enumerate() {\n@@ -141,7 +141,7 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         )?;\n     }\n \n-    write!(w, \") -&gt; {}\", escape(mir.return_ty()))?;\n+    write!(w, \") -&gt; {}\", escape(&mir.return_ty()))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n     for local in mir.vars_and_temps_iter() {"}, {"sha": "cbdd50cf4052af71d62f40f2bb97e77b22767836", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::visit::{\n };\n use rustc::mir::Local;\n use rustc::mir::*;\n-use rustc::ty::{item_path, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n@@ -265,9 +265,9 @@ pub fn dump_mir<'a, 'tcx>(\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id())\n+        tcx.def_path_str(source.def_id())\n     });\n     dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }"}, {"sha": "c7c77d351a75f5b2bea9e92e745e14e299f87c5d", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,8 +1,8 @@\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def::CtorKind;\n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n@@ -78,9 +78,9 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n         return;\n     }\n \n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id())\n+        tcx.def_path_str(source.def_id())\n     });\n     dump_matched_mir_node(\n         tcx,\n@@ -103,9 +103,9 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n         None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_path = item_path::with_forced_impl_filename_line(|| {\n+    let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id())\n+        tcx.def_path_str(source.def_id())\n     });\n     filters.split('|').any(|or_filter| {\n         or_filter.split('&').all(|and_filter| {\n@@ -115,7 +115,7 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n }\n \n // #41697 -- we use `with_forced_impl_filename_line()` because\n-// `item_path_str()` would otherwise trigger `type_of`, and this can\n+// `def_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n@@ -597,7 +597,8 @@ fn write_mir_sig(\n     trace!(\"write_mir_sig: {:?}\", src.instance);\n     let descr = tcx.describe_def(src.def_id());\n     let is_function = match descr {\n-        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::StructCtor(..)) => true,\n+        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Variant(..)) |\n+        Some(Def::StructCtor(_, CtorKind::Fn)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n     match (descr, src.promoted) {\n@@ -612,9 +613,9 @@ fn write_mir_sig(\n         _ => bug!(\"Unexpected def description {:?}\", descr),\n     }\n \n-    item_path::with_forced_impl_filename_line(|| {\n+    ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 elsewhere\n-        write!(w, \"{}\", tcx.item_path_str(src.def_id()))\n+        write!(w, \" {}\", tcx.def_path_str(src.def_id()))\n     })?;\n \n     if src.promoted.is_none() && is_function {"}, {"sha": "5065c1de97bee27b7c860198b4ef4efe896246d8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n             ty::FnDef(def_id, ..) |\n             ty::Closure(def_id, ..) |\n             ty::Generator(def_id, ..) => {\n-                if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n+                if self.def_id_visitor.visit_def_id(def_id, \"type\", &ty) {\n                     return true;\n                 }\n                 if self.def_id_visitor.shallow() {\n@@ -816,7 +816,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n         let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n-                             field.ident, def.variant_descr(), self.tcx.item_path_str(def.did))\n+                             field.ident, def.variant_descr(), self.tcx.def_path_str(def.did))\n                 .span_label(span, format!(\"field `{}` is private\", field.ident))\n                 .emit();\n         }"}, {"sha": "3fea515ae401e2a75b8e1fc3cc7a80409285ce0b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::Input;\n use rustc::span_bug;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, DefIdTree, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n use std::path::Path;\n@@ -429,7 +429,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         vis: ast::Visibility,\n         attrs: &'l [Attribute],\n     ) {\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(id)));\n \n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n@@ -470,7 +471,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n \n         let kind = match item.node {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -682,7 +684,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         methods: &'l [ast::TraitItem],\n     ) {\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(&generics.params));\n@@ -1093,7 +1096,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(trait_item.id)));\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n@@ -1201,7 +1205,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         // The parent def id of a given use tree is always the enclosing item.\n         let parent = self.save_ctxt.tcx.hir().opt_local_def_id(id)\n-            .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n+            .and_then(|id| self.save_ctxt.tcx.parent(id))\n             .map(id_from_def_id);\n \n         match use_tree.kind {\n@@ -1300,7 +1304,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         // only get called for the root module of a crate.\n         assert_eq!(id, ast::CRATE_NODE_ID);\n \n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(id)));\n \n         let cm = self.tcx.sess.source_map();\n         let filename = cm.span_to_filename(span);\n@@ -1350,7 +1355,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n                     let parent = self.save_ctxt.tcx.hir().opt_local_def_id(item.id)\n-                        .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n+                        .and_then(|id| self.save_ctxt.tcx.parent(id))\n                         .map(id_from_def_id);\n                     self.dumper.import(\n                         &Access {\n@@ -1389,7 +1394,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 self.nest_scope(item.id, |v| visit::walk_mod(v, m));\n             }\n             Ty(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n@@ -1418,7 +1424,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Existential(ref _bounds, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 // FIXME do something with _bounds\n                 let value = String::new();\n                 if !self.span.filter_generated(item.ident.span) {"}, {"sha": "7ad5b7ce8c73ebdf3a25dcb824c5bdb6a0b2af08", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -20,7 +20,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::{CrateType, Input, OutputType};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, DefIdTree, TyCtxt};\n use rustc::{bug, span_bug};\n use rustc_typeck::hir_ty_to_ty;\n use rustc_codegen_utils::link::{filename_for_metadata, out_filename};\n@@ -134,7 +134,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_extern_item_data(&self, item: &ast::ForeignItem) -> Option<Data> {\n-        let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+        let qualname = format!(\"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n@@ -184,7 +185,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n@@ -202,7 +204,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, ..) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n \n                 filter!(self.span_utils, item.ident.span);\n \n@@ -225,7 +228,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Const(ref typ, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n@@ -247,7 +251,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Mod(ref m) => {\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n \n                 let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n@@ -274,7 +279,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n-                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n+                let qualname = format!(\"::{}\",\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.id)));\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n@@ -358,7 +364,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<Def> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n-            let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n+            let qualname = format!(\"::{}::{}\",\n+                self.tcx.def_path_str(self.tcx.hir().local_def_id(scope)),\n+                ident);\n             filter!(self.span_utils, ident.span);\n             let def_id = self.tcx.hir().local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n@@ -411,7 +419,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             if let Some(def_id) = trait_id {\n                                 // A method in a trait impl.\n                                 qualname.push_str(\" as \");\n-                                qualname.push_str(&self.tcx.item_path_str(def_id));\n+                                qualname.push_str(&self.tcx.def_path_str(def_id));\n                                 self.tcx\n                                     .associated_items(def_id)\n                                     .find(|item| item.ident.name == ident.name)\n@@ -451,7 +459,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }\n \n                         (\n-                            format!(\"::{}\", self.tcx.item_path_str(def_id)),\n+                            format!(\"::{}\", self.tcx.def_path_str(def_id)),\n                             Some(def_id),\n                             None,\n                             docs,\n@@ -763,7 +771,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n-                let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n+                let parent_def_id = self.tcx.parent(def_id).unwrap();\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,"}, {"sha": "f47291458492e0cea6b658814809dc3fee290d3a", "filename": "src/librustc_target/spec/mipsisa32r6_unknown_linux_gnu.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa32r6-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            cpu: \"mips32r6\".to_string(),\n+            features: \"+mips32r6\".to_string(),\n+            max_atomic_width: Some(32),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "f4f98d33571f05724274d575a7d4586dff9154fb", "filename": "src/librustc_target/spec/mipsisa32r6el_unknown_linux_gnu.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa32r6el-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            cpu: \"mips32r6\".to_string(),\n+            features: \"+mips32r6\".to_string(),\n+            max_atomic_width: Some(32),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "7faed3adc79cc1cca9c551db76f2732dad0f509e", "filename": "src/librustc_target/spec/mipsisa64r6_unknown_linux_gnuabi64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa64r6-unknown-linux-gnuabi64\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            // NOTE(mips64r6) matches C toolchain\n+            cpu: \"mips64r6\".to_string(),\n+            features: \"+mips64r6\".to_string(),\n+            max_atomic_width: Some(64),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "58a814a759eb874d6fb33f02b1d9f3883ef8e00a", "filename": "src/librustc_target/spec/mipsisa64r6el_unknown_linux_gnuabi64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mipsisa64r6el-unknown-linux-gnuabi64\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            // NOTE(mips64r6) matches C toolchain\n+            cpu: \"mips64r6\".to_string(),\n+            features: \"+mips64r6\".to_string(),\n+            max_atomic_width: Some(64),\n+\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "fdb1db645c3c43dc2623262edce9cb97f3abcdcd", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -335,6 +335,10 @@ supported_targets! {\n     (\"mips-unknown-linux-gnu\", mips_unknown_linux_gnu),\n     (\"mips64-unknown-linux-gnuabi64\", mips64_unknown_linux_gnuabi64),\n     (\"mips64el-unknown-linux-gnuabi64\", mips64el_unknown_linux_gnuabi64),\n+    (\"mipsisa32r6-unknown-linux-gnu\", mipsisa32r6_unknown_linux_gnu),\n+    (\"mipsisa32r6el-unknown-linux-gnu\", mipsisa32r6el_unknown_linux_gnu),\n+    (\"mipsisa64r6-unknown-linux-gnuabi64\", mipsisa64r6_unknown_linux_gnuabi64),\n+    (\"mipsisa64r6el-unknown-linux-gnuabi64\", mipsisa64r6el_unknown_linux_gnuabi64),\n     (\"mipsel-unknown-linux-gnu\", mipsel_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnu\", powerpc_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnuspe\", powerpc_unknown_linux_gnuspe),"}, {"sha": "956767a22a0e1cc5e43eab3c4a59767c880f0b14", "filename": "src/librustc_target/spec/uefi_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -59,7 +59,7 @@ pub fn opts() -> TargetOptions {\n         singlethread: true,\n         emit_debug_gdb_scripts: false,\n \n-        linker: Some(\"lld-link\".to_string()),\n+        linker: Some(\"rust-lld\".to_string()),\n         lld_flavor: LldFlavor::Link,\n         pre_link_args,\n "}, {"sha": "9ca75566b4280ce7f75e0e7b7450979a479fa326", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -12,7 +12,7 @@ use crate::middle::resolve_lifetime as rl;\n use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n@@ -922,7 +922,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                      \"the value of the associated type `{}` (from the trait `{}`) \\\n                                       is already specified\",\n                                      binding.item_name,\n-                                     tcx.item_path_str(assoc_ty.container.id()))\n+                                     tcx.def_path_str(assoc_ty.container.id()))\n                         .span_label(binding.span, \"re-bound here\")\n                         .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n                         .emit();\n@@ -959,7 +959,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// removing the dummy `Self` type (`TRAIT_OBJECT_DUMMY_SELF`).\n     fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n                                 -> ty::ExistentialTraitRef<'tcx> {\n-        assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n+        if trait_ref.self_ty().sty != TRAIT_OBJECT_DUMMY_SELF {\n+            bug!(\"trait_ref_to_existential called on {:?} with non-dummy Self\", trait_ref);\n+        }\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n@@ -1069,7 +1071,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 format!(\n                     \"`{}` (from the trait `{}`)\",\n                     assoc_item.ident,\n-                    tcx.item_path_str(trait_def_id),\n+                    tcx.def_path_str(trait_def_id),\n                 )\n             }).collect::<Vec<_>>().join(\", \");\n             let mut err = struct_span_err!(\n@@ -1450,14 +1452,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                    -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let trait_def_id = tcx.parent_def_id(item_def_id).unwrap();\n+        let trait_def_id = tcx.parent(item_def_id).unwrap();\n \n         self.prohibit_generics(slice::from_ref(item_segment));\n \n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n         } else {\n-            let path_str = tcx.item_path_str(trait_def_id);\n+            let path_str = tcx.def_path_str(trait_def_id);\n             self.report_ambiguous_associated_type(span,\n                                                   \"Type\",\n                                                   &path_str,\n@@ -1619,7 +1621,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n                     // Everything but the penultimate segment should have no\n                     // parameters at all.\n-                    let enum_def_id = tcx.parent_def_id(def_id).unwrap();\n+                    let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {\n                     // FIXME: lint here recommending `Enum::<...>::Variant` form"}, {"sha": "c6b66393dd2f1e2733cc72c03fcf6dcc901fccc8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // See the examples in `run-pass/match-defbm*.rs`.\n             let mut pat_adjustments = vec![];\n             while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n-                debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n+                debug!(\"inspecting {:?}\", exp_ty);\n \n                 debug!(\"current discriminant is Ref, inserting implicit deref\");\n                 // Preserve the reference type. We'll need it later during HAIR lowering.\n@@ -894,7 +894,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n             let substs = match pat_ty.sty {\n                 ty::Adt(_, substs) => substs,\n-                ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n+                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n@@ -1001,13 +1001,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                                            E0026,\n                                            \"{} `{}` does not have {}\",\n                                            kind_name,\n-                                           tcx.item_path_str(variant.did),\n+                                           tcx.def_path_str(variant.did),\n                                            field_names);\n             if let Some((span, ident)) = inexistent_fields.last() {\n                 err.span_label(*span,\n                                format!(\"{} `{}` does not have {} field{}\",\n                                        kind_name,\n-                                       tcx.item_path_str(variant.did),\n+                                       tcx.def_path_str(variant.did),\n                                        t,\n                                        plural));\n                 if plural == \"\" {"}, {"sha": "e6e5c46c473d54abb7ae5a6d84b2eb47ea3862e4", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -719,7 +719,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         trait `{}` has {}\",\n                                        trait_m.ident,\n                                        potentially_plural_count(impl_number_args, \"parameter\"),\n-                                       tcx.item_path_str(trait_m.def_id),\n+                                       tcx.def_path_str(trait_m.def_id),\n                                        trait_number_args);\n         if let Some(trait_span) = trait_span {\n             err.span_label(trait_span, format!(\"trait requires {}\","}, {"sha": "3a7308d09172e6581402db7d77fd0eecba619a29", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.item_path_str(variant.did);\n+                            let variant_path = self.tcx.def_path_str(variant.did);\n                             // FIXME #56861: DRYer prelude filtering\n                             Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n                         } else {"}, {"sha": "1f0ab3abb283617346f34d9a8905876088f682e2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1195,15 +1195,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // `report_method_error()`.\n         diag.help(&format!(\n             \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n-            self.tcx.item_path_str(stable_pick.item.def_id),\n+            self.tcx.def_path_str(stable_pick.item.def_id),\n         ));\n \n         if nightly_options::is_nightly_build() {\n             for (candidate, feature) in unstable_candidates {\n                 diag.help(&format!(\n                     \"add #![feature({})] to the crate attributes to enable `{}`\",\n                     feature,\n-                    self.tcx.item_path_str(candidate.item.def_id),\n+                    self.tcx.def_path_str(candidate.item.def_id),\n                 ));\n             }\n         }"}, {"sha": "b4a1a2d76c262554fbf400e8724b58ad7f239810", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::print;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n use rustc::ty::{self, Adt, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use rustc::ty::item_path::with_crate_prefix;\n+use rustc::ty::print::with_crate_prefix;\n use syntax_pos::{Span, FileName};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             None => String::new(),\n                             Some(trait_ref) => {\n                                 format!(\" of the trait `{}`\",\n-                                        self.tcx.item_path_str(trait_ref.def_id))\n+                                        self.tcx.def_path_str(trait_ref.def_id))\n                             }\n                         };\n \n@@ -135,16 +135,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        item_span,\n                                        \"candidate #{} is defined in the trait `{}`\",\n                                        idx + 1,\n-                                       self.tcx.item_path_str(trait_did));\n+                                       self.tcx.def_path_str(trait_did));\n                         } else {\n                             span_note!(err,\n                                        item_span,\n                                        \"the candidate is defined in the trait `{}`\",\n-                                       self.tcx.item_path_str(trait_did));\n+                                       self.tcx.def_path_str(trait_did));\n                         }\n                         err.help(&format!(\"to disambiguate the method call, write `{}::{}({}{})` \\\n                                           instead\",\n-                                          self.tcx.item_path_str(trait_did),\n+                                          self.tcx.def_path_str(trait_did),\n                                           item_name,\n                                           if rcvr_ty.is_region_ptr() && args.is_some() {\n                                               if rcvr_ty.is_mutable_pointer() {\n@@ -516,7 +516,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 format!(\n                     \"use {};\\n{}\",\n-                    with_crate_prefix(|| self.tcx.item_path_str(*did)),\n+                    with_crate_prefix(|| self.tcx.def_path_str(*did)),\n                     additional_newline\n                 )\n             });\n@@ -530,14 +530,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         &format!(\n                             \"\\ncandidate #{}: `use {};`\",\n                             i + 1,\n-                            with_crate_prefix(|| self.tcx.item_path_str(*trait_did))\n+                            with_crate_prefix(|| self.tcx.def_path_str(*trait_did))\n                         )\n                     );\n                 } else {\n                     msg.push_str(\n                         &format!(\n                             \"\\n`use {};`\",\n-                            with_crate_prefix(|| self.tcx.item_path_str(*trait_did))\n+                            with_crate_prefix(|| self.tcx.def_path_str(*trait_did))\n                         )\n                     );\n                 }\n@@ -638,7 +638,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for (i, trait_info) in candidates.iter().enumerate() {\n                 msg.push_str(&format!(\"\\ncandidate #{}: `{}`\",\n                                       i + 1,\n-                                      self.tcx.item_path_str(trait_info.def_id)));\n+                                      self.tcx.def_path_str(trait_info.def_id)));\n             }\n             err.note(&msg[..]);\n         }"}, {"sha": "fa4bb02189f20260877fd0d42349c7ca114e0b1b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1328,7 +1328,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n-        tcx.item_path_str(tcx.hir().local_def_id_from_hir_id(it.hir_id))\n+        tcx.def_path_str(tcx.hir().local_def_id_from_hir_id(it.hir_id))\n     );\n     let _indenter = indenter();\n     match it.node {\n@@ -3534,7 +3534,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         autoderef.unambiguous_final_ty(self);\n \n         if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().item_path_str(did);\n+            let struct_path = self.tcx().def_path_str(did);\n             let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n                                            \"field `{}` of struct `{}` is private\",\n                                            field, struct_path);\n@@ -3885,7 +3885,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Adt(adt, substs) => {\n                         Some((adt.variant_of_def(def), adt.did, substs))\n                     }\n-                    _ => bug!(\"unexpected type: {:?}\", ty.sty)\n+                    _ => bug!(\"unexpected type: {:?}\", ty)\n                 }\n             }\n             Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n@@ -5226,8 +5226,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.node);\n                 let sp = ty.span;\n                 let ty = AstConv::ast_ty_to_ty(self, ty);\n-                debug!(\"suggest_missing_return_type: return type sty {:?}\", ty.sty);\n-                debug!(\"suggest_missing_return_type: expected type sty {:?}\", ty.sty);\n+                debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n+                debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 if ty.sty == expected.sty {\n                     err.span_label(sp, format!(\"expected `{}` because of return type\",\n                                                expected));\n@@ -5288,6 +5288,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n+    // Rewrite `SelfCtor` to `StructCtor`\n+    pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n+        let tcx = self.tcx;\n+        if let Def::SelfCtor(impl_def_id) = def {\n+            let ty = self.impl_self_ty(span, impl_def_id).ty;\n+            let adt_def = ty.ty_adt_def();\n+\n+            match adt_def {\n+                Some(adt_def) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let def = Def::StructCtor(variant.did, variant.ctor_kind);\n+                    (def, variant.did, tcx.type_of(variant.did))\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\");\n+                    if let Some(adt_def) = adt_def {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            },\n+                            AdtKind::Struct |\n+                            AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    (def, impl_def_id, tcx.types.err)\n+                }\n+            }\n+        } else {\n+            let def_id = def.def_id();\n+\n+            // The things we are substituting into the type should not contain\n+            // escaping late-bound regions, and nor should the base type scheme.\n+            let ty = tcx.type_of(def_id);\n+            (def, def_id, ty)\n+        }\n+    }\n+\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -5307,6 +5354,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        match def {\n+            Def::Local(nid) | Def::Upvar(nid, ..) => {\n+                let hid = self.tcx.hir().node_to_hir_id(nid);\n+                let ty = self.local_ty(span, hid).decl_ty;\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(hir_id, ty);\n+                return (ty, def);\n+            }\n+            _ => {}\n+        }\n+\n+        let (def, def_id, ty) = self.rewrite_self_ctor(def, span);\n         let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n \n         let mut user_self_ty = None;\n@@ -5368,17 +5427,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             user_self_ty = None;\n         }\n \n-        match def {\n-            Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let hid = self.tcx.hir().node_to_hir_id(nid);\n-                let ty = self.local_ty(span, hid).decl_ty;\n-                let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(hir_id, ty);\n-                return (ty, def);\n-            }\n-            _ => {}\n-        }\n-\n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n@@ -5411,53 +5459,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n-        let mut new_def = def;\n-        let (def_id, ty) = match def {\n-            Def::SelfCtor(impl_def_id) => {\n-                let ty = self.impl_self_ty(span, impl_def_id).ty;\n-                let adt_def = ty.ty_adt_def();\n-\n-                match adt_def {\n-                    Some(adt_def) if adt_def.has_ctor() => {\n-                        let variant = adt_def.non_enum_variant();\n-                        new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                        (variant.did, tcx.type_of(variant.did))\n-                    }\n-                    _ => {\n-                        let mut err = tcx.sess.struct_span_err(span,\n-                            \"the `Self` constructor can only be used with tuple or unit structs\");\n-                        if let Some(adt_def) = adt_def {\n-                            match adt_def.adt_kind() {\n-                                AdtKind::Enum => {\n-                                    err.help(\"did you mean to use one of the enum's variants?\");\n-                                },\n-                                AdtKind::Struct |\n-                                AdtKind::Union => {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"use curly brackets\",\n-                                        String::from(\"Self { /* fields */ }\"),\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                }\n-                            }\n-                        }\n-                        err.emit();\n-\n-                        (impl_def_id, tcx.types.err)\n-                    }\n-                }\n-            }\n-            _ => {\n-                let def_id = def.def_id();\n-\n-                // The things we are substituting into the type should not contain\n-                // escaping late-bound regions, and nor should the base type scheme.\n-                let ty = tcx.type_of(def_id);\n-                (def_id, ty)\n-            }\n-        };\n-\n         let substs = AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n@@ -5573,7 +5574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, new_def)\n+        (ty_substituted, def)\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "a76dfdd69ba9797304da44193f7093b797910962", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -93,19 +93,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         // Extract the type of the closure.\n-        let (closure_def_id, substs) = match self.node_ty(closure_hir_id).sty {\n+        let ty = self.node_ty(closure_hir_id);\n+        let (closure_def_id, substs) = match ty.sty {\n             ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n             ty::Error => {\n                 // #51714: skip analysis when we have already encountered type errors\n                 return;\n             }\n-            ref t => {\n+            _ => {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n                     closure_hir_id,\n-                    t\n+                    ty\n                 );\n             }\n         };"}, {"sha": "1f7e05de18bcf07ff09de6fed0704cc06c86b7dd", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -68,7 +68,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n \n     debug!(\"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n            item.hir_id,\n-           tcx.item_path_str(def_id));\n+           tcx.def_path_str(def_id));\n \n     match item.node {\n         // Right now we check that every default trait implementation\n@@ -618,7 +618,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n-    trace!(\"check_existential_types: {:?}, {:?}\", ty, ty.sty);\n+    trace!(\"check_existential_types: {:?}\", ty);\n     let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n@@ -976,7 +976,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(def_id) = suggested_marker_id {\n         err.help(&format!(\"consider removing `{}` or using a marker such as `{}`\",\n                           param_name,\n-                          tcx.item_path_str(def_id)));\n+                          tcx.def_path_str(def_id)));\n     }\n     err.emit();\n }"}, {"sha": "4a3d4f31a24731eed44d220ea783e4adb3f47ed6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -472,7 +472,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 instantiated_ty.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx().global_tcx(),\n                     fldop: |ty| {\n-                        trace!(\"checking type {:?}: {:#?}\", ty, ty.sty);\n+                        trace!(\"checking type {:?}\", ty);\n                         // find a type parameter\n                         if let ty::Param(..) = ty.sty {\n                             // look it up in the substitution list"}, {"sha": "a2b01e3843ff2d43d2361969c389603ac1cd45d7", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -198,8 +198,8 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n                     if def_a.is_struct() && def_b.is_struct() =>\n                 {\n                     if def_a != def_b {\n-                        let source_path = tcx.item_path_str(def_a.did);\n-                        let target_path = tcx.item_path_str(def_b.did);\n+                        let source_path = tcx.def_path_str(def_a.did);\n+                        let target_path = tcx.def_path_str(def_b.did);\n \n                         create_err(\n                             &format!(\n@@ -388,8 +388,8 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                       def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = gcx.item_path_str(def_a.did);\n-                    let target_path = gcx.item_path_str(def_b.did);\n+                    let source_path = gcx.def_path_str(def_a.did);\n+                    let target_path = gcx.def_path_str(def_b.did);\n                     span_err!(gcx.sess,\n                               span,\n                               E0377,"}, {"sha": "a5452b4db2a2081538f6657284993e1549ba5fcb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -28,7 +28,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n         debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                trait_ref,\n-               tcx.item_path_str(impl_def_id));\n+               tcx.def_path_str(impl_def_id));\n \n         // Skip impls where one of the self type is an error type.\n         // This occurs with e.g., resolve failures (#30589).\n@@ -204,10 +204,10 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n                                      E0371,\n                                      \"the object type `{}` automatically implements the trait `{}`\",\n                                      trait_ref.self_ty(),\n-                                     tcx.item_path_str(trait_def_id))\n+                                     tcx.def_path_str(trait_def_id))\n                         .span_label(sp, format!(\"`{}` automatically implements trait `{}`\",\n                                                 trait_ref.self_ty(),\n-                                                tcx.item_path_str(trait_def_id)))\n+                                                tcx.def_path_str(trait_def_id)))\n                         .emit();\n                 }\n             }"}, {"sha": "7e1c38e051542298eec8eb6c877a6059bb4f7edc", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -121,15 +121,15 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                 format!(\"cross-crate traits with a default impl, like `{}`, \\\n                                          can only be implemented for a struct/enum type \\\n                                          defined in the current crate\",\n-                                        self.tcx.item_path_str(trait_def_id)),\n+                                        self.tcx.def_path_str(trait_def_id)),\n                                 \"can't implement cross-crate trait for type in another crate\"\n                             ))\n                         }\n                     }\n                     _ => {\n                         Some((format!(\"cross-crate traits with a default impl, like `{}`, can \\\n                                        only be implemented for a struct/enum type, not `{}`\",\n-                                      self.tcx.item_path_str(trait_def_id),\n+                                      self.tcx.def_path_str(trait_def_id),\n                                       self_ty),\n                               \"can't implement cross-crate trait with a default impl for \\\n                                non-struct/enum type\"))"}, {"sha": "cbed7d26a9950b413a68448e16c37179d05efe4a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -317,7 +317,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> Result<(), ErrorReported>\n {\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::TypeChecking));\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::TypeChecking, \"type-check crate\"));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n@@ -368,7 +368,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::TypeChecking));\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::TypeChecking, \"type-check crate\"));\n \n     if tcx.sess.err_count() == 0 {\n         Ok(())"}, {"sha": "c18f9fd102f1093980b26fbc179a61122c3d7e5f", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n     fn build_constraints_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx();\n-        debug!(\"build_constraints_for_item({})\", tcx.item_path_str(def_id));\n+        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id));\n \n         // Skip items with no generics - there's nothing to infer in them.\n         if tcx.generics_of(def_id).count() == 0 {"}, {"sha": "c80fd8fcd812f9588a34b9da7583a5d218dc832a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 100, "deletions": 18, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -20,8 +20,9 @@ use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::hir::map::DisambiguatedDefPathData;\n+use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef};\n+use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -3971,7 +3972,7 @@ pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n         Def::ForeignTy(i) => (i, TypeKind::Foreign),\n         Def::Const(i) => (i, TypeKind::Const),\n         Def::Static(i, _) => (i, TypeKind::Static),\n-        Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n+        Def::Variant(i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n         Def::Macro(i, mac_kind) => match mac_kind {\n             MacroKind::Bang => (i, TypeKind::Macro),\n@@ -4223,32 +4224,113 @@ pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n-where F: Fn(DefId) -> Def {\n-    #[derive(Debug)]\n-    struct AbsolutePathBuffer {\n-        names: Vec<String>,\n+pub fn get_path_for_type(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    def_id: DefId,\n+    def_ctor: impl Fn(DefId) -> Def,\n+) -> hir::Path {\n+    use rustc::ty::print::Printer;\n+\n+    struct AbsolutePathPrinter<'a, 'tcx> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n-    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n-        fn root_mode(&self) -> &ty::item_path::RootMode {\n-            const ABSOLUTE: &'static ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n-            ABSOLUTE\n+    impl Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+        type Error = !;\n+\n+        type Path = Vec<String>;\n+        type Region = ();\n+        type Type = ();\n+        type DynExistential = ();\n+\n+        fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+            self.tcx\n         }\n \n-        fn push(&mut self, text: &str) {\n-            self.names.push(text.to_owned());\n+        fn print_region(\n+            self,\n+            _region: ty::Region<'_>,\n+        ) -> Result<Self::Region, Self::Error> {\n+            Ok(())\n         }\n-    }\n \n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n+        fn print_type(\n+            self,\n+            _ty: Ty<'tcx>,\n+        ) -> Result<Self::Type, Self::Error> {\n+            Ok(())\n+        }\n+\n+        fn print_dyn_existential(\n+            self,\n+            _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        ) -> Result<Self::DynExistential, Self::Error> {\n+            Ok(())\n+        }\n+\n+        fn path_crate(\n+            self,\n+            cnum: CrateNum,\n+        ) -> Result<Self::Path, Self::Error> {\n+            Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n+        }\n+        fn path_qualified(\n+            self,\n+            self_ty: Ty<'tcx>,\n+            trait_ref: Option<ty::TraitRef<'tcx>>,\n+        ) -> Result<Self::Path, Self::Error> {\n+            // This shouldn't ever be needed, but just in case:\n+            Ok(vec![match trait_ref {\n+                Some(trait_ref) => format!(\"{:?}\", trait_ref),\n+                None => format!(\"<{}>\", self_ty),\n+            }])\n+        }\n+\n+        fn path_append_impl(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+            _disambiguated_data: &DisambiguatedDefPathData,\n+            self_ty: Ty<'tcx>,\n+            trait_ref: Option<ty::TraitRef<'tcx>>,\n+        ) -> Result<Self::Path, Self::Error> {\n+            let mut path = print_prefix(self)?;\n+\n+            // This shouldn't ever be needed, but just in case:\n+            path.push(match trait_ref {\n+                Some(trait_ref) => {\n+                    format!(\"<impl {} for {}>\", trait_ref, self_ty)\n+                }\n+                None => format!(\"<impl {}>\", self_ty),\n+            });\n+\n+            Ok(path)\n+        }\n+        fn path_append(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+            disambiguated_data: &DisambiguatedDefPathData,\n+        ) -> Result<Self::Path, Self::Error> {\n+            let mut path = print_prefix(self)?;\n+            path.push(disambiguated_data.data.as_interned_str().to_string());\n+            Ok(path)\n+        }\n+        fn path_generic_args(\n+            self,\n+            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+            _args: &[Kind<'tcx>],\n+        ) -> Result<Self::Path, Self::Error> {\n+            print_prefix(self)\n+        }\n+    }\n \n-    tcx.push_item_path(&mut apb, def_id, false);\n+    let names = AbsolutePathPrinter { tcx: tcx.global_tcx() }\n+        .print_def_path(def_id, &[])\n+        .unwrap();\n \n     hir::Path {\n         span: DUMMY_SP,\n         def: def_ctor(def_id),\n-        segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n+        segments: hir::HirVec::from_vec(names.iter().map(|s| hir::PathSegment {\n             ident: ast::Ident::from_str(&s),\n             hir_id: None,\n             def: None,"}, {"sha": "5109e775ebf8113b742187e9c40fba27fbf96ee6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1117,11 +1117,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n     let mut w = try_err!(File::create(&dst), &dst);\n-    if options.enable_minification {\n-        try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n-    } else {\n-        try_err!(writeln!(&mut w, \"var searchIndex={{}};\"), &dst);\n-    }\n+    try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n     try_err!(write_minify_replacer(&mut w,\n                                    &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n                                    options.enable_minification),"}, {"sha": "fef6910f40a574c5f62d6f259b25f1b6d25c88ee", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2077,16 +2077,22 @@ if (!DOMTokenList.prototype.remove) {\n     }\n \n     var toggle = createSimpleToggle(false);\n+    var hideMethodDocs = getCurrentValue(\"rustdoc-method-docs\") !== \"false\";\n+    var pageId = getPageId();\n \n     var func = function(e) {\n         var next = e.nextElementSibling;\n         if (!next) {\n             return;\n         }\n-        if (hasClass(next, \"docblock\") ||\n-            (hasClass(next, \"stability\") &&\n-             hasClass(next.nextElementSibling, \"docblock\"))) {\n-            insertAfter(toggle.cloneNode(true), e.childNodes[e.childNodes.length - 1]);\n+        if (hasClass(next, \"docblock\") === true ||\n+            (hasClass(next, \"stability\") === true &&\n+             hasClass(next.nextElementSibling, \"docblock\") === true)) {\n+            var newToggle = toggle.cloneNode(true);\n+            insertAfter(newToggle, e.childNodes[e.childNodes.length - 1]);\n+            if (hideMethodDocs === true && hasClass(e, \"method\") === true) {\n+                collapseDocs(newToggle, \"hide\", pageId);\n+            }\n         }\n     };\n \n@@ -2107,17 +2113,16 @@ if (!DOMTokenList.prototype.remove) {\n     onEachLazy(document.getElementsByClassName(\"associatedconstant\"), func);\n     onEachLazy(document.getElementsByClassName(\"impl\"), funcImpl);\n     var impl_call = function() {};\n-    if (getCurrentValue(\"rustdoc-method-docs\") !== \"false\") {\n+    if (hideMethodDocs === true) {\n         impl_call = function(e, newToggle, pageId) {\n             if (e.id.match(/^impl(?:-\\d+)?$/) === null) {\n                 // Automatically minimize all non-inherent impls\n-                if (hasClass(e, \"impl\")) {\n+                if (hasClass(e, \"impl\") === true) {\n                     collapseDocs(newToggle, \"hide\", pageId);\n                 }\n             }\n         };\n     }\n-    var pageId = getPageId();\n     var newToggle = document.createElement(\"a\");\n     newToggle.href = \"javascript:void(0)\";\n     newToggle.className = \"collapse-toggle hidden-default collapsed\";\n@@ -2163,7 +2168,7 @@ if (!DOMTokenList.prototype.remove) {\n             var inner_toggle = newToggle.cloneNode(true);\n             inner_toggle.onclick = toggleClicked;\n             e.insertBefore(inner_toggle, e.firstChild);\n-            impl_call(e, inner_toggle, pageId);\n+            impl_call(e.previousSibling, inner_toggle, pageId);\n         }\n     });\n \n@@ -2265,30 +2270,6 @@ if (!DOMTokenList.prototype.remove) {\n     onEachLazy(document.getElementsByClassName(\"docblock\"), buildToggleWrapper);\n     onEachLazy(document.getElementsByClassName(\"sub-variant\"), buildToggleWrapper);\n \n-    // In the search display, allows to switch between tabs.\n-    function printTab(nb) {\n-        if (nb === 0 || nb === 1 || nb === 2) {\n-            currentTab = nb;\n-        }\n-        var nb_copy = nb;\n-        onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n-            if (nb_copy === 0) {\n-                addClass(elem, \"selected\");\n-            } else {\n-                removeClass(elem, \"selected\");\n-            }\n-            nb_copy -= 1;\n-        });\n-        onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n-            if (nb === 0) {\n-                elem.style.display = \"\";\n-            } else {\n-                elem.style.display = \"none\";\n-            }\n-            nb -= 1;\n-        });\n-    }\n-\n     function createToggleWrapper(tog) {\n         var span = document.createElement(\"span\");\n         span.className = \"toggle-label\";\n@@ -2374,6 +2355,30 @@ if (!DOMTokenList.prototype.remove) {\n         };\n     });\n \n+    // In the search display, allows to switch between tabs.\n+    function printTab(nb) {\n+        if (nb === 0 || nb === 1 || nb === 2) {\n+            currentTab = nb;\n+        }\n+        var nb_copy = nb;\n+        onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n+            if (nb_copy === 0) {\n+                addClass(elem, \"selected\");\n+            } else {\n+                removeClass(elem, \"selected\");\n+            }\n+            nb_copy -= 1;\n+        });\n+        onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n+            if (nb === 0) {\n+                elem.style.display = \"\";\n+            } else {\n+                elem.style.display = \"none\";\n+            }\n+            nb -= 1;\n+        });\n+    }\n+\n     function putBackSearch(search_input) {\n         if (search_input.value !== \"\") {\n             addClass(main, \"hidden\");"}, {"sha": "fccf5a67ad46564fede5025f5925e3fc836968aa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -5,8 +5,10 @@\n \n #![feature(bind_by_move_pattern_guards)]\n #![feature(rustc_private)]\n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(set_stdio)]\n #![feature(test)]\n@@ -16,6 +18,7 @@\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(inner_deref)]\n+#![feature(never_type)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "0f8e8894c04abd42432c85d8c8b318346b3ccdd7", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -288,6 +288,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             if ori_link.contains('/') {\n                 continue;\n             }\n+\n+            // [] is mostly likely not supposed to be a link\n+            if ori_link.is_empty() {\n+                continue;\n+            }\n+\n             let link = ori_link.replace(\"`\", \"\");\n             let (def, fragment) = {\n                 let mut kind = PathKind::Unknown;"}, {"sha": "1d45df499d86b914adf3ecae00967af2f0968d47", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -19,7 +19,7 @@ use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucke\n use super::table::BucketState::{Empty, Full};\n use super::table::Fallibility::{Fallible, Infallible};\n \n-const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n+const MIN_NONZERO_RAW_CAPACITY: usize = 32; // must be a power of two\n \n /// The default behavior of HashMap implements a maximum load factor of 90.9%.\n #[derive(Clone)]"}, {"sha": "c026de35da63d79bfa33b9433da973041a7a5771", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -8,7 +8,7 @@ use super::Recover;\n use super::map::{self, HashMap, Keys, RandomState};\n \n // Future Optimization (FIXME!)\n-// =============================\n+// ============================\n //\n // Iteration over zero sized values is a noop. There is no need\n // for `bucket.val` in the case of HashSet. I suppose we would need HKT"}, {"sha": "a2b12d00a78c21c9f5a986e6fe3d1e263be8b820", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -956,6 +956,27 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n+    /// Returns max if self is greater than max, and min if self is less than min.\n+    /// Otherwise this returns self.  Panics if min > max, min equals NaN, or max equals NaN.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(clamp)]\n+    /// assert!((-3.0f32).clamp(-2.0f32, 1.0f32) == -2.0f32);\n+    /// assert!((0.0f32).clamp(-2.0f32, 1.0f32) == 0.0f32);\n+    /// assert!((2.0f32).clamp(-2.0f32, 1.0f32) == 1.0f32);\n+    /// ```\n+    #[unstable(feature = \"clamp\", issue = \"44095\")]\n+    #[inline]\n+    pub fn clamp(self, min: f32, max: f32) -> f32 {\n+        assert!(min <= max);\n+        let mut x = self;\n+        if x < min { x = min; }\n+        if x > max { x = max; }\n+        x\n+    }\n+\n }\n \n #[cfg(test)]"}, {"sha": "be5cd92d4167bf51222110ec3a48eefee195f6a2", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -878,6 +878,27 @@ impl f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n+    /// Returns max if self is greater than max, and min if self is less than min.\n+    /// Otherwise this returns self.  Panics if min > max, min equals NaN, or max equals NaN.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(clamp)]\n+    /// assert!((-3.0f64).clamp(-2.0f64, 1.0f64) == -2.0f64);\n+    /// assert!((0.0f64).clamp(-2.0f64, 1.0f64) == 0.0f64);\n+    /// assert!((2.0f64).clamp(-2.0f64, 1.0f64) == 1.0f64);\n+    /// ```\n+    #[unstable(feature = \"clamp\", issue = \"44095\")]\n+    #[inline]\n+    pub fn clamp(self, min: f64, max: f64) -> f64 {\n+        assert!(min <= max);\n+        let mut x = self;\n+        if x < min { x = min; }\n+        if x > max { x = max; }\n+        x\n+    }\n+\n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n     // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN)."}, {"sha": "8c3d0da0a7e405836a723ff096c7b5aa2b9560c3", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -211,7 +211,7 @@ pub struct DirBuilder {\n     recursive: bool,\n }\n \n-/// How large a buffer to pre-allocate before reading the entire file.\n+/// Indicates how large a buffer to pre-allocate before reading the entire file.\n fn initial_buffer_size(file: &File) -> usize {\n     // Allocate one extra byte so the buffer doesn't need to grow before the\n     // final `read` call at the end of the file.  Don't worry about `usize`\n@@ -1581,7 +1581,8 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n /// NTFS streams are copied but only the size of the main stream is returned by\n-/// this function.\n+/// this function. On MacOS, this function corresponds to `copyfile` with\n+/// `COPYFILE_ALL`.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior\n@@ -2836,6 +2837,26 @@ mod tests {\n         assert_eq!(check!(out_path.metadata()).len(), copied_len);\n     }\n \n+    #[test]\n+    fn copy_file_follows_dst_symlink() {\n+        let tmp = tmpdir();\n+        if !got_symlink_permission(&tmp) { return };\n+\n+        let in_path = tmp.join(\"in.txt\");\n+        let out_path = tmp.join(\"out.txt\");\n+        let out_path_symlink = tmp.join(\"out_symlink.txt\");\n+\n+        check!(fs::write(&in_path, \"foo\"));\n+        check!(fs::write(&out_path, \"bar\"));\n+        check!(symlink_file(&out_path, &out_path_symlink));\n+\n+        check!(fs::copy(&in_path, &out_path_symlink));\n+\n+        assert!(check!(out_path_symlink.symlink_metadata()).file_type().is_symlink());\n+        assert_eq!(check!(fs::read(&out_path_symlink)), b\"foo\".to_vec());\n+        assert_eq!(check!(fs::read(&out_path)), b\"foo\".to_vec());\n+    }\n+\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();"}, {"sha": "1a2152a79af5a235fc660e5362dc7a79a4fe7fba", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -390,6 +390,28 @@ fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n     ret\n }\n \n+pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoVecMut<'_>]) -> Result<usize>\n+where\n+    F: FnOnce(&mut [u8]) -> Result<usize>\n+{\n+    let buf = bufs\n+        .iter_mut()\n+        .find(|b| !b.is_empty())\n+        .map_or(&mut [][..], |b| &mut **b);\n+    read(buf)\n+}\n+\n+pub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoVec<'_>]) -> Result<usize>\n+where\n+    F: FnOnce(&[u8]) -> Result<usize>\n+{\n+    let buf = bufs\n+        .iter()\n+        .find(|b| !b.is_empty())\n+        .map_or(&[][..], |b| &**b);\n+    write(buf)\n+}\n+\n /// The `Read` trait allows for reading bytes from a source.\n ///\n /// Implementors of the `Read` trait are called 'readers'.\n@@ -528,14 +550,11 @@ pub trait Read {\n     /// written to possibly being only partially filled. This method must behave\n     /// as a single call to `read` with the buffers concatenated would.\n     ///\n-    /// The default implementation simply passes the first nonempty buffer to\n-    /// `read`.\n+    /// The default implementation calls `read` with either the first nonempty\n+    /// buffer provided, or an empty one if none exists.\n     #[unstable(feature = \"iovec\", issue = \"58452\")]\n     fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> Result<usize> {\n-        match bufs.iter_mut().find(|b| !b.is_empty()) {\n-            Some(buf) => self.read(buf),\n-            None => Ok(0),\n-        }\n+        default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     /// Determines if this `Read`er can work with buffers of uninitialized\n@@ -1107,14 +1126,11 @@ pub trait Write {\n     /// read from possibly being only partially consumed. This method must\n     /// behave as a call to `write` with the buffers concatenated would.\n     ///\n-    /// The default implementation simply passes the first nonempty buffer to\n-    /// `write`.\n+    /// The default implementation calls `write` with either the first nonempty\n+    /// buffer provided, or an empty one if none exists.\n     #[unstable(feature = \"iovec\", issue = \"58452\")]\n     fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> Result<usize> {\n-        match bufs.iter().find(|b| !b.is_empty()) {\n-            Some(buf) => self.write(buf),\n-            None => Ok(0),\n-        }\n+        default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     /// Flush this output stream, ensuring that all intermediately buffered"}, {"sha": "fc8ac9a0b3e00b57978501097236dbd9dda88f28", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -221,7 +221,7 @@\n \n #![cfg_attr(test, feature(print_internals, set_stdio, test, update_panic_count))]\n #![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n-            feature(global_asm, range_contains, slice_index_methods,\n+            feature(global_asm, slice_index_methods,\n                     decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]\n \n // std is implemented with unstable features, many of which are internal\n@@ -245,6 +245,7 @@\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]\n #![feature(checked_duration_since)]\n+#![feature(clamp)]\n #![feature(compiler_builtins_lib)]\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]"}, {"sha": "4e30b1edd15e82dc7171328699fd3e23f2de679a", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -43,3 +43,8 @@ pub mod mem {\n }\n \n pub use crate::sys::ext::{io, arch, ffi};\n+\n+/// Functions for querying thread-related information.\n+pub mod thread {\n+    pub use crate::sys::abi::thread::current;\n+}"}, {"sha": "ad86acbb47de420c6ed67365fd2cf118c81a18f1", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -8,7 +8,7 @@\n //!\n //! The [`Command`] struct is used to configure and spawn processes:\n //!\n-//! ```\n+//! ```no_run\n //! use std::process::Command;\n //!\n //! let output = Command::new(\"echo\")"}, {"sha": "c383f21dcd752ae327a13ad9289977d2387467a2", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -190,7 +190,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }\n@@ -254,7 +254,7 @@ impl Condvar {\n     ///\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n     /// ```\n     #[unstable(feature = \"wait_until\", issue = \"47960\")]\n@@ -311,7 +311,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// loop {\n     ///     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n     ///     // 10 milliseconds have passed, or maybe the value changed!\n@@ -384,7 +384,7 @@ impl Condvar {\n     /// // wait for the thread to start up\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // as long as the value inside the `Mutex` is false, we wait\n+    /// // as long as the value inside the `Mutex<bool>` is `false`, we wait\n     /// loop {\n     ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n     ///     // 10 milliseconds have passed, or maybe the value changed!\n@@ -518,7 +518,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }\n@@ -558,7 +558,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n-    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n     ///     started = cvar.wait(started).unwrap();\n     /// }"}, {"sha": "3f2f6166a791a4433c316c1e9d90d9d25f44b7dd", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -35,21 +35,15 @@ impl TcpStream {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-        match bufs.iter_mut().find(|b| !b.is_empty()) {\n-            Some(buf) => self.read(buf),\n-            None => Ok(0),\n-        }\n+        io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         self.0.write(buf)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n-        match bufs.iter().find(|b| !b.is_empty()) {\n-            Some(buf) => self.write(buf),\n-            None => Ok(0),\n-        }\n+        io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     pub fn take_error(&self) -> Result<Option<Error>> {"}, {"sha": "c17fa2d00159ee305a1db0df35a248e714b4b350", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -4,6 +4,7 @@ use fortanix_sgx_abi::Tcs;\n /// all currently running threads in the enclave, and it is guaranteed to be\n /// constant for the lifetime of the thread. More specifically for SGX, there\n /// is a one-to-one correspondence of the ID to the address of the TCS.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn current() -> Tcs {\n     extern \"C\" { fn get_tcs_addr() -> Tcs; }\n     unsafe { get_tcs_addr() }"}, {"sha": "e167e917957f3f652b9dce3735f802c868bcb9fd", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -103,24 +103,16 @@ impl TcpStream {\n         self.inner.inner.read(buf)\n     }\n \n-    pub fn read_vectored(&self, buf: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n-        let buf = match buf.get_mut(0) {\n-            Some(buf) => buf,\n-            None => return Ok(0),\n-        };\n-        self.read(buf)\n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.write(buf)\n     }\n \n-    pub fn write_vectored(&self, buf: &[IoVec<'_>]) -> io::Result<usize> {\n-        let buf = match buf.get(0) {\n-            Some(buf) => buf,\n-            None => return Ok(0),\n-        };\n-        self.write(buf)\n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {"}, {"sha": "7ff098bc9e1237fd288beb1c2ecfa4a7cb8d9ea3", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -827,7 +827,10 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+#[cfg(not(any(target_os = \"linux\",\n+              target_os = \"android\",\n+              target_os = \"macos\",\n+              target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::fs::File;\n     if !from.is_file() {\n@@ -937,3 +940,85 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     writer.set_permissions(perm)?;\n     Ok(written)\n }\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    const COPYFILE_ACL: u32 = 1 << 0;\n+    const COPYFILE_STAT: u32 = 1 << 1;\n+    const COPYFILE_XATTR: u32 = 1 << 2;\n+    const COPYFILE_DATA: u32 = 1 << 3;\n+\n+    const COPYFILE_SECURITY: u32 = COPYFILE_STAT | COPYFILE_ACL;\n+    const COPYFILE_METADATA: u32 = COPYFILE_SECURITY | COPYFILE_XATTR;\n+    const COPYFILE_ALL: u32 = COPYFILE_METADATA | COPYFILE_DATA;\n+\n+    const COPYFILE_STATE_COPIED: u32 = 8;\n+\n+    #[allow(non_camel_case_types)]\n+    type copyfile_state_t = *mut libc::c_void;\n+    #[allow(non_camel_case_types)]\n+    type copyfile_flags_t = u32;\n+\n+    extern \"C\" {\n+        fn copyfile(\n+            from: *const libc::c_char,\n+            to: *const libc::c_char,\n+            state: copyfile_state_t,\n+            flags: copyfile_flags_t,\n+        ) -> libc::c_int;\n+        fn copyfile_state_alloc() -> copyfile_state_t;\n+        fn copyfile_state_free(state: copyfile_state_t) -> libc::c_int;\n+        fn copyfile_state_get(\n+            state: copyfile_state_t,\n+            flag: u32,\n+            dst: *mut libc::c_void,\n+        ) -> libc::c_int;\n+    }\n+\n+    struct FreeOnDrop(copyfile_state_t);\n+    impl Drop for FreeOnDrop {\n+        fn drop(&mut self) {\n+            // The code below ensures that `FreeOnDrop` is never a null pointer\n+            unsafe {\n+                // `copyfile_state_free` returns -1 if the `to` or `from` files\n+                // cannot be closed. However, this is not considerd this an\n+                // error.\n+                copyfile_state_free(self.0);\n+            }\n+        }\n+    }\n+\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    // We ensure that `FreeOnDrop` never contains a null pointer so it is\n+    // always safe to call `copyfile_state_free`\n+    let state = unsafe {\n+        let state = copyfile_state_alloc();\n+        if state.is_null() {\n+            return Err(crate::io::Error::last_os_error());\n+        }\n+        FreeOnDrop(state)\n+    };\n+\n+    cvt(unsafe {\n+        copyfile(\n+            cstr(from)?.as_ptr(),\n+            cstr(to)?.as_ptr(),\n+            state.0,\n+            COPYFILE_ALL,\n+        )\n+    })?;\n+\n+    let mut bytes_copied: libc::off_t = 0;\n+    cvt(unsafe {\n+        copyfile_state_get(\n+            state.0,\n+            COPYFILE_STATE_COPIED,\n+            &mut bytes_copied as *mut libc::off_t as *mut libc::c_void,\n+        )\n+    })?;\n+    Ok(bytes_copied as u64)\n+}"}, {"sha": "c1af6ec12623c51bf7d9509b398f41e7452157d7", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -49,7 +49,6 @@ unsafe impl GlobalAlloc for System {\n \n #[cfg(target_feature = \"atomics\")]\n mod lock {\n-    use crate::arch::wasm32;\n     use crate::sync::atomic::{AtomicI32, Ordering::SeqCst};\n \n     static LOCKED: AtomicI32 = AtomicI32::new(0);\n@@ -61,27 +60,93 @@ mod lock {\n             if LOCKED.swap(1, SeqCst) == 0 {\n                 return DropLock\n             }\n-            unsafe {\n-                let r = wasm32::i32_atomic_wait(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1,  // expected value\n-                    -1, // timeout\n-                );\n-                debug_assert!(r == 0 || r == 1);\n-            }\n+            // Ok so here's where things get a little depressing. At this point\n+            // in time we need to synchronously acquire a lock, but we're\n+            // contending with some other thread. Typically we'd execute some\n+            // form of `i32.atomic.wait` like so:\n+            //\n+            //     unsafe {\n+            //         let r = core::arch::wasm32::i32_atomic_wait(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1,  //     expected value\n+            //             -1, //     timeout\n+            //         );\n+            //         debug_assert!(r == 0 || r == 1);\n+            //     }\n+            //\n+            // Unfortunately though in doing so we would cause issues for the\n+            // main thread. The main thread in a web browser *cannot ever\n+            // block*, no exceptions. This means that the main thread can't\n+            // actually execute the `i32.atomic.wait` instruction.\n+            //\n+            // As a result if we want to work within the context of browsers we\n+            // need to figure out some sort of allocation scheme for the main\n+            // thread where when there's contention on the global malloc lock we\n+            // do... something.\n+            //\n+            // Possible ideas include:\n+            //\n+            // 1. Attempt to acquire the global lock. If it fails, fall back to\n+            //    memory allocation via `memory.grow`. Later just ... somehow\n+            //    ... inject this raw page back into the main allocator as it\n+            //    gets sliced up over time. This strategy has the downside of\n+            //    forcing allocation of a page to happen whenever the main\n+            //    thread contents with other threads, which is unfortunate.\n+            //\n+            // 2. Maintain a form of \"two level\" allocator scheme where the main\n+            //    thread has its own allocator. Somehow this allocator would\n+            //    also be balanced with a global allocator, not only to have\n+            //    allocations cross between threads but also to ensure that the\n+            //    two allocators stay \"balanced\" in terms of free'd memory and\n+            //    such. This, however, seems significantly complicated.\n+            //\n+            // Out of a lack of other ideas, the current strategy implemented\n+            // here is to simply spin. Typical spin loop algorithms have some\n+            // form of \"hint\" here to the CPU that it's what we're doing to\n+            // ensure that the CPU doesn't get too hot, but wasm doesn't have\n+            // such an instruction.\n+            //\n+            // To be clear, spinning here is not a great solution.\n+            // Another thread with the lock may take quite a long time to wake\n+            // up. For example it could be in `memory.grow` or it could be\n+            // evicted from the CPU for a timeslice like 10ms. For these periods\n+            // of time our thread will \"helpfully\" sit here and eat CPU time\n+            // until it itself is evicted or the lock holder finishes. This\n+            // means we're just burning and wasting CPU time to no one's\n+            // benefit.\n+            //\n+            // Spinning does have the nice properties, though, of being\n+            // semantically correct, being fair to all threads for memory\n+            // allocation, and being simple enough to implement.\n+            //\n+            // This will surely (hopefully) be replaced in the future with a\n+            // real memory allocator that can handle the restriction of the main\n+            // thread.\n+            //\n+            //\n+            // FIXME: We can also possibly add an optimization here to detect\n+            // when a thread is the main thread or not and block on all\n+            // non-main-thread threads. Currently, however, we have no way\n+            // of knowing which wasm thread is on the browser main thread, but\n+            // if we could figure out we could at least somewhat mitigate the\n+            // cost of this spinning.\n         }\n     }\n \n     impl Drop for DropLock {\n         fn drop(&mut self) {\n             let r = LOCKED.swap(0, SeqCst);\n             debug_assert_eq!(r, 1);\n-            unsafe {\n-                wasm32::atomic_notify(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1, // only one thread\n-                );\n-            }\n+\n+            // Note that due to the above logic we don't actually need to wake\n+            // anyone up, but if we did it'd likely look something like this:\n+            //\n+            //     unsafe {\n+            //         core::arch::wasm32::atomic_notify(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1, //     only one thread\n+            //         );\n+            //     }\n         }\n     }\n }"}, {"sha": "b38727830f37f11c64a4acb9e858438612c95a50", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -37,9 +37,9 @@ pub struct Pipes {\n ///\n /// The ours/theirs pipes are *not* specifically readable or writable. Each\n /// one only supports a read or a write, but which is which depends on the\n-/// boolean flag given. If `ours_readable` is true then `ours` is readable where\n-/// `theirs` is writable. Conversely if `ours_readable` is false then `ours` is\n-/// writable where `theirs` is readable.\n+/// boolean flag given. If `ours_readable` is `true`, then `ours` is readable and\n+/// `theirs` is writable. Conversely, if `ours_readable` is `false`, then `ours`\n+/// is writable and `theirs` is readable.\n ///\n /// Also note that the `ours` pipe is always a handle opened up in overlapped\n /// mode. This means that technically speaking it should only ever be used"}, {"sha": "4c86f70ad871d6df5617bc4828ab5f7513081a56", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -712,13 +712,6 @@ mod tests {\n         assert_almost_eq!(a - second + second, a);\n         assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n-        // A difference of 80 and 800 years cannot fit inside a 32-bit time_t\n-        if !(cfg!(unix) && crate::mem::size_of::<libc::time_t>() <= 4) {\n-            let eighty_years = second * 60 * 60 * 24 * 365 * 80;\n-            assert_almost_eq!(a - eighty_years + eighty_years, a);\n-            assert_almost_eq!(a - (eighty_years * 10) + (eighty_years * 10), a);\n-        }\n-\n         let one_second_from_epoch = UNIX_EPOCH + Duration::new(1, 0);\n         let one_second_from_epoch2 = UNIX_EPOCH + Duration::new(0, 500_000_000)\n             + Duration::new(0, 500_000_000);\n@@ -747,8 +740,8 @@ mod tests {\n     #[test]\n     fn since_epoch() {\n         let ts = SystemTime::now();\n-        let a = ts.duration_since(UNIX_EPOCH).unwrap();\n-        let b = ts.duration_since(UNIX_EPOCH - Duration::new(1, 0)).unwrap();\n+        let a = ts.duration_since(UNIX_EPOCH + Duration::new(1, 0)).unwrap();\n+        let b = ts.duration_since(UNIX_EPOCH).unwrap();\n         assert!(b > a);\n         assert_eq!(b - a, Duration::new(1, 0));\n "}, {"sha": "2abb7e407eb026d1d22f94f51ef8ca91d131c253", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -24,8 +24,8 @@ pub struct StripUnconfigured<'a> {\n }\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition)\n-                -> (ast::Crate, Features) {\n+pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition,\n+                allow_features: &Option<Vec<String>>) -> (ast::Crate, Features) {\n     let features;\n     {\n         let mut strip_unconfigured = StripUnconfigured {\n@@ -43,7 +43,7 @@ pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition)\n             return (krate, Features::new());\n         }\n \n-        features = get_features(&sess.span_diagnostic, &krate.attrs, edition);\n+        features = get_features(&sess.span_diagnostic, &krate.attrs, edition, allow_features);\n \n         // Avoid reconfiguring malformed `cfg_attr`s\n         if err_count == sess.span_diagnostic.err_count() {"}, {"sha": "ac24475cab89fa1d6c614c3e2c3d9bd9f6a1e6d0", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -378,6 +378,21 @@ Erroneous code example:\n \n \"##,\n \n+E0725: r##\"\n+A feature attribute named a feature that was disallowed in the compiler\n+command line flags.\n+\n+Erroneous code example:\n+\n+```ignore (can't specify compiler flags from doctests)\n+#![feature(never_type)] // error: the feature `never_type` is not in\n+                        // the list of allowed features\n+```\n+\n+Delete the offending feature attribute, or add it to the list of allowed\n+features in the `-Z allow_features` flag.\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "280b17da0be3f313e538d9c9a6a22a1313af50c4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1042,7 +1042,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n                                              \"rustc_attrs\",\n                                              \"internal rustc attributes will never be stable\",\n                                              cfg_fn!(rustc_attrs))),\n-    (\"rustc_item_path\", Whitelisted, template!(Word), Gated(Stability::Unstable,\n+    (\"rustc_def_path\", Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                            \"rustc_attrs\",\n                                            \"internal rustc attributes will never be stable\",\n                                            cfg_fn!(rustc_attrs))),\n@@ -2008,7 +2008,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n }\n \n pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n-                    crate_edition: Edition) -> Features {\n+                    crate_edition: Edition, allow_features: &Option<Vec<String>>) -> Features {\n     fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n         let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n         if let Some(reason) = reason {\n@@ -2127,6 +2127,15 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             }\n \n             if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n+                if let Some(allowed) = allow_features.as_ref() {\n+                    if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                        span_err!(span_handler, mi.span, E0725,\n+                                  \"the feature `{}` is not in the list of allowed features\",\n+                                  name);\n+                        continue;\n+                    }\n+                }\n+\n                 set(&mut features, mi.span);\n                 features.declared_lang_features.push((name, mi.span, None));\n                 continue"}, {"sha": "22af7d47fd0a1fe6736bab98aac875feb383d416", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -5116,12 +5116,8 @@ impl<'a> Parser<'a> {\n \n                 let ident = self.parse_ident()?;\n                 let (delim, tokens) = self.expect_delimited_token_tree()?;\n-                if delim != MacDelimiter::Brace {\n-                    if !self.eat(&token::Semi) {\n-                        let msg = \"macros that expand to items must either \\\n-                                   be surrounded with braces or followed by a semicolon\";\n-                        self.span_err(self.prev_span, msg);\n-                    }\n+                if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                    self.report_invalid_macro_expansion_item();\n                 }\n \n                 (ident, ast::MacroDef { tokens: tokens, legacy: true })\n@@ -5264,13 +5260,8 @@ impl<'a> Parser<'a> {\n                 // if it has a special ident, it's definitely an item\n                 //\n                 // Require a semicolon or braces.\n-                if style != MacStmtStyle::Braces {\n-                    if !self.eat(&token::Semi) {\n-                        self.span_err(self.prev_span,\n-                                      \"macros that expand to items must \\\n-                                       either be surrounded with braces or \\\n-                                       followed by a semicolon\");\n-                    }\n+                if style != MacStmtStyle::Braces && !self.eat(&token::Semi) {\n+                    self.report_invalid_macro_expansion_item();\n                 }\n                 let span = lo.to(hi);\n                 Stmt {\n@@ -8360,13 +8351,8 @@ impl<'a> Parser<'a> {\n             };\n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace {\n-                if !self.eat(&token::Semi) {\n-                    self.span_err(self.prev_span,\n-                                  \"macros that expand to items must either \\\n-                                   be surrounded with braces or followed by \\\n-                                   a semicolon\");\n-                }\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n             }\n \n             let hi = self.prev_span;\n@@ -8597,6 +8583,25 @@ impl<'a> Parser<'a> {\n             }\n         }\n     }\n+\n+    fn report_invalid_macro_expansion_item(&self) {\n+        self.struct_span_err(\n+            self.prev_span,\n+            \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n+        ).multipart_suggestion(\n+            \"change the delimiters to curly braces\",\n+            vec![\n+                (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), String::from(\" {\")),\n+                (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        ).span_suggestion(\n+            self.sess.source_map.next_point(self.prev_span),\n+            \"add a semicolon\",\n+            ';'.to_string(),\n+            Applicability::MaybeIncorrect,\n+        ).emit();\n+    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "4fc9fb8245abe24680192535870c4522644a4212", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1 +1 @@\n-Subproject commit 38ad31bde8ff681d862dc0f96930a5dd9b7a472e\n+Subproject commit 4fc9fb8245abe24680192535870c4522644a4212"}, {"sha": "bde98b44544d6b2f0af5cf11bf42227f90133072", "filename": "src/test/debuginfo/auxiliary/issue-13213-aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fissue-13213-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fissue-13213-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fissue-13213-aux.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/debuginfo/auxiliary/issue13213aux.rs"}, {"sha": "3c9a365fd4f7b3c6a4077716e9ef151d105f0f2b", "filename": "src/test/debuginfo/issue-13213.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fdebuginfo%2Fissue-13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fdebuginfo%2Fissue-13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue-13213.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,15 +1,15 @@\n // min-lldb-version: 310\n \n-// aux-build:issue13213aux.rs\n+// aux-build:issue-13213-aux.rs\n \n-extern crate issue13213aux;\n+extern crate issue_13213_aux;\n \n // compile-flags:-g\n \n // This tests make sure that we get no linker error when using a completely inlined static. Some\n // statics that are marked with AvailableExternallyLinkage in the importing crate, may actually not\n // be available because they have been optimized out from the exporting crate.\n fn main() {\n-    let b: issue13213aux::S = issue13213aux::A;\n+    let b: issue_13213_aux::S = issue_13213_aux::A;\n     println!(\"Nothing to do here...\");\n }"}, {"sha": "bfa7abb1a9d052163c944d6202ded5c354fe5869", "filename": "src/test/incremental/auxiliary/issue-49482-macro-def.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-49482-macro-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-49482-macro-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-49482-macro-def.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/incremental/auxiliary/issue_49482_macro_def.rs"}, {"sha": "39f19e3f15f245b0d7460387ae09009df927c7e2", "filename": "src/test/incremental/auxiliary/issue-49482-reexport.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-49482-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-49482-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-49482-reexport.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/incremental/auxiliary/issue_49482_reexport.rs"}, {"sha": "fa2814a77f2b95ec5ffdb71066199a6d8ffb8fc7", "filename": "src/test/incremental/auxiliary/issue-54059.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-54059.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-54059.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-54059.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/incremental/auxiliary/issue_54059.rs"}, {"sha": "042ecc0f27954c0663b5c194a2a55f5073968970", "filename": "src/test/incremental/issue-49482.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fissue-49482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fissue-49482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-49482.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,5 +1,5 @@\n-// aux-build:issue_49482_macro_def.rs\n-// aux-build:issue_49482_reexport.rs\n+// aux-build:issue-49482-macro-def.rs\n+// aux-build:issue-49482-reexport.rs\n // revisions: rpass1\n \n extern crate issue_49482_reexport;"}, {"sha": "ada93f79b261d7303210515d23ee3b136362c8e0", "filename": "src/test/incremental/issue-49595/issue-49595.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue-49595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue-49595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue-49595.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/incremental/issue-49595/issue_49595.rs"}, {"sha": "0a5a547509f6922ac3f4dbdf5bf0cf30446aba95", "filename": "src/test/incremental/issue-54059.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fissue-54059.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fincremental%2Fissue-54059.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-54059.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:issue_54059.rs\n+// aux-build:issue-54059.rs\n // ignore-wasm32-bare no libc for ffi testing\n // ignore-windows - dealing with weird symbols issues on dylibs isn't worth it\n // revisions: rpass1"}, {"sha": "3ce43cc4a224fa1f443145bbffba5aaaca0246b7", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -35,7 +35,7 @@ fn main() {\n //        _2 = move _3;\n //        StorageDead(_3);\n //        StorageLive(_4);\n-//        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//        _4 = std::option::Option::<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n //        AscribeUserType(_4, o, UserTypeProjection { base: UserType(1), projs: [] });\n //        StorageLive(_5);"}, {"sha": "5a461d61482546f65e1b121418ec474f5eed64a7", "filename": "src/test/mir-opt/issue-41697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41697.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,7 +1,7 @@\n // Regression test for #41697. Using dump-mir was triggering\n // artificial cycles: during type-checking, we had to get the MIR for\n // the constant expressions in `[u8; 2]`, which in turn would trigger\n-// an attempt to get the item-path, which in turn would request the\n+// an attempt to get the def-path, which in turn would request the\n // types of the impl, which would trigger a cycle. We suppressed this\n // cycle now by forcing mir-dump to avoid asking for types of an impl.\n "}, {"sha": "9eeef8570a37a307f86bd0e0f0fb90d075c6cabc", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -42,7 +42,7 @@ fn main() {\n // START rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n //  bb0: {\n //      ...\n-//      _2 = std::option::Option<i32>::Some(const 42i32,);\n+//      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n //      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb7];\n@@ -111,7 +111,7 @@ fn main() {\n // START rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n //  bb0: {\n //      ...\n-//      _2 = std::option::Option<i32>::Some(const 42i32,);\n+//      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n //      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb7];\n@@ -180,7 +180,7 @@ fn main() {\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n // bb0: {\n //     ...\n-//      _2 = std::option::Option<i32>::Some(const 1i32,);\n+//      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n //      switchInt(move _3) -> [1isize: bb2, otherwise: bb3];"}, {"sha": "3b333b5431c3e995dd5f02bb718abab16344a03e", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -98,7 +98,7 @@ fn main() {\n // }\n // END rustc.main.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &[closure@HirId { owner: DefIndex(0:7), local_id: 70 }], _2: &i32) -> &i32 {\n+// fn main::{{closure}}#0(_1: &[closure@HirId { owner: DefIndex(0:7), local_id: 70 }], _2: &i32) -> &i32 {\n //     ...\n //     bb0: {\n //         Retag([fn entry] _1);"}, {"sha": "9a22f57116ed89f7a0997e2d32a494a096f39daf", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -18,7 +18,7 @@ fn main() {\n //         StorageLive(_4);\n //         StorageLive(_5);\n //         _5 = _1;\n-//         _4 = std::option::Option<i32>::Some(move _5,);\n+//         _4 = std::option::Option::<i32>::Some(move _5,);\n //         StorageDead(_5);\n //         _3 = &_4;\n //         FakeRead(ForLet, _3);"}, {"sha": "ced30381fda68cb0f81a16151a9f3005297456bb", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -7,11 +7,18 @@ impl A {\n     const ASSOCIATED_CONSTANT: i32 = 2;\n }\n \n+// See #59021\n+enum Test {\n+    X(usize),\n+    Y { a: usize },\n+}\n+\n enum E {\n     V = 5,\n }\n \n fn main() {\n+    let f = Test::X as fn(usize) -> Test;\n     let v = Vec::<i32>::new();\n }\n \n@@ -64,3 +71,14 @@ fn main() {\n //     _3 = const std::ops::Drop::drop(move _2) -> [return: bb6, unwind: bb5];\n // }\n // END rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir\n+\n+// START rustc.Test-X.mir_map.0.mir\n+// fn Test::X(_1: usize) -> Test {\n+//     let mut _0: Test;\n+//\n+//     bb0: {\n+//         _0 = Test::X(move _1,);\n+//         return;\n+//     }\n+// }\n+// END rustc.Test-X.mir_map.0.mir"}, {"sha": "1a9e85c42d8fb95411a06e3fc6a4711cfc2d940f", "filename": "src/test/pretty/issue-12590-a.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-12590-a.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2,6 +2,7 @@\n \n // The next line should not be expanded\n \n+#[path = \"issue-12590-b.rs\"]\n mod issue_12590_b;\n \n fn main() { }", "previous_filename": "src/test/pretty/issue_12590_a.rs"}, {"sha": "b14c7afa22142aaec9fd3ba2eeee702c5d355ad0", "filename": "src/test/pretty/issue-12590-b.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-12590-b.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,5 @@\n+// Second part of two-file test\n+\n+fn b() { }\n+\n+fn main() { }"}, {"sha": "1761c0653ce86f051d029afed5070f63e912c0e3", "filename": "src/test/pretty/issue-12590-c.pp", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-c.pp", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-c.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-12590-c.pp?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -6,10 +6,11 @@\n extern crate std;\n // pretty-compare-only\n // pretty-mode:expanded\n-// pp-exact:issue_12590_c.pp\n+// pp-exact:issue-12590-c.pp\n \n // The next line should be expanded\n \n+#[path = \"issue-12590-b.rs\"]\n mod issue_12590_b {\n \n     fn b() { }", "previous_filename": "src/test/pretty/issue_12590_c.pp"}, {"sha": "2cc444edda3d7f1d0900add319b5dbe7703ffe98", "filename": "src/test/pretty/issue-12590-c.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-12590-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-12590-c.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,9 +1,10 @@\n // pretty-compare-only\n // pretty-mode:expanded\n-// pp-exact:issue_12590_c.pp\n+// pp-exact:issue-12590-c.pp\n \n // The next line should be expanded\n \n+#[path = \"issue-12590-b.rs\"]\n mod issue_12590_b;\n \n fn main() { }", "previous_filename": "src/test/pretty/issue_12590_c.rs"}, {"sha": "ad663412e77768505d34156a85313ed0afd900e4", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -32,27 +32,27 @@\n                   (($crate::fmt::format as\n                        for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<$crate::fmt::Arguments>::new_v1\n                                                                                                            as\n-                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n+                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                            as\n+                                                                                                                                                                                                                            &'static str)]\n                                                                                                                                                                                                                           as\n-                                                                                                                                                                                                                          &'static str)]\n+                                                                                                                                                                                                                          [&str; 1])\n                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                        [&str; 1])\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      &[&str; 1]),\n-                                                                                                                                                                                                                  (&(match (()\n+                                                                                                                                                                                                                        &[&str; 1]),\n+                                                                                                                                                                                                                    (&(match (()\n+                                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                                 ())\n+                                                                                                                                                                                                                           {\n+                                                                                                                                                                                                                           ()\n+                                                                                                                                                                                                                           =>\n+                                                                                                                                                                                                                           ([]\n                                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                               ())\n-                                                                                                                                                                                                                         {\n-                                                                                                                                                                                                                         ()\n-                                                                                                                                                                                                                         =>\n-                                                                                                                                                                                                                         ([]\n-                                                                                                                                                                                                                             as\n-                                                                                                                                                                                                                             [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                     }\n+                                                                                                                                                                                                                               [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                       }\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          [std::fmt::ArgumentV1<'_>; 0])\n                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                                                                                                                        &[std::fmt::ArgumentV1<'_>; 0]))\n                                                                                                           as\n                                                                                                           std::fmt::Arguments<'_>))\n                       as std::string::String);"}, {"sha": "f188f7bca698379a9a2495c8bc77983d96691009", "filename": "src/test/pretty/issue_12590_b.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Ftest%2Fpretty%2Fissue_12590_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5f171da2486c34e4e473c97a1468279d05e7c/src%2Ftest%2Fpretty%2Fissue_12590_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue_12590_b.rs?ref=eeb5f171da2486c34e4e473c97a1468279d05e7c", "patch": "@@ -1,4 +0,0 @@\n-// Second part of two file test\n-fn b() { }\n-\n-fn main() { }"}, {"sha": "4d6ff47a3ee918666b944fd64676f1043982221d", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-partial-eq.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs"}, {"sha": "699972c9a85bd458ca0153d4c78fd3e8bc97b3c0", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs"}, {"sha": "874a0ec7c13fba640680bc324d34e4521b1fd89e", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs"}, {"sha": "2c6a6034806bdc1a4488a47d518bb87e5aeb1b8e", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-24106.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-24106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-24106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-24106.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/issue_24106.rs"}, {"sha": "f34e10218d455f3222df9e95828711c094c1f211", "filename": "src/test/run-pass-fulldeps/auxiliary/lint-for-crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/lint_for_crate.rs"}, {"sha": "b5307446bca052d2ff8c79d530f40728d03c3651", "filename": "src/test/run-pass-fulldeps/auxiliary/llvm-pass-plugin.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/llvm_pass_plugin.rs"}, {"sha": "a2b1d6976d0eb7e0db2c0ca96712b6fff5c4cfea", "filename": "src/test/run-pass-fulldeps/auxiliary/macro-crate-test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs"}, {"sha": "309acb25184a8f54b6c898c8bc19d2e7f4b60c65", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs"}, {"sha": "216c81ca34ce5bc170bcfc3c458a518df466ae53", "filename": "src/test/run-pass-fulldeps/auxiliary/roman-numerals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman-numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman-numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman-numerals.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/roman_numerals.rs"}, {"sha": "8b00fb81cd25935d2991034d978b5e9f5b226d80", "filename": "src/test/run-pass-fulldeps/auxiliary/syntax-extension-with-dll-deps-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax-extension-with-dll-deps-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax-extension-with-dll-deps-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax-extension-with-dll-deps-1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass-fulldeps/auxiliary/syntax_extension_with_dll_deps_1.rs"}, {"sha": "ac8fff4f6bfad0c49b0407dc389117163c79d51b", "filename": "src/test/run-pass-fulldeps/custom-derive-partial-eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:custom_derive_partial_eq.rs\n+// aux-build:custom-derive-partial-eq.rs\n // ignore-stage1\n #![feature(plugin)]\n #![plugin(custom_derive_partial_eq)]"}, {"sha": "38eaa71dd6abaa8fd455ac27c7b229b6cdd85864", "filename": "src/test/run-pass-fulldeps/derive-totalsum-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:custom_derive_plugin_attr.rs\n+// aux-build:custom-derive-plugin-attr.rs\n // ignore-stage1\n \n #![feature(plugin, rustc_attrs)]"}, {"sha": "2b0bb51d90aec59a345e384140c3074aaada1613", "filename": "src/test/run-pass-fulldeps/derive-totalsum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:custom_derive_plugin.rs\n+// aux-build:custom-derive-plugin.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "2add3ccbe36f2f05a7160320b78297d5dccfeac2", "filename": "src/test/run-pass-fulldeps/issue-15778-pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:lint_for_crate.rs\n+// aux-build:lint-for-crate.rs\n // ignore-stage1\n // compile-flags: -D crate-not-okay\n "}, {"sha": "e8e85ff33772e1985f206828df99795f6c39f53f", "filename": "src/test/run-pass-fulldeps/issue-24106.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fissue-24106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fissue-24106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-24106.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:issue_24106.rs\n+// aux-build:issue-24106.rs\n \n extern crate issue_24106;\n ", "previous_filename": "src/test/run-pass-fulldeps/issue_24106.rs"}, {"sha": "133f6302bde57cf15834f7801b95f6f9e2c526d3", "filename": "src/test/run-pass-fulldeps/issue-40663.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,5 +1,5 @@\n #![allow(dead_code)]\n-// aux-build:custom_derive_plugin.rs\n+// aux-build:custom-derive-plugin.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "411631104a4bc258bf8158537873e352bbc780a8", "filename": "src/test/run-pass-fulldeps/llvm-pass-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fllvm-pass-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fllvm-pass-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fllvm-pass-plugin.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:llvm_pass_plugin.rs\n+// aux-build:llvm-pass-plugin.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "573bfca31683fb6e8ff180de85fc6be1034677bd", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2,7 +2,7 @@\n #![allow(dead_code)]\n #![allow(unused_variables)]\n #![allow(unused_imports)]\n-// aux-build:macro_crate_test.rs\n+// aux-build:macro-crate-test.rs\n // ignore-stage1\n \n #![feature(rustc_attrs)]"}, {"sha": "1bdf004e3052ff8a9c48145a60ac7c5a6a9a57f1", "filename": "src/test/run-pass-fulldeps/plugin-args-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:plugin_args.rs\n+// aux-build:plugin-args.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "83091df058283bec6b631fece03410b988b11225", "filename": "src/test/run-pass-fulldeps/plugin-args-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-2.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:plugin_args.rs\n+// aux-build:plugin-args.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "9cd9bee5a0fe9eec74f12bc299715015eac7937d", "filename": "src/test/run-pass-fulldeps/plugin-args-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-args-3.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:plugin_args.rs\n+// aux-build:plugin-args.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "49c12e426fee2c087e7736a7498cbeea558c90b4", "filename": "src/test/run-pass-fulldeps/roman-numerals-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Froman-numerals-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Froman-numerals-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Froman-numerals-macro.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,4 +1,4 @@\n-// aux-build:roman_numerals.rs\n+// aux-build:roman-numerals.rs\n // ignore-stage1\n \n #![feature(plugin)]"}, {"sha": "cf6e6f72316384812aa6ed749f7e6d1b66bd751f", "filename": "src/test/run-pass-fulldeps/undef_mask.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fundef_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass-fulldeps%2Fundef_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fundef_mask.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,26 @@\n+// ignore-cross-compile\n+// ignore-stage1\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc;\n+\n+use rustc::mir::interpret::UndefMask;\n+use rustc::ty::layout::Size;\n+\n+fn main() {\n+    let mut mask = UndefMask::new(Size::from_bytes(500), false);\n+    assert!(!mask.get(Size::from_bytes(499)));\n+    mask.set(Size::from_bytes(499), true);\n+    assert!(mask.get(Size::from_bytes(499)));\n+    mask.set_range_inbounds(Size::from_bytes(100), Size::from_bytes(256), true);\n+    for i in 0..100 {\n+        assert!(!mask.get(Size::from_bytes(i)));\n+    }\n+    for i in 100..256 {\n+        assert!(mask.get(Size::from_bytes(i)));\n+    }\n+    for i in 256..499 {\n+        assert!(!mask.get(Size::from_bytes(i)));\n+    }\n+}"}, {"sha": "cd2c17220655af8db2f75cabf74458b14f3d7f8a", "filename": "src/test/run-pass/array-slice-vec/estr-slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray-slice-vec%2Festr-slice.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n \n     let z : &str = \"thing\";\n     assert_eq!(v, x);\n-    assert!(x != z);\n+    assert_ne!(x, z);\n \n     let a = \"aaaa\";\n     let b = \"bbbb\";\n@@ -26,23 +26,23 @@ pub fn main() {\n \n     assert!(a < b);\n     assert!(a <= b);\n-    assert!(a != b);\n+    assert_ne!(a, b);\n     assert!(b >= a);\n     assert!(b > a);\n \n     println!(\"{}\", b);\n \n     assert!(a < c);\n     assert!(a <= c);\n-    assert!(a != c);\n+    assert_ne!(a, c);\n     assert!(c >= a);\n     assert!(c > a);\n \n     println!(\"{}\", c);\n \n     assert!(c < cc);\n     assert!(c <= cc);\n-    assert!(c != cc);\n+    assert_ne!(c, cc);\n     assert!(cc >= c);\n     assert!(cc > c);\n "}, {"sha": "f5e8c3d2a5c87c7b623e315291bcdadda07da445", "filename": "src/test/run-pass/auxiliary/rmeta-rlib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta-rlib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/auxiliary/rmeta_rlib.rs"}, {"sha": "4a6d055a81fabf8edc1567e8b0d2688856ee657d", "filename": "src/test/run-pass/auxiliary/rmeta-rmeta.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta-rmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta-rmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta-rmeta.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/auxiliary/rmeta_rmeta.rs"}, {"sha": "86b0977bebe1d5a3f2821d5e6a9423ed3a5a99b4", "filename": "src/test/run-pass/issue-55809.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-55809.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,30 @@\n+// edition:2018\n+// run-pass\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+trait Foo { }\n+\n+impl Foo for () { }\n+\n+impl<'a, T> Foo for &'a mut T where T: Foo { }\n+\n+async fn foo_async<T>(_v: T) -> u8 where T: Foo {\n+    0\n+}\n+\n+async fn bad<T>(v: T) -> u8 where T: Foo {\n+    await!(foo_async(v))\n+}\n+\n+async fn async_main() {\n+    let mut v = ();\n+\n+    let _ = await!(bad(&mut v));\n+    let _ = await!(foo_async(&mut v));\n+    let _ = await!(bad(v));\n+}\n+\n+fn main() {\n+    let _ = async_main();\n+}"}, {"sha": "e2abeb99ea829af8a9f3b437d71bec4bd4afe8b3", "filename": "src/test/run-pass/issues/auxiliary/issue-10031-aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-10031-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-10031-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-10031-aux.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_10031_aux.rs"}, {"sha": "01f5a784bb79c95a4cc859e0e42f1618d4431f8f", "filename": "src/test/run-pass/issues/auxiliary/issue-12612-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-12612-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-12612-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-12612-1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_12612_1.rs"}, {"sha": "2c7247871936fe06b74cd585fe9a3aba912c0119", "filename": "src/test/run-pass/issues/auxiliary/issue-12612-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-12612-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-12612-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-12612-2.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_12612_2.rs"}, {"sha": "c91013043eb7745766d6980db92aac3af5f3b7fc", "filename": "src/test/run-pass/issues/auxiliary/issue-13507.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-13507.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue13507.rs"}, {"sha": "31359e86559dd14907a74ed552269a5b9f0ebe07", "filename": "src/test/run-pass/issues/auxiliary/issue-19293.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-19293.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-19293.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-19293.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_19293.rs"}, {"sha": "ae6d44eeb7703ffa72640d6883a75177cb1ad53b", "filename": "src/test/run-pass/issues/auxiliary/issue-20389.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-20389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-20389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-20389.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_20389.rs"}, {"sha": "a99385a834dfb5fb2e3b9371324ce414336ff8bd", "filename": "src/test/run-pass/issues/auxiliary/issue-2170-lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2170-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2170-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2170-lib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue2170lib.rs"}, {"sha": "418ddc0b06926078f293e50ee8e2296ac9fc002e", "filename": "src/test/run-pass/issues/auxiliary/issue-2316-a.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2316-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2316-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2316-a.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_2316_a.rs"}, {"sha": "550c2d6eb226d318556ced01b86813299f0331a6", "filename": "src/test/run-pass/issues/auxiliary/issue-2316-b.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2316-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2316-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2316-b.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_2316_b.rs"}, {"sha": "0d151520fe07908c7db0706e2c8411e65be8fceb", "filename": "src/test/run-pass/issues/auxiliary/issue-2472-b.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2472-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2472-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2472-b.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_2472_b.rs"}, {"sha": "661b46d829dfe4935e43df7dda321fb42cc534f5", "filename": "src/test/run-pass/issues/auxiliary/issue-2723-a.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2723-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2723-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-2723-a.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_2723_a.rs"}, {"sha": "cd5fd3145055c56a8917c2a83866e6ab9af86f4b", "filename": "src/test/run-pass/issues/auxiliary/issue-3136-a.rc", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3136-a.rc", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3136-a.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3136-a.rc?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,3 +1,4 @@\n #![crate_type = \"lib\"]\n \n+#[path = \"issue-3136-a.rs\"]\n pub mod issue_3136_a;", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_3136_a.rc"}, {"sha": "9bb546ab393b13ad0466ee22f82ebddf2ede1e12", "filename": "src/test/run-pass/issues/auxiliary/issue-3136-a.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3136-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3136-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3136-a.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_3136_a.rs"}, {"sha": "09c69b90329ffd8ddff9329c6550b4ecc2709497", "filename": "src/test/run-pass/issues/auxiliary/issue-34796-aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-34796-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-34796-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-34796-aux.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue34796aux.rs"}, {"sha": "373e646ba2c397959b841519a6c901c79cb8416d", "filename": "src/test/run-pass/issues/auxiliary/issue-38190.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38190.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_38190.rs"}, {"sha": "f968017199f50e44319f7ad8c60912f50c00b587", "filename": "src/test/run-pass/issues/auxiliary/issue-38226-aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38226-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38226-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38226-aux.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_38226_aux.rs"}, {"sha": "15d072957cbd8292639e7abd96225a7a50ccf386", "filename": "src/test/run-pass/issues/auxiliary/issue-38715-modern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38715-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38715-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38715-modern.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_38715-modern.rs"}, {"sha": "5c15073f5a5e687a65621ddbb9d7aaea5437f0e8", "filename": "src/test/run-pass/issues/auxiliary/issue-38715.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-38715.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_38715.rs"}, {"sha": "5d03a0e9e993134aab66c3e51635d39f97a6294c", "filename": "src/test/run-pass/issues/auxiliary/issue-3979-traits.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3979-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3979-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-3979-traits.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_3979_traits.rs"}, {"sha": "3af9c68f2331d6781b1cccf0fe3780cad475a27b", "filename": "src/test/run-pass/issues/auxiliary/issue-39823.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-39823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-39823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-39823.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_39823.rs"}, {"sha": "4f2f41f2cde64c5200ba382c1152c3cd7cea1067", "filename": "src/test/run-pass/issues/auxiliary/issue-40469.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-40469.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-40469.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-40469.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_40469.rs"}, {"sha": "ae73c3e780fb3c902ea6d0f2b426952c5f597385", "filename": "src/test/run-pass/issues/auxiliary/issue-41053.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-41053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-41053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-41053.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_41053.rs"}, {"sha": "95119a589c99dcbfa53b3430b9efdf20a0fb9c11", "filename": "src/test/run-pass/issues/auxiliary/issue-42007-s.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-42007-s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-42007-s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-42007-s.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_42007_s.rs"}, {"sha": "e35dbbfabfcddd93c7ce8dff0abc6d64a2a2fb02", "filename": "src/test/run-pass/issues/auxiliary/issue-8401.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-8401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-8401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-8401.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_8401.rs"}, {"sha": "60af53359e8adb8bb982b95bc9d26c1345554565", "filename": "src/test/run-pass/issues/auxiliary/issue-9123.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9123.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_9123.rs"}, {"sha": "049a96a655a3a22c3189110c6c017c4e5d3c2e18", "filename": "src/test/run-pass/issues/auxiliary/issue-9155.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9155.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_9155.rs"}, {"sha": "3bc5697a1a68906c4c5ae866de9f542c843e8409", "filename": "src/test/run-pass/issues/auxiliary/issue-9188.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fauxiliary%2Fissue-9188.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/auxiliary/issue_9188.rs"}, {"sha": "136df05c2397a0b0e1a2115d7747f2c107e0c861", "filename": "src/test/run-pass/issues/issue-10031.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-10031.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-10031.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-10031.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// aux-build:issue_10031_aux.rs\n+// aux-build:issue-10031-aux.rs\n // pretty-expanded FIXME #23616\n \n extern crate issue_10031_aux;"}, {"sha": "d254f6941a339c25ed9d1cfa5c18de23a17d8695", "filename": "src/test/run-pass/issues/issue-12612.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-12612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-12612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-12612.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n #![allow(unused_imports)]\n-// aux-build:issue_12612_1.rs\n-// aux-build:issue_12612_2.rs\n+// aux-build:issue-12612-1.rs\n+// aux-build:issue-12612-2.rs\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "ce920a3ccab9df738fd8fc2fe4f055fc839c587f", "filename": "src/test/run-pass/issues/issue-13507-2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13507-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13507-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13507-2.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,14 +1,14 @@\n // run-pass\n #![allow(unused_imports)]\n-// aux-build:issue13507.rs\n+// aux-build:issue-13507.rs\n \n-extern crate issue13507;\n-use issue13507::testtypes;\n+extern crate issue_13507;\n+use issue_13507::testtypes;\n \n use std::any::TypeId;\n \n pub fn type_ids() -> Vec<TypeId> {\n-    use issue13507::testtypes::*;\n+    use issue_13507::testtypes::*;\n     vec![\n         TypeId::of::<FooBool>(),\n         TypeId::of::<FooInt>(),\n@@ -30,7 +30,7 @@ pub fn type_ids() -> Vec<TypeId> {\n }\n \n pub fn main() {\n-    let othercrate = issue13507::testtypes::type_ids();\n+    let othercrate = issue_13507::testtypes::type_ids();\n     let thiscrate = type_ids();\n     assert_eq!(thiscrate, othercrate);\n }"}, {"sha": "56378b59e3642cd986b4c56e25a2b052acea7b52", "filename": "src/test/run-pass/issues/issue-18952.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18952.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18952.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18952.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issue-18952.rs"}, {"sha": "b6e9e3d065a48b044f896626d9af356d8606fc25", "filename": "src/test/run-pass/issues/issue-19293.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-19293.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-19293.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-19293.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// aux-build:issue_19293.rs\n+// aux-build:issue-19293.rs\n // pretty-expanded FIXME #23616\n \n extern crate issue_19293;"}, {"sha": "9bc3efcc1c4bfe11d98edb4da7f73cbc7bfe6395", "filename": "src/test/run-pass/issues/issue-20389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20389.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n-// aux-build:issue_20389.rs\n+// aux-build:issue-20389.rs\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "a89579706c8dc5347260c391ef9d39b2570c38b3", "filename": "src/test/run-pass/issues/issue-2170-exe.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2170-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2170-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2170-exe.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -0,0 +1,9 @@\n+// run-pass\n+// aux-build:issue-2170-lib.rs\n+// pretty-expanded FIXME #23616\n+\n+extern crate issue_2170_lib;\n+\n+pub fn main() {\n+   // let _ = issue_2170_lib::rsrc(2);\n+}"}, {"sha": "d975aa695c836b35db05ecd6be751cde832edf31", "filename": "src/test/run-pass/issues/issue-2316-c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2316-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2316-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2316-c.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n-// aux-build:issue_2316_a.rs\n-// aux-build:issue_2316_b.rs\n+// aux-build:issue-2316-a.rs\n+// aux-build:issue-2316-b.rs\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "2275a8da696dd047f6dcfad08aaf539f28790649", "filename": "src/test/run-pass/issues/issue-24687-embed-debuginfo/auxiliary/issue-24687-lib.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fauxiliary%2Fissue-24687-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fauxiliary%2Fissue-24687-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fauxiliary%2Fissue-24687-lib.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -4,7 +4,8 @@\n // that separate file has many multi-byte characters, to try to\n // encourage the compiler to trip on them.\n \n-mod issue24687_mbcs_in_comments;\n+#[path = \"issue-24687-mbcs-in-comments.rs\"]\n+mod issue_24687_mbcs_in_comments;\n \n-pub use issue24687_mbcs_in_comments::D;\n+pub use issue_24687_mbcs_in_comments::D;\n ", "previous_filename": "src/test/run-pass/issues/issue24687-embed-debuginfo/auxiliary/issue24687_lib.rs"}, {"sha": "215145a64b177fc89292c0783d07e00a8f222e8d", "filename": "src/test/run-pass/issues/issue-24687-embed-debuginfo/auxiliary/issue-24687-mbcs-in-comments.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fauxiliary%2Fissue-24687-mbcs-in-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fauxiliary%2Fissue-24687-mbcs-in-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fauxiliary%2Fissue-24687-mbcs-in-comments.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue24687-embed-debuginfo/auxiliary/issue24687_mbcs_in_comments.rs"}, {"sha": "773792c7a3f1f3492ecf737a50ea7d5fa50eb6a4", "filename": "src/test/run-pass/issues/issue-24687-embed-debuginfo/main.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24687-embed-debuginfo%2Fmain.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,11 +1,11 @@\n // run-pass\n-// aux-build:issue24687_lib.rs\n+// aux-build:issue-24687-lib.rs\n // compile-flags:-g\n \n-extern crate issue24687_lib as d;\n+extern crate issue_24687_lib as d;\n \n fn main() {\n-    // Create a d, which has a destructor whose body will be codegen'ed\n+    // Create a `D`, which has a destructor whose body will be codegen'ed\n     // into the generated code here, and thus the local debuginfo will\n     // need references into the original source locations from\n     // `importer` above.", "previous_filename": "src/test/run-pass/issues/issue24687-embed-debuginfo/main.rs"}, {"sha": "c790bc2d09548c9e96ee0b9e462464329234ef7f", "filename": "src/test/run-pass/issues/issue-2472.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2472.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2472.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2472.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// aux-build:issue_2472_b.rs\n+// aux-build:issue-2472-b.rs\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "da2acf6c9f70432ef032c4ea947e5ed705471e1a", "filename": "src/test/run-pass/issues/issue-26873-multifile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -5,6 +5,7 @@\n \n // ignore-pretty issue #37195\n \n-mod issue_26873_multifile;\n+#[path = \"issue-26873-multifile/mod.rs\"]\n+mod multifile;\n \n fn main() {}"}, {"sha": "d1b802ff3cd4831b85402dc71ea0b623d4e9a1cf", "filename": "src/test/run-pass/issues/issue-26873-multifile/A/B.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2FB.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2FB.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2FB.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue_26873_multifile/A/B.rs"}, {"sha": "88f3eb04afbdc42e20b760be1d8a692bfc3ab191", "filename": "src/test/run-pass/issues/issue-26873-multifile/A/C.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2FC.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2FC.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2FC.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue_26873_multifile/A/C.rs"}, {"sha": "20f40a06782aee038288e8565fe4a38afb79d995", "filename": "src/test/run-pass/issues/issue-26873-multifile/A/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2FA%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue_26873_multifile/A/mod.rs"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/run-pass/issues/issue-26873-multifile/compiletest-ignore-dir", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2Fcompiletest-ignore-dir", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2Fcompiletest-ignore-dir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2Fcompiletest-ignore-dir?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue_26873_multifile/compiletest-ignore-dir"}, {"sha": "52deea79a20c7c7c5f4a5fdfbcd1f2775209d6d4", "filename": "src/test/run-pass/issues/issue-26873-multifile/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26873-multifile%2Fmod.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue_26873_multifile/mod.rs"}, {"sha": "1910561d0ba430715a98a303fe4ba8e57b79b910", "filename": "src/test/run-pass/issues/issue-2723-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2723-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2723-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2723-b.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// aux-build:issue_2723_a.rs\n+// aux-build:issue-2723-a.rs\n \n extern crate issue_2723_a;\n use issue_2723_a::f;"}, {"sha": "4699d3352ad20e4264dafca2b11ad5e547ef13d3", "filename": "src/test/run-pass/issues/issue-28498-must-work-ex1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-must-work-ex1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-must-work-ex1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-must-work-ex1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue28498-must-work-ex1.rs"}, {"sha": "17111308555d897102d12edf517c8d6a04e369ec", "filename": "src/test/run-pass/issues/issue-28498-must-work-ex2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-must-work-ex2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-must-work-ex2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-must-work-ex2.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue28498-must-work-ex2.rs"}, {"sha": "65d5588871b65161250319553f56ab26d78c6e5b", "filename": "src/test/run-pass/issues/issue-28498-ugeh-ex1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-ex1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-ex1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-ex1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue28498-ugeh-ex1.rs"}, {"sha": "573ec8f6131f75b1f6cdb53edb64653767b15d08", "filename": "src/test/run-pass/issues/issue-28498-ugeh-with-lifetime-param.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-lifetime-param.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue28498-ugeh-with-lifetime-param.rs"}, {"sha": "e0863fa9947ed788ae5434f124d7a2c8bd68d956", "filename": "src/test/run-pass/issues/issue-28498-ugeh-with-passed-to-fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-passed-to-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-passed-to-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-passed-to-fn.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue28498-ugeh-with-passed-to-fn.rs"}, {"sha": "01d884584f640bee038c5cf43130f335691e7329", "filename": "src/test/run-pass/issues/issue-28498-ugeh-with-trait-bound.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-28498-ugeh-with-trait-bound.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue28498-ugeh-with-trait-bound.rs"}, {"sha": "a236e49137554d71b67d9ce662d57932f425e8b6", "filename": "src/test/run-pass/issues/issue-29927-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-29927-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-29927-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-29927-1.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "previous_filename": "src/test/run-pass/issues/issue29927-1.rs"}, {"sha": "c4ca7236e76155c641a8e6581415cb3eb93165d1", "filename": "src/test/run-pass/issues/issue-3136-b.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3136-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3136-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3136-b.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,7 +1,8 @@\n // run-pass\n-// aux-build:issue_3136_a.rc\n+// aux-build:issue-3136-a.rc\n \n // pretty-expanded FIXME #23616\n \n extern crate issue_3136_a;\n+\n pub fn main() {}", "previous_filename": "src/test/run-pass/issues/issue_3136_b.rs"}, {"sha": "88d5c50a27d2941e8b34350ec6e98c81505d040c", "filename": "src/test/run-pass/issues/issue-34796.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-34796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-34796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-34796.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -8,8 +8,8 @@\n // the symbol name.\n // The fix was to make the order in which predicates get encoded stable.\n \n-// aux-build:issue34796aux.rs\n-extern crate issue34796aux;\n+// aux-build:issue-34796-aux.rs\n+extern crate issue_34796_aux;\n \n fn mk<T>() -> T { loop {} }\n \n@@ -19,7 +19,7 @@ struct Data<T, E> {\n }\n \n fn main() {\n-    issue34796aux::bar(|()| {\n+    issue_34796_aux::bar(|()| {\n         Data::<(), std::io::Error> {\n             data: mk(),\n             error: mk(),"}, {"sha": "cfa0420c80d1d465a709822a3d1fdf0627526b01", "filename": "src/test/run-pass/issues/issue-38190.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38190.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,12 +1,15 @@\n // run-pass\n-// aux-build:issue_38190.rs\n+// aux-build:issue-38190.rs\n // ignore-pretty issue #37195\n \n #[macro_use]\n extern crate issue_38190;\n \n mod auxiliary {\n-    m!([mod issue_38190;]);\n+    m!([\n+        #[path = \"issue-38190.rs\"]\n+        mod issue_38190;\n+    ]);\n }\n \n fn main() {}"}, {"sha": "3213e3618a88b44582245d1e6e13477fd7e675f0", "filename": "src/test/run-pass/issues/issue-38226.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38226.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38226.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38226.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -2,7 +2,7 @@\n // This test makes sure that we don't run into a linker error because of the\n // middle::reachable pass missing trait methods with default impls.\n \n-// aux-build:issue_38226_aux.rs\n+// aux-build:issue-38226-aux.rs\n \n // Need -Cno-prepopulate-passes to really disable inlining, otherwise the faulty\n // code gets optimized out:"}, {"sha": "e3c3a027f3cd0cd3829e61b4d955b1afbb99dfa1", "filename": "src/test/run-pass/issues/issue-38715.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-38715.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n-// aux-build:issue_38715.rs\n-// aux-build:issue_38715-modern.rs\n+// aux-build:issue-38715.rs\n+// aux-build:issue-38715-modern.rs\n \n // Test that `#[macro_export] macro_rules!` shadow earlier `#[macro_export] macro_rules!`\n "}, {"sha": "fcb1f55c32f9c2601bbd2e56785ef487f6b00835", "filename": "src/test/run-pass/issues/issue-3979-xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3979-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1644fd2746fd29520099d1667b6c3a3eb7b83/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3979-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3979-xcrate.rs?ref=60f1644fd2746fd29520099d1667b6c3a3eb7b83", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n-// aux-build:issue_3979_traits.rs\n+// aux-build:issue-3979-traits.rs\n \n extern crate issue_3979_traits;\n use issue_3979_traits::{Positioned, Movable};"}]}