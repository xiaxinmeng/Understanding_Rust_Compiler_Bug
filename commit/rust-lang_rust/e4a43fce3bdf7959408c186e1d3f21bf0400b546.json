{"sha": "e4a43fce3bdf7959408c186e1d3f21bf0400b546", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YTQzZmNlM2JkZjc5NTk0MDhjMTg2ZTFkM2YyMWJmMDQwMGI1NDY=", "commit": {"author": {"name": "Zachary Catlin", "email": "z@zc.is", "date": "2020-11-12T02:17:45Z"}, "committer": {"name": "Zachary Catlin", "email": "z@zc.is", "date": "2020-11-12T02:17:45Z"}, "message": "Merge changes from rust-lang/rust", "tree": {"sha": "f3aba9acfef6009d54d1e9d63fec905b1e76f0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3aba9acfef6009d54d1e9d63fec905b1e76f0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4a43fce3bdf7959408c186e1d3f21bf0400b546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a43fce3bdf7959408c186e1d3f21bf0400b546", "html_url": "https://github.com/rust-lang/rust/commit/e4a43fce3bdf7959408c186e1d3f21bf0400b546", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4a43fce3bdf7959408c186e1d3f21bf0400b546/comments", "author": {"login": "zec", "id": 334445, "node_id": "MDQ6VXNlcjMzNDQ0NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/334445?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zec", "html_url": "https://github.com/zec", "followers_url": "https://api.github.com/users/zec/followers", "following_url": "https://api.github.com/users/zec/following{/other_user}", "gists_url": "https://api.github.com/users/zec/gists{/gist_id}", "starred_url": "https://api.github.com/users/zec/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zec/subscriptions", "organizations_url": "https://api.github.com/users/zec/orgs", "repos_url": "https://api.github.com/users/zec/repos", "events_url": "https://api.github.com/users/zec/events{/privacy}", "received_events_url": "https://api.github.com/users/zec/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zec", "id": 334445, "node_id": "MDQ6VXNlcjMzNDQ0NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/334445?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zec", "html_url": "https://github.com/zec", "followers_url": "https://api.github.com/users/zec/followers", "following_url": "https://api.github.com/users/zec/following{/other_user}", "gists_url": "https://api.github.com/users/zec/gists{/gist_id}", "starred_url": "https://api.github.com/users/zec/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zec/subscriptions", "organizations_url": "https://api.github.com/users/zec/orgs", "repos_url": "https://api.github.com/users/zec/repos", "events_url": "https://api.github.com/users/zec/events{/privacy}", "received_events_url": "https://api.github.com/users/zec/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "562d50eb7b67109ca420eab8705673b138863e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/562d50eb7b67109ca420eab8705673b138863e6a", "html_url": "https://github.com/rust-lang/rust/commit/562d50eb7b67109ca420eab8705673b138863e6a"}, {"sha": "77180db6f81ffdacd14545f1df0a5db55dac1706", "url": "https://api.github.com/repos/rust-lang/rust/commits/77180db6f81ffdacd14545f1df0a5db55dac1706", "html_url": "https://github.com/rust-lang/rust/commit/77180db6f81ffdacd14545f1df0a5db55dac1706"}], "stats": {"total": 1593, "additions": 1068, "deletions": 525}, "files": [{"sha": "1fc2d281e793536271f6fa2b1c8a0fa53572a983", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -554,6 +554,8 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(function_sections, Some(false));\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n+    tracked!(inline_mir_threshold, 123);\n+    tracked!(inline_mir_hint_threshold, 123);\n     tracked!(insert_sideeffect, true);\n     tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);"}, {"sha": "7737672dbde66d2a7b8b04a828f12727322fbf70", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -16,9 +16,6 @@ use crate::transform::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n \n-const DEFAULT_THRESHOLD: usize = 50;\n-const HINT_THRESHOLD: usize = 100;\n-\n const INSTR_COST: usize = 5;\n const CALL_PENALTY: usize = 25;\n const LANDINGPAD_PENALTY: usize = 50;\n@@ -31,7 +28,8 @@ pub struct Inline;\n #[derive(Copy, Clone, Debug)]\n struct CallSite<'tcx> {\n     callee: Instance<'tcx>,\n-    bb: BasicBlock,\n+    block: BasicBlock,\n+    target: Option<BasicBlock>,\n     source_info: SourceInfo,\n }\n \n@@ -175,8 +173,7 @@ impl Inliner<'tcx> {\n \n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n-        // FIXME: Handle inlining of diverging calls\n-        if let TerminatorKind::Call { func: ref op, destination: Some(_), .. } = terminator.kind {\n+        if let TerminatorKind::Call { func: ref op, ref destination, .. } = terminator.kind {\n             if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n                 // To resolve an instance its substs have to be fully normalized, so\n                 // we do this here.\n@@ -190,7 +187,12 @@ impl Inliner<'tcx> {\n                     return None;\n                 }\n \n-                return Some(CallSite { callee, bb, source_info: terminator.source_info });\n+                return Some(CallSite {\n+                    callee,\n+                    block: bb,\n+                    target: destination.map(|(_, target)| target),\n+                    source_info: terminator.source_info,\n+                });\n             }\n         }\n \n@@ -248,7 +250,11 @@ impl Inliner<'tcx> {\n             }\n         }\n \n-        let mut threshold = if hinted { HINT_THRESHOLD } else { DEFAULT_THRESHOLD };\n+        let mut threshold = if hinted {\n+            self.tcx.sess.opts.debugging_opts.inline_mir_hint_threshold\n+        } else {\n+            self.tcx.sess.opts.debugging_opts.inline_mir_threshold\n+        };\n \n         // Significantly lower the threshold for inlining cold functions\n         if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n@@ -398,9 +404,9 @@ impl Inliner<'tcx> {\n         caller_body: &mut Body<'tcx>,\n         mut callee_body: Body<'tcx>,\n     ) {\n-        let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n+        let terminator = caller_body[callsite.block].terminator.take().unwrap();\n         match terminator.kind {\n-            TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n+            TerminatorKind::Call { args, destination, cleanup, .. } => {\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -417,43 +423,39 @@ impl Inliner<'tcx> {\n                     false\n                 }\n \n-                let dest = if dest_needs_borrow(destination.0) {\n-                    trace!(\"creating temp for return destination\");\n-                    let dest = Rvalue::Ref(\n-                        self.tcx.lifetimes.re_erased,\n-                        BorrowKind::Mut { allow_two_phase_borrow: false },\n-                        destination.0,\n-                    );\n-\n-                    let ty = dest.ty(caller_body, self.tcx);\n-\n-                    let temp = LocalDecl::new(ty, callsite.source_info.span);\n-\n-                    let tmp = caller_body.local_decls.push(temp);\n-                    let tmp = Place::from(tmp);\n-\n-                    let stmt = Statement {\n-                        source_info: callsite.source_info,\n-                        kind: StatementKind::Assign(box (tmp, dest)),\n-                    };\n-                    caller_body[callsite.bb].statements.push(stmt);\n-                    self.tcx.mk_place_deref(tmp)\n+                let dest = if let Some((destination_place, _)) = destination {\n+                    if dest_needs_borrow(destination_place) {\n+                        trace!(\"creating temp for return destination\");\n+                        let dest = Rvalue::Ref(\n+                            self.tcx.lifetimes.re_erased,\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            destination_place,\n+                        );\n+                        let dest_ty = dest.ty(caller_body, self.tcx);\n+                        let temp = Place::from(self.new_call_temp(caller_body, &callsite, dest_ty));\n+                        caller_body[callsite.block].statements.push(Statement {\n+                            source_info: callsite.source_info,\n+                            kind: StatementKind::Assign(box (temp, dest)),\n+                        });\n+                        self.tcx.mk_place_deref(temp)\n+                    } else {\n+                        destination_place\n+                    }\n                 } else {\n-                    destination.0\n+                    trace!(\"creating temp for return place\");\n+                    Place::from(self.new_call_temp(caller_body, &callsite, callee_body.return_ty()))\n                 };\n \n-                let return_block = destination.1;\n-\n                 // Copy the arguments if needed.\n-                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, return_block);\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body);\n \n                 let mut integrator = Integrator {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n                     new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n                     new_blocks: BasicBlock::new(caller_body.basic_blocks().len())..,\n                     destination: dest,\n-                    return_block,\n+                    return_block: callsite.target,\n                     cleanup_block: cleanup,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n@@ -502,7 +504,7 @@ impl Inliner<'tcx> {\n                 caller_body.var_debug_info.extend(callee_body.var_debug_info.drain(..));\n                 caller_body.basic_blocks_mut().extend(callee_body.basic_blocks_mut().drain(..));\n \n-                caller_body[callsite.bb].terminator = Some(Terminator {\n+                caller_body[callsite.block].terminator = Some(Terminator {\n                     source_info: callsite.source_info,\n                     kind: TerminatorKind::Goto { target: integrator.map_block(START_BLOCK) },\n                 });\n@@ -526,7 +528,6 @@ impl Inliner<'tcx> {\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n-        return_block: BasicBlock,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -557,18 +558,8 @@ impl Inliner<'tcx> {\n         // `callee_body.spread_arg == None`, instead of special-casing closures.\n         if tcx.is_closure(callsite.callee.def_id()) {\n             let mut args = args.into_iter();\n-            let self_ = self.create_temp_if_necessary(\n-                args.next().unwrap(),\n-                callsite,\n-                caller_body,\n-                return_block,\n-            );\n-            let tuple = self.create_temp_if_necessary(\n-                args.next().unwrap(),\n-                callsite,\n-                caller_body,\n-                return_block,\n-            );\n+            let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n+            let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n@@ -588,13 +579,13 @@ impl Inliner<'tcx> {\n                     Operand::Move(tcx.mk_place_field(tuple, Field::new(i), ty.expect_ty()));\n \n                 // Spill to a local to make e.g., `tmp0`.\n-                self.create_temp_if_necessary(tuple_field, callsite, caller_body, return_block)\n+                self.create_temp_if_necessary(tuple_field, callsite, caller_body)\n             });\n \n             closure_ref_arg.chain(tuple_tmp_args).collect()\n         } else {\n             args.into_iter()\n-                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body, return_block))\n+                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body))\n                 .collect()\n         }\n     }\n@@ -606,46 +597,52 @@ impl Inliner<'tcx> {\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n-        return_block: BasicBlock,\n     ) -> Local {\n-        // FIXME: Analysis of the usage of the arguments to avoid\n-        // unnecessary temporaries.\n-\n+        // Reuse the operand if it is a moved temporary.\n         if let Operand::Move(place) = &arg {\n             if let Some(local) = place.as_local() {\n                 if caller_body.local_kind(local) == LocalKind::Temp {\n-                    // Reuse the operand if it's a temporary already\n                     return local;\n                 }\n             }\n         }\n \n+        // Otherwise, create a temporary for the argument.\n         trace!(\"creating temp for argument {:?}\", arg);\n-        // Otherwise, create a temporary for the arg\n-        let arg = Rvalue::Use(arg);\n-\n-        let ty = arg.ty(caller_body, self.tcx);\n-\n-        let arg_tmp = LocalDecl::new(ty, callsite.source_info.span);\n-        let arg_tmp = caller_body.local_decls.push(arg_tmp);\n-\n-        caller_body[callsite.bb].statements.push(Statement {\n+        let arg_ty = arg.ty(caller_body, self.tcx);\n+        let local = self.new_call_temp(caller_body, callsite, arg_ty);\n+        caller_body[callsite.block].statements.push(Statement {\n             source_info: callsite.source_info,\n-            kind: StatementKind::StorageLive(arg_tmp),\n+            kind: StatementKind::Assign(box (Place::from(local), Rvalue::Use(arg))),\n         });\n-        caller_body[callsite.bb].statements.push(Statement {\n+        local\n+    }\n+\n+    /// Introduces a new temporary into the caller body that is live for the duration of the call.\n+    fn new_call_temp(\n+        &self,\n+        caller_body: &mut Body<'tcx>,\n+        callsite: &CallSite<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Local {\n+        let local = caller_body.local_decls.push(LocalDecl::new(ty, callsite.source_info.span));\n+\n+        caller_body[callsite.block].statements.push(Statement {\n             source_info: callsite.source_info,\n-            kind: StatementKind::Assign(box (Place::from(arg_tmp), arg)),\n+            kind: StatementKind::StorageLive(local),\n         });\n-        caller_body[return_block].statements.insert(\n-            0,\n-            Statement {\n-                source_info: callsite.source_info,\n-                kind: StatementKind::StorageDead(arg_tmp),\n-            },\n-        );\n-\n-        arg_tmp\n+\n+        if let Some(block) = callsite.target {\n+            caller_body[block].statements.insert(\n+                0,\n+                Statement {\n+                    source_info: callsite.source_info,\n+                    kind: StatementKind::StorageDead(local),\n+                },\n+            );\n+        }\n+\n+        local\n     }\n }\n \n@@ -670,7 +667,7 @@ struct Integrator<'a, 'tcx> {\n     new_scopes: RangeFrom<SourceScope>,\n     new_blocks: RangeFrom<BasicBlock>,\n     destination: Place<'tcx>,\n-    return_block: BasicBlock,\n+    return_block: Option<BasicBlock>,\n     cleanup_block: Option<BasicBlock>,\n     in_cleanup_block: bool,\n     tcx: TyCtxt<'tcx>,\n@@ -816,7 +813,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Return => {\n-                terminator.kind = TerminatorKind::Goto { target: self.return_block };\n+                terminator.kind = if let Some(tgt) = self.return_block {\n+                    TerminatorKind::Goto { target: tgt }\n+                } else {\n+                    TerminatorKind::Unreachable\n+                }\n             }\n             TerminatorKind::Resume => {\n                 if let Some(tgt) = self.cleanup_block {"}, {"sha": "1cd3d11e3215367f8468c4bffa290a3a13fca96e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -929,6 +929,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (default: no)\"),\n     incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n         \"verify incr. comp. hashes of green query instances (default: no)\"),\n+    inline_mir_threshold: usize = (50, parse_uint, [TRACKED],\n+        \"a default MIR inlining threshold (default: 50)\"),\n+    inline_mir_hint_threshold: usize = (100, parse_uint, [TRACKED],\n+        \"inlining threshold for functions with inline hint (default: 100)\"),\n     inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"control whether `#[inline]` functions are in all CGUs\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "58c72af4e769cbfa37cd044848147c238cd88762", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.max_atomic_width = Some(128);\n \n     Target {"}, {"sha": "f6fbe7cd5f6223f8710f9e05b12d551c6477e42a", "filename": "compiler/rustc_target/src/spec/android_base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,15 +1,14 @@\n use crate::spec::{LinkerFlavor, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.os = \"android\".to_string();\n     // Many of the symbols defined in compiler-rt are also defined in libgcc.\n     // Android's linker doesn't like that by default.\n     base.pre_link_args\n         .get_mut(&LinkerFlavor::Gcc)\n         .unwrap()\n         .push(\"-Wl,--allow-multiple-definition\".to_string());\n-    base.is_like_android = true;\n     base.dwarf_version = Some(2);\n     base.position_independent_executables = true;\n     base.has_elf_tls = false;"}, {"sha": "c41cf6e521a1d8875623f14d22d5badda9bbfe60", "filename": "compiler/rustc_target/src/spec/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabi.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.max_atomic_width = Some(64);\n     Target {\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),"}, {"sha": "f2143966c1dcd6b06e9382bc51f9252ee25e60aa", "filename": "compiler/rustc_target/src/spec/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabihf.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.max_atomic_width = Some(64);\n     Target {\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),"}, {"sha": "e1ba72bf83b9c8ad78e6f4333dd8edbeeb61b4d8", "filename": "compiler/rustc_target/src/spec/armv4t_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_unknown_linux_gnueabi.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let base = super::linux_gnu_base::opts();\n     Target {\n         llvm_target: \"armv4t-unknown-linux-gnueabi\".to_string(),\n         pointer_width: 32,"}, {"sha": "3ac8d53564d7d73c70685b2e4a5ce99c3a4452e3", "filename": "compiler/rustc_target/src/spec/armv5te_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_gnueabi.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let base = super::linux_gnu_base::opts();\n     Target {\n         llvm_target: \"armv5te-unknown-linux-gnueabi\".to_string(),\n         pointer_width: 32,"}, {"sha": "ae6b8286f085fe2a7ba4268b17ee88acd5646e60", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabi.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -4,7 +4,7 @@ use crate::spec::{Target, TargetOptions};\n // hardfloat.\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let base = super::linux_gnu_base::opts();\n     Target {\n         llvm_target: \"armv7-unknown-linux-gnueabi\".to_string(),\n         pointer_width: 32,"}, {"sha": "48c16b620fd69e6cf9a4780b8b291d2a76ef02c9", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabihf.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -4,7 +4,7 @@ use crate::spec::{Target, TargetOptions};\n // thumb-mode. See the thumbv7neon variant for enabling both.\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let base = super::linux_gnu_base::opts();\n     Target {\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         pointer_width: 32,"}, {"sha": "083c115d084b46acf86feb102c3290370f80270d", "filename": "compiler/rustc_target/src/spec/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());"}, {"sha": "0631644ad63555d868180a5a1affe9a62585d320", "filename": "compiler/rustc_target/src/spec/linux_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_base.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -20,7 +20,6 @@ pub fn opts() -> TargetOptions {\n \n     TargetOptions {\n         os: \"linux\".to_string(),\n-        env: \"gnu\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n         os_family: Some(\"unix\".to_string()),"}, {"sha": "3d940ceaf0270b2ea8dec8f887af49aac850a480", "filename": "compiler/rustc_target/src/spec/linux_gnu_base.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_gnu_base.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,5 @@\n+use crate::spec::TargetOptions;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions { env: \"gnu\".to_string(), ..super::linux_base::opts() }\n+}"}, {"sha": "daa0d9da1725e6cabc2c5b15ae05d5df1a450272", "filename": "compiler/rustc_target/src/spec/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -14,7 +14,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(64),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "d767705b0459b38c8b6c9c1a0c7d6359042deb4c", "filename": "compiler/rustc_target/src/spec/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(64),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "a7ec1f19c9de7b5810adb1ebb55a8960e5a845de", "filename": "compiler/rustc_target/src/spec/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "9cb2a13c7d4b5da57b06942d3d4b947379e68f6c", "filename": "compiler/rustc_target/src/spec/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "11b3734a10507f6215d67247e852525eca44fd10", "filename": "compiler/rustc_target/src/spec/mipsisa32r6_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "06a5f40d69b3aa19fef116fd23215ce2edf8be75", "filename": "compiler/rustc_target/src/spec/mipsisa32r6el_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "6282c9e1d54b692974571bc7a4459b2bfeb2ff59", "filename": "compiler/rustc_target/src/spec/mipsisa64r6_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -14,7 +14,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(64),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "589d7acba68045f67f9d8b67b9bf52bbec49e667", "filename": "compiler/rustc_target/src/spec/mipsisa64r6el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(64),\n             mcount: \"_mcount\".to_string(),\n \n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "f949bf95a502af67c9d209fb8ddb2616e1d56550", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -64,6 +64,7 @@ mod hermit_kernel_base;\n mod illumos_base;\n mod l4re_base;\n mod linux_base;\n+mod linux_gnu_base;\n mod linux_kernel_base;\n mod linux_musl_base;\n mod linux_uclibc_base;\n@@ -823,9 +824,6 @@ pub struct TargetOptions {\n     /// library naming convention. Defaults to false.\n     pub is_like_windows: bool,\n     pub is_like_msvc: bool,\n-    /// Whether the target toolchain is like Android's. Only useful for compiling against Android.\n-    /// Defaults to false.\n-    pub is_like_android: bool,\n     /// Whether the target toolchain is like Emscripten's. Only useful for compiling with\n     /// Emscripten toolchain.\n     /// Defaults to false.\n@@ -1033,7 +1031,6 @@ impl Default for TargetOptions {\n             is_like_osx: false,\n             is_like_solaris: false,\n             is_like_windows: false,\n-            is_like_android: false,\n             is_like_emscripten: false,\n             is_like_msvc: false,\n             is_like_fuchsia: false,\n@@ -1476,7 +1473,6 @@ impl Target {\n         key!(is_like_windows, bool);\n         key!(is_like_msvc, bool);\n         key!(is_like_emscripten, bool);\n-        key!(is_like_android, bool);\n         key!(is_like_fuchsia, bool);\n         key!(dwarf_version, Option<u32>);\n         key!(linker_is_gnu, bool);\n@@ -1712,7 +1708,6 @@ impl ToJson for Target {\n         target_option_val!(is_like_windows);\n         target_option_val!(is_like_msvc);\n         target_option_val!(is_like_emscripten);\n-        target_option_val!(is_like_android);\n         target_option_val!(is_like_fuchsia);\n         target_option_val!(dwarf_version);\n         target_option_val!(linker_is_gnu);"}, {"sha": "03322818d33c3d6863baabad6aee20ebfd2af1e6", "filename": "compiler/rustc_target/src/spec/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, RelroLevel, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);"}, {"sha": "07e0bf81bc72f056dec6f9dc73ce480f09f7e6bb", "filename": "compiler/rustc_target/src/spec/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64le_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.cpu = \"ppc64le\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);"}, {"sha": "3a9271247b0426cf2f0446f7bd2bb491b30a3b49", "filename": "compiler/rustc_target/src/spec/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.max_atomic_width = Some(32);\n "}, {"sha": "105a0b21aaf01c3a035d0a4cf11100af42a67bd2", "filename": "compiler/rustc_target/src/spec/powerpc_unknown_linux_gnuspe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_linux_gnuspe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_linux_gnuspe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_linux_gnuspe.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mspe\".to_string());\n     base.max_atomic_width = Some(32);\n "}, {"sha": "cf5e0201d08bf6b217f67a1e69fb2d8d48597b39", "filename": "compiler/rustc_target/src/spec/riscv32gc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32gc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32gc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32gc_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             features: \"+m,+a,+f,+d,+c\".to_string(),\n             llvm_abiname: \"ilp32d\".to_string(),\n             max_atomic_width: Some(32),\n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "84f28413fcbcea0d03729b590706a42799b21454", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -13,7 +13,7 @@ pub fn target() -> Target {\n             features: \"+m,+a,+f,+d,+c\".to_string(),\n             llvm_abiname: \"lp64d\".to_string(),\n             max_atomic_width: Some(64),\n-            ..super::linux_base::opts()\n+            ..super::linux_gnu_base::opts()\n         },\n     }\n }"}, {"sha": "d6e8e6ee220e65b994cac7f144fcaed605c0d761", "filename": "compiler/rustc_target/src/spec/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.endian = \"big\".to_string();\n     // z10 is the oldest CPU supported by LLVM\n     base.cpu = \"z10\".to_string();"}, {"sha": "e9b5520ac3d37e38b2c6d33d3ed32b1f8c8edbb1", "filename": "compiler/rustc_target/src/spec/sparc64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparc64_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.endian = \"big\".to_string();\n     base.cpu = \"v9\".to_string();\n     base.max_atomic_width = Some(64);"}, {"sha": "aae186b2293c70577bb64fb599aba9124da1b635", "filename": "compiler/rustc_target/src/spec/sparc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparc_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.endian = \"big\".to_string();\n     base.cpu = \"v9\".to_string();\n     base.max_atomic_width = Some(64);"}, {"sha": "352d246874308f03b11c536bc6b553155792fd54", "filename": "compiler/rustc_target/src/spec/thumbv7neon_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv7neon_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv7neon_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv7neon_unknown_linux_gnueabihf.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -7,7 +7,7 @@ use crate::spec::{Target, TargetOptions};\n // https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let base = super::linux_gnu_base::opts();\n     Target {\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         pointer_width: 32,"}, {"sha": "f127dd49bc4b7c500c2b6b9f27c3fdcefef7e0a6", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnu.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());"}, {"sha": "0cae57528483f9023e45b03ba38d448886b733d3", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_linux_gnux32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnux32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnux32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_linux_gnux32.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,7 +1,7 @@\n use crate::spec::{LinkerFlavor, Target};\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_gnu_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mx32\".to_string());"}, {"sha": "e1721a5a88a76f6edf98a7f76ddfcaa52c7c8e3e", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -512,6 +512,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n                 assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n+                // `AbstractConst`s should not contain any promoteds as they require references which\n+                // are not allowed.\n+                assert!(!self.nodes.iter().any(|n| matches!(\n+                    n.node,\n+                    Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(_, _, Some(_)), ty: _ })\n+                )));\n+\n                 self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n                 if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n                     self.error(Some(unused.span), \"dead code\")?;\n@@ -609,6 +616,10 @@ pub(super) fn try_unify<'tcx>(\n         (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n             let a_ct = a_ct.subst(tcx, a.substs);\n             let b_ct = b_ct.subst(tcx, b.substs);\n+            if a_ct.ty != b_ct.ty {\n+                return false;\n+            }\n+\n             match (a_ct.val, b_ct.val) {\n                 // We can just unify errors with everything to reduce the amount of\n                 // emitted errors here.\n@@ -621,6 +632,12 @@ pub(super) fn try_unify<'tcx>(\n                 // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n                 // means that we only allow inference variables if they are equal.\n                 (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                // We may want to instead recurse into unevaluated constants here. That may require some\n+                // care to prevent infinite recursion, so let's just ignore this for now.\n+                (\n+                    ty::ConstKind::Unevaluated(a_def, a_substs, None),\n+                    ty::ConstKind::Unevaluated(b_def, b_substs, None),\n+                ) => a_def == b_def && a_substs == b_substs,\n                 // FIXME(const_evaluatable_checked): We may want to either actually try\n                 // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n                 // this, for now we just return false here."}, {"sha": "c9e183887504c20605b749917fd0c50c27bb68b1", "filename": "config.toml.example", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -586,6 +586,15 @@ changelog-seen = 2\n # build native code.\n #android-ndk = \"/path/to/ndk\"\n \n+# Build the sanitizer runtimes for this target.\n+# This option will override the same option under [build] section.\n+#sanitizers = false\n+\n+# Build the profiler runtime for this target(required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n+# This option will override the same option under [build] section.\n+#profiler = false\n+\n # Force static or dynamic linkage of the standard library for this target. If\n # this target is a host for rustc, this will also affect the linkage of the\n # compiler itself. This is useful for building rustc on targets that normally"}, {"sha": "e0362b2f37df7d61c71a9a7e9f148d7f98447034", "filename": "library/alloc/src/collections/btree/append.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,124 @@\n+use super::map::MIN_LEN;\n+use super::merge_iter::MergeIterInner;\n+use super::node::{self, ForceResult::*, Root};\n+use core::iter::FusedIterator;\n+\n+impl<K, V> Root<K, V> {\n+    /// Appends all key-value pairs from the union of two ascending iterators,\n+    /// incrementing a `length` variable along the way. The latter makes it\n+    /// easier for the caller to avoid a leak when a drop handler panicks.\n+    ///\n+    /// If both iterators produce the same key, this method drops the pair from\n+    /// the left iterator and appends the pair from the right iterator.\n+    ///\n+    /// If you want the tree to end up in a strictly ascending order, like for\n+    /// a `BTreeMap`, both iterators should produce keys in strictly ascending\n+    /// order, each greater than all keys in the tree, including any keys\n+    /// already in the tree upon entry.\n+    pub fn append_from_sorted_iters<I>(&mut self, left: I, right: I, length: &mut usize)\n+    where\n+        K: Ord,\n+        I: Iterator<Item = (K, V)> + FusedIterator,\n+    {\n+        // We prepare to merge `left` and `right` into a sorted sequence in linear time.\n+        let iter = MergeIter(MergeIterInner::new(left, right));\n+\n+        // Meanwhile, we build a tree from the sorted sequence in linear time.\n+        self.bulk_push(iter, length)\n+    }\n+\n+    /// Pushes all key-value pairs to the end of the tree, incrementing a\n+    /// `length` variable along the way. The latter makes it easier for the\n+    /// caller to avoid a leak when the iterator panicks.\n+    fn bulk_push<I>(&mut self, iter: I, length: &mut usize)\n+    where\n+        I: Iterator<Item = (K, V)>,\n+    {\n+        let mut cur_node = self.node_as_mut().last_leaf_edge().into_node();\n+        // Iterate through all key-value pairs, pushing them into nodes at the right level.\n+        for (key, value) in iter {\n+            // Try to push key-value pair into the current leaf node.\n+            if cur_node.len() < node::CAPACITY {\n+                cur_node.push(key, value);\n+            } else {\n+                // No space left, go up and push there.\n+                let mut open_node;\n+                let mut test_node = cur_node.forget_type();\n+                loop {\n+                    match test_node.ascend() {\n+                        Ok(parent) => {\n+                            let parent = parent.into_node();\n+                            if parent.len() < node::CAPACITY {\n+                                // Found a node with space left, push here.\n+                                open_node = parent;\n+                                break;\n+                            } else {\n+                                // Go up again.\n+                                test_node = parent.forget_type();\n+                            }\n+                        }\n+                        Err(_) => {\n+                            // We are at the top, create a new root node and push there.\n+                            open_node = self.push_internal_level();\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                // Push key-value pair and new right subtree.\n+                let tree_height = open_node.height() - 1;\n+                let mut right_tree = Root::new_leaf();\n+                for _ in 0..tree_height {\n+                    right_tree.push_internal_level();\n+                }\n+                open_node.push(key, value, right_tree);\n+\n+                // Go down to the right-most leaf again.\n+                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n+            }\n+\n+            // Increment length every iteration, to make sure the map drops\n+            // the appended elements even if advancing the iterator panicks.\n+            *length += 1;\n+        }\n+        self.fix_right_edge();\n+    }\n+\n+    fn fix_right_edge(&mut self) {\n+        // Handle underfull nodes, start from the top.\n+        let mut cur_node = self.node_as_mut();\n+        while let Internal(internal) = cur_node.force() {\n+            // Check if right-most child is underfull.\n+            let mut last_edge = internal.last_edge();\n+            let right_child_len = last_edge.reborrow().descend().len();\n+            if right_child_len < MIN_LEN {\n+                // We need to steal.\n+                let mut last_kv = match last_edge.left_kv() {\n+                    Ok(left) => left,\n+                    Err(_) => unreachable!(),\n+                };\n+                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n+                last_edge = last_kv.right_edge();\n+            }\n+\n+            // Go further down.\n+            cur_node = last_edge.descend();\n+        }\n+    }\n+}\n+\n+// An iterator for merging two sorted sequences into one\n+struct MergeIter<K, V, I: Iterator<Item = (K, V)>>(MergeIterInner<I>);\n+\n+impl<K: Ord, V, I> Iterator for MergeIter<K, V, I>\n+where\n+    I: Iterator<Item = (K, V)> + FusedIterator,\n+{\n+    type Item = (K, V);\n+\n+    /// If two keys are equal, returns the key-value pair from the right source.\n+    fn next(&mut self) -> Option<(K, V)> {\n+        let (a_next, b_next) = self.0.nexts(|a: &(K, V), b: &(K, V)| K::cmp(&a.0, &b.0));\n+        b_next.or(a_next)\n+    }\n+}"}, {"sha": "49122f53d33ad0a7b2f74be1f9558245d70604b4", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 94, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -9,7 +9,6 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::merge_iter::MergeIterInner;\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n@@ -458,9 +457,6 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-// An iterator for merging two sorted sequences into one\n-struct MergeIter<K, V, I: Iterator<Item = (K, V)>>(MergeIterInner<I>);\n-\n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap.\n     ///\n@@ -908,13 +904,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             return;\n         }\n \n-        // First, we merge `self` and `other` into a sorted sequence in linear time.\n         let self_iter = mem::take(self).into_iter();\n         let other_iter = mem::take(other).into_iter();\n-        let iter = MergeIter(MergeIterInner::new(self_iter, other_iter));\n-\n-        // Second, we build a tree from the sorted sequence in linear time.\n-        self.from_sorted_iter(iter);\n+        let root = BTreeMap::ensure_is_owned(&mut self.root);\n+        root.append_from_sorted_iters(self_iter, other_iter, &mut self.length)\n     }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the map.\n@@ -1039,78 +1032,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n-        let root = Self::ensure_is_owned(&mut self.root);\n-        let mut cur_node = root.node_as_mut().last_leaf_edge().into_node();\n-        // Iterate through all key-value pairs, pushing them into nodes at the right level.\n-        for (key, value) in iter {\n-            // Try to push key-value pair into the current leaf node.\n-            if cur_node.len() < node::CAPACITY {\n-                cur_node.push(key, value);\n-            } else {\n-                // No space left, go up and push there.\n-                let mut open_node;\n-                let mut test_node = cur_node.forget_type();\n-                loop {\n-                    match test_node.ascend() {\n-                        Ok(parent) => {\n-                            let parent = parent.into_node();\n-                            if parent.len() < node::CAPACITY {\n-                                // Found a node with space left, push here.\n-                                open_node = parent;\n-                                break;\n-                            } else {\n-                                // Go up again.\n-                                test_node = parent.forget_type();\n-                            }\n-                        }\n-                        Err(_) => {\n-                            // We are at the top, create a new root node and push there.\n-                            open_node = root.push_internal_level();\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                // Push key-value pair and new right subtree.\n-                let tree_height = open_node.height() - 1;\n-                let mut right_tree = node::Root::new_leaf();\n-                for _ in 0..tree_height {\n-                    right_tree.push_internal_level();\n-                }\n-                open_node.push(key, value, right_tree);\n-\n-                // Go down to the right-most leaf again.\n-                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n-            }\n-\n-            self.length += 1;\n-        }\n-        Self::fix_right_edge(root)\n-    }\n-\n-    fn fix_right_edge(root: &mut node::Root<K, V>) {\n-        // Handle underfull nodes, start from the top.\n-        let mut cur_node = root.node_as_mut();\n-        while let Internal(internal) = cur_node.force() {\n-            // Check if right-most child is underfull.\n-            let mut last_edge = internal.last_edge();\n-            let right_child_len = last_edge.reborrow().descend().len();\n-            if right_child_len < MIN_LEN {\n-                // We need to steal.\n-                let mut last_kv = match last_edge.left_kv() {\n-                    Ok(left) => left,\n-                    Err(_) => unreachable!(),\n-                };\n-                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n-                last_edge = last_kv.right_edge();\n-            }\n-\n-            // Go further down.\n-            cur_node = last_edge.descend();\n-        }\n-    }\n-\n     /// Splits the collection into two at the given key. Returns everything after the given key,\n     /// including the key.\n     ///\n@@ -2220,18 +2141,5 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V, I> Iterator for MergeIter<K, V, I>\n-where\n-    I: Iterator<Item = (K, V)> + ExactSizeIterator + FusedIterator,\n-{\n-    type Item = (K, V);\n-\n-    /// If two keys are equal, returns the key/value-pair from the right source.\n-    fn next(&mut self) -> Option<(K, V)> {\n-        let (a_next, b_next) = self.0.nexts(|a: &(K, V), b: &(K, V)| K::cmp(&a.0, &b.0));\n-        b_next.or(a_next)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "dd3ebcccf76a5c131914642d7883763cd21873e3", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1685,6 +1685,33 @@ create_append_test!(test_append_239, 239);\n #[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_1700, 1700);\n \n+#[test]\n+fn test_append_drop_leak() {\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct D;\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut left = BTreeMap::new();\n+    let mut right = BTreeMap::new();\n+    left.insert(0, D);\n+    left.insert(1, D); // first to be dropped during append\n+    left.insert(2, D);\n+    right.insert(1, D);\n+    right.insert(2, D);\n+\n+    catch_unwind(move || left.append(&mut right)).unwrap_err();\n+\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n+}\n+\n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     assert!(len * 2 <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();"}, {"sha": "7f23d93b990f5fb2f8c79ae6aff12ed704fcbc7a", "filename": "library/alloc/src/collections/btree/merge_iter.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -2,48 +2,43 @@ use core::cmp::Ordering;\n use core::fmt::{self, Debug};\n use core::iter::FusedIterator;\n \n-/// Core of an iterator that merges the output of two ascending iterators,\n+/// Core of an iterator that merges the output of two strictly ascending iterators,\n /// for instance a union or a symmetric difference.\n-pub struct MergeIterInner<I>\n-where\n-    I: Iterator,\n-{\n+pub struct MergeIterInner<I: Iterator> {\n     a: I,\n     b: I,\n     peeked: Option<Peeked<I>>,\n }\n \n-/// Benchmarks faster than wrapping both iterators in a Peekable.\n+/// Benchmarks faster than wrapping both iterators in a Peekable,\n+/// probably because we can afford to impose a FusedIterator bound.\n #[derive(Clone, Debug)]\n enum Peeked<I: Iterator> {\n     A(I::Item),\n     B(I::Item),\n }\n \n-impl<I> Clone for MergeIterInner<I>\n+impl<I: Iterator> Clone for MergeIterInner<I>\n where\n-    I: Clone + Iterator,\n+    I: Clone,\n     I::Item: Clone,\n {\n     fn clone(&self) -> Self {\n         Self { a: self.a.clone(), b: self.b.clone(), peeked: self.peeked.clone() }\n     }\n }\n \n-impl<I> Debug for MergeIterInner<I>\n+impl<I: Iterator> Debug for MergeIterInner<I>\n where\n-    I: Iterator + Debug,\n+    I: Debug,\n     I::Item: Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).finish()\n+        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).field(&self.peeked).finish()\n     }\n }\n \n-impl<I> MergeIterInner<I>\n-where\n-    I: ExactSizeIterator + FusedIterator,\n-{\n+impl<I: Iterator> MergeIterInner<I> {\n     /// Creates a new core for an iterator merging a pair of sources.\n     pub fn new(a: I, b: I) -> Self {\n         MergeIterInner { a, b, peeked: None }\n@@ -52,13 +47,17 @@ where\n     /// Returns the next pair of items stemming from the pair of sources\n     /// being merged. If both returned options contain a value, that value\n     /// is equal and occurs in both sources. If one of the returned options\n-    /// contains a value, that value doesn't occur in the other source.\n-    /// If neither returned option contains a value, iteration has finished\n-    /// and subsequent calls will return the same empty pair.\n+    /// contains a value, that value doesn't occur in the other source (or\n+    /// the sources are not strictly ascending). If neither returned option\n+    /// contains a value, iteration has finished and subsequent calls will\n+    /// return the same empty pair.\n     pub fn nexts<Cmp: Fn(&I::Item, &I::Item) -> Ordering>(\n         &mut self,\n         cmp: Cmp,\n-    ) -> (Option<I::Item>, Option<I::Item>) {\n+    ) -> (Option<I::Item>, Option<I::Item>)\n+    where\n+        I: FusedIterator,\n+    {\n         let mut a_next;\n         let mut b_next;\n         match self.peeked.take() {\n@@ -86,7 +85,10 @@ where\n     }\n \n     /// Returns a pair of upper bounds for the `size_hint` of the final iterator.\n-    pub fn lens(&self) -> (usize, usize) {\n+    pub fn lens(&self) -> (usize, usize)\n+    where\n+        I: ExactSizeIterator,\n+    {\n         match self.peeked {\n             Some(Peeked::A(_)) => (1 + self.a.len(), self.b.len()),\n             Some(Peeked::B(_)) => (self.a.len(), 1 + self.b.len()),"}, {"sha": "ebcbb0e467c467b1cb95879bda8328301ec0b908", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,3 +1,4 @@\n+mod append;\n mod borrow;\n pub mod map;\n mod mem;"}, {"sha": "88b4e2a2436e73a050dda5864e1bdfdfe00f6df4", "filename": "library/core/src/time.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -108,18 +108,20 @@ impl Duration {\n     #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n     pub const NANOSECOND: Duration = Duration::from_nanos(1);\n \n-    /// The minimum duration.\n+    /// A duration of zero time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(duration_constants)]\n+    /// #![feature(duration_zero)]\n     /// use std::time::Duration;\n     ///\n-    /// assert_eq!(Duration::MIN, Duration::new(0, 0));\n+    /// let duration = Duration::ZERO;\n+    /// assert!(duration.is_zero());\n+    /// assert_eq!(duration.as_nanos(), 0);\n     /// ```\n-    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-    pub const MIN: Duration = Duration::from_nanos(0);\n+    #[unstable(feature = \"duration_zero\", issue = \"73544\")]\n+    pub const ZERO: Duration = Duration::from_nanos(0);\n \n     /// The maximum duration.\n     ///\n@@ -166,24 +168,6 @@ impl Duration {\n         Duration { secs, nanos }\n     }\n \n-    /// Creates a new `Duration` that spans no time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(duration_zero)]\n-    /// use std::time::Duration;\n-    ///\n-    /// let duration = Duration::zero();\n-    /// assert!(duration.is_zero());\n-    /// assert_eq!(duration.as_nanos(), 0);\n-    /// ```\n-    #[unstable(feature = \"duration_zero\", issue = \"73544\")]\n-    #[inline]\n-    pub const fn zero() -> Duration {\n-        Duration { secs: 0, nanos: 0 }\n-    }\n-\n     /// Creates a new `Duration` from the specified number of whole seconds.\n     ///\n     /// # Examples\n@@ -277,7 +261,7 @@ impl Duration {\n     /// #![feature(duration_zero)]\n     /// use std::time::Duration;\n     ///\n-    /// assert!(Duration::zero().is_zero());\n+    /// assert!(Duration::ZERO.is_zero());\n     /// assert!(Duration::new(0, 0).is_zero());\n     /// assert!(Duration::from_nanos(0).is_zero());\n     /// assert!(Duration::from_secs(0).is_zero());\n@@ -536,26 +520,26 @@ impl Duration {\n         }\n     }\n \n-    /// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::MIN`]\n+    /// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]\n     /// if the result would be negative or if overflow occurred.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(duration_saturating_ops)]\n-    /// #![feature(duration_constants)]\n+    /// #![feature(duration_zero)]\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));\n-    /// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::MIN);\n+    /// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);\n     /// ```\n     #[unstable(feature = \"duration_saturating_ops\", issue = \"76416\")]\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n     pub const fn saturating_sub(self, rhs: Duration) -> Duration {\n         match self.checked_sub(rhs) {\n             Some(res) => res,\n-            None => Duration::MIN,\n+            None => Duration::ZERO,\n         }\n     }\n "}, {"sha": "f14639e0d589fb95eeb5abc329ad0a9eba461d92", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -108,24 +108,24 @@ fn sub() {\n \n #[test]\n fn checked_sub() {\n-    let zero = Duration::new(0, 0);\n-    let one_nano = Duration::new(0, 1);\n-    let one_sec = Duration::new(1, 0);\n-    assert_eq!(one_nano.checked_sub(zero), Some(Duration::new(0, 1)));\n-    assert_eq!(one_sec.checked_sub(one_nano), Some(Duration::new(0, 999_999_999)));\n-    assert_eq!(zero.checked_sub(one_nano), None);\n-    assert_eq!(zero.checked_sub(one_sec), None);\n+    assert_eq!(Duration::NANOSECOND.checked_sub(Duration::ZERO), Some(Duration::NANOSECOND));\n+    assert_eq!(\n+        Duration::SECOND.checked_sub(Duration::NANOSECOND),\n+        Some(Duration::new(0, 999_999_999))\n+    );\n+    assert_eq!(Duration::ZERO.checked_sub(Duration::NANOSECOND), None);\n+    assert_eq!(Duration::ZERO.checked_sub(Duration::SECOND), None);\n }\n \n #[test]\n fn saturating_sub() {\n-    let zero = Duration::new(0, 0);\n-    let one_nano = Duration::new(0, 1);\n-    let one_sec = Duration::new(1, 0);\n-    assert_eq!(one_nano.saturating_sub(zero), Duration::new(0, 1));\n-    assert_eq!(one_sec.saturating_sub(one_nano), Duration::new(0, 999_999_999));\n-    assert_eq!(zero.saturating_sub(one_nano), Duration::MIN);\n-    assert_eq!(zero.saturating_sub(one_sec), Duration::MIN);\n+    assert_eq!(Duration::NANOSECOND.saturating_sub(Duration::ZERO), Duration::NANOSECOND);\n+    assert_eq!(\n+        Duration::SECOND.saturating_sub(Duration::NANOSECOND),\n+        Duration::new(0, 999_999_999)\n+    );\n+    assert_eq!(Duration::ZERO.saturating_sub(Duration::NANOSECOND), Duration::ZERO);\n+    assert_eq!(Duration::ZERO.saturating_sub(Duration::SECOND), Duration::ZERO);\n }\n \n #[test]\n@@ -337,87 +337,82 @@ fn duration_const() {\n     const SUB_SEC_NANOS: u32 = DURATION.subsec_nanos();\n     assert_eq!(SUB_SEC_NANOS, 123_456_789);\n \n-    const ZERO: Duration = Duration::zero();\n-    assert_eq!(ZERO, Duration::new(0, 0));\n-\n-    const IS_ZERO: bool = ZERO.is_zero();\n+    const IS_ZERO: bool = Duration::ZERO.is_zero();\n     assert!(IS_ZERO);\n \n-    const ONE: Duration = Duration::new(1, 0);\n-\n-    const SECONDS: u64 = ONE.as_secs();\n+    const SECONDS: u64 = Duration::SECOND.as_secs();\n     assert_eq!(SECONDS, 1);\n \n     const FROM_SECONDS: Duration = Duration::from_secs(1);\n-    assert_eq!(FROM_SECONDS, ONE);\n+    assert_eq!(FROM_SECONDS, Duration::SECOND);\n \n-    const SECONDS_F32: f32 = ONE.as_secs_f32();\n+    const SECONDS_F32: f32 = Duration::SECOND.as_secs_f32();\n     assert_eq!(SECONDS_F32, 1.0);\n \n     const FROM_SECONDS_F32: Duration = Duration::from_secs_f32(1.0);\n-    assert_eq!(FROM_SECONDS_F32, ONE);\n+    assert_eq!(FROM_SECONDS_F32, Duration::SECOND);\n \n-    const SECONDS_F64: f64 = ONE.as_secs_f64();\n+    const SECONDS_F64: f64 = Duration::SECOND.as_secs_f64();\n     assert_eq!(SECONDS_F64, 1.0);\n \n     const FROM_SECONDS_F64: Duration = Duration::from_secs_f64(1.0);\n-    assert_eq!(FROM_SECONDS_F64, ONE);\n+    assert_eq!(FROM_SECONDS_F64, Duration::SECOND);\n \n-    const MILLIS: u128 = ONE.as_millis();\n+    const MILLIS: u128 = Duration::SECOND.as_millis();\n     assert_eq!(MILLIS, 1_000);\n \n     const FROM_MILLIS: Duration = Duration::from_millis(1_000);\n-    assert_eq!(FROM_MILLIS, ONE);\n+    assert_eq!(FROM_MILLIS, Duration::SECOND);\n \n-    const MICROS: u128 = ONE.as_micros();\n+    const MICROS: u128 = Duration::SECOND.as_micros();\n     assert_eq!(MICROS, 1_000_000);\n \n     const FROM_MICROS: Duration = Duration::from_micros(1_000_000);\n-    assert_eq!(FROM_MICROS, ONE);\n+    assert_eq!(FROM_MICROS, Duration::SECOND);\n \n-    const NANOS: u128 = ONE.as_nanos();\n+    const NANOS: u128 = Duration::SECOND.as_nanos();\n     assert_eq!(NANOS, 1_000_000_000);\n \n     const FROM_NANOS: Duration = Duration::from_nanos(1_000_000_000);\n-    assert_eq!(FROM_NANOS, ONE);\n+    assert_eq!(FROM_NANOS, Duration::SECOND);\n \n     const MAX: Duration = Duration::new(u64::MAX, 999_999_999);\n \n-    const CHECKED_ADD: Option<Duration> = MAX.checked_add(ONE);\n+    const CHECKED_ADD: Option<Duration> = MAX.checked_add(Duration::SECOND);\n     assert_eq!(CHECKED_ADD, None);\n \n-    const CHECKED_SUB: Option<Duration> = ZERO.checked_sub(ONE);\n+    const CHECKED_SUB: Option<Duration> = Duration::ZERO.checked_sub(Duration::SECOND);\n     assert_eq!(CHECKED_SUB, None);\n \n-    const CHECKED_MUL: Option<Duration> = ONE.checked_mul(1);\n-    assert_eq!(CHECKED_MUL, Some(ONE));\n+    const CHECKED_MUL: Option<Duration> = Duration::SECOND.checked_mul(1);\n+    assert_eq!(CHECKED_MUL, Some(Duration::SECOND));\n \n-    const MUL_F32: Duration = ONE.mul_f32(1.0);\n-    assert_eq!(MUL_F32, ONE);\n+    const MUL_F32: Duration = Duration::SECOND.mul_f32(1.0);\n+    assert_eq!(MUL_F32, Duration::SECOND);\n \n-    const MUL_F64: Duration = ONE.mul_f64(1.0);\n-    assert_eq!(MUL_F64, ONE);\n+    const MUL_F64: Duration = Duration::SECOND.mul_f64(1.0);\n+    assert_eq!(MUL_F64, Duration::SECOND);\n \n-    const CHECKED_DIV: Option<Duration> = ONE.checked_div(1);\n-    assert_eq!(CHECKED_DIV, Some(ONE));\n+    const CHECKED_DIV: Option<Duration> = Duration::SECOND.checked_div(1);\n+    assert_eq!(CHECKED_DIV, Some(Duration::SECOND));\n \n-    const DIV_F32: Duration = ONE.div_f32(1.0);\n-    assert_eq!(DIV_F32, ONE);\n+    const DIV_F32: Duration = Duration::SECOND.div_f32(1.0);\n+    assert_eq!(DIV_F32, Duration::SECOND);\n \n-    const DIV_F64: Duration = ONE.div_f64(1.0);\n-    assert_eq!(DIV_F64, ONE);\n+    const DIV_F64: Duration = Duration::SECOND.div_f64(1.0);\n+    assert_eq!(DIV_F64, Duration::SECOND);\n \n-    const DIV_DURATION_F32: f32 = ONE.div_duration_f32(ONE);\n+    const DIV_DURATION_F32: f32 = Duration::SECOND.div_duration_f32(Duration::SECOND);\n     assert_eq!(DIV_DURATION_F32, 1.0);\n \n-    const DIV_DURATION_F64: f64 = ONE.div_duration_f64(ONE);\n+    const DIV_DURATION_F64: f64 = Duration::SECOND.div_duration_f64(Duration::SECOND);\n     assert_eq!(DIV_DURATION_F64, 1.0);\n \n-    const SATURATING_ADD: Duration = MAX.saturating_add(ONE);\n+    const SATURATING_ADD: Duration = MAX.saturating_add(Duration::SECOND);\n     assert_eq!(SATURATING_ADD, MAX);\n \n-    const SATURATING_SUB: Duration = ZERO.saturating_sub(ONE);\n-    assert_eq!(SATURATING_SUB, ZERO);\n+    const SATURATING_SUB: Duration = Duration::ZERO.saturating_sub(Duration::SECOND);\n+    assert_eq!(SATURATING_SUB, Duration::ZERO);\n \n     const SATURATING_MUL: Duration = MAX.saturating_mul(2);\n     assert_eq!(SATURATING_MUL, MAX);"}, {"sha": "fa2608e6fb6d3385a6a70cd501d15d16316087af", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -257,6 +257,7 @@\n #![feature(doc_spotlight)]\n #![feature(dropck_eyepatch)]\n #![feature(duration_constants)]\n+#![feature(duration_zero)]\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]"}, {"sha": "20c813fdc70ff6f8a833fcb0ed766e5d51f95b07", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -5,7 +5,7 @@ macro_rules! assert_almost_eq {\n         let (a, b) = ($a, $b);\n         if a != b {\n             let (a, b) = if a > b { (a, b) } else { (b, a) };\n-            assert!(a - Duration::new(0, 1000) <= b, \"{:?} is not almost equal to {:?}\", a, b);\n+            assert!(a - Duration::from_micros(1) <= b, \"{:?} is not almost equal to {:?}\", a, b);\n         }\n     }};\n }\n@@ -34,7 +34,7 @@ fn instant_math() {\n     assert_almost_eq!(b - dur, a);\n     assert_almost_eq!(a + dur, b);\n \n-    let second = Duration::new(1, 0);\n+    let second = Duration::SECOND;\n     assert_almost_eq!(a - second + second, a);\n     assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n@@ -65,32 +65,32 @@ fn instant_math_is_associative() {\n #[should_panic]\n fn instant_duration_since_panic() {\n     let a = Instant::now();\n-    (a - Duration::new(1, 0)).duration_since(a);\n+    (a - Duration::SECOND).duration_since(a);\n }\n \n #[test]\n fn instant_checked_duration_since_nopanic() {\n     let now = Instant::now();\n-    let earlier = now - Duration::new(1, 0);\n-    let later = now + Duration::new(1, 0);\n+    let earlier = now - Duration::SECOND;\n+    let later = now + Duration::SECOND;\n     assert_eq!(earlier.checked_duration_since(now), None);\n-    assert_eq!(later.checked_duration_since(now), Some(Duration::new(1, 0)));\n-    assert_eq!(now.checked_duration_since(now), Some(Duration::new(0, 0)));\n+    assert_eq!(later.checked_duration_since(now), Some(Duration::SECOND));\n+    assert_eq!(now.checked_duration_since(now), Some(Duration::ZERO));\n }\n \n #[test]\n fn instant_saturating_duration_since_nopanic() {\n     let a = Instant::now();\n-    let ret = (a - Duration::new(1, 0)).saturating_duration_since(a);\n-    assert_eq!(ret, Duration::new(0, 0));\n+    let ret = (a - Duration::SECOND).saturating_duration_since(a);\n+    assert_eq!(ret, Duration::ZERO);\n }\n \n #[test]\n fn system_time_math() {\n     let a = SystemTime::now();\n     let b = SystemTime::now();\n     match b.duration_since(a) {\n-        Ok(dur) if dur == Duration::new(0, 0) => {\n+        Ok(Duration::ZERO) => {\n             assert_almost_eq!(a, b);\n         }\n         Ok(dur) => {\n@@ -106,16 +106,16 @@ fn system_time_math() {\n         }\n     }\n \n-    let second = Duration::new(1, 0);\n+    let second = Duration::SECOND;\n     assert_almost_eq!(a.duration_since(a - second).unwrap(), second);\n     assert_almost_eq!(a.duration_since(a + second).unwrap_err().duration(), second);\n \n     assert_almost_eq!(a - second + second, a);\n     assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n-    let one_second_from_epoch = UNIX_EPOCH + Duration::new(1, 0);\n+    let one_second_from_epoch = UNIX_EPOCH + Duration::SECOND;\n     let one_second_from_epoch2 =\n-        UNIX_EPOCH + Duration::new(0, 500_000_000) + Duration::new(0, 500_000_000);\n+        UNIX_EPOCH + Duration::from_millis(500) + Duration::from_millis(500);\n     assert_eq!(one_second_from_epoch, one_second_from_epoch2);\n \n     // checked_add_duration will not panic on overflow\n@@ -141,12 +141,12 @@ fn system_time_elapsed() {\n #[test]\n fn since_epoch() {\n     let ts = SystemTime::now();\n-    let a = ts.duration_since(UNIX_EPOCH + Duration::new(1, 0)).unwrap();\n+    let a = ts.duration_since(UNIX_EPOCH + Duration::SECOND).unwrap();\n     let b = ts.duration_since(UNIX_EPOCH).unwrap();\n     assert!(b > a);\n-    assert_eq!(b - a, Duration::new(1, 0));\n+    assert_eq!(b - a, Duration::SECOND);\n \n-    let thirty_years = Duration::new(1, 0) * 60 * 60 * 24 * 365 * 30;\n+    let thirty_years = Duration::SECOND * 60 * 60 * 24 * 365 * 30;\n \n     // Right now for CI this test is run in an emulator, and apparently the\n     // aarch64 emulator's sense of time is that we're still living in the"}, {"sha": "3d724c148422724c2af9d8b39a2e68e79893326c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -264,7 +264,7 @@ impl<'a> ShouldRun<'a> {\n     /// `all_krates` should probably be removed at some point.\n     pub fn all_krates(mut self, name: &str) -> Self {\n         let mut set = BTreeSet::new();\n-        for krate in self.builder.in_tree_crates(name) {\n+        for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n             set.insert(path);\n         }\n@@ -277,7 +277,7 @@ impl<'a> ShouldRun<'a> {\n     ///\n     /// `make_run` will be called separately for each matching command-line path.\n     pub fn krate(mut self, name: &str) -> Self {\n-        for krate in self.builder.in_tree_crates(name) {\n+        for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n             self.paths.insert(PathSet::one(path));\n         }"}, {"sha": "ecca12108b65961f0340292b7e6415822fe45fb1", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -108,7 +108,7 @@ impl Step for Std {\n             // Explicitly pass -p for all dependencies krates -- this will force cargo\n             // to also check the tests/benches/examples for these crates, rather\n             // than just the leaf crate.\n-            for krate in builder.in_tree_crates(\"test\") {\n+            for krate in builder.in_tree_crates(\"test\", Some(target)) {\n                 cargo.arg(\"-p\").arg(krate.name);\n             }\n \n@@ -172,7 +172,7 @@ impl Step for Rustc {\n         // Explicitly pass -p for all compiler krates -- this will force cargo\n         // to also check the tests/benches/examples for these crates, rather\n         // than just the leaf crate.\n-        for krate in builder.in_tree_crates(\"rustc-main\") {\n+        for krate in builder.in_tree_crates(\"rustc-main\", Some(target)) {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n "}, {"sha": "cdad1cb4d499dc53446be4b92d7323f972a072a8", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -143,7 +143,7 @@ fn copy_third_party_objects(\n         }\n     }\n \n-    if builder.config.sanitizers && compiler.stage != 0 {\n+    if builder.config.sanitizers_enabled(target) && compiler.stage != 0 {\n         // The sanitizers are only copied in stage1 or above,\n         // to avoid creating dependency on LLVM.\n         target_deps.extend(\n@@ -251,7 +251,7 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car\n             .arg(\"--features\")\n             .arg(features);\n     } else {\n-        let mut features = builder.std_features();\n+        let mut features = builder.std_features(target);\n         features.push_str(compiler_builtins_c_feature);\n \n         cargo"}, {"sha": "c0753d88504aef655b3abc9bc0140507db8800b7", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -279,6 +279,8 @@ pub struct Target {\n     pub ranlib: Option<PathBuf>,\n     pub linker: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n+    pub sanitizers: bool,\n+    pub profiler: bool,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub musl_libdir: Option<PathBuf>,\n@@ -503,6 +505,8 @@ struct TomlTarget {\n     llvm_config: Option<String>,\n     llvm_filecheck: Option<String>,\n     android_ndk: Option<String>,\n+    sanitizers: Option<bool>,\n+    profiler: Option<bool>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n     musl_libdir: Option<String>,\n@@ -890,6 +894,8 @@ impl Config {\n                 target.musl_libdir = cfg.musl_libdir.map(PathBuf::from);\n                 target.wasi_root = cfg.wasi_root.map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.map(PathBuf::from);\n+                target.sanitizers = cfg.sanitizers.unwrap_or(build.sanitizers.unwrap_or_default());\n+                target.profiler = cfg.profiler.unwrap_or(build.profiler.unwrap_or_default());\n \n                 config.target_config.insert(TargetSelection::from_user(&triple), target);\n             }\n@@ -999,6 +1005,22 @@ impl Config {\n         self.verbose > 1\n     }\n \n+    pub fn sanitizers_enabled(&self, target: TargetSelection) -> bool {\n+        self.target_config.get(&target).map(|t| t.sanitizers).unwrap_or(self.sanitizers)\n+    }\n+\n+    pub fn any_sanitizers_enabled(&self) -> bool {\n+        self.target_config.values().any(|t| t.sanitizers) || self.sanitizers\n+    }\n+\n+    pub fn profiler_enabled(&self, target: TargetSelection) -> bool {\n+        self.target_config.get(&target).map(|t| t.profiler).unwrap_or(self.profiler)\n+    }\n+\n+    pub fn any_profiler_enabled(&self) -> bool {\n+        self.target_config.values().any(|t| t.profiler) || self.profiler\n+    }\n+\n     pub fn llvm_enabled(&self) -> bool {\n         self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n     }"}, {"sha": "5ce5737f318c73f46d2d2ccd5a6455c8b1a9a6f5", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1040,6 +1040,30 @@ impl Step for Src {\n             builder.copy(&builder.src.join(file), &dst_src.join(file));\n         }\n \n+        // libtest includes std and everything else, so vendoring it\n+        // creates exactly what's needed for `cargo -Zbuild-std` or any\n+        // other analysis of the stdlib's source. Cargo also needs help\n+        // finding the lock, so we copy it to libtest temporarily.\n+        //\n+        // Note that this requires std to only have one version of each\n+        // crate. e.g. two versions of getopts won't be patchable.\n+        let dst_libtest = dst_src.join(\"library/test\");\n+        let dst_vendor = dst_src.join(\"vendor\");\n+        let root_lock = dst_src.join(\"Cargo.lock\");\n+        let temp_lock = dst_libtest.join(\"Cargo.lock\");\n+\n+        // `cargo vendor` will delete everything from the lockfile that\n+        // isn't used by libtest, so we need to not use any links!\n+        builder.really_copy(&root_lock, &temp_lock);\n+\n+        let mut cmd = Command::new(&builder.initial_cargo);\n+        cmd.arg(\"vendor\").arg(dst_vendor).current_dir(&dst_libtest);\n+        builder.info(\"Dist src\");\n+        let _time = timeit(builder);\n+        builder.run(&mut cmd);\n+\n+        builder.remove(&temp_lock);\n+\n         // Create source tarball in rust-installer format\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -1056,8 +1080,6 @@ impl Step for Src {\n             .arg(\"--component-name=rust-src\")\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n \n-        builder.info(\"Dist src\");\n-        let _time = timeit(builder);\n         builder.run(&mut cmd);\n \n         builder.remove_dir(&image);"}, {"sha": "af7f7eff89418be4ad24d2c265712c0edea1fd32", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -535,8 +535,12 @@ impl Step for Rustc {\n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n         for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n-            compiler_crates\n-                .extend(builder.in_tree_crates(root_crate).into_iter().map(|krate| krate.name));\n+            compiler_crates.extend(\n+                builder\n+                    .in_tree_crates(root_crate, Some(target))\n+                    .into_iter()\n+                    .map(|krate| krate.name),\n+            );\n         }\n \n         for krate in &compiler_crates {"}, {"sha": "ca140b9d278287911d6277f84cb7d25d4c698f9b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -169,18 +169,19 @@ pub use crate::config::Config;\n pub use crate::flags::Subcommand;\n \n const LLVM_TOOLS: &[&str] = &[\n-    \"llvm-nm\", // used to inspect binaries; it shows symbol names, their sizes and visibility\n-    \"llvm-objcopy\", // used to transform ELFs into binary format which flashing tools consume\n-    \"llvm-objdump\", // used to disassemble programs\n+    \"llvm-cov\",      // used to generate coverage report\n+    \"llvm-nm\",       // used to inspect binaries; it shows symbol names, their sizes and visibility\n+    \"llvm-objcopy\",  // used to transform ELFs into binary format which flashing tools consume\n+    \"llvm-objdump\",  // used to disassemble programs\n     \"llvm-profdata\", // used to inspect and merge files generated by profiles\n-    \"llvm-readobj\", // used to get information from ELFs/objects that the other tools don't provide\n-    \"llvm-size\", // used to prints the size of the linker sections of a program\n-    \"llvm-strip\", // used to discard symbols from binary files to reduce their size\n-    \"llvm-ar\", // used for creating and modifying archive files\n-    \"llvm-as\", // used to convert LLVM assembly to LLVM bitcode\n-    \"llvm-dis\", // used to disassemble LLVM bitcode\n-    \"llc\",     // used to compile LLVM bytecode\n-    \"opt\",     // used to optimize LLVM bytecode\n+    \"llvm-readobj\",  // used to get information from ELFs/objects that the other tools don't provide\n+    \"llvm-size\",     // used to prints the size of the linker sections of a program\n+    \"llvm-strip\",    // used to discard symbols from binary files to reduce their size\n+    \"llvm-ar\",       // used for creating and modifying archive files\n+    \"llvm-as\",       // used to convert LLVM assembly to LLVM bitcode\n+    \"llvm-dis\",      // used to disassemble LLVM bitcode\n+    \"llc\",           // used to compile LLVM bytecode\n+    \"opt\",           // used to optimize LLVM bytecode\n ];\n \n pub const VERSION: usize = 2;\n@@ -542,7 +543,7 @@ impl Build {\n \n     /// Gets the space-separated set of activated features for the standard\n     /// library.\n-    fn std_features(&self) -> String {\n+    fn std_features(&self, target: TargetSelection) -> String {\n         let mut features = \"panic-unwind\".to_string();\n \n         match self.config.llvm_libunwind.unwrap_or_default() {\n@@ -553,7 +554,7 @@ impl Build {\n         if self.config.backtrace {\n             features.push_str(\" backtrace\");\n         }\n-        if self.config.profiler {\n+        if self.config.profiler_enabled(target) {\n             features.push_str(\" profiler\");\n         }\n         features\n@@ -1116,7 +1117,7 @@ impl Build {\n     /// Returns a Vec of all the dependencies of the given root crate,\n     /// including transitive dependencies and the root itself. Only includes\n     /// \"local\" crates (those in the local source tree, not from a registry).\n-    fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n+    fn in_tree_crates(&self, root: &str, target: Option<TargetSelection>) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n         let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n@@ -1137,7 +1138,10 @@ impl Build {\n                 // metadata::build.\n                 if visited.insert(dep)\n                     && dep != \"build_helper\"\n-                    && (dep != \"profiler_builtins\" || self.config.profiler)\n+                    && (dep != \"profiler_builtins\"\n+                        || target\n+                            .map(|t| self.config.profiler_enabled(t))\n+                            .unwrap_or(self.config.any_profiler_enabled()))\n                     && (dep != \"rustc_codegen_llvm\" || self.config.llvm_enabled())\n                 {\n                     list.push(*dep);\n@@ -1172,6 +1176,27 @@ impl Build {\n         paths\n     }\n \n+    /// Copies a file from `src` to `dst` and doesn't use links, so\n+    /// that the copy can be modified without affecting the original.\n+    pub fn really_copy(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run {\n+            return;\n+        }\n+        self.verbose_than(1, &format!(\"Copy {:?} to {:?}\", src, dst));\n+        if src == dst {\n+            return;\n+        }\n+        let _ = fs::remove_file(&dst);\n+        let metadata = t!(src.symlink_metadata());\n+        if let Err(e) = fs::copy(src, dst) {\n+            panic!(\"failed to copy `{}` to `{}`: {}\", src.display(), dst.display(), e)\n+        }\n+        t!(fs::set_permissions(dst, metadata.permissions()));\n+        let atime = FileTime::from_last_access_time(&metadata);\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        t!(filetime::set_file_times(dst, atime, mtime));\n+    }\n+\n     /// Copies a file from `src` to `dst`\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run {"}, {"sha": "4cfcf6ca407b5b17a856f695ac64772738074933", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -91,7 +91,7 @@ pub fn check(build: &mut Build) {\n                 .unwrap_or(true)\n         })\n         .any(|build_llvm_ourselves| build_llvm_ourselves);\n-    if building_llvm || build.config.sanitizers {\n+    if building_llvm || build.config.any_sanitizers_enabled() {\n         cmd_finder.must_have(\"cmake\");\n     }\n "}, {"sha": "60808dcba6144ac950d9188fc260a1bf6d058574", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1271,11 +1271,11 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         builder.add_rust_test_threads(&mut cmd);\n \n-        if builder.config.sanitizers {\n+        if builder.config.sanitizers_enabled(target) {\n             cmd.env(\"RUSTC_SANITIZER_SUPPORT\", \"1\");\n         }\n \n-        if builder.config.profiler {\n+        if builder.config.profiler_enabled(target) {\n             cmd.env(\"RUSTC_PROFILER_SUPPORT\", \"1\");\n         }\n \n@@ -1591,7 +1591,7 @@ impl Step for CrateLibrustc {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.build_triple());\n \n-        for krate in builder.in_tree_crates(\"rustc-main\") {\n+        for krate in builder.in_tree_crates(\"rustc-main\", Some(run.target)) {\n             if krate.path.ends_with(&run.path) {\n                 let test_kind = builder.kind.into();\n \n@@ -1698,7 +1698,7 @@ impl Step for Crate {\n             });\n         };\n \n-        for krate in builder.in_tree_crates(\"test\") {\n+        for krate in builder.in_tree_crates(\"test\", Some(run.target)) {\n             if krate.path.ends_with(&run.path) {\n                 make(Mode::Std, krate);\n             }"}, {"sha": "fcf869b68be7100c10401accceb73eb60e438291", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -29,7 +29,8 @@ mkdir ../gcc-build\n cd ../gcc-build\n hide_output ../gcc-$GCC/configure \\\n     --prefix=/rustroot \\\n-    --enable-languages=c,c++\n+    --enable-languages=c,c++ \\\n+    --disable-gnu-unique-object\n hide_output make -j10\n hide_output make install\n ln -s gcc /rustroot/bin/cc"}, {"sha": "c9d4f51cbf3a7e4a78d0d387ae109bfcae01db0e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 247, "deletions": 167, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -1,3 +1,7 @@\n+//! This module implements [RFC 1946]: Intra-rustdoc-links\n+//!\n+//! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n+\n use rustc_ast as ast;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -27,7 +31,7 @@ use std::cell::Cell;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::*;\n+use crate::clean::{self, Crate, GetDefId, Import, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -42,10 +46,10 @@ pub const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    let mut coll = LinkCollector::new(cx);\n-    coll.fold_crate(krate)\n+    LinkCollector::new(cx).fold_crate(krate)\n }\n \n+/// Top-level errors emitted by this pass.\n enum ErrorKind<'a> {\n     Resolve(Box<ResolutionFailure<'a>>),\n     AnchorFailure(AnchorFailure),\n@@ -58,18 +62,37 @@ impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n }\n \n #[derive(Debug)]\n+/// A link failed to resolve.\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n-    /// `Namespace` is the expected namespace (as opposed to the actual).\n-    WrongNamespace(Res, Namespace),\n+    ///\n+    /// `Namespace` is the namespace specified with a disambiguator\n+    /// (as opposed to the actual namespace of the `Res`).\n+    WrongNamespace(Res, /* disambiguated */ Namespace),\n     /// The link failed to resolve. `resolution_failure` should look to see if there's\n     /// a more helpful error that can be given.\n-    NotResolved { module_id: DefId, partial_res: Option<Res>, unresolved: Cow<'a, str> },\n-    /// should not ever happen\n+    NotResolved {\n+        /// The scope the link was resolved in.\n+        module_id: DefId,\n+        /// If part of the link resolved, this has the `Res`.\n+        ///\n+        /// In `[std::io::Error::x]`, `std::io::Error` would be a partial resolution.\n+        partial_res: Option<Res>,\n+        /// The remaining unresolved path segments.\n+        ///\n+        /// In `[std::io::Error::x]`, `x` would be unresolved.\n+        unresolved: Cow<'a, str>,\n+    },\n+    /// This happens when rustdoc can't determine the parent scope for an item.\n+    ///\n+    /// It is always a bug in rustdoc.\n     NoParentItem,\n     /// This link has malformed generic parameters; e.g., the angle brackets are unbalanced.\n     MalformedGenerics(MalformedGenerics),\n-    /// used to communicate that this should be ignored, but shouldn't be reported to the user\n+    /// Used to communicate that this should be ignored, but shouldn't be reported to the user\n+    ///\n+    /// This happens when there is no disambiguator and one of the namespaces\n+    /// failed to resolve.\n     Dummy,\n }\n \n@@ -115,7 +138,9 @@ enum MalformedGenerics {\n }\n \n impl ResolutionFailure<'a> {\n-    // This resolved fully (not just partially) but is erroneous for some other reason\n+    /// This resolved fully (not just partially) but is erroneous for some other reason\n+    ///\n+    /// Returns the full resolution of the link, if present.\n     fn full_res(&self) -> Option<Res> {\n         match self {\n             Self::WrongNamespace(res, _) => Some(*res),\n@@ -125,13 +150,30 @@ impl ResolutionFailure<'a> {\n }\n \n enum AnchorFailure {\n+    /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n+    /// The anchor provided by the user conflicts with Rustdoc's generated anchor.\n+    ///\n+    /// This is an unfortunate state of affairs. Not every item that can be\n+    /// linked to has its own page; sometimes it is a subheading within a page,\n+    /// like for associated items. In those cases, rustdoc uses an anchor to\n+    /// link to the subheading. Since you can't have two anchors for the same\n+    /// link, Rustdoc disallows having a user-specified anchor.\n+    ///\n+    /// Most of the time this is fine, because you can just link to the page of\n+    /// the item if you want to provide your own anchor. For primitives, though,\n+    /// rustdoc uses the anchor as a side channel to know which page to link to;\n+    /// it doesn't show up in the generated link. Ideally, rustdoc would remove\n+    /// this limitation, allowing you to link to subheaders on primitives.\n     RustdocAnchorConflict(Res),\n }\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n-    // NOTE: this may not necessarily be a module in the current crate\n+    /// A stack of modules used to decide what scope to resolve in.\n+    ///\n+    /// The last module will be used if the parent scope of the current item is\n+    /// unknown.\n     mod_ids: Vec<DefId>,\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n@@ -144,6 +186,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         LinkCollector { cx, mod_ids: Vec::new(), kind_side_channel: Cell::new(None) }\n     }\n \n+    /// Given a full link, parse it as an [enum struct variant].\n+    ///\n+    /// In particular, this will return an error whenever there aren't three\n+    /// full path segments left in the link.\n+    ///\n+    /// [enum struct variant]: hir::VariantData::Struct\n     fn variant_field(\n         &self,\n         path_str: &'path str,\n@@ -235,6 +283,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    /// Given a primitive type, try to resolve an associated item.\n+    ///\n+    /// HACK(jynelson): `item_str` is passed in instead of derived from `item_name` so the\n+    /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n         prim_ty: hir::PrimTy,\n@@ -286,14 +338,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n \n     /// Resolves a string as a macro.\n-    fn macro_resolve(\n+    ///\n+    /// FIXME(jynelson): Can this be unified with `resolve()`?\n+    fn resolve_macro(\n         &self,\n         path_str: &'a str,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n         cx.enter_resolver(|resolver| {\n+            // FIXME(jynelson): does this really need 3 separate lookups?\n             if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n                 &path,\n                 None,\n@@ -326,6 +381,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    /// Convenience wrapper around `resolve_str_path_error`.\n+    ///\n+    /// This also handles resolving `true` and `false` as booleans.\n+    /// NOTE: `resolve_str_path_error` knows only about paths, not about types.\n+    /// Associated items will never be resolved by this function.\n     fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n         let result = self.cx.enter_resolver(|resolver| {\n             resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n@@ -339,12 +399,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n-    /// Resolves a string as a path within a particular namespace. Also returns an optional\n-    /// URL fragment in the case of variants and methods.\n+    /// Resolves a string as a path within a particular namespace. Returns an\n+    /// optional URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n         &self,\n         path_str: &'path str,\n         ns: Namespace,\n+        // FIXME(#76467): This is for `Self`, and it's wrong.\n         current_item: &Option<String>,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n@@ -353,15 +414,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n+                // FIXME(#76467): make this fallthrough to lookup the associated\n+                // item a separate function.\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => {\n                     assert_eq!(ns, ValueNS);\n-                    // Fall through: In case this is a trait item, skip the\n-                    // early return and try looking for the trait.\n                 }\n                 Res::Def(DefKind::AssocTy, _) => {\n                     assert_eq!(ns, TypeNS);\n-                    // Fall through: In case this is a trait item, skip the\n-                    // early return and try looking for the trait.\n                 }\n                 Res::Def(DefKind::Variant, _) => {\n                     return handle_variant(cx, res, extra_fragment);\n@@ -410,7 +469,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })?;\n \n         // FIXME: are these both necessary?\n-        let ty_res = if let Some(ty_res) = is_primitive(&path_root, TypeNS)\n+        let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n             .map(|(_, res)| res)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n         {\n@@ -452,8 +511,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // There should only ever be one associated item that matches from any inherent impl\n                     .next()\n                     // Check if item_name belongs to `impl SomeTrait for SomeItem`\n-                    // This gives precedence to `impl SomeItem`:\n-                    // Although having both would be ambiguous, use impl version for compat. sake.\n+                    // FIXME(#74563): This gives precedence to `impl SomeItem`:\n+                    // Although having both would be ambiguous, use impl version for compatibility's sake.\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n@@ -480,6 +539,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     })\n                 } else if ns == Namespace::ValueNS {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                    // FIXME(jynelson): why is this different from\n+                    // `variant_field`?\n                     match cx.tcx.type_of(did).kind() {\n                         ty::Adt(def, _) => {\n                             let field = if def.is_enum() {\n@@ -577,7 +638,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n-            Namespace::MacroNS => self.macro_resolve(path_str, module_id).map_err(ErrorKind::from),\n+            Namespace::MacroNS => self.resolve_macro(path_str, module_id).map_err(ErrorKind::from),\n             Namespace::TypeNS | Namespace::ValueNS => self\n                 .resolve(path_str, ns, current_item, module_id, extra_fragment)\n                 .map(|(res, _)| res),\n@@ -593,6 +654,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n }\n \n+/// Look to see if a resolved item has an associated item named `item_name`.\n+///\n+/// Given `[std::io::Error::source]`, where `source` is unresolved, this would\n+/// find `std::error::Error::source` and return\n+/// `<io::Error as error::Error>::source`.\n fn resolve_associated_trait_item(\n     did: DefId,\n     module: DefId,\n@@ -601,12 +667,12 @@ fn resolve_associated_trait_item(\n     cx: &DocContext<'_>,\n ) -> Option<(ty::AssocKind, DefId)> {\n     let ty = cx.tcx.type_of(did);\n-    // First consider automatic impls: `impl From<T> for T`\n+    // First consider blanket impls: `impl From<T> for T`\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n     let mut candidates: Vec<_> = implicit_impls\n         .flat_map(|impl_outer| {\n             match impl_outer.inner {\n-                ImplItem(impl_) => {\n+                clean::ImplItem(impl_) => {\n                     debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n                     // Give precedence to methods that were overridden\n                     if !impl_.provided_trait_methods.contains(&*item_name.as_str()) {\n@@ -669,7 +735,7 @@ fn resolve_associated_trait_item(\n                 .map(|assoc| (assoc.kind, assoc.def_id))\n         }));\n     }\n-    // FIXME: warn about ambiguity\n+    // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates);\n     candidates.pop()\n }\n@@ -719,20 +785,15 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n     iter.collect()\n }\n \n-/// Check for resolve collisions between a trait and its derive\n+/// Check for resolve collisions between a trait and its derive.\n ///\n-/// These are common and we should just resolve to the trait in that case\n+/// These are common and we should just resolve to the trait in that case.\n fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n-    if let PerNS {\n+    matches!(*ns, PerNS {\n         type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n         macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n         ..\n-    } = *ns\n-    {\n-        true\n-    } else {\n-        false\n-    }\n+    })\n }\n \n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n@@ -772,29 +833,30 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         let current_item = match item.inner {\n-            ModuleItem(..) => {\n+            clean::ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n                     if item.def_id.is_top_level_module() { item.name.clone() } else { None }\n                 } else {\n                     match parent_node.or(self.mod_ids.last().copied()) {\n                         Some(parent) if !parent.is_top_level_module() => {\n-                            // FIXME: can we pull the parent module's name from elsewhere?\n                             Some(self.cx.tcx.item_name(parent).to_string())\n                         }\n                         _ => None,\n                     }\n                 }\n             }\n-            ImplItem(Impl { ref for_, .. }) => {\n+            clean::ImplItem(clean::Impl { ref for_, .. }) => {\n                 for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n             }\n             // we don't display docs on `extern crate` items anyway, so don't process them.\n-            ExternCrateItem(..) => {\n+            clean::ExternCrateItem(..) => {\n                 debug!(\"ignoring extern crate item {:?}\", item.def_id);\n                 return self.fold_item_recur(item);\n             }\n-            ImportItem(Import { kind: ImportKind::Simple(ref name, ..), .. }) => Some(name.clone()),\n-            MacroItem(..) => None,\n+            clean::ImportItem(Import { kind: clean::ImportKind::Simple(ref name, ..), .. }) => {\n+                Some(name.clone())\n+            }\n+            clean::MacroItem(..) => None,\n             _ => item.name.clone(),\n         };\n \n@@ -803,6 +865,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         // find item's parent to resolve `Self` in item's docs below\n+        // FIXME(#76467, #75809): this is a mess and doesn't handle cross-crate\n+        // re-exports\n         let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {\n             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n             let item_parent = self.cx.tcx.hir().find(parent_hir);\n@@ -870,7 +934,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n-            // FIXME: this will break links that start in `#[doc = ...]` and end as a sugared doc. Should this be supported?\n             for (ori_link, link_range) in markdown_links(&combined_docs) {\n                 let link = self.resolve_link(\n                     &item,\n@@ -888,15 +951,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         }\n \n-        if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(item.def_id);\n-        }\n-\n         if item.is_mod() {\n-            let ret = self.fold_item_recur(item);\n+            if !item.attrs.inner_docs {\n+                self.mod_ids.push(item.def_id);\n+            }\n \n+            let ret = self.fold_item_recur(item);\n             self.mod_ids.pop();\n-\n             ret\n         } else {\n             self.fold_item_recur(item)\n@@ -905,6 +966,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n }\n \n impl LinkCollector<'_, '_> {\n+    /// This is the entry point for resolving an intra-doc link.\n+    ///\n+    /// FIXME(jynelson): this is way too many arguments\n     fn resolve_link(\n         &self,\n         item: &Item,\n@@ -943,129 +1007,120 @@ impl LinkCollector<'_, '_> {\n         } else {\n             (parts[0], None)\n         };\n-        let resolved_self;\n-        let link_text;\n-        let mut path_str;\n-        let disambiguator;\n-        let stripped_path_string;\n-        let (mut res, mut fragment) = {\n-            path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n-                disambiguator = Some(d);\n-                path\n-            } else {\n-                disambiguator = None;\n-                &link\n-            }\n-            .trim();\n \n-            if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, \".contains(ch))) {\n-                return None;\n-            }\n+        // Parse and strip the disambiguator from the link, if present.\n+        let (mut path_str, disambiguator) = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+            (path.trim(), Some(d))\n+        } else {\n+            (link.trim(), None)\n+        };\n \n-            // We stripped `()` and `!` when parsing the disambiguator.\n-            // Add them back to be displayed, but not prefix disambiguators.\n-            link_text = disambiguator\n-                .map(|d| d.display_for(path_str))\n-                .unwrap_or_else(|| path_str.to_owned());\n-\n-            // In order to correctly resolve intra-doc-links we need to\n-            // pick a base AST node to work from.  If the documentation for\n-            // this module came from an inner comment (//!) then we anchor\n-            // our name resolution *inside* the module.  If, on the other\n-            // hand it was an outer comment (///) then we anchor the name\n-            // resolution in the parent module on the basis that the names\n-            // used are more likely to be intended to be parent names.  For\n-            // this, we set base_node to None for inner comments since\n-            // we've already pushed this node onto the resolution stack but\n-            // for outer comments we explicitly try and resolve against the\n-            // parent_node first.\n-            let base_node = if item.is_mod() && item.attrs.inner_docs {\n-                self.mod_ids.last().copied()\n-            } else {\n-                parent_node\n-            };\n+        if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, \".contains(ch))) {\n+            return None;\n+        }\n \n-            let mut module_id = if let Some(id) = base_node {\n-                id\n-            } else {\n-                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-                let err_kind = ResolutionFailure::NoParentItem.into();\n-                resolution_failure(\n-                    self,\n-                    &item,\n-                    path_str,\n-                    disambiguator,\n-                    dox,\n-                    link_range,\n-                    smallvec![err_kind],\n-                );\n-                return None;\n-            };\n+        // We stripped `()` and `!` when parsing the disambiguator.\n+        // Add them back to be displayed, but not prefix disambiguators.\n+        let link_text =\n+            disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+\n+        // In order to correctly resolve intra-doc-links we need to\n+        // pick a base AST node to work from.  If the documentation for\n+        // this module came from an inner comment (//!) then we anchor\n+        // our name resolution *inside* the module.  If, on the other\n+        // hand it was an outer comment (///) then we anchor the name\n+        // resolution in the parent module on the basis that the names\n+        // used are more likely to be intended to be parent names.  For\n+        // this, we set base_node to None for inner comments since\n+        // we've already pushed this node onto the resolution stack but\n+        // for outer comments we explicitly try and resolve against the\n+        // parent_node first.\n+        let base_node = if item.is_mod() && item.attrs.inner_docs {\n+            self.mod_ids.last().copied()\n+        } else {\n+            parent_node\n+        };\n \n-            // replace `Self` with suitable item's parent name\n-            if path_str.starts_with(\"Self::\") {\n-                if let Some(ref name) = parent_name {\n-                    resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n-                    path_str = &resolved_self;\n-                }\n-            } else if path_str.starts_with(\"crate::\") {\n-                use rustc_span::def_id::CRATE_DEF_INDEX;\n-\n-                // HACK(jynelson): rustc_resolve thinks that `crate` is the crate currently being documented.\n-                // But rustdoc wants it to mean the crate this item was originally present in.\n-                // To work around this, remove it and resolve relative to the crate root instead.\n-                // HACK(jynelson)(2): If we just strip `crate::` then suddenly primitives become ambiguous\n-                // (consider `crate::char`). Instead, change it to `self::`. This works because 'self' is now the crate root.\n-                resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n-                path_str = &resolved_self;\n-                module_id = DefId { krate, index: CRATE_DEF_INDEX };\n-            }\n+        let mut module_id = if let Some(id) = base_node {\n+            id\n+        } else {\n+            // This is a bug.\n+            debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+            let err_kind = ResolutionFailure::NoParentItem.into();\n+            resolution_failure(\n+                self,\n+                &item,\n+                path_str,\n+                disambiguator,\n+                dox,\n+                link_range,\n+                smallvec![err_kind],\n+            );\n+            return None;\n+        };\n \n-            // Strip generics from the path.\n-            if path_str.contains(['<', '>'].as_slice()) {\n-                stripped_path_string = match strip_generics_from_path(path_str) {\n-                    Ok(path) => path,\n-                    Err(err_kind) => {\n-                        debug!(\"link has malformed generics: {}\", path_str);\n-                        resolution_failure(\n-                            self,\n-                            &item,\n-                            path_str,\n-                            disambiguator,\n-                            dox,\n-                            link_range,\n-                            smallvec![err_kind],\n-                        );\n-                        return None;\n-                    }\n-                };\n-                path_str = &stripped_path_string;\n+        let resolved_self;\n+        // replace `Self` with suitable item's parent name\n+        if path_str.starts_with(\"Self::\") {\n+            if let Some(ref name) = parent_name {\n+                resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n+                path_str = &resolved_self;\n             }\n+        } else if path_str.starts_with(\"crate::\") {\n+            use rustc_span::def_id::CRATE_DEF_INDEX;\n+\n+            // HACK(jynelson): rustc_resolve thinks that `crate` is the crate currently being documented.\n+            // But rustdoc wants it to mean the crate this item was originally present in.\n+            // To work around this, remove it and resolve relative to the crate root instead.\n+            // HACK(jynelson)(2): If we just strip `crate::` then suddenly primitives become ambiguous\n+            // (consider `crate::char`). Instead, change it to `self::`. This works because 'self' is now the crate root.\n+            // FIXME(#78696): This doesn't always work.\n+            resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n+            path_str = &resolved_self;\n+            module_id = DefId { krate, index: CRATE_DEF_INDEX };\n+        }\n \n-            // Sanity check to make sure we don't have any angle brackets after stripping generics.\n-            assert!(!path_str.contains(['<', '>'].as_slice()));\n+        // Strip generics from the path.\n+        let stripped_path_string;\n+        if path_str.contains(['<', '>'].as_slice()) {\n+            stripped_path_string = match strip_generics_from_path(path_str) {\n+                Ok(path) => path,\n+                Err(err_kind) => {\n+                    debug!(\"link has malformed generics: {}\", path_str);\n+                    resolution_failure(\n+                        self,\n+                        &item,\n+                        path_str,\n+                        disambiguator,\n+                        dox,\n+                        link_range,\n+                        smallvec![err_kind],\n+                    );\n+                    return None;\n+                }\n+            };\n+            path_str = &stripped_path_string;\n+        }\n+        // Sanity check to make sure we don't have any angle brackets after stripping generics.\n+        assert!(!path_str.contains(['<', '>'].as_slice()));\n \n-            // The link is not an intra-doc link if it still contains commas or spaces after\n-            // stripping generics.\n-            if path_str.contains([',', ' '].as_slice()) {\n-                return None;\n-            }\n+        // The link is not an intra-doc link if it still contains commas or spaces after\n+        // stripping generics.\n+        if path_str.contains([',', ' '].as_slice()) {\n+            return None;\n+        }\n \n-            match self.resolve_with_disambiguator(\n-                disambiguator,\n-                item,\n-                dox,\n-                path_str,\n-                current_item,\n-                module_id,\n-                extra_fragment,\n-                &ori_link,\n-                link_range.clone(),\n-            ) {\n-                Some(x) => x,\n-                None => return None,\n-            }\n-        };\n+        let (mut res, mut fragment) = self.resolve_with_disambiguator(\n+            disambiguator,\n+            item,\n+            dox,\n+            path_str,\n+            current_item,\n+            module_id,\n+            extra_fragment,\n+            &ori_link,\n+            link_range.clone(),\n+        )?;\n \n         // Check for a primitive which might conflict with a module\n         // Report the ambiguity and require that the user specify which one they meant.\n@@ -1075,7 +1130,7 @@ impl LinkCollector<'_, '_> {\n             None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n         ) && !matches!(res, Res::PrimTy(_))\n         {\n-            if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n+            if let Some((path, prim)) = resolve_primitive(path_str, TypeNS) {\n                 // `prim@char`\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n                     if fragment.is_some() {\n@@ -1168,11 +1223,13 @@ impl LinkCollector<'_, '_> {\n                     privacy_error(cx, &item, &path_str, dox, link_range);\n                 }\n             }\n-            let id = register_res(cx, res);\n+            let id = clean::register_res(cx, res);\n             Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n         }\n     }\n \n+    /// After parsing the disambiguator, resolve the main part of the link.\n+    // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n         &self,\n         disambiguator: Option<Disambiguator>,\n@@ -1232,7 +1289,7 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .macro_resolve(path_str, base_node)\n+                        .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n                     type_ns: match self.resolve(\n                         path_str,\n@@ -1320,10 +1377,10 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.macro_resolve(path_str, base_node) {\n+                match self.resolve_macro(path_str, base_node) {\n                     Ok(res) => Some((res, extra_fragment)),\n                     Err(mut kind) => {\n-                        // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                        // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n                             if let Some(res) = self.check_full_res(\n                                 ns,\n@@ -1354,9 +1411,15 @@ impl LinkCollector<'_, '_> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// Disambiguators for a link.\n enum Disambiguator {\n+    /// `prim@`\n+    ///\n+    /// This is buggy, see <https://github.com/rust-lang/rust/pull/77875#discussion_r503583103>\n     Primitive,\n+    /// `struct@` or `f()`\n     Kind(DefKind),\n+    /// `type@`\n     Namespace(Namespace),\n }\n \n@@ -1373,7 +1436,7 @@ impl Disambiguator {\n         }\n     }\n \n-    /// (disambiguator, path_str)\n+    /// Given a link, parse and return `(disambiguator, path_str)`\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};\n \n@@ -1424,6 +1487,7 @@ impl Disambiguator {\n         }\n     }\n \n+    /// Used for error reporting.\n     fn suggestion(self) -> Suggestion {\n         let kind = match self {\n             Disambiguator::Primitive => return Suggestion::Prefix(\"prim\"),\n@@ -1490,9 +1554,13 @@ impl Disambiguator {\n     }\n }\n \n+/// A suggestion to show in a diagnostic.\n enum Suggestion {\n+    /// `struct@`\n     Prefix(&'static str),\n+    /// `f()`\n     Function,\n+    /// `m!`\n     Macro,\n }\n \n@@ -1582,6 +1650,11 @@ fn report_diagnostic(\n     });\n }\n \n+/// Reports a link that failed to resolve.\n+///\n+/// This also tries to resolve any intermediate path segments that weren't\n+/// handled earlier. For example, if passed `Item::Crate(std)` and `path_str`\n+/// `std::io::Error::x`, this will resolve `std::io::Error`.\n fn resolution_failure(\n     collector: &LinkCollector<'_, '_>,\n     item: &Item,\n@@ -1816,6 +1889,7 @@ fn resolution_failure(\n     );\n }\n \n+/// Report an anchor failure.\n fn anchor_failure(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -1840,6 +1914,7 @@ fn anchor_failure(\n     });\n }\n \n+/// Report an ambiguity error, where there were multiple possible resolutions.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -1886,6 +1961,8 @@ fn ambiguity_error(\n     });\n }\n \n+/// In case of an ambiguity or mismatched disambiguator, suggest the correct\n+/// disambiguator.\n fn suggest_disambiguator(\n     disambiguator: Disambiguator,\n     diag: &mut DiagnosticBuilder<'_>,\n@@ -1911,6 +1988,7 @@ fn suggest_disambiguator(\n     }\n }\n \n+/// Report a link from a public item to a private one.\n fn privacy_error(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -1978,7 +2056,8 @@ const PRIMITIVES: &[(Symbol, Res)] = &[\n     (sym::char, Res::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n+/// Resolve a primitive type or value.\n+fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     is_bool_value(path_str, ns).or_else(|| {\n         if ns == TypeNS {\n             // FIXME: this should be replaced by a lookup in PrimitiveTypeTable\n@@ -1990,6 +2069,7 @@ fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     })\n }\n \n+/// Resolve a primitive value.\n fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n         Some((sym::bool, Res::PrimTy(hir::PrimTy::Bool)))"}, {"sha": "ae6f814c290c8ee060a81ae45844c79324e57056", "filename": "src/test/mir-opt/inline/inline-diverging.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline-diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline-diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-diverging.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,40 @@\n+// Tests inlining of diverging calls.\n+//\n+// ignore-wasm32-bare compiled with panic=abort by default\n+#![crate_type = \"lib\"]\n+\n+// EMIT_MIR inline_diverging.f.Inline.diff\n+pub fn f() {\n+    sleep();\n+}\n+\n+// EMIT_MIR inline_diverging.g.Inline.diff\n+pub fn g(i: i32) -> u32 {\n+    if i > 0 {\n+        i as u32\n+    } else {\n+        panic();\n+    }\n+}\n+\n+// EMIT_MIR inline_diverging.h.Inline.diff\n+pub fn h() {\n+    call_twice(sleep);\n+}\n+\n+#[inline(always)]\n+pub fn call_twice<R, F: Fn() -> R>(f: F) -> (R, R) {\n+    let a = f();\n+    let b = f();\n+    (a, b)\n+}\n+\n+#[inline(always)]\n+fn panic() -> ! {\n+    panic!();\n+}\n+\n+#[inline(always)]\n+fn sleep() -> ! {\n+    loop {}\n+}"}, {"sha": "477f050b69e42ac8fba5142de12ac62e4308b8dd", "filename": "src/test/mir-opt/inline/inline-options.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-options.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,19 @@\n+// Checks that inlining threshold can be controlled with\n+// inline-mir-threshold and inline-hint-threshold options.\n+//\n+// compile-flags: -Zinline-mir-threshold=90\n+// compile-flags: -Zinline-mir-hint-threshold=50\n+\n+// EMIT_MIR inline_options.main.Inline.after.mir\n+fn main() {\n+    not_inlined();\n+    inlined::<u32>();\n+}\n+\n+// Cost is approximately 3 * 25 + 5 = 80.\n+#[inline]\n+pub fn not_inlined() { g(); g(); g(); }\n+pub fn inlined<T>() { g(); g(); g(); }\n+\n+#[inline(never)]\n+fn g() {}"}, {"sha": "6e36dc06a201e87f731dc0831205beab12007384", "filename": "src/test/mir-opt/inline/inline_diverging.f.Inline.diff", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.f.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.f.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.f.Inline.diff?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,26 @@\n+- // MIR for `f` before Inline\n++ // MIR for `f` after Inline\n+  \n+  fn f() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:7:12: 7:12\n+      let mut _1: !;                       // in scope 0 at $DIR/inline-diverging.rs:7:12: 9:2\n+      let _2: !;                           // in scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++     let mut _3: !;                       // in scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++     scope 1 (inlined sleep) {            // at $DIR/inline-diverging.rs:8:5: 8:12\n++     }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n+-         sleep();                         // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-diverging.rs:8:5: 8:10\n+-                                          // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_3);                 // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++         goto -> bb1;                     // scope 0 at $DIR/inline-diverging.rs:8:5: 8:12\n++     }\n++ \n++     bb1: {\n++         goto -> bb1;                     // scope 1 at $DIR/inline-diverging.rs:8:5: 8:12\n+      }\n+  }\n+  "}, {"sha": "3dc33354a5a56d699a85c72c2bae44b9fb422343", "filename": "src/test/mir-opt/inline/inline_diverging.g.Inline.diff", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,52 @@\n+- // MIR for `g` before Inline\n++ // MIR for `g` after Inline\n+  \n+  fn g(_1: i32) -> u32 {\n+      debug i => _1;                       // in scope 0 at $DIR/inline-diverging.rs:12:10: 12:11\n+      let mut _0: u32;                     // return place in scope 0 at $DIR/inline-diverging.rs:12:21: 12:24\n+      let mut _2: bool;                    // in scope 0 at $DIR/inline-diverging.rs:13:8: 13:13\n+      let mut _3: i32;                     // in scope 0 at $DIR/inline-diverging.rs:13:8: 13:9\n+      let mut _4: i32;                     // in scope 0 at $DIR/inline-diverging.rs:14:9: 14:10\n+      let mut _5: !;                       // in scope 0 at $DIR/inline-diverging.rs:15:12: 17:6\n+      let _6: !;                           // in scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++     let mut _7: !;                       // in scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++     scope 1 (inlined panic) {            // at $DIR/inline-diverging.rs:16:9: 16:16\n++     }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:13:8: 13:13\n+          StorageLive(_3);                 // scope 0 at $DIR/inline-diverging.rs:13:8: 13:9\n+          _3 = _1;                         // scope 0 at $DIR/inline-diverging.rs:13:8: 13:9\n+          _2 = Gt(move _3, const 0_i32);   // scope 0 at $DIR/inline-diverging.rs:13:8: 13:13\n+          StorageDead(_3);                 // scope 0 at $DIR/inline-diverging.rs:13:12: 13:13\n+          switchInt(_2) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/inline-diverging.rs:13:5: 17:6\n+      }\n+  \n+      bb1: {\n+          StorageLive(_6);                 // scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n+-         panic();                         // scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++         StorageLive(_7);                 // scope 0 at $DIR/inline-diverging.rs:16:9: 16:16\n++         begin_panic::<&str>(const \"explicit panic\"); // scope 1 at $DIR/inline-diverging.rs:16:9: 16:16\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-diverging.rs:16:9: 16:14\n+-                                          // + literal: Const { ty: fn() -> ! {panic}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/inline-diverging.rs:16:9: 16:16\n++                                          // + literal: Const { ty: fn(&str) -> ! {std::rt::begin_panic::<&str>}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: &str\n++                                          // + val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 })\n++                                          // mir::Constant\n++                                          // + span: $DIR/inline-diverging.rs:16:9: 16:16\n++                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [101, 120, 112, 108, 105, 99, 105, 116, 32, 112, 97, 110, 105, 99], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [16383], len: Size { raw: 14 } }, size: Size { raw: 14 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 14 }) }\n+      }\n+  \n+      bb2: {\n+          StorageLive(_4);                 // scope 0 at $DIR/inline-diverging.rs:14:9: 14:10\n+          _4 = _1;                         // scope 0 at $DIR/inline-diverging.rs:14:9: 14:10\n+          _0 = move _4 as u32 (Misc);      // scope 0 at $DIR/inline-diverging.rs:14:9: 14:17\n+          StorageDead(_4);                 // scope 0 at $DIR/inline-diverging.rs:14:16: 14:17\n+          StorageDead(_2);                 // scope 0 at $DIR/inline-diverging.rs:18:1: 18:2\n+          return;                          // scope 0 at $DIR/inline-diverging.rs:18:2: 18:2\n+      }\n+  }\n+  "}, {"sha": "b728ad4b42899bd56f378988156a32a30631f615", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,58 @@\n+- // MIR for `h` before Inline\n++ // MIR for `h` after Inline\n+  \n+  fn h() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:21:12: 21:12\n+      let _1: (!, !);                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _7: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _8: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++         debug f => _2;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let _3: !;                       // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _6: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         scope 2 {\n++             debug a => _3;               // in scope 2 at $DIR/inline-diverging.rs:22:5: 22:22\n++             scope 3 {\n++                 debug b => _6;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n++             }\n++             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++                 scope 7 (inlined sleep) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++                 }\n++             }\n++         }\n++         scope 4 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n++             scope 5 (inlined sleep) {    // at $DIR/inline-diverging.rs:22:5: 22:22\n++             }\n++         }\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n+-         _1 = call_twice::<!, fn() -> ! {sleep}>(sleep) -> bb1; // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _2 = sleep;                      // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n+                                           // mir::Constant\n+-                                          // + span: $DIR/inline-diverging.rs:22:5: 22:15\n+-                                          // + literal: Const { ty: fn(fn() -> ! {sleep}) -> (!, !) {call_twice::<!, fn() -> ! {sleep}>}, val: Value(Scalar(<ZST>)) }\n+-                                          // mir::Constant\n+                                           // + span: $DIR/inline-diverging.rs:22:16: 22:21\n+                                           // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_3);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _4 = &_2;                        // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_7);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _7 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:22:5: 22:22\n+      }\n+  \n+      bb1: {\n+-         StorageDead(_1);                 // scope 0 at $DIR/inline-diverging.rs:22:22: 22:23\n+-         _0 = const ();                   // scope 0 at $DIR/inline-diverging.rs:21:12: 23:2\n+-         return;                          // scope 0 at $DIR/inline-diverging.rs:23:2: 23:2\n++         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:22:5: 22:22\n+      }\n+  }\n+  "}, {"sha": "3c0dfb4a77e1643e2830cf50a09ef5e4e5ee8461", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -18,6 +18,7 @@\n           StorageLive(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _2 = Box(std::vec::Vec<u32>);    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n -         (*_2) = Vec::<u32>::new() -> [return: bb1, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageLive(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _4 = &mut (*_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         ((*_4).0: alloc::raw_vec::RawVec<u32>) = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: {0x4 as *const u32}, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +                                          // ty::Const\n@@ -34,6 +35,7 @@\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [255], len: Size { raw: 8 } }, size: Size { raw: 8 }, align: Align { pow2: 2 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         ((*_4).1: usize) = const 0_usize; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageDead(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n           _1 = move _2;                    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           StorageDead(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n           _0 = const ();                   // scope 0 at $DIR/inline-into-box-place.rs:7:11: 9:2"}, {"sha": "a72db9cf1dc8f9bfdcf459492e63459598671dd8", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -18,6 +18,7 @@\n           StorageLive(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _2 = Box(std::vec::Vec<u32>);    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n -         (*_2) = Vec::<u32>::new() -> [return: bb1, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageLive(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _4 = &mut (*_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         ((*_4).0: alloc::raw_vec::RawVec<u32>) = const alloc::raw_vec::RawVec::<u32> { ptr: Unique::<u32> { pointer: {0x4 as *const u32}, _marker: PhantomData::<u32> }, cap: 0_usize, alloc: std::alloc::Global }; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +                                          // ty::Const\n@@ -34,6 +35,7 @@\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Value(ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }) }\n +         ((*_4).1: usize) = const 0_usize; // scope 2 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageDead(_4);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n           _1 = move _2;                    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           StorageDead(_2);                 // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n           _0 = const ();                   // scope 0 at $DIR/inline-into-box-place.rs:7:11: 9:2"}, {"sha": "4cbdde2ba07d7114ffd3b738b511d57b0e259292", "filename": "src/test/mir-opt/inline/inline_options.main.Inline.after.mir", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_options.main.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fmir-opt%2Finline%2Finline_options.main.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_options.main.Inline.after.mir?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,56 @@\n+// MIR for `main` after Inline\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/inline-options.rs:8:11: 8:11\n+    let _1: ();                          // in scope 0 at $DIR/inline-options.rs:9:5: 9:18\n+    let _2: ();                          // in scope 0 at $DIR/inline-options.rs:10:5: 10:21\n+    scope 1 (inlined inlined::<u32>) {   // at $DIR/inline-options.rs:10:5: 10:21\n+        let _3: ();                      // in scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        let _4: ();                      // in scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        let _5: ();                      // in scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/inline-options.rs:9:5: 9:18\n+        _1 = not_inlined() -> bb1;       // scope 0 at $DIR/inline-options.rs:9:5: 9:18\n+                                         // mir::Constant\n+                                         // + span: $DIR/inline-options.rs:9:5: 9:16\n+                                         // + literal: Const { ty: fn() {not_inlined}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb1: {\n+        StorageDead(_1);                 // scope 0 at $DIR/inline-options.rs:9:18: 9:19\n+        StorageLive(_2);                 // scope 0 at $DIR/inline-options.rs:10:5: 10:21\n+        StorageLive(_3);                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        _3 = g() -> bb2;                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+                                         // mir::Constant\n+                                         // + span: $DIR/inline-options.rs:10:5: 10:21\n+                                         // + literal: Const { ty: fn() {g}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb2: {\n+        StorageDead(_3);                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        StorageLive(_4);                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        _4 = g() -> bb3;                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+                                         // mir::Constant\n+                                         // + span: $DIR/inline-options.rs:10:5: 10:21\n+                                         // + literal: Const { ty: fn() {g}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb3: {\n+        StorageDead(_4);                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        StorageLive(_5);                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        _5 = g() -> bb4;                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+                                         // mir::Constant\n+                                         // + span: $DIR/inline-options.rs:10:5: 10:21\n+                                         // + literal: Const { ty: fn() {g}, val: Value(Scalar(<ZST>)) }\n+    }\n+\n+    bb4: {\n+        StorageDead(_5);                 // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        _2 = const ();                   // scope 1 at $DIR/inline-options.rs:10:5: 10:21\n+        StorageDead(_2);                 // scope 0 at $DIR/inline-options.rs:10:21: 10:22\n+        _0 = const ();                   // scope 0 at $DIR/inline-options.rs:8:11: 11:2\n+        return;                          // scope 0 at $DIR/inline-options.rs:11:2: 11:2\n+    }\n+}"}, {"sha": "533fe55b45beea4d32c09302c1aa76ddb62f3a10", "filename": "src/test/ui/const-generics/const_evaluatable_checked/associated-consts.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fassociated-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fassociated-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fassociated-consts.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,31 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+pub trait BlockCipher {\n+    const BLOCK_SIZE: usize;\n+}\n+\n+struct FooCipher;\n+impl BlockCipher for FooCipher {\n+    const BLOCK_SIZE: usize = 64;\n+}\n+\n+struct BarCipher;\n+impl BlockCipher for BarCipher {\n+    const BLOCK_SIZE: usize = 32;\n+}\n+\n+pub struct Block<C>(C);\n+\n+pub fn test<C: BlockCipher, const M: usize>()\n+where\n+    [u8; M - C::BLOCK_SIZE]: Sized,\n+{\n+    let _ = [0; M - C::BLOCK_SIZE];\n+}\n+\n+fn main() {\n+    test::<FooCipher, 128>();\n+    test::<BarCipher, 64>();\n+}"}, {"sha": "05049d9c2a6efb7716c063a7fe32d4e39c0c2c34", "filename": "src/test/ui/const-generics/const_evaluatable_checked/different-fn.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdifferent-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdifferent-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdifferent-fn.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,16 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+use std::mem::size_of;\n+use std::marker::PhantomData;\n+\n+struct Foo<T>(PhantomData<T>);\n+\n+fn test<T>() -> [u8; size_of::<T>()] {\n+    [0; size_of::<Foo<T>>()]\n+    //~^ ERROR unconstrained generic constant\n+}\n+\n+fn main() {\n+    test::<u32>();\n+}"}, {"sha": "1f6dddb04e56c91ce53910b2ea229d3791735f8e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/different-fn.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdifferent-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdifferent-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdifferent-fn.stderr?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -0,0 +1,14 @@\n+error: unconstrained generic constant\n+  --> $DIR/different-fn.rs:10:9\n+   |\n+LL |     [0; size_of::<Foo<T>>()]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/different-fn.rs:10:9\n+   |\n+LL |     [0; size_of::<Foo<T>>()]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a4264f9b5c4ec4995f457b4856740ac64a7e009", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a43fce3bdf7959408c186e1d3f21bf0400b546/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=e4a43fce3bdf7959408c186e1d3f21bf0400b546", "patch": "@@ -3089,7 +3089,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     }\n }\n \n-/// Detect the occurences of calls to `iter` or `into_iter` for the\n+/// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {"}]}