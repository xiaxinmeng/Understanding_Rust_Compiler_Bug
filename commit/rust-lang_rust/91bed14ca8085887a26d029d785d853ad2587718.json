{"sha": "91bed14ca8085887a26d029d785d853ad2587718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYmVkMTRjYTgwODU4ODdhMjZkMDI5ZDc4NWQ4NTNhZDI1ODc3MTg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-10T22:10:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-12T20:39:47Z"}, "message": "green: Fix a scheduler assertion on yielding\n\nThis commit fixes a small bug in the green scheduler where a scheduler task\ncalling `maybe_yield` would trip the assertion that `self.yield_check_count > 0`\n\nThis behavior was seen when a scheduler task was scheduled many times\nsuccessively, sending messages in a loop (via the channel `send` method), which\nin turn invokes `maybe_yield`. Yielding on a sched task doesn't make sense\nbecause as soon as it's done it will implicitly do a yield, and for this reason\nthe yield check is just skipped if it's a sched task.\n\nI am unable to create a reliable test for this behavior, as there's no direct\nway to have control over the scheduler tasks.\n\ncc #12666, I discovered this when investigating that issue", "tree": {"sha": "1594c5d38605029822e4cd70fe0139b37258292a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1594c5d38605029822e4cd70fe0139b37258292a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91bed14ca8085887a26d029d785d853ad2587718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91bed14ca8085887a26d029d785d853ad2587718", "html_url": "https://github.com/rust-lang/rust/commit/91bed14ca8085887a26d029d785d853ad2587718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91bed14ca8085887a26d029d785d853ad2587718/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80f92f5c5fedadd131842977c0b9b21806f3902f", "url": "https://api.github.com/repos/rust-lang/rust/commits/80f92f5c5fedadd131842977c0b9b21806f3902f", "html_url": "https://github.com/rust-lang/rust/commit/80f92f5c5fedadd131842977c0b9b21806f3902f"}], "stats": {"total": 14, "additions": 14, "deletions": 0}, "files": [{"sha": "872d6de17582071cf26eac57d146c4cddae0291a", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91bed14ca8085887a26d029d785d853ad2587718/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bed14ca8085887a26d029d785d853ad2587718/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=91bed14ca8085887a26d029d785d853ad2587718", "patch": "@@ -832,6 +832,20 @@ impl Scheduler {\n     }\n \n     pub fn maybe_yield(mut ~self, cur: ~GreenTask) {\n+        // It's possible for sched tasks to possibly call this function, and it\n+        // just means that they're likely sending on channels (which\n+        // occasionally call this function). Sched tasks follow different paths\n+        // when executing yield_now(), which may possibly trip the assertion\n+        // below. For this reason, we just have sched tasks bail out soon.\n+        //\n+        // Sched tasks have no need to yield anyway because as soon as they\n+        // return they'll yield to other threads by falling back to the event\n+        // loop. Additionally, we completely control sched tasks, so we can make\n+        // sure that they never execute more than enough code.\n+        if cur.is_sched() {\n+            return cur.put_with_sched(self)\n+        }\n+\n         // The number of times to do the yield check before yielding, chosen\n         // arbitrarily.\n         rtassert!(self.yield_check_count > 0);"}]}