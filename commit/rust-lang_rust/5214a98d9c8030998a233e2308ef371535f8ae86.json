{"sha": "5214a98d9c8030998a233e2308ef371535f8ae86", "node_id": "C_kwDOAAsO6NoAKDUyMTRhOThkOWM4MDMwOTk4YTIzM2UyMzA4ZWYzNzE1MzVmOGFlODY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-11T22:04:35Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-11T22:04:35Z"}, "message": "Simplify", "tree": {"sha": "2fdaeb8c20140204d20746914e2c24b5851043e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fdaeb8c20140204d20746914e2c24b5851043e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5214a98d9c8030998a233e2308ef371535f8ae86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5214a98d9c8030998a233e2308ef371535f8ae86", "html_url": "https://github.com/rust-lang/rust/commit/5214a98d9c8030998a233e2308ef371535f8ae86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5214a98d9c8030998a233e2308ef371535f8ae86/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "html_url": "https://github.com/rust-lang/rust/commit/1ce3e820dcb3ca90dec6d3b008e14531c54afc06"}], "stats": {"total": 153, "additions": 72, "deletions": 81}, "files": [{"sha": "f527aa290c4cd292eb4b865508a8115138f713b9", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 72, "deletions": 81, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5214a98d9c8030998a233e2308ef371535f8ae86/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5214a98d9c8030998a233e2308ef371535f8ae86/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=5214a98d9c8030998a233e2308ef371535f8ae86", "patch": "@@ -46,106 +46,97 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n     let our_path = source_root.path_for_file(&file_id)?;\n     let parent = our_path.parent()?;\n     let (module_name, _) = our_path.name_and_extension()?;\n-    let (parent, module_name) = if module_name == \"mod\" {\n+    let (parent, module_name) = match module_name {\n         // for mod.rs we need to actually look up one higher\n         // and take the parent as our to be module name\n-        let (name, _) = parent.name_and_extension()?;\n-        (parent.parent()?, name.to_owned())\n-    } else {\n-        (parent, module_name.to_owned())\n+        \"mod\" => {\n+            let (name, _) = parent.name_and_extension()?;\n+            (parent.parent()?, name.to_owned())\n+        }\n+        _ => (parent, module_name.to_owned()),\n     };\n \n     // check crate roots, i.e. main.rs, lib.rs, ...\n-    'outer: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n+    'crates: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n         let crate_def_map = ctx.sema.db.crate_def_map(krate);\n-        if let Some(root_file_id) = crate_def_map[crate_def_map.root()].origin.file_id() {\n-            if let Some(path) = source_root.path_for_file(&root_file_id) {\n-                let parent2 = path.parent()?;\n-                if let Some(rel) = parent.strip_prefix(&parent2) {\n-                    let mut current = &crate_def_map[crate_def_map.root()];\n-                    for ele in rel.as_ref().components() {\n-                        let seg = match ele {\n-                            std::path::Component::Normal(seg) => seg.to_str()?,\n-                            std::path::Component::RootDir => continue,\n-                            // shouldn't occur\n-                            _ => continue 'outer,\n-                        };\n-                        match current.children.iter().find(|(name, _)| name.to_smol_str() == seg) {\n-                            Some((_, child)) => {\n-                                current = &crate_def_map[*child];\n-                            }\n-                            None => continue 'outer,\n-                        }\n-                    }\n-                    let InFile { file_id: parent_file_id, value: source } =\n-                        current.definition_source(ctx.sema.db);\n-                    if let Some(parent_file_id) = parent_file_id.file_id() {\n-                        return make_fixes(\n-                            ctx.sema.db,\n-                            parent_file_id,\n-                            source,\n-                            &module_name,\n-                            file_id,\n-                        );\n-                    }\n-                }\n+\n+        let root_module = &crate_def_map[crate_def_map.root()];\n+        let Some(root_file_id) = root_module.origin.file_id() else { continue };\n+        let Some(crate_root_path) = source_root.path_for_file(&root_file_id) else { continue };\n+        let Some(rel) = parent.strip_prefix(&crate_root_path.parent()?) else { continue };\n+\n+        // try resolving the relative difference of the paths as inline modules\n+        let mut current = root_module;\n+        for ele in rel.as_ref().components() {\n+            let seg = match ele {\n+                std::path::Component::Normal(seg) => seg.to_str()?,\n+                std::path::Component::RootDir => continue,\n+                // shouldn't occur\n+                _ => continue 'crates,\n+            };\n+            match current.children.iter().find(|(name, _)| name.to_smol_str() == seg) {\n+                Some((_, &child)) => current = &crate_def_map[child],\n+                None => continue 'crates,\n+            }\n+            if !current.origin.is_inline() {\n+                continue 'crates;\n             }\n         }\n+\n+        let InFile { file_id: parent_file_id, value: source } =\n+            current.definition_source(ctx.sema.db);\n+        let parent_file_id = parent_file_id.file_id()?;\n+        return make_fixes(ctx.sema.db, parent_file_id, source, &module_name, file_id);\n     }\n+\n+    // if we aren't adding to a crate root, walk backwards such that we support `#[path = ...]` overrides if possible\n+\n     // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`\n     let paths = iter::successors(Some(parent.clone()), |prev| prev.parent()).filter_map(|path| {\n         let parent = path.parent()?;\n         let (name, _) = path.name_and_extension()?;\n         Some(([parent.join(&format!(\"{name}.rs\"))?, path.join(\"mod.rs\")?], name.to_owned()))\n     });\n     let mut stack = vec![];\n-    if let Some(&parent_id) = paths\n-        .inspect(|(_, name)| stack.push(name.clone()))\n-        .find_map(|(paths, _)| paths.into_iter().find_map(|path| source_root.file_for_path(&path)))\n-    {\n-        stack.pop();\n-        for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n-            let crate_def_map = ctx.sema.db.crate_def_map(krate);\n-            'outer: for (_, module) in crate_def_map.modules() {\n-                if module.origin.file_id() == Some(parent_id) {\n-                    if module.origin.is_inline() {\n-                        continue;\n-                    }\n-                    if stack.is_empty() {\n-                        return make_fixes(\n-                            ctx.sema.db,\n-                            parent_id,\n-                            module.definition_source(ctx.sema.db).value,\n-                            &module_name,\n-                            file_id,\n-                        );\n-                    } else {\n-                        let mut current = module;\n-                        for s in stack.iter().rev() {\n-                            match module.children.iter().find(|(name, _)| name.to_smol_str() == s) {\n-                                Some((_, child)) => {\n-                                    current = &crate_def_map[*child];\n-                                }\n-                                None => break 'outer,\n-                            }\n-                        }\n-                        let InFile { file_id: parent_file_id, value: source } =\n-                            current.definition_source(ctx.sema.db);\n-                        if let Some(parent_file_id) = parent_file_id.file_id() {\n-                            if current.origin.is_inline() {\n-                                return make_fixes(\n-                                    ctx.sema.db,\n-                                    parent_file_id,\n-                                    source,\n-                                    &module_name,\n-                                    file_id,\n-                                );\n-                            }\n-                        }\n-                        break;\n+    let &parent_id =\n+        paths.inspect(|(_, name)| stack.push(name.clone())).find_map(|(paths, _)| {\n+            paths.into_iter().find_map(|path| source_root.file_for_path(&path))\n+        })?;\n+    stack.pop();\n+    'crates: for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n+        let crate_def_map = ctx.sema.db.crate_def_map(krate);\n+        let Some((_, module)) =\n+            crate_def_map.modules()\n+            .find(|(_, module)| module.origin.file_id() == Some(parent_id) && !module.origin.is_inline())\n+        else { continue };\n+\n+        if stack.is_empty() {\n+            return make_fixes(\n+                ctx.sema.db,\n+                parent_id,\n+                module.definition_source(ctx.sema.db).value,\n+                &module_name,\n+                file_id,\n+            );\n+        } else {\n+            // direct parent file is missing,\n+            // try finding a parent that has an inline tree from here on\n+            let mut current = module;\n+            for s in stack.iter().rev() {\n+                match module.children.iter().find(|(name, _)| name.to_smol_str() == s) {\n+                    Some((_, child)) => {\n+                        current = &crate_def_map[*child];\n                     }\n+                    None => continue 'crates,\n+                }\n+                if !current.origin.is_inline() {\n+                    continue 'crates;\n                 }\n             }\n+            let InFile { file_id: parent_file_id, value: source } =\n+                current.definition_source(ctx.sema.db);\n+            let parent_file_id = parent_file_id.file_id()?;\n+            return make_fixes(ctx.sema.db, parent_file_id, source, &module_name, file_id);\n         }\n     }\n "}]}