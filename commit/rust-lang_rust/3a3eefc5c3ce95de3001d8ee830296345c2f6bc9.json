{"sha": "3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhM2VlZmM1YzNjZTk1ZGUzMDAxZDhlZTgzMDI5NjM0NWMyZjZiYzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-07T23:26:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Update to the latest libuv\n\nAt this time, also point the libuv submodule to the official repo instead of my\nown off to the side.\n\ncc #10246\nCloses #10329", "tree": {"sha": "c9be634bc3bc799e793df728cd782f27f0f3e9e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9be634bc3bc799e793df728cd782f27f0f3e9e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "html_url": "https://github.com/rust-lang/rust/commit/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b652bbc6700e36c9ad80105c89d7fc2e3afec111", "url": "https://api.github.com/repos/rust-lang/rust/commits/b652bbc6700e36c9ad80105c89d7fc2e3afec111", "html_url": "https://github.com/rust-lang/rust/commit/b652bbc6700e36c9ad80105c89d7fc2e3afec111"}], "stats": {"total": 642, "additions": 172, "deletions": 470}, "files": [{"sha": "a861cf79978663eec281724a25323deaae8f9526", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -4,7 +4,7 @@\n \tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n-\turl = https://github.com/alexcrichton/libuv.git\n+\turl = https://github.com/joyent/libuv.git\n \tbranch = master\n [submodule \"src/gyp\"]\n \tpath = src/gyp"}, {"sha": "55187fad49db07472da94c877cc7365e682b8a86", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -207,7 +207,7 @@ LIBUV_MAKEFILE_$(1) := $$(CFG_BUILD_DIR)$$(RT_OUTPUT_DIR_$(1))/libuv/Makefile\n \n $$(LIBUV_MAKEFILE_$(1)): $$(LIBUV_DEPS)\n \t(cd $(S)src/libuv/ && \\\n-\t $$(CFG_PYTHON) ./gyp_uv -f make -Dtarget_arch=$$(LIBUV_ARCH_$(1)) \\\n+\t $$(CFG_PYTHON) ./gyp_uv.py -f make -Dtarget_arch=$$(LIBUV_ARCH_$(1)) \\\n \t   -D ninja \\\n \t   -DOS=$$(LIBUV_OSTYPE_$(1)) \\\n \t   -Goutput_dir=$$(@D) --generator-output $$(@D))"}, {"sha": "601cc9f84add0ef3307ea73ad51abe6157c43e3c", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -141,8 +141,7 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n \n         let mut addrs = ~[];\n         loop {\n-            let uvaddr = net::sockaddr_to_UvSocketAddr((*addr).ai_addr);\n-            let rustaddr = net::uv_socket_addr_to_socket_addr(uvaddr);\n+            let rustaddr = net::sockaddr_to_socket_addr((*addr).ai_addr);\n \n             let mut flags = 0;\n             do each_ai_flag |cval, aival| {"}, {"sha": "7c84ccb8f2cd750e3e0188fee6698394fcbb1368", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -47,7 +47,7 @@ via `close` and `delete` methods.\n \n use std::cast::transmute;\n use std::cast;\n-use std::libc::{c_int, malloc, free};\n+use std::libc::{c_int, malloc};\n use std::ptr::null;\n use std::ptr;\n use std::rt::BlockedTask;"}, {"sha": "10b8f50e387ce4377284971766d8bef3fbd54ea2", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 89, "deletions": 132, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cast;\n+use std::libc;\n use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n use std::ptr;\n use std::rt::BlockedTask;\n@@ -28,103 +29,81 @@ use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             wait_until_woken_after};\n use uvio::HomingIO;\n use uvll;\n+use uvll::sockaddr;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub enum UvSocketAddr {\n-    UvIpv4SocketAddr(*uvll::sockaddr_in),\n-    UvIpv6SocketAddr(*uvll::sockaddr_in6),\n-}\n-\n-pub fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n-    unsafe {\n-        assert!((uvll::is_ip4_addr(addr) || uvll::is_ip6_addr(addr)));\n-        assert!(!(uvll::is_ip4_addr(addr) && uvll::is_ip6_addr(addr)));\n-        match addr {\n-            _ if uvll::is_ip4_addr(addr) =>\n-                UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n-            _ if uvll::is_ip6_addr(addr) =>\n-                UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n-            _ => fail!(),\n-        }\n-    }\n-}\n-\n-fn socket_addr_as_uv_socket_addr<T>(addr: SocketAddr, f: &fn(UvSocketAddr) -> T) -> T {\n+#[fixed_stack_segment]\n+fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: &fn(*sockaddr) -> T) -> T {\n     let malloc = match addr.ip {\n-        Ipv4Addr(*) => uvll::malloc_ip4_addr,\n-        Ipv6Addr(*) => uvll::malloc_ip6_addr,\n-    };\n-    let wrap = match addr.ip {\n-        Ipv4Addr(*) => UvIpv4SocketAddr,\n-        Ipv6Addr(*) => UvIpv6SocketAddr,\n-    };\n-    let free = match addr.ip {\n-        Ipv4Addr(*) => uvll::free_ip4_addr,\n-        Ipv6Addr(*) => uvll::free_ip6_addr,\n+        Ipv4Addr(*) => uvll::rust_malloc_ip4_addr,\n+        Ipv6Addr(*) => uvll::rust_malloc_ip6_addr,\n     };\n \n-    let addr = unsafe { malloc(addr.ip.to_str(), addr.port as int) };\n+    let ip = addr.ip.to_str();\n+    let addr = ip.with_c_str(|p| unsafe { malloc(p, addr.port as c_int) });\n     do (|| {\n-        f(wrap(addr))\n+        f(addr)\n     }).finally {\n-        unsafe { free(addr) };\n+        unsafe { libc::free(addr) };\n     }\n }\n \n-fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T) -> T {\n-    let ip_size = match addr {\n-        UvIpv4SocketAddr(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n-        UvIpv6SocketAddr(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n-    };\n-    let ip_name = {\n-        let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n-        unsafe {\n+#[fixed_stack_segment]\n+pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n+    unsafe {\n+        let ip_size = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n+            4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/\n+        } else if uvll::rust_is_ipv6_sockaddr(addr) == 1 {\n+            8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/\n+        } else {\n+            fail!(\"unknown address?\");\n+        };\n+        let ip_name = {\n+            let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n             let buf_ptr = vec::raw::to_ptr(buf);\n-            match addr {\n-                UvIpv4SocketAddr(addr) =>\n-                    uvll::uv_ip4_name(addr, buf_ptr as *c_char, ip_size as size_t),\n-                UvIpv6SocketAddr(addr) =>\n-                    uvll::uv_ip6_name(addr, buf_ptr as *c_char, ip_size as size_t),\n+            if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n+                uvll::uv_ip4_name(addr, buf_ptr as *c_char, ip_size as size_t);\n+            } else {\n+                uvll::uv_ip6_name(addr, buf_ptr as *c_char, ip_size as size_t);\n             }\n+            buf\n         };\n-        buf\n-    };\n-    let ip_port = unsafe {\n-        let port = match addr {\n-            UvIpv4SocketAddr(addr) => uvll::ip4_port(addr),\n-            UvIpv6SocketAddr(addr) => uvll::ip6_port(addr),\n+        let ip_port = {\n+            let port = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n+                uvll::rust_ip4_port(addr)\n+            } else {\n+                uvll::rust_ip6_port(addr)\n+            };\n+            port as u16\n         };\n-        port as u16\n-    };\n-    let ip_str = str::from_utf8_slice(ip_name).trim_right_chars(&'\\x00');\n-    let ip_addr = FromStr::from_str(ip_str).unwrap();\n+        let ip_str = str::from_utf8_slice(ip_name).trim_right_chars(&'\\x00');\n+        let ip_addr = FromStr::from_str(ip_str).unwrap();\n \n-    // finally run the closure\n-    f(SocketAddr { ip: ip_addr, port: ip_port })\n-}\n-\n-pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n-    use std::util;\n-    uv_socket_addr_as_socket_addr(addr, util::id)\n+        SocketAddr { ip: ip_addr, port: ip_port }\n+    }\n }\n \n #[cfg(test)]\n #[test]\n fn test_ip4_conversion() {\n     use std::rt;\n     let ip4 = rt::test::next_test_ip4();\n-    assert_eq!(ip4, socket_addr_as_uv_socket_addr(ip4, uv_socket_addr_to_socket_addr));\n+    do socket_addr_as_sockaddr(ip4) |addr| {\n+        assert_eq!(ip4, sockaddr_to_socket_addr(addr));\n+    }\n }\n \n #[cfg(test)]\n #[test]\n fn test_ip6_conversion() {\n     use std::rt;\n     let ip6 = rt::test::next_test_ip6();\n-    assert_eq!(ip6, socket_addr_as_uv_socket_addr(ip6, uv_socket_addr_to_socket_addr));\n+    do socket_addr_as_sockaddr(ip6) |addr| {\n+        assert_eq!(ip6, sockaddr_to_socket_addr(addr));\n+    }\n }\n \n enum SocketNameKind {\n@@ -133,37 +112,29 @@ enum SocketNameKind {\n     Udp\n }\n \n+#[fixed_stack_segment]\n fn socket_name(sk: SocketNameKind, handle: *c_void) -> Result<SocketAddr, IoError> {\n-    let getsockname = match sk {\n-        TcpPeer => uvll::tcp_getpeername,\n-        Tcp     => uvll::tcp_getsockname,\n-        Udp     => uvll::udp_getsockname,\n-    };\n-\n-    // Allocate a sockaddr_storage\n-    // since we don't know if it's ipv4 or ipv6\n-    let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+    unsafe {\n+        let getsockname = match sk {\n+            TcpPeer => uvll::uv_tcp_getpeername,\n+            Tcp     => uvll::uv_tcp_getsockname,\n+            Udp     => uvll::uv_udp_getsockname,\n+        };\n \n-    let r = unsafe {\n-        getsockname(handle, r_addr as *uvll::sockaddr_storage)\n-    };\n+        // Allocate a sockaddr_storage\n+        // since we don't know if it's ipv4 or ipv6\n+        let size = uvll::rust_sockaddr_size();\n+        let name = libc::malloc(size as size_t);\n+        assert!(!name.is_null());\n+        let mut namelen = size;\n \n-    if r != 0 {\n-        return Err(uv_error_to_io_error(UvError(r)));\n+        let ret = match getsockname(handle, name, &mut namelen) {\n+            0 => Ok(sockaddr_to_socket_addr(name)),\n+            n => Err(uv_error_to_io_error(UvError(n)))\n+        };\n+        libc::free(name);\n+        ret\n     }\n-\n-    let addr = unsafe {\n-        if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n-            uv_socket_addr_to_socket_addr(UvIpv6SocketAddr(r_addr as *uvll::sockaddr_in6))\n-        } else {\n-            uv_socket_addr_to_socket_addr(UvIpv4SocketAddr(r_addr as *uvll::sockaddr_in))\n-        }\n-    };\n-\n-    unsafe { uvll::free_sockaddr_storage(r_addr); }\n-\n-    Ok(addr)\n-\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -210,17 +181,11 @@ impl TcpWatcher {\n \n         return do task::unkillable {\n             let tcp = TcpWatcher::new(loop_);\n-            let ret = do socket_addr_as_uv_socket_addr(address) |addr| {\n+            let ret = do socket_addr_as_sockaddr(address) |addr| {\n                 let mut req = Request::new(uvll::UV_CONNECT);\n-                let result = match addr {\n-                    UvIpv4SocketAddr(addr) => unsafe {\n-                        uvll::tcp_connect(req.handle, tcp.handle, addr,\n-                                          connect_cb)\n-                    },\n-                    UvIpv6SocketAddr(addr) => unsafe {\n-                        uvll::tcp_connect6(req.handle, tcp.handle, addr,\n-                                           connect_cb)\n-                    },\n+                let result = unsafe {\n+                    uvll::uv_tcp_connect(req.handle, tcp.handle, addr,\n+                                         connect_cb)\n                 };\n                 match result {\n                     0 => {\n@@ -340,11 +305,8 @@ impl TcpListener {\n                 closing_task: None,\n                 outgoing: Tube::new(),\n             };\n-            let res = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::tcp_bind(l.handle, addr),\n-                    UvIpv6SocketAddr(addr) => uvll::tcp_bind6(l.handle, addr),\n-                }\n+            let res = socket_addr_as_sockaddr(address, |addr| unsafe {\n+                uvll::uv_tcp_bind(l.handle, addr)\n             });\n             match res {\n                 0 => Ok(l.install()),\n@@ -475,13 +437,8 @@ impl UdpWatcher {\n             assert_eq!(unsafe {\n                 uvll::uv_udp_init(loop_.handle, udp.handle)\n             }, 0);\n-            let result = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) =>\n-                        uvll::udp_bind(udp.handle, addr, 0u32),\n-                    UvIpv6SocketAddr(addr) =>\n-                        uvll::udp_bind6(udp.handle, addr, 0u32),\n-                }\n+            let result = socket_addr_as_sockaddr(address, |addr| unsafe {\n+                uvll::uv_udp_bind(udp.handle, addr, 0u32)\n             });\n             match result {\n                 0 => Ok(udp),\n@@ -513,7 +470,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         struct Ctx {\n             task: Option<BlockedTask>,\n             buf: Option<Buf>,\n-            result: Option<(ssize_t, SocketAddr)>,\n+            result: Option<(ssize_t, Option<SocketAddr>)>,\n         }\n         let _m = self.fire_homing_missile();\n \n@@ -532,22 +489,24 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 match cx.result.take_unwrap() {\n                     (n, _) if n < 0 =>\n                         Err(uv_error_to_io_error(UvError(n as c_int))),\n-                    (n, addr) => Ok((n as uint, addr))\n+                    (n, addr) => Ok((n as uint, addr.unwrap()))\n                 }\n             }\n             n => Err(uv_error_to_io_error(UvError(n)))\n         };\n         return a;\n \n         extern fn alloc_cb(handle: *uvll::uv_udp_t,\n-                           _suggested_size: size_t) -> Buf {\n-            let cx: &mut Ctx = unsafe {\n-                cast::transmute(uvll::get_data_for_uv_handle(handle))\n-            };\n-            cx.buf.take().expect(\"recv alloc_cb called more than once\")\n+                           _suggested_size: size_t,\n+                           buf: *mut Buf) {\n+            unsafe {\n+                let cx: &mut Ctx =\n+                    cast::transmute(uvll::get_data_for_uv_handle(handle));\n+                *buf = cx.buf.take().expect(\"recv alloc_cb called more than once\")\n+            }\n         }\n \n-        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n+        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: *Buf,\n                           addr: *uvll::sockaddr, _flags: c_uint) {\n             assert!(nread != uvll::ECANCELED as ssize_t);\n             let cx: &mut Ctx = unsafe {\n@@ -558,7 +517,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n             // this we just drop back to kqueue and wait for the next callback.\n             if nread == 0 {\n-                cx.buf = Some(buf);\n+                cx.buf = Some(unsafe { *buf });\n                 return\n             }\n \n@@ -569,8 +528,11 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             let cx: &mut Ctx = unsafe {\n                 cast::transmute(uvll::get_data_for_uv_handle(handle))\n             };\n-            let addr = sockaddr_to_UvSocketAddr(addr);\n-            let addr = uv_socket_addr_to_socket_addr(addr);\n+            let addr = if addr == ptr::null() {\n+                None\n+            } else {\n+                Some(sockaddr_to_socket_addr(addr))\n+            };\n             cx.result = Some((nread, addr));\n \n             let sched: ~Scheduler = Local::take();\n@@ -585,13 +547,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n         let buf = slice_to_uv_buf(buf);\n-        let result = socket_addr_as_uv_socket_addr(dst, |dst| unsafe {\n-            match dst {\n-                UvIpv4SocketAddr(dst) =>\n-                    uvll::udp_send(req.handle, self.handle, [buf], dst, send_cb),\n-                UvIpv6SocketAddr(dst) =>\n-                    uvll::udp_send6(req.handle, self.handle, [buf], dst, send_cb),\n-            }\n+        let result = socket_addr_as_sockaddr(dst, |dst| unsafe {\n+            uvll::uv_udp_send(req.handle, self.handle, [buf], dst, send_cb)\n         });\n \n         return match result {"}, {"sha": "d0b0d6429b8be43f7bbea11fd08b74d14c7885a6", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -78,7 +78,7 @@ impl Process {\n \n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n                 match unsafe {\n-                    uvll::uv_spawn(loop_.handle, handle, options)\n+                    uvll::uv_spawn(loop_.handle, handle, &options)\n                 } {\n                     0 => {\n                         let process = ~Process {\n@@ -106,7 +106,7 @@ impl Process {\n }\n \n extern fn on_exit(handle: *uvll::uv_process_t,\n-                  exit_status: libc::c_int,\n+                  exit_status: i64,\n                   term_signal: libc::c_int) {\n     let p: &mut Process = unsafe { UvHandle::from_uv_handle(&handle) };\n "}, {"sha": "08b307700c7cdb866dff8cf5cc33610970a2b073", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -135,17 +135,18 @@ impl StreamWatcher {\n // This allocation callback expects to be invoked once and only once. It will\n // unwrap the buffer in the ReadContext stored in the stream and return it. This\n // will fail if it is called more than once.\n-extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t) -> Buf {\n+extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) {\n     uvdebug!(\"alloc_cb\");\n-    let rcx: &mut ReadContext = unsafe {\n-        cast::transmute(uvll::get_data_for_uv_handle(stream))\n-    };\n-    rcx.buf.take().expect(\"stream alloc_cb called more than once\")\n+    unsafe {\n+        let rcx: &mut ReadContext =\n+            cast::transmute(uvll::get_data_for_uv_handle(stream));\n+        *buf = rcx.buf.take().expect(\"stream alloc_cb called more than once\");\n+    }\n }\n \n // When a stream has read some data, we will always forcibly stop reading and\n // return all the data read (even if it didn't fill the whole buffer).\n-extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: Buf) {\n+extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n     uvdebug!(\"read_cb {}\", nread);\n     assert!(nread != uvll::ECANCELED as ssize_t);\n     let rcx: &mut ReadContext = unsafe {"}, {"sha": "4183ce4309eeba17a05587d588f1f8c98f98de54", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 44, "deletions": 172, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -206,15 +206,16 @@ impl uv_stat_t {\n pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n                                     status: c_int);\n pub type uv_alloc_cb = extern \"C\" fn(stream: *uv_stream_t,\n-                                     suggested_size: size_t) -> uv_buf_t;\n+                                     suggested_size: size_t,\n+                                     buf: *mut uv_buf_t);\n pub type uv_read_cb = extern \"C\" fn(stream: *uv_stream_t,\n                                     nread: ssize_t,\n-                                    buf: uv_buf_t);\n+                                    buf: *uv_buf_t);\n pub type uv_udp_send_cb = extern \"C\" fn(req: *uv_udp_send_t,\n                                         status: c_int);\n pub type uv_udp_recv_cb = extern \"C\" fn(handle: *uv_udp_t,\n                                         nread: ssize_t,\n-                                        buf: uv_buf_t,\n+                                        buf: *uv_buf_t,\n                                         addr: *sockaddr,\n                                         flags: c_uint);\n pub type uv_close_cb = extern \"C\" fn(handle: *uv_handle_t);\n@@ -234,16 +235,13 @@ pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n                                            status: c_int,\n                                            res: *addrinfo);\n pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n-                                    exit_status: c_int,\n+                                    exit_status: i64,\n                                     term_signal: c_int);\n pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n                                       signum: c_int);\n pub type uv_fs_cb = extern \"C\" fn(req: *uv_fs_t);\n \n pub type sockaddr = c_void;\n-pub type sockaddr_in = c_void;\n-pub type sockaddr_in6 = c_void;\n-pub type sockaddr_storage = c_void;\n \n #[cfg(unix)]\n pub type socklen_t = c_int;\n@@ -420,86 +418,12 @@ pub unsafe fn loop_new() -> *c_void {\n     return rust_uv_loop_new();\n }\n \n-pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_bind(server, addr, flags);\n-}\n-\n-pub unsafe fn udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_bind6(server, addr, flags);\n-}\n-\n-pub unsafe fn udp_send<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n-                          addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_udp_send(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n-}\n-\n-pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n-                          addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n-}\n-\n pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n-pub unsafe fn udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_getsockname(handle, name);\n-}\n-\n-pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n-                          addr_ptr: *sockaddr_in, after_connect_cb: uv_connect_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n-                           addr_ptr: *sockaddr_in6, after_connect_cb: uv_connect_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_getsockname(handle, name);\n-}\n-\n pub unsafe fn uv_write(req: *uv_write_t,\n                        stream: *uv_stream_t,\n                        buf_in: &[uv_buf_t],\n@@ -513,67 +437,6 @@ pub unsafe fn uv_write(req: *uv_write_t,\n     return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n }\n \n-pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n-}\n-\n-pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n-}\n-\n-pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    do ip.with_c_str |ip_buf| {\n-        rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n-    }\n-}\n-pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    do ip.with_c_str |ip_buf| {\n-        rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n-    }\n-}\n-\n-pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_malloc_sockaddr_storage()\n-}\n-\n-pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_free_sockaddr_storage(ss);\n-}\n-\n-pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_free_ip4_addr(addr);\n-}\n-\n-pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_free_ip6_addr(addr);\n-}\n-\n-pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-   return rust_uv_ip4_port(addr);\n-}\n-\n-pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_ip6_port(addr);\n-}\n-\n pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n     return rust_uv_process_pid(p);\n@@ -685,36 +548,19 @@ pub unsafe fn guess_handle(handle: c_int) -> c_int {\n extern {\n     fn rust_uv_loop_new() -> *c_void;\n \n+    // dealing with sockaddr things\n+    pub fn rust_sockaddr_size() -> c_int;\n+    pub fn rust_malloc_ip4_addr(s: *c_char, port: c_int) -> *sockaddr;\n+    pub fn rust_malloc_ip6_addr(s: *c_char, port: c_int) -> *sockaddr;\n+    pub fn rust_ip4_port(src: *sockaddr) -> c_uint;\n+    pub fn rust_ip6_port(src: *sockaddr) -> c_uint;\n+    pub fn rust_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n+    pub fn rust_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n+\n     fn rust_uv_handle_type_max() -> uintptr_t;\n     fn rust_uv_req_type_max() -> uintptr_t;\n-    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n-    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n-    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n-    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n-    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n-    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n-    fn rust_uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t,\n-                           cb: uv_connect_cb,\n-                           addr: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t,\n-                            cb: uv_connect_cb,\n-                            addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int;\n-    fn rust_uv_udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int;\n-    fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n-                        buf_cnt: c_int, addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int;\n-    fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n-                         buf_cnt: c_int, addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int;\n     fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n-    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n-    fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n-    fn rust_uv_malloc_sockaddr_storage() -> *sockaddr_storage;\n-    fn rust_uv_free_sockaddr_storage(ss: *sockaddr_storage);\n+\n     fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n@@ -768,17 +614,27 @@ externfn!(fn uv_async_send(a: *uv_async_t))\n \n // tcp bindings\n externfn!(fn uv_tcp_init(l: *uv_loop_t, h: *uv_tcp_t) -> c_int)\n-externfn!(fn uv_ip4_name(src: *sockaddr_in, dst: *c_char,\n+externfn!(fn uv_tcp_connect(c: *uv_connect_t, h: *uv_tcp_t,\n+                            addr: *sockaddr, cb: uv_connect_cb) -> c_int)\n+externfn!(fn uv_tcp_bind(t: *uv_tcp_t, addr: *sockaddr) -> c_int)\n+externfn!(fn uv_ip4_name(src: *sockaddr, dst: *c_char,\n                          size: size_t) -> c_int)\n-externfn!(fn uv_ip6_name(src: *sockaddr_in6, dst: *c_char,\n+externfn!(fn uv_ip6_name(src: *sockaddr, dst: *c_char,\n                          size: size_t) -> c_int)\n externfn!(fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int)\n externfn!(fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,\n                               delay: c_uint) -> c_int)\n externfn!(fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int)\n+externfn!(fn uv_tcp_getsockname(h: *uv_tcp_t, name: *sockaddr,\n+                                len: *mut c_int) -> c_int)\n+externfn!(fn uv_tcp_getpeername(h: *uv_tcp_t, name: *sockaddr,\n+                                len: *mut c_int) -> c_int)\n+externfn!(fn uv_ip4_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int)\n+externfn!(fn uv_ip6_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int)\n \n // udp bindings\n externfn!(fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int)\n+externfn!(fn uv_udp_bind(h: *uv_udp_t, addr: *sockaddr, flags: c_uint) -> c_int)\n externfn!(fn uv_udp_recv_start(server: *uv_udp_t,\n                                on_alloc: uv_alloc_cb,\n                                on_recv: uv_udp_recv_cb) -> c_int)\n@@ -790,6 +646,22 @@ externfn!(fn uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int)\n externfn!(fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int)\n externfn!(fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int)\n externfn!(fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int)\n+externfn!(fn uv_udp_getsockname(h: *uv_udp_t, name: *sockaddr,\n+                                len: *mut c_int) -> c_int)\n+\n+pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n+                          handle: *uv_udp_t,\n+                          buf_in: &[uv_buf_t],\n+                          addr: *sockaddr,\n+                          cb: uv_udp_send_cb) -> c_int {\n+    externfn!(fn uv_udp_send(req: *uv_write_t, stream: *uv_stream_t,\n+                             buf_in: *uv_buf_t, buf_cnt: c_int, addr: *sockaddr,\n+                             cb: uv_udp_send_cb) -> c_int)\n+\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n+}\n \n // timer bindings\n externfn!(fn uv_timer_init(l: *uv_loop_t, t: *uv_timer_t) -> c_int)\n@@ -853,7 +725,7 @@ externfn!(fn uv_freeaddrinfo(ai: *addrinfo))\n \n // process spawning\n externfn!(fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,\n-                      options: uv_process_options_t) -> c_int)\n+                      options: *uv_process_options_t) -> c_int)\n externfn!(fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int)\n \n // pipes"}, {"sha": "c6ecf97aafc858c2ad1089fb78da6c586d61d8b6", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -1 +1 @@\n-Subproject commit d88cf5652a1afb23939da0bae86c70ec521b9921\n+Subproject commit c6ecf97aafc858c2ad1089fb78da6c586d61d8b6"}, {"sha": "280b016af10c2b0d9764f53813a699651ca2da63", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 25, "deletions": 152, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "patch": "@@ -36,96 +36,11 @@ rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;\n }\n \n-extern \"C\" int\n-rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n-        uv_tcp_t* tcp_ptr,\n-        uv_connect_cb cb,\n-        sockaddr_in* addr_ptr) {\n-    // FIXME ref #2064\n-    sockaddr_in addr = *addr_ptr;\n-    int result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n-    return result;\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_bind(uv_tcp_t* tcp_server, sockaddr_in* addr_ptr) {\n-    // FIXME ref #2064\n-    sockaddr_in addr = *addr_ptr;\n-    return uv_tcp_bind(tcp_server, addr);\n-}\n-extern \"C\" int\n-rust_uv_tcp_connect6(uv_connect_t* connect_ptr,\n-        uv_tcp_t* tcp_ptr,\n-        uv_connect_cb cb,\n-        sockaddr_in6* addr_ptr) {\n-    // FIXME ref #2064\n-    sockaddr_in6 addr = *addr_ptr;\n-    int result = uv_tcp_connect6(connect_ptr, tcp_ptr, addr, cb);\n-    return result;\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_bind6\n-(uv_tcp_t* tcp_server, sockaddr_in6* addr_ptr) {\n-    // FIXME ref #2064\n-    sockaddr_in6 addr = *addr_ptr;\n-    return uv_tcp_bind6(tcp_server, addr);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_getpeername\n-(uv_tcp_t* handle, sockaddr_storage* name) {\n-    // sockaddr_storage is big enough to hold either\n-    // sockaddr_in or sockaddr_in6\n-    int namelen = sizeof(sockaddr_in);\n-    return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_getsockname\n-(uv_tcp_t* handle, sockaddr_storage* name) {\n-    // sockaddr_storage is big enough to hold either\n-    // sockaddr_in or sockaddr_in6\n-    int namelen = sizeof(sockaddr_storage);\n-    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_bind(uv_udp_t* server, sockaddr_in* addr_ptr, unsigned flags) {\n-    return uv_udp_bind(server, *addr_ptr, flags);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_bind6(uv_udp_t* server, sockaddr_in6* addr_ptr, unsigned flags) {\n-    return uv_udp_bind6(server, *addr_ptr, flags);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t* buf_in,\n-                 int buf_cnt, sockaddr_in* addr_ptr, uv_udp_send_cb cb) {\n-    return uv_udp_send(req, handle, buf_in, buf_cnt, *addr_ptr, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t* buf_in,\n-                  int buf_cnt, sockaddr_in6* addr_ptr, uv_udp_send_cb cb) {\n-    return uv_udp_send6(req, handle, buf_in, buf_cnt, *addr_ptr, cb);\n-}\n-\n extern \"C\" uv_udp_t*\n rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n     return send_req->handle;\n }\n \n-extern \"C\" int\n-rust_uv_udp_getsockname\n-(uv_udp_t* handle, sockaddr_storage* name) {\n-    // sockaddr_storage is big enough to hold either\n-    // sockaddr_in or sockaddr_in6\n-    int namelen = sizeof(sockaddr_storage);\n-    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n-}\n-\n extern \"C\" uv_stream_t*\n rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {\n     return connect->handle;\n@@ -171,94 +86,52 @@ rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n     req->data = data;\n }\n \n-extern \"C\" struct sockaddr_in\n-rust_uv_ip4_addr(const char* ip, int port) {\n-    struct sockaddr_in addr = uv_ip4_addr(ip, port);\n-    return addr;\n-}\n-extern \"C\" struct sockaddr_in6\n-rust_uv_ip6_addr(const char* ip, int port) {\n-    return uv_ip6_addr(ip, port);\n-}\n-\n-extern \"C\" struct sockaddr_in*\n-rust_uv_ip4_addrp(const char* ip, int port) {\n-  struct sockaddr_in addr = uv_ip4_addr(ip, port);\n-  struct sockaddr_in *addrp = (sockaddr_in*)malloc(sizeof(struct sockaddr_in));\n-  assert(addrp);\n-  memcpy(addrp, &addr, sizeof(struct sockaddr_in));\n-  return addrp;\n-}\n-extern \"C\" struct sockaddr_in6*\n-rust_uv_ip6_addrp(const char* ip, int port) {\n-  struct sockaddr_in6 addr = uv_ip6_addr(ip, port);\n-  struct sockaddr_in6 *addrp = (sockaddr_in6*)malloc(sizeof(struct sockaddr_in6));\n-  assert(addrp);\n-  memcpy(addrp, &addr, sizeof(struct sockaddr_in6));\n-  return addrp;\n-}\n-\n-extern \"C\" struct sockaddr_storage *\n-rust_uv_malloc_sockaddr_storage() {\n-    struct sockaddr_storage *ss = (sockaddr_storage *)malloc(sizeof(struct sockaddr_storage));\n-    return ss;\n+extern \"C\" int\n+rust_sockaddr_size() {\n+    return sizeof(struct sockaddr_storage);\n }\n \n-extern \"C\" void\n-rust_uv_free_sockaddr_storage(struct sockaddr_storage *ss) {\n-    free(ss);\n+extern \"C\" struct sockaddr*\n+rust_malloc_ip4_addr(char *name, int port) {\n+    struct sockaddr_in *addr = (struct sockaddr_in*) malloc(sizeof(struct sockaddr_in));\n+    memset(addr, 0, sizeof(struct sockaddr_in));\n+    assert(addr != NULL);\n+    addr->sin_port = htons(port);\n+    assert(uv_inet_pton(AF_INET, name, &addr->sin_addr) == 0);\n+    addr->sin_family = AF_INET;\n+    return (struct sockaddr*) addr;\n }\n \n-extern \"C\" void\n-rust_uv_free_ip4_addr(sockaddr_in *addrp) {\n-  free(addrp);\n+extern \"C\" struct sockaddr*\n+rust_malloc_ip6_addr(char *name, int port) {\n+    struct sockaddr_in6 *addr = (struct sockaddr_in6*) malloc(sizeof(struct sockaddr_in6));\n+    memset(addr, 0, sizeof(struct sockaddr));\n+    assert(addr != NULL);\n+    addr->sin6_port = htons(port);\n+    assert(uv_inet_pton(AF_INET6, name, &addr->sin6_addr) == 0);\n+    addr->sin6_family = AF_INET6;\n+    return (struct sockaddr*) addr;\n }\n \n-extern \"C\" void\n-rust_uv_free_ip6_addr(sockaddr_in6 *addrp) {\n-  free(addrp);\n-}\n extern \"C\" unsigned int\n-rust_uv_ip4_port(struct sockaddr_in* src) {\n+rust_ip4_port(struct sockaddr_in* src) {\n     return ntohs(src->sin_port);\n }\n extern \"C\" unsigned int\n-rust_uv_ip6_port(struct sockaddr_in6* src) {\n+rust_ip6_port(struct sockaddr_in6* src) {\n     return ntohs(src->sin6_port);\n }\n \n extern \"C\" int\n-rust_uv_is_ipv4_sockaddr(sockaddr* addr) {\n+rust_is_ipv4_sockaddr(sockaddr* addr) {\n     return addr->sa_family == AF_INET;\n }\n \n extern \"C\" int\n-rust_uv_is_ipv6_sockaddr(sockaddr* addr) {\n+rust_is_ipv6_sockaddr(sockaddr* addr) {\n     return addr->sa_family == AF_INET6;\n }\n \n-extern \"C\" bool\n-rust_uv_is_ipv4_addrinfo(addrinfo* input) {\n-    return input->ai_family == AF_INET;\n-}\n-\n-extern \"C\" bool\n-rust_uv_is_ipv6_addrinfo(addrinfo* input) {\n-    return input->ai_family == AF_INET6;\n-}\n-extern \"C\" addrinfo*\n-rust_uv_get_next_addrinfo(addrinfo* input) {\n-    return input->ai_next;\n-}\n-extern \"C\" sockaddr_in*\n-rust_uv_addrinfo_as_sockaddr_in(addrinfo* input) {\n-    return (sockaddr_in*)input->ai_addr;\n-}\n-extern \"C\" sockaddr_in6*\n-rust_uv_addrinfo_as_sockaddr_in6(addrinfo* input) {\n-    return (sockaddr_in6*)input->ai_addr;\n-}\n-\n extern \"C\" uintptr_t\n rust_uv_handle_type_max() {\n   return UV_HANDLE_TYPE_MAX;"}]}