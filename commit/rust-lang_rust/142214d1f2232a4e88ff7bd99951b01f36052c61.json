{"sha": "142214d1f2232a4e88ff7bd99951b01f36052c61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MjIxNGQxZjIyMzJhNGU4OGZmN2JkOTk5NTFiMDFmMzYwNTJjNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-28T22:13:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-28T22:13:25Z"}, "message": "Auto merge of #30411 - mitaa:multispan, r=nrc\n\nThis allows to render multiple spans on one line, or to splice multiple replacements into a code suggestion.\n\nfixes #28124", "tree": {"sha": "1d6bb4858399c46d39d9f85076cef439fb899f94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6bb4858399c46d39d9f85076cef439fb899f94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/142214d1f2232a4e88ff7bd99951b01f36052c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/142214d1f2232a4e88ff7bd99951b01f36052c61", "html_url": "https://github.com/rust-lang/rust/commit/142214d1f2232a4e88ff7bd99951b01f36052c61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/142214d1f2232a4e88ff7bd99951b01f36052c61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "552bf75e7d689c42febc7798d31ae58d614418f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/552bf75e7d689c42febc7798d31ae58d614418f9", "html_url": "https://github.com/rust-lang/rust/commit/552bf75e7d689c42febc7798d31ae58d614418f9"}, {"sha": "727f959095023d9fa749acbba49a4a904c57356b", "url": "https://api.github.com/repos/rust-lang/rust/commits/727f959095023d9fa749acbba49a4a904c57356b", "html_url": "https://github.com/rust-lang/rust/commit/727f959095023d9fa749acbba49a4a904c57356b"}], "stats": {"total": 1621, "additions": 1187, "deletions": 434}, "files": [{"sha": "a55a6918b5b9690d05de0da8efd9741cd1e2c965", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -15,7 +15,7 @@ use session::search_paths::PathKind;\n use util::nodemap::{NodeMap, FnvHashMap};\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, MultiSpan};\n use syntax::errors::{self, DiagnosticBuilder};\n use syntax::errors::emitter::{Emitter, BasicEmitter, EmitterWriter};\n use syntax::errors::json::JsonEmitter;\n@@ -47,7 +47,7 @@ pub struct Session {\n     pub cstore: Rc<for<'a> CrateStore<'a>>,\n     pub parse_sess: ParseSess,\n     // For a library crate, this is always none\n-    pub entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n+    pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n@@ -57,7 +57,7 @@ pub struct Session {\n     pub local_crate_source_file: Option<PathBuf>,\n     pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,\n-    pub lints: RefCell<NodeMap<Vec<(lint::LintId, codemap::Span, String)>>>,\n+    pub lints: RefCell<NodeMap<Vec<(lint::LintId, Span, String)>>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n@@ -81,36 +81,36 @@ pub struct Session {\n }\n \n impl Session {\n-    pub fn struct_span_warn<'a>(&'a self,\n-                                sp: Span,\n-                                msg: &str)\n-                                -> DiagnosticBuilder<'a>  {\n+    pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n+                                                    sp: S,\n+                                                    msg: &str)\n+                                                    -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n-    pub fn struct_span_warn_with_code<'a>(&'a self,\n-                                          sp: Span,\n-                                          msg: &str,\n-                                          code: &str)\n-                                          -> DiagnosticBuilder<'a>  {\n+    pub fn struct_span_warn_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                              sp: S,\n+                                                              msg: &str,\n+                                                              code: &str)\n+                                                              -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n     pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_warn(msg)\n     }\n-    pub fn struct_span_err<'a>(&'a self,\n-                               sp: Span,\n-                               msg: &str)\n-                               -> DiagnosticBuilder<'a>  {\n+    pub fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                                   sp: S,\n+                                                   msg: &str)\n+                                                   -> DiagnosticBuilder<'a>  {\n         match split_msg_into_multilines(msg) {\n             Some(ref msg) => self.diagnostic().struct_span_err(sp, msg),\n             None => self.diagnostic().struct_span_err(sp, msg),\n         }\n     }\n-    pub fn struct_span_err_with_code<'a>(&'a self,\n-                                         sp: Span,\n-                                         msg: &str,\n-                                         code: &str)\n-                                         -> DiagnosticBuilder<'a>  {\n+    pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                             sp: S,\n+                                                             msg: &str,\n+                                                             code: &str)\n+                                                             -> DiagnosticBuilder<'a>  {\n         match split_msg_into_multilines(msg) {\n             Some(ref msg) => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n             None => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n@@ -119,46 +119,46 @@ impl Session {\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_err(msg)\n     }\n-    pub fn struct_span_fatal<'a>(&'a self,\n-                                 sp: Span,\n-                                 msg: &str)\n-                                 -> DiagnosticBuilder<'a>  {\n+    pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n+                                                     sp: S,\n+                                                     msg: &str)\n+                                                     -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n-    pub fn struct_span_fatal_with_code<'a>(&'a self,\n-                                           sp: Span,\n-                                           msg: &str,\n-                                           code: &str)\n-                                           -> DiagnosticBuilder<'a>  {\n+    pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                               sp: S,\n+                                                               msg: &str,\n+                                                               code: &str)\n+                                                               -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n     pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n-    pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         panic!(self.diagnostic().span_fatal(sp, msg))\n     }\n-    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) -> ! {\n         panic!(self.diagnostic().span_fatal_with_code(sp, msg, code))\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n         panic!(self.diagnostic().fatal(msg))\n     }\n-    pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n+    pub fn span_err_or_warn<S: Into<MultiSpan>>(&self, is_warning: bool, sp: S, msg: &str) {\n         if is_warning {\n             self.span_warn(sp, msg);\n         } else {\n             self.span_err(sp, msg);\n         }\n     }\n-    pub fn span_err(&self, sp: Span, msg: &str) {\n+    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err(sp, &msg),\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n-    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err_with_code(sp, &msg, code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n@@ -199,32 +199,32 @@ impl Session {\n             }\n         }\n     }\n-    pub fn span_warn(&self, sp: Span, msg: &str) {\n+    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n-    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n+    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n     pub fn warn(&self, msg: &str) {\n         self.diagnostic().warn(msg)\n     }\n-    pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n+    pub fn opt_span_warn<S: Into<MultiSpan>>(&self, opt_sp: Option<S>, msg: &str) {\n         match opt_sp {\n             Some(sp) => self.span_warn(sp, msg),\n             None => self.warn(msg),\n         }\n     }\n-    pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n+    pub fn opt_span_bug<S: Into<MultiSpan>>(&self, opt_sp: Option<S>, msg: &str) -> ! {\n         match opt_sp {\n             Some(sp) => self.span_bug(sp, msg),\n             None => self.bug(msg),\n         }\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n-    pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n+    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().delay_span_bug(sp, msg)\n     }\n-    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n+    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n@@ -233,10 +233,10 @@ impl Session {\n     pub fn note_without_error(&self, msg: &str) {\n         self.diagnostic().note_without_error(msg)\n     }\n-    pub fn span_note_without_error(&self, sp: Span, msg: &str) {\n+    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n-    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n+    pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.diagnostic().span_unimpl(sp, msg)\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -273,7 +273,7 @@ impl Session {\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n+    pub fn impossible_case<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }"}, {"sha": "3ca9a176864852d922f3fa527fdcc65fd49b993e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -991,7 +991,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\\n                                        use the `move` keyword, as shown:\",\n-                                      cmt_path_or_string),\n+                                       cmt_path_or_string),\n                              suggestion)\n             .emit();\n     }"}, {"sha": "a662081ac21237c2549fa690584ba45feba7f9d8", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -32,7 +32,7 @@ use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::{abi, ast};\n-use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n+use syntax::codemap::{MultiSpan, CodeMap, DUMMY_SP};\n use syntax::errors;\n use syntax::errors::emitter::Emitter;\n use syntax::errors::{Level, RenderSpan};\n@@ -78,14 +78,14 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n \n impl Emitter for ExpectErrorEmitter {\n     fn emit(&mut self,\n-            _sp: Option<Span>,\n+            _sp: Option<&MultiSpan>,\n             msg: &str,\n             _: Option<&str>,\n             lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n \n-    fn custom_emit(&mut self, _sp: RenderSpan, msg: &str, lvl: Level) {\n+    fn custom_emit(&mut self, _sp: &RenderSpan, msg: &str, lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n }"}, {"sha": "1068bca55d61b7396b90ac47ee302c50bc5e0cca", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -109,7 +109,7 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit(&mut self, sp: Option<codemap::Span>,\n+    fn emit(&mut self, sp: Option<&codemap::MultiSpan>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n         assert!(sp.is_none(), \"SharedEmitter doesn't support spans\");\n \n@@ -120,7 +120,7 @@ impl Emitter for SharedEmitter {\n         });\n     }\n \n-    fn custom_emit(&mut self, _sp: errors::RenderSpan, _msg: &str, _lvl: Level) {\n+    fn custom_emit(&mut self, _sp: &errors::RenderSpan, _msg: &str, _lvl: Level) {\n         panic!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }"}, {"sha": "af343e0b0790f357a9b556d9ef9c5d403d8370f8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -1072,8 +1072,8 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                 Ok(s) => {\n                     err.span_suggestion(t_span,\n-                                                          \"try casting to a `Box` instead:\",\n-                                                           format!(\"Box<{}>\", s));\n+                                        \"try casting to a `Box` instead:\",\n+                                        format!(\"Box<{}>\", s));\n                 },\n                 Err(_) =>\n                     span_help!(err, t_span, \"did you mean `Box<{}>`?\", tstr),"}, {"sha": "ca01623fef90ffeb0dcdc8cd1e7ebf6b90d70d91", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 260, "deletions": 3, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -23,6 +23,7 @@ use std::cell::{Cell, RefCell};\n use std::ops::{Add, Sub};\n use std::path::Path;\n use std::rc::Rc;\n+use std::cmp;\n \n use std::{fmt, fs};\n use std::io::{self, Read};\n@@ -31,6 +32,8 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use ast::Name;\n \n+use errors::emitter::MAX_HIGHLIGHT_LINES;\n+\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //\n@@ -42,7 +45,7 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n@@ -109,7 +112,7 @@ impl Sub for CharPos {\n }\n \n // _____________________________________________________________________________\n-// Span, Spanned\n+// Span, MultiSpan, Spanned\n //\n \n /// Spans represent a region of code, used for error reporting. Positions in spans\n@@ -129,6 +132,15 @@ pub struct Span {\n     pub expn_id: ExpnId\n }\n \n+/// Spans are converted to MultiSpans just before error reporting, either automatically,\n+/// generated by line grouping, or manually constructed.\n+/// In the latter case care should be taken to ensure that spans are ordered, disjoint,\n+/// and point into the same FileMap.\n+#[derive(Clone)]\n+pub struct MultiSpan {\n+    pub spans: Vec<Span>\n+}\n+\n pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n \n // Generic span to be used for code originating from the command line\n@@ -145,6 +157,33 @@ impl Span {\n     pub fn contains(self, other: Span) -> bool {\n         self.lo <= other.lo && other.hi <= self.hi\n     }\n+\n+    /// Returns `Some(span)`, a union of `self` and `other`, on overlap.\n+    pub fn merge(self, other: Span) -> Option<Span> {\n+        if self.expn_id != other.expn_id {\n+            return None;\n+        }\n+\n+        if (self.lo <= other.lo && self.hi > other.lo) ||\n+           (self.lo >= other.lo && self.lo < other.hi) {\n+            Some(Span {\n+                lo: cmp::min(self.lo, other.lo),\n+                hi: cmp::max(self.hi, other.hi),\n+                expn_id: self.expn_id,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n+    pub fn trim_start(self, other: Span) -> Option<Span> {\n+        if self.hi > other.hi {\n+            Some(Span { lo: cmp::max(self.lo, other.hi), .. self })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -236,6 +275,102 @@ pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n+impl MultiSpan {\n+    pub fn new() -> MultiSpan {\n+        MultiSpan { spans: Vec::new() }\n+    }\n+\n+    pub fn to_span_bounds(&self) -> Span {\n+        assert!(!self.spans.is_empty());\n+        let Span { lo, expn_id, .. } = *self.spans.first().unwrap();\n+        let Span { hi, .. } = *self.spans.last().unwrap();\n+        Span { lo: lo, hi: hi, expn_id: expn_id }\n+    }\n+\n+    /// Merges or inserts the given span into itself.\n+    pub fn push_merge(&mut self, mut sp: Span) {\n+        let mut idx_merged = None;\n+\n+        for idx in 0.. {\n+            let cur = match self.spans.get(idx) {\n+                Some(s) => *s,\n+                None => break,\n+            };\n+            // Try to merge with a contained Span\n+            if let Some(union) = cur.merge(sp) {\n+                self.spans[idx] = union;\n+                sp = union;\n+                idx_merged = Some(idx);\n+                break;\n+            }\n+            // Or insert into the first sorted position\n+            if sp.hi <= cur.lo {\n+                self.spans.insert(idx, sp);\n+                idx_merged = Some(idx);\n+                break;\n+            }\n+        }\n+        if let Some(idx) = idx_merged {\n+            // Merge with spans trailing the insertion/merging position\n+            while (idx + 1) < self.spans.len() {\n+                if let Some(union) = self.spans[idx + 1].merge(sp) {\n+                    self.spans[idx] = union;\n+                    self.spans.remove(idx + 1);\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            self.spans.push(sp);\n+        }\n+    }\n+\n+    /// Inserts the given span into itself, for use with `end_highlight_lines`.\n+    pub fn push_trim(&mut self, mut sp: Span) {\n+        let mut prev = mk_sp(BytePos(0), BytePos(0));\n+\n+        if let Some(first) = self.spans.get_mut(0) {\n+            if first.lo > sp.lo {\n+                // Prevent us here from spanning fewer lines\n+                // because of trimming the start of the span\n+                // (this should not be visible, because this method ought\n+                // to not be used in conjunction with `highlight_lines`)\n+                first.lo = sp.lo;\n+            }\n+        }\n+\n+        for idx in 0.. {\n+            if let Some(sp_trim) = sp.trim_start(prev) {\n+                // Implies `sp.hi > prev.hi`\n+                let cur = match self.spans.as_slice().get(idx) {\n+                    Some(s) => *s,\n+                    None => {\n+                        sp = sp_trim;\n+                        break;\n+                    }\n+                };\n+                // `cur` may overlap with `sp_trim`\n+                if let Some(cur_trim) = cur.trim_start(sp_trim) {\n+                    // Implies `sp.hi < cur.hi`\n+                    self.spans.insert(idx, sp_trim);\n+                    self.spans[idx + 1] = cur_trim;\n+                    return;\n+                } else if sp.hi == cur.hi {\n+                    return;\n+                }\n+                prev = cur;\n+            }\n+        }\n+        self.spans.push(sp);\n+    }\n+}\n+\n+impl From<Span> for MultiSpan {\n+    fn from(span: Span) -> MultiSpan {\n+        MultiSpan { spans: vec![span] }\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Loc, LocWithOpt, FileMapAndLine, FileMapAndBytePos\n //\n@@ -1020,6 +1155,59 @@ impl CodeMap {\n         }\n     }\n \n+    /// Groups and sorts spans by lines into `MultiSpan`s, where `push` adds them to their group,\n+    /// specifying the unification behaviour for overlapping spans.\n+    /// Spans overflowing a line are put into their own one-element-group.\n+    pub fn custom_group_spans<F>(&self, mut spans: Vec<Span>, push: F) -> Vec<MultiSpan>\n+        where F: Fn(&mut MultiSpan, Span)\n+    {\n+        spans.sort_by(|a, b| a.lo.cmp(&b.lo));\n+        let mut groups = Vec::<MultiSpan>::new();\n+        let mut overflowing = vec![];\n+        let mut prev_expn = ExpnId(!2u32);\n+        let mut prev_file = !0usize;\n+        let mut prev_line = !0usize;\n+        let mut err_size = 0;\n+\n+        for sp in spans {\n+            let line = self.lookup_char_pos(sp.lo).line;\n+            let line_hi = self.lookup_char_pos(sp.hi).line;\n+            if line != line_hi {\n+                overflowing.push(sp.into());\n+                continue\n+            }\n+            let file = self.lookup_filemap_idx(sp.lo);\n+\n+            if err_size < MAX_HIGHLIGHT_LINES && sp.expn_id == prev_expn && file == prev_file {\n+                // `push` takes care of sorting, trimming, and merging\n+                push(&mut groups.last_mut().unwrap(), sp);\n+                if line != prev_line {\n+                    err_size += 1;\n+                }\n+            } else {\n+                groups.push(sp.into());\n+                err_size = 1;\n+            }\n+            prev_expn = sp.expn_id;\n+            prev_file = file;\n+            prev_line = line;\n+        }\n+        groups.extend(overflowing);\n+        groups\n+    }\n+\n+    /// Groups and sorts spans by lines into `MultiSpan`s, merging overlapping spans.\n+    /// Spans overflowing a line are put into their own one-element-group.\n+    pub fn group_spans(&self, spans: Vec<Span>) -> Vec<MultiSpan> {\n+        self.custom_group_spans(spans, |msp, sp| msp.push_merge(sp))\n+    }\n+\n+    /// Like `group_spans`, but trims overlapping spans instead of\n+    /// merging them (for use with `end_highlight_lines`)\n+    pub fn end_group_spans(&self, spans: Vec<Span>) -> Vec<MultiSpan> {\n+        self.custom_group_spans(spans, |msp, sp| msp.push_trim(sp))\n+    }\n+\n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n@@ -1351,7 +1539,7 @@ mod tests {\n     fn span_from_selection(input: &str, selection: &str) -> Span {\n         assert_eq!(input.len(), selection.len());\n         let left_index = selection.find('^').unwrap() as u32;\n-        let right_index = selection.rfind('~').unwrap() as u32;\n+        let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n     }\n \n@@ -1511,4 +1699,73 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n+\n+    #[test]\n+    fn t13() {\n+        // Test that collecting multiple spans into line-groups works correctly\n+        let cm = CodeMap::new();\n+        let inp  =      \"_aaaaa__bbb\\nvv\\nw\\nx\\ny\\nz\\ncccccc__ddddee__\";\n+        let sp1  =      \" ^~~~~     \\n  \\n \\n \\n \\n \\n                \";\n+        let sp2  =      \"           \\n  \\n \\n \\n \\n^\\n                \";\n+        let sp3  =      \"        ^~~\\n~~\\n \\n \\n \\n \\n                \";\n+        let sp4  =      \"           \\n  \\n \\n \\n \\n \\n^~~~~~          \";\n+        let sp5  =      \"           \\n  \\n \\n \\n \\n \\n        ^~~~    \";\n+        let sp6  =      \"           \\n  \\n \\n \\n \\n \\n          ^~~~  \";\n+        let sp_trim =   \"           \\n  \\n \\n \\n \\n \\n            ^~  \";\n+        let sp_merge =  \"           \\n  \\n \\n \\n \\n \\n        ^~~~~~  \";\n+        let sp7  =      \"           \\n ^\\n \\n \\n \\n \\n                \";\n+        let sp8  =      \"           \\n  \\n^\\n \\n \\n \\n                \";\n+        let sp9  =      \"           \\n  \\n \\n^\\n \\n \\n                \";\n+        let sp10 =      \"           \\n  \\n \\n \\n^\\n \\n                \";\n+\n+        let span = |sp, expected| {\n+            let sp = span_from_selection(inp, sp);\n+            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n+            sp\n+        };\n+\n+        cm.new_filemap_and_lines(\"blork.rs\", inp);\n+        let sp1 = span(sp1, \"aaaaa\");\n+        let sp2 = span(sp2, \"z\");\n+        let sp3 = span(sp3, \"bbb\\nvv\");\n+        let sp4 = span(sp4, \"cccccc\");\n+        let sp5 = span(sp5, \"dddd\");\n+        let sp6 = span(sp6, \"ddee\");\n+        let sp7 = span(sp7, \"v\");\n+        let sp8 = span(sp8, \"w\");\n+        let sp9 = span(sp9, \"x\");\n+        let sp10 = span(sp10, \"y\");\n+        let sp_trim = span(sp_trim, \"ee\");\n+        let sp_merge = span(sp_merge, \"ddddee\");\n+\n+        let spans = vec![sp5, sp2, sp4, sp9, sp10, sp7, sp3, sp8, sp1, sp6];\n+\n+        macro_rules! check_next {\n+            ($groups: expr, $expected: expr) => ({\n+                let actual = $groups.next().map(|g|&g.spans[..]);\n+                let expected = $expected;\n+                println!(\"actual:\\n{:?}\\n\", actual);\n+                println!(\"expected:\\n{:?}\\n\", expected);\n+                assert_eq!(actual, expected.as_ref().map(|x|&x[..]));\n+            });\n+        }\n+\n+        let _groups = cm.group_spans(spans.clone());\n+        let it = &mut _groups.iter();\n+\n+        check_next!(it, Some([sp1, sp7, sp8, sp9, sp10, sp2]));\n+        // New group because we're exceeding MAX_HIGHLIGHT_LINES\n+        check_next!(it, Some([sp4, sp_merge]));\n+        check_next!(it, Some([sp3]));\n+        check_next!(it, None::<[Span; 0]>);\n+\n+        let _groups = cm.end_group_spans(spans);\n+        let it = &mut _groups.iter();\n+\n+        check_next!(it, Some([sp1, sp7, sp8, sp9, sp10, sp2]));\n+        // New group because we're exceeding MAX_HIGHLIGHT_LINES\n+        check_next!(it, Some([sp4, sp5, sp_trim]));\n+        check_next!(it, Some([sp3]));\n+        check_next!(it, None::<[Span; 0]>);\n+    }\n }"}, {"sha": "c1239bfd66db82042d5f9b3e393e2cdd86999516", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 612, "deletions": 201, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -10,10 +10,10 @@\n \n use self::Destination::*;\n \n-use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, DUMMY_SP, Pos, Span};\n+use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, DUMMY_SP, Pos, Span, MultiSpan};\n use diagnostics;\n \n-use errors::{Level, RenderSpan, DiagnosticBuilder};\n+use errors::{Level, RenderSpan, CodeSuggestion, DiagnosticBuilder};\n use errors::RenderSpan::*;\n use errors::Level::*;\n \n@@ -23,25 +23,27 @@ use std::io;\n use std::rc::Rc;\n use term;\n \n-\n pub trait Emitter {\n-    fn emit(&mut self, span: Option<Span>, msg: &str, code: Option<&str>, lvl: Level);\n-    fn custom_emit(&mut self, sp: RenderSpan, msg: &str, lvl: Level);\n+    fn emit(&mut self, span: Option<&MultiSpan>, msg: &str, code: Option<&str>, lvl: Level);\n+    fn custom_emit(&mut self, sp: &RenderSpan, msg: &str, lvl: Level);\n \n     /// Emit a structured diagnostic.\n     fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n-        self.emit(db.span, &db.message, db.code.as_ref().map(|s| &**s), db.level);\n+        self.emit(db.span.as_ref(), &db.message, db.code.as_ref().map(|s| &**s), db.level);\n         for child in &db.children {\n             match child.render_span {\n-                Some(ref sp) => self.custom_emit(sp.clone(), &child.message, child.level),\n-                None => self.emit(child.span, &child.message, None, child.level),\n+                Some(ref sp) => self.custom_emit(sp, &child.message, child.level),\n+                None => self.emit(child.span.as_ref(), &child.message, None, child.level),\n             }\n         }\n     }\n }\n \n /// maximum number of lines we will print for each error; arbitrary.\n-const MAX_LINES: usize = 6;\n+pub const MAX_HIGHLIGHT_LINES: usize = 6;\n+\n+/// maximum number of lines we will print for each span; arbitrary.\n+const MAX_SP_LINES: usize = 6;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ColorConfig {\n@@ -68,18 +70,18 @@ pub struct BasicEmitter {\n \n impl Emitter for BasicEmitter {\n     fn emit(&mut self,\n-            sp: Option<Span>,\n+            msp: Option<&MultiSpan>,\n             msg: &str,\n             code: Option<&str>,\n             lvl: Level) {\n-        assert!(sp.is_none(), \"BasicEmitter can't handle spans\");\n+        assert!(msp.is_none(), \"BasicEmitter can't handle spans\");\n         if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n \n     }\n \n-    fn custom_emit(&mut self, _: RenderSpan, _: &str, _: Level) {\n+    fn custom_emit(&mut self, _: &RenderSpan, _: &str, _: Level) {\n         panic!(\"BasicEmitter can't handle custom_emit\");\n     }\n }\n@@ -103,14 +105,16 @@ pub struct EmitterWriter {\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self,\n-            sp: Option<Span>,\n+            msp: Option<&MultiSpan>,\n             msg: &str,\n             code: Option<&str>,\n             lvl: Level) {\n-        let error = match sp {\n-            Some(COMMAND_LINE_SP) => self.emit_(FileLine(COMMAND_LINE_SP), msg, code, lvl),\n-            Some(DUMMY_SP) | None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n-            Some(sp) => self.emit_(FullSpan(sp), msg, code, lvl),\n+        let error = match msp.map(|s|(s.to_span_bounds(), s)) {\n+            Some((COMMAND_LINE_SP, msp)) => {\n+                self.emit_(&FileLine(msp.clone()), msg, code, lvl)\n+            },\n+            Some((DUMMY_SP, _)) | None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n+            Some((_, msp)) => self.emit_(&FullSpan(msp.clone()), msg, code, lvl),\n         };\n \n         if let Err(e) = error {\n@@ -119,10 +123,10 @@ impl Emitter for EmitterWriter {\n     }\n \n     fn custom_emit(&mut self,\n-                   sp: RenderSpan,\n+                   rsp: &RenderSpan,\n                    msg: &str,\n                    lvl: Level) {\n-        if let Err(e) = self.emit_(sp, msg, None, lvl) {\n+        if let Err(e) = self.emit_(rsp, msg, None, lvl) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n@@ -163,114 +167,93 @@ impl EmitterWriter {\n     }\n \n     fn emit_(&mut self,\n-             rsp: RenderSpan,\n+             rsp: &RenderSpan,\n              msg: &str,\n              code: Option<&str>,\n              lvl: Level)\n              -> io::Result<()> {\n-        let sp = rsp.span();\n+        let msp = rsp.span();\n+        let bounds = msp.to_span_bounds();\n \n         // We cannot check equality directly with COMMAND_LINE_SP\n         // since PartialEq is manually implemented to ignore the ExpnId\n-        let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n+        let ss = if bounds.expn_id == COMMAND_LINE_EXPN {\n             \"<command line option>\".to_string()\n-        } else if let EndSpan(_) = rsp {\n-            let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+        } else if let EndSpan(_) = *rsp {\n+            let span_end = Span { lo: bounds.hi, hi: bounds.hi, expn_id: bounds.expn_id};\n             self.cm.span_to_string(span_end)\n         } else {\n-            self.cm.span_to_string(sp)\n+            self.cm.span_to_string(bounds)\n         };\n \n         try!(print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code));\n \n-        match rsp {\n+        match *rsp {\n             FullSpan(_) => {\n-                let lines = self.cm.span_to_lines(sp);\n-                try!(self.highlight_lines(sp, lvl, lines));\n-                try!(self.print_macro_backtrace(sp));\n+                try!(self.highlight_lines(msp, lvl));\n+                try!(self.print_macro_backtrace(bounds));\n             }\n             EndSpan(_) => {\n-                let lines = self.cm.span_to_lines(sp);\n-                try!(self.end_highlight_lines(sp, lvl, lines));\n-                try!(self.print_macro_backtrace(sp));\n+                try!(self.end_highlight_lines(msp, lvl));\n+                try!(self.print_macro_backtrace(bounds));\n             }\n-            Suggestion(_, ref suggestion) => {\n-                try!(self.highlight_suggestion(sp, suggestion));\n-                try!(self.print_macro_backtrace(sp));\n+            Suggestion(ref suggestion) => {\n+                try!(self.highlight_suggestion(suggestion));\n+                try!(self.print_macro_backtrace(bounds));\n             }\n             FileLine(..) => {\n                 // no source text in this case!\n             }\n         }\n \n-        match code {\n-            Some(code) =>\n-                match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n-                    Some(_) => {\n-                        try!(print_diagnostic(&mut self.dst, &ss[..], Help,\n-                                              &format!(\"run `rustc --explain {}` to see a \\\n-                                                       detailed explanation\", code), None));\n-                    }\n-                    None => ()\n-                },\n-            None => (),\n+        if let Some(code) = code {\n+            if let Some(_) = self.registry.as_ref()\n+                                          .and_then(|registry| registry.find_description(code)) {\n+                try!(print_diagnostic(&mut self.dst, &ss[..], Help,\n+                                      &format!(\"run `rustc --explain {}` to see a \\\n+                                               detailed explanation\", code), None));\n+            }\n         }\n         Ok(())\n     }\n \n-    fn highlight_suggestion(&mut self,\n-                            sp: Span,\n-                            suggestion: &str)\n-                            -> io::Result<()>\n+    fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n     {\n-        let lines = self.cm.span_to_lines(sp).unwrap();\n+        let lines = self.cm.span_to_lines(suggestion.msp.to_span_bounds()).unwrap();\n         assert!(!lines.lines.is_empty());\n \n-        // To build up the result, we want to take the snippet from the first\n-        // line that precedes the span, prepend that with the suggestion, and\n-        // then append the snippet from the last line that trails the span.\n-        let fm = &lines.file;\n-\n-        let first_line = &lines.lines[0];\n-        let prefix = fm.get_line(first_line.line_index)\n-                       .map(|l| &l[..first_line.start_col.0])\n-                       .unwrap_or(\"\");\n+        let complete = suggestion.splice_lines(&self.cm);\n+        let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n+        let display_lines = &lines.lines[..line_count];\n \n-        let last_line = lines.lines.last().unwrap();\n-        let suffix = fm.get_line(last_line.line_index)\n-                       .map(|l| &l[last_line.end_col.0..])\n-                       .unwrap_or(\"\");\n-\n-        let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n+        let fm = &*lines.file;\n+        // Calculate the widest number to format evenly\n+        let max_digits = line_num_max_digits(display_lines.last().unwrap());\n \n         // print the suggestion without any line numbers, but leave\n         // space for them. This helps with lining up with previous\n         // snippets from the actual error being reported.\n-        let fm = &*lines.file;\n         let mut lines = complete.lines();\n-        for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n-            let elided_line_num = format!(\"{}\", line_index+1);\n+        for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n             try!(write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                        fm.name, \"\", elided_line_num.len(), line));\n+                        fm.name, \"\", max_digits, line));\n         }\n \n         // if we elided some lines, add an ellipsis\n-        if lines.next().is_some() {\n-            let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n+        if let Some(_) = lines.next() {\n             try!(write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                        \"\", fm.name.len(), elided_line_num.len()));\n+                        \"\", fm.name.len(), max_digits));\n         }\n \n         Ok(())\n     }\n \n     fn highlight_lines(&mut self,\n-                       sp: Span,\n-                       lvl: Level,\n-                       lines: codemap::FileLinesResult)\n+                       msp: &MultiSpan,\n+                       lvl: Level)\n                        -> io::Result<()>\n     {\n-        let lines = match lines {\n+        let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n             Ok(lines) => lines,\n             Err(_) => {\n                 try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n@@ -279,73 +262,111 @@ impl EmitterWriter {\n         };\n \n         let fm = &*lines.file;\n+        if let None = fm.src {\n+            return Ok(());\n+        }\n \n-        let line_strings: Option<Vec<&str>> =\n-            lines.lines.iter()\n-                       .map(|info| fm.get_line(info.line_index))\n-                       .collect();\n-\n-        let line_strings = match line_strings {\n-            None => { return Ok(()); }\n-            Some(line_strings) => line_strings\n-        };\n-\n-        // Display only the first MAX_LINES lines.\n-        let all_lines = lines.lines.len();\n-        let display_lines = cmp::min(all_lines, MAX_LINES);\n-        let display_line_infos = &lines.lines[..display_lines];\n-        let display_line_strings = &line_strings[..display_lines];\n+        let display_line_infos = &lines.lines[..];\n+        assert!(display_line_infos.len() > 0);\n \n         // Calculate the widest number to format evenly and fix #11715\n-        assert!(display_line_infos.len() > 0);\n-        let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n-        let mut digits = 0;\n-        while max_line_num > 0 {\n-            max_line_num /= 10;\n-            digits += 1;\n-        }\n+        let digits = line_num_max_digits(display_line_infos.last().unwrap());\n+        let first_line_index = display_line_infos.first().unwrap().line_index;\n \n-        // Print the offending lines\n-        for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n-            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n-                        fm.name,\n-                        line_info.line_index + 1,\n-                        line,\n-                        width=digits));\n-        }\n+        let skip = fm.name.chars().count() + digits + 2;\n \n-        // If we elided something, put an ellipsis.\n-        if display_lines < all_lines {\n-            let last_line_index = display_line_infos.last().unwrap().line_index;\n-            let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n-            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", s.len()));\n-        }\n+        let mut spans = msp.spans.iter().peekable();\n+        let mut lines = display_line_infos.iter();\n+        let mut prev_line_index = first_line_index.wrapping_sub(1);\n \n-        // FIXME (#3260)\n-        // If there's one line at fault we can easily point to the problem\n-        if lines.lines.len() == 1 {\n-            let lo = self.cm.lookup_char_pos(sp.lo);\n-            let mut digits = 0;\n-            let mut num = (lines.lines[0].line_index + 1) / 10;\n+        // Display at most MAX_HIGHLIGHT_LINES lines.\n+        let mut remaining_err_lines = MAX_HIGHLIGHT_LINES;\n \n-            // how many digits must be indent past?\n-            while num > 0 { num /= 10; digits += 1; }\n+        // To emit a overflowed spans code-lines *AFTER* the rendered spans\n+        let mut overflowed_buf = String::new();\n+        let mut overflowed = false;\n \n-            let mut s = String::new();\n-            // Skip is the number of characters we need to skip because they are\n-            // part of the 'filename:line ' part of the previous line.\n-            let skip = fm.name.chars().count() + digits + 3;\n-            for _ in 0..skip {\n-                s.push(' ');\n+        // FIXME (#8706)\n+        'l: loop {\n+            if remaining_err_lines <= 0 {\n+                break;\n             }\n-            if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n-                let mut col = skip;\n-                let mut lastc = ' ';\n-                let mut iter = orig.chars().enumerate();\n-                for (pos, ch) in iter.by_ref() {\n+            let line = match lines.next() {\n+                Some(l) => l,\n+                None => break,\n+            };\n+\n+            // Skip is the number of characters we need to skip because they are\n+            // part of the 'filename:line ' part of the code line.\n+            let mut s: String = ::std::iter::repeat(' ').take(skip).collect();\n+            let mut col = skip;\n+            let mut lastc = ' ';\n+\n+            let cur_line_str = fm.get_line(line.line_index).unwrap();\n+            let mut line_chars = cur_line_str.chars().enumerate().peekable();\n+            let mut line_spans = 0;\n+\n+            // Assemble spans for this line\n+            loop {\n+                // Peek here to preserve the span if it doesn't belong to this line\n+                let sp = match spans.peek() {\n+                    Some(sp) => **sp,\n+                    None => break,\n+                };\n+                let lo = self.cm.lookup_char_pos(sp.lo);\n+                let hi = self.cm.lookup_char_pos(sp.hi);\n+                let line_num = line.line_index + 1;\n+\n+                if !(lo.line <= line_num && hi.line >= line_num) {\n+                    // This line is not contained in the span\n+                    if overflowed {\n+                        // Never elide the final line of an overflowed span\n+                        prev_line_index = line.line_index - 1;\n+                        overflowed = false;\n+                        break;\n+                    }\n+\n+                    if line_spans == 0 {\n+                        continue 'l;\n+                    } else {\n+                        // This line is finished, now render the spans we've assembled\n+                        break;\n+                    }\n+                }\n+                spans.next();\n+                line_spans += 1;\n+\n+                if lo.line != hi.line {\n+                    // Assemble extra code lines to be emitted after this lines spans\n+                    // (substract `2` because the first and last line are rendered normally)\n+                    let max_lines = cmp::min(remaining_err_lines, MAX_SP_LINES) - 2;\n+                    prev_line_index = line.line_index;\n+                    let count = cmp::min((hi.line - lo.line - 1), max_lines);\n+                    for _ in 0..count {\n+                        let line = match lines.next() {\n+                            Some(l) => l,\n+                            None => break,\n+                        };\n+                        let line_str = fm.get_line(line.line_index).unwrap();\n+                        overflowed_buf.push_str(&format!(\"{}:{:>width$} {}\\n\",\n+                                                       fm.name,\n+                                                       line.line_index + 1,\n+                                                       line_str,\n+                                                       width=digits));\n+                        remaining_err_lines -= 1;\n+                        prev_line_index += 1\n+                    }\n+                    // Remember that the span overflowed to ensure\n+                    // that we emit its last line exactly once\n+                    // (other spans may, or may not, start on it)\n+                    overflowed = true;\n+                    break;\n+                }\n+\n+                for (pos, ch) in line_chars.by_ref() {\n                     lastc = ch;\n                     if pos >= lo.col.to_usize() { break; }\n-                    // Whenever a tab occurs on the previous line, we insert one on\n+                    // Whenever a tab occurs on the code line, we insert one on\n                     // the error-point-squiggly-line as well (instead of a space).\n                     // That way the squiggly line will usually appear in the correct\n                     // position.\n@@ -361,8 +382,8 @@ impl EmitterWriter {\n                     }\n                 }\n \n-                try!(write!(&mut self.dst, \"{}\", s));\n-                let mut s = String::from(\"^\");\n+                s.push('^');\n+                let col_ptr = col;\n                 let count = match lastc {\n                     // Most terminals have a tab stop every eight columns by default\n                     '\\t' => 8 - col%8,\n@@ -373,42 +394,77 @@ impl EmitterWriter {\n \n                 let hi = self.cm.lookup_char_pos(sp.hi);\n                 if hi.col != lo.col {\n-                    for (pos, ch) in iter {\n+                    let mut chars = line_chars.by_ref();\n+                    loop {\n+                        // We peek here to preserve the value for the next span\n+                        let (pos, ch) = match chars.peek() {\n+                            Some(elem) => *elem,\n+                            None => break,\n+                        };\n                         if pos >= hi.col.to_usize() { break; }\n                         let count = match ch {\n                             '\\t' => 8 - col%8,\n                             _ => 1,\n                         };\n                         col += count;\n                         s.extend(::std::iter::repeat('~').take(count));\n+\n+                        chars.next();\n                     }\n                 }\n-\n-                if s.len() > 1 {\n+                if (col - col_ptr) > 1 {\n                     // One extra squiggly is replaced by a \"^\"\n                     s.pop();\n                 }\n+            }\n \n+            // If we elided something put an ellipsis.\n+            if prev_line_index != line.line_index.wrapping_sub(1) && !overflowed {\n+                try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip));\n+            }\n+\n+            // Print offending code-line\n+            remaining_err_lines -= 1;\n+            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n+                        fm.name,\n+                        line.line_index + 1,\n+                        cur_line_str,\n+                        width=digits));\n+\n+            if s.len() > skip {\n+                // Render the spans we assembled previously (if any).\n                 try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n                                            \"{}\", s));\n             }\n+\n+            if !overflowed_buf.is_empty() {\n+                // Print code-lines trailing the rendered spans (when a span overflows)\n+                try!(write!(&mut self.dst, \"{}\", &overflowed_buf));\n+                overflowed_buf.clear();\n+            } else {\n+                prev_line_index = line.line_index;\n+            }\n+        }\n+\n+        // If we elided something, put an ellipsis.\n+        if lines.next().is_some() {\n+            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip));\n         }\n         Ok(())\n     }\n \n     /// Here are the differences between this and the normal `highlight_lines`:\n-    /// `end_highlight_lines` will always put arrow on the last byte of the\n-    /// span (instead of the first byte). Also, when the span is too long (more\n+    /// `end_highlight_lines` will always put arrow on the last byte of each\n+    /// span (instead of the first byte). Also, when a span is too long (more\n     /// than 6 lines), `end_highlight_lines` will print the first line, then\n     /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n     /// six lines.\n     #[allow(deprecated)]\n     fn end_highlight_lines(&mut self,\n-                           sp: Span,\n-                           lvl: Level,\n-                           lines: codemap::FileLinesResult)\n+                           msp: &MultiSpan,\n+                           lvl: Level)\n                           -> io::Result<()> {\n-        let lines = match lines {\n+        let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n             Ok(lines) => lines,\n             Err(_) => {\n                 try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n@@ -417,52 +473,107 @@ impl EmitterWriter {\n         };\n \n         let fm = &*lines.file;\n+        if let None = fm.src {\n+            return Ok(());\n+        }\n \n         let lines = &lines.lines[..];\n-        if lines.len() > MAX_LINES {\n-            if let Some(line) = fm.get_line(lines[0].line_index) {\n-                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n-                            lines[0].line_index + 1, line));\n-            }\n-            try!(write!(&mut self.dst, \"...\\n\"));\n-            let last_line_index = lines[lines.len() - 1].line_index;\n-            if let Some(last_line) = fm.get_line(last_line_index) {\n-                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n-                            last_line_index + 1, last_line));\n+\n+        // Calculate the widest number to format evenly\n+        let first_line = lines.first().unwrap();\n+        let last_line = lines.last().unwrap();\n+        let digits = line_num_max_digits(last_line);\n+\n+        let skip = fm.name.chars().count() + digits + 2;\n+\n+        let mut spans = msp.spans.iter().peekable();\n+        let mut lines = lines.iter();\n+        let mut prev_line_index = first_line.line_index.wrapping_sub(1);\n+\n+        // Display at most MAX_HIGHLIGHT_LINES lines.\n+        let mut remaining_err_lines = MAX_HIGHLIGHT_LINES;\n+\n+        'l: loop {\n+            if remaining_err_lines <= 0 {\n+                break;\n             }\n-        } else {\n-            for line_info in lines {\n-                if let Some(line) = fm.get_line(line_info.line_index) {\n-                    try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n-                                line_info.line_index + 1, line));\n+            let line = match lines.next() {\n+                Some(line) => line,\n+                None => break,\n+            };\n+\n+            // Skip is the number of characters we need to skip because they are\n+            // part of the 'filename:line ' part of the previous line.\n+            let mut s: String = ::std::iter::repeat(' ').take(skip).collect();\n+\n+            let line_str = fm.get_line(line.line_index).unwrap();\n+            let mut line_chars = line_str.chars().enumerate();\n+            let mut line_spans = 0;\n+\n+            loop {\n+                // Peek here to preserve the span if it doesn't belong to this line\n+                let sp = match spans.peek() {\n+                    Some(sp) => **sp,\n+                    None => break,\n+                };\n+                let lo = self.cm.lookup_char_pos(sp.lo);\n+                let hi = self.cm.lookup_char_pos(sp.hi);\n+                let elide_sp = (lo.line - hi.line) > MAX_SP_LINES;\n+\n+                let line_num = line.line_index + 1;\n+                if !(lo.line <= line_num && hi.line >= line_num) {\n+                    // This line is not contained in the span\n+                    if line_spans == 0 {\n+                        continue 'l;\n+                    } else {\n+                        // This line is finished, now render the spans we've assembled\n+                        break\n+                    }\n+                } else if hi.line > line_num {\n+                    if elide_sp && lo.line < line_num {\n+                        // This line is inbetween the first and last line of the span,\n+                        // so we may want to elide it.\n+                        continue 'l;\n+                    } else {\n+                        break\n+                    }\n                 }\n-            }\n-        }\n-        let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n-        let hi = self.cm.lookup_char_pos(sp.hi);\n-        let skip = last_line_start.chars().count();\n-        let mut s = String::new();\n-        for _ in 0..skip {\n-            s.push(' ');\n-        }\n-        if let Some(orig) = fm.get_line(lines[0].line_index) {\n-            let iter = orig.chars().enumerate();\n-            for (pos, ch) in iter {\n-                // Span seems to use half-opened interval, so subtract 1\n-                if pos >= hi.col.to_usize() - 1 { break; }\n-                // Whenever a tab occurs on the previous line, we insert one on\n-                // the error-point-squiggly-line as well (instead of a space).\n-                // That way the squiggly line will usually appear in the correct\n-                // position.\n-                match ch {\n-                    '\\t' => s.push('\\t'),\n-                    _ => s.push(' '),\n+                line_spans += 1;\n+                spans.next();\n+\n+                for (pos, ch) in line_chars.by_ref() {\n+                    // Span seems to use half-opened interval, so subtract 1\n+                    if pos >= hi.col.to_usize() - 1 { break; }\n+                    // Whenever a tab occurs on the previous line, we insert one on\n+                    // the error-point-squiggly-line as well (instead of a space).\n+                    // That way the squiggly line will usually appear in the correct\n+                    // position.\n+                    match ch {\n+                        '\\t' => s.push('\\t'),\n+                        _ => s.push(' '),\n+                    }\n                 }\n+                s.push('^');\n+            }\n+\n+            if prev_line_index != line.line_index.wrapping_sub(1) {\n+                // If we elided something, put an ellipsis.\n+                try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip));\n             }\n+\n+            // Print offending code-lines\n+            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\", fm.name,\n+                        line.line_index + 1, line_str, width=digits));\n+            remaining_err_lines -= 1;\n+\n+            if s.len() > skip {\n+                // Render the spans we assembled previously (if any)\n+                try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n+                                           \"{}\", s));\n+            }\n+            prev_line_index = line.line_index;\n         }\n-        s.push('^');\n-        println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                              \"{}\", s)\n+        Ok(())\n     }\n \n     fn print_macro_backtrace(&mut self,\n@@ -512,6 +623,16 @@ impl EmitterWriter {\n     }\n }\n \n+fn line_num_max_digits(line: &codemap::LineInfo) -> usize {\n+    let mut max_line_num = line.line_index + 1;\n+    let mut digits = 0;\n+    while max_line_num > 0 {\n+        max_line_num /= 10;\n+        digits += 1;\n+    }\n+    digits\n+}\n+\n fn print_diagnostic(dst: &mut Destination,\n                     topic: &str,\n                     lvl: Level,\n@@ -526,12 +647,9 @@ fn print_diagnostic(dst: &mut Destination,\n                              \"{}: \", lvl.to_string()));\n     try!(print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg));\n \n-    match code {\n-        Some(code) => {\n-            let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled!(dst, style, \" [{}]\", code.clone()));\n-        }\n-        None => ()\n+    if let Some(code) = code {\n+        let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+        try!(print_maybe_styled!(dst, style, \" [{}]\", code.clone()));\n     }\n     try!(write!(dst, \"\\n\"));\n     Ok(())\n@@ -632,24 +750,36 @@ impl Write for Destination {\n \n #[cfg(test)]\n mod test {\n-    use errors::Level;\n+    use errors::{Level, CodeSuggestion};\n     use super::EmitterWriter;\n-    use codemap::{mk_sp, CodeMap};\n+    use codemap::{mk_sp, CodeMap, Span, MultiSpan, BytePos, NO_EXPANSION};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n     use std::str::from_utf8;\n     use std::rc::Rc;\n \n+    struct Sink(Arc<Mutex<Vec<u8>>>);\n+    impl Write for Sink {\n+        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+            Write::write(&mut *self.0.lock().unwrap(), data)\n+        }\n+        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    }\n+\n+    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n+    /// coverting that range. The idea is that the string has the same\n+    /// length as the input, and we uncover the byte positions.  Note\n+    /// that this can span lines and so on.\n+    fn span_from_selection(input: &str, selection: &str) -> Span {\n+        assert_eq!(input.len(), selection.len());\n+        let left_index = selection.find('^').unwrap() as u32;\n+        let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n+        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n+    }\n+\n     // Diagnostic doesn't align properly in span where line number increases by one digit\n     #[test]\n     fn test_hilight_suggestion_issue_11715() {\n-        struct Sink(Arc<Mutex<Vec<u8>>>);\n-        impl Write for Sink {\n-            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-                Write::write(&mut *self.0.lock().unwrap(), data)\n-            }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-        }\n         let data = Arc::new(Mutex::new(Vec::new()));\n         let cm = Rc::new(CodeMap::new());\n         let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n@@ -672,10 +802,8 @@ mod test {\n         let end = file.lines.borrow()[11];\n         let sp = mk_sp(start, end);\n         let lvl = Level::Error;\n-        println!(\"span_to_lines\");\n-        let lines = cm.span_to_lines(sp);\n         println!(\"highlight_lines\");\n-        ew.highlight_lines(sp, lvl, lines).unwrap();\n+        ew.highlight_lines(&sp.into(), lvl).unwrap();\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;\n@@ -687,4 +815,287 @@ mod test {\n                          dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n                          dummy.txt:12         tolv\\n\");\n     }\n+\n+    #[test]\n+    fn test_single_span_splice() {\n+        // Test that a `MultiSpan` containing a single span splices a substition correctly\n+        let cm = CodeMap::new();\n+        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        let sp = span_from_selection(inputtext, selection);\n+        let msp: MultiSpan = sp.into();\n+\n+        // check that we are extracting the text we thought we were extracting\n+        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+        let substitute = \"ZZZZZZ\".to_owned();\n+        let expected = \"bbbbZZZZZZddddd\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![substitute],\n+        };\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n+    }\n+\n+    #[test]\n+    fn test_multiple_span_splice() {\n+        // Test that a `MultiSpan` containing multiple spans splices substitions on\n+        // several lines correctly\n+        let cm = CodeMap::new();\n+        let inp = \"aaaaabbbbBB\\nZZ\\nZZ\\nCCCDDDDDdddddeee\";\n+        let sp1 = \"     ^~~~~~\\n  \\n  \\n                \";\n+        let sp2 = \"           \\n  \\n  \\n^~~~~~          \";\n+        let sp3 = \"           \\n  \\n  \\n        ^~~     \";\n+        let sp4 = \"           \\n  \\n  \\n           ^~~~ \";\n+\n+        let span_eq = |sp, eq| assert_eq!(&cm.span_to_snippet(sp).unwrap(), eq);\n+\n+        cm.new_filemap_and_lines(\"blork.rs\", inp);\n+        let sp1 = span_from_selection(inp, sp1);\n+        let sp2 = span_from_selection(inp, sp2);\n+        let sp3 = span_from_selection(inp, sp3);\n+        let sp4 = span_from_selection(inp, sp4);\n+        span_eq(sp1, \"bbbbBB\");\n+        span_eq(sp2, \"CCCDDD\");\n+        span_eq(sp3, \"ddd\");\n+        span_eq(sp4, \"ddee\");\n+\n+        let substitutes: Vec<String> = [\"1\", \"2\", \"3\", \"4\"].iter().map(|x|x.to_string()).collect();\n+        let expected = \"aaaaa1\\nZZ\\nZZ\\n2DD34e\";\n+\n+        let test = |msp| {\n+            let suggest = CodeSuggestion {\n+                msp: msp,\n+                substitutes: substitutes.clone(),\n+            };\n+            let actual = suggest.splice_lines(&cm);\n+            assert_eq!(actual, expected);\n+        };\n+        test(MultiSpan { spans: vec![sp1, sp2, sp3, sp4] });\n+\n+        // Test ordering and merging by `MultiSpan::push`\n+        let mut msp = MultiSpan::new();\n+        msp.push_merge(sp2);\n+        msp.push_merge(sp1);\n+        assert_eq!(&msp.spans, &[sp1, sp2]);\n+        msp.push_merge(sp4);\n+        assert_eq!(&msp.spans, &[sp1, sp2, sp4]);\n+        msp.push_merge(sp3);\n+        assert_eq!(&msp.spans, &[sp1, sp2, sp3, sp4]);\n+        test(msp);\n+    }\n+\n+    #[test]\n+    fn test_multispan_highlight() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n+\n+        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n+        let sp1 =       \"     ^~~~~~                    \";\n+        let sp2 =       \"               ^~~~~~          \";\n+        let sp3 =       \"                       ^~~~~   \";\n+        let sp4 =       \"                          ^~~~ \";\n+        let sp34 =      \"                       ^~~~~~~ \";\n+        let sp4_end =   \"                            ^~ \";\n+\n+        let expect_start = \"dummy.txt:1 _____aaaaaa____bbbbbb__cccccdd_\\n\\\n+                         \\x20                ^~~~~~    ^~~~~~  ^~~~~~~\\n\";\n+        let expect_end =   \"dummy.txt:1 _____aaaaaa____bbbbbb__cccccdd_\\n\\\n+                         \\x20                     ^         ^      ^ ^\\n\";\n+\n+        let span = |sp, expected| {\n+            let sp = span_from_selection(inp, sp);\n+            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n+            sp\n+        };\n+        cm.new_filemap_and_lines(\"dummy.txt\", inp);\n+        let sp1 = span(sp1, \"aaaaaa\");\n+        let sp2 = span(sp2, \"bbbbbb\");\n+        let sp3 = span(sp3, \"ccccc\");\n+        let sp4 = span(sp4, \"ccdd\");\n+        let sp34 = span(sp34, \"cccccdd\");\n+        let sp4_end = span(sp4_end, \"dd\");\n+\n+        let spans = vec![sp1, sp2, sp3, sp4];\n+\n+        let test = |expected, highlight: &mut FnMut()| {\n+            data.lock().unwrap().clear();\n+            highlight();\n+            let vec = data.lock().unwrap().clone();\n+            let actual = from_utf8(&vec[..]).unwrap();\n+            assert_eq!(actual, expected);\n+        };\n+\n+        let msp = MultiSpan { spans: vec![sp1, sp2, sp34] };\n+        let msp_end = MultiSpan { spans: vec![sp1, sp2, sp3, sp4_end] };\n+        test(expect_start, &mut || {\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+        test(expect_end, &mut || {\n+            diag.end_highlight_lines(&msp_end, Level::Error).unwrap();\n+        });\n+        test(expect_start, &mut || {\n+            for msp in cm.group_spans(spans.clone()) {\n+                diag.highlight_lines(&msp, Level::Error).unwrap();\n+            }\n+        });\n+        test(expect_end, &mut || {\n+            for msp in cm.end_group_spans(spans.clone()) {\n+                diag.end_highlight_lines(&msp, Level::Error).unwrap();\n+            }\n+        });\n+    }\n+\n+    #[test]\n+    fn test_huge_multispan_highlight() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n+\n+        let inp = \"aaaaa\\n\\\n+                   aaaaa\\n\\\n+                   aaaaa\\n\\\n+                   bbbbb\\n\\\n+                   ccccc\\n\\\n+                   xxxxx\\n\\\n+                   yyyyy\\n\\\n+                   _____\\n\\\n+                   ddd__eee_\\n\\\n+                   elided\\n\\\n+                   _ff_gg\";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", inp);\n+\n+        let span = |lo, hi, (off_lo, off_hi)| {\n+            let lines = file.lines.borrow();\n+            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n+            lo.0 += off_lo;\n+            hi.0 += off_hi;\n+            mk_sp(lo, hi)\n+        };\n+        let sp0 = span(4, 6, (0, 5));\n+        let sp1 = span(0, 6, (0, 5));\n+        let sp2 = span(8, 8, (0, 3));\n+        let sp3 = span(8, 8, (5, 8));\n+        let sp4 = span(10, 10, (1, 3));\n+        let sp5 = span(10, 10, (4, 6));\n+\n+        let expect0 = \"dummy.txt: 5 ccccc\\n\\\n+                       dummy.txt: 6 xxxxx\\n\\\n+                       dummy.txt: 7 yyyyy\\n\\\n+                    \\x20            ...\\n\\\n+                       dummy.txt: 9 ddd__eee_\\n\\\n+                    \\x20            ^~~  ^~~\\n\\\n+                    \\x20            ...\\n\\\n+                       dummy.txt:11 _ff_gg\\n\\\n+                    \\x20             ^~ ^~\\n\";\n+\n+        let expect = \"dummy.txt: 1 aaaaa\\n\\\n+                      dummy.txt: 2 aaaaa\\n\\\n+                      dummy.txt: 3 aaaaa\\n\\\n+                      dummy.txt: 4 bbbbb\\n\\\n+                      dummy.txt: 5 ccccc\\n\\\n+                      dummy.txt: 6 xxxxx\\n\\\n+                   \\x20            ...\\n\";\n+\n+        let expect_g1 = \"dummy.txt:1 aaaaa\\n\\\n+                         dummy.txt:2 aaaaa\\n\\\n+                         dummy.txt:3 aaaaa\\n\\\n+                         dummy.txt:4 bbbbb\\n\\\n+                         dummy.txt:5 ccccc\\n\\\n+                         dummy.txt:6 xxxxx\\n\\\n+                      \\x20           ...\\n\";\n+\n+        let expect2 = \"dummy.txt: 9 ddd__eee_\\n\\\n+                    \\x20            ^~~  ^~~\\n\\\n+                    \\x20            ...\\n\\\n+                       dummy.txt:11 _ff_gg\\n\\\n+                    \\x20             ^~ ^~\\n\";\n+\n+\n+        let expect_end = \"dummy.txt: 1 aaaaa\\n\\\n+                       \\x20            ...\\n\\\n+                          dummy.txt: 7 yyyyy\\n\\\n+                       \\x20                ^\\n\\\n+                       \\x20            ...\\n\\\n+                          dummy.txt: 9 ddd__eee_\\n\\\n+                       \\x20              ^    ^\\n\\\n+                       \\x20            ...\\n\\\n+                          dummy.txt:11 _ff_gg\\n\\\n+                       \\x20              ^  ^\\n\";\n+\n+        let expect0_end = \"dummy.txt: 5 ccccc\\n\\\n+                        \\x20            ...\\n\\\n+                           dummy.txt: 7 yyyyy\\n\\\n+                        \\x20                ^\\n\\\n+                        \\x20            ...\\n\\\n+                           dummy.txt: 9 ddd__eee_\\n\\\n+                        \\x20              ^    ^\\n\\\n+                        \\x20            ...\\n\\\n+                           dummy.txt:11 _ff_gg\\n\\\n+                        \\x20              ^  ^\\n\";\n+\n+        let expect_end_g1 = \"dummy.txt:1 aaaaa\\n\\\n+                          \\x20           ...\\n\\\n+                             dummy.txt:7 yyyyy\\n\\\n+                          \\x20               ^\\n\";\n+\n+        let expect2_end = \"dummy.txt: 9 ddd__eee_\\n\\\n+                        \\x20              ^    ^\\n\\\n+                        \\x20            ...\\n\\\n+                           dummy.txt:11 _ff_gg\\n\\\n+                        \\x20              ^  ^\\n\";\n+\n+        let expect_groups = [expect2, expect_g1];\n+        let expect_end_groups = [expect2_end, expect_end_g1];\n+        let spans = vec![sp3, sp1, sp4, sp2, sp5];\n+\n+        macro_rules! test {\n+            ($expected: expr, $highlight: expr) => ({\n+                data.lock().unwrap().clear();\n+                $highlight();\n+                let vec = data.lock().unwrap().clone();\n+                let actual = from_utf8(&vec[..]).unwrap();\n+                println!(\"actual:\");\n+                println!(\"{}\", actual);\n+                println!(\"expected:\");\n+                println!(\"{}\", $expected);\n+                assert_eq!(&actual[..], &$expected[..]);\n+            });\n+        }\n+\n+        let msp0 = MultiSpan { spans: vec![sp0, sp2, sp3, sp4, sp5] };\n+        let msp = MultiSpan { spans: vec![sp1, sp2, sp3, sp4, sp5] };\n+        let msp2 = MultiSpan { spans: vec![sp2, sp3, sp4, sp5] };\n+\n+        test!(expect0, || {\n+            diag.highlight_lines(&msp0, Level::Error).unwrap();\n+        });\n+        test!(expect0_end, || {\n+            diag.end_highlight_lines(&msp0, Level::Error).unwrap();\n+        });\n+        test!(expect, || {\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+        test!(expect_end, || {\n+            diag.end_highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+        test!(expect2, || {\n+            diag.highlight_lines(&msp2, Level::Error).unwrap();\n+        });\n+        test!(expect2_end, || {\n+            diag.end_highlight_lines(&msp2, Level::Error).unwrap();\n+        });\n+        for (msp, expect) in cm.group_spans(spans.clone()).iter().zip(expect_groups.iter()) {\n+            test!(expect, || {\n+                diag.highlight_lines(&msp, Level::Error).unwrap();\n+            });\n+        }\n+        for (msp, expect) in cm.group_spans(spans.clone()).iter().zip(expect_end_groups.iter()) {\n+            test!(expect, || {\n+                diag.end_highlight_lines(&msp, Level::Error).unwrap();\n+            });\n+        }\n+    }\n }"}, {"sha": "5bb5f4757e013ad729d8cd389687e560254784d1", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 60, "deletions": 52, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -20,9 +20,9 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{Span, CodeMap};\n+use codemap::{MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n-use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan};\n+use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n \n use std::rc::Rc;\n@@ -52,15 +52,15 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit(&mut self, span: Option<Span>, msg: &str, code: Option<&str>, level: Level) {\n+    fn emit(&mut self, span: Option<&MultiSpan>, msg: &str, code: Option<&str>, level: Level) {\n         let data = Diagnostic::new(span, msg, code, level, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n \n-    fn custom_emit(&mut self, sp: RenderSpan, msg: &str, level: Level) {\n-        let data = Diagnostic::from_render_span(&sp, msg, level, self);\n+    fn custom_emit(&mut self, sp: &RenderSpan, msg: &str, level: Level) {\n+        let data = Diagnostic::from_render_span(sp, msg, level, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n@@ -83,7 +83,7 @@ struct Diagnostic<'a> {\n     code: Option<DiagnosticCode>,\n     /// \"error: internal compiler error\", \"error\", \"warning\", \"note\", \"help\".\n     level: &'static str,\n-    span: Option<DiagnosticSpan>,\n+    spans: Vec<DiagnosticSpan>,\n     /// Assocaited diagnostic messages.\n     children: Vec<Diagnostic<'a>>,\n }\n@@ -110,7 +110,7 @@ struct DiagnosticCode {\n }\n \n impl<'a> Diagnostic<'a> {\n-    fn new(span: Option<Span>,\n+    fn new(msp: Option<&MultiSpan>,\n            msg: &'a str,\n            code: Option<&str>,\n            level: Level,\n@@ -120,7 +120,7 @@ impl<'a> Diagnostic<'a> {\n             message: msg,\n             code: DiagnosticCode::map_opt_string(code.map(|c| c.to_owned()), je),\n             level: level.to_str(),\n-            span: span.map(|sp| DiagnosticSpan::from_span(sp, je)),\n+            spans: msp.map_or(vec![], |msp| DiagnosticSpan::from_multispan(msp, je)),\n             children: vec![],\n         }\n     }\n@@ -134,7 +134,7 @@ impl<'a> Diagnostic<'a> {\n             message: msg,\n             code: None,\n             level: level.to_str(),\n-            span: Some(DiagnosticSpan::from_render_span(span, je)),\n+            spans: DiagnosticSpan::from_render_span(span, je),\n             children: vec![],\n         }\n     }\n@@ -146,7 +146,7 @@ impl<'a> Diagnostic<'a> {\n             message: &db.message,\n             code: DiagnosticCode::map_opt_string(db.code.clone(), je),\n             level: db.level.to_str(),\n-            span: db.span.map(|sp| DiagnosticSpan::from_span(sp, je)),\n+            spans: db.span.as_ref().map_or(vec![], |sp| DiagnosticSpan::from_multispan(sp, je)),\n             children: db.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n             }).collect(),\n@@ -158,59 +158,67 @@ impl<'a> Diagnostic<'a> {\n             message: &db.message,\n             code: None,\n             level: db.level.to_str(),\n-            span: db.render_span.as_ref()\n-                    .map(|sp| DiagnosticSpan::from_render_span(sp, je))\n-                    .or_else(|| db.span.map(|sp| DiagnosticSpan::from_span(sp, je))),\n+            spans: db.render_span.as_ref()\n+                     .map(|sp| DiagnosticSpan::from_render_span(sp, je))\n+                     .or_else(|| db.span.as_ref().map(|s| DiagnosticSpan::from_multispan(s, je)))\n+                     .unwrap_or(vec![]),\n             children: vec![],\n         }\n     }\n }\n \n impl DiagnosticSpan {\n-    fn from_span(span: Span, je: &JsonEmitter) -> DiagnosticSpan {\n-        let start = je.cm.lookup_char_pos(span.lo);\n-        let end = je.cm.lookup_char_pos(span.hi);\n-        DiagnosticSpan {\n-            file_name: start.file.name.clone(),\n-            byte_start: span.lo.0,\n-            byte_end: span.hi.0,\n-            line_start: start.line,\n-            line_end: end.line,\n-            column_start: start.col.0 + 1,\n-            column_end: end.col.0 + 1,\n-        }\n+    fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n+        msp.spans.iter().map(|span| {\n+            let start = je.cm.lookup_char_pos(span.lo);\n+            let end = je.cm.lookup_char_pos(span.hi);\n+            DiagnosticSpan {\n+                file_name: start.file.name.clone(),\n+                byte_start: span.lo.0,\n+                byte_end: span.hi.0,\n+                line_start: start.line,\n+                line_end: end.line,\n+                column_start: start.col.0 + 1,\n+                column_end: end.col.0 + 1,\n+            }\n+        }).collect()\n     }\n \n-    fn from_render_span(span: &RenderSpan, je: &JsonEmitter) -> DiagnosticSpan {\n-        match *span {\n+    fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n+        match *rsp {\n             // FIXME(#30701) handle Suggestion properly\n-            RenderSpan::FullSpan(sp) | RenderSpan::Suggestion(sp, _) => {\n-                DiagnosticSpan::from_span(sp, je)\n+            RenderSpan::FullSpan(ref msp) |\n+            RenderSpan::Suggestion(CodeSuggestion { ref msp, .. }) => {\n+                DiagnosticSpan::from_multispan(msp, je)\n             }\n-            RenderSpan::EndSpan(span) => {\n-                let end = je.cm.lookup_char_pos(span.hi);\n-                DiagnosticSpan {\n-                    file_name: end.file.name.clone(),\n-                    byte_start: span.lo.0,\n-                    byte_end: span.hi.0,\n-                    line_start: 0,\n-                    line_end: end.line,\n-                    column_start: 0,\n-                    column_end: end.col.0 + 1,\n-                }\n+            RenderSpan::EndSpan(ref msp) => {\n+                msp.spans.iter().map(|span| {\n+                    let end = je.cm.lookup_char_pos(span.hi);\n+                    DiagnosticSpan {\n+                        file_name: end.file.name.clone(),\n+                        byte_start: span.lo.0,\n+                        byte_end: span.hi.0,\n+                        line_start: 0,\n+                        line_end: end.line,\n+                        column_start: 0,\n+                        column_end: end.col.0 + 1,\n+                    }\n+                }).collect()\n             }\n-            RenderSpan::FileLine(span) => {\n-                let start = je.cm.lookup_char_pos(span.lo);\n-                let end = je.cm.lookup_char_pos(span.hi);\n-                DiagnosticSpan {\n-                    file_name: start.file.name.clone(),\n-                    byte_start: span.lo.0,\n-                    byte_end: span.hi.0,\n-                    line_start: start.line,\n-                    line_end: end.line,\n-                    column_start: 0,\n-                    column_end: 0,\n-                }\n+            RenderSpan::FileLine(ref msp) => {\n+                msp.spans.iter().map(|span| {\n+                    let start = je.cm.lookup_char_pos(span.lo);\n+                    let end = je.cm.lookup_char_pos(span.hi);\n+                    DiagnosticSpan {\n+                        file_name: start.file.name.clone(),\n+                        byte_start: span.lo.0,\n+                        byte_end: span.hi.0,\n+                        line_start: start.line,\n+                        line_end: end.line,\n+                        column_start: 0,\n+                        column_end: 0,\n+                    }\n+                }).collect()\n             }\n         }\n     }"}, {"sha": "9e1cb60f54f67528aa71cb67212f8ee52f017dbd", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 201, "deletions": 124, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -13,7 +13,7 @@ pub use errors::emitter::ColorConfig;\n use self::Level::*;\n use self::RenderSpan::*;\n \n-use codemap::{self, Span};\n+use codemap::{self, CodeMap, MultiSpan};\n use diagnostics;\n use errors::emitter::{Emitter, EmitterWriter};\n \n@@ -31,35 +31,112 @@ pub enum RenderSpan {\n     /// A FullSpan renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary of\n     /// the source code covered by the span.\n-    FullSpan(Span),\n+    FullSpan(MultiSpan),\n \n     /// Similar to a FullSpan, but the cited position is the end of\n     /// the span, instead of the start. Used, at least, for telling\n     /// compiletest/runtest to look at the last line of the span\n     /// (since `end_highlight_lines` displays an arrow to the end\n     /// of the span).\n-    EndSpan(Span),\n+    EndSpan(MultiSpan),\n \n     /// A suggestion renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary\n-    /// of hypothetical source code, where the `String` is spliced\n-    /// into the lines in place of the code covered by the span.\n-    Suggestion(Span, String),\n+    /// of hypothetical source code, where each `String` is spliced\n+    /// into the lines in place of the code covered by each span.\n+    Suggestion(CodeSuggestion),\n \n     /// A FileLine renders with just a line for the message prefixed\n     /// by file:linenum.\n-    FileLine(Span),\n+    FileLine(MultiSpan),\n+}\n+\n+#[derive(Clone)]\n+pub struct CodeSuggestion {\n+    msp: MultiSpan,\n+    substitutes: Vec<String>,\n }\n \n impl RenderSpan {\n-    fn span(&self) -> Span {\n+    fn span(&self) -> &MultiSpan {\n         match *self {\n-            FullSpan(s) |\n-            Suggestion(s, _) |\n-            EndSpan(s) |\n-            FileLine(s) =>\n-                s\n+            FullSpan(ref msp) |\n+            Suggestion(CodeSuggestion { ref msp, .. }) |\n+            EndSpan(ref msp) |\n+            FileLine(ref msp) =>\n+                msp\n+        }\n+    }\n+}\n+\n+impl CodeSuggestion {\n+    /// Returns the assembled code suggestion.\n+    pub fn splice_lines(&self, cm: &CodeMap) -> String {\n+        use codemap::{CharPos, Loc, Pos};\n+\n+        fn push_trailing(buf: &mut String, line_opt: Option<&str>,\n+                         lo: &Loc, hi_opt: Option<&Loc>) {\n+            let (lo, hi_opt) = (lo.col.to_usize(), hi_opt.map(|hi|hi.col.to_usize()));\n+            if let Some(line) = line_opt {\n+                if line.len() > lo {\n+                    buf.push_str(match hi_opt {\n+                        Some(hi) => &line[lo..hi],\n+                        None => &line[lo..],\n+                    });\n+                }\n+                if let None = hi_opt {\n+                    buf.push('\\n');\n+                }\n+            }\n+        }\n+        let bounds = self.msp.to_span_bounds();\n+        let lines = cm.span_to_lines(bounds).unwrap();\n+        assert!(!lines.lines.is_empty());\n+\n+        // This isn't strictly necessary, but would in all likelyhood be an error\n+        assert_eq!(self.msp.spans.len(), self.substitutes.len());\n+\n+        // To build up the result, we do this for each span:\n+        // - push the line segment trailing the previous span\n+        //   (at the beginning a \"phantom\" span pointing at the start of the line)\n+        // - push lines between the previous and current span (if any)\n+        // - if the previous and current span are not on the same line\n+        //   push the line segment leading up to the current span\n+        // - splice in the span substitution\n+        //\n+        // Finally push the trailing line segment of the last span\n+        let fm = &lines.file;\n+        let mut prev_hi = cm.lookup_char_pos(bounds.lo);\n+        prev_hi.col = CharPos::from_usize(0);\n+\n+        let mut prev_line = fm.get_line(lines.lines[0].line_index);\n+        let mut buf = String::new();\n+\n+        for (sp, substitute) in self.msp.spans.iter().zip(self.substitutes.iter()) {\n+            let cur_lo = cm.lookup_char_pos(sp.lo);\n+            if prev_hi.line == cur_lo.line {\n+                push_trailing(&mut buf, prev_line, &prev_hi, Some(&cur_lo));\n+            } else {\n+                push_trailing(&mut buf, prev_line, &prev_hi, None);\n+                // push lines between the previous and current span (if any)\n+                for idx in prev_hi.line..(cur_lo.line - 1) {\n+                    if let Some(line) = fm.get_line(idx) {\n+                        buf.push_str(line);\n+                        buf.push('\\n');\n+                    }\n+                }\n+                if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n+                    buf.push_str(&cur_line[.. cur_lo.col.to_usize()]);\n+                }\n+            }\n+            buf.push_str(substitute);\n+            prev_hi = cm.lookup_char_pos(sp.hi);\n+            prev_line = fm.get_line(prev_hi.line - 1);\n         }\n+        push_trailing(&mut buf, prev_line, &prev_hi, None);\n+        // remove trailing newline\n+        buf.pop();\n+        buf\n     }\n }\n \n@@ -106,15 +183,15 @@ pub struct DiagnosticBuilder<'a> {\n     level: Level,\n     message: String,\n     code: Option<String>,\n-    span: Option<Span>,\n+    span: Option<MultiSpan>,\n     children: Vec<SubDiagnostic>,\n }\n \n /// For example a note attached to an error.\n struct SubDiagnostic {\n     level: Level,\n     message: String,\n-    span: Option<Span>,\n+    span: Option<MultiSpan>,\n     render_span: Option<RenderSpan>,\n }\n \n@@ -150,81 +227,84 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.level == Level::Fatal\n     }\n \n-    pub fn note(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a>  {\n+    pub fn note(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n         self.sub(Level::Note, msg, None, None);\n         self\n     }\n-    pub fn span_note(&mut self ,\n-                     sp: Span,\n-                     msg: &str)\n-                     -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, Some(sp), None);\n+    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Note, msg, Some(sp.into()), None);\n         self\n     }\n-    pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a>  {\n+    pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n         self.sub(Level::Warning, msg, None, None);\n         self\n     }\n-    pub fn span_warn(&mut self,\n-                     sp: Span,\n-                     msg: &str)\n-                     -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, Some(sp), None);\n+    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Warning, msg, Some(sp.into()), None);\n         self\n     }\n-    pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a>  {\n+    pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n         self.sub(Level::Help, msg, None, None);\n         self\n     }\n-    pub fn span_help(&mut self ,\n-                     sp: Span,\n-                     msg: &str)\n-                     -> &mut DiagnosticBuilder<'a>  {\n-        self.sub(Level::Help, msg, Some(sp), None);\n+    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Help, msg, Some(sp.into()), None);\n         self\n     }\n     /// Prints out a message with a suggested edit of the code.\n     ///\n     /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion(&mut self ,\n-                           sp: Span,\n-                           msg: &str,\n-                           suggestion: String)\n-                           -> &mut DiagnosticBuilder<'a>  {\n-        self.sub(Level::Help, msg, Some(sp), Some(Suggestion(sp, suggestion)));\n+    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                               sp: S,\n+                                               msg: &str,\n+                                               suggestion: String)\n+                                               -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Help, msg, None, Some(Suggestion(CodeSuggestion {\n+            msp: sp.into(),\n+            substitutes: vec![suggestion],\n+        })));\n         self\n     }\n-    pub fn span_end_note(&mut self ,\n-                         sp: Span,\n-                         msg: &str)\n-                         -> &mut DiagnosticBuilder<'a>  {\n-        self.sub(Level::Note, msg, Some(sp), Some(EndSpan(sp)));\n+    pub fn span_end_note<S: Into<MultiSpan>>(&mut self,\n+                                             sp: S,\n+                                             msg: &str)\n+                                             -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Note, msg, None, Some(EndSpan(sp.into())));\n         self\n     }\n-    pub fn fileline_warn(&mut self ,\n-                         sp: Span,\n-                         msg: &str)\n-                         -> &mut DiagnosticBuilder<'a>  {\n-        self.sub(Level::Warning, msg, Some(sp), Some(FileLine(sp)));\n+    pub fn fileline_warn<S: Into<MultiSpan>>(&mut self,\n+                                             sp: S,\n+                                             msg: &str)\n+                                             -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Warning, msg, None, Some(FileLine(sp.into())));\n         self\n     }\n-    pub fn fileline_note(&mut self ,\n-                         sp: Span,\n-                         msg: &str)\n-                         -> &mut DiagnosticBuilder<'a>  {\n-        self.sub(Level::Note, msg, Some(sp), Some(FileLine(sp)));\n+    pub fn fileline_note<S: Into<MultiSpan>>(&mut self,\n+                                             sp: S,\n+                                             msg: &str)\n+                                             -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Note, msg, None, Some(FileLine(sp.into())));\n         self\n     }\n-    pub fn fileline_help(&mut self ,\n-                         sp: Span,\n-                         msg: &str)\n-                         -> &mut DiagnosticBuilder<'a>  {\n-        self.sub(Level::Help, msg, Some(sp), Some(FileLine(sp)));\n+    pub fn fileline_help<S: Into<MultiSpan>>(&mut self,\n+                                             sp: S,\n+                                             msg: &str)\n+                                             -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Help, msg, None, Some(FileLine(sp.into())));\n         self\n     }\n \n-    pub fn span(&mut self, sp: Span) -> &mut Self {\n-        self.span = Some(sp);\n+    pub fn span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n+        self.span = Some(sp.into());\n         self\n     }\n \n@@ -237,7 +317,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// struct_* methods on Handler.\n     fn new(emitter: &'a RefCell<Box<Emitter>>,\n            level: Level,\n-           message: &str) -> DiagnosticBuilder<'a>  {\n+           message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder {\n             emitter: emitter,\n             level: level,\n@@ -253,7 +333,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     fn sub(&mut self,\n            level: Level,\n            message: &str,\n-           span: Option<Span>,\n+           span: Option<MultiSpan>,\n            render_span: Option<RenderSpan>) {\n         let sub = SubDiagnostic {\n             level: level,\n@@ -290,7 +370,7 @@ pub struct Handler {\n     emit: RefCell<Box<Emitter>>,\n     pub can_emit_warnings: bool,\n     treat_err_as_bug: bool,\n-    delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n+    delayed_span_bug: RefCell<Option<(MultiSpan, String)>>,\n }\n \n impl Handler {\n@@ -320,22 +400,22 @@ impl Handler {\n         DiagnosticBuilder::new(&self.emit, Level::Cancelled, \"\")\n     }\n \n-    pub fn struct_span_warn<'a>(&'a self,\n-                                sp: Span,\n-                                msg: &str)\n-                                -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n+                                                    sp: S,\n+                                                    msg: &str)\n+                                                    -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n         result.span(sp);\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_span_warn_with_code<'a>(&'a self,\n-                                          sp: Span,\n-                                          msg: &str,\n-                                          code: &str)\n-                                          -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_warn_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                              sp: S,\n+                                                              msg: &str,\n+                                                              code: &str)\n+                                                              -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n         result.span(sp);\n         result.code(code.to_owned());\n@@ -351,20 +431,20 @@ impl Handler {\n         }\n         result\n     }\n-    pub fn struct_span_err<'a>(&'a self,\n-                               sp: Span,\n-                               msg: &str)\n-                               -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                                   sp: S,\n+                                                   msg: &str)\n+                                                   -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n         result.span(sp);\n         result\n     }\n-    pub fn struct_span_err_with_code<'a>(&'a self,\n-                                         sp: Span,\n-                                         msg: &str,\n-                                         code: &str)\n-                                         -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                             sp: S,\n+                                                             msg: &str,\n+                                                             code: &str)\n+                                                             -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n         result.span(sp);\n@@ -375,20 +455,20 @@ impl Handler {\n         self.bump_err_count();\n         DiagnosticBuilder::new(&self.emit, Level::Error, msg)\n     }\n-    pub fn struct_span_fatal<'a>(&'a self,\n-                                 sp: Span,\n-                                 msg: &str)\n-                                 -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n+                                                     sp: S,\n+                                                     msg: &str)\n+                                                     -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n         result.span(sp);\n         result\n     }\n-    pub fn struct_span_fatal_with_code<'a>(&'a self,\n-                                           sp: Span,\n-                                           msg: &str,\n-                                           code: &str)\n-                                           -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                               sp: S,\n+                                                               msg: &str,\n+                                                               code: &str)\n+                                                               -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n         result.span(sp);\n@@ -408,58 +488,59 @@ impl Handler {\n         err.cancel();\n     }\n \n-    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit(Some(sp), msg, Fatal);\n+        self.emit(Some(&sp.into()), msg, Fatal);\n         self.bump_err_count();\n         return FatalError;\n     }\n-    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n+    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str)\n+    -> FatalError {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit_with_code(Some(sp), msg, code, Fatal);\n+        self.emit_with_code(Some(&sp.into()), msg, code, Fatal);\n         self.bump_err_count();\n         return FatalError;\n     }\n-    pub fn span_err(&self, sp: Span, msg: &str) {\n+    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit(Some(sp), msg, Error);\n+        self.emit(Some(&sp.into()), msg, Error);\n         self.bump_err_count();\n     }\n-    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit_with_code(Some(sp), msg, code, Error);\n+        self.emit_with_code(Some(&sp.into()), msg, code, Error);\n         self.bump_err_count();\n     }\n-    pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.emit(Some(sp), msg, Warning);\n+    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+        self.emit(Some(&sp.into()), msg, Warning);\n     }\n-    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.emit_with_code(Some(sp), msg, code, Warning);\n+    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n+        self.emit_with_code(Some(&sp.into()), msg, code, Warning);\n     }\n-    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.emit(Some(sp), msg, Bug);\n+    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n+        self.emit(Some(&sp.into()), msg, Bug);\n         panic!(ExplicitBug);\n     }\n-    pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n+    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         let mut delayed = self.delayed_span_bug.borrow_mut();\n-        *delayed = Some((sp, msg.to_string()));\n+        *delayed = Some((sp.into(), msg.to_string()));\n     }\n-    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n-        self.emit(Some(sp), msg, Bug);\n+    pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+        self.emit(Some(&sp.into()), msg, Bug);\n         self.bump_err_count();\n     }\n-    pub fn span_note_without_error(&self, sp: Span, msg: &str) {\n-        self.emit.borrow_mut().emit(Some(sp), msg, None, Note);\n+    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+        self.emit.borrow_mut().emit(Some(&sp.into()), msg, None, Note);\n     }\n-    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n+    pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n     }\n     pub fn fatal(&self, msg: &str) -> FatalError {\n@@ -502,15 +583,14 @@ impl Handler {\n     pub fn has_errors(&self) -> bool {\n         self.err_count.get() > 0\n     }\n-\n     pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n             0 => {\n                 let delayed_bug = self.delayed_span_bug.borrow();\n                 match *delayed_bug {\n-                    Some((span, ref errmsg)) => {\n-                        self.span_bug(span, errmsg);\n+                    Some((ref span, ref errmsg)) => {\n+                        self.span_bug(span.clone(), errmsg);\n                     },\n                     _ => {}\n                 }\n@@ -526,27 +606,24 @@ impl Handler {\n \n         panic!(self.fatal(&s));\n     }\n-\n     pub fn emit(&self,\n-                sp: Option<Span>,\n+                msp: Option<&MultiSpan>,\n                 msg: &str,\n                 lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(sp, msg, None, lvl);\n+        self.emit.borrow_mut().emit(msp, msg, None, lvl);\n     }\n-\n     pub fn emit_with_code(&self,\n-                          sp: Option<Span>,\n+                          msp: Option<&MultiSpan>,\n                           msg: &str,\n                           code: &str,\n                           lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(sp, msg, Some(code), lvl);\n+        self.emit.borrow_mut().emit(msp, msg, Some(code), lvl);\n     }\n-\n-    pub fn custom_emit(&self, sp: RenderSpan, msg: &str, lvl: Level) {\n+    pub fn custom_emit(&self, rsp: RenderSpan, msg: &str, lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().custom_emit(sp, msg, lvl);\n+        self.emit.borrow_mut().custom_emit(&rsp, msg, lvl);\n     }\n }\n "}, {"sha": "e6701224ccb6bb331fbed5bcdf0c8df1477cef8a", "filename": "src/test/run-make/json-errors/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/142214d1f2232a4e88ff7bd99951b01f36052c61/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile?ref=142214d1f2232a4e88ff7bd99951b01f36052c61", "patch": "@@ -4,5 +4,5 @@ all:\n \tcp foo.rs $(TMPDIR)\n \tcd $(TMPDIR)\n \t-$(RUSTC) -Z unstable-options --error-format=json foo.rs 2>foo.log\n-\tgrep -q '{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\\\nAn unresolved name was used. Example of erroneous codes.*\"},\"level\":\"error\",\"span\":{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19},\"children\":\\[\\]}' foo.log\n-\tgrep -q '{\"message\":\".*\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\\\nYou tried.*\"},\"level\":\"error\",\"span\":{.*},\"children\":\\[{\"message\":\"the .*\",\"code\":null,\"level\":\"help\",\"span\":{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":0,\"column_end\":0},\"children\":\\[\\]},{\"message\":\"  <u8 as core::ops::Add>\",\"code\":null,\"level\":\"help\",' foo.log\n+\tgrep -q '{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\\\nAn unresolved name was used. Example of erroneous codes.*\"},\"level\":\"error\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19}\\],\"children\":\\[\\]}' foo.log\n+\tgrep -q '{\"message\":\".*\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\\\nYou tried.*\"},\"level\":\"error\",\"spans\":\\[{.*}\\],\"children\":\\[{\"message\":\"the .*\",\"code\":null,\"level\":\"help\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":0,\"column_end\":0}\\],\"children\":\\[\\]},{\"message\":\"  <u8 as core::ops::Add>\",\"code\":null,\"level\":\"help\",' foo.log"}]}