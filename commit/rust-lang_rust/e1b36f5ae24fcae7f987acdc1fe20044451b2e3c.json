{"sha": "e1b36f5ae24fcae7f987acdc1fe20044451b2e3c", "node_id": "C_kwDOAAsO6NoAKGUxYjM2ZjVhZTI0ZmNhZTdmOTg3YWNkYzFmZTIwMDQ0NDUxYjJlM2M", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-05-13T07:28:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-02T21:23:19Z"}, "message": "Use DefPathHash instead of HirId to break cycles.", "tree": {"sha": "e45da0abd535d94ee721f6c932ab25d8fbbf3c33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e45da0abd535d94ee721f6c932ab25d8fbbf3c33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b36f5ae24fcae7f987acdc1fe20044451b2e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b36f5ae24fcae7f987acdc1fe20044451b2e3c", "html_url": "https://github.com/rust-lang/rust/commit/e1b36f5ae24fcae7f987acdc1fe20044451b2e3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b36f5ae24fcae7f987acdc1fe20044451b2e3c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0677edc86e342f333d4828b0ee1ef395a4e70fe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0677edc86e342f333d4828b0ee1ef395a4e70fe5", "html_url": "https://github.com/rust-lang/rust/commit/0677edc86e342f333d4828b0ee1ef395a4e70fe5"}], "stats": {"total": 22, "additions": 8, "deletions": 14}, "files": [{"sha": "1f8f1fa83716737e60bfabcb7915560b4b017b8b", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1b36f5ae24fcae7f987acdc1fe20044451b2e3c/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b36f5ae24fcae7f987acdc1fe20044451b2e3c/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=e1b36f5ae24fcae7f987acdc1fe20044451b2e3c", "patch": "@@ -1,7 +1,6 @@\n //! Inlining pass for MIR functions\n \n use rustc_attr::InlineAttr;\n-use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -88,7 +87,6 @@ fn inline<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n         tcx,\n         param_env,\n         codegen_fn_attrs: tcx.codegen_fn_attrs(def_id),\n-        hir_id,\n         history: Vec::new(),\n         changed: false,\n     };\n@@ -102,8 +100,6 @@ struct Inliner<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     /// Caller codegen attributes.\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n-    /// Caller HirID.\n-    hir_id: hir::HirId,\n     /// Stack of inlined Instances.\n     history: Vec<ty::Instance<'tcx>>,\n     /// Indicates that the caller body has been modified.\n@@ -179,7 +175,8 @@ impl<'tcx> Inliner<'tcx> {\n         caller_body: &Body<'tcx>,\n         callee: &Instance<'tcx>,\n     ) -> Result<(), &'static str> {\n-        if callee.def_id() == caller_body.source.def_id() {\n+        let caller_def_id = caller_body.source.def_id();\n+        if callee.def_id() == caller_def_id {\n             return Err(\"self-recursion\");\n         }\n \n@@ -215,22 +212,19 @@ impl<'tcx> Inliner<'tcx> {\n         }\n \n         if let Some(callee_def_id) = callee.def_id().as_local() {\n-            let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n             // Avoid a cycle here by only using `instance_mir` only if we have\n-            // a lower `HirId` than the callee. This ensures that the callee will\n-            // not inline us. This trick only works without incremental compilation.\n-            // So don't do it if that is enabled.\n-            if !self.tcx.dep_graph.is_fully_enabled() && self.hir_id.index() < callee_hir_id.index()\n+            // a lower `DefPathHash` than the callee. This ensures that the callee will\n+            // not inline us. This trick even works with incremental compilation,\n+            // since `DefPathHash` is stable.\n+            if self.tcx.def_path_hash(caller_def_id)\n+                < self.tcx.def_path_hash(callee_def_id.to_def_id())\n             {\n                 return Ok(());\n             }\n \n             // If we know for sure that the function we're calling will itself try to\n             // call us, then we avoid inlining that function.\n-            if self\n-                .tcx\n-                .mir_callgraph_reachable((*callee, caller_body.source.def_id().expect_local()))\n-            {\n+            if self.tcx.mir_callgraph_reachable((*callee, caller_def_id.expect_local())) {\n                 return Err(\"caller might be reachable from callee (query cycle avoidance)\");\n             }\n "}]}