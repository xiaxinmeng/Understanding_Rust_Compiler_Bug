{"sha": "2a1aa9fb5356dc43e649b86622bd12463722d2af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMWFhOWZiNTM1NmRjNDNlNjQ5Yjg2NjIyYmQxMjQ2MzcyMmQyYWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-14T20:39:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-15T20:37:50Z"}, "message": "Check whether loans conflict with old loans or with themselves.\n\nAlong the way, convert from dvec-of-dvec representation to track loans in scope\nto just a single flattened list.  It's more convenient.\n\nFixes #3765. r+ pcwalton.", "tree": {"sha": "9a1a6c0263b6e5e0e600ccef00079ddc43927f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a1a6c0263b6e5e0e600ccef00079ddc43927f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a1aa9fb5356dc43e649b86622bd12463722d2af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1aa9fb5356dc43e649b86622bd12463722d2af", "html_url": "https://github.com/rust-lang/rust/commit/2a1aa9fb5356dc43e649b86622bd12463722d2af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a1aa9fb5356dc43e649b86622bd12463722d2af/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0643466f85a765bbd0d7ec14a96e0980795aebec", "url": "https://api.github.com/repos/rust-lang/rust/commits/0643466f85a765bbd0d7ec14a96e0980795aebec", "html_url": "https://github.com/rust-lang/rust/commit/0643466f85a765bbd0d7ec14a96e0980795aebec"}], "stats": {"total": 259, "additions": 165, "deletions": 94}, "files": [{"sha": "02fd2998f4dba79138abee2378f109b7eb5ae779", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=2a1aa9fb5356dc43e649b86622bd12463722d2af", "patch": "@@ -383,7 +383,7 @@ impl bckerr : cmp::Eq {\n type bckres<T> = Result<T, bckerr>;\n \n /// a complete record of a loan that was granted\n-type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n+struct Loan {lp: @loan_path, cmt: cmt, mutbl: ast::mutability}\n \n /// maps computed by `gather_loans` that are then used by `check_loans`\n ///\n@@ -392,7 +392,7 @@ type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n type req_maps = {\n-    req_loan_map: HashMap<ast::node_id, @DVec<@DVec<loan>>>,\n+    req_loan_map: HashMap<ast::node_id, @DVec<Loan>>,\n     pure_map: HashMap<ast::node_id, bckerr>\n };\n \n@@ -582,6 +582,11 @@ impl borrowck_ctxt {\n                                            method_map: self.method_map};\n         mc.mut_to_str(mutbl)\n     }\n+\n+    fn loan_to_repr(loan: &Loan) -> ~str {\n+        fmt!(\"Loan(lp=%?, cmt=%s, mutbl=%?)\",\n+             loan.lp, self.cmt_to_repr(loan.cmt), loan.mutbl)\n+    }\n }\n \n // The inherent mutability of a component is its default mutability"}, {"sha": "7f95d44fd3b85f85ae10ca4e0fbd01121cb395a4", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 52, "deletions": 33, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=2a1aa9fb5356dc43e649b86622bd12463722d2af", "patch": "@@ -131,18 +131,15 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn walk_loans(scope_id: ast::node_id,\n-                  f: fn(v: &loan) -> bool) {\n+    fn walk_loans(scope_id: ast::node_id, f: fn(v: &Loan) -> bool) {\n         let mut scope_id = scope_id;\n         let region_map = self.tcx().region_map;\n         let req_loan_map = self.req_maps.req_loan_map;\n \n         loop {\n-            for req_loan_map.find(scope_id).each |loanss| {\n-                for loanss.each |loans| {\n-                    for loans.each |loan| {\n-                        if !f(loan) { return; }\n-                    }\n+            for req_loan_map.find(scope_id).each |loans| {\n+                for loans.each |loan| {\n+                    if !f(loan) { return; }\n                 }\n             }\n \n@@ -155,7 +152,7 @@ impl check_loan_ctxt {\n \n     fn walk_loans_of(scope_id: ast::node_id,\n                      lp: @loan_path,\n-                     f: fn(v: &loan) -> bool) {\n+                     f: fn(v: &Loan) -> bool) {\n         for self.walk_loans(scope_id) |loan| {\n             if loan.lp == lp {\n                 if !f(loan) { return; }\n@@ -256,36 +253,58 @@ impl check_loan_ctxt {\n     }\n \n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n-        let new_loanss = match self.req_maps.req_loan_map.find(scope_id) {\n+        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n+\n+        let new_loans = match self.req_maps.req_loan_map.find(scope_id) {\n             None => return,\n-            Some(loanss) => loanss\n+            Some(loans) => loans\n         };\n \n+        debug!(\"new_loans has length %?\", new_loans.len());\n+\n         let par_scope_id = self.tcx().region_map.get(scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n-            for new_loanss.each |new_loans| {\n-                for new_loans.each |new_loan| {\n-                    if old_loan.lp != new_loan.lp { loop; }\n-                    match (old_loan.mutbl, new_loan.mutbl) {\n-                      (m_const, _) | (_, m_const) |\n-                      (m_mutbl, m_mutbl) | (m_imm, m_imm) => {\n-                        /*ok*/\n-                      }\n-\n-                      (m_mutbl, m_imm) | (m_imm, m_mutbl) => {\n-                        self.bccx.span_err(\n-                            new_loan.cmt.span,\n-                            fmt!(\"loan of %s as %s \\\n-                                  conflicts with prior loan\",\n-                                 self.bccx.cmt_to_str(new_loan.cmt),\n-                                 self.bccx.mut_to_str(new_loan.mutbl)));\n-                        self.bccx.span_note(\n-                            old_loan.cmt.span,\n-                            fmt!(\"prior loan as %s granted here\",\n-                                 self.bccx.mut_to_str(old_loan.mutbl)));\n-                      }\n-                    }\n-                }\n+            debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n+\n+            for new_loans.each |new_loan| {\n+                self.report_error_if_loans_conflict(old_loan, new_loan);\n+            }\n+        }\n+\n+        let len = new_loans.len();\n+        for uint::range(0, len) |i| {\n+            let loan_i = new_loans[i];\n+            for uint::range(i+1, len) |j| {\n+                let loan_j = new_loans[j];\n+                self.report_error_if_loans_conflict(&loan_i, &loan_j);\n+            }\n+        }\n+    }\n+\n+    fn report_error_if_loans_conflict(&self,\n+                                      old_loan: &Loan,\n+                                      new_loan: &Loan) {\n+        if old_loan.lp != new_loan.lp {\n+            return;\n+        }\n+\n+        match (old_loan.mutbl, new_loan.mutbl) {\n+            (m_const, _) | (_, m_const) |\n+            (m_mutbl, m_mutbl) | (m_imm, m_imm) => {\n+                /*ok*/\n+            }\n+\n+            (m_mutbl, m_imm) | (m_imm, m_mutbl) => {\n+                self.bccx.span_err(\n+                    new_loan.cmt.span,\n+                    fmt!(\"loan of %s as %s \\\n+                          conflicts with prior loan\",\n+                         self.bccx.cmt_to_str(new_loan.cmt),\n+                         self.bccx.mut_to_str(new_loan.mutbl)));\n+                self.bccx.span_note(\n+                    old_loan.cmt.span,\n+                    fmt!(\"prior loan as %s granted here\",\n+                         self.bccx.mut_to_str(old_loan.mutbl)));\n             }\n         }\n     }"}, {"sha": "e8d11fd1708f9001df7b3875e1f38d2ec2efa564", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2a1aa9fb5356dc43e649b86622bd12463722d2af", "patch": "@@ -213,9 +213,10 @@ fn req_loans_in_expr(ex: @ast::expr,\n }\n \n impl gather_loan_ctxt {\n-    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn guarantee_adjustments(expr: @ast::expr,\n+    fn guarantee_adjustments(&self,\n+                             expr: @ast::expr,\n                              adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n                expr_repr(self.tcx(), expr), adjustment);\n@@ -256,7 +257,8 @@ impl gather_loan_ctxt {\n     // out loans, which will be added to the `req_loan_map`.  This can\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n-    fn guarantee_valid(cmt: cmt,\n+    fn guarantee_valid(&self,\n+                       cmt: cmt,\n                        req_mutbl: ast::mutability,\n                        scope_r: ty::region) {\n \n@@ -280,35 +282,12 @@ impl gather_loan_ctxt {\n           // it within that scope, the loan will be detected and an\n           // error will be reported.\n           Some(_) => {\n-            match self.bccx.loan(cmt, scope_r, req_mutbl) {\n-              Err(e) => { self.bccx.report(e); }\n-              Ok(loans) if loans.len() == 0 => {}\n-              Ok(loans) => {\n-                match scope_r {\n-                  ty::re_scope(scope_id) => {\n-                    self.add_loans(scope_id, loans);\n-\n-                    if req_mutbl == m_imm && cmt.mutbl != m_imm {\n-                        self.bccx.loaned_paths_imm += 1;\n-\n-                        if self.tcx().sess.borrowck_note_loan() {\n-                            self.bccx.span_note(\n-                                cmt.span,\n-                                fmt!(\"immutable loan required\"));\n-                        }\n-                    } else {\n-                        self.bccx.loaned_paths_same += 1;\n-                    }\n+              match self.bccx.loan(cmt, scope_r, req_mutbl) {\n+                  Err(e) => { self.bccx.report(e); }\n+                  Ok(move loans) => {\n+                      self.add_loans(cmt, req_mutbl, scope_r, move loans);\n                   }\n-                  _ => {\n-                    self.bccx.tcx.sess.span_bug(\n-                        cmt.span,\n-                        fmt!(\"loans required but scope is scope_region is %s\",\n-                             region_to_str(self.tcx(), scope_r)));\n-                  }\n-                }\n               }\n-            }\n           }\n \n           // The path is not loanable: in that case, we must try and\n@@ -385,7 +364,8 @@ impl gather_loan_ctxt {\n     // has type `@mut{f:int}`, this check might fail because `&x.f`\n     // reqires an immutable pointer, but `f` lives in (aliased)\n     // mutable memory.\n-    fn check_mutbl(req_mutbl: ast::mutability,\n+    fn check_mutbl(&self,\n+                   req_mutbl: ast::mutability,\n                    cmt: cmt) -> bckres<preserve_condition> {\n         debug!(\"check_mutbl(req_mutbl=%?, cmt.mutbl=%?)\",\n                req_mutbl, cmt.mutbl);\n@@ -407,21 +387,58 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn add_loans(scope_id: ast::node_id, loans: @DVec<loan>) {\n+    fn add_loans(&self,\n+                 cmt: cmt,\n+                 req_mutbl: ast::mutability,\n+                 scope_r: ty::region,\n+                 +loans: ~[Loan]) {\n+        if loans.len() == 0 {\n+            return;\n+        }\n+\n+        let scope_id = match scope_r {\n+            ty::re_scope(scope_id) => scope_id,\n+            _ => {\n+                self.bccx.tcx.sess.span_bug(\n+                    cmt.span,\n+                    fmt!(\"loans required but scope is scope_region is %s\",\n+                         region_to_str(self.tcx(), scope_r)));\n+            }\n+        };\n+\n+        self.add_loans_to_scope_id(scope_id, move loans);\n+\n+        if req_mutbl == m_imm && cmt.mutbl != m_imm {\n+            self.bccx.loaned_paths_imm += 1;\n+\n+            if self.tcx().sess.borrowck_note_loan() {\n+                self.bccx.span_note(\n+                    cmt.span,\n+                    fmt!(\"immutable loan required\"));\n+            }\n+        } else {\n+            self.bccx.loaned_paths_same += 1;\n+        }\n+    }\n+\n+    fn add_loans_to_scope_id(&self, scope_id: ast::node_id, +loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?\", loans.len(), scope_id);\n         match self.req_maps.req_loan_map.find(scope_id) {\n-            Some(l) => {\n-                l.push(loans);\n+            Some(req_loans) => {\n+                req_loans.push_all(loans);\n             }\n             None => {\n-                self.req_maps.req_loan_map.insert(\n-                    scope_id, @dvec::from_vec(~[loans]));\n+                let dvec = @dvec::from_vec(move loans);\n+                self.req_maps.req_loan_map.insert(scope_id, dvec);\n             }\n         }\n     }\n \n-    fn gather_pat(discr_cmt: cmt, root_pat: @ast::pat,\n-                  arm_id: ast::node_id, alt_id: ast::node_id) {\n+    fn gather_pat(&self,\n+                  discr_cmt: cmt,\n+                  root_pat: @ast::pat,\n+                  arm_id: ast::node_id,\n+                  alt_id: ast::node_id) {\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if !self.pat_is_variant(pat) => {\n@@ -475,7 +492,7 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn pat_is_variant(pat: @ast::pat) -> bool {\n+    fn pat_is_variant(&self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_variant(self.bccx.tcx.def_map, pat)\n     }\n }"}, {"sha": "5d3ccc392139e7e83e336baa97244460440c8239", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=2a1aa9fb5356dc43e649b86622bd12463722d2af", "patch": "@@ -8,35 +8,37 @@ use result::{Result, Ok, Err};\n impl borrowck_ctxt {\n     fn loan(cmt: cmt,\n             scope_region: ty::region,\n-            mutbl: ast::mutability) -> bckres<@DVec<loan>> {\n-        let lc = loan_ctxt_(@{bccx: self,\n-                              scope_region: scope_region,\n-                              loans: @DVec()});\n+            mutbl: ast::mutability) -> bckres<~[Loan]> {\n+        let lc = LoanContext {\n+            bccx: self,\n+            scope_region: scope_region,\n+            loans: ~[]\n+        };\n         match lc.loan(cmt, mutbl) {\n-          Ok(()) => {Ok(lc.loans)}\n-          Err(e) => {Err(e)}\n+          Err(e) => Err(e),\n+          Ok(()) => {\n+              let LoanContext {loans, _} = move lc;\n+              Ok(loans)\n+          }\n         }\n     }\n }\n \n-type loan_ctxt_ = {\n+struct LoanContext {\n     bccx: borrowck_ctxt,\n \n     // the region scope for which we must preserve the memory\n     scope_region: ty::region,\n \n     // accumulated list of loans that will be required\n-    loans: @DVec<loan>\n-};\n-\n-enum loan_ctxt {\n-    loan_ctxt_(@loan_ctxt_)\n+    mut loans: ~[Loan]\n }\n \n-impl loan_ctxt {\n-    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+impl LoanContext {\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn issue_loan(cmt: cmt,\n+    fn issue_loan(&self,\n+                  cmt: cmt,\n                   scope_ub: ty::region,\n                   req_mutbl: ast::mutability) -> bckres<()> {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n@@ -57,12 +59,13 @@ impl loan_ctxt {\n                 }\n             }\n \n-            (*self.loans).push({\n+            self.loans.push(Loan {\n                 // Note: cmt.lp must be Some(_) because otherwise this\n                 // loan process does not apply at all.\n                 lp: cmt.lp.get(),\n                 cmt: cmt,\n-                mutbl: req_mutbl});\n+                mutbl: req_mutbl\n+            });\n             return Ok(());\n         } else {\n             // The loan being requested lives longer than the data\n@@ -73,7 +76,7 @@ impl loan_ctxt {\n         }\n     }\n \n-    fn loan(cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n+    fn loan(&self, cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n         debug!(\"loan(%s, %s)\",\n                self.bccx.cmt_to_repr(cmt),\n                self.bccx.mut_to_str(req_mutbl));\n@@ -144,7 +147,8 @@ impl loan_ctxt {\n     // A \"stable component\" is one where assigning the base of the\n     // component cannot cause the component itself to change types.\n     // Example: record fields.\n-    fn loan_stable_comp(cmt: cmt,\n+    fn loan_stable_comp(&self,\n+                        cmt: cmt,\n                         cmt_base: cmt,\n                         req_mutbl: ast::mutability) -> bckres<()> {\n         let base_mutbl = match req_mutbl {\n@@ -162,7 +166,8 @@ impl loan_ctxt {\n     // An \"unstable deref\" means a deref of a ptr/comp where, if the\n     // base of the deref is assigned to, pointers into the result of the\n     // deref would be invalidated. Examples: interior of variants, uniques.\n-    fn loan_unstable_deref(cmt: cmt,\n+    fn loan_unstable_deref(&self,\n+                           cmt: cmt,\n                            cmt_base: cmt,\n                            req_mutbl: ast::mutability) -> bckres<()> {\n         // Variant components: the base must be immutable, because"}, {"sha": "54048ed2fd8cbb768884c0059a27fc43efbf691f", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1aa9fb5356dc43e649b86622bd12463722d2af/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=2a1aa9fb5356dc43e649b86622bd12463722d2af", "patch": "@@ -0,0 +1,25 @@\n+use core::either::{Either, Left, Right};\n+\n+    fn f(x: &mut Either<int,float>, y: &Either<int,float>) -> int {\n+        match *y {\n+            Left(ref z) => {\n+                *x = Right(1.0);\n+                *z\n+            }\n+            _ => fail\n+        }\n+    }\n+\n+    fn g() {\n+        let mut x: Either<int,float> = Left(3);\n+        io::println(f(&mut x, &x).to_str()); //~ ERROR conflicts with prior loan\n+    }\n+\n+    fn h() {\n+        let mut x: Either<int,float> = Left(3);\n+        let y: &Either<int, float> = &x;\n+        let z: &mut Either<int, float> = &mut x; //~ ERROR conflicts with prior loan\n+        *z = *y;\n+    } \n+\n+    fn main() {}"}]}