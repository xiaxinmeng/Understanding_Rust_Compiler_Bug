{"sha": "9f87362308613a71bca62f7e42e32bd1c9500f04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmODczNjIzMDg2MTNhNzFiY2E2MmY3ZTQyZTMyYmQxYzk1MDBmMDQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T01:15:54Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T01:15:54Z"}, "message": "Rollup merge of #24631 - steveklabnik:unsafe_guide, r=alexcrichton\n\nMany unsafe features are now in the unstable section, so this section is\r\nreally just about raw pointers now. That also makes sense for its place\r\nin the TOC.\r\n\r\nThis addresses part of #12905.", "tree": {"sha": "fe4e9aef44a5137e3bad7a181f4439a4b4881cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe4e9aef44a5137e3bad7a181f4439a4b4881cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f87362308613a71bca62f7e42e32bd1c9500f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f87362308613a71bca62f7e42e32bd1c9500f04", "html_url": "https://github.com/rust-lang/rust/commit/9f87362308613a71bca62f7e42e32bd1c9500f04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f87362308613a71bca62f7e42e32bd1c9500f04/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05ee6f07099416d657f485b6a69fd2fced8df1a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/05ee6f07099416d657f485b6a69fd2fced8df1a9", "html_url": "https://github.com/rust-lang/rust/commit/05ee6f07099416d657f485b6a69fd2fced8df1a9"}, {"sha": "1150fb0f880fbff8f10b9677033334981c7275fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1150fb0f880fbff8f10b9677033334981c7275fe", "html_url": "https://github.com/rust-lang/rust/commit/1150fb0f880fbff8f10b9677033334981c7275fe"}], "stats": {"total": 225, "additions": 124, "deletions": 101}, "files": [{"sha": "a179f8fa55e5eca66854a4985ecfddeb592ba4c2", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f87362308613a71bca62f7e42e32bd1c9500f04/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f87362308613a71bca62f7e42e32bd1c9500f04/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=9f87362308613a71bca62f7e42e32bd1c9500f04", "patch": "@@ -54,7 +54,7 @@\n     * [Unsized Types](unsized-types.md)\n     * [Deref coercions](deref-coercions.md)\n     * [Macros](macros.md)\n-    * [`unsafe` Code](unsafe-code.md)\n+    * [Raw Pointers](raw-pointers.md)\n * [Nightly Rust](nightly-rust.md)\n     * [Compiler Plugins](compiler-plugins.md)\n     * [Inline Assembly](inline-assembly.md)"}, {"sha": "ab6ff18501ed57253ae562890bc27c420300256f", "filename": "src/doc/trpl/raw-pointers.md", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9f87362308613a71bca62f7e42e32bd1c9500f04/src%2Fdoc%2Ftrpl%2Fraw-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f87362308613a71bca62f7e42e32bd1c9500f04/src%2Fdoc%2Ftrpl%2Fraw-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fraw-pointers.md?ref=9f87362308613a71bca62f7e42e32bd1c9500f04", "patch": "@@ -0,0 +1,122 @@\n+% Raw Pointers\n+\n+Rust has a number of different smart pointer types in its standard library, but\n+there are two types that are extra-special. Much of Rust\u2019s safety comes from\n+compile-time checks, but raw pointers don\u2019t have such guarantees, and are\n+[unsafe][unsafe] to use.\n+\n+`*const T` and `*mut T` are called \u2018raw pointers\u2019 in Rust. Sometimes, when\n+writing certain kinds of libraries, you\u2019ll need to get around Rust\u2019s safety\n+guarantees for some reason. In this case, you can use raw pointers to implement\n+your library, while exposing a safe interface for your users. For example, `*`\n+pointers are allowed to alias, allowing them to be used to write\n+shared-ownership types, and even thread-safe shared memory types (the `Rc<T>`\n+and `Arc<T>` types are both implemented entirely in Rust).\n+\n+Here are some things to remember about raw pointers that are different than\n+other pointer types. They:\n+\n+- are not guaranteed to point to valid memory and are not even\n+  guaranteed to be non-null (unlike both `Box` and `&`);\n+- do not have any automatic clean-up, unlike `Box`, and so require\n+  manual resource management;\n+- are plain-old-data, that is, they don't move ownership, again unlike\n+  `Box`, hence the Rust compiler cannot protect against bugs like\n+  use-after-free;\n+- lack any form of lifetimes, unlike `&`, and so the compiler cannot\n+  reason about dangling pointers; and\n+- have no guarantees about aliasing or mutability other than mutation\n+  not being allowed directly through a `*const T`.\n+\n+# Basics\n+\n+Creating a raw pointer is perfectly safe:\n+\n+```rust\n+let x = 5;\n+let raw = &x as *const i32;\n+\n+let mut y = 10;\n+let raw_mut = &mut y as *mut i32;\n+```\n+\n+However, dereferencing one is not. This won\u2019t work:\n+\n+```rust,ignore\n+let x = 5;\n+let raw = &x as *const i32;\n+\n+println!(\"raw points at {}\", *raw);\n+```\n+\n+It gives this error:\n+\n+```text\n+error: dereference of unsafe pointer requires unsafe function or block [E0133]\n+     println!(\"raw points at{}\", *raw);\n+                                 ^~~~\n+```\n+\n+When you dereference a raw pointer, you\u2019re taking responsibility that it\u2019s not\n+pointing somewhere that would be incorrect. As such, you need `unsafe`:\n+\n+```rust\n+let x = 5;\n+let raw = &x as *const i32;\n+\n+let points_at = unsafe { *raw };\n+\n+println!(\"raw points at {}\", points_at);\n+```\n+\n+For more operations on raw pointers, see [their API documentation][rawapi].\n+\n+[unsafe]: unsafe.html\n+[rawapi]: ../std/primitive.pointer.html\n+\n+# FFI\n+\n+Raw pointers are useful for FFI: Rust\u2019s `*const T` and `*mut T` are similar to\n+C\u2019s `const T*` and `T*`, respectfully. For more about this use, consult the\n+[FFI chapter][ffi].\n+\n+[ffi]: ffi.md\n+\n+# References and raw pointers\n+\n+At runtime, a raw pointer `*` and a reference pointing to the same piece of\n+data have an identical representation. In fact, an `&T` reference will\n+implicitly coerce to an `*const T` raw pointer in safe code and similarly for\n+the `mut` variants (both coercions can be performed explicitly with,\n+respectively, `value as *const T` and `value as *mut T`).\n+\n+Going the opposite direction, from `*const` to a reference `&`, is not safe. A\n+`&T` is always valid, and so, at a minimum, the raw pointer `*const T` has to\n+point to a valid instance of type `T`. Furthermore, the resulting pointer must\n+satisfy the aliasing and mutability laws of references. The compiler assumes\n+these properties are true for any references, no matter how they are created,\n+and so any conversion from raw pointers is asserting that they hold. The\n+programmer *must* guarantee this.\n+\n+The recommended method for the conversion is\n+\n+```rust\n+let i: u32 = 1;\n+\n+// explicit cast\n+let p_imm: *const u32 = &i as *const u32;\n+let mut m: u32 = 2;\n+\n+// implicit coercion\n+let p_mut: *mut u32 = &mut m;\n+\n+unsafe {\n+    let ref_imm: &u32 = &*p_imm;\n+    let ref_mut: &mut u32 = &mut *p_mut;\n+}\n+```\n+\n+The `&*x` dereferencing style is preferred to using a `transmute`. The latter\n+is far more powerful than necessary, and the more restricted operation is\n+harder to use incorrectly; for example, it requires that `x` is a pointer\n+(unlike `transmute`)."}, {"sha": "dd166034b541e30e4cc4b6b4bda795451abae71a", "filename": "src/doc/trpl/unsafe-code.md", "status": "modified", "additions": 1, "deletions": 100, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9f87362308613a71bca62f7e42e32bd1c9500f04/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f87362308613a71bca62f7e42e32bd1c9500f04/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe-code.md?ref=9f87362308613a71bca62f7e42e32bd1c9500f04", "patch": "@@ -1,82 +1,4 @@\n-% Unsafe Code\n-\n-# Introduction\n-\n-Rust aims to provide safe abstractions over the low-level details of\n-the CPU and operating system, but sometimes one needs to drop down and\n-write code at that level. This guide aims to provide an overview of\n-the dangers and power one gets with Rust's unsafe subset.\n-\n-Rust provides an escape hatch in the form of the `unsafe { ... }`\n-block which allows the programmer to dodge some of the compiler's\n-checks and do a wide range of operations, such as:\n-\n-- dereferencing [raw pointers](#raw-pointers)\n-- calling a function via FFI ([covered by the FFI guide](ffi.html))\n-- casting between types bitwise (`transmute`, aka \"reinterpret cast\")\n-- [inline assembly](#inline-assembly)\n-\n-Note that an `unsafe` block does not relax the rules about lifetimes\n-of `&` and the freezing of borrowed data.\n-\n-Any use of `unsafe` is the programmer saying \"I know more than you\" to\n-the compiler, and, as such, the programmer should be very sure that\n-they actually do know more about why that piece of code is valid.  In\n-general, one should try to minimize the amount of unsafe code in a\n-code base; preferably by using the bare minimum `unsafe` blocks to\n-build safe interfaces.\n-\n-> **Note**: the low-level details of the Rust language are still in\n-> flux, and there is no guarantee of stability or backwards\n-> compatibility. In particular, there may be changes that do not cause\n-> compilation errors, but do cause semantic changes (such as invoking\n-> undefined behaviour). As such, extreme care is required.\n-\n-# Pointers\n-\n-## References\n-\n-One of Rust's biggest features is memory safety.  This is achieved in\n-part via [the ownership system](ownership.html), which is how the\n-compiler can guarantee that every `&` reference is always valid, and,\n-for example, never pointing to freed memory.\n-\n-These restrictions on `&` have huge advantages. However, they also\n-constrain how we can use them. For example, `&` doesn't behave\n-identically to C's pointers, and so cannot be used for pointers in\n-foreign function interfaces (FFI). Additionally, both immutable (`&`)\n-and mutable (`&mut`) references have some aliasing and freezing\n-guarantees, required for memory safety.\n-\n-In particular, if you have an `&T` reference, then the `T` must not be\n-modified through that reference or any other reference. There are some\n-standard library types, e.g. `Cell` and `RefCell`, that provide inner\n-mutability by replacing compile time guarantees with dynamic checks at\n-runtime.\n-\n-An `&mut` reference has a different constraint: when an object has an\n-`&mut T` pointing into it, then that `&mut` reference must be the only\n-such usable path to that object in the whole program. That is, an\n-`&mut` cannot alias with any other references.\n-\n-Using `unsafe` code to incorrectly circumvent and violate these\n-restrictions is undefined behaviour. For example, the following\n-creates two aliasing `&mut` pointers, and is invalid.\n-\n-```\n-use std::mem;\n-let mut x: u8 = 1;\n-\n-let ref_1: &mut u8 = &mut x;\n-let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n-\n-// oops, ref_1 and ref_2 point to the same piece of data (x) and are\n-// both usable\n-*ref_1 = 10;\n-*ref_2 = 20;\n-```\n-\n-## Raw pointers\n+% Raw Pointers\n \n Rust offers two additional pointer types (*raw pointers*), written as\n `*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n@@ -160,24 +82,3 @@ The `&*x` dereferencing style is preferred to using a `transmute`.\n The latter is far more powerful than necessary, and the more\n restricted operation is harder to use incorrectly; for example, it\n requires that `x` is a pointer (unlike `transmute`).\n-\n-\n-\n-## Making the unsafe safe(r)\n-\n-There are various ways to expose a safe interface around some unsafe\n-code:\n-\n-- store pointers privately (i.e. not in public fields of public\n-  structs), so that you can see and control all reads and writes to\n-  the pointer in one place.\n-- use `assert!()` a lot: since you can't rely on the protection of the\n-  compiler & type-system to ensure that your `unsafe` code is correct\n-  at compile-time, use `assert!()` to verify that it is doing the\n-  right thing at run-time.\n-- implement the `Drop` for resource clean-up via a destructor, and use\n-  RAII (Resource Acquisition Is Initialization). This reduces the need\n-  for any manual memory management by users, and automatically ensures\n-  that clean-up is always run, even when the thread panics.\n-- ensure that any data stored behind a raw pointer is destroyed at the\n-  appropriate time."}]}