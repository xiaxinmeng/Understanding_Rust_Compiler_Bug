{"sha": "410f948c5f8711b951d16d6119d152cc159d9110", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMGY5NDhjNWY4NzExYjk1MWQxNmQ2MTE5ZDE1MmNjMTU5ZDkxMTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-20T14:21:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-20T14:21:13Z"}, "message": "Drop high-order combinators", "tree": {"sha": "87bd790171683ca532973795ec31759e9afbb655", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87bd790171683ca532973795ec31759e9afbb655"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/410f948c5f8711b951d16d6119d152cc159d9110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/410f948c5f8711b951d16d6119d152cc159d9110", "html_url": "https://github.com/rust-lang/rust/commit/410f948c5f8711b951d16d6119d152cc159d9110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/410f948c5f8711b951d16d6119d152cc159d9110/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c612bfa3a86675ef18b1effcc76037cb6b9fddf", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c612bfa3a86675ef18b1effcc76037cb6b9fddf", "html_url": "https://github.com/rust-lang/rust/commit/3c612bfa3a86675ef18b1effcc76037cb6b9fddf"}], "stats": {"total": 271, "additions": 135, "deletions": 136}, "files": [{"sha": "7ae48b5db6a1798c4a07ba5fc9baf935b1d2c6db", "filename": "src/parser/event_parser/grammar/items.rs", "status": "modified", "additions": 99, "deletions": 80, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/410f948c5f8711b951d16d6119d152cc159d9110/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410f948c5f8711b951d16d6119d152cc159d9110/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs?ref=410f948c5f8711b951d16d6119d152cc159d9110", "patch": "@@ -2,93 +2,90 @@ use super::*;\n \n pub(super) fn mod_contents(p: &mut Parser) {\n     attributes::inner_attributes(p);\n-    repeat(p, |p| {\n-        skip_to_first(\n-            p, item_first, mod_contents_item,\n-            \"expected item\",\n-        )\n-    });\n-}\n-\n-fn item_first(p: &Parser) -> bool {\n-    match p.current() {\n-        STRUCT_KW | FN_KW | EXTERN_KW | MOD_KW | USE_KW | POUND | PUB_KW => true,\n-        _ => false,\n+    while !p.at(EOF) {\n+        item(p);\n     }\n }\n \n-fn mod_contents_item(p: &mut Parser) {\n-    if item(p) {\n-        if p.current() == SEMI {\n-            node(p, ERROR, |p| {\n-                p.error()\n-                    .message(\"expected item, found `;`\\n\\\n-                              consider removing this semicolon\")\n-                    .emit();\n-                p.bump();\n-            })\n-        }\n-    }\n-}\n-\n-fn item(p: &mut Parser) -> bool {\n+fn item(p: &mut Parser){\n     let attrs_start = p.mark();\n     attributes::outer_attributes(p);\n     visibility(p);\n-    //    node_if(p, USE_KW, USE_ITEM, use_item)\n-    // || extern crate_fn\n-    // || node_if(p, STATIC_KW, STATIC_ITEM, static_item)\n-    // || node_if(p, CONST_KW, CONST_ITEM, const_item) or const FN!\n-    // || unsafe trait, impl\n-    // || node_if(p, FN_KW, FN_ITEM, fn_item)\n-    // || node_if(p, TYPE_KW, TYPE_ITEM, type_item)\n+    let la = p.raw_lookahead(1);\n     let item_start = p.mark();\n-    let item_parsed = node_if(p, [EXTERN_KW, CRATE_KW], EXTERN_CRATE_ITEM, extern_crate_item)\n-        || node_if(p, MOD_KW, MOD_ITEM, mod_item)\n-        || node_if(p, USE_KW, USE_ITEM, use_item)\n-        || node_if(p, STRUCT_KW, STRUCT_ITEM, struct_item)\n-        || node_if(p, FN_KW, FN_ITEM, fn_item);\n-\n+    match p.current() {\n+        EXTERN_KW if la == CRATE_KW => extern_crate_item(p),\n+        MOD_KW => mod_item(p),\n+        USE_KW => use_item(p),\n+        STRUCT_KW => struct_item(p),\n+        FN_KW => fn_item(p),\n+        err_token => {\n+            p.start(ERROR);\n+            let message = if err_token == SEMI {\n+                //TODO: if the item is incomplete, this messsage is misleading\n+                \"expected item, found `;`\\n\\\n+                consider removing this semicolon\"\n+            } else {\n+                \"expected item\"\n+            };\n+            p.error()\n+                .message(message)\n+                .emit();\n+            p.bump();\n+            p.finish();\n+            return;\n+        }\n+    };\n     p.forward_parent(attrs_start, item_start);\n-    item_parsed\n }\n \n fn struct_item(p: &mut Parser) {\n-    if !p.expect(IDENT) {\n-        return\n-    }\n-    generic_parameters(p);\n-    match p.current() {\n-        WHERE_KW => {\n-            where_clause(p);\n-            match p.current() {\n-                SEMI => {\n-                    p.bump();\n-                    return\n-                }\n-                L_CURLY => named_fields(p),\n-                _ => { //TODO: special case `(` error message\n-                    p.error()\n-                        .message(\"expected `;` or `{`\")\n-                        .emit();\n-                    return\n-                }\n-            }\n-        }\n-        SEMI => {\n-            p.bump();\n+    p.start(STRUCT_ITEM);\n+\n+    assert!(p.at(STRUCT_KW));\n+    p.bump();\n+\n+    struct_inner(p);\n+    p.finish();\n+\n+    fn struct_inner(p: &mut Parser) {\n+        if !p.expect(IDENT) {\n+            p.finish();\n             return\n         }\n-        L_CURLY => named_fields(p),\n-        L_PAREN => {\n-            tuple_fields(p);\n-            p.expect(SEMI);\n-        },\n-        _ => {\n-            p.error()\n-                .message(\"expected `;`, `{`, or `(`\")\n-                .emit();\n-            return\n+        generic_parameters(p);\n+        match p.current() {\n+            WHERE_KW => {\n+                where_clause(p);\n+                match p.current() {\n+                    SEMI => {\n+                        p.bump();\n+                        return\n+                    }\n+                    L_CURLY => named_fields(p),\n+                    _ => { //TODO: special case `(` error message\n+                        p.error()\n+                            .message(\"expected `;` or `{`\")\n+                            .emit();\n+                        return\n+                    }\n+                }\n+            }\n+            SEMI => {\n+                p.bump();\n+                return\n+            }\n+            L_CURLY => named_fields(p),\n+            L_PAREN => {\n+                tuple_fields(p);\n+                p.expect(SEMI);\n+            },\n+            _ => {\n+                p.error()\n+                    .message(\"expected `;`, `{`, or `(`\")\n+                    .emit();\n+                return\n+            }\n         }\n     }\n }\n@@ -135,26 +132,42 @@ fn where_clause(_: &mut Parser) {\n }\n \n fn extern_crate_item(p: &mut Parser) {\n+    p.start(EXTERN_CRATE_ITEM);\n+\n+    assert!(p.at(EXTERN_KW));\n+    p.bump();\n+\n+    assert!(p.at(CRATE_KW));\n+    p.bump();\n+\n     p.expect(IDENT) && alias(p) && p.expect(SEMI);\n+    p.finish();\n }\n \n fn mod_item(p: &mut Parser) {\n-    if !p.expect(IDENT) {\n-        return;\n-    }\n-    if p.eat(SEMI) {\n-        return;\n+    p.start(MOD_ITEM);\n+\n+    assert!(p.at(MOD_KW));\n+    p.bump();\n+\n+    if p.expect(IDENT) && !p.eat(SEMI) {\n+        p.curly_block(mod_contents);\n     }\n-    p.curly_block(mod_contents);\n+    p.finish()\n }\n \n pub(super) fn is_use_tree_start(kind: SyntaxKind) -> bool {\n     kind == STAR || kind == L_CURLY\n }\n \n fn use_item(p: &mut Parser) {\n+    p.start(USE_ITEM);\n+\n+    assert!(p.at(USE_KW));\n+    p.bump();\n     use_tree(p);\n     p.expect(SEMI);\n+    p.finish();\n \n     fn use_tree(p: &mut Parser) -> bool{\n         if node_if(p, STAR, USE_TREE, |_| ()) {\n@@ -210,8 +223,14 @@ fn use_item(p: &mut Parser) {\n \n \n fn fn_item(p: &mut Parser) {\n+    p.start(FN_ITEM);\n+\n+    assert!(p.at(FN_KW));\n+    p.bump();\n+\n     p.expect(IDENT) && p.expect(L_PAREN) && p.expect(R_PAREN)\n         && p.curly_block(|_| ());\n+    p.finish();\n }\n \n "}, {"sha": "0c775bb257db4d2e06d99a7304da4654f6db23a1", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 29, "deletions": 54, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/410f948c5f8711b951d16d6119d152cc159d9110/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410f948c5f8711b951d16d6119d152cc159d9110/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=410f948c5f8711b951d16d6119d152cc159d9110", "patch": "@@ -10,37 +10,39 @@ mod types;\n mod paths;\n \n pub(crate) fn file(p: &mut Parser) {\n-    node(p, FILE, |p| {\n-        p.eat(SHEBANG);\n-        items::mod_contents(p);\n-    })\n+    p.start(FILE);\n+    p.eat(SHEBANG);\n+    items::mod_contents(p);\n+    p.finish()\n }\n \n fn visibility(p: &mut Parser) {\n-    node_if(p, PUB_KW, VISIBILITY, |p| {\n-        if p.current() != L_PAREN {\n-            return\n-        }\n-        match p.raw_lookahead(1) {\n-            CRATE_KW | SELF_KW | SUPER_KW => {\n-                p.bump();\n-                p.bump();\n-            }\n-            IN_KW => {\n-                p.bump();\n-                p.bump();\n-                paths::use_path(p);\n+    if p.at(PUB_KW) {\n+        p.start(VISIBILITY);\n+        p.bump();\n+        if p.at(L_PAREN) {\n+            match p.raw_lookahead(1) {\n+                CRATE_KW | SELF_KW | SUPER_KW | IN_KW => {\n+                    p.bump();\n+                    if p.bump() == IN_KW {\n+                        paths::use_path(p);\n+                    }\n+                    p.expect(R_PAREN);\n+                }\n+                _ => ()\n             }\n-            _ => return\n         }\n-        p.expect(R_PAREN);\n-    });\n+        p.finish();\n+    }\n }\n \n fn alias(p: &mut Parser) -> bool {\n-    node_if(p, AS_KW, ALIAS, |p| {\n+    if p.at(AS_KW) {\n+        p.start(ALIAS);\n+        p.bump();\n         p.expect(IDENT);\n-    });\n+        p.finish();\n+    }\n     true //FIXME: return false if three are errors\n }\n \n@@ -92,40 +94,13 @@ fn comma_list<F: Fn(&mut Parser) -> bool>(p: &mut Parser, end: SyntaxKind, f: F)\n }\n \n \n-fn skip_to_first<C, F>(p: &mut Parser, cond: C, f: F, message: &str) -> bool\n-where\n-    C: Fn(&Parser) -> bool,\n-    F: FnOnce(&mut Parser),\n-{\n-    let mut skipped = false;\n-    loop {\n-        if cond(p) {\n-            if skipped {\n-                p.finish();\n-            }\n-            f(p);\n-            return true;\n-        }\n-        if p.current() == EOF {\n-            if skipped {\n-                p.finish();\n-            }\n-            return false;\n-        }\n-        if !skipped {\n-            p.start(ERROR);\n-            p.error()\n-                .message(message)\n-                .emit();\n-        }\n-        p.bump();\n-        skipped = true;\n+impl<'p> Parser<'p> {\n+    fn at(&self, kind: SyntaxKind) -> bool {\n+        self.current() == kind\n     }\n-}\n \n-impl<'p> Parser<'p> {\n     pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n-        if self.current() == kind {\n+        if self.at(kind) {\n             self.bump();\n             true\n         } else {\n@@ -195,4 +170,4 @@ impl<'a> Lookahead for AnyOf<'a> {\n         p.bump();\n     }\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "0ac741aa85ad2ec94ffc62d82988d9bf640c930d", "filename": "tests/data/parser/err/0001_item_recovery_in_file.txt", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/410f948c5f8711b951d16d6119d152cc159d9110/tests%2Fdata%2Fparser%2Ferr%2F0001_item_recovery_in_file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/410f948c5f8711b951d16d6119d152cc159d9110/tests%2Fdata%2Fparser%2Ferr%2F0001_item_recovery_in_file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdata%2Fparser%2Ferr%2F0001_item_recovery_in_file.txt?ref=410f948c5f8711b951d16d6119d152cc159d9110", "patch": "@@ -1,8 +1,10 @@\n FILE@[0; 21)\n-  ERROR@[0; 10)\n+  ERROR@[0; 3)\n   err: `expected item`\n     IDENT@[0; 2)\n     WHITESPACE@[2; 3)\n+  ERROR@[3; 10)\n+  err: `expected item`\n     IDENT@[3; 8)\n     WHITESPACE@[8; 10)\n   STRUCT_ITEM@[10; 21)"}, {"sha": "adc0496832d18b1e8d0920cd577c7c6f6763b1af", "filename": "tests/data/parser/err/0004_use_path_bad_segment.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/410f948c5f8711b951d16d6119d152cc159d9110/tests%2Fdata%2Fparser%2Ferr%2F0004_use_path_bad_segment.txt", "raw_url": "https://github.com/rust-lang/rust/raw/410f948c5f8711b951d16d6119d152cc159d9110/tests%2Fdata%2Fparser%2Ferr%2F0004_use_path_bad_segment.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdata%2Fparser%2Ferr%2F0004_use_path_bad_segment.txt?ref=410f948c5f8711b951d16d6119d152cc159d9110", "patch": "@@ -11,7 +11,10 @@ FILE@[0; 12)\n         PATH_SEGMENT@[9; 9)\n         err: `expected identifier`\n     err: `expected SEMI`\n-  ERROR@[9; 12)\n+  ERROR@[9; 11)\n   err: `expected item`\n     INT_NUMBER@[9; 11)\n+  ERROR@[11; 12)\n+  err: `expected item, found `;`\n+consider removing this semicolon`\n     SEMI@[11; 12)"}]}