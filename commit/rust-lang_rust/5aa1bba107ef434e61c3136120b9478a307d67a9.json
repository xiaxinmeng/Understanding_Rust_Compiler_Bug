{"sha": "5aa1bba107ef434e61c3136120b9478a307d67a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYTFiYmExMDdlZjQzNGU2MWMzMTM2MTIwYjk0NzhhMzA3ZDY3YTk=", "commit": {"author": {"name": "Craig Disselkoen", "email": "craigdissel@gmail.com", "date": "2020-05-05T20:44:43Z"}, "committer": {"name": "Craig Disselkoen", "email": "craigdissel@gmail.com", "date": "2020-05-05T23:12:56Z"}, "message": "more generic, find rustc as well", "tree": {"sha": "92fee5065cbd19409ab49f0e853f826e870ffbe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92fee5065cbd19409ab49f0e853f826e870ffbe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aa1bba107ef434e61c3136120b9478a307d67a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa1bba107ef434e61c3136120b9478a307d67a9", "html_url": "https://github.com/rust-lang/rust/commit/5aa1bba107ef434e61c3136120b9478a307d67a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aa1bba107ef434e61c3136120b9478a307d67a9/comments", "author": {"login": "cdisselkoen", "id": 4458638, "node_id": "MDQ6VXNlcjQ0NTg2Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/4458638?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cdisselkoen", "html_url": "https://github.com/cdisselkoen", "followers_url": "https://api.github.com/users/cdisselkoen/followers", "following_url": "https://api.github.com/users/cdisselkoen/following{/other_user}", "gists_url": "https://api.github.com/users/cdisselkoen/gists{/gist_id}", "starred_url": "https://api.github.com/users/cdisselkoen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cdisselkoen/subscriptions", "organizations_url": "https://api.github.com/users/cdisselkoen/orgs", "repos_url": "https://api.github.com/users/cdisselkoen/repos", "events_url": "https://api.github.com/users/cdisselkoen/events{/privacy}", "received_events_url": "https://api.github.com/users/cdisselkoen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cdisselkoen", "id": 4458638, "node_id": "MDQ6VXNlcjQ0NTg2Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/4458638?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cdisselkoen", "html_url": "https://github.com/cdisselkoen", "followers_url": "https://api.github.com/users/cdisselkoen/followers", "following_url": "https://api.github.com/users/cdisselkoen/following{/other_user}", "gists_url": "https://api.github.com/users/cdisselkoen/gists{/gist_id}", "starred_url": "https://api.github.com/users/cdisselkoen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cdisselkoen/subscriptions", "organizations_url": "https://api.github.com/users/cdisselkoen/orgs", "repos_url": "https://api.github.com/users/cdisselkoen/repos", "events_url": "https://api.github.com/users/cdisselkoen/events{/privacy}", "received_events_url": "https://api.github.com/users/cdisselkoen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffaef1b7aeb61984992e231d9af20f39486403ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffaef1b7aeb61984992e231d9af20f39486403ea", "html_url": "https://github.com/rust-lang/rust/commit/ffaef1b7aeb61984992e231d9af20f39486403ea"}], "stats": {"total": 125, "additions": 71, "deletions": 54}, "files": [{"sha": "c7350d1e021f900cbd978b020a5f4dc0a647a0e5", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 4, "deletions": 53, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=5aa1bba107ef434e61c3136120b9478a307d67a9", "patch": "@@ -1,14 +1,14 @@\n //! FIXME: write short doc here\n \n use std::{\n-    env,\n     ffi::OsStr,\n     ops,\n     path::{Path, PathBuf},\n     process::Command,\n };\n \n-use anyhow::{Context, Error, Result};\n+use super::find_executables::get_path_for_executable;\n+use anyhow::{Context, Result};\n use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{Arena, Idx};\n use ra_db::Edition;\n@@ -146,7 +146,7 @@ impl CargoWorkspace {\n         cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n-        meta.cargo_path(cargo_binary()?);\n+        meta.cargo_path(get_path_for_executable(\"cargo\")?);\n         meta.manifest_path(cargo_toml);\n         if cargo_features.all_features {\n             meta.features(CargoOpt::AllFeatures);\n@@ -284,7 +284,7 @@ pub fn load_extern_resources(\n     cargo_toml: &Path,\n     cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n-    let mut cmd = Command::new(cargo_binary()?);\n+    let mut cmd = Command::new(get_path_for_executable(\"cargo\")?);\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n     if cargo_features.all_features {\n         cmd.arg(\"--all-features\");\n@@ -332,52 +332,3 @@ fn is_dylib(path: &Path) -> bool {\n         Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n     }\n }\n-\n-/// Return a `String` to use for executable `cargo`.\n-///\n-/// E.g., this may just be `cargo` if that gives a valid Cargo executable; or it\n-/// may be a full path to a valid Cargo.\n-fn cargo_binary() -> Result<String> {\n-    // The current implementation checks three places for a `cargo` to use:\n-    // 1) $CARGO environment variable (erroring if this is set but not a usable Cargo)\n-    // 2) `cargo`\n-    // 3) `~/.cargo/bin/cargo`\n-    if let Ok(path) = env::var(\"CARGO\") {\n-        if is_valid_cargo(&path) {\n-            Ok(path)\n-        } else {\n-            Err(Error::msg(\"`CARGO` environment variable points to something that's not a valid Cargo executable\"))\n-        }\n-    } else {\n-        let final_path: Option<String> = if is_valid_cargo(\"cargo\") {\n-            Some(\"cargo\".to_owned())\n-        } else {\n-            if let Some(mut path) = dirs::home_dir() {\n-                path.push(\".cargo\");\n-                path.push(\"bin\");\n-                path.push(\"cargo\");\n-                if is_valid_cargo(&path) {\n-                    Some(path.into_os_string().into_string().expect(\"Invalid Unicode in path\"))\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            }\n-        };\n-        final_path.ok_or(\n-            // This error message may also be caused by $PATH or $CARGO not being set correctly for VSCode,\n-            // even if they are set correctly in a terminal.\n-            // On macOS in particular, launching VSCode from terminal with `code <dirname>` causes VSCode\n-            // to inherit environment variables including $PATH and $CARGO from that terminal; but\n-            // launching VSCode from Dock does not inherit environment variables from a terminal.\n-            // For more discussion, see #3118.\n-            Error::msg(\"Failed to find `cargo` executable. Make sure `cargo` is in `$PATH`, or set `$CARGO` to point to a valid Cargo executable.\")\n-        )\n-    }\n-}\n-\n-/// Does the given `Path` point to a usable `Cargo`?\n-fn is_valid_cargo(p: impl AsRef<Path>) -> bool {\n-    Command::new(p.as_ref()).arg(\"--version\").output().is_ok()\n-}"}, {"sha": "9b020d3dafce4ffc1edb6ba935889cab4d8444dd", "filename": "crates/ra_project_model/src/find_executables.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Ffind_executables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Ffind_executables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Ffind_executables.rs?ref=5aa1bba107ef434e61c3136120b9478a307d67a9", "patch": "@@ -0,0 +1,63 @@\n+use anyhow::{Error, Result};\n+use std::env;\n+use std::path::Path;\n+use std::process::Command;\n+\n+/// Return a `String` to use for the given executable.\n+///\n+/// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n+/// gives a valid Cargo executable; or it may return a full path to a valid\n+/// Cargo.\n+pub fn get_path_for_executable(executable_name: impl AsRef<str>) -> Result<String> {\n+    // The current implementation checks three places for an executable to use:\n+    // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n+    //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n+    // 2) `<executable_name>`\n+    //      example: for cargo, this tries just `cargo`, which will succeed if `cargo` in on the $PATH\n+    // 3) `~/.cargo/bin/<executable_name>`\n+    //      example: for cargo, this tries ~/.cargo/bin/cargo\n+    //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n+    let executable_name = executable_name.as_ref();\n+    let env_var = executable_name.to_ascii_uppercase();\n+    if let Ok(path) = env::var(&env_var) {\n+        if is_valid_executable(&path) {\n+            Ok(path)\n+        } else {\n+            Err(Error::msg(format!(\"`{}` environment variable points to something that's not a valid executable\", env_var)))\n+        }\n+    } else {\n+        let final_path: Option<String> = if is_valid_executable(executable_name) {\n+            Some(executable_name.to_owned())\n+        } else {\n+            if let Some(mut path) = dirs::home_dir() {\n+                path.push(\".cargo\");\n+                path.push(\"bin\");\n+                path.push(executable_name);\n+                if is_valid_executable(&path) {\n+                    Some(path.into_os_string().into_string().expect(\"Invalid Unicode in path\"))\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            }\n+        };\n+        final_path.ok_or(\n+            // This error message may also be caused by $PATH or $CARGO/$RUSTC/etc not being set correctly\n+            // for VSCode, even if they are set correctly in a terminal.\n+            // On macOS in particular, launching VSCode from terminal with `code <dirname>` causes VSCode\n+            // to inherit environment variables including $PATH, $CARGO, $RUSTC, etc from that terminal;\n+            // but launching VSCode from Dock does not inherit environment variables from a terminal.\n+            // For more discussion, see #3118.\n+            Error::msg(format!(\"Failed to find `{}` executable. Make sure `{}` is in `$PATH`, or set `${}` to point to a valid executable.\", executable_name, executable_name, env_var))\n+        )\n+    }\n+}\n+\n+/// Does the given `Path` point to a usable executable?\n+///\n+/// (assumes the executable takes a `--version` switch and writes to stdout,\n+/// which is true for `cargo`, `rustc`, and `rustup`)\n+fn is_valid_executable(p: impl AsRef<Path>) -> bool {\n+    Command::new(p.as_ref()).arg(\"--version\").output().is_ok()\n+}"}, {"sha": "5028b6b6df9392d5ababc57559f820115f875f77", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=5aa1bba107ef434e61c3136120b9478a307d67a9", "patch": "@@ -1,6 +1,7 @@\n //! FIXME: write short doc here\n \n mod cargo_workspace;\n+mod find_executables;\n mod json_project;\n mod sysroot;\n "}, {"sha": "8d68032b2ab32785f5d343fbf05cef69d45be87a", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa1bba107ef434e61c3136120b9478a307d67a9/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=5aa1bba107ef434e61c3136120b9478a307d67a9", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use super::find_executables::get_path_for_executable;\n use anyhow::{bail, Context, Result};\n use std::{\n     env, ops,\n@@ -114,7 +115,8 @@ fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         return Ok(path.into());\n     }\n-    let rustc_output = run_command_in_cargo_dir(cargo_toml, \"rustc\", &[\"--print\", \"sysroot\"])?;\n+    let rustc = get_path_for_executable(\"rustc\")?;\n+    let rustc_output = run_command_in_cargo_dir(cargo_toml, &rustc, &[\"--print\", \"sysroot\"])?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n     let sysroot_path = Path::new(stdout.trim());\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");"}]}