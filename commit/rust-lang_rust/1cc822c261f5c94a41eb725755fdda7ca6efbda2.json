{"sha": "1cc822c261f5c94a41eb725755fdda7ca6efbda2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYzgyMmMyNjFmNWM5NGE0MWViNzI1NzU1ZmRkYTdjYTZlZmJkYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-22T04:42:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-22T04:42:20Z"}, "message": "Auto merge of #60840 - tmandry:preserve-scope-in-generator-mir, r=cramertj\n\nPreserve local scopes in generator MIR\n\nPart of #52924, depended upon by the generator layout optimization #60187.\n\nThis PR adds `StorageDead` statements in more places in generators, so we can see when non-`Drop` locals have gone out of scope and recover their storage.\n\nThe reason this is only done for generators is compiler performance. See https://github.com/rust-lang/rust/pull/60187#issuecomment-485637811 for what happens when we do this for all functions.\n\nFor `Drop` locals, we modify the `MaybeStorageLive` analysis to use `drop` to indicate that storage is no longer live for the local. Once `drop` returns or unwinds to our function, we implicitly assume that the local is `StorageDead`.\n\nInstead of using `drop`, it is possible to emit more `StorageDead` statements in the MIR for `Drop` locals so we can handle all locals the same. I am fine with doing it that way, but this was the simplest approach for my purposes. It is also likely to be more performant.\n\nr? @Zoxc (feel free to reassign)\ncc @cramertj @eddyb @RalfJung @rust-lang/wg-async-await", "tree": {"sha": "7cef8fc95f0d6c858dcebd6741f51db0b1be441e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cef8fc95f0d6c858dcebd6741f51db0b1be441e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cc822c261f5c94a41eb725755fdda7ca6efbda2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc822c261f5c94a41eb725755fdda7ca6efbda2", "html_url": "https://github.com/rust-lang/rust/commit/1cc822c261f5c94a41eb725755fdda7ca6efbda2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cc822c261f5c94a41eb725755fdda7ca6efbda2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "html_url": "https://github.com/rust-lang/rust/commit/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b"}, {"sha": "26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2", "html_url": "https://github.com/rust-lang/rust/commit/26c37d7b168781d8be0236fdcdcb502b6c2b8ee2"}], "stats": {"total": 137, "additions": 93, "deletions": 44}, "files": [{"sha": "e46c51535552164ef07f78e4a3bcedbcb7ee6d11", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1cc822c261f5c94a41eb725755fdda7ca6efbda2", "patch": "@@ -343,6 +343,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     fn_span: Span,\n     arg_count: usize,\n+    is_generator: bool,\n \n     /// The current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details.\n@@ -689,7 +690,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         return_ty,\n         return_ty_span,\n         upvar_debuginfo,\n-        upvar_mutbls);\n+        upvar_mutbls,\n+        body.is_generator);\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n@@ -759,6 +761,7 @@ fn construct_const<'a, 'gcx, 'tcx>(\n         const_ty_span,\n         vec![],\n         vec![],\n+        false,\n     );\n \n     let mut block = START_BLOCK;\n@@ -788,7 +791,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![], vec![]);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![], vec![], false);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(None)\n@@ -802,14 +805,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n            __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n-           upvar_mutbls: Vec<Mutability>)\n+           upvar_mutbls: Vec<Mutability>,\n+           is_generator: bool)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count,\n+            is_generator,\n             scopes: vec![],\n             block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),"}, {"sha": "3b11e335fb87f6019d901d259a0d22e15395db50", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 76, "deletions": 38, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1cc822c261f5c94a41eb725755fdda7ca6efbda2", "patch": "@@ -83,9 +83,10 @@ use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n use rustc::mir::*;\n-use syntax_pos::{Span};\n+use syntax_pos::{Span, DUMMY_SP};\n use rustc_data_structures::fx::FxHashMap;\n use std::collections::hash_map::Entry;\n+use std::mem;\n \n #[derive(Debug)]\n pub struct Scope<'tcx> {\n@@ -107,6 +108,8 @@ pub struct Scope<'tcx> {\n     ///  * polluting the cleanup MIR with StorageDead creates\n     ///    landing pads even though there's no actual destructors\n     ///  * freeing up stack space has no effect during unwinding\n+    /// Note that for generators we do emit StorageDeads, for the\n+    /// use of optimizations in the MIR generator transform.\n     needs_cleanup: bool,\n \n     /// set of places to drop when exiting this scope. This starts\n@@ -466,10 +469,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// This path terminates in GeneratorDrop. Returns the start of the path.\n     /// None indicates there\u2019s no cleanup to do at this point.\n     pub fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n-        if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n-            return None;\n-        }\n-\n         // Fill in the cache for unwinds\n         self.diverge_cleanup_gen(true);\n \n@@ -480,7 +479,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let result = block;\n \n         while let Some(scope) = scopes.next() {\n-            if !scope.needs_cleanup {\n+            if !scope.needs_cleanup && !self.is_generator {\n                 continue;\n             }\n \n@@ -802,7 +801,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         for scope in self.scopes[first_uncached..].iter_mut() {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n-                                         scope, target, generator_drop);\n+                                         scope, target, generator_drop, self.is_generator);\n         }\n \n         target\n@@ -900,12 +899,6 @@ fn build_scope_drops<'tcx>(\n     // drops panic (panicking while unwinding will abort, so there's no need for\n     // another set of arrows). The drops for the unwind path should have already\n     // been generated by `diverge_cleanup_gen`.\n-    //\n-    // The code in this function reads from right to left.\n-    // Storage dead drops have to be done left to right (since we can only push\n-    // to the end of a Vec). So, we find the next drop and then call\n-    // push_storage_deads which will iterate backwards through them so that\n-    // they are added in the correct order.\n \n     let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n         if let DropKind::Value { cached_block } = drop_data.kind {\n@@ -936,11 +929,6 @@ fn build_scope_drops<'tcx>(\n                 block = next;\n             }\n             DropKind::Storage => {\n-                // We do not need to emit StorageDead for generator drops\n-                if generator_drop {\n-                    continue\n-                }\n-\n                 // Drop the storage for both value and storage drops.\n                 // Only temps and vars need their storage dead.\n                 match drop_data.location {\n@@ -962,7 +950,8 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              span: Span,\n                              scope: &mut Scope<'tcx>,\n                              mut target: BasicBlock,\n-                             generator_drop: bool)\n+                             generator_drop: bool,\n+                             is_generator: bool)\n                              -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n@@ -981,41 +970,90 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         scope: source_scope\n     };\n \n-    // Next, build up the drops. Here we iterate the vector in\n+    // We keep track of StorageDead statements to prepend to our current block\n+    // and store them here, in reverse order.\n+    let mut storage_deads = vec![];\n+\n+    let mut target_built_by_us = false;\n+\n+    // Build up the drops. Here we iterate the vector in\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n     for (j, drop_data) in scope.drops.iter_mut().enumerate() {\n         debug!(\"build_diverge_scope drop_data[{}]: {:?}\", j, drop_data);\n         // Only full value drops are emitted in the diverging path,\n-        // not StorageDead.\n+        // not StorageDead, except in the case of generators.\n         //\n         // Note: This may not actually be what we desire (are we\n         // \"freeing\" stack storage as we unwind, or merely observing a\n         // frozen stack)? In particular, the intent may have been to\n         // match the behavior of clang, but on inspection eddyb says\n         // this is not what clang does.\n-        let cached_block = match drop_data.kind {\n-            DropKind::Value { ref mut cached_block } => cached_block.ref_mut(generator_drop),\n-            DropKind::Storage => continue\n-        };\n-        target = if let Some(cached_block) = *cached_block {\n-            cached_block\n-        } else {\n-            let block = cfg.start_new_cleanup_block();\n-            cfg.terminate(block, source_info(drop_data.span),\n-                          TerminatorKind::Drop {\n-                              location: drop_data.location.clone(),\n-                              target,\n-                              unwind: None\n-                          });\n-            *cached_block = Some(block);\n-            block\n+        match drop_data.kind {\n+            DropKind::Storage if is_generator => {\n+                // Only temps and vars need their storage dead.\n+                match drop_data.location {\n+                    Place::Base(PlaceBase::Local(index)) => {\n+                        storage_deads.push(Statement {\n+                            source_info: source_info(drop_data.span),\n+                            kind: StatementKind::StorageDead(index)\n+                        });\n+                    }\n+                    _ => unreachable!(),\n+                };\n+            }\n+            DropKind::Storage => {}\n+            DropKind::Value { ref mut cached_block } => {\n+                let cached_block = cached_block.ref_mut(generator_drop);\n+                target = if let Some(cached_block) = *cached_block {\n+                    storage_deads.clear();\n+                    target_built_by_us = false;\n+                    cached_block\n+                } else {\n+                    push_storage_deads(\n+                        cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n+                    let block = cfg.start_new_cleanup_block();\n+                    cfg.terminate(block, source_info(drop_data.span),\n+                                  TerminatorKind::Drop {\n+                                      location: drop_data.location.clone(),\n+                                      target,\n+                                      unwind: None\n+                                  });\n+                    *cached_block = Some(block);\n+                    target_built_by_us = true;\n+                    block\n+                };\n+            }\n         };\n     }\n-\n+    push_storage_deads(cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n     *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n+    assert!(storage_deads.is_empty());\n     debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n \n     target\n }\n+\n+fn push_storage_deads(cfg: &mut CFG<'tcx>,\n+                      target: &mut BasicBlock,\n+                      storage_deads: &mut Vec<Statement<'tcx>>,\n+                      target_built_by_us: bool,\n+                      source_scope: SourceScope) {\n+    if storage_deads.is_empty() { return; }\n+    if !target_built_by_us {\n+        // We cannot add statements to an existing block, so we create a new\n+        // block for our StorageDead statements.\n+        let block = cfg.start_new_cleanup_block();\n+        let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n+        cfg.terminate(block, source_info, TerminatorKind::Goto { target: *target });\n+        *target = block;\n+    }\n+    let statements = &mut cfg.block_data_mut(*target).statements;\n+    storage_deads.reverse();\n+    debug!(\"push_storage_deads({:?}), storage_deads={:?}, statements={:?}\",\n+           *target, storage_deads, statements);\n+    storage_deads.append(statements);\n+    mem::swap(statements, storage_deads);\n+    assert!(storage_deads.is_empty());\n+}"}, {"sha": "3bf11c57379c24fcc2dad7781c358c233cee79db", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=1cc822c261f5c94a41eb725755fdda7ca6efbda2", "patch": "@@ -43,9 +43,14 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     }\n \n     fn terminator_effect(&self,\n-                         _sets: &mut BlockSets<'_, Local>,\n-                         _loc: Location) {\n-        // Terminators have no effect\n+                         sets: &mut BlockSets<'_, Local>,\n+                         loc: Location) {\n+        match &self.mir[loc.block].terminator().kind {\n+            TerminatorKind::Drop { location, .. } => if let Some(l) = location.local() {\n+                sets.kill(l);\n+            }\n+            _ => (),\n+        }\n     }\n \n     fn propagate_call_return("}, {"sha": "30f6d0deb9187dab1899fcbf99780928c7c40656", "filename": "src/test/mir-opt/generator-drop-cleanup.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc822c261f5c94a41eb725755fdda7ca6efbda2/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs?ref=1cc822c261f5c94a41eb725755fdda7ca6efbda2", "patch": "@@ -17,6 +17,7 @@ fn main() {\n //     switchInt(move _5) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n // }\n // bb1: {\n+//     StorageDead(_3);\n //     goto -> bb5;\n // }\n // bb2: {"}]}