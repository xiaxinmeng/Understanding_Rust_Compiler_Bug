{"sha": "c765a8e7ad314651b92ff860cda0159c79dbec6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjVhOGU3YWQzMTQ2NTFiOTJmZjg2MGNkYTAxNTljNzlkYmVjNmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-01T19:24:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T18:39:23Z"}, "message": "Fixing remaining warnings and errors throughout", "tree": {"sha": "5cb922f942920dc7d6b0f3606e9cd914360b2707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cb922f942920dc7d6b0f3606e9cd914360b2707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c765a8e7ad314651b92ff860cda0159c79dbec6e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c765a8e7ad314651b92ff860cda0159c79dbec6e", "html_url": "https://github.com/rust-lang/rust/commit/c765a8e7ad314651b92ff860cda0159c79dbec6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c765a8e7ad314651b92ff860cda0159c79dbec6e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "html_url": "https://github.com/rust-lang/rust/commit/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257"}], "stats": {"total": 462, "additions": 185, "deletions": 277}, "files": [{"sha": "5b7494c06187913732e6d3339445ea1e81d66824", "filename": "src/doc/guide-conditions.md", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Fdoc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Fdoc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-conditions.md?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -47,15 +47,15 @@ An example program that does this task reads like this:\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -71,7 +71,6 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n \n     // Path takes a generic by-value, rather than by reference\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n     let mut reader = BufferedReader::new(File::open(&path));\n \n@@ -245,15 +244,15 @@ and trapping its exit status using `task::try`:\n use std::io::{BufferedReader, File};\n use std::task;\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -277,7 +276,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -347,15 +345,15 @@ but similarly clear as the version that used `fail!` in the logic where the erro\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -374,7 +372,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -415,15 +412,15 @@ and replaces bad input lines with the pair `(-1,-1)`:\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -447,7 +444,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -489,15 +485,15 @@ Changing the condition's return type from `(int,int)` to `Option<(int,int)>` wil\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{IoResult, File};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -522,7 +518,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -573,15 +568,15 @@ This can be encoded in the handler API by introducing a helper type: `enum Malfo\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -615,7 +610,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -696,15 +690,15 @@ a second condition and a helper function will suffice:\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -752,7 +746,6 @@ fn parse_int(x: &str) -> int {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));"}, {"sha": "457c0b683ac688212754ac1a7f8ce9e2a9ca2635", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -69,6 +69,7 @@ def scrub(b):\n use run_pass_stage2::*;\n use std::io;\n use std::io::Writer;\n+#[allow(warnings)]\n fn main() {\n     let mut out = io::stdout();\n \"\"\""}, {"sha": "cc5b0770d4d2056daf6d0ad7875e5093f22c692a", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -561,7 +561,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                         }\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n-                    FindClose(find_handle);\n+                    assert!(FindClose(find_handle) != 0);\n                     free(wfd_ptr as *mut c_void);\n                     Ok(paths)\n                 } else {\n@@ -683,7 +683,9 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n                                   ptr::mut_null())\n             })\n         };\n-        if handle == ptr::mut_null() { return Err(super::last_error()) }\n+        if handle as int == libc::INVALID_HANDLE_VALUE as int {\n+            return Err(super::last_error())\n+        }\n         let ret = fill_utf16_buf_and_decode(|buf, sz| {\n             unsafe {\n                 libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n@@ -694,7 +696,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n             Some(s) => Ok(Path::new(s)),\n             None => Err(super::last_error()),\n         };\n-        unsafe { libc::CloseHandle(handle) };\n+        assert!(unsafe { libc::CloseHandle(handle) } != 0);\n         return ret;\n \n     }"}, {"sha": "2a061c5f9b204fe565c8a7088dfd861adeca2973", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -149,9 +149,8 @@ impl rtio::RtioProcess for Process {\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n             match signal {\n                 io::process::PleaseExitSignal | io::process::MustDieSignal => {\n-                    libc::funcs::extra::kernel32::TerminateProcess(\n-                        cast::transmute(pid), 1);\n-                    Ok(())\n+                    let ret = libc::TerminateProcess(pid as libc::HANDLE, 1);\n+                    super::mkerr_winbool(ret)\n                 }\n                 _ => Err(io::IoError {\n                     kind: io::OtherIoError,\n@@ -255,9 +254,9 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             })\n         });\n \n-        CloseHandle(si.hStdInput);\n-        CloseHandle(si.hStdOutput);\n-        CloseHandle(si.hStdError);\n+        assert!(CloseHandle(si.hStdInput) != 0);\n+        assert!(CloseHandle(si.hStdOutput) != 0);\n+        assert!(CloseHandle(si.hStdError) != 0);\n \n         match create_err {\n             Some(err) => return Err(err),\n@@ -269,7 +268,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         // able to close it later. We don't close the process handle however\n         // because std::we want the process id to stay valid at least until the\n         // calling code closes the process handle.\n-        CloseHandle(pi.hThread);\n+        assert!(CloseHandle(pi.hThread) != 0);\n \n         Ok(SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n@@ -576,9 +575,9 @@ fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T {\n \n #[cfg(windows)]\n fn free_handle(handle: *()) {\n-    unsafe {\n-        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n-    }\n+    assert!(unsafe {\n+        libc::CloseHandle(cast::transmute(handle)) != 0\n+    })\n }\n \n #[cfg(unix)]\n@@ -629,15 +628,15 @@ fn waitpid(pid: pid_t) -> p::ProcessExit {\n             loop {\n                 let mut status = 0;\n                 if GetExitCodeProcess(process, &mut status) == FALSE {\n-                    CloseHandle(process);\n+                    assert!(CloseHandle(process) != 0);\n                     fail!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n                 }\n                 if status != STILL_ACTIVE {\n-                    CloseHandle(process);\n+                    assert!(CloseHandle(process) != 0);\n                     return p::ExitStatus(status as int);\n                 }\n                 if WaitForSingleObject(process, INFINITE) == WAIT_FAILED {\n-                    CloseHandle(process);\n+                    assert!(CloseHandle(process) != 0);\n                     fail!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n                 }\n             }"}, {"sha": "7311be46e8bd244b1dd206d763529537067b8b8c", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -126,11 +126,11 @@ mod imp {\n     }\n \n     pub fn signal(handle: HANDLE) {\n-        unsafe { SetEvent(handle); }\n+        assert!(unsafe { SetEvent(handle) != 0 });\n     }\n \n     pub fn close(handle: HANDLE) {\n-        unsafe { CloseHandle(handle); }\n+        assert!(unsafe { CloseHandle(handle) != 0 });\n     }\n \n     extern \"system\" {"}, {"sha": "6b472d2f46d59621baf84139e3fe62dc54e53cfd", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -62,8 +62,8 @@ fn helper(input: libc::HANDLE, messages: Port<Req>) {\n                         c.send(());\n                         match objs.iter().position(|&o| o == obj) {\n                             Some(i) => {\n-                                objs.remove(i);\n-                                chans.remove(i - 1);\n+                                drop(objs.remove(i));\n+                                drop(chans.remove(i - 1));\n                             }\n                             None => {}\n                         }\n@@ -83,8 +83,8 @@ fn helper(input: libc::HANDLE, messages: Port<Req>) {\n                 }\n             };\n             if remove {\n-                objs.remove(idx as uint);\n-                chans.remove(idx as uint - 1);\n+                drop(objs.remove(idx as uint));\n+                drop(chans.remove(idx as uint - 1));\n             }\n         }\n     }\n@@ -133,7 +133,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE); }\n+        let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n     fn oneshot(&mut self, msecs: u64) -> Port<()> {\n@@ -173,7 +173,7 @@ impl rtio::RtioTimer for Timer {\n impl Drop for Timer {\n     fn drop(&mut self) {\n         self.remove();\n-        unsafe { libc::CloseHandle(self.obj); }\n+        assert!(unsafe { libc::CloseHandle(self.obj) != 0 });\n     }\n }\n "}, {"sha": "c5f7d61c224a58c52c977baec351398ed2e8e9b5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -241,8 +241,8 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if ifile == \"-\" {\n-            let src =\n-                str::from_utf8_owned(io::stdin().read_to_end()).unwrap();\n+            let contents = io::stdin().read_to_end().unwrap();\n+            let src = str::from_utf8_owned(contents).unwrap();\n             (d::StrInput(src), None)\n         } else {\n             (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))"}, {"sha": "8ba98e84dfa50b85ab894df6d6e00ed92731581e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -1160,12 +1160,12 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n         let string = token::get_ident(dep.name.name);\n-        write!(out,\n-               \"{} {}-{}-{}\\n\",\n-               dep.cnum,\n-               string.get(),\n-               dep.hash,\n-               dep.vers);\n+        if_ok!(write!(out,\n+                      \"{} {}-{}-{}\\n\",\n+                      dep.cnum,\n+                      string.get(),\n+                      dep.hash,\n+                      dep.vers));\n     }\n \n     if_ok!(write!(out, \"\\n\"));"}, {"sha": "92d15fbcd672d13081152e5824278db3a8db2b76", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -48,7 +48,6 @@ impl PuritySpace {\n }\n \n impl fmt::Show for clean::Generics {\n-impl fmt::Default for clean::Generics {\n     fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) -> fmt::Result {\n         if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return Ok(()) }\n         if_ok!(f.buf.write(\"&lt;\".as_bytes()));"}, {"sha": "65696528a6fa1cab4ae0603a410dcfeb165a169d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -804,13 +804,13 @@ impl<'a> fmt::Show for Item<'a> {\n     fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match attr::find_stability(it.item.attrs.iter()) {\n             Some(ref stability) => {\n-                write!(fmt.buf,\n+                if_ok!(write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n                            Some(ref s) => (*s).clone(),\n                            None => InternedString::new(\"\"),\n-                       });\n+                       }));\n             }\n             None => {}\n         }"}, {"sha": "06737e22007e4672680ee62f502357072770fa03", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -477,36 +477,27 @@ will look like `\"\\\\{\"`.\n \n */\n \n-#[cfg(not(stage0))]\n-use prelude::*;\n-\n use cast;\n use char::Char;\n+use container::Container;\n use io::MemWriter;\n use io;\n-use str;\n+use iter::{Iterator, range};\n+use num::Signed;\n+use option::{Option,Some,None};\n use repr;\n+use result::{Ok, Err};\n+use str::StrSlice;\n+use str;\n use util;\n+use vec::ImmutableVector;\n use vec;\n \n // NOTE this is just because the `prelude::*` import above includes\n // default::Default, so the reexport doesn't work.\n #[cfg(stage0)]\n pub use Default = fmt::Show; // export required for `format!()` etc.\n \n-#[cfg(stage0)]\n-use container::Container;\n-#[cfg(stage0)]\n-use iter::{Iterator, range};\n-#[cfg(stage0)]\n-use option::{Option,Some,None};\n-#[cfg(stage0)]\n-use vec::ImmutableVector;\n-#[cfg(stage0)]\n-use str::StrSlice;\n-#[cfg(stage0)]\n-use num::Signed;\n-\n pub mod parse;\n pub mod rt;\n \n@@ -628,7 +619,7 @@ macro_rules! uniform_fn_call_workaround {\n     ($( $name: ident, $trait_: ident; )*) => {\n         $(\n             #[doc(hidden)]\n-            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) {\n+            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n                 $trait_::fmt(x, fmt)\n             }\n             )*"}, {"sha": "7690c88478fdeac333ef453f610cf093e9952a4f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -46,6 +46,7 @@ Some examples of obvious things you might want to do\n * Write a line to a file\n \n     ```rust\n+    # #[allow(unused_must_use)];\n     use std::io::File;\n \n     let mut file = File::create(&Path::new(\"message.txt\"));\n@@ -83,6 +84,7 @@ Some examples of obvious things you might want to do\n   `write_str` and `write_line` methods.\n \n     ```rust,should_fail\n+    # #[allow(unused_must_use)];\n     use std::io::net::ip::SocketAddr;\n     use std::io::net::tcp::TcpStream;\n \n@@ -188,6 +190,7 @@ be an error.\n If you wanted to handle the error though you might write:\n \n ```rust\n+# #[allow(unused_must_use)];\n use std::io::File;\n \n match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n@@ -360,7 +363,7 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n-impl fmt::Default for IoError {\n+impl fmt::Show for IoError {\n     fn fmt(err: &IoError, fmt: &mut fmt::Formatter) -> fmt::Result {\n         if_ok!(fmt.buf.write_str(err.desc));\n         match err.detail {\n@@ -515,14 +518,13 @@ pub trait Reader {\n     /// Returns any non-EOF error immediately. Previously read bytes are\n     /// discarded when an error is returned.\n     ///\n-    /// When EOF is encountered, all bytes read up to that point are returned,\n-    /// but if 0 bytes have been read then the EOF error is returned.\n+    /// When EOF is encountered, all bytes read up to that point are returned.\n     fn read_to_end(&mut self) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n         loop {\n             match self.push_bytes(&mut buf, DEFAULT_BUF_SIZE) {\n                 Ok(()) => {}\n-                Err(ref e) if buf.len() > 0 && e.kind == EndOfFile => break,\n+                Err(ref e) if e.kind == EndOfFile => break,\n                 Err(e) => return Err(e)\n             }\n         }"}, {"sha": "a0bdc193d980c85ca3df046994a50452c98bfecd", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -192,9 +192,10 @@ mod test {\n \n         match stream.read(buf) {\n             Ok(..) => fail!(),\n-            Err(ref e) if cfg!(windows) => assert_eq!(e.kind, NotConnected),\n-            Err(ref e) if cfg!(unix) => assert_eq!(e.kind, EndOfFile),\n-            Err(..) => fail!(),\n+            Err(ref e) => {\n+                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n+                        \"unknown kind: {:?}\", e.kind);\n+            }\n         }\n     })\n \n@@ -217,9 +218,10 @@ mod test {\n \n         match stream.read(buf) {\n             Ok(..) => fail!(),\n-            Err(ref e) if cfg!(windows) => assert_eq!(e.kind, NotConnected),\n-            Err(ref e) if cfg!(unix) => assert_eq!(e.kind, EndOfFile),\n-            Err(..) => fail!(),\n+            Err(ref e) => {\n+                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n+                        \"unknown kind: {:?}\", e.kind);\n+            }\n         }\n     })\n "}, {"sha": "75804c40c58061f5136f4d2580b83636ecfe8805", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -203,6 +203,7 @@ mod test {\n     fn test_io_signal_invalid_signum() {\n         use io;\n         use super::User1;\n+        use result::{Ok, Err};\n         let mut s = Listener::new();\n         let mut called = false;\n         match s.register(User1) {"}, {"sha": "541db01f1484f351b6855fb22905ae13515df288", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -1535,6 +1535,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n+        drop(chunk);\n \n         fs::unlink(&path).unwrap();\n     }"}, {"sha": "4aa4a3feab1be045e8bcc5abe52a1e0e6a833319", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -533,7 +533,7 @@ pub struct Display<'a, P> {\n }\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n-    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) -> fmt::Display {\n+    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) -> fmt::Result {\n         d.with_str(|s| f.pad(s))\n     }\n }"}, {"sha": "f1dd844fc7c68fe47a07b4ae96ba3400fd01bb31", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -588,8 +588,8 @@ impl BytesContainer for InternedString {\n }\n \n impl fmt::Show for InternedString {\n-    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) {\n-        write!(f.buf, \"{}\", obj.string.as_slice());\n+    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f.buf, \"{}\", obj.string.as_slice())\n     }\n }\n "}, {"sha": "f69522617232131fcdb5495ed731ba654d94f476", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -299,19 +299,34 @@ impl Printer {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n                 let left = self.token[self.left].clone();\n-                self.advance_left(left, self.size[self.left]);\n+                if_ok!(self.advance_left(left, self.size[self.left]));\n             }\n-            Begin(b) => {\n-                if self.scan_stack_empty {\n-                    self.left_total = 1;\n-                    self.right_total = 1;\n-                    self.left = 0u;\n-                    self.right = 0u;\n-                } else { self.advance_right(); }\n-                debug!(\"pp Begin({})/buffer ~[{},{}]\",\n-                b.offset, self.left, self.right);\n+            self.indent(0);\n+            Ok(())\n+          }\n+          Begin(b) => {\n+            if self.scan_stack_empty {\n+                self.left_total = 1;\n+                self.right_total = 1;\n+                self.left = 0u;\n+                self.right = 0u;\n+            } else { self.advance_right(); }\n+            debug!(\"pp Begin({})/buffer ~[{},{}]\",\n+                   b.offset, self.left, self.right);\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n+            self.scan_push(self.right);\n+            Ok(())\n+          }\n+          End => {\n+            if self.scan_stack_empty {\n+                debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n+                self.print(t, 0)\n+            } else {\n+                debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n+                self.advance_right();\n                 self.token[self.right] = t;\n-                self.size[self.right] = -self.right_total;\n+                self.size[self.right] = -1;\n                 self.scan_push(self.right);\n                 Ok(())\n             }\n@@ -330,21 +345,23 @@ impl Printer {\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n+            Ok(())\n           }\n           String(ref s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp String('{}')/print ~[{},{}]\",\n                        *s, self.left, self.right);\n-                self.print(t.clone(), len);\n+                self.print(t.clone(), len)\n             } else {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n                        *s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t.clone();\n                 self.size[self.right] = len;\n                 self.right_total += len;\n-                self.check_stream();\n+                self.check_stream()\n             }\n+          }\n         }\n     }\n     pub fn check_stream(&mut self) -> io::IoResult<()> {\n@@ -360,8 +377,10 @@ impl Printer {\n                 }\n             }\n             let left = self.token[self.left].clone();\n-            self.advance_left(left, self.size[self.left]);\n-            if self.left != self.right { self.check_stream(); }\n+            if_ok!(self.advance_left(left, self.size[self.left]));\n+            if self.left != self.right {\n+                if_ok!(self.check_stream());\n+            }\n         }\n         Ok(())\n     }\n@@ -405,7 +424,7 @@ impl Printer {\n         debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n-            self.print(x.clone(), L);\n+            let ret = self.print(x.clone(), L);\n             match x {\n               Break(b) => self.left_total += b.blank_space,\n               String(_, len) => {\n@@ -417,7 +436,7 @@ impl Printer {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n                 let left = self.token[self.left].clone();\n-                self.advance_left(left, self.size[self.left]);\n+                if_ok!(self.advance_left(left, self.size[self.left]));\n             }\n             ret\n         } else {\n@@ -477,7 +496,7 @@ impl Printer {\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, x: Token, L: int) {\n+    pub fn print(&mut self, x: Token, L: int) -> io::IoResult<()> {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), L,\n                self.space);\n         debug!(\"{}\", buf_str(self.token.clone(),\n@@ -587,16 +606,16 @@ pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n \n pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n \n-pub fn word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_str(), wrd.len() as int));\n+pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+    p.pretty_print(String(/* bad */ wrd.to_str(), wrd.len() as int))\n }\n \n-pub fn huge_word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_str(), SIZE_INFINITY));\n+pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+    p.pretty_print(String(/* bad */ wrd.to_str(), SIZE_INFINITY))\n }\n \n-pub fn zero_word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_str(), 0));\n+pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+    p.pretty_print(String(/* bad */ wrd.to_str(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {"}, {"sha": "e291583d121d7ff00daae27dd204441055cb6c9f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 54, "deletions": 164, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -964,11 +964,7 @@ pub fn print_attribute(s: &mut State, attr: &ast::Attribute) -> io::IoResult<()>\n     if_ok!(maybe_print_comment(s, attr.span.lo));\n     if attr.node.is_sugared_doc {\n         let comment = attr.value_str().unwrap();\n-<<<<<<< HEAD\n-        word(&mut s.s, comment.get());\n-=======\n-        if_ok!(word(&mut s.s, comment));\n->>>>>>> syntax: Remove io_error usage\n+        if_ok!(word(&mut s.s, comment.get()));\n     } else {\n         if_ok!(word(&mut s.s, \"#[\"));\n         if_ok!(print_meta_item(s, attr.meta()));\n@@ -1139,24 +1135,7 @@ pub fn print_mac(s: &mut State, m: &ast::Mac) -> io::IoResult<()> {\n     }\n }\n \n-<<<<<<< HEAD\n-pub fn print_expr_vstore(s: &mut State, t: ast::ExprVstore) {\n-=======\n-pub fn print_vstore(s: &mut State, t: ast::Vstore) -> io::IoResult<()> {\n-    match t {\n-        ast::VstoreFixed(Some(i)) => word(&mut s.s, format!(\"{}\", i)),\n-        ast::VstoreFixed(None) => word(&mut s.s, \"_\"),\n-        ast::VstoreUniq => word(&mut s.s, \"~\"),\n-        ast::VstoreBox => word(&mut s.s, \"@\"),\n-        ast::VstoreSlice(ref r) => {\n-            if_ok!(word(&mut s.s, \"&\"));\n-            print_opt_lifetime(s, r)\n-        }\n-    }\n-}\n-\n pub fn print_expr_vstore(s: &mut State, t: ast::ExprVstore) -> io::IoResult<()> {\n->>>>>>> syntax: Remove io_error usage\n     match t {\n       ast::ExprVstoreUniq => word(&mut s.s, \"~\"),\n       ast::ExprVstoreSlice => word(&mut s.s, \"&\"),\n@@ -1557,51 +1536,27 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n         } else {\n             if_ok!(word(&mut s.s, \"asm!\"));\n         }\n-<<<<<<< HEAD\n-        popen(s);\n-        print_string(s, a.asm.get(), a.asm_str_style);\n-        word_space(s, \":\");\n-        for &(ref co, o) in a.outputs.iter() {\n-            print_string(s, co.get(), ast::CookedStr);\n-            popen(s);\n-            print_expr(s, o);\n-            pclose(s);\n-            word_space(s, \",\");\n-        }\n-        word_space(s, \":\");\n-        for &(ref co, o) in a.inputs.iter() {\n-            print_string(s, co.get(), ast::CookedStr);\n-            popen(s);\n-            print_expr(s, o);\n-            pclose(s);\n-            word_space(s, \",\");\n-        }\n-        word_space(s, \":\");\n-        print_string(s, a.clobbers.get(), ast::CookedStr);\n-        pclose(s);\n-=======\n         if_ok!(popen(s));\n-        if_ok!(print_string(s, a.asm, a.asm_str_style));\n+        if_ok!(print_string(s, a.asm.get(), a.asm_str_style));\n         if_ok!(word_space(s, \":\"));\n-        for &(co, o) in a.outputs.iter() {\n-            if_ok!(print_string(s, co, ast::CookedStr));\n+        for &(ref co, o) in a.outputs.iter() {\n+            if_ok!(print_string(s, co.get(), ast::CookedStr));\n             if_ok!(popen(s));\n             if_ok!(print_expr(s, o));\n             if_ok!(pclose(s));\n             if_ok!(word_space(s, \",\"));\n         }\n         if_ok!(word_space(s, \":\"));\n-        for &(co, o) in a.inputs.iter() {\n-            if_ok!(print_string(s, co, ast::CookedStr));\n+        for &(ref co, o) in a.inputs.iter() {\n+            if_ok!(print_string(s, co.get(), ast::CookedStr));\n             if_ok!(popen(s));\n             if_ok!(print_expr(s, o));\n             if_ok!(pclose(s));\n             if_ok!(word_space(s, \",\"));\n         }\n         if_ok!(word_space(s, \":\"));\n-        if_ok!(print_string(s, a.clobbers, ast::CookedStr));\n+        if_ok!(print_string(s, a.clobbers.get(), ast::CookedStr));\n         if_ok!(pclose(s));\n->>>>>>> syntax: Remove io_error usage\n       }\n       ast::ExprMac(ref m) => if_ok!(print_mac(s, m)),\n       ast::ExprParen(e) => {\n@@ -1659,23 +1614,14 @@ pub fn print_decl(s: &mut State, decl: &ast::Decl) -> io::IoResult<()> {\n     }\n }\n \n-<<<<<<< HEAD\n-pub fn print_ident(s: &mut State, ident: ast::Ident) {\n-    let string = token::get_ident(ident.name);\n-    word(&mut s.s, string.get());\n-}\n-\n-pub fn print_name(s: &mut State, name: ast::Name) {\n-    let string = token::get_ident(name);\n-    word(&mut s.s, string.get());\n-=======\n pub fn print_ident(s: &mut State, ident: ast::Ident) -> io::IoResult<()> {\n-    word(&mut s.s, ident_to_str(&ident))\n+    let string = token::get_ident(ident.name);\n+    word(&mut s.s, string.get())\n }\n \n pub fn print_name(s: &mut State, name: ast::Name) -> io::IoResult<()> {\n-    word(&mut s.s, interner_get(name))\n->>>>>>> syntax: Remove io_error usage\n+    let string = token::get_ident(name);\n+    word(&mut s.s, string.get())\n }\n \n pub fn print_for_decl(s: &mut State, loc: &ast::Local,\n@@ -2088,38 +2034,23 @@ pub fn print_generics(s: &mut State,\n pub fn print_meta_item(s: &mut State, item: &ast::MetaItem) -> io::IoResult<()> {\n     if_ok!(ibox(s, indent_unit));\n     match item.node {\n-<<<<<<< HEAD\n-      ast::MetaWord(ref name) => word(&mut s.s, name.get()),\n-      ast::MetaNameValue(ref name, ref value) => {\n-        word_space(s, name.get());\n-        word_space(s, \"=\");\n-        print_literal(s, value);\n-      }\n-      ast::MetaList(ref name, ref items) => {\n-        word(&mut s.s, name.get());\n-        popen(s);\n-        commasep(s,\n-                 Consistent,\n-                 items.as_slice(),\n-                 |p, &i| print_meta_item(p, i));\n-        pclose(s);\n-=======\n-      ast::MetaWord(name) => { if_ok!(word(&mut s.s, name)); }\n-      ast::MetaNameValue(name, value) => {\n-        if_ok!(word_space(s, name));\n-        if_ok!(word_space(s, \"=\"));\n-        if_ok!(print_literal(s, &value));\n-      }\n-      ast::MetaList(name, ref items) => {\n-        if_ok!(word(&mut s.s, name));\n-        if_ok!(popen(s));\n-        if_ok!(commasep(s,\n-                        Consistent,\n-                        items.as_slice(),\n-                        |p, &i| print_meta_item(p, i)));\n-        if_ok!(pclose(s));\n->>>>>>> syntax: Remove io_error usage\n-      }\n+        ast::MetaWord(ref name) => {\n+            if_ok!(word(&mut s.s, name.get()));\n+        }\n+        ast::MetaNameValue(ref name, ref value) => {\n+            if_ok!(word_space(s, name.get()));\n+            if_ok!(word_space(s, \"=\"));\n+            if_ok!(print_literal(s, value));\n+        }\n+        ast::MetaList(ref name, ref items) => {\n+            if_ok!(word(&mut s.s, name.get()));\n+            if_ok!(popen(s));\n+            if_ok!(commasep(s,\n+                            Consistent,\n+                            items.as_slice(),\n+                            |p, &i| print_meta_item(p, i)));\n+            if_ok!(pclose(s));\n+        }\n     }\n     end(s)\n }\n@@ -2171,17 +2102,10 @@ pub fn print_view_item(s: &mut State, item: &ast::ViewItem) -> io::IoResult<()>\n             if_ok!(head(s, \"extern mod\"));\n             if_ok!(print_ident(s, id));\n             for &(ref p, style) in optional_path.iter() {\n-<<<<<<< HEAD\n-                space(&mut s.s);\n-                word(&mut s.s, \"=\");\n-                space(&mut s.s);\n-                print_string(s, p.get(), style);\n-=======\n                 if_ok!(space(&mut s.s));\n                 if_ok!(word(&mut s.s, \"=\"));\n                 if_ok!(space(&mut s.s));\n-                if_ok!(print_string(s, *p, style));\n->>>>>>> syntax: Remove io_error usage\n+                if_ok!(print_string(s, p.get(), style));\n             }\n         }\n \n@@ -2373,88 +2297,54 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n       _ => ()\n     }\n     match lit.node {\n-<<<<<<< HEAD\n       ast::LitStr(ref st, style) => print_string(s, st.get(), style),\n       ast::LitChar(ch) => {\n           let mut res = ~\"'\";\n           char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n           res.push_char('\\'');\n-          word(&mut s.s, res);\n+          word(&mut s.s, res)\n       }\n       ast::LitInt(i, t) => {\n         if i < 0_i64 {\n             word(&mut s.s,\n                  ~\"-\" + (-i as u64).to_str_radix(10u)\n-                 + ast_util::int_ty_to_str(t));\n+                 + ast_util::int_ty_to_str(t))\n         } else {\n             word(&mut s.s,\n                  (i as u64).to_str_radix(10u)\n-                 + ast_util::int_ty_to_str(t));\n-=======\n-        ast::LitStr(st, style) => print_string(s, st, style),\n-        ast::LitChar(ch) => {\n-            let mut res = ~\"'\";\n-            char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n-            res.push_char('\\'');\n-            word(&mut s.s, res)\n-        }\n-        ast::LitInt(i, t) => {\n-            if i < 0_i64 {\n-                word(&mut s.s, ~\"-\" + (-i as u64).to_str_radix(10u)\n-                               + ast_util::int_ty_to_str(t))\n-            } else {\n-                word(&mut s.s, (i as u64).to_str_radix(10u)\n-                                + ast_util::int_ty_to_str(t))\n-            }\n->>>>>>> syntax: Remove io_error usage\n-        }\n-        ast::LitUint(u, t) => {\n-            word(&mut s.s, u.to_str_radix(10u) + ast_util::uint_ty_to_str(t))\n+                 + ast_util::int_ty_to_str(t))\n         }\n-        ast::LitIntUnsuffixed(i) => {\n-            if i < 0_i64 {\n-                word(&mut s.s, ~\"-\" + (-i as u64).to_str_radix(10u))\n-            } else {\n-                word(&mut s.s, (i as u64).to_str_radix(10u))\n-            }\n-        }\n-        ast::LitFloat(f, t) => {\n-            word(&mut s.s, f.to_owned() + ast_util::float_ty_to_str(t))\n-        }\n-        ast::LitFloatUnsuffixed(f) => word(&mut s.s, f),\n-        ast::LitNil => word(&mut s.s, \"()\"),\n-        ast::LitBool(val) => {\n-            if val { word(&mut s.s, \"true\") } else { word(&mut s.s, \"false\") }\n-        }\n-        ast::LitBinary(arr) => {\n-            if_ok!(ibox(s, indent_unit));\n-            if_ok!(word(&mut s.s, \"[\"));\n-            if_ok!(commasep_cmnt(s, Inconsistent, arr,\n-                                 |s, u| word(&mut s.s, format!(\"{}\", *u)),\n-                                 |_| lit.span));\n-            if_ok!(word(&mut s.s, \"]\"));\n-            end(s)\n+      }\n+      ast::LitUint(u, t) => {\n+        word(&mut s.s,\n+             u.to_str_radix(10u)\n+             + ast_util::uint_ty_to_str(t))\n+      }\n+      ast::LitIntUnsuffixed(i) => {\n+        if i < 0_i64 {\n+            word(&mut s.s, ~\"-\" + (-i as u64).to_str_radix(10u))\n+        } else {\n+            word(&mut s.s, (i as u64).to_str_radix(10u))\n         }\n-<<<<<<< HEAD\n       }\n+\n       ast::LitFloat(ref f, t) => {\n-        word(&mut s.s, f.get() + ast_util::float_ty_to_str(t));\n+        word(&mut s.s, f.get() + ast_util::float_ty_to_str(t))\n       }\n       ast::LitFloatUnsuffixed(ref f) => word(&mut s.s, f.get()),\n       ast::LitNil => word(&mut s.s, \"()\"),\n       ast::LitBool(val) => {\n-        if val { word(&mut s.s, \"true\"); } else { word(&mut s.s, \"false\"); }\n+        if val { word(&mut s.s, \"true\") } else { word(&mut s.s, \"false\") }\n       }\n       ast::LitBinary(ref arr) => {\n-        ibox(s, indent_unit);\n-        word(&mut s.s, \"[\");\n-        commasep_cmnt(s, Inconsistent, *arr.borrow(), |s, u| word(&mut s.s, format!(\"{}\", *u)),\n-                      |_| lit.span);\n-        word(&mut s.s, \"]\");\n-        end(s);\n-      }\n-=======\n->>>>>>> syntax: Remove io_error usage\n+        if_ok!(ibox(s, indent_unit));\n+        if_ok!(word(&mut s.s, \"[\"));\n+        if_ok!(commasep_cmnt(s, Inconsistent, *arr.borrow(),\n+                             |s, u| word(&mut s.s, format!(\"{}\", *u)),\n+                             |_| lit.span));\n+        if_ok!(word(&mut s.s, \"]\"));\n+        end(s)\n+      }\n     }\n }\n "}, {"sha": "c4481a1a07f0153e14160ca94189019fb86a8cc0", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -19,15 +19,21 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n+#[feature(macro_rules)];\n #[deny(non_camel_case_types)];\n #[allow(missing_doc)];\n \n use std::os;\n+use std::io;\n use terminfo::TermInfo;\n use terminfo::searcher::open;\n use terminfo::parser::compiled::{parse, msys_terminfo};\n use terminfo::parm::{expand, Number, Variables};\n \n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n pub mod terminfo;\n \n // FIXME (#2807): Windows support."}, {"sha": "6f4a4c43b03956aba8b7d17bd9faa9cb1d6b876e", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::io;\n use std::io::BufferedWriter;\n \n struct DummyWriter;\n impl Writer for DummyWriter {\n-    fn write(&mut self, _: &[u8]) {}\n+    fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n }\n \n static ITER: int = 50;"}, {"sha": "771e545ece88cc0a50139e7eb6d04690b91d7844", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c765a8e7ad314651b92ff860cda0159c79dbec6e/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=c765a8e7ad314651b92ff860cda0159c79dbec6e", "patch": "@@ -36,11 +36,12 @@ fn make_complements() -> [u8, ..256] {\n \n fn main() {\n     let complements = make_complements();\n-    let mut data = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let data = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         File::open(&Path::new(\"shootout-k-nucleotide.data\")).read_to_end()\n     } else {\n         stdin().read_to_end()\n     };\n+    let mut data = data.unwrap();\n \n     for seq in data.mut_split(|c| *c == '>' as u8) {\n         // skip header and last \\n"}]}