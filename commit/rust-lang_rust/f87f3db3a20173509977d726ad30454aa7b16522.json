{"sha": "f87f3db3a20173509977d726ad30454aa7b16522", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4N2YzZGIzYTIwMTczNTA5OTc3ZDcyNmFkMzA0NTRhYTdiMTY1MjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-25T21:21:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-25T21:21:11Z"}, "message": "Rollup merge of #62978 - LukasKalbertodt:remove-array-impl-bootstrap-cfg, r=Mark-Simulacrum\n\nRemove `cfg(bootstrap)` code for array implementations\n\nIn https://github.com/rust-lang/rust/pull/62435 (\"Use const generics for array impls [part 1]\") the old macro-based implementations were not removed but still used with `cfg(bootstrap)` since the bootstrap compiler had some problems with const generics at the time. This does not seem to be the case anymore, so there is no reason to keep the old code.\n\nUnfortunately, the diff is pretty ugly because much of the code was indented by one level before. The change is pretty trivial, though.\n\nPS: I did not run the full test suite locally. There are 40\u00b0C outside and 31\u00b0C inside my room. I don't want my notebook to melt. I hope that CI is green.\n\nr? @scottmcm", "tree": {"sha": "1e390390028715e4312fa9af7d91852ef0e14d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e390390028715e4312fa9af7d91852ef0e14d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f87f3db3a20173509977d726ad30454aa7b16522", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOh1HCRBK7hj4Ov3rIwAAdHIIABfQDpmYuLqmDEbtCyQnYiCa\nTrmnDXmQcoL5V1+f1MK0abuVwSAvYf9HY6gl2LmHFrooEXwcqZ9mLFic279NLR1Y\nYWoTUq4Kj+lEp6c0amf51XwDSkj/0QWkXmOUh7qOqZymnLHiMVd5McJbfw0CQ1gw\n3UiUiQEeLxEH0z5afE8eDXYFCaY0Os6DKo8sAt6AqHVMU3HSwriOvcAFmesw8r21\niBvs9z4lN8AvavgSOFMMefetIAVZoWtyANbT+Fo4uNiDyISZ/iSNupN9znkdkJnA\nsn2+x5zk4QMGEFpEzYr52R3gi5Ap7kJN66hHFkwnnbRZSL7fyI+xCxWEgAsXnGo=\n=q8Pk\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e390390028715e4312fa9af7d91852ef0e14d27\nparent ca26d2e5133c960ea5df7cc7a38a337dbf2410a9\nparent 9d39758d14df45956b1a8d8132e3e40c3558dd4b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564089671 +0200\ncommitter GitHub <noreply@github.com> 1564089671 +0200\n\nRollup merge of #62978 - LukasKalbertodt:remove-array-impl-bootstrap-cfg, r=Mark-Simulacrum\n\nRemove `cfg(bootstrap)` code for array implementations\n\nIn https://github.com/rust-lang/rust/pull/62435 (\"Use const generics for array impls [part 1]\") the old macro-based implementations were not removed but still used with `cfg(bootstrap)` since the bootstrap compiler had some problems with const generics at the time. This does not seem to be the case anymore, so there is no reason to keep the old code.\n\nUnfortunately, the diff is pretty ugly because much of the code was indented by one level before. The change is pretty trivial, though.\n\nPS: I did not run the full test suite locally. There are 40\u00b0C outside and 31\u00b0C inside my room. I don't want my notebook to melt. I hope that CI is green.\n\nr? @scottmcm\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f87f3db3a20173509977d726ad30454aa7b16522", "html_url": "https://github.com/rust-lang/rust/commit/f87f3db3a20173509977d726ad30454aa7b16522", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f87f3db3a20173509977d726ad30454aa7b16522/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca26d2e5133c960ea5df7cc7a38a337dbf2410a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca26d2e5133c960ea5df7cc7a38a337dbf2410a9", "html_url": "https://github.com/rust-lang/rust/commit/ca26d2e5133c960ea5df7cc7a38a337dbf2410a9"}, {"sha": "9d39758d14df45956b1a8d8132e3e40c3558dd4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d39758d14df45956b1a8d8132e3e40c3558dd4b", "html_url": "https://github.com/rust-lang/rust/commit/9d39758d14df45956b1a8d8132e3e40c3558dd4b"}], "stats": {"total": 675, "additions": 241, "deletions": 434}, "files": [{"sha": "6ecc0487fae1b16fdadaf00c94d36a3117a9b373", "filename": "src/libcore/array.rs", "status": "modified", "additions": 240, "deletions": 433, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/f87f3db3a20173509977d726ad30454aa7b16522/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f87f3db3a20173509977d726ad30454aa7b16522/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=f87f3db3a20173509977d726ad30454aa7b16522", "patch": "@@ -81,487 +81,296 @@ impl From<Infallible> for TryFromSliceError {\n     }\n }\n \n-#[cfg(bootstrap)]\n-macro_rules! __impl_slice_eq1 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$Rhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Rhs) -> bool { self[..] != other[..] }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, const N: usize> AsRef<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T] {\n+        &self[..]\n     }\n }\n \n-#[cfg(bootstrap)]\n-macro_rules! __impl_slice_eq2 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        __impl_slice_eq1!($Lhs, $Rhs, $Bound);\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$Lhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Lhs) -> bool { self[..] != other[..] }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, const N: usize> AsMut<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T] {\n+        &mut self[..]\n     }\n }\n \n-// macro for implementing n-element array functions and operations\n-#[cfg(bootstrap)]\n-macro_rules! array_impls {\n-    ($($N:expr)+) => {\n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T> AsRef<[T]> for [T; $N] {\n-                #[inline]\n-                fn as_ref(&self) -> &[T] {\n-                    &self[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T> AsMut<[T]> for [T; $N] {\n-                #[inline]\n-                fn as_mut(&mut self) -> &mut [T] {\n-                    &mut self[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-            impl<T> Borrow<[T]> for [T; $N] {\n-                fn borrow(&self) -> &[T] {\n-                    self\n-                }\n-            }\n-\n-            #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-            impl<T> BorrowMut<[T]> for [T; $N] {\n-                fn borrow_mut(&mut self) -> &mut [T] {\n-                    self\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<T> TryFrom<&[T]> for [T; $N] where T: Copy {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n-                    <&Self>::try_from(slice).map(|r| *r)\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &[T]) -> Result<&[T; $N], TryFromSliceError> {\n-                    if slice.len() == $N {\n-                        let ptr = slice.as_ptr() as *const [T; $N];\n-                        unsafe { Ok(&*ptr) }\n-                    } else {\n-                        Err(TryFromSliceError(()))\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &mut [T]) -> Result<&mut [T; $N], TryFromSliceError> {\n-                    if slice.len() == $N {\n-                        let ptr = slice.as_mut_ptr() as *mut [T; $N];\n-                        unsafe { Ok(&mut *ptr) }\n-                    } else {\n-                        Err(TryFromSliceError(()))\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T: Hash> Hash for [T; $N] {\n-                fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-                    Hash::hash(&self[..], state)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::Debug::fmt(&&self[..], f)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, T> IntoIterator for &'a [T; $N] {\n-                type Item = &'a T;\n-                type IntoIter = Iter<'a, T>;\n-\n-                fn into_iter(self) -> Iter<'a, T> {\n-                    self.iter()\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n-                type Item = &'a mut T;\n-                type IntoIter = IterMut<'a, T>;\n-\n-                fn into_iter(self) -> IterMut<'a, T> {\n-                    self.iter_mut()\n-                }\n-            }\n-\n-            // NOTE: some less important impls are omitted to reduce code bloat\n-            __impl_slice_eq1! { [A; $N], [B; $N] }\n-            __impl_slice_eq2! { [A; $N], [B] }\n-            __impl_slice_eq2! { [A; $N], &'b [B] }\n-            __impl_slice_eq2! { [A; $N], &'b mut [B] }\n-            // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-            // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:Eq> Eq for [T; $N] { }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:PartialOrd> PartialOrd for [T; $N] {\n-                #[inline]\n-                fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&&self[..], &&other[..])\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:Ord> Ord for [T; $N] {\n-                #[inline]\n-                fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&&self[..], &&other[..])\n-                }\n-            }\n-        )+\n+#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+impl<T, const N: usize> Borrow<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn borrow(&self) -> &[T] {\n+        self\n     }\n }\n \n-#[cfg(not(bootstrap))]\n-mod impls_using_const_generics {\n-    use super::*;\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T, const N: usize> AsRef<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn as_ref(&self) -> &[T] {\n-            &self[..]\n-        }\n+#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn borrow_mut(&mut self) -> &mut [T] {\n+        self\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T, const N: usize> AsMut<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn as_mut(&mut self) -> &mut [T] {\n-            &mut self[..]\n-        }\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n+where\n+    T: Copy,\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n+        <&Self>::try_from(slice).map(|r| *r)\n     }\n+}\n \n-    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-    impl<T, const N: usize> Borrow<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn borrow(&self) -> &[T] {\n-            self\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n+        if slice.len() == N {\n+            let ptr = slice.as_ptr() as *const [T; N];\n+            unsafe { Ok(&*ptr) }\n+        } else {\n+            Err(TryFromSliceError(()))\n         }\n     }\n+}\n \n-    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-    impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn borrow_mut(&mut self) -> &mut [T] {\n-            self\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n+        if slice.len() == N {\n+            let ptr = slice.as_mut_ptr() as *mut [T; N];\n+            unsafe { Ok(&mut *ptr) }\n+        } else {\n+            Err(TryFromSliceError(()))\n         }\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n-    where\n-        T: Copy,\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash, const N: usize> Hash for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        Hash::hash(&self[..], state)\n+    }\n+}\n \n-        fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n-            <&Self>::try_from(slice).map(|r| *r)\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&&self[..], f)\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n \n-        fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n-            if slice.len() == N {\n-                let ptr = slice.as_ptr() as *const [T; N];\n-                unsafe { Ok(&*ptr) }\n-            } else {\n-                Err(TryFromSliceError(()))\n-            }\n-        }\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n \n-        fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n-            if slice.len() == N {\n-                let ptr = slice.as_mut_ptr() as *mut [T; N];\n-                unsafe { Ok(&mut *ptr) }\n-            } else {\n-                Err(TryFromSliceError(()))\n-            }\n-        }\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash, const N: usize> Hash for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-            Hash::hash(&self[..], state)\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+    [B; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B; N]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            fmt::Debug::fmt(&&self[..], f)\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[B; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Item = &'a T;\n-        type IntoIter = Iter<'a, T>;\n-\n-        fn into_iter(self) -> Iter<'a, T> {\n-            self.iter()\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Item = &'a mut T;\n-        type IntoIter = IterMut<'a, T>;\n-\n-        fn into_iter(self) -> IterMut<'a, T> {\n-            self.iter_mut()\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-        [B; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[B; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[B; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[B]) -> bool {\n-            self[..] != other[..]\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&'b [B]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &&'b [B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &&'b [B]) -> bool {\n-            self[..] != other[..]\n-        }\n+    #[inline]\n+    fn ne(&self, other: &&'b [B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &&'b mut [B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &&'b mut [B]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&'b mut [B]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &&'b mut [B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    // NOTE: some less important impls are omitted to reduce code bloat\n-    // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-    // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n-            PartialOrd::partial_cmp(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn lt(&self, other: &[T; N]) -> bool {\n-            PartialOrd::lt(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn le(&self, other: &[T; N]) -> bool {\n-            PartialOrd::le(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn ge(&self, other: &[T; N]) -> bool {\n-            PartialOrd::ge(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn gt(&self, other: &[T; N]) -> bool {\n-            PartialOrd::gt(&&self[..], &&other[..])\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn lt(&self, other: &[T; N]) -> bool {\n+        PartialOrd::lt(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn le(&self, other: &[T; N]) -> bool {\n+        PartialOrd::le(&&self[..], &&other[..])\n     }\n+    #[inline]\n+    fn ge(&self, other: &[T; N]) -> bool {\n+        PartialOrd::ge(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn gt(&self, other: &[T; N]) -> bool {\n+        PartialOrd::gt(&&self[..], &&other[..])\n+    }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Ord, const N: usize> Ord for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn cmp(&self, other: &[T; N]) -> Ordering {\n-            Ord::cmp(&&self[..], &&other[..])\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord, const N: usize> Ord for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn cmp(&self, other: &[T; N]) -> Ordering {\n+        Ord::cmp(&&self[..], &&other[..])\n     }\n }\n \n@@ -571,10 +380,8 @@ mod impls_using_const_generics {\n )]\n #[unstable(feature = \"const_generic_impls_guard\", issue = \"0\",\n     reason = \"will never be stable, just a temporary step until const generics are stable\")]\n-#[cfg(not(bootstrap))]\n pub trait LengthAtMost32 {}\n \n-#[cfg(not(bootstrap))]\n macro_rules! array_impls {\n     ($($N:literal)+) => {\n         $("}, {"sha": "2bb941b490e56097d20a4940bed90eb27393e015", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f87f3db3a20173509977d726ad30454aa7b16522/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f87f3db3a20173509977d726ad30454aa7b16522/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=f87f3db3a20173509977d726ad30454aa7b16522", "patch": "@@ -74,7 +74,7 @@\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n-#![cfg_attr(not(bootstrap), feature(const_generics))]\n+#![feature(const_generics)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]"}]}