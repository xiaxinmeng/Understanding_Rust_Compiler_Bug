{"sha": "6211b49ac1c9a013869943a003efbd5a71a73c93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMTFiNDlhYzFjOWEwMTM4Njk5NDNhMDAzZWZiZDVhNzFhNzNjOTM=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-12T03:47:21Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-16T02:28:53Z"}, "message": "Move unit_arg to its own module", "tree": {"sha": "d8a2a4bd18aff45511415f923558975d694e9dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a2a4bd18aff45511415f923558975d694e9dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6211b49ac1c9a013869943a003efbd5a71a73c93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6211b49ac1c9a013869943a003efbd5a71a73c93", "html_url": "https://github.com/rust-lang/rust/commit/6211b49ac1c9a013869943a003efbd5a71a73c93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6211b49ac1c9a013869943a003efbd5a71a73c93/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bb221243b853856596241ff3c4210e80a114d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb221243b853856596241ff3c4210e80a114d34", "html_url": "https://github.com/rust-lang/rust/commit/1bb221243b853856596241ff3c4210e80a114d34"}], "stats": {"total": 438, "additions": 218, "deletions": 220}, "files": [{"sha": "f479d756a332bd6e477473a1702240ab55a3b335", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6211b49ac1c9a013869943a003efbd5a71a73c93/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6211b49ac1c9a013869943a003efbd5a71a73c93/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6211b49ac1c9a013869943a003efbd5a71a73c93", "patch": "@@ -1160,7 +1160,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n     store.register_late_pass(|| box types::ImplicitHasher);\n     store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n-    store.register_late_pass(|| box unit_types::UnitArg);\n     store.register_late_pass(|| box double_comparison::DoubleComparisons);\n     store.register_late_pass(|| box question_mark::QuestionMark);\n     store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);"}, {"sha": "64420a03933490efa7b7cebb908ff0d5dd3a663f", "filename": "clippy_lints/src/unit_types/mod.rs", "status": "modified", "additions": 9, "deletions": 219, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/6211b49ac1c9a013869943a003efbd5a71a73c93/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6211b49ac1c9a013869943a003efbd5a71a73c93/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs?ref=6211b49ac1c9a013869943a003efbd5a71a73c93", "patch": "@@ -1,20 +1,12 @@\n mod let_unit_value;\n+mod unit_arg;\n mod unit_cmp;\n mod utils;\n \n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, Node, Stmt, StmtKind};\n+use rustc_hir::{Expr, Stmt};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use if_chain::if_chain;\n-\n-use crate::utils::diagnostics::span_lint_and_then;\n-use crate::utils::source::{indent_of, reindent_multiline, snippet_opt};\n-\n-use utils::{is_unit, is_unit_literal};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for binding a unit value.\n     ///\n@@ -81,18 +73,6 @@ declare_clippy_lint! {\n     \"comparing unit values\"\n }\n \n-declare_lint_pass!(UnitTypes => [LET_UNIT_VALUE, UNIT_CMP]);\n-\n-impl LateLintPass<'_> for UnitTypes {\n-    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n-        let_unit_value::check(cx, stmt);\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        unit_cmp::check(cx, expr);\n-    }\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for passing a unit value as an argument to a function without using a\n     /// unit literal (`()`).\n@@ -113,205 +93,15 @@ declare_clippy_lint! {\n     \"passing unit to a function\"\n }\n \n-declare_lint_pass!(UnitArg => [UNIT_ARG]);\n-\n-impl<'tcx> LateLintPass<'tcx> for UnitArg {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        // apparently stuff in the desugaring of `?` can trigger this\n-        // so check for that here\n-        // only the calls to `Try::from_error` is marked as desugared,\n-        // so we need to check both the current Expr and its parent.\n-        if is_questionmark_desugar_marked_call(expr) {\n-            return;\n-        }\n-        if_chain! {\n-            let map = &cx.tcx.hir();\n-            let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n-            if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n-            if is_questionmark_desugar_marked_call(parent_expr);\n-            then {\n-                return;\n-            }\n-        }\n-\n-        match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n-                let args_to_recover = args\n-                    .iter()\n-                    .filter(|arg| {\n-                        if is_unit(cx.typeck_results().expr_ty(arg)) && !is_unit_literal(arg) {\n-                            !matches!(\n-                                &arg.kind,\n-                                ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n-                            )\n-                        } else {\n-                            false\n-                        }\n-                    })\n-                    .collect::<Vec<_>>();\n-                if !args_to_recover.is_empty() {\n-                    lint_unit_args(cx, expr, &args_to_recover);\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n+declare_lint_pass!(UnitTypes => [LET_UNIT_VALUE, UNIT_CMP, UNIT_ARG]);\n \n-fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n-    use rustc_span::hygiene::DesugaringKind;\n-    if let ExprKind::Call(ref callee, _) = expr.kind {\n-        callee.span.is_desugaring(DesugaringKind::QuestionMark)\n-    } else {\n-        false\n+impl LateLintPass<'_> for UnitTypes {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n+        let_unit_value::check(cx, stmt);\n     }\n-}\n-\n-fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let (singular, plural) = if args_to_recover.len() > 1 {\n-        (\"\", \"s\")\n-    } else {\n-        (\"a \", \"\")\n-    };\n-    span_lint_and_then(\n-        cx,\n-        UNIT_ARG,\n-        expr.span,\n-        &format!(\"passing {}unit value{} to a function\", singular, plural),\n-        |db| {\n-            let mut or = \"\";\n-            args_to_recover\n-                .iter()\n-                .filter_map(|arg| {\n-                    if_chain! {\n-                        if let ExprKind::Block(block, _) = arg.kind;\n-                        if block.expr.is_none();\n-                        if let Some(last_stmt) = block.stmts.iter().last();\n-                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n-                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n-                        then {\n-                            Some((\n-                                last_stmt.span,\n-                                snip,\n-                            ))\n-                        }\n-                        else {\n-                            None\n-                        }\n-                    }\n-                })\n-                .for_each(|(span, sugg)| {\n-                    db.span_suggestion(\n-                        span,\n-                        \"remove the semicolon from the last statement in the block\",\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    or = \"or \";\n-                    applicability = Applicability::MaybeIncorrect;\n-                });\n-\n-            let arg_snippets: Vec<String> = args_to_recover\n-                .iter()\n-                .filter_map(|arg| snippet_opt(cx, arg.span))\n-                .collect();\n-            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n-                .iter()\n-                .filter(|arg| !is_empty_block(arg))\n-                .filter_map(|arg| snippet_opt(cx, arg.span))\n-                .collect();\n-\n-            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n-                let sugg = fmt_stmts_and_call(\n-                    cx,\n-                    expr,\n-                    &call_snippet,\n-                    &arg_snippets,\n-                    &arg_snippets_without_empty_blocks,\n-                );\n \n-                if arg_snippets_without_empty_blocks.is_empty() {\n-                    db.multipart_suggestion(\n-                        &format!(\"use {}unit literal{} instead\", singular, plural),\n-                        args_to_recover\n-                            .iter()\n-                            .map(|arg| (arg.span, \"()\".to_string()))\n-                            .collect::<Vec<_>>(),\n-                        applicability,\n-                    );\n-                } else {\n-                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n-                    let empty_or_s = if plural { \"s\" } else { \"\" };\n-                    let it_or_them = if plural { \"them\" } else { \"it\" };\n-                    db.span_suggestion(\n-                        expr.span,\n-                        &format!(\n-                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n-                            or, empty_or_s, it_or_them\n-                        ),\n-                        sugg,\n-                        applicability,\n-                    );\n-                }\n-            }\n-        },\n-    );\n-}\n-\n-fn is_empty_block(expr: &Expr<'_>) -> bool {\n-    matches!(\n-        expr.kind,\n-        ExprKind::Block(\n-            Block {\n-                stmts: &[],\n-                expr: None,\n-                ..\n-            },\n-            _,\n-        )\n-    )\n-}\n-\n-fn fmt_stmts_and_call(\n-    cx: &LateContext<'_>,\n-    call_expr: &Expr<'_>,\n-    call_snippet: &str,\n-    args_snippets: &[impl AsRef<str>],\n-    non_empty_block_args_snippets: &[impl AsRef<str>],\n-) -> String {\n-    let call_expr_indent = indent_of(cx, call_expr.span).unwrap_or(0);\n-    let call_snippet_with_replacements = args_snippets\n-        .iter()\n-        .fold(call_snippet.to_owned(), |acc, arg| acc.replacen(arg.as_ref(), \"()\", 1));\n-\n-    let mut stmts_and_call = non_empty_block_args_snippets\n-        .iter()\n-        .map(|it| it.as_ref().to_owned())\n-        .collect::<Vec<_>>();\n-    stmts_and_call.push(call_snippet_with_replacements);\n-    stmts_and_call = stmts_and_call\n-        .into_iter()\n-        .map(|v| reindent_multiline(v.into(), true, Some(call_expr_indent)).into_owned())\n-        .collect();\n-\n-    let mut stmts_and_call_snippet = stmts_and_call.join(&format!(\"{}{}\", \";\\n\", \" \".repeat(call_expr_indent)));\n-    // expr is not in a block statement or result expression position, wrap in a block\n-    let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(call_expr.hir_id));\n-    if !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_))) {\n-        let block_indent = call_expr_indent + 4;\n-        stmts_and_call_snippet =\n-            reindent_multiline(stmts_and_call_snippet.into(), true, Some(block_indent)).into_owned();\n-        stmts_and_call_snippet = format!(\n-            \"{{\\n{}{}\\n{}}}\",\n-            \" \".repeat(block_indent),\n-            &stmts_and_call_snippet,\n-            \" \".repeat(call_expr_indent)\n-        );\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        unit_cmp::check(cx, expr);\n+        unit_arg::check(cx, expr);\n     }\n-    stmts_and_call_snippet\n }"}, {"sha": "49b5725f528dd0db0fe5ffbae4d42272c62d050d", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/6211b49ac1c9a013869943a003efbd5a71a73c93/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6211b49ac1c9a013869943a003efbd5a71a73c93/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=6211b49ac1c9a013869943a003efbd5a71a73c93", "patch": "@@ -0,0 +1,209 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, Block, Expr, ExprKind, MatchSource, Node, StmtKind};\n+use rustc_lint::LateContext;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::diagnostics::span_lint_and_then;\n+use crate::utils::source::{indent_of, reindent_multiline, snippet_opt};\n+\n+use super::{utils, UNIT_ARG};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if expr.span.from_expansion() {\n+        return;\n+    }\n+\n+    // apparently stuff in the desugaring of `?` can trigger this\n+    // so check for that here\n+    // only the calls to `Try::from_error` is marked as desugared,\n+    // so we need to check both the current Expr and its parent.\n+    if is_questionmark_desugar_marked_call(expr) {\n+        return;\n+    }\n+    if_chain! {\n+        let map = &cx.tcx.hir();\n+        let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n+        if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n+        if is_questionmark_desugar_marked_call(parent_expr);\n+        then {\n+            return;\n+        }\n+    }\n+\n+    match expr.kind {\n+        ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n+            let args_to_recover = args\n+                .iter()\n+                .filter(|arg| {\n+                    if utils::is_unit(cx.typeck_results().expr_ty(arg)) && !utils::is_unit_literal(arg) {\n+                        !matches!(\n+                            &arg.kind,\n+                            ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n+                        )\n+                    } else {\n+                        false\n+                    }\n+                })\n+                .collect::<Vec<_>>();\n+            if !args_to_recover.is_empty() {\n+                lint_unit_args(cx, expr, &args_to_recover);\n+            }\n+        },\n+        _ => (),\n+    }\n+}\n+\n+fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n+    use rustc_span::hygiene::DesugaringKind;\n+    if let ExprKind::Call(ref callee, _) = expr.kind {\n+        callee.span.is_desugaring(DesugaringKind::QuestionMark)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let (singular, plural) = if args_to_recover.len() > 1 {\n+        (\"\", \"s\")\n+    } else {\n+        (\"a \", \"\")\n+    };\n+    span_lint_and_then(\n+        cx,\n+        UNIT_ARG,\n+        expr.span,\n+        &format!(\"passing {}unit value{} to a function\", singular, plural),\n+        |db| {\n+            let mut or = \"\";\n+            args_to_recover\n+                .iter()\n+                .filter_map(|arg| {\n+                    if_chain! {\n+                        if let ExprKind::Block(block, _) = arg.kind;\n+                        if block.expr.is_none();\n+                        if let Some(last_stmt) = block.stmts.iter().last();\n+                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n+                        then {\n+                            Some((\n+                                last_stmt.span,\n+                                snip,\n+                            ))\n+                        }\n+                        else {\n+                            None\n+                        }\n+                    }\n+                })\n+                .for_each(|(span, sugg)| {\n+                    db.span_suggestion(\n+                        span,\n+                        \"remove the semicolon from the last statement in the block\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    or = \"or \";\n+                    applicability = Applicability::MaybeIncorrect;\n+                });\n+\n+            let arg_snippets: Vec<String> = args_to_recover\n+                .iter()\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n+                .iter()\n+                .filter(|arg| !is_empty_block(arg))\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+\n+            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n+                let sugg = fmt_stmts_and_call(\n+                    cx,\n+                    expr,\n+                    &call_snippet,\n+                    &arg_snippets,\n+                    &arg_snippets_without_empty_blocks,\n+                );\n+\n+                if arg_snippets_without_empty_blocks.is_empty() {\n+                    db.multipart_suggestion(\n+                        &format!(\"use {}unit literal{} instead\", singular, plural),\n+                        args_to_recover\n+                            .iter()\n+                            .map(|arg| (arg.span, \"()\".to_string()))\n+                            .collect::<Vec<_>>(),\n+                        applicability,\n+                    );\n+                } else {\n+                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n+                    let empty_or_s = if plural { \"s\" } else { \"\" };\n+                    let it_or_them = if plural { \"them\" } else { \"it\" };\n+                    db.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n+                            or, empty_or_s, it_or_them\n+                        ),\n+                        sugg,\n+                        applicability,\n+                    );\n+                }\n+            }\n+        },\n+    );\n+}\n+\n+fn is_empty_block(expr: &Expr<'_>) -> bool {\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: &[],\n+                expr: None,\n+                ..\n+            },\n+            _,\n+        )\n+    )\n+}\n+\n+fn fmt_stmts_and_call(\n+    cx: &LateContext<'_>,\n+    call_expr: &Expr<'_>,\n+    call_snippet: &str,\n+    args_snippets: &[impl AsRef<str>],\n+    non_empty_block_args_snippets: &[impl AsRef<str>],\n+) -> String {\n+    let call_expr_indent = indent_of(cx, call_expr.span).unwrap_or(0);\n+    let call_snippet_with_replacements = args_snippets\n+        .iter()\n+        .fold(call_snippet.to_owned(), |acc, arg| acc.replacen(arg.as_ref(), \"()\", 1));\n+\n+    let mut stmts_and_call = non_empty_block_args_snippets\n+        .iter()\n+        .map(|it| it.as_ref().to_owned())\n+        .collect::<Vec<_>>();\n+    stmts_and_call.push(call_snippet_with_replacements);\n+    stmts_and_call = stmts_and_call\n+        .into_iter()\n+        .map(|v| reindent_multiline(v.into(), true, Some(call_expr_indent)).into_owned())\n+        .collect();\n+\n+    let mut stmts_and_call_snippet = stmts_and_call.join(&format!(\"{}{}\", \";\\n\", \" \".repeat(call_expr_indent)));\n+    // expr is not in a block statement or result expression position, wrap in a block\n+    let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(call_expr.hir_id));\n+    if !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_))) {\n+        let block_indent = call_expr_indent + 4;\n+        stmts_and_call_snippet =\n+            reindent_multiline(stmts_and_call_snippet.into(), true, Some(block_indent)).into_owned();\n+        stmts_and_call_snippet = format!(\n+            \"{{\\n{}{}\\n{}}}\",\n+            \" \".repeat(block_indent),\n+            &stmts_and_call_snippet,\n+            \" \".repeat(call_expr_indent)\n+        );\n+    }\n+    stmts_and_call_snippet\n+}"}]}