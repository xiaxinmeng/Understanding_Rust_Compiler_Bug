{"sha": "40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "node_id": "C_kwDOAAsO6NoAKDQwYTA1MzM2MWEyODcxZTI4NmNmNWNiYzgzY2MyZWQzOTI2ZTFiNGI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-25T14:51:46Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-25T14:52:58Z"}, "message": "small method code cleanup", "tree": {"sha": "51b6d98f3fc4b058d917281c76876273e7ae922d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51b6d98f3fc4b058d917281c76876273e7ae922d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "html_url": "https://github.com/rust-lang/rust/commit/40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a75c5a9b5d9c48aa576b08faf735b926d0d9a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a75c5a9b5d9c48aa576b08faf735b926d0d9a71", "html_url": "https://github.com/rust-lang/rust/commit/8a75c5a9b5d9c48aa576b08faf735b926d0d9a71"}], "stats": {"total": 32, "additions": 17, "deletions": 15}, "files": [{"sha": "cd1322d1a3bcc8a998f88da0dd7486ec1858f52f", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "patch": "@@ -179,12 +179,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Hack: we know that there are traits implementing Fn for &F\n             // where F:Fn and so forth. In the particular case of types\n-            // like `x: &mut FnMut()`, if there is a call `x()`, we would\n-            // normally translate to `FnMut::call_mut(&mut x, ())`, but\n-            // that winds up requiring `mut x: &mut FnMut()`. A little\n-            // over the top. The simplest fix by far is to just ignore\n-            // this case and deref again, so we wind up with\n-            // `FnMut::call_mut(&mut *x, ())`.\n+            // like `f: &mut FnMut()`, if there is a call `f()`, we would\n+            // normally translate to `FnMut::call_mut(&mut f, ())`, but\n+            // that winds up requiring the user to potentially mark their\n+            // variable as `mut` which feels unnecessary and unexpected.\n+            //\n+            //     fn foo(f: &mut impl FnMut()) { f() }\n+            //            ^ without this hack `f` would have to be declared as mutable\n+            //\n+            // The simplest fix by far is to just ignore this case and deref again,\n+            // so we wind up with `FnMut::call_mut(&mut *f, ())`.\n             ty::Ref(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }"}, {"sha": "f6377f9f49403c404cef913e9bc2855cd547cbfa", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "patch": "@@ -1112,15 +1112,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Special-case that coercion alone cannot handle:\n         // Function items or non-capturing closures of differing IDs or InternalSubsts.\n         let (a_sig, b_sig) = {\n-            #[allow(rustc::usage_of_ty_tykind)]\n-            let is_capturing_closure = |ty: &ty::TyKind<'tcx>| {\n-                if let &ty::Closure(closure_def_id, _substs) = ty {\n+            let is_capturing_closure = |ty: Ty<'tcx>| {\n+                if let &ty::Closure(closure_def_id, _substs) = ty.kind() {\n                     self.tcx.upvars_mentioned(closure_def_id.expect_local()).is_some()\n                 } else {\n                     false\n                 }\n             };\n-            if is_capturing_closure(prev_ty.kind()) || is_capturing_closure(new_ty.kind()) {\n+            if is_capturing_closure(prev_ty) || is_capturing_closure(new_ty) {\n                 (None, None)\n             } else {\n                 match (prev_ty.kind(), new_ty.kind()) {"}, {"sha": "37f9cdfeebc60096312decbfd01864c7f3954edf", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a053361a2871e286cf5cbc83cc2ed3926e1b4b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=40a053361a2871e286cf5cbc83cc2ed3926e1b4b", "patch": "@@ -342,10 +342,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &mut orig_values,\n         );\n \n-        let steps = if mode == Mode::MethodCall {\n-            self.tcx.method_autoderef_steps(param_env_and_self_ty)\n-        } else {\n-            self.probe(|_| {\n+        let steps = match mode {\n+            Mode::MethodCall => self.tcx.method_autoderef_steps(param_env_and_self_ty),\n+            Mode::Path => self.probe(|_| {\n                 // Mode::Path - the deref steps is \"trivial\". This turns\n                 // our CanonicalQuery into a \"trivial\" QueryResponse. This\n                 // is a bit inefficient, but I don't think that writing\n@@ -374,7 +373,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     opt_bad_ty: None,\n                     reached_recursion_limit: false,\n                 }\n-            })\n+            }),\n         };\n \n         // If our autoderef loop had reached the recursion limit,"}]}