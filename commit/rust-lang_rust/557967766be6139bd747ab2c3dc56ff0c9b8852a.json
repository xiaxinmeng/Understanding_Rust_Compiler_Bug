{"sha": "557967766be6139bd747ab2c3dc56ff0c9b8852a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1Nzk2Nzc2NmJlNjEzOWJkNzQ3YWIyYzNkYzU2ZmYwYzliODg1MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-26T18:11:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-26T18:11:54Z"}, "message": "Auto merge of #42081 - ishitatsuyuki:submodule-better, r=aidanhs\n\nUse the improved submodule handling\n\nr? @alexcrichton\n\nThat was a crap...\n```\nUpdating submodules\nTraceback (most recent call last):\n  File \"./x.py\", line 20, in <module>\n    bootstrap.main()\n  File \"/home/ishitatsuyuki/Documents/rust/src/bootstrap/bootstrap.py\", line 684, in main\n    bootstrap()\n  File \"/home/ishitatsuyuki/Documents/rust/src/bootstrap/bootstrap.py\", line 662, in bootstrap\n    rb.update_submodules()\n  File \"/home/ishitatsuyuki/Documents/rust/src/bootstrap/bootstrap.py\", line 566, in update_submodules\n    path = line[1:].split(' ')[1]\nTypeError: a bytes-like object is required, not 'str'\n```\n\nMaybe we need to confirm the compatibility of git options, such as `git config` or `git -C` (I believe they existed long before, though). This is tested locally.", "tree": {"sha": "a199a0aa0b68d70954669a6c2dd326762e6905f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a199a0aa0b68d70954669a6c2dd326762e6905f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/557967766be6139bd747ab2c3dc56ff0c9b8852a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/557967766be6139bd747ab2c3dc56ff0c9b8852a", "html_url": "https://github.com/rust-lang/rust/commit/557967766be6139bd747ab2c3dc56ff0c9b8852a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/557967766be6139bd747ab2c3dc56ff0c9b8852a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "256e497fe63bf4b13f7c0b58fa17360ca849c54d", "url": "https://api.github.com/repos/rust-lang/rust/commits/256e497fe63bf4b13f7c0b58fa17360ca849c54d", "html_url": "https://github.com/rust-lang/rust/commit/256e497fe63bf4b13f7c0b58fa17360ca849c54d"}, {"sha": "15c26c92ccbc3bbd26f6f3fa3ac72d3f1295991e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15c26c92ccbc3bbd26f6f3fa3ac72d3f1295991e", "html_url": "https://github.com/rust-lang/rust/commit/15c26c92ccbc3bbd26f6f3fa3ac72d3f1295991e"}], "stats": {"total": 164, "additions": 78, "deletions": 86}, "files": [{"sha": "971064fe9fedecda17297bae3a8b68c87bec0fdc", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 78, "deletions": 86, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/557967766be6139bd747ab2c3dc56ff0c9b8852a/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/557967766be6139bd747ab2c3dc56ff0c9b8852a/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=557967766be6139bd747ab2c3dc56ff0c9b8852a", "patch": "@@ -40,7 +40,8 @@ def get(url, path, verbose=False):\n                 return\n             else:\n                 if verbose:\n-                    print(\"ignoring already-download file \" + path + \" due to failed verification\")\n+                    print(\"ignoring already-download file \" +\n+                          path + \" due to failed verification\")\n                 os.unlink(path)\n         download(temp_path, url, True, verbose)\n         if not verify(temp_path, sha_path, verbose):\n@@ -100,8 +101,8 @@ def verify(path, sha_path, verbose):\n     verified = found == expected\n     if not verified:\n         print(\"invalid checksum:\\n\"\n-               \"    found:    {}\\n\"\n-               \"    expected: {}\".format(found, expected))\n+              \"    found:    {}\\n\"\n+              \"    expected: {}\".format(found, expected))\n     return verified\n \n \n@@ -127,20 +128,21 @@ def unpack(tarball, dst, verbose=False, match=None):\n             shutil.move(tp, fp)\n     shutil.rmtree(os.path.join(dst, fname))\n \n-def run(args, verbose=False, exception=False, cwd=None, env=None):\n+def run(args, verbose=False, exception=False, **kwargs):\n     if verbose:\n         print(\"running: \" + ' '.join(args))\n     sys.stdout.flush()\n     # Use Popen here instead of call() as it apparently allows powershell on\n     # Windows to not lock up waiting for input presumably.\n-    ret = subprocess.Popen(args, cwd=cwd, env=env)\n+    ret = subprocess.Popen(args, **kwargs)\n     code = ret.wait()\n     if code != 0:\n         err = \"failed to run: \" + ' '.join(args)\n         if verbose or exception:\n             raise RuntimeError(err)\n         sys.exit(err)\n \n+\n def stage0_data(rust_root):\n     nightlies = os.path.join(rust_root, \"src/stage0.txt\")\n     data = {}\n@@ -153,11 +155,13 @@ def stage0_data(rust_root):\n             data[a] = b\n     return data\n \n+\n def format_build_time(duration):\n     return str(datetime.timedelta(seconds=int(duration)))\n \n \n class RustBuild(object):\n+\n     def download_stage0(self):\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, self.stage0_date())\n@@ -172,11 +176,13 @@ def download_stage0(self):\n             self.print_what_it_means_to_bootstrap()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n-            filename = \"rust-std-{}-{}.tar.gz\".format(rustc_channel, self.build)\n+            filename = \"rust-std-{}-{}.tar.gz\".format(\n+                rustc_channel, self.build)\n             url = self._download_url + \"/dist/\" + self.stage0_date()\n             tarball = os.path.join(rustc_cache, filename)\n             if not os.path.exists(tarball):\n-                get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n+                get(\"{}/{}\".format(url, filename),\n+                    tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(),\n                    match=\"rust-std-\" + self.build,\n                    verbose=self.verbose)\n@@ -185,20 +191,25 @@ def download_stage0(self):\n             url = self._download_url + \"/dist/\" + self.stage0_date()\n             tarball = os.path.join(rustc_cache, filename)\n             if not os.path.exists(tarball):\n-                get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n-            unpack(tarball, self.bin_root(), match=\"rustc\", verbose=self.verbose)\n+                get(\"{}/{}\".format(url, filename),\n+                    tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(),\n+                   match=\"rustc\", verbose=self.verbose)\n             self.fix_executable(self.bin_root() + \"/bin/rustc\")\n             self.fix_executable(self.bin_root() + \"/bin/rustdoc\")\n             with open(self.rustc_stamp(), 'w') as f:\n                 f.write(self.stage0_date())\n \n             if \"pc-windows-gnu\" in self.build:\n-                filename = \"rust-mingw-{}-{}.tar.gz\".format(rustc_channel, self.build)\n+                filename = \"rust-mingw-{}-{}.tar.gz\".format(\n+                    rustc_channel, self.build)\n                 url = self._download_url + \"/dist/\" + self.stage0_date()\n                 tarball = os.path.join(rustc_cache, filename)\n                 if not os.path.exists(tarball):\n-                    get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n-                unpack(tarball, self.bin_root(), match=\"rust-mingw\", verbose=self.verbose)\n+                    get(\"{}/{}\".format(url, filename),\n+                        tarball, verbose=self.verbose)\n+                unpack(tarball, self.bin_root(),\n+                       match=\"rust-mingw\", verbose=self.verbose)\n \n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n@@ -207,8 +218,10 @@ def download_stage0(self):\n             url = self._download_url + \"/dist/\" + self.stage0_date()\n             tarball = os.path.join(rustc_cache, filename)\n             if not os.path.exists(tarball):\n-                get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n-            unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n+                get(\"{}/{}\".format(url, filename),\n+                    tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(),\n+                   match=\"cargo\", verbose=self.verbose)\n             self.fix_executable(self.bin_root() + \"/bin/cargo\")\n             with open(self.cargo_stamp(), 'w') as f:\n                 f.write(self.stage0_date())\n@@ -218,7 +231,8 @@ def fix_executable(self, fname):\n \n         default_encoding = sys.getdefaultencoding()\n         try:\n-            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n+            ostype = subprocess.check_output(\n+                ['uname', '-s']).strip().decode(default_encoding)\n         except (subprocess.CalledProcessError, WindowsError):\n             return\n \n@@ -234,7 +248,8 @@ def fix_executable(self, fname):\n         print(\"info: you seem to be running NixOS. Attempting to patch \" + fname)\n \n         try:\n-            interpreter = subprocess.check_output([\"patchelf\", \"--print-interpreter\", fname])\n+            interpreter = subprocess.check_output(\n+                [\"patchelf\", \"--print-interpreter\", fname])\n             interpreter = interpreter.strip().decode(default_encoding)\n         except subprocess.CalledProcessError as e:\n             print(\"warning: failed to call patchelf: %s\" % e)\n@@ -243,7 +258,8 @@ def fix_executable(self, fname):\n         loader = interpreter.split(\"/\")[-1]\n \n         try:\n-            ldd_output = subprocess.check_output(['ldd', '/run/current-system/sw/bin/sh'])\n+            ldd_output = subprocess.check_output(\n+                ['ldd', '/run/current-system/sw/bin/sh'])\n             ldd_output = ldd_output.strip().decode(default_encoding)\n         except subprocess.CalledProcessError as e:\n             print(\"warning: unable to call ldd: %s\" % e)\n@@ -261,7 +277,8 @@ def fix_executable(self, fname):\n         correct_interpreter = loader_path + loader\n \n         try:\n-            subprocess.check_output([\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n+            subprocess.check_output(\n+                [\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n         except subprocess.CalledProcessError as e:\n             print(\"warning: failed to call patchelf: %s\" % e)\n             return\n@@ -371,16 +388,16 @@ def build_bootstrap(self):\n         env[\"CARGO_TARGET_DIR\"] = build_dir\n         env[\"RUSTC\"] = self.rustc()\n         env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n-                                 (os.pathsep + env[\"LD_LIBRARY_PATH\"]) \\\n-                                 if \"LD_LIBRARY_PATH\" in env else \"\"\n+            (os.pathsep + env[\"LD_LIBRARY_PATH\"]) \\\n+            if \"LD_LIBRARY_PATH\" in env else \"\"\n         env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n-                                   (os.pathsep + env[\"DYLD_LIBRARY_PATH\"]) \\\n-                                   if \"DYLD_LIBRARY_PATH\" in env else \"\"\n+            (os.pathsep + env[\"DYLD_LIBRARY_PATH\"]) \\\n+            if \"DYLD_LIBRARY_PATH\" in env else \"\"\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n-                                   (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n-                                   if \"LIBRARY_PATH\" in env else \"\"\n+            (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n+            if \"LIBRARY_PATH\" in env else \"\"\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n-                      os.pathsep + env[\"PATH\"]\n+            os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n             raise Exception(\"no cargo executable found at `%s`\" % self.cargo())\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n@@ -395,16 +412,6 @@ def build_bootstrap(self):\n             args.append(\"--frozen\")\n         run(args, env=env, verbose=self.verbose)\n \n-    def output(self, args, env=None, cwd=None):\n-        default_encoding = sys.getdefaultencoding()\n-        proc = subprocess.Popen(args, stdout=subprocess.PIPE, env=env, cwd=cwd)\n-        (out, err) = proc.communicate()\n-        ret = proc.wait()\n-        if ret != 0:\n-            print(out)\n-            sys.exit(ret)\n-        return out.decode(default_encoding)\n-\n     def build_triple(self):\n         default_encoding = sys.getdefaultencoding()\n         config = self.get_toml('build')\n@@ -414,8 +421,10 @@ def build_triple(self):\n         if config:\n             return config\n         try:\n-            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n-            cputype = subprocess.check_output(['uname', '-m']).strip().decode(default_encoding)\n+            ostype = subprocess.check_output(\n+                ['uname', '-s']).strip().decode(default_encoding)\n+            cputype = subprocess.check_output(\n+                ['uname', '-m']).strip().decode(default_encoding)\n         except (subprocess.CalledProcessError, OSError):\n             if sys.platform == 'win32':\n                 return 'x86_64-pc-windows-msvc'\n@@ -427,7 +436,8 @@ def build_triple(self):\n         # The goal here is to come up with the same triple as LLVM would,\n         # at least for the subset of platforms we're willing to target.\n         if ostype == 'Linux':\n-            os_from_sp = subprocess.check_output(['uname', '-o']).strip().decode(default_encoding)\n+            os_from_sp = subprocess.check_output(\n+                ['uname', '-o']).strip().decode(default_encoding)\n             if os_from_sp == 'Android':\n                 ostype = 'linux-android'\n             else:\n@@ -451,7 +461,7 @@ def build_triple(self):\n             # must be used instead.\n             try:\n                 cputype = subprocess.check_output(['isainfo',\n-                  '-k']).strip().decode(default_encoding)\n+                                                   '-k']).strip().decode(default_encoding)\n             except (subprocess.CalledProcessError, OSError):\n                 err = \"isainfo not found\"\n                 if self.verbose:\n@@ -544,51 +554,29 @@ def build_triple(self):\n \n     def update_submodules(self):\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n-            self.get_toml('submodules') == \"false\" or \\\n-            self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n+                self.get_toml('submodules') == \"false\" or \\\n+                self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n             return\n-\n         print('Updating submodules')\n-        output = self.output([\"git\", \"submodule\", \"status\"], cwd=self.rust_root)\n-        submodules = []\n-        for line in output.splitlines():\n-            # NOTE `git submodule status` output looks like this:\n-            #\n-            # -5066b7dcab7e700844b0e2ba71b8af9dc627a59b src/liblibc\n-            # +b37ef24aa82d2be3a3cc0fe89bf82292f4ca181c src/compiler-rt (remotes/origin/..)\n-            #  e058ca661692a8d01f8cf9d35939dfe3105ce968 src/jemalloc (3.6.0-533-ge058ca6)\n-            #\n-            # The first character can be '-', '+' or ' ' and denotes the\n-            # `State` of the submodule Right next to this character is the\n-            # SHA-1 of the submodule HEAD And after that comes the path to the\n-            # submodule\n-            path = line[1:].split(' ')[1]\n-            submodules.append([path, line[0]])\n-\n-        run([\"git\", \"submodule\", \"sync\"], cwd=self.rust_root)\n-\n-        for submod in submodules:\n-            path, status = submod\n-            if path.endswith('llvm') and \\\n-                (self.get_toml('llvm-config') or self.get_mk('CFG_LLVM_ROOT')):\n-                continue\n-            if path.endswith('jemalloc') and \\\n-                (self.get_toml('jemalloc') or self.get_mk('CFG_JEMALLOC_ROOT')):\n-                continue\n-            submod_path = os.path.join(self.rust_root, path)\n-\n-            if status == ' ':\n-                run([\"git\", \"reset\", \"--hard\"], cwd=submod_path)\n-                run([\"git\", \"clean\", \"-fdx\"], cwd=submod_path)\n-            elif status == '+':\n-                run([\"git\", \"submodule\", \"update\", path], cwd=self.rust_root)\n-                run([\"git\", \"reset\", \"--hard\"], cwd=submod_path)\n-                run([\"git\", \"clean\", \"-fdx\"], cwd=submod_path)\n-            elif status == '-':\n-                run([\"git\", \"submodule\", \"init\", path], cwd=self.rust_root)\n-                run([\"git\", \"submodule\", \"update\", path], cwd=self.rust_root)\n-            else:\n-                raise ValueError('unknown submodule status: ' + status)\n+        default_encoding = sys.getdefaultencoding()\n+        run([\"git\", \"submodule\", \"-q\", \"sync\"], cwd=self.rust_root)\n+        submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n+            [\"git\", \"config\", \"--file\", os.path.join(self.rust_root, \".gitmodules\"),\n+             \"--get-regexp\", \"path\"]\n+        ).decode(default_encoding).splitlines()]\n+        submodules = [module for module in submodules\n+                      if not ((module.endswith(\"llvm\") and\n+                               (self.get_toml('llvm-config') or self.get_mk('CFG_LLVM_ROOT'))) or\n+                              (module.endswith(\"jemalloc\") and\n+                               (self.get_toml('jemalloc') or self.get_mk('CFG_JEMALLOC_ROOT'))))\n+                     ]\n+        run([\"git\", \"submodule\", \"update\",\n+                  \"--init\"] + submodules, cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n+                  \"reset\", \"-q\", \"--hard\"], cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n+                  \"clean\", \"-qdfx\"], cwd=self.rust_root, verbose=self.verbose)\n+\n \n def bootstrap():\n     parser = argparse.ArgumentParser(description='Build rust')\n@@ -641,7 +629,7 @@ def bootstrap():\n     if rb.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n             os.makedirs('.cargo')\n-        with open('.cargo/config','w') as f:\n+        with open('.cargo/config', 'w') as f:\n             f.write(\"\"\"\n                 [source.crates-io]\n                 replace-with = 'vendored-sources'\n@@ -681,21 +669,25 @@ def bootstrap():\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     run(args, env=env, verbose=rb.verbose)\n \n+\n def main():\n     start_time = time()\n-    help_triggered = ('-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n+    help_triggered = (\n+        '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n         bootstrap()\n         if not help_triggered:\n-            print(\"Build completed successfully in %s\" % format_build_time(time() - start_time))\n+            print(\"Build completed successfully in %s\" %\n+                  format_build_time(time() - start_time))\n     except (SystemExit, KeyboardInterrupt) as e:\n         if hasattr(e, 'code') and isinstance(e.code, int):\n             exit_code = e.code\n         else:\n             exit_code = 1\n             print(e)\n         if not help_triggered:\n-            print(\"Build completed unsuccessfully in %s\" % format_build_time(time() - start_time))\n+            print(\"Build completed unsuccessfully in %s\" %\n+                  format_build_time(time() - start_time))\n         sys.exit(exit_code)\n \n if __name__ == '__main__':"}]}