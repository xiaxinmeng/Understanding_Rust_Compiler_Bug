{"sha": "f229422cc1a0d46d15a7f953f59d8e057ae03865", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMjk0MjJjYzFhMGQ0NmQxNWE3Zjk1M2Y1OWQ4ZTA1N2FlMDM4NjU=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-03-12T17:58:30Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-03-25T18:31:19Z"}, "message": "SGX target: fix std unit tests", "tree": {"sha": "c903a58406eb4f3de4a338ad8b37388ca364c719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c903a58406eb4f3de4a338ad8b37388ca364c719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f229422cc1a0d46d15a7f953f59d8e057ae03865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f229422cc1a0d46d15a7f953f59d8e057ae03865", "html_url": "https://github.com/rust-lang/rust/commit/f229422cc1a0d46d15a7f953f59d8e057ae03865", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f229422cc1a0d46d15a7f953f59d8e057ae03865/comments", "author": null, "committer": null, "parents": [{"sha": "2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "html_url": "https://github.com/rust-lang/rust/commit/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff"}], "stats": {"total": 330, "additions": 236, "deletions": 94}, "files": [{"sha": "b2eaf956d0e2d5b66dfc2ee8ab77ed3a38a656a8", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -72,3 +72,7 @@ wasm-bindgen-threads = []\n # https://github.com/rust-lang-nursery/stdsimd/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []\n std_detect_dlsym_getauxval = []\n+\n+[package.metadata.fortanix-sgx]\n+# Maximum possible number of threads when testing\n+threads = 125"}, {"sha": "f723a2b0bb281eeab9677338cc2cefb40df7ac44", "filename": "src/libstd/env.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -975,7 +975,7 @@ mod tests {\n     use crate::path::Path;\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    #[cfg_attr(any(target_os = \"emscripten\", target_env = \"sgx\"), ignore)]\n     fn test_self_exe_path() {\n         let path = current_exe();\n         assert!(path.is_ok());\n@@ -989,6 +989,7 @@ mod tests {\n     fn test() {\n         assert!((!Path::new(\"test-path\").is_absolute()));\n \n+        #[cfg(not(target_env = \"sgx\"))]\n         current_dir().unwrap();\n     }\n "}, {"sha": "dfff44b88ea784e3598285ca9555f18db0d5255c", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -2095,7 +2095,7 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n     }\n }\n \n-#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n mod tests {\n     use crate::io::prelude::*;\n "}, {"sha": "eaa6a070154f7ed684401b0424c13d92159ffcf3", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -941,7 +941,10 @@ mod tests {\n         assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n \n         let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n+        #[cfg(not(target_env = \"sgx\"))]\n         assert!(tsa((\"localhost\", 23924)).unwrap().contains(&a));\n+        #[cfg(target_env = \"sgx\")]\n+        let _ = a;\n     }\n \n     #[test]\n@@ -953,7 +956,10 @@ mod tests {\n         assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n \n         let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n+        #[cfg(not(target_env = \"sgx\"))]\n         assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n+        #[cfg(target_env = \"sgx\")]\n+        let _ = a;\n     }\n \n     #[test]"}, {"sha": "7e14de7cc4f4a8b0b49eb8c2b77a7ba5a43d50db", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -929,12 +929,12 @@ impl fmt::Debug for TcpListener {\n \n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n+    use crate::fmt;\n     use crate::io::{ErrorKind, IoVec, IoVecMut};\n     use crate::io::prelude::*;\n     use crate::net::*;\n     use crate::net::test::{next_test_ip4, next_test_ip6};\n     use crate::sync::mpsc::channel;\n-    use crate::sys_common::AsInner;\n     use crate::time::{Instant, Duration};\n     use crate::thread;\n \n@@ -1129,7 +1129,7 @@ mod tests {\n                 connect(i + 1, addr);\n                 t!(stream.write(&[i as u8]));\n             });\n-            t.join().ok().unwrap();\n+            t.join().ok().expect(\"thread panicked\");\n         }\n     }\n \n@@ -1162,7 +1162,7 @@ mod tests {\n                 connect(i + 1, addr);\n                 t!(stream.write(&[99]));\n             });\n-            t.join().ok().unwrap();\n+            t.join().ok().expect(\"thread panicked\");\n         }\n     }\n \n@@ -1377,6 +1377,8 @@ mod tests {\n     }\n \n     #[test]\n+    // FIXME: https://github.com/fortanix/rust-sgx/issues/110\n+    #[cfg_attr(target_env = \"sgx\", ignore)]\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -1397,6 +1399,8 @@ mod tests {\n     }\n \n     #[test]\n+    // FIXME: https://github.com/fortanix/rust-sgx/issues/110\n+    #[cfg_attr(target_env = \"sgx\", ignore)]\n     fn close_readwrite_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -1550,30 +1554,51 @@ mod tests {\n \n     #[test]\n     fn debug() {\n-        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        #[cfg(not(target_env = \"sgx\"))]\n+        fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n+            addr\n+        }\n+        #[cfg(target_env = \"sgx\")]\n+        fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n+            addr.to_string()\n+        }\n+\n+        #[cfg(unix)]\n+        use crate::os::unix::io::AsRawFd;\n+        #[cfg(target_env = \"sgx\")]\n+        use crate::os::fortanix_sgx::io::AsRawFd;\n+        #[cfg(not(windows))]\n+        fn render_inner(addr: &dyn AsRawFd) -> impl fmt::Debug {\n+            addr.as_raw_fd()\n+        }\n+        #[cfg(windows)]\n+        fn render_inner(addr: &dyn crate::os::windows::io::AsRawSocket) -> impl fmt::Debug {\n+            addr.as_raw_socket()\n+        }\n+\n+        let inner_name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n         let socket_addr = next_test_ip4();\n \n         let listener = t!(TcpListener::bind(&socket_addr));\n-        let listener_inner = listener.0.socket().as_inner();\n         let compare = format!(\"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n-                              socket_addr, name, listener_inner);\n+                              render_socket_addr(&socket_addr),\n+                              inner_name,\n+                              render_inner(&listener));\n         assert_eq!(format!(\"{:?}\", listener), compare);\n \n-        let stream = t!(TcpStream::connect(&(\"localhost\",\n-                                                 socket_addr.port())));\n-        let stream_inner = stream.0.socket().as_inner();\n-        let compare = format!(\"TcpStream {{ addr: {:?}, \\\n-                              peer: {:?}, {}: {:?} }}\",\n-                              stream.local_addr().unwrap(),\n-                              stream.peer_addr().unwrap(),\n-                              name,\n-                              stream_inner);\n+        let stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n+        let compare = format!(\"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n+                              render_socket_addr(&stream.local_addr().unwrap()),\n+                              render_socket_addr(&stream.peer_addr().unwrap()),\n+                              inner_name,\n+                              render_inner(&stream));\n         assert_eq!(format!(\"{:?}\", stream), compare);\n     }\n \n     // FIXME: re-enabled bitrig/openbsd tests once their socket timeout code\n     //        no longer has rounding errors.\n     #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     #[test]\n     fn timeouts() {\n         let addr = next_test_ip4();\n@@ -1601,6 +1626,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_read_timeout() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1618,6 +1644,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_read_with_timeout() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1661,6 +1688,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)]\n     fn nodelay() {\n         let addr = next_test_ip4();\n         let _listener = t!(TcpListener::bind(&addr));\n@@ -1675,6 +1703,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)]\n     fn ttl() {\n         let ttl = 100;\n \n@@ -1691,6 +1720,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)]\n     fn set_nonblocking() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1712,6 +1742,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn peek() {\n         each_ip(&mut |addr| {\n             let (txdone, rxdone) = channel();\n@@ -1743,6 +1774,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn connect_timeout_valid() {\n         let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n         let addr = listener.local_addr().unwrap();"}, {"sha": "e2991cbdd88226c3abf6ba2cbf7b08ca82f71678", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -36,12 +36,16 @@ pub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n // all want to use ports. This function figures out which workspace\n // it is running in and assigns a port range based on it.\n fn base_port() -> u16 {\n-    let cwd = env::current_dir().unwrap();\n+    let cwd = if cfg!(target_env = \"sgx\") {\n+        String::from(\"sgx\")\n+    } else {\n+        env::current_dir().unwrap().into_os_string().into_string().unwrap()\n+    };\n     let dirs = [\"32-opt\", \"32-nopt\",\n                 \"musl-64-opt\", \"cross-opt\",\n                 \"64-opt\", \"64-nopt\", \"64-opt-vg\", \"64-debug-opt\",\n-                \"all-opt\", \"snap3\", \"dist\"];\n+                \"all-opt\", \"snap3\", \"dist\", \"sgx\"];\n     dirs.iter().enumerate().find(|&(_, dir)| {\n-        cwd.to_str().unwrap().contains(dir)\n+        cwd.contains(dir)\n     }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n }"}, {"sha": "951f385fb3ea52c9da4952185d73f8330d15cb81", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -806,7 +806,7 @@ impl fmt::Debug for UdpSocket {\n     }\n }\n \n-#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n mod tests {\n     use crate::io::ErrorKind;\n     use crate::net::*;"}, {"sha": "4048bc4da2557f0434c33bd9ef8aca9c90a972b1", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -3801,7 +3801,7 @@ mod tests {\n             });\n         );\n \n-        if cfg!(unix) {\n+        if cfg!(unix) || cfg!(all(target_env = \"sgx\", target_vendor = \"fortanix\")) {\n             tp!(\"\", \"foo\", \"foo\");\n             tp!(\"foo\", \"bar\", \"foo/bar\");\n             tp!(\"foo/\", \"bar\", \"foo/bar\");\n@@ -3960,7 +3960,7 @@ mod tests {\n         tfn!(\"foo\", \"bar\", \"bar\");\n         tfn!(\"foo\", \"\", \"\");\n         tfn!(\"\", \"foo\", \"foo\");\n-        if cfg!(unix) {\n+        if cfg!(unix) || cfg!(all(target_env = \"sgx\", target_vendor = \"fortanix\")) {\n             tfn!(\".\", \"foo\", \"./foo\");\n             tfn!(\"foo/\", \"bar\", \"bar\");\n             tfn!(\"foo/.\", \"bar\", \"bar\");"}, {"sha": "054b398b01f26a414bef98dae648e2458c3d883b", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -1621,7 +1621,7 @@ impl Termination for ExitCode {\n     }\n }\n \n-#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n mod tests {\n     use crate::io::prelude::*;\n "}, {"sha": "2e8182671dd6f4d84299e39c8559b4073a06f5a8", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -705,6 +705,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -724,6 +725,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_until_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -748,6 +750,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_until_wake() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n@@ -771,6 +774,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wake() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());"}, {"sha": "4ed2bfb175a464da1bcb1ba0a3d46810dd3ac3a2", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -1951,7 +1951,7 @@ mod tests {\n         for _ in 0..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n         }\n-        t.join().ok().unwrap();\n+        t.join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -1977,7 +1977,7 @@ mod tests {\n             });\n         }\n         drop(tx);\n-        t.join().ok().unwrap();\n+        t.join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -1996,8 +1996,8 @@ mod tests {\n                 tx2.send(1).unwrap();\n             }\n         });\n-        t1.join().ok().unwrap();\n-        t2.join().ok().unwrap();\n+        t1.join().ok().expect(\"thread panicked\");\n+        t2.join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -2011,7 +2011,7 @@ mod tests {\n         for _ in 0..40 {\n             tx.send(1).unwrap();\n         }\n-        t.join().ok().unwrap();\n+        t.join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -2026,8 +2026,8 @@ mod tests {\n             tx1.send(1).unwrap();\n             assert_eq!(rx2.recv().unwrap(), 2);\n         });\n-        t1.join().ok().unwrap();\n-        t2.join().ok().unwrap();\n+        t1.join().ok().expect(\"thread panicked\");\n+        t2.join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -2225,6 +2225,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn oneshot_single_thread_recv_timeout() {\n         let (tx, rx) = channel();\n         tx.send(()).unwrap();\n@@ -2235,6 +2236,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2265,6 +2267,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout_upgrade() {\n         let (tx, rx) = channel::<()>();\n         let timeout = Duration::from_millis(1);\n@@ -2276,6 +2279,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2306,6 +2310,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n         let join_handle = thread::spawn(move || {\n@@ -2325,6 +2330,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn shared_recv_timeout() {\n         let (tx, rx) = channel();\n         let total = 5;\n@@ -2550,6 +2556,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n@@ -2639,6 +2646,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n@@ -2662,6 +2670,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;"}, {"sha": "85ec8be4aae69bf157b89a7e6c86209279a20dc6", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -1,3 +1,5 @@\n+#![cfg_attr(test, allow(unused))] // RT initialization logic is not compiled for test\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n use crate::io::Write;\n \n@@ -12,8 +14,10 @@ pub mod tls;\n #[macro_use]\n pub mod usercalls;\n \n+#[cfg(not(test))]\n global_asm!(include_str!(\"entry.S\"));\n \n+#[cfg(not(test))]\n #[no_mangle]\n unsafe extern \"C\" fn tcs_init(secondary: bool) {\n     // Be very careful when changing this code: it runs before the binary has been\n@@ -48,6 +52,7 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n // FIXME: this item should only exist if this is linked into an executable\n // (main function exists). If this is a library, the crate author should be\n // able to specify this\n+#[cfg(not(test))]\n #[no_mangle]\n extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64) {\n     // FIXME: how to support TLS in library mode?"}, {"sha": "de86394b4b88cdfd8013b57b089988f60567df04", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -49,7 +49,7 @@ impl Write for SgxPanicOutput {\n     }\n }\n \n-#[no_mangle]\n+#[cfg_attr(not(test), no_mangle)]\n pub extern \"C\" fn panic_msg(msg: &str) -> ! {\n     let _ = SgxPanicOutput::new().map(|mut out| out.write(msg.as_bytes()));\n     usercalls::exit(true)"}, {"sha": "6b9ab7e383c01565f27fc18664ae768f1af6d5c8", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -10,45 +10,16 @@ const USIZE_BITS: usize = 64;\n const TLS_KEYS: usize = 128; // Same as POSIX minimum\n const TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n \n+#[cfg_attr(test, linkage = \"available_externally\")]\n+#[export_name = \"_ZN16__rust_internals3std3sys3sgx3abi3tls14TLS_KEY_IN_USEE\"]\n static TLS_KEY_IN_USE: SyncBitset = SYNC_BITSET_INIT;\n macro_rules! dup {\n     ((* $($exp:tt)*) $($val:tt)*) => (dup!( ($($exp)*) $($val)* $($val)* ));\n     (() $($val:tt)*) => ([$($val),*])\n }\n-static TLS_DESTRUCTOR: [AtomicUsize; TLS_KEYS] = [\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-];\n+#[cfg_attr(test, linkage = \"available_externally\")]\n+#[export_name = \"_ZN16__rust_internals3std3sys3sgx3abi3tls14TLS_DESTRUCTORE\"]\n+static TLS_DESTRUCTOR: [AtomicUsize; TLS_KEYS] = dup!((* * * * * * *) (AtomicUsize::new(0)));\n \n extern \"C\" {\n     fn get_tls_ptr() -> *const u8;"}, {"sha": "449a5fe5ae3082a837e1f5d7c744e1bb7228c8a3", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -188,8 +188,13 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n     // from outside as obtained by `super::alloc`.\n     fn new_uninit_bytes(size: usize) -> Self {\n         unsafe {\n-            let ptr = super::alloc(size, T::align_of()).expect(\"User memory allocation failed\");\n-            User(NonNull::new_userref(T::from_raw_sized(ptr as _, size)))\n+            // Mustn't call alloc with size 0.\n+            let ptr = if size > 0 {\n+                super::alloc(size, T::align_of()).expect(\"User memory allocation failed\") as _\n+            } else {\n+                T::align_of() as _ // dangling pointer ok for size 0\n+            };\n+            User(NonNull::new_userref(T::from_raw_sized(ptr, size)))\n         }\n     }\n "}, {"sha": "98eb8397436bfeb98b06852cea90c6e541c5e5ed", "filename": "src/libstd/sys/sgx/alloc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -4,6 +4,8 @@ use super::waitqueue::SpinMutex;\n \n // Using a SpinMutex because we never want to exit the enclave waiting for the\n // allocator.\n+#[cfg_attr(test, linkage = \"available_externally\")]\n+#[export_name = \"_ZN16__rust_internals3std3sys3sgx5alloc8DLMALLOCE\"]\n static DLMALLOC: SpinMutex<dlmalloc::Dlmalloc> = SpinMutex::new(dlmalloc::DLMALLOC_INIT);\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]"}, {"sha": "a84ab4138761ef6fd672e59c3c9e5aabe045eeea", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -5,9 +5,12 @@ use crate::sys::os_str::Buf;\n use crate::sys_common::FromInner;\n use crate::slice;\n \n+#[cfg_attr(test, linkage = \"available_externally\")]\n+#[export_name = \"_ZN16__rust_internals3std3sys3sgx4args4ARGSE\"]\n static ARGS: AtomicUsize = AtomicUsize::new(0);\n type ArgsStore = Vec<OsString>;\n \n+#[cfg_attr(test, allow(dead_code))]\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     if argc != 0 {\n         let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);"}, {"sha": "f9a76f0baf51a383ef5c18ce02b3c01befd17b55", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -32,7 +32,8 @@ impl Condvar {\n         mutex.lock()\n     }\n \n-    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, _dur: Duration) -> bool {\n+        mutex.unlock(); // don't hold the lock while panicking\n         panic!(\"timeout not supported in SGX\");\n     }\n "}, {"sha": "592b300ac667c0a3f99e401550e40ad4a5535778", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -41,12 +41,29 @@ impl FromInner<FileDesc> for Socket {\n     }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n pub struct TcpStream {\n     inner: Socket,\n     peer_addr: Option<String>,\n }\n \n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut res = f.debug_struct(\"TcpStream\");\n+\n+        if let Some(ref addr) = self.inner.local_addr {\n+            res.field(\"addr\", addr);\n+        }\n+\n+        if let Some(ref peer) = self.peer_addr {\n+            res.field(\"peer\", peer);\n+        }\n+\n+        res.field(\"fd\", &self.inner.inner.as_inner())\n+            .finish()\n+    }\n+}\n+\n fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n     match result {\n         Ok(saddr) => Ok(saddr.to_string()),\n@@ -75,16 +92,32 @@ impl TcpStream {\n         Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr: Some(peer_addr) })\n     }\n \n-    pub fn connect_timeout(addr: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+    pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n+        if dur == Duration::default() {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"cannot set a 0 duration timeout\"));\n+        }\n         Self::connect(Ok(addr)) // FIXME: ignoring timeout\n     }\n \n-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        sgx_ineffective(())\n+    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        match dur {\n+            Some(dur) if dur == Duration::default() => {\n+                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                          \"cannot set a 0 duration timeout\"));\n+            }\n+            _ => sgx_ineffective(())\n+        }\n     }\n \n-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        sgx_ineffective(())\n+    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        match dur {\n+            Some(dur) if dur == Duration::default() => {\n+                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                          \"cannot set a 0 duration timeout\"));\n+            }\n+            _ => sgx_ineffective(())\n+        }\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n@@ -174,11 +207,24 @@ impl FromInner<(Socket, Option<String>)> for TcpStream {\n     }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n pub struct TcpListener {\n     inner: Socket,\n }\n \n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut res = f.debug_struct(\"TcpListener\");\n+\n+        if let Some(ref addr) = self.inner.local_addr {\n+            res.field(\"addr\", addr);\n+        }\n+\n+        res.field(\"fd\", &self.inner.inner.as_inner())\n+            .finish()\n+    }\n+}\n+\n impl TcpListener {\n     pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n         let addr = io_err_to_addr(addr)?;"}, {"sha": "0bb7b897058db08878ca2e28df709d6384deb398", "filename": "src/libstd/sys/sgx/os.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -73,7 +73,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     unsupported()\n }\n \n+#[cfg_attr(test, linkage = \"available_externally\")]\n+#[export_name = \"_ZN16__rust_internals3std3sys3sgx2os3ENVE\"]\n static ENV: AtomicUsize = AtomicUsize::new(0);\n+#[cfg_attr(test, linkage = \"available_externally\")]\n+#[export_name = \"_ZN16__rust_internals3std3sys3sgx2os8ENV_INITE\"]\n static ENV_INIT: Once = Once::new();\n type EnvStore = Mutex<HashMap<OsString, OsString>>;\n "}, {"sha": "7b113267865b6cde073e02309fdeb9a99459a19b", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -1,6 +1,9 @@\n+#[cfg(not(test))]\n use crate::alloc::{self, Layout};\n use crate::num::NonZeroUsize;\n+#[cfg(not(test))]\n use crate::slice;\n+#[cfg(not(test))]\n use crate::str;\n \n use super::waitqueue::{\n@@ -147,6 +150,7 @@ impl RWLock {\n \n     // only used by __rust_rwlock_unlock below\n     #[inline]\n+    #[cfg_attr(test, allow(dead_code))]\n     unsafe fn unlock(&self) {\n         let rguard = self.readers.lock();\n         let wguard = self.writer.lock();\n@@ -161,9 +165,11 @@ impl RWLock {\n     pub unsafe fn destroy(&self) {}\n }\n \n+#[cfg(not(test))]\n const EINVAL: i32 = 22;\n \n // used by libunwind port\n+#[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n@@ -173,6 +179,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n     return 0;\n }\n \n+#[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n@@ -181,6 +188,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n     (*p).write();\n     return 0;\n }\n+#[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n@@ -192,6 +200,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n \n // the following functions are also used by the libunwind port. They're\n // included here to make sure parallel codegen and LTO don't mess things up.\n+#[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n     if s < 0 {\n@@ -203,33 +212,34 @@ pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n     }\n }\n \n+#[cfg(not(test))]\n #[no_mangle]\n // NB. used by both libunwind and libpanic_abort\n pub unsafe extern \"C\" fn __rust_abort() {\n     crate::sys::abort_internal();\n }\n \n+#[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n     alloc::alloc(Layout::from_size_align_unchecked(size, align))\n }\n \n+#[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n     alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n }\n \n #[cfg(test)]\n mod tests {\n-\n     use super::*;\n     use core::array::FixedSizeArray;\n-    use crate::mem::MaybeUninit;\n-    use crate::{mem, ptr};\n+    use crate::mem::{self, MaybeUninit};\n \n-    // The below test verifies that the bytes of initialized RWLock are the ones\n-    // we use in libunwind.\n-    // If they change we need to update src/UnwindRustSgx.h in libunwind.\n+    // Verify that the bytes of initialized RWLock are the same as in\n+    // libunwind. If they change, `src/UnwindRustSgx.h` in libunwind needs to\n+    // be changed too.\n     #[test]\n     fn test_c_rwlock_initializer() {\n         const RWLOCK_INIT: &[u8] = &[\n@@ -251,11 +261,28 @@ mod tests {\n             0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n         ];\n \n-        let mut init = MaybeUninit::<RWLock>::zeroed();\n-        init.set(RWLock::new());\n-        assert_eq!(\n-            mem::transmute::<_, [u8; 128]>(init.into_inner()).as_slice(),\n-            RWLOCK_INIT\n-        );\n+        #[inline(never)]\n+        fn zero_stack() {\n+            test::black_box(MaybeUninit::<[RWLock; 16]>::zeroed());\n+        }\n+\n+        #[inline(never)]\n+        unsafe fn rwlock_new(init: &mut MaybeUninit<RWLock>) {\n+            init.set(RWLock::new());\n+        }\n+\n+        unsafe {\n+            // try hard to make sure that the padding/unused bytes in RWLock\n+            // get initialized as 0. If the assertion below fails, that might\n+            // just be an issue with the test code and not with the value of\n+            // RWLOCK_INIT.\n+            zero_stack();\n+            let mut init = MaybeUninit::<RWLock>::zeroed();\n+            rwlock_new(&mut init);\n+            assert_eq!(\n+                mem::transmute::<_, [u8; 128]>(init.into_initialized()).as_slice(),\n+                RWLOCK_INIT\n+            )\n+        };\n     }\n }"}, {"sha": "e63fa2bed65d56700f5a67447f5bc134602bf205", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -6,6 +6,7 @@ impl Handler {\n     }\n }\n \n+#[cfg_attr(test, allow(dead_code))]\n pub unsafe fn init() {\n }\n "}, {"sha": "a3637723ba1bd05611daf419248562941587fce7", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -1,3 +1,4 @@\n+#![cfg_attr(test, allow(dead_code))] // why is this necessary?\n use crate::boxed::FnBox;\n use crate::ffi::CStr;\n use crate::io;\n@@ -33,7 +34,11 @@ mod task_queue {\n         }\n     }\n \n+    #[cfg_attr(test, linkage = \"available_externally\")]\n+    #[export_name = \"_ZN16__rust_internals3std3sys3sgx6thread15TASK_QUEUE_INITE\"]\n     static TASK_QUEUE_INIT: Once = Once::new();\n+    #[cfg_attr(test, linkage = \"available_externally\")]\n+    #[export_name = \"_ZN16__rust_internals3std3sys3sgx6thread10TASK_QUEUEE\"]\n     static mut TASK_QUEUE: Option<Mutex<Vec<Task>>> = None;\n \n     pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {"}, {"sha": "3f5e03ddad69eee59068aa76735f8a98ba1cc1a0", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -498,6 +498,7 @@ mod spin_mutex {\n         use super::*;\n         use crate::sync::Arc;\n         use crate::thread;\n+        use crate::time::{SystemTime, Duration};\n \n         #[test]\n         fn sleep() {\n@@ -507,7 +508,13 @@ mod spin_mutex {\n             let t1 = thread::spawn(move || {\n                 *mutex2.lock() = 1;\n             });\n-            thread::sleep_ms(50);\n+\n+            // \"sleep\" for 50ms\n+            // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n+            let start = SystemTime::now();\n+            let max = Duration::from_millis(50);\n+            while start.elapsed().unwrap() < max {}\n+\n             assert_eq!(*guard, 0);\n             drop(guard);\n             t1.join().unwrap();\n@@ -530,7 +537,8 @@ mod tests {\n         let locked = wq.lock();\n \n         let t1 = thread::spawn(move || {\n-            assert!(WaitQueue::notify_one(wq2.lock()).is_none())\n+            // if we obtain the lock, the main thread should be waiting\n+            assert!(WaitQueue::notify_one(wq2.lock()).is_ok());\n         });\n \n         WaitQueue::wait(locked);"}, {"sha": "b73c5856b8805bdd91cee0c7a9363734694ac081", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -530,7 +530,7 @@ mod tests {\n \n         thread::spawn(|| {\n             assert!(FOO.try_with(|_| ()).is_ok());\n-        }).join().ok().unwrap();\n+        }).join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -584,7 +584,7 @@ mod tests {\n \n         thread::spawn(move|| {\n             drop(S1);\n-        }).join().ok().unwrap();\n+        }).join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -600,7 +600,7 @@ mod tests {\n \n         thread::spawn(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n-        }).join().ok().unwrap();\n+        }).join().ok().expect(\"thread panicked\");\n     }\n \n     // Note that this test will deadlock if TLS destructors aren't run (this"}, {"sha": "8f323b59bf8e1af7950af7fa9d57e115d3a7c686", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -1497,7 +1497,7 @@ mod tests {\n     fn test_unnamed_thread() {\n         thread::spawn(move|| {\n             assert!(thread::current().name().is_none());\n-        }).join().ok().unwrap();\n+        }).join().ok().expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -1691,13 +1691,15 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n             thread::park_timeout(Duration::from_millis(10));\n         }\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_called_other_thread() {\n         for _ in 0..10 {\n             let th = thread::current();\n@@ -1712,6 +1714,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn sleep_ms_smoke() {\n         thread::sleep(Duration::from_millis(2));\n     }"}, {"sha": "0be3ec839e9a2c9c1d9795414832388fd3368c6f", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f229422cc1a0d46d15a7f953f59d8e057ae03865/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=f229422cc1a0d46d15a7f953f59d8e057ae03865", "patch": "@@ -54,6 +54,7 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libstd/f64.rs\",\n     // Integration test for platform-specific run-time feature detection:\n     \"src/libstd/tests/run-time-detect.rs\" ,\n+    \"src/libstd/net/test.rs\",\n     \"src/libstd/sys_common/mod.rs\",\n     \"src/libstd/sys_common/net.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test crate needs it."}]}