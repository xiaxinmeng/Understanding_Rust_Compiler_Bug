{"sha": "aaa3905fdd18a7981d40ac371099ae9044e833a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYTM5MDVmZGQxOGE3OTgxZDQwYWMzNzEwOTlhZTkwNDRlODMzYTg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-06T17:07:34Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-06T17:20:42Z"}, "message": "Shorten type hints for std::iter Iterators", "tree": {"sha": "dbacb3b28efc4404f664edd802b1467b2bf57e37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbacb3b28efc4404f664edd802b1467b2bf57e37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaa3905fdd18a7981d40ac371099ae9044e833a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa3905fdd18a7981d40ac371099ae9044e833a8", "html_url": "https://github.com/rust-lang/rust/commit/aaa3905fdd18a7981d40ac371099ae9044e833a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaa3905fdd18a7981d40ac371099ae9044e833a8/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1f4599809b6e1b10418fa78e1d7bfc3c817319", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1f4599809b6e1b10418fa78e1d7bfc3c817319", "html_url": "https://github.com/rust-lang/rust/commit/ec1f4599809b6e1b10418fa78e1d7bfc3c817319"}], "stats": {"total": 171, "additions": 162, "deletions": 9}, "files": [{"sha": "031c91ccf612dd18f7fe52ae641796d6a02e6e8d", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=aaa3905fdd18a7981d40ac371099ae9044e833a8", "patch": "@@ -30,8 +30,12 @@ use hir_expand::{\n use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n-    method_resolution, ApplicationTy, CallableDefId, Canonical, FnSig, GenericPredicate,\n-    InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    method_resolution,\n+    traits::Solution,\n+    traits::SolutionVariables,\n+    ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n+    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, Ty,\n+    TyDefId, TyKind, TypeCtor,\n };\n use rustc_hash::FxHashSet;\n use stdx::impl_from;\n@@ -1362,6 +1366,35 @@ impl Type {\n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n+    pub fn normalize_trait_assoc_type(\n+        &self,\n+        db: &dyn HirDatabase,\n+        r#trait: Trait,\n+        args: &[Type],\n+        alias: TypeAlias,\n+    ) -> Option<Ty> {\n+        let subst = Substs::build_for_def(db, r#trait.id)\n+            .push(self.ty.value.clone())\n+            .fill(args.iter().map(|t| t.ty.value.clone()))\n+            .build();\n+        let predicate = ProjectionPredicate {\n+            projection_ty: ProjectionTy { associated_ty: alias.id, parameters: subst },\n+            ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n+        };\n+        let goal = Canonical {\n+            value: InEnvironment::new(\n+                self.ty.environment.clone(),\n+                Obligation::Projection(predicate),\n+            ),\n+            kinds: Arc::new([TyKind::General]),\n+        };\n+\n+        match db.trait_solve(self.krate, goal)? {\n+            Solution::Unique(SolutionVariables(subst)) => subst.value.first().cloned(),\n+            Solution::Ambig(_) => None,\n+        }\n+    }\n+\n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n         let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n         let copy_trait = match lang_item {"}, {"sha": "4094a76cbdba1076898cd4c76f5b1f04ebcfa613", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=aaa3905fdd18a7981d40ac371099ae9044e833a8", "patch": "@@ -55,7 +55,7 @@ pub use hir_def::{\n     type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n-    name::AsName, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n+    name::known, name::AsName, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n     /* FIXME */ MacroDefId, MacroFile, Origin,\n };\n pub use hir_ty::display::HirDisplay;"}, {"sha": "63f8287079db26dfb1b035b251c000cdc98a1345", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=aaa3905fdd18a7981d40ac371099ae9044e833a8", "patch": "@@ -164,6 +164,7 @@ pub mod known {\n         result,\n         boxed,\n         // Components of known path (type name)\n+        Iterator,\n         IntoIterator,\n         Item,\n         Try,"}, {"sha": "d8e67bbd90939171facdbf21a2df626324ca7ab5", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 125, "deletions": 6, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa3905fdd18a7981d40ac371099ae9044e833a8/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=aaa3905fdd18a7981d40ac371099ae9044e833a8", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Adt, Callable, HirDisplay, Semantics, Type};\n+use hir::{known, Adt, AssocItem, Callable, HirDisplay, ModuleDef, Semantics, Type};\n use ide_db::RootDatabase;\n use stdx::to_lower_snake_case;\n use syntax::{\n@@ -193,14 +193,68 @@ fn get_bind_pat_hints(\n         return None;\n     }\n \n-    acc.push(InlayHint {\n-        range: pat.syntax().text_range(),\n-        kind: InlayKind::TypeHint,\n-        label: ty.display_truncated(sema.db, config.max_length).to_string().into(),\n-    });\n+    let db = sema.db;\n+    if let Some(hint) = hint_iterator(db, config, &ty, pat.clone()) {\n+        acc.push(hint);\n+    } else {\n+        acc.push(InlayHint {\n+            range: pat.syntax().text_range(),\n+            kind: InlayKind::TypeHint,\n+            label: ty.display_truncated(db, config.max_length).to_string().into(),\n+        });\n+    }\n+\n     Some(())\n }\n \n+/// Checks if the type is an Iterator from std::iter and replaces its hint with an `impl Iterator<Item = Ty>`.\n+fn hint_iterator(\n+    db: &RootDatabase,\n+    config: &InlayHintsConfig,\n+    ty: &Type,\n+    pat: ast::IdentPat,\n+) -> Option<InlayHint> {\n+    let strukt = ty.as_adt()?;\n+    let krate = strukt.krate(db)?;\n+    let module = strukt.module(db);\n+    if krate.declaration_name(db).as_deref() != Some(\"core\") {\n+        return None;\n+    }\n+    let module = module\n+        .path_to_root(db)\n+        .into_iter()\n+        .rev()\n+        .find(|module| module.name(db) == Some(known::iter))?;\n+    let iter_trait = module.scope(db, None).into_iter().find_map(|(name, def)| match def {\n+        hir::ScopeDef::ModuleDef(ModuleDef::Trait(r#trait)) if name == known::Iterator => {\n+            Some(r#trait)\n+        }\n+        _ => None,\n+    })?;\n+    if ty.impls_trait(db, iter_trait, &[]) {\n+        let assoc_type_item = iter_trait.items(db).into_iter().find_map(|item| match item {\n+            AssocItem::TypeAlias(alias) if alias.name(db) == known::Item => Some(alias),\n+            _ => None,\n+        })?;\n+        if let Some(ty) = ty.normalize_trait_assoc_type(db, iter_trait, &[], assoc_type_item) {\n+            return Some(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::TypeHint,\n+                label: format!(\n+                    \"impl Iterator<Item = {}>\",\n+                    ty.display_truncated(\n+                        db,\n+                        config.max_length.map(|len| len - 22 /*len of the template string above*/)\n+                    )\n+                )\n+                .into(),\n+            });\n+        }\n+    }\n+\n+    None\n+}\n+\n fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &Type) -> bool {\n     if let Some(Adt::Enum(enum_data)) = pat_ty.as_adt() {\n         let pat_text = bind_pat.to_string();\n@@ -1057,6 +1111,71 @@ fn main() {\n     let _v = Vec::<Box<dyn Display + Sync>>::new();\n       //^^ Vec<Box<dyn Display + Sync>>\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterator_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: true,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n+            r#\"\n+//- /main.rs crate:main deps:std\n+use std::{Option::{self, Some, None}, iter};\n+\n+fn main() {\n+    let _x = iter::repeat(0);\n+      //^^ impl Iterator<Item = i32>\n+    let _y = iter::Chain(iter::repeat(0), iter::repeat(0));\n+      //^^ impl Iterator<Item = i32>\n+    fn generic<T: Clone>(t: T) {\n+        let _x = iter::repeat(t);\n+          //^^ impl Iterator<Item = T>\n+    }\n+}\n+\n+//- /std.rs crate:std deps:core\n+use core::*;\n+\n+//- /core.rs crate:core\n+pub enum Option<T> {\n+    Some(T),\n+    None\n+}\n+\n+pub mod iter {\n+    pub use self::traits::iterator::Iterator;\n+    pub mod traits { pub mod iterator {\n+        pub trait Iterator {\n+            type Item;\n+        }\n+    } }\n+\n+    pub use self::sources::*;\n+    pub mod sources {\n+        use super::Iterator;\n+        pub struct Repeat<T: Clone>(pub T);\n+\n+        pub fn repeat<T: Clone>(t: T) -> Repeat<T> {\n+            Repeat(f)\n+        }\n+\n+        impl<T: Clone> Iterator for Repeat<T> {\n+            type Item = T;\n+        }\n+\n+        pub struct Chain<A, B>(pub A, pub B);\n+\n+        impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item = T>, B: Iterator<Item = T> {\n+            type Item = T;\n+        }\n+    }\n+}\n \"#,\n         );\n     }"}]}