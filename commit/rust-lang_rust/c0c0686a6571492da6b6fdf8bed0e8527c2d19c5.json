{"sha": "c0c0686a6571492da6b6fdf8bed0e8527c2d19c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYzA2ODZhNjU3MTQ5MmRhNmI2ZmRmOGJlZDBlODUyN2MyZDE5YzU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2019-02-25T20:48:20Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2019-02-25T21:31:16Z"}, "message": "Fix `bool_comparison` with non-`bool` expressions", "tree": {"sha": "70836e0aa6fd9fb6ba901e9ad6a716fd68aa88e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70836e0aa6fd9fb6ba901e9ad6a716fd68aa88e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5", "html_url": "https://github.com/rust-lang/rust/commit/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d9473856a0dd138c6e293d8d0882756eb5d68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d9473856a0dd138c6e293d8d0882756eb5d68a", "html_url": "https://github.com/rust-lang/rust/commit/50d9473856a0dd138c6e293d8d0882756eb5d68a"}], "stats": {"total": 76, "additions": 56, "deletions": 20}, "files": [{"sha": "eca70c6a4036f589f9eb768859a231367b8a1f13", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=c0c0686a6571492da6b6fdf8bed0e8527c2d19c5", "patch": "@@ -225,23 +225,23 @@ fn check_comparison<'a, 'tcx>(\n     use self::Expression::*;\n \n     if let ExprKind::Binary(_, ref left_side, ref right_side) = e.node {\n-        let mut applicability = Applicability::MachineApplicable;\n-        match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n-            (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n-            }),\n-            (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n-            }),\n-            (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n-            }),\n-            (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n-                suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n-            }),\n-            (Other, Other) => no_literal.map_or((), |(h, m)| {\n-                let (l_ty, r_ty) = (cx.tables.expr_ty(left_side), cx.tables.expr_ty(right_side));\n-                if l_ty.is_bool() && r_ty.is_bool() {\n+        let (l_ty, r_ty) = (cx.tables.expr_ty(left_side), cx.tables.expr_ty(right_side));\n+        if l_ty.is_bool() && r_ty.is_bool() {\n+            let mut applicability = Applicability::MachineApplicable;\n+            match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n+                (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n+                }),\n+                (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n+                }),\n+                (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n+                }),\n+                (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n+                    suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n+                }),\n+                (Other, Other) => no_literal.map_or((), |(h, m)| {\n                     let left_side = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n                     let right_side = Sugg::hir_with_applicability(cx, right_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n@@ -253,9 +253,9 @@ fn check_comparison<'a, 'tcx>(\n                         h(left_side, right_side).to_string(),\n                         applicability,\n                     )\n-                }\n-            }),\n-            _ => (),\n+                }),\n+                _ => (),\n+            }\n         }\n     }\n }"}, {"sha": "36d31aa043bb9ec700bcd6e0f216fa1816521f33", "filename": "tests/ui/bool_comparison.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5/tests%2Fui%2Fbool_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c0686a6571492da6b6fdf8bed0e8527c2d19c5/tests%2Fui%2Fbool_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_comparison.rs?ref=c0c0686a6571492da6b6fdf8bed0e8527c2d19c5", "patch": "@@ -73,3 +73,39 @@ fn main() {\n         \"no\"\n     };\n }\n+\n+#[allow(dead_code)]\n+fn issue3703() {\n+    struct Foo;\n+    impl PartialEq<bool> for Foo {\n+        fn eq(&self, _: &bool) -> bool {\n+            true\n+        }\n+    }\n+    impl PartialEq<Foo> for bool {\n+        fn eq(&self, _: &Foo) -> bool {\n+            true\n+        }\n+    }\n+    impl PartialOrd<bool> for Foo {\n+        fn partial_cmp(&self, _: &bool) -> Option<std::cmp::Ordering> {\n+            None\n+        }\n+    }\n+    impl PartialOrd<Foo> for bool {\n+        fn partial_cmp(&self, _: &Foo) -> Option<std::cmp::Ordering> {\n+            None\n+        }\n+    }\n+\n+    if Foo == true {}\n+    if true == Foo {}\n+    if Foo != true {}\n+    if true != Foo {}\n+    if Foo == false {}\n+    if false == Foo {}\n+    if Foo != false {}\n+    if false != Foo {}\n+    if Foo < false {}\n+    if false < Foo {}\n+}"}]}