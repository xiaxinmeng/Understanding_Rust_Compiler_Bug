{"sha": "2fe2e59c67842b37de212bf63466b6280c2bf498", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZTJlNTljNjc4NDJiMzdkZTIxMmJmNjM0NjZiNjI4MGMyYmY0OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-09T09:53:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-09T09:53:08Z"}, "message": "auto merge of #8361 : alexcrichton/rust/fix-node-hashes-in-crates, r=thestinger\n\nWhen running rusti 32-bit tests from a 64-bit host, these errors came up frequently. My best idea as to what was happening is:\r\n\r\n1. First, if you hash the same `int` value on 32-bit and 64-bit, you will get two different hashes.\r\n2. In a cross-compile situation, let's say x86_64 is building an i686 library, all of the hashes will be 64-bit hashes.\r\n3. Then let's say you use the i686 libraries and then attempt to link against the same i686 libraries, because you're calculating hashes with a 32-bit int instead of a 64-bit one, you'll have different hashes and you won't be able to find items in the metadata (the items were generated with a 64-bit int).\r\n\r\nThis patch changes the items to always be hashed as an `i64` to preserve the hash value across architectures. Here's a nice before/after for this patch of the state of rusti tests\r\n\r\n```\r\nhost   target  before  after\r\n64     64      yes     yes\r\n64     32      no      no (llvm assertion)\r\n32     64      no      yes\r\n32     32      no      no (llvm assertion)\r\n```\r\n\r\nBasically one case started working, but currently when the target is 32-bit LLVM is having a lot of problems generating code. That's another separate issue though.", "tree": {"sha": "a733a0515e6ce42ae375b484f0a4534c71dfcbcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a733a0515e6ce42ae375b484f0a4534c71dfcbcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fe2e59c67842b37de212bf63466b6280c2bf498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe2e59c67842b37de212bf63466b6280c2bf498", "html_url": "https://github.com/rust-lang/rust/commit/2fe2e59c67842b37de212bf63466b6280c2bf498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fe2e59c67842b37de212bf63466b6280c2bf498/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "094e4260f8b0a1d1cddf235373d2588cefd167b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/094e4260f8b0a1d1cddf235373d2588cefd167b9", "html_url": "https://github.com/rust-lang/rust/commit/094e4260f8b0a1d1cddf235373d2588cefd167b9"}, {"sha": "0b47b4ccc9a714731112cc49633fc829cf46c95e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b47b4ccc9a714731112cc49633fc829cf46c95e", "html_url": "https://github.com/rust-lang/rust/commit/0b47b4ccc9a714731112cc49633fc829cf46c95e"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "81a2e863bde00613392089509de365aaf8774149", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2fe2e59c67842b37de212bf63466b6280c2bf498/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe2e59c67842b37de212bf63466b6280c2bf498/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2fe2e59c67842b37de212bf63466b6280c2bf498", "patch": "@@ -51,20 +51,20 @@ type cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n+fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n    Option<ebml::Doc> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n-    let hash_pos = table.start + hash % 256u * 4u;\n-    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n+    let hash_pos = table.start + (hash % 256 * 4) as uint;\n+    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        if eq_fn(elt.data.slice(elt.start + 4u, elt.end)) {\n+        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n         } else {\n@@ -84,7 +84,7 @@ pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),\n-                item_id.hash() as uint)\n+                (item_id as i64).hash())\n }\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {"}, {"sha": "c4919e7f263213335ade8a94d45a0030f0a9ae45", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2fe2e59c67842b37de212bf63466b6280c2bf498/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe2e59c67842b37de212bf63466b6280c2bf498/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2fe2e59c67842b37de212bf63466b6280c2bf498", "patch": "@@ -319,7 +319,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             id: NodeId,\n                             variants: &[variant],\n                             path: &[ast_map::path_elt],\n-                            index: @mut ~[entry<int>],\n+                            index: @mut ~[entry<i64>],\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id=%?)\", id);\n \n@@ -329,7 +329,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::def_id { crate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: variant.node.id as i64,\n+                          pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'v');\n@@ -677,8 +678,8 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n                           fields: &[@struct_field],\n-                          global_index: @mut ~[entry<int>])\n-                          -> ~[entry<int>] {\n+                          global_index: @mut ~[entry<i64>])\n+                          -> ~[entry<i64>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let mut index = ~[];\n@@ -692,8 +693,8 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         };\n \n         let id = field.node.id;\n-        index.push(entry {val: id, pos: ebml_w.writer.tell()});\n-        global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n+        global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n                tcx.sess.str_of(nm), id);\n@@ -712,8 +713,8 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n                                ctor_id: NodeId,\n-                               index: @mut ~[entry<int>]) {\n-    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n+                               index: @mut ~[entry<i64>]) {\n+    index.push(entry { val: ctor_id as i64, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(ctor_id));\n@@ -815,13 +816,13 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n-                        index: @mut ~[entry<int>],\n+                        index: @mut ~[entry<i64>],\n                         path: &[ast_map::path_elt]) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n-                     index: @mut ~[entry<int>]) {\n-        index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n+                     index: @mut ~[entry<i64>]) {\n+        index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n     }\n     let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n \n@@ -969,7 +970,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         /* Each class has its own index -- encode it */\n         let bkts = create_index(idx);\n-        encode_index(ebml_w, bkts, write_int);\n+        encode_index(ebml_w, bkts, write_i64);\n         ebml_w.end_tag();\n \n         // If this is a tuple- or enum-like struct, encode the type of the\n@@ -1040,7 +1041,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 Some(ast_methods[i])\n             } else { None };\n \n-            index.push(entry {val: m.def_id.node, pos: ebml_w.writer.tell()});\n+            index.push(entry {val: m.def_id.node as i64,\n+                              pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n                                    ebml_w,\n                                    *m,\n@@ -1086,7 +1088,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n+            index.push(entry {val: method_def_id.node as i64,\n+                              pos: ebml_w.writer.tell()});\n \n             ebml_w.start_tag(tag_items_data_item);\n \n@@ -1145,10 +1148,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n-                                index: @mut ~[entry<int>],\n+                                index: @mut ~[entry<i64>],\n                                 path: &ast_map::path,\n                                 abi: AbiSet) {\n-    index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n+    index.push(entry { val: nitem.id as i64, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n@@ -1184,10 +1187,10 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &Crate)\n-                         -> ~[entry<int>] {\n+                         -> ~[entry<i64>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n-    index.push(entry { val: CRATE_NODE_ID, pos: ebml_w.writer.tell() });\n+    index.push(entry { val: CRATE_NODE_ID as i64, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &crate.module,\n@@ -1304,7 +1307,7 @@ fn write_str(writer: @io::Writer, s: ~str) {\n     writer.write_str(s);\n }\n \n-fn write_int(writer: @io::Writer, &n: &int) {\n+fn write_i64(writer: @io::Writer, &n: &i64) {\n     assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n@@ -1623,7 +1626,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     i = *wr.pos;\n     let items_buckets = create_index(items_index);\n-    encode_index(&mut ebml_w, items_buckets, write_int);\n+    encode_index(&mut ebml_w, items_buckets, write_i64);\n     ecx.stats.index_bytes = *wr.pos - i;\n     ebml_w.end_tag();\n "}]}