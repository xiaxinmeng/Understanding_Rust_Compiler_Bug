{"sha": "4a754f224d2ec61268649bc2421b7843b686375b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNzU0ZjIyNGQyZWM2MTI2ODY0OWJjMjQyMWI3ODQzYjY4NjM3NWI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-20T17:03:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: replace autoderefs' use of MethodCallee with OverloadedDeref.", "tree": {"sha": "385a76d4e71ef65ffc16f5b0afd7a0e8ac761c68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385a76d4e71ef65ffc16f5b0afd7a0e8ac761c68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a754f224d2ec61268649bc2421b7843b686375b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a754f224d2ec61268649bc2421b7843b686375b", "html_url": "https://github.com/rust-lang/rust/commit/4a754f224d2ec61268649bc2421b7843b686375b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a754f224d2ec61268649bc2421b7843b686375b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0e8fffcbfea1d61695acc143b514419826f5ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e8fffcbfea1d61695acc143b514419826f5ac8", "html_url": "https://github.com/rust-lang/rust/commit/c0e8fffcbfea1d61695acc143b514419826f5ac8"}], "stats": {"total": 425, "additions": 261, "deletions": 164}, "files": [{"sha": "22ef88e0e5a9e726cdc906e11756baf13642aa46", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n }\n \n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n-impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, substs, sig });\n+impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl, target });\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n "}, {"sha": "f75f3a145f55794c0a6cca783eecd9e144075e46", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -745,23 +745,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_autoderefs(&mut self,\n                        expr: &hir::Expr,\n                        mut cmt: mc::cmt<'tcx>,\n-                       autoderefs: &[Option<ty::MethodCallee<'tcx>>])\n+                       autoderefs: &[Option<adjustment::OverloadedDeref<'tcx>>])\n                        -> mc::McResult<mc::cmt<'tcx>> {\n         debug!(\"walk_autoderefs expr={:?} autoderefs={:?}\", expr, autoderefs);\n \n         for &overloaded in autoderefs {\n-            if let Some(method) = overloaded {\n-                let self_ty = method.sig.inputs()[0];\n-                let self_ty = self.mc.infcx.resolve_type_vars_if_possible(&self_ty);\n-\n-                let (m, r) = match self_ty.sty {\n-                    ty::TyRef(r, ref m) => (m.mutbl, r),\n-                    _ => span_bug!(expr.span, \"bad overloaded deref type {:?}\", self_ty)\n-                };\n-                let bk = ty::BorrowKind::from_mutbl(m);\n+            if let Some(deref) = overloaded {\n+                let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n                 self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n-                                     r, bk, AutoRef);\n-                cmt = self.mc.cat_overloaded_autoderef(expr, method)?;\n+                                     deref.region, bk, AutoRef);\n+                cmt = self.mc.cat_overloaded_autoderef(expr, deref)?;\n             } else {\n                 cmt = self.mc.cat_deref(expr, cmt, false)?;\n             }"}, {"sha": "68c56177490c5086ebc725ac27b803f9aebfc7bd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -485,8 +485,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"cat_expr: autoderefs={:?}, cmt={:?}\",\n                                autoderefs, cmt);\n                         for &overloaded in autoderefs {\n-                            if let Some(method) = overloaded {\n-                                cmt = self.cat_overloaded_autoderef(expr, method)?;\n+                            if let Some(deref) = overloaded {\n+                                cmt = self.cat_overloaded_autoderef(expr, deref)?;\n                             } else {\n                                 cmt = self.cat_deref(expr, cmt, false)?;\n                             }\n@@ -936,12 +936,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     pub fn cat_overloaded_autoderef(&self,\n                                     expr: &hir::Expr,\n-                                    method: ty::MethodCallee<'tcx>)\n+                                    deref: adjustment::OverloadedDeref<'tcx>)\n                                     -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_overloaded_autoderef: method={:?}\", method);\n+        debug!(\"cat_overloaded_autoderef: deref={:?}\", deref);\n \n-        let ref_ty = method.sig.output();\n-        let ref_ty = self.infcx.resolve_type_vars_if_possible(&ref_ty);\n+        let target = self.infcx.resolve_type_vars_if_possible(&deref.target);\n+        let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n+            ty: target,\n+            mutbl: deref.mutbl,\n+        });\n         let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n         self.cat_deref(expr, base_cmt, false)\n     }"}, {"sha": "55f85ef003b1cce0ed6412207de40997bf2d1a68", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::{self, Ty, TyCtxt, TypeAndMut};\n-\n use hir;\n+use hir::def_id::DefId;\n+use ty::{self, Ty, TyCtxt, TypeAndMut};\n+use ty::subst::Substs;\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {\n@@ -105,7 +106,7 @@ pub enum Adjust<'tcx> {\n     /// ```\n     DerefRef {\n         /// Step 1. Apply a number of dereferences, producing an lvalue.\n-        autoderefs: Vec<Option<ty::MethodCallee<'tcx>>>,\n+        autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n \n         /// Step 2. Optionally produce a pointer/reference from the value.\n         autoref: Option<AutoBorrow<'tcx>>,\n@@ -136,6 +137,30 @@ impl<'tcx> Adjustment<'tcx> {\n     }\n }\n \n+/// An overloaded autoderef step, representing a `Deref(Mut)::deref(_mut)`\n+/// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n+/// The target type is `U` in both cases, with the region and mutability\n+/// being those shared by both the receiver and the returned reference.\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub struct OverloadedDeref<'tcx> {\n+    pub region: ty::Region<'tcx>,\n+    pub mutbl: hir::Mutability,\n+    pub target: Ty<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n+    pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n+                       -> (DefId, &'tcx Substs<'tcx>) {\n+        let trait_def_id = match self.mutbl {\n+            hir::MutImmutable => tcx.lang_items.deref_trait(),\n+            hir::MutMutable => tcx.lang_items.deref_mut_trait()\n+        };\n+        let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n+            .find(|m| m.kind == ty::AssociatedKind::Method).unwrap().def_id;\n+        (method_def_id, tcx.mk_substs_trait(source, &[]))\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T."}, {"sha": "259f44d9d139177de540ef1f98dd80ca45771863", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -390,18 +390,6 @@ impl Variance {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n-pub struct MethodCallee<'tcx> {\n-    /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n-    pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-\n-    /// Instantiated method signature, i.e. it has been substituted,\n-    /// normalized, and has had late-bound lifetimes replaced\n-    /// (with inference variables, during type-checking).\n-    pub sig: FnSig<'tcx>,\n-}\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "811b383324de3a04853bd47c1daac691b2085a11", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -220,6 +220,55 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n+    type Lifted = ty::adjustment::Adjustment<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.kind).and_then(|kind| {\n+            tcx.lift(&self.target).map(|target| {\n+                ty::adjustment::Adjustment { kind, target }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n+    type Lifted = ty::adjustment::Adjust<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny =>\n+                Some(ty::adjustment::Adjust::NeverToAny),\n+            ty::adjustment::Adjust::ReifyFnPointer =>\n+                Some(ty::adjustment::Adjust::ReifyFnPointer),\n+            ty::adjustment::Adjust::UnsafeFnPointer =>\n+                Some(ty::adjustment::Adjust::UnsafeFnPointer),\n+            ty::adjustment::Adjust::ClosureFnPointer =>\n+                Some(ty::adjustment::Adjust::ClosureFnPointer),\n+            ty::adjustment::Adjust::MutToConstPointer =>\n+                Some(ty::adjustment::Adjust::MutToConstPointer),\n+            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize } => {\n+                tcx.lift(autoderefs).and_then(|autoderefs| {\n+                    tcx.lift(autoref).map(|autoref| {\n+                        ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize }\n+                    })\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n+    type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.region, self.target)).map(|(region, target)| {\n+            ty::adjustment::OverloadedDeref {\n+                region,\n+                mutbl: self.mutbl,\n+                target,\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -631,6 +680,65 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::adjustment::Adjustment {\n+            kind: self.kind.fold_with(folder),\n+            target: self.target.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.kind.visit_with(visitor) || self.target.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer => self.clone(),\n+            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize } => {\n+                ty::adjustment::Adjust::DerefRef {\n+                    autoderefs: autoderefs.fold_with(folder),\n+                    autoref: autoref.fold_with(folder),\n+                    unsize,\n+                }\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer => false,\n+            ty::adjustment::Adjust::DerefRef { ref autoderefs, ref autoref, unsize: _ } => {\n+                autoderefs.visit_with(visitor) || autoref.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::adjustment::OverloadedDeref {\n+            region: self.region.fold_with(folder),\n+            mutbl: self.mutbl,\n+            target: self.target.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.region.visit_with(visitor) || self.target.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "b0bfda4a658756d74b1e4d53ed9d4503cfbbcef7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -892,11 +892,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             if let Some(&Adjustment {\n                 kind: Adjust::DerefRef { ref autoderefs, .. }, ..\n             }) = cx.tables.adjustments.get(&id) {\n+                let mut source = cx.tables.expr_ty(expr);\n                 for &overloaded in autoderefs {\n-                    if let Some(m) = overloaded {\n-                        if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n+                    if let Some(deref) = overloaded {\n+                        let (def_id, substs) = deref.method_call(cx.tcx, source);\n+                        if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n                             return true;\n                         }\n+                        source = deref.target;\n+                    } else {\n+                        source = source.builtin_deref(true,\n+                            ty::LvaluePreference::NoPreference).unwrap().ty;\n                     }\n                 }\n             }"}, {"sha": "05f6381d93468bfab157df220134dd14a7186a71", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -89,55 +89,56 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             Some((&ty::adjustment::Adjust::DerefRef { ref autoderefs, autoref, unsize },\n                   adjusted_ty)) => {\n                 for &overloaded in autoderefs {\n-                    let mut ref_ty = expr.ty;\n-                    let kind = if let Some(method) = overloaded {\n-                        debug!(\"make_mirror: overloaded autoderef (method={:?})\", method);\n-\n-                        ref_ty = method.sig.output();\n-                        let (region, mt) = match ref_ty.sty {\n-                            ty::TyRef(region, mt) => (region, mt),\n-                            _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n-                        };\n+                    let source = expr.ty;\n+                    let target;\n+                    let kind = if let Some(deref) = overloaded {\n+                        debug!(\"make_mirror: overloaded autoderef ({:?})\", deref);\n \n                         expr = Expr {\n                             temp_lifetime: temp_lifetime,\n                             temp_lifetime_was_shrunk: was_shrunk,\n-                            ty: cx.tcx.mk_ref(region,\n+                            ty: cx.tcx.mk_ref(deref.region,\n                                               ty::TypeAndMut {\n-                                                  ty: expr.ty,\n-                                                  mutbl: mt.mutbl,\n+                                                  ty: source,\n+                                                  mutbl: deref.mutbl,\n                                               }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n-                                region: region,\n-                                borrow_kind: to_borrow_kind(mt.mutbl),\n+                                region: deref.region,\n+                                borrow_kind: to_borrow_kind(deref.mutbl),\n                                 arg: expr.to_ref(),\n                             },\n                         };\n \n+                        target = deref.target;\n+\n+                        let call = deref.method_call(cx.tcx, source);\n                         overloaded_lvalue(cx,\n                                           self,\n-                                          mt.ty,\n-                                          Some(method),\n+                                          deref.target,\n+                                          Some(call),\n                                           PassArgs::ByRef,\n                                           expr.to_ref(),\n                                           vec![])\n                     } else {\n+                        match source.builtin_deref(true,\n+                                                   ty::LvaluePreference::NoPreference) {\n+                            Some(mt) => {\n+                                target = mt.ty;\n+                            }\n+                            None => {\n+                                span_bug!(self.span, \"autoderef for {} failed: {}\",\n+                                          self.id, source);\n+                            }\n+                        };\n                         debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n                     };\n-                    let adjusted_ty = match ref_ty.builtin_deref(true,\n-                                                ty::LvaluePreference::NoPreference) {\n-                        Some(mt) => mt.ty,\n-                        None => {\n-                            span_bug!(self.span, \"autoderef for {} failed: {}\", self.id, ref_ty);\n-                        }\n-                    };\n-                    debug!(\"make_mirror: autoderef adjusted_ty={:?}\", adjusted_ty);\n+                    debug!(\"make_mirror: autoderef target={:?}\", target);\n                     expr = Expr {\n                         temp_lifetime: temp_lifetime,\n                         temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: adjusted_ty,\n+                        ty: target,\n                         span: self.span,\n                         kind: kind,\n                     };\n@@ -698,10 +699,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n-                                 custom_callee: Option<ty::MethodCallee<'tcx>>)\n+                                 custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n-    let (def_id, substs) = custom_callee.map(|m| (m.def_id, m.substs)).unwrap_or_else(|| {\n+    let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         (cx.tables().type_dependent_defs[&expr.id].def_id(),\n          cx.tables().node_substs(expr.id))\n     });\n@@ -945,7 +946,7 @@ enum PassArgs {\n \n fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                        expr: &'tcx hir::Expr,\n-                                       custom_callee: Option<ty::MethodCallee<'tcx>>,\n+                                       custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n                                        pass_args: PassArgs,\n                                        receiver: ExprRef<'tcx>,\n                                        args: Vec<&'tcx P<hir::Expr>>)\n@@ -999,7 +1000,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      lvalue_ty: Ty<'tcx>,\n-                                     custom_callee: Option<ty::MethodCallee<'tcx>>,\n+                                     custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n                                      pass_args: PassArgs,\n                                      receiver: ExprRef<'tcx>,\n                                      args: Vec<&'tcx P<hir::Expr>>)\n@@ -1016,13 +1017,13 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // Reconstruct the output assuming it's a reference with the\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mutbl) = match recv_ty.sty {\n-        ty::TyRef(region, mt) => (region, mt.mutbl),\n+    let (region, mt) = match recv_ty.sty {\n+        ty::TyRef(region, mt) => (region, mt),\n         _ => span_bug!(expr.span, \"overloaded_lvalue: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {\n         ty: lvalue_ty,\n-        mutbl,\n+        mutbl: mt.mutbl,\n     });\n \n     // construct the complete expression `foo()` for the overloaded call,"}, {"sha": "36671521474a0563486a4ae20e5b75fd52863706", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -11,13 +11,14 @@\n use astconv::AstConv;\n \n use super::{FnCtxt, LvalueOp};\n+use super::method::MethodCallee;\n \n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::{LvaluePreference, NoPreference};\n-use rustc::ty::adjustment::AutoBorrow;\n+use rustc::ty::adjustment::{AutoBorrow, OverloadedDeref};\n \n use syntax_pos::Span;\n use syntax::symbol::Symbol;\n@@ -153,19 +154,27 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n     /// Returns the steps required in adjustments (overloaded deref calls).\n     pub fn adjust_steps(&self, pref: LvaluePreference)\n-                        -> Vec<Option<ty::MethodCallee<'tcx>>> {\n+                        -> Vec<Option<OverloadedDeref<'tcx>>> {\n         self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(pref))\n     }\n \n     pub fn adjust_steps_as_infer_ok(&self, pref: LvaluePreference)\n-                                    -> InferOk<'tcx, Vec<Option<ty::MethodCallee<'tcx>>>> {\n+                                    -> InferOk<'tcx, Vec<Option<OverloadedDeref<'tcx>>>> {\n         let mut obligations = vec![];\n-        let steps: Vec<_> = self.steps.iter().map(|&(ty, kind)| {\n+        let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n             if let AutoderefKind::Overloaded = kind {\n-                self.fcx.try_overloaded_deref(self.span, ty, pref)\n-                    .map(|InferOk { value: (_, method), obligations: o }| {\n+                self.fcx.try_overloaded_deref(self.span, source, pref)\n+                    .and_then(|InferOk { value: (_, method), obligations: o }| {\n                         obligations.extend(o);\n-                        method\n+                        if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                            Some(OverloadedDeref {\n+                                region,\n+                                mutbl: mt.mutbl,\n+                                target: mt.ty\n+                            })\n+                        } else {\n+                            None\n+                        }\n                     })\n             } else {\n                 None\n@@ -206,7 +215,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 pref: LvaluePreference)\n                                 -> Option<InferOk<'tcx,\n                                     (Option<AutoBorrow<'tcx>>,\n-                                     ty::MethodCallee<'tcx>)>> {\n+                                     MethodCallee<'tcx>)>> {\n         self.try_overloaded_lvalue_op(span, base_ty, &[], pref, LvalueOp::Deref)\n     }\n }"}, {"sha": "b498d0f80826b003d3933949ee5f35db5b2c9b1e", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -10,13 +10,14 @@\n \n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use super::autoderef::Autoderef;\n+use super::method::MethodCallee;\n \n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, LvaluePreference, Ty};\n use rustc::ty::subst::Subst;\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -37,7 +38,7 @@ pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefI\n enum CallStep<'tcx> {\n     Builtin(Ty<'tcx>),\n     DeferredClosure(ty::FnSig<'tcx>),\n-    Overloaded(ty::MethodCallee<'tcx>),\n+    Overloaded(MethodCallee<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -158,7 +159,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   call_expr: &hir::Expr,\n                                   adjusted_ty: Ty<'tcx>)\n                                   -> Option<(Option<AutoBorrow<'tcx>>,\n-                                             ty::MethodCallee<'tcx>)> {\n+                                             MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name) in\n             &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n@@ -300,7 +301,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                call_expr: &hir::Expr,\n                                arg_exprs: &'gcx [hir::Expr],\n                                expected: Expectation<'tcx>,\n-                               method_callee: ty::MethodCallee<'tcx>)\n+                               method_callee: MethodCallee<'tcx>)\n                                -> Ty<'tcx> {\n         let output_type = self.check_method_argument_types(call_expr.span,\n                                                            Ok(method_callee),\n@@ -318,7 +319,7 @@ pub struct DeferredCallResolution<'gcx: 'tcx, 'tcx> {\n     call_expr: &'gcx hir::Expr,\n     callee_expr: &'gcx hir::Expr,\n     adjusted_ty: Ty<'tcx>,\n-    autoderefs: Vec<Option<ty::MethodCallee<'tcx>>>,\n+    autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n }"}, {"sha": "ad05a8391890768e2e02026e63ebdd1a0b1688a3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::probe;\n+use super::{probe, MethodCallee};\n \n use check::{FnCtxt, LvalueOp, callee};\n use hir::def_id::DefId;\n@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n                           supplied_method_types: Vec<Ty<'tcx>>)\n-                          -> ty::MethodCallee<'tcx> {\n+                          -> MethodCallee<'tcx> {\n         debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n                unadjusted_self_ty,\n                pick,\n@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                supplied_method_types: Vec<Ty<'tcx>>)\n-               -> ty::MethodCallee<'tcx> {\n+               -> MethodCallee<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         self.add_obligations(method_ty, all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n-        let callee = ty::MethodCallee {\n+        let callee = MethodCallee {\n             def_id: pick.item.def_id,\n             substs: all_substs,\n             sig: method_sig,"}, {"sha": "688def4356ccc28d97bc302c5b336e9143934d2d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -36,6 +36,18 @@ mod suggest;\n \n use self::probe::IsSuggestion;\n \n+#[derive(Clone, Copy, Debug)]\n+pub struct MethodCallee<'tcx> {\n+    /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+\n+    /// Instantiated method signature, i.e. it has been\n+    /// substituted, normalized, and has had late-bound\n+    /// lifetimes replaced with inference variables.\n+    pub sig: ty::FnSig<'tcx>,\n+}\n+\n pub enum MethodError<'tcx> {\n     // Did not find an applicable method, but we did find various near-misses that may work.\n     NoMatch(NoMatchData<'tcx>),\n@@ -125,7 +137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          supplied_method_types: Vec<ty::Ty<'tcx>>,\n                          call_expr: &'gcx hir::Expr,\n                          self_expr: &'gcx hir::Expr)\n-                         -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>> {\n+                         -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n                method_name,\n                self_ty,\n@@ -172,7 +184,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            opt_input_types: Option<&[ty::Ty<'tcx>]>)\n                                            -> Option<InferOk<'tcx,\n                                                 (Option<AutoBorrow<'tcx>>,\n-                                                 ty::MethodCallee<'tcx>)>> {\n+                                                 MethodCallee<'tcx>)>> {\n         debug!(\"lookup_in_trait_adjusted(self_ty={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n@@ -279,7 +291,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let callee = ty::MethodCallee {\n+        let callee = MethodCallee {\n             def_id: def_id,\n             substs: trait_ref.substs,\n             sig: fn_sig,"}, {"sha": "bc76c56599d0237b24a8ab8eff39336c87c34cc7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -81,6 +81,7 @@ use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n+use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n@@ -95,8 +96,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n-use rustc::ty::{MethodCallee};\n-use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, OverloadedDeref};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n@@ -1758,7 +1758,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_method_call(&self, node_id: ast::NodeId, method: ty::MethodCallee<'tcx>) {\n+    pub fn write_method_call(&self, node_id: ast::NodeId, method: MethodCallee<'tcx>) {\n         self.tables.borrow_mut().type_dependent_defs.insert(node_id, Def::Method(method.def_id));\n         self.write_substs(node_id, method.substs);\n     }\n@@ -1776,7 +1776,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn apply_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n-                                      autoderefs: Vec<Option<ty::MethodCallee<'tcx>>>,\n+                                      autoderefs: Vec<Option<OverloadedDeref<'tcx>>>,\n                                       adjusted_ty: Ty<'tcx>) {\n         self.apply_adjustment(node_id, Adjustment {\n             kind: Adjust::DerefRef {\n@@ -2276,7 +2276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 op: LvalueOp)\n                                 -> Option<InferOk<'tcx,\n                                     (Option<AutoBorrow<'tcx>>,\n-                                     ty::MethodCallee<'tcx>)>>\n+                                     MethodCallee<'tcx>)>>\n     {\n         debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n                span,\n@@ -2315,7 +2315,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_method_argument_types(&self,\n                                    sp: Span,\n-                                   method: Result<ty::MethodCallee<'tcx>, ()>,\n+                                   method: Result<MethodCallee<'tcx>, ()>,\n                                    args_no_rcvr: &'gcx [hir::Expr],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)"}, {"sha": "7fff0ceb7788c7d4c4036f63b99ab1e59e82ad19", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -906,7 +906,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n     fn constrain_autoderefs(&mut self,\n                             deref_expr: &hir::Expr,\n-                            autoderefs: &[Option<ty::MethodCallee<'tcx>>])\n+                            autoderefs: &[Option<adjustment::OverloadedDeref<'tcx>>])\n                             -> mc::McResult<mc::cmt<'tcx>>\n     {\n         debug!(\"constrain_autoderefs(deref_expr={:?}, autoderefs={:?})\",\n@@ -920,43 +920,35 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let r_deref_expr = self.tcx.node_scope_region(deref_expr.id);\n         for &overloaded in autoderefs {\n-            if let Some(method) = overloaded {\n-                debug!(\"constrain_autoderefs: overloaded, method={:?}\", method);\n-\n-                let origin = infer::ParameterOrigin::OverloadedDeref;\n-                self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n+            if let Some(deref) = overloaded {\n+                debug!(\"constrain_autoderefs: overloaded, {:?}\", deref);\n \n                 // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                 // was applied on the base type, as that is always the case.\n-                let self_ty = method.sig.inputs()[0];\n-                let (m, r) = match self_ty.sty {\n-                    ty::TyRef(r, ref m) => (m.mutbl, r),\n-                    _ => {\n-                        span_bug!(\n-                            deref_expr.span,\n-                            \"bad overloaded deref type {:?}\",\n-                            method.sig)\n-                    }\n-                };\n-\n-                debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n-                       r, m);\n+                let input = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n+                    ty: cmt.ty,\n+                    mutbl: deref.mutbl,\n+                });\n+                let output = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n+                    ty: deref.target,\n+                    mutbl: deref.mutbl,\n+                });\n \n                 debug!(\"constrain_autoderefs: self_cmt={:?}\", cmt);\n-                self.link_region(deref_expr.span, r,\n-                                 ty::BorrowKind::from_mutbl(m), cmt.clone());\n+                self.link_region(deref_expr.span, deref.region,\n+                                 ty::BorrowKind::from_mutbl(deref.mutbl), cmt.clone());\n \n                 // Specialized version of constrain_call.\n                 self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n-                                       self_ty, r_deref_expr);\n+                                       input, r_deref_expr);\n                 self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                       method.sig.output(), r_deref_expr);\n+                                       output, r_deref_expr);\n             }\n \n             {\n                 let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                if let Some(method) = overloaded {\n-                    cmt = mc.cat_overloaded_autoderef(deref_expr, method)?;\n+                if let Some(deref) = overloaded {\n+                    cmt = mc.cat_overloaded_autoderef(deref_expr, deref)?;\n                 } else {\n                     cmt = mc.cat_deref(deref_expr, cmt, false)?;\n                 }"}, {"sha": "0b93db54980994ac58596a057f0bcaf7d1e387e1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a754f224d2ec61268649bc2421b7843b686375b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4a754f224d2ec61268649bc2421b7843b686375b", "patch": "@@ -16,8 +16,7 @@ use check::FnCtxt;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n-use rustc::ty::{self, Ty, TyCtxt, MethodCallee};\n-use rustc::ty::adjustment;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n@@ -307,54 +306,14 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {\n-        let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n-        match adjustments {\n+        let adjustment = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n+        match adjustment {\n             None => {\n                 debug!(\"No adjustments for node {}\", node_id);\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = match adjustment.kind {\n-                    adjustment::Adjust::NeverToAny => {\n-                        adjustment::Adjust::NeverToAny\n-                    }\n-\n-                    adjustment::Adjust::ReifyFnPointer => {\n-                        adjustment::Adjust::ReifyFnPointer\n-                    }\n-\n-                    adjustment::Adjust::MutToConstPointer => {\n-                        adjustment::Adjust::MutToConstPointer\n-                    }\n-\n-                    adjustment::Adjust::ClosureFnPointer => {\n-                        adjustment::Adjust::ClosureFnPointer\n-                    }\n-\n-                    adjustment::Adjust::UnsafeFnPointer => {\n-                        adjustment::Adjust::UnsafeFnPointer\n-                    }\n-\n-                    adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n-                        adjustment::Adjust::DerefRef {\n-                            autoderefs: autoderefs.iter().map(|overloaded| {\n-                                overloaded.map(|method| {\n-                                    MethodCallee {\n-                                        def_id: method.def_id,\n-                                        substs: self.resolve(&method.substs, &span),\n-                                        sig: self.resolve(&method.sig, &span),\n-                                    }\n-                                })\n-                            }).collect(),\n-                            autoref: self.resolve(&autoref, &span),\n-                            unsize: unsize,\n-                        }\n-                    }\n-                };\n-                let resolved_adjustment = adjustment::Adjustment {\n-                    kind: resolved_adjustment,\n-                    target: self.resolve(&adjustment.target, &span)\n-                };\n+                let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\"Adjustments for node {}: {:?}\", node_id, resolved_adjustment);\n                 self.tables.adjustments.insert(node_id, resolved_adjustment);\n             }"}]}