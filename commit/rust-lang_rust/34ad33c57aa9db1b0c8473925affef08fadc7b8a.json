{"sha": "34ad33c57aa9db1b0c8473925affef08fadc7b8a", "node_id": "C_kwDOAAsO6NoAKDM0YWQzM2M1N2FhOWRiMWIwYzg0NzM5MjVhZmZlZjA4ZmFkYzdiOGE", "commit": {"author": {"name": "Max Baumann", "email": "max@bmn.dev", "date": "2022-03-18T20:11:54Z"}, "committer": {"name": "Max Baumann", "email": "max@bmn.dev", "date": "2022-03-18T20:11:54Z"}, "message": "refactor: move into methods module", "tree": {"sha": "e69aa1c2af0c8a20a67b7004d19f88afbc325ff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e69aa1c2af0c8a20a67b7004d19f88afbc325ff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34ad33c57aa9db1b0c8473925affef08fadc7b8a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEhJzmO046LuvaNO3WIPoWCbA7HW0FAmI054oACgkQIPoWCbA7\nHW0ZzQ/8DPW5imHaV2QOsFIlm6PcUvINyi5BbEDxCvDHiyfYATQxlcRSyhZ/Zdml\n3+s587GJrP/jn2LQBWX7Ohiq3LcvjiyNzNv1Xo9V76dj+Fpzva9YMMyqizkf2sto\npNXJ/nk+5DlDg6IihTJg+eU29BKZc4gyhv57OTMdnQ29MnyDsAlwc+BlTDIjXDFw\nUJib2F4Xh4net5EaaOJvxqqyy3PYEtIQtPmJoMw4br778mKj34hEM85oLtnsYRmB\nuTTWxGc0i2wViu56aDqtOxTB6ZnYstTtPvrwZFz8ALT82NupCfv9qai0wJpnfMsO\ne6OmU1ApoZU5+6+dKjBh0MIqjX/VIryZGqnifubl51HFxI5dtXAX4XbZJ57ARTbv\nDiSiT4SA/wf2zFlHgguWm5b6X3m9zihoaNO6Uo7kdZUZI65QihI55VCr28qAQbPO\ny8gH4Aev5HJbvd3GuVwBWO3E182qtcd1SNo66uaSeev0LOOLijix1ChX4RiSyfn6\nk+BU0u2TDTHOclqwL3f7agn2TbCvELvGfFHD6O2o0Jzd56fiThiR5efVoM6ro2BK\nNdjpFWF2/mfAZgwm60wK8djMq83adSezGzONpQepSxyy21LoYZAWdPrWW7BznhxK\nvFPgrUMFuTt8xYqMzCzXYdug/vbLpvzQvsAPKB27d6rtZuoBh1s=\n=yuRX\n-----END PGP SIGNATURE-----", "payload": "tree e69aa1c2af0c8a20a67b7004d19f88afbc325ff4\nparent fd2c8601711554d31f0c836d5aa96623a25e63b6\nauthor Max Baumann <max@bmn.dev> 1647634314 +0100\ncommitter Max Baumann <max@bmn.dev> 1647634314 +0100\n\nrefactor: move into methods module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34ad33c57aa9db1b0c8473925affef08fadc7b8a", "html_url": "https://github.com/rust-lang/rust/commit/34ad33c57aa9db1b0c8473925affef08fadc7b8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34ad33c57aa9db1b0c8473925affef08fadc7b8a/comments", "author": {"login": "FoseFx", "id": 22842759, "node_id": "MDQ6VXNlcjIyODQyNzU5", "avatar_url": "https://avatars.githubusercontent.com/u/22842759?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FoseFx", "html_url": "https://github.com/FoseFx", "followers_url": "https://api.github.com/users/FoseFx/followers", "following_url": "https://api.github.com/users/FoseFx/following{/other_user}", "gists_url": "https://api.github.com/users/FoseFx/gists{/gist_id}", "starred_url": "https://api.github.com/users/FoseFx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FoseFx/subscriptions", "organizations_url": "https://api.github.com/users/FoseFx/orgs", "repos_url": "https://api.github.com/users/FoseFx/repos", "events_url": "https://api.github.com/users/FoseFx/events{/privacy}", "received_events_url": "https://api.github.com/users/FoseFx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FoseFx", "id": 22842759, "node_id": "MDQ6VXNlcjIyODQyNzU5", "avatar_url": "https://avatars.githubusercontent.com/u/22842759?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FoseFx", "html_url": "https://github.com/FoseFx", "followers_url": "https://api.github.com/users/FoseFx/followers", "following_url": "https://api.github.com/users/FoseFx/following{/other_user}", "gists_url": "https://api.github.com/users/FoseFx/gists{/gist_id}", "starred_url": "https://api.github.com/users/FoseFx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FoseFx/subscriptions", "organizations_url": "https://api.github.com/users/FoseFx/orgs", "repos_url": "https://api.github.com/users/FoseFx/repos", "events_url": "https://api.github.com/users/FoseFx/events{/privacy}", "received_events_url": "https://api.github.com/users/FoseFx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd2c8601711554d31f0c836d5aa96623a25e63b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd2c8601711554d31f0c836d5aa96623a25e63b6", "html_url": "https://github.com/rust-lang/rust/commit/fd2c8601711554d31f0c836d5aa96623a25e63b6"}], "stats": {"total": 219, "additions": 112, "deletions": 107}, "files": [{"sha": "033efcb8a89cf4a3e7989eb49e427bb9062c4014", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=34ad33c57aa9db1b0c8473925affef08fadc7b8a", "patch": "@@ -181,6 +181,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::OPTION_MAP_OR_NONE),\n     LintId::of(methods::OR_FUN_CALL),\n+    LintId::of(methods::OR_THEN_UNWRAP),\n     LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n@@ -238,7 +239,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n-    LintId::of(or_then_unwrap::OR_THEN_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "a2ce69065f94d47685a1c47f1fa8deb01ecbc05b", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=34ad33c57aa9db1b0c8473925affef08fadc7b8a", "patch": "@@ -47,6 +47,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n+    LintId::of(methods::OR_THEN_UNWRAP),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n@@ -66,7 +67,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n     LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n-    LintId::of(or_then_unwrap::OR_THEN_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "ce5a1170504fe73d492620c7717133ab521ecbb0", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=34ad33c57aa9db1b0c8473925affef08fadc7b8a", "patch": "@@ -319,6 +319,7 @@ store.register_lints(&[\n     methods::OPTION_FILTER_MAP,\n     methods::OPTION_MAP_OR_NONE,\n     methods::OR_FUN_CALL,\n+    methods::OR_THEN_UNWRAP,\n     methods::RESULT_MAP_OR_INTO_OPTION,\n     methods::SEARCH_IS_SOME,\n     methods::SHOULD_IMPLEMENT_TRAIT,\n@@ -404,7 +405,6 @@ store.register_lints(&[\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,\n-    or_then_unwrap::OR_THEN_UNWRAP,\n     overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n     panic_in_result_fn::PANIC_IN_RESULT_FN,\n     panic_unimplemented::PANIC,"}, {"sha": "504235d0d1ef00b40bf5b8f948514b86827a1c40", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=34ad33c57aa9db1b0c8473925affef08fadc7b8a", "patch": "@@ -322,7 +322,6 @@ mod only_used_in_recursion;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n-mod or_then_unwrap;\n mod overflow_check_conditional;\n mod panic_in_result_fn;\n mod panic_unimplemented;\n@@ -867,7 +866,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             ignore_publish: cargo_ignore_publish,\n         })\n     });\n-    store.register_late_pass(|| Box::new(or_then_unwrap::OrThenUnwrap));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "1e76428858bf9253b38435d59ec72e1cf0102cb3", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=34ad33c57aa9db1b0c8473925affef08fadc7b8a", "patch": "@@ -45,6 +45,7 @@ mod option_as_ref_deref;\n mod option_map_or_none;\n mod option_map_unwrap_or;\n mod or_fun_call;\n+mod or_then_unwrap;\n mod search_is_some;\n mod single_char_add_str;\n mod single_char_insert_string;\n@@ -778,6 +779,42 @@ declare_clippy_lint! {\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `.or(\u2026).unwrap()` calls to Options and Results.\n+    ///\n+    /// ### Why is this bad?\n+    /// You should use `.unwrap_or(\u2026)` instead for clarity.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let fallback = \"fallback\";\n+    /// // Result\n+    /// # type Error = &'static str;\n+    /// # let result: Result<&str, Error> = Err(\"error\");\n+    /// let value = result.or::<Error>(Ok(fallback)).unwrap();\n+    ///\n+    /// // Option\n+    /// # let option: Option<&str> = None;\n+    /// let value = option.or(Some(fallback)).unwrap();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let fallback = \"fallback\";\n+    /// // Result\n+    /// # let result: Result<&str, &str> = Err(\"error\");\n+    /// let value = result.unwrap_or(fallback);\n+    ///\n+    /// // Option\n+    /// # let option: Option<&str> = None;\n+    /// let value = option.unwrap_or(fallback);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub OR_THEN_UNWRAP,\n+    complexity,\n+    \"checks for `.or(\u2026).unwrap()` calls to Options and Results.\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n@@ -2039,6 +2076,7 @@ impl_lint_pass!(Methods => [\n     OPTION_MAP_OR_NONE,\n     BIND_INSTEAD_OF_MAP,\n     OR_FUN_CALL,\n+    OR_THEN_UNWRAP,\n     EXPECT_FUN_CALL,\n     CHARS_NEXT_CMP,\n     CHARS_LAST_CMP,\n@@ -2474,6 +2512,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     Some((\"get_mut\", [recv, get_arg], _)) => {\n                         get_unwrap::check(cx, expr, recv, get_arg, true);\n                     },\n+                    Some((\"or\", [recv, or_arg], or_span)) => {\n+                        or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n+                    },\n                     _ => {},\n                 }\n                 unwrap_used::check(cx, expr, recv);"}, {"sha": "02fa5887f6764b3283aa395ea8cb7d3e86514b14", "filename": "clippy_lints/src/methods/or_then_unwrap.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ad33c57aa9db1b0c8473925affef08fadc7b8a/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=34ad33c57aa9db1b0c8473925affef08fadc7b8a", "patch": "@@ -0,0 +1,68 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, Span};\n+\n+use super::OR_THEN_UNWRAP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    unwrap_expr: &Expr<'_>,\n+    recv: &'tcx Expr<'tcx>,\n+    or_arg: &'tcx Expr<'_>,\n+    or_span: Span,\n+) {\n+    let ty = cx.typeck_results().expr_ty(recv); // get type of x (we later check if it's Option or Result)\n+    let title;\n+\n+    if is_type_diagnostic_item(cx, ty, sym::Option) {\n+        title = \".or(Some(\u2026)).unwrap() found\";\n+        if !is(or_arg, \"Some\") {\n+            return;\n+        }\n+    } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n+        title = \".or(Ok(\u2026)).unwrap() found\";\n+        if !is(or_arg, \"Ok\") {\n+            return;\n+        }\n+    } else {\n+        // Someone has implemented a struct with .or(...).unwrap() chaining,\n+        // but it's not an Option or a Result, so bail\n+        return;\n+    }\n+\n+    let unwrap_span = if let ExprKind::MethodCall(_, _, span) = unwrap_expr.kind {\n+        span\n+    } else {\n+        // unreachable. but fallback to ident's span (\"()\" are missing)\n+        unwrap_expr.span\n+    };\n+\n+    span_lint_and_help(\n+        cx,\n+        OR_THEN_UNWRAP,\n+        or_span.to(unwrap_span),\n+        title,\n+        None,\n+        \"use `unwrap_or()` instead\",\n+    );\n+}\n+\n+/// is expr a Call to name?\n+/// name might be \"Some\", \"Ok\", \"Err\", etc.\n+fn is<'a>(expr: &Expr<'a>, name: &str) -> bool {\n+    if_chain! {\n+        if let ExprKind::Call(some_expr, _some_args) = expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = &some_expr.kind;\n+        if let Some(path_segment) = path.segments.first();\n+        if path_segment.ident.name.as_str() == name;\n+        then {\n+            true\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "d467fbdfe02868bbd6c7e115fbe74538a5dbd207", "filename": "clippy_lints/src/or_then_unwrap.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fd2c8601711554d31f0c836d5aa96623a25e63b6/clippy_lints%2Fsrc%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd2c8601711554d31f0c836d5aa96623a25e63b6/clippy_lints%2Fsrc%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2For_then_unwrap.rs?ref=fd2c8601711554d31f0c836d5aa96623a25e63b6", "patch": "@@ -1,102 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `.or(\u2026).unwrap()` calls to Options and Results.\n-    ///\n-    /// ### Why is this bad?\n-    /// You should use `.unwrap_or(\u2026)` instead for clarity.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let fallback = \"fallback\";\n-    /// // Result\n-    /// # type Error = &'static str;\n-    /// # let result: Result<&str, Error> = Err(\"error\");\n-    /// let value = result.or::<Error>(Ok(fallback)).unwrap();\n-    ///\n-    /// // Option\n-    /// # let option: Option<&str> = None;\n-    /// let value = option.or(Some(fallback)).unwrap();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # let fallback = \"fallback\";\n-    /// // Result\n-    /// # let result: Result<&str, &str> = Err(\"error\");\n-    /// let value = result.unwrap_or(fallback);\n-    ///\n-    /// // Option\n-    /// # let option: Option<&str> = None;\n-    /// let value = option.unwrap_or(fallback);\n-    /// ```\n-    #[clippy::version = \"1.61.0\"]\n-    pub OR_THEN_UNWRAP,\n-    complexity,\n-    \"checks for `.or(\u2026).unwrap()` calls to Options and Results.\"\n-}\n-declare_lint_pass!(OrThenUnwrap => [OR_THEN_UNWRAP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OrThenUnwrap {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // look for x.or().unwrap()\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [unwrap_self], unwrap_span) = &expr.kind;\n-            if path.ident.name == sym::unwrap;\n-            if let ExprKind::MethodCall(caller_path, [or_self, or_arg], or_span) = &unwrap_self.kind;\n-            if caller_path.ident.name == sym::or;\n-            then {\n-                let ty = cx.typeck_results().expr_ty(or_self); // get type of x (we later check if it's Option or Result)\n-                let title;\n-\n-                if is_type_diagnostic_item(cx, ty, sym::Option) {\n-                    title = \".or(Some(\u2026)).unwrap() found\";\n-                    if !is(or_arg, \"Some\") {\n-                        return;\n-                    }\n-                } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n-                    title = \".or(Ok(\u2026)).unwrap() found\";\n-                    if !is(or_arg, \"Ok\") {\n-                        return;\n-                    }\n-                } else {\n-                    // Someone has implemented a struct with .or(...).unwrap() chaining,\n-                    // but it's not an Option or a Result, so bail\n-                    return;\n-                }\n-\n-                span_lint_and_help(\n-                    cx,\n-                    OR_THEN_UNWRAP,\n-                    or_span.to(*unwrap_span),\n-                    title,\n-                    None,\n-                    \"use `unwrap_or()` instead\"\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// is expr a Call to name?\n-/// name might be \"Some\", \"Ok\", \"Err\", etc.\n-fn is<'a>(expr: &Expr<'a>, name: &str) -> bool {\n-    if_chain! {\n-        if let ExprKind::Call(some_expr, _some_args) = expr.kind;\n-        if let ExprKind::Path(QPath::Resolved(_, path)) = &some_expr.kind;\n-        if let Some(path_segment) = path.segments.first();\n-        if path_segment.ident.name.as_str() == name;\n-        then {\n-            true\n-        }\n-        else {\n-            false\n-        }\n-    }\n-}"}]}