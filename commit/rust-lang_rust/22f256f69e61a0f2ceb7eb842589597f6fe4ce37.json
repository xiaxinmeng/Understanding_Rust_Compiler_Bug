{"sha": "22f256f69e61a0f2ceb7eb842589597f6fe4ce37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjI1NmY2OWU2MWEwZjJjZWI3ZWI4NDI1ODk1OTdmNmZlNGNlMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-02T11:14:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-02T11:14:54Z"}, "message": "Auto merge of #43612 - michaelwoerister:fix-cgu-hashing, r=eddyb\n\nincr.comp.: Properly incorporate symbol linkage and visibility into CGU hash.\n\nThis PR fixes the way the CGU hash for incr. comp. is computed. The CGU hash represents which `TransItems` are emitted into which codegen unit with which linkage and visibility. Before the new, LLVM-independent symbol internalizer the CGU hash did not accurately contain `TransItem` linkage and visibility because we would not enable symbol internalization in incremental mode anyway. The new internalizer is also run in incremental mode which uncovered the inaccuracy of CGU hashing. Luckily, the fix is rather simple.\n\nr? @eddyb\ncc @nikomatsakis", "tree": {"sha": "1217cc20970a766ece338fda537dc7f63470dddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1217cc20970a766ece338fda537dc7f63470dddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f256f69e61a0f2ceb7eb842589597f6fe4ce37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f256f69e61a0f2ceb7eb842589597f6fe4ce37", "html_url": "https://github.com/rust-lang/rust/commit/22f256f69e61a0f2ceb7eb842589597f6fe4ce37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f256f69e61a0f2ceb7eb842589597f6fe4ce37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c385bef7a2429db496f809f2e5042774fe7079b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c385bef7a2429db496f809f2e5042774fe7079b", "html_url": "https://github.com/rust-lang/rust/commit/5c385bef7a2429db496f809f2e5042774fe7079b"}, {"sha": "b2c3a413b955ac89be06367f4db7706cbd88dc9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c3a413b955ac89be06367f4db7706cbd88dc9c", "html_url": "https://github.com/rust-lang/rust/commit/b2c3a413b955ac89be06367f4db7706cbd88dc9c"}], "stats": {"total": 23, "additions": 5, "deletions": 18}, "files": [{"sha": "49a2885747f6d3dd1da669afab0560def96717b8", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f256f69e61a0f2ceb7eb842589597f6fe4ce37/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f256f69e61a0f2ceb7eb842589597f6fe4ce37/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=22f256f69e61a0f2ceb7eb842589597f6fe4ce37", "patch": "@@ -1172,7 +1172,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &exported_symbols);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not"}, {"sha": "cff0eca02c60ee4ccaea654f6d436bc8c86721c5", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/22f256f69e61a0f2ceb7eb842589597f6fe4ce37/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f256f69e61a0f2ceb7eb842589597f6fe4ce37/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=22f256f69e61a0f2ceb7eb842589597f6fe4ce37", "patch": "@@ -174,29 +174,16 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>,\n-                                        exported_symbols: &ExportedSymbols)\n+                                        scx: &SharedCrateContext<'a, 'tcx>)\n                                         -> u64 {\n         let mut state = IchHasher::new();\n-        let exported_symbols = exported_symbols.local_exports();\n         let all_items = self.items_in_deterministic_order(scx.tcx());\n-        for (item, _) in all_items {\n+        for (item, (linkage, visibility)) in all_items {\n             let symbol_name = item.symbol_name(scx.tcx());\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n-            let exported = match item {\n-                TransItem::Fn(ref instance) => {\n-                    let node_id =\n-                        scx.tcx().hir.as_local_node_id(instance.def_id());\n-                    node_id.map(|node_id| exported_symbols.contains(&node_id))\n-                        .unwrap_or(false)\n-                }\n-                TransItem::Static(node_id) => {\n-                    exported_symbols.contains(&node_id)\n-                }\n-                TransItem::GlobalAsm(..) => true,\n-            };\n-            exported.hash(&mut state);\n+            linkage.hash(&mut state);\n+            visibility.hash(&mut state);\n         }\n         state.finish().to_smaller_hash()\n     }"}]}