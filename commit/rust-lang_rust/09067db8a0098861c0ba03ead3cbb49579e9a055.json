{"sha": "09067db8a0098861c0ba03ead3cbb49579e9a055", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MDY3ZGI4YTAwOTg4NjFjMGJhMDNlYWQzY2JiNDk1NzllOWEwNTU=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-01-12T21:04:51Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-01-13T06:20:29Z"}, "message": "Serialize dependency graph directly from DepGraph\n\nReduce memory usage by serializing dep graph directly from `DepGraph`,\nrather than copying it into `SerializedDepGraph` and serializing that.", "tree": {"sha": "01a00b948820546cf79eb3574f000933e7bf264e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a00b948820546cf79eb3574f000933e7bf264e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09067db8a0098861c0ba03ead3cbb49579e9a055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09067db8a0098861c0ba03ead3cbb49579e9a055", "html_url": "https://github.com/rust-lang/rust/commit/09067db8a0098861c0ba03ead3cbb49579e9a055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09067db8a0098861c0ba03ead3cbb49579e9a055/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "704e47f78b4c8801a3c76f235a5a152e1b60b300", "url": "https://api.github.com/repos/rust-lang/rust/commits/704e47f78b4c8801a3c76f235a5a152e1b60b300", "html_url": "https://github.com/rust-lang/rust/commit/704e47f78b4c8801a3c76f235a5a152e1b60b300"}], "stats": {"total": 498, "additions": 328, "deletions": 170}, "files": [{"sha": "45d474b89b8dfe689074d37363668caae7fa52f2", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 7, "deletions": 75, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=09067db8a0098861c0ba03ead3cbb49579e9a055", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n-use rustc_middle::dep_graph::{DepGraph, DepKind, WorkProduct, WorkProductId};\n+use rustc_middle::dep_graph::{DepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encodable as RustcEncodable;\n@@ -148,83 +148,15 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeRes\n     // First encode the commandline arguments hash\n     tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n \n-    // Encode the graph data.\n-    let serialized_graph =\n-        tcx.sess.time(\"incr_comp_serialize_dep_graph\", || tcx.dep_graph.serialize());\n-\n     if tcx.sess.opts.debugging_opts.incremental_info {\n-        #[derive(Clone)]\n-        struct Stat {\n-            kind: DepKind,\n-            node_counter: u64,\n-            edge_counter: u64,\n-        }\n-\n-        let total_node_count = serialized_graph.nodes.len();\n-        let total_edge_count = serialized_graph.edge_list_data.len();\n-\n-        let mut counts: FxHashMap<_, Stat> =\n-            FxHashMap::with_capacity_and_hasher(total_node_count, Default::default());\n-\n-        for (i, &node) in serialized_graph.nodes.iter_enumerated() {\n-            let stat = counts.entry(node.kind).or_insert(Stat {\n-                kind: node.kind,\n-                node_counter: 0,\n-                edge_counter: 0,\n-            });\n-\n-            stat.node_counter += 1;\n-            let (edge_start, edge_end) = serialized_graph.edge_list_indices[i];\n-            stat.edge_counter += (edge_end - edge_start) as u64;\n-        }\n-\n-        let mut counts: Vec<_> = counts.values().cloned().collect();\n-        counts.sort_by_key(|s| -(s.node_counter as i64));\n-\n-        println!(\"[incremental]\");\n-        println!(\"[incremental] DepGraph Statistics\");\n-\n-        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n-                                 ----------------------------------------------\\\n-                                 ------------\";\n-\n-        println!(\"{}\", SEPARATOR);\n-        println!(\"[incremental]\");\n-        println!(\"[incremental] Total Node Count: {}\", total_node_count);\n-        println!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n-        if let Some((total_edge_reads, total_duplicate_edge_reads)) =\n-            tcx.dep_graph.edge_deduplication_data()\n-        {\n-            println!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n-            println!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n-        }\n-        println!(\"[incremental]\");\n-        println!(\n-            \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n-            \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n-        );\n-        println!(\n-            \"[incremental] -------------------------------------\\\n-                  |------------------\\\n-                  |-------------\\\n-                  |------------------|\"\n-        );\n-\n-        for stat in counts.iter() {\n-            println!(\n-                \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n-                format!(\"{:?}\", stat.kind),\n-                (100.0 * (stat.node_counter as f64)) / (total_node_count as f64), // percentage of all nodes\n-                stat.node_counter,\n-                (stat.edge_counter as f64) / (stat.node_counter as f64), // average edges per kind\n-            );\n-        }\n-\n-        println!(\"{}\", SEPARATOR);\n-        println!(\"[incremental]\");\n+        tcx.dep_graph.print_incremental_info();\n     }\n \n-    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || serialized_graph.encode(encoder))\n+    // There is a tiny window between printing the incremental info above and encoding the dep\n+    // graph below in which the dep graph could change, thus making the printed incremental info\n+    // slightly out of date. If this matters to you, please feel free to submit a patch. :)\n+\n+    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || tcx.dep_graph.encode(encoder))\n }\n \n fn encode_work_product_index("}, {"sha": "4a54ddf854530b5808b07be5861e91622aa75b0d", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 242, "deletions": 93, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=09067db8a0098861c0ba03ead3cbb49579e9a055", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Or\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_serialize::{Encodable, Encoder};\n \n use parking_lot::{Condvar, Mutex};\n use smallvec::{smallvec, SmallVec};\n@@ -21,7 +22,7 @@ use std::sync::atomic::Ordering::Relaxed;\n use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n-use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::serialized::SerializedDepNodeIndex;\n use super::{DepContext, DepKind, DepNode, WorkProductId};\n \n #[derive(Clone)]\n@@ -148,7 +149,7 @@ impl<K: DepKind> DepGraph<K> {\n         let mut edge_list_indices = Vec::with_capacity(node_count);\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n \n-        // See `serialize` for notes on the approach used here.\n+        // See `DepGraph`'s `Encodable` implementation for notes on the approach used here.\n \n         edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n \n@@ -551,19 +552,6 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n-    pub fn edge_deduplication_data(&self) -> Option<(u64, u64)> {\n-        if cfg!(debug_assertions) {\n-            let current_dep_graph = &self.data.as_ref().unwrap().current;\n-\n-            Some((\n-                current_dep_graph.total_read_count.load(Relaxed),\n-                current_dep_graph.total_duplicate_read_count.load(Relaxed),\n-            ))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n@@ -579,84 +567,6 @@ impl<K: DepKind> DepGraph<K> {\n         edge_count\n     }\n \n-    pub fn serialize(&self) -> SerializedDepGraph<K> {\n-        type SDNI = SerializedDepNodeIndex;\n-\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        let mut nodes = IndexVec::with_capacity(node_count);\n-        let mut fingerprints = IndexVec::with_capacity(node_count);\n-        let mut edge_list_indices = IndexVec::with_capacity(node_count);\n-        let mut edge_list_data = Vec::with_capacity(edge_count);\n-\n-        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be in\n-        // `DepNodeIndex` order. The edges in `edge_list_data`, on the other\n-        // hand, don't need to be in a particular order, as long as each node\n-        // can reference its edges as a contiguous range within it. This is why\n-        // we're able to copy `unshared_edges` directly into `edge_list_data`.\n-        // It meets the above requirements, and each non-dark-green node already\n-        // knows the range of edges to reference within it, which they'll push\n-        // onto `edge_list_indices`. Dark green nodes, however, don't have their\n-        // edges in `unshared_edges`, so need to add them to `edge_list_data`.\n-\n-        edge_list_data.extend(data.unshared_edges.iter().map(|i| SDNI::new(i.index())));\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            match hybrid_index.into() {\n-                HybridIndex::New(i) => {\n-                    let new = &data.new;\n-                    nodes.push(new.nodes[i]);\n-                    fingerprints.push(new.fingerprints[i]);\n-                    let edges = &new.edges[i];\n-                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n-                }\n-                HybridIndex::Red(i) => {\n-                    let red = &data.red;\n-                    nodes.push(previous.index_to_node(red.node_indices[i]));\n-                    fingerprints.push(red.fingerprints[i]);\n-                    let edges = &red.edges[i];\n-                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n-                }\n-                HybridIndex::LightGreen(i) => {\n-                    let lg = &data.light_green;\n-                    nodes.push(previous.index_to_node(lg.node_indices[i]));\n-                    fingerprints.push(previous.fingerprint_by_index(lg.node_indices[i]));\n-                    let edges = &lg.edges[i];\n-                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    nodes.push(previous.index_to_node(prev_index));\n-                    fingerprints.push(previous.fingerprint_by_index(prev_index));\n-\n-                    let edges_iter = previous\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|&dst| prev_index_to_index[dst].as_ref().unwrap());\n-\n-                    let start = edge_list_data.len() as u32;\n-                    edge_list_data.extend(edges_iter.map(|i| SDNI::new(i.index())));\n-                    let end = edge_list_data.len() as u32;\n-                    edge_list_indices.push((start, end));\n-                }\n-            }\n-        }\n-\n-        debug_assert_eq!(nodes.len(), node_count);\n-        debug_assert_eq!(fingerprints.len(), node_count);\n-        debug_assert_eq!(edge_list_indices.len(), node_count);\n-        debug_assert_eq!(edge_list_data.len(), edge_count);\n-        debug_assert!(edge_list_data.len() <= u32::MAX as usize);\n-\n-        SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data }\n-    }\n-\n     pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n@@ -997,12 +907,251 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    pub fn print_incremental_info(&self) {\n+        #[derive(Clone)]\n+        struct Stat<Kind: DepKind> {\n+            kind: Kind,\n+            node_counter: u64,\n+            edge_counter: u64,\n+        }\n+\n+        let data = self.data.as_ref().unwrap();\n+        let prev = &data.previous;\n+        let current = &data.current;\n+        let data = current.data.lock();\n+\n+        let mut stats: FxHashMap<_, Stat<K>> = FxHashMap::with_hasher(Default::default());\n+\n+        for &hybrid_index in data.hybrid_indices.iter() {\n+            let (kind, edge_count) = match hybrid_index.into() {\n+                HybridIndex::New(new_index) => {\n+                    let kind = data.new.nodes[new_index].kind;\n+                    let edge_range = &data.new.edges[new_index];\n+                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n+                }\n+                HybridIndex::Red(red_index) => {\n+                    let kind = prev.index_to_node(data.red.node_indices[red_index]).kind;\n+                    let edge_range = &data.red.edges[red_index];\n+                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n+                }\n+                HybridIndex::LightGreen(lg_index) => {\n+                    let kind = prev.index_to_node(data.light_green.node_indices[lg_index]).kind;\n+                    let edge_range = &data.light_green.edges[lg_index];\n+                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    let kind = prev.index_to_node(prev_index).kind;\n+                    let edge_count = prev.edge_targets_from(prev_index).len();\n+                    (kind, edge_count)\n+                }\n+            };\n+\n+            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n+            stat.node_counter += 1;\n+            stat.edge_counter += edge_count as u64;\n+        }\n+\n+        let total_node_count = data.hybrid_indices.len();\n+        let total_edge_count = self.edge_count(&data);\n+\n+        // Drop the lock guard.\n+        std::mem::drop(data);\n+\n+        let mut stats: Vec<_> = stats.values().cloned().collect();\n+        stats.sort_by_key(|s| -(s.node_counter as i64));\n+\n+        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n+                                 ----------------------------------------------\\\n+                                 ------------\";\n+\n+        println!(\"[incremental]\");\n+        println!(\"[incremental] DepGraph Statistics\");\n+        println!(\"{}\", SEPARATOR);\n+        println!(\"[incremental]\");\n+        println!(\"[incremental] Total Node Count: {}\", total_node_count);\n+        println!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n+\n+        if cfg!(debug_assertions) {\n+            let total_edge_reads = current.total_read_count.load(Relaxed);\n+            let total_duplicate_edge_reads = current.total_duplicate_read_count.load(Relaxed);\n+\n+            println!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n+            println!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n+        }\n+\n+        println!(\"[incremental]\");\n+\n+        println!(\n+            \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n+            \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n+        );\n+\n+        println!(\n+            \"[incremental] -------------------------------------\\\n+                  |------------------\\\n+                  |-------------\\\n+                  |------------------|\"\n+        );\n+\n+        for stat in stats {\n+            let node_kind_ratio = (100.0 * (stat.node_counter as f64)) / (total_node_count as f64);\n+            let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n+\n+            println!(\n+                \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n+                format!(\"{:?}\", stat.kind),\n+                node_kind_ratio,\n+                stat.node_counter,\n+                node_kind_avg_edges,\n+            );\n+        }\n+\n+        println!(\"{}\", SEPARATOR);\n+        println!(\"[incremental]\");\n+    }\n+\n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n         let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n         DepNodeIndex::from_u32(index)\n     }\n }\n \n+impl<E: Encoder, K: DepKind + Encodable<E>> Encodable<E> for DepGraph<K> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n+        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n+        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n+        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n+        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n+        // be in sync. If you update this encoding, be sure to update the decoding, and vice-versa.\n+\n+        let data = self.data.as_ref().unwrap();\n+        let prev = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n+        let data = data.current.data.lock();\n+        let new = &data.new;\n+        let red = &data.red;\n+        let lg = &data.light_green;\n+\n+        let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n+\n+        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be encoded in `DepNodeIndex`\n+        // order. The edges in `edge_list_data` don't need to be in a particular order, as long as\n+        // each node references its edges as a contiguous range within it. Therefore, we can encode\n+        // `edge_list_data` directly from `unshared_edges`. It meets the above requirements, as\n+        // each non-dark-green node already knows the range of edges to reference within it, which\n+        // they'll encode in `edge_list_indices`. Dark green nodes, however, don't have their edges\n+        // in `unshared_edges`, so need to add them to `edge_list_data`.\n+\n+        use HybridIndex::*;\n+\n+        // Encoded values (nodes, etc.) are explicitly typed below to avoid inadvertently\n+        // serializing data in the wrong format (i.e. one incompatible with `SerializedDepGraph`).\n+        e.emit_struct(\"SerializedDepGraph\", 4, |e| {\n+            e.emit_struct_field(\"nodes\", 0, |e| {\n+                // `SerializedDepGraph` expects this to be encoded as a sequence of `DepNode`s.\n+                e.emit_seq(node_count, |e| {\n+                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n+                        let node: DepNode<K> = match hybrid_index.into() {\n+                            New(i) => new.nodes[i],\n+                            Red(i) => prev.index_to_node(red.node_indices[i]),\n+                            LightGreen(i) => prev.index_to_node(lg.node_indices[i]),\n+                            DarkGreen(prev_index) => prev.index_to_node(prev_index),\n+                        };\n+\n+                        e.emit_seq_elt(seq_index, |e| node.encode(e))?;\n+                    }\n+\n+                    Ok(())\n+                })\n+            })?;\n+\n+            e.emit_struct_field(\"fingerprints\", 1, |e| {\n+                // `SerializedDepGraph` expects this to be encoded as a sequence of `Fingerprints`s.\n+                e.emit_seq(node_count, |e| {\n+                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n+                        let fingerprint: Fingerprint = match hybrid_index.into() {\n+                            New(i) => new.fingerprints[i],\n+                            Red(i) => red.fingerprints[i],\n+                            LightGreen(i) => prev.fingerprint_by_index(lg.node_indices[i]),\n+                            DarkGreen(prev_index) => prev.fingerprint_by_index(prev_index),\n+                        };\n+\n+                        e.emit_seq_elt(seq_index, |e| fingerprint.encode(e))?;\n+                    }\n+\n+                    Ok(())\n+                })\n+            })?;\n+\n+            e.emit_struct_field(\"edge_list_indices\", 2, |e| {\n+                // `SerializedDepGraph` expects this to be encoded as a sequence of `(u32, u32)`s.\n+                e.emit_seq(node_count, |e| {\n+                    // Dark green node edges start after the unshared (all other nodes') edges.\n+                    let mut dark_green_edge_index = data.unshared_edges.len();\n+\n+                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n+                        let edge_indices: (u32, u32) = match hybrid_index.into() {\n+                            New(i) => (new.edges[i].start.as_u32(), new.edges[i].end.as_u32()),\n+                            Red(i) => (red.edges[i].start.as_u32(), red.edges[i].end.as_u32()),\n+                            LightGreen(i) => (lg.edges[i].start.as_u32(), lg.edges[i].end.as_u32()),\n+                            DarkGreen(prev_index) => {\n+                                let edge_count = prev.edge_targets_from(prev_index).len();\n+                                let start = dark_green_edge_index as u32;\n+                                dark_green_edge_index += edge_count;\n+                                let end = dark_green_edge_index as u32;\n+                                (start, end)\n+                            }\n+                        };\n+\n+                        e.emit_seq_elt(seq_index, |e| edge_indices.encode(e))?;\n+                    }\n+\n+                    assert_eq!(dark_green_edge_index, edge_count);\n+\n+                    Ok(())\n+                })\n+            })?;\n+\n+            e.emit_struct_field(\"edge_list_data\", 3, |e| {\n+                // `SerializedDepGraph` expects this to be encoded as a sequence of\n+                // `SerializedDepNodeIndex`.\n+                e.emit_seq(edge_count, |e| {\n+                    for (seq_index, &edge) in data.unshared_edges.iter().enumerate() {\n+                        let serialized_edge = SerializedDepNodeIndex::new(edge.index());\n+                        e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n+                    }\n+\n+                    let mut seq_index = data.unshared_edges.len();\n+\n+                    for &hybrid_index in data.hybrid_indices.iter() {\n+                        if let DarkGreen(prev_index) = hybrid_index.into() {\n+                            for &edge in prev.edge_targets_from(prev_index) {\n+                                // Dark green node edges are stored in the previous graph\n+                                // and must be converted to edges in the current graph,\n+                                // and then serialized as `SerializedDepNodeIndex`.\n+                                let serialized_edge = SerializedDepNodeIndex::new(\n+                                    prev_index_to_index[edge].as_ref().unwrap().index(),\n+                                );\n+\n+                                e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n+                                seq_index += 1;\n+                            }\n+                        }\n+                    }\n+\n+                    assert_eq!(seq_index, edge_count);\n+\n+                    Ok(())\n+                })\n+            })\n+        })\n+    }\n+}\n+\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code"}, {"sha": "c3d0f79525572467fe9b4ee04b967d6ae2147ebd", "filename": "compiler/rustc_query_system/src/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs?ref=09067db8a0098861c0ba03ead3cbb49579e9a055", "patch": "@@ -3,7 +3,7 @@ use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n \n-#[derive(Debug, Encodable, Decodable)]\n+#[derive(Debug)]\n pub struct PreviousDepGraph<K: DepKind> {\n     data: SerializedDepGraph<K>,\n     index: FxHashMap<DepNode<K>, SerializedDepNodeIndex>,"}, {"sha": "9bb922b0a9008a991c227464c9ccfc74a3eab59a", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09067db8a0098861c0ba03ead3cbb49579e9a055/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=09067db8a0098861c0ba03ead3cbb49579e9a055", "patch": "@@ -3,6 +3,7 @@\n use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n+use rustc_serialize::{Decodable, Decoder};\n \n // The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n // unused so that we can store multiple index types in `CompressedHybridIndex`,\n@@ -14,7 +15,7 @@ rustc_index::newtype_index! {\n }\n \n /// Data for use when recompiling the **current crate**.\n-#[derive(Debug, Encodable, Decodable)]\n+#[derive(Debug)]\n pub struct SerializedDepGraph<K: DepKind> {\n     /// The set of all DepNodes in the graph\n     pub nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>>,\n@@ -48,3 +49,79 @@ impl<K: DepKind> SerializedDepGraph<K> {\n         &self.edge_list_data[targets.0 as usize..targets.1 as usize]\n     }\n }\n+\n+impl<D: Decoder, K: DepKind + Decodable<D>> Decodable<D> for SerializedDepGraph<K> {\n+    fn decode(d: &mut D) -> Result<SerializedDepGraph<K>, D::Error> {\n+        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n+        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n+        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n+        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n+        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n+        // be in sync. If you update this decoding, be sure to update the encoding, and vice-versa.\n+        //\n+        // We mimic the sequence of `Encode` and `Encodable` method calls used by the `DepGraph`'s\n+        // `Encodable` implementation with the corresponding sequence of `Decode` and `Decodable`\n+        // method calls. E.g. `Decode::read_struct` pairs with `Encode::emit_struct`, `DepNode`'s\n+        // `decode` pairs with `DepNode`'s `encode`, and so on. Any decoding methods not associated\n+        // with corresponding encoding methods called in `DepGraph`'s `Encodable` implementation\n+        // are off limits, because we'd be relying on their implementation details.\n+        //\n+        // For example, because we know it happens to do the right thing, its tempting to just use\n+        // `IndexVec`'s `Decodable` implementation to decode into some of the collections below,\n+        // even though `DepGraph` doesn't use its `Encodable` implementation. But the `IndexVec`\n+        // implementation could change, and we'd have a bug.\n+        //\n+        // Variables below are explicitly typed so that anyone who changes the `SerializedDepGraph`\n+        // representation without updating this function will encounter a compilation error, and\n+        // know to update this and possibly the `DepGraph` `Encodable` implementation accordingly\n+        // (the latter should serialize data in a format compatible with our representation).\n+\n+        d.read_struct(\"SerializedDepGraph\", 4, |d| {\n+            let nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>> =\n+                d.read_struct_field(\"nodes\", 0, |d| {\n+                    d.read_seq(|d, len| {\n+                        let mut v = IndexVec::with_capacity(len);\n+                        for i in 0..len {\n+                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+                        }\n+                        Ok(v)\n+                    })\n+                })?;\n+\n+            let fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint> =\n+                d.read_struct_field(\"fingerprints\", 1, |d| {\n+                    d.read_seq(|d, len| {\n+                        let mut v = IndexVec::with_capacity(len);\n+                        for i in 0..len {\n+                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+                        }\n+                        Ok(v)\n+                    })\n+                })?;\n+\n+            let edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)> = d\n+                .read_struct_field(\"edge_list_indices\", 2, |d| {\n+                    d.read_seq(|d, len| {\n+                        let mut v = IndexVec::with_capacity(len);\n+                        for i in 0..len {\n+                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+                        }\n+                        Ok(v)\n+                    })\n+                })?;\n+\n+            let edge_list_data: Vec<SerializedDepNodeIndex> =\n+                d.read_struct_field(\"edge_list_data\", 3, |d| {\n+                    d.read_seq(|d, len| {\n+                        let mut v = Vec::with_capacity(len);\n+                        for i in 0..len {\n+                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+                        }\n+                        Ok(v)\n+                    })\n+                })?;\n+\n+            Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n+        })\n+    }\n+}"}]}