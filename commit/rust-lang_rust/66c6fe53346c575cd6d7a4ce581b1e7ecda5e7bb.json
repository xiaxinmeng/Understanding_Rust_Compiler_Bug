{"sha": "66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YzZmZTUzMzQ2YzU3NWNkNmQ3YTRjZTU4MWIxZTdlY2RhNWU3YmI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-23T13:18:07Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-23T13:18:07Z"}, "message": "Merge pull request #112 from marcusklaas/config-fix\n\nRemove global mutable config to allow for concurrency", "tree": {"sha": "aa9460e73e576defa78827c505153159bd4de6bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa9460e73e576defa78827c505153159bd4de6bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "html_url": "https://github.com/rust-lang/rust/commit/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1488d5eadb4ccd7138e0fb6fd6eb6911f6386255", "url": "https://api.github.com/repos/rust-lang/rust/commits/1488d5eadb4ccd7138e0fb6fd6eb6911f6386255", "html_url": "https://github.com/rust-lang/rust/commit/1488d5eadb4ccd7138e0fb6fd6eb6911f6386255"}, {"sha": "d7b49fd76ce4d38beda129c7b8a733e62729bcb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b49fd76ce4d38beda129c7b8a733e62729bcb0", "html_url": "https://github.com/rust-lang/rust/commit/d7b49fd76ce4d38beda129c7b8a733e62729bcb0"}], "stats": {"total": 210, "additions": 107, "deletions": 103}, "files": [{"sha": "7a16a5bca66b832fd4386ce68024c5beebb957b8", "filename": "src/changes.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -21,6 +21,7 @@ use std::fs::File;\n use std::io::{Write, stdout};\n use WriteMode;\n use NewlineStyle;\n+use config::Config;\n use utils::round_up_to_power_of_two;\n \n // This is basically a wrapper around a bunch of Ropes which makes it convenient\n@@ -130,11 +131,12 @@ impl<'a> ChangeSet<'a> {\n     }\n \n     pub fn write_all_files(&self,\n-                           mode: WriteMode)\n+                           mode: WriteMode,\n+                           config: &Config)\n                            -> Result<(HashMap<String, String>), ::std::io::Error> {\n         let mut result = HashMap::new();\n         for filename in self.file_map.keys() {\n-            let one_result = try!(self.write_file(filename, mode));\n+            let one_result = try!(self.write_file(filename, mode, config));\n             if let Some(r) = one_result {\n                 result.insert(filename.clone(), r);\n             }\n@@ -145,18 +147,20 @@ impl<'a> ChangeSet<'a> {\n \n     pub fn write_file(&self,\n                       filename: &str,\n-                      mode: WriteMode)\n+                      mode: WriteMode,\n+                      config: &Config)\n                       -> Result<Option<String>, ::std::io::Error> {\n         let text = &self.file_map[filename];\n \n         // prints all newlines either as `\\n` or as `\\r\\n`\n         fn write_system_newlines<T>(\n             mut writer: T,\n-            text: &StringBuffer)\n+            text: &StringBuffer,\n+            config: &Config)\n             -> Result<(), ::std::io::Error>\n             where T: Write,\n         {\n-            match config!(newline_style) {\n+            match config.newline_style {\n                 NewlineStyle::Unix => write!(writer, \"{}\", text),\n                 NewlineStyle::Windows => {\n                     for (c, _) in text.chars() {\n@@ -181,7 +185,7 @@ impl<'a> ChangeSet<'a> {\n                 {\n                     // Write text to temp file\n                     let tmp_file = try!(File::create(&tmp_name));\n-                    try!(write_system_newlines(tmp_file, text));\n+                    try!(write_system_newlines(tmp_file, text, config));\n                 }\n \n                 try!(::std::fs::rename(filename, bk_name));\n@@ -190,18 +194,18 @@ impl<'a> ChangeSet<'a> {\n             WriteMode::NewFile(extn) => {\n                 let filename = filename.to_owned() + \".\" + extn;\n                 let file = try!(File::create(&filename));\n-                try!(write_system_newlines(file, text));\n+                try!(write_system_newlines(file, text, config));\n             }\n             WriteMode::Display => {\n                 println!(\"{}:\\n\", filename);\n                 let stdout = stdout();\n                 let stdout_lock = stdout.lock();\n-                try!(write_system_newlines(stdout_lock, text));\n+                try!(write_system_newlines(stdout_lock, text, config));\n             }\n             WriteMode::Return(_) => {\n                 // io::Write is not implemented for String, working around with Vec<u8>\n                 let mut v = Vec::new();\n-                try!(write_system_newlines(&mut v, text));\n+                try!(write_system_newlines(&mut v, text, config));\n                 // won't panic, we are writing correct utf8\n                 return Ok(Some(String::from_utf8(v).unwrap()));\n             }"}, {"sha": "23285167689ef17276125640d6770e7b17deafbb", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -14,7 +14,7 @@ use {NewlineStyle, BraceStyle, ReturnIndent};\n use lists::SeparatorTactic;\n use issues::ReportTactic;\n \n-#[derive(RustcDecodable)]\n+#[derive(RustcDecodable, Clone)]\n pub struct Config {\n     pub max_width: usize,\n     pub ideal_width: usize,\n@@ -32,20 +32,8 @@ pub struct Config {\n }\n \n impl Config {\n-    fn from_toml(toml: &str) -> Config {\n+    pub fn from_toml(toml: &str) -> Config {\n         let parsed = toml.parse().unwrap();\n         toml::decode(parsed).unwrap()\n     }\n }\n-\n-pub fn set_config(toml: &str) {\n-    unsafe {\n-        ::CONFIG = Some(Config::from_toml(toml));\n-    }\n-}\n-\n-macro_rules! config {\n-    ($name: ident) => {\n-        unsafe { ::CONFIG.as_ref().unwrap().$name }\n-    };\n-}"}, {"sha": "dae64891ab3d3fcf2382adc33aa5986434bd429e", "filename": "src/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -62,7 +62,7 @@ fn rewrite_string_lit(context: &RewriteContext, s: &str, span: Span, width: usiz\n     // strings, or if the string is too long for the line.\n     let l_loc = context.codemap.lookup_char_pos(span.lo);\n     let r_loc = context.codemap.lookup_char_pos(span.hi);\n-    if l_loc.line == r_loc.line && r_loc.col.to_usize() <= config!(max_width) {\n+    if l_loc.line == r_loc.line && r_loc.col.to_usize() <= context.config.max_width {\n         return context.codemap.span_to_snippet(span).ok();\n     }\n \n@@ -82,7 +82,7 @@ fn rewrite_string_lit(context: &RewriteContext, s: &str, span: Span, width: usiz\n             // First line.\n             width - 2 // 2 = \" + \\\n         } else {\n-            config!(max_width) - offset - 1 // 1 = either \\ or ;\n+            context.config.max_width - offset - 1 // 1 = either \\ or ;\n         };\n \n         let mut cur_end = cur_start + max_chars;\n@@ -206,7 +206,7 @@ fn rewrite_struct_lit(context: &RewriteContext,\n         trailing_separator: if base.is_some() {\n             SeparatorTactic::Never\n         } else {\n-            config!(struct_lit_trailing_comma)\n+            context.config.struct_lit_trailing_comma\n         },\n         indent: indent,\n         h_width: budget,\n@@ -247,7 +247,7 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                               let rem_width = if i == items.len() - 1 {\n                                   width - 2\n                               } else {\n-                                  config!(max_width) - indent - 2\n+                                  context.config.max_width - indent - 2\n                               };\n                               item.rewrite(context, rem_width, indent)\n                           })"}, {"sha": "2dfa8a5fe651bf580a9d22c931839d729376c321", "filename": "src/items.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -144,7 +144,7 @@ impl<'a> FmtVisitor<'a> {\n \n         // Check if vertical layout was forced by compute_budget_for_args.\n         if one_line_budget <= 0 {\n-            if config!(fn_args_paren_newline) {\n+            if self.config.fn_args_paren_newline {\n                 result.push('\\n');\n                 result.push_str(&make_indent(arg_indent));\n                 arg_indent = arg_indent + 1; // extra space for `(`\n@@ -170,8 +170,8 @@ impl<'a> FmtVisitor<'a> {\n             // If we've already gone multi-line, or the return type would push\n             // over the max width, then put the return type on a new line.\n             if result.contains(\"\\n\") ||\n-               result.len() + indent + ret_str.len() > config!(max_width) {\n-                let indent = match config!(fn_return_indent) {\n+               result.len() + indent + ret_str.len() > self.config.max_width {\n+                let indent = match self.config.fn_return_indent {\n                     ReturnIndent::WithWhereClause => indent + 4,\n                     // TODO we might want to check that using the arg indent doesn't\n                     // blow our budget, and if it does, then fallback to the where\n@@ -363,15 +363,15 @@ impl<'a> FmtVisitor<'a> {\n             if !newline_brace {\n                 used_space += 2;\n             }\n-            let one_line_budget = if used_space > config!(max_width) {\n+            let one_line_budget = if used_space > self.config.max_width {\n                 0\n             } else {\n-                config!(max_width) - used_space\n+                self.config.max_width - used_space\n             };\n \n             // 2 = `()`\n             let used_space = indent + result.len() + 2;\n-            let max_space = config!(ideal_width) + config!(leeway);\n+            let max_space = self.config.ideal_width + self.config.leeway;\n             debug!(\"compute_budgets_for_args: used_space: {}, max_space: {}\",\n                    used_space, max_space);\n             if used_space < max_space {\n@@ -383,9 +383,9 @@ impl<'a> FmtVisitor<'a> {\n \n         // Didn't work. we must force vertical layout and put args on a newline.\n         if let None = budgets {\n-            let new_indent = indent + config!(tab_spaces);\n+            let new_indent = indent + self.config.tab_spaces;\n             let used_space = new_indent + 2; // account for `(` and `)`\n-            let max_space = config!(ideal_width) + config!(leeway);\n+            let max_space = self.config.ideal_width + self.config.leeway;\n             if used_space > max_space {\n                 // Whoops! bankrupt.\n                 // TODO take evasive action, perhaps kill the indent or something.\n@@ -398,7 +398,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn newline_for_brace(&self, where_clause: &ast::WhereClause) -> bool {\n-        match config!(fn_brace_style) {\n+        match self.config.fn_brace_style {\n             BraceStyle::AlwaysNextLine => true,\n             BraceStyle::SameLineWhere if where_clause.predicates.len() > 0 => true,\n             _ => false,\n@@ -421,7 +421,7 @@ impl<'a> FmtVisitor<'a> {\n         self.changes.push_str_span(span, &generics_str);\n \n         self.last_pos = body_start;\n-        self.block_indent += config!(tab_spaces);\n+        self.block_indent += self.config.tab_spaces;\n         for (i, f) in enum_def.variants.iter().enumerate() {\n             let next_span_start: BytePos = if i == enum_def.variants.len() - 1 {\n                 span.hi\n@@ -431,7 +431,7 @@ impl<'a> FmtVisitor<'a> {\n \n             self.visit_variant(f, i == enum_def.variants.len() - 1, next_span_start);\n         }\n-        self.block_indent -= config!(tab_spaces);\n+        self.block_indent -= self.config.tab_spaces;\n \n         self.format_missing_with_indent(span.lo + BytePos(enum_snippet.rfind('}').unwrap() as u32));\n         self.changes.push_str_span(span, \"}\");\n@@ -478,8 +478,8 @@ impl<'a> FmtVisitor<'a> {\n                              + field.node.name.to_string().len()\n                              + 1; // 1 = (\n \n-                let comma_cost = if config!(enum_trailing_comma) { 1 } else { 0 };\n-                let budget = config!(ideal_width) - indent - comma_cost - 1; // 1 = )\n+                let comma_cost = if self.config.enum_trailing_comma { 1 } else { 0 };\n+                let budget = self.config.ideal_width - indent - comma_cost - 1; // 1 = )\n \n                 let fmt = ListFormatting {\n                     tactic: ListTactic::HorizontalVertical,\n@@ -500,13 +500,13 @@ impl<'a> FmtVisitor<'a> {\n \n                 // Make sure we do not exceed column limit\n                 // 4 = \" = ,\"\n-                assert!(config!(max_width) >= vis.len() + name.len() + expr_snippet.len() + 4,\n+                assert!(self.config.max_width >= vis.len() + name.len() + expr_snippet.len() + 4,\n                         \"Enum variant exceeded column limit\");\n             }\n \n             self.changes.push_str_span(field.span, &result);\n \n-            if !last_field || config!(enum_trailing_comma) {\n+            if !last_field || self.config.enum_trailing_comma {\n                 self.changes.push_str_span(field.span, \",\");\n             }\n         }\n@@ -543,11 +543,11 @@ impl<'a> FmtVisitor<'a> {\n         // This will drop the comment in between the header and body.\n         self.last_pos = span.lo + BytePos(struct_snippet.find_uncommented(\"{\").unwrap() as u32 + 1);\n \n-        self.block_indent += config!(tab_spaces);\n+        self.block_indent += self.config.tab_spaces;\n         for (i, f) in struct_def.fields.iter().enumerate() {\n             self.visit_field(f, i == struct_def.fields.len() - 1, span.lo, &struct_snippet);\n         }\n-        self.block_indent -= config!(tab_spaces);\n+        self.block_indent -= self.config.tab_spaces;\n \n         self.format_missing_with_indent(span.lo + BytePos(struct_snippet.rfind('}').unwrap() as u32));\n         self.changes.push_str_span(span, \"}\");\n@@ -608,21 +608,21 @@ impl<'a> FmtVisitor<'a> {\n \n         let mut field_str = match name {\n             Some(name) => {\n-                let budget = config!(ideal_width) - self.block_indent;\n+                let budget = self.config.ideal_width - self.block_indent;\n                 // 3 is being conservative and assuming that there will be a trailing comma.\n                 if self.block_indent + vis.len() + name.len() + typ.len() + 3 > budget {\n                     format!(\"{}{}:\\n{}{}\",\n                             vis,\n                             name,\n-                            &make_indent(self.block_indent + config!(tab_spaces)),\n+                            &make_indent(self.block_indent + self.config.tab_spaces),\n                             typ)\n                 } else {\n                     format!(\"{}{}: {}\", vis, name, typ)\n                 }\n             }\n             None => format!(\"{}{}\", vis, typ),\n         };\n-        if !last_field || config!(struct_trailing_comma) {\n+        if !last_field || self.config.struct_trailing_comma {\n             field_str.push(',');\n         }\n         self.changes.push_str_span(field.span, &field_str);\n@@ -647,7 +647,7 @@ impl<'a> FmtVisitor<'a> {\n             return result;\n         }\n \n-        let budget = config!(max_width) - indent - 2;\n+        let budget = self.config.max_width - indent - 2;\n         // TODO might need to insert a newline if the generics are really long\n         result.push('<');\n \n@@ -723,7 +723,7 @@ impl<'a> FmtVisitor<'a> {\n                                                         .zip(comments.into_iter())\n                                                         .collect();\n \n-        let budget = config!(ideal_width) + config!(leeway) - indent - 10;\n+        let budget = self.config.ideal_width + self.config.leeway - indent - 10;\n         let fmt = ListFormatting {\n             tactic: ListTactic::Vertical,\n             separator: \",\","}, {"sha": "dfcf4c7042414877a8075a51e3bee8c91bf66628", "filename": "src/lib.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -41,10 +41,12 @@ use syntax::visit;\n use std::path::PathBuf;\n use std::collections::HashMap;\n use std::fmt;\n+use std::mem::swap;\n \n use issues::{BadIssueSeeker, Issue};\n use changes::ChangeSet;\n use visitor::FmtVisitor;\n+use config::Config;\n \n #[macro_use]\n mod config;\n@@ -65,8 +67,6 @@ const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n \n-static mut CONFIG: Option<config::Config> = None;\n-\n #[derive(Copy, Clone)]\n pub enum WriteMode {\n     Overwrite,\n@@ -109,7 +109,7 @@ pub enum ReturnIndent {\n impl_enum_decodable!(ReturnIndent, WithArgs, WithWhereClause);\n \n enum ErrorKind {\n-    // Line has more than config!(max_width) characters\n+    // Line has exceeded character limit\n     LineOverflow,\n     // Line ends in whitespace\n     TrailingWhitespace,\n@@ -161,8 +161,8 @@ impl fmt::Display for FormatReport {\n }\n \n // Formatting which depends on the AST.\n-fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n-    let mut visitor = FmtVisitor::from_codemap(codemap);\n+fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap, config: &'a Config) -> ChangeSet<'a> {\n+    let mut visitor = FmtVisitor::from_codemap(codemap, config);\n     visit::walk_crate(&mut visitor, krate);\n     let files = codemap.files.borrow();\n     if let Some(last) = files.last() {\n@@ -175,7 +175,7 @@ fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n // Formatting done on a char by char or line by line basis.\n // TODO warn on bad license\n // TODO other stuff for parity with make tidy\n-fn fmt_lines(changes: &mut ChangeSet) -> FormatReport {\n+fn fmt_lines(changes: &mut ChangeSet, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n     let mut report = FormatReport { file_error_map: HashMap::new() };\n \n@@ -187,8 +187,8 @@ fn fmt_lines(changes: &mut ChangeSet) -> FormatReport {\n         let mut cur_line = 1;\n         let mut newline_count = 0;\n         let mut errors = vec![];\n-        let mut issue_seeker = BadIssueSeeker::new(config!(report_todo),\n-                                                   config!(report_fixme));\n+        let mut issue_seeker = BadIssueSeeker::new(config.report_todo,\n+                                                   config.report_fixme);\n \n         for (c, b) in text.chars() {\n             if c == '\\r' { continue; }\n@@ -208,7 +208,7 @@ fn fmt_lines(changes: &mut ChangeSet) -> FormatReport {\n                     line_len -= b - lw;\n                 }\n                 // Check for any line width errors we couldn't correct.\n-                if line_len > config!(max_width) {\n+                if line_len > config.max_width {\n                     errors.push(FormattingError {\n                         line: cur_line,\n                         kind: ErrorKind::LineOverflow\n@@ -256,6 +256,7 @@ fn fmt_lines(changes: &mut ChangeSet) -> FormatReport {\n struct RustFmtCalls {\n     input_path: Option<PathBuf>,\n     write_mode: WriteMode,\n+    config: Option<Box<config::Config>>,\n }\n \n impl<'a> CompilerCalls<'a> for RustFmtCalls {\n@@ -302,18 +303,23 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n \n     fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n         let write_mode = self.write_mode;\n+\n+        let mut config_option = None;\n+        swap(&mut self.config, &mut config_option);\n+        let config = config_option.unwrap();\n+\n         let mut control = driver::CompileController::basic();\n         control.after_parse.stop = Compilation::Stop;\n         control.after_parse.callback = Box::new(move |state| {\n             let krate = state.krate.unwrap();\n             let codemap = state.session.codemap();\n-            let mut changes = fmt_ast(krate, codemap);\n+            let mut changes = fmt_ast(krate, codemap, &*config);\n             // For some reason, the codemap does not include terminating newlines\n             // so we must add one on for each file. This is sad.\n             changes.append_newlines();\n-            println!(\"{}\", fmt_lines(&mut changes));\n+            println!(\"{}\", fmt_lines(&mut changes, &*config));\n \n-            let result = changes.write_all_files(write_mode);\n+            let result = changes.write_all_files(write_mode, &*config);\n \n             match result {\n                 Err(msg) => println!(\"Error writing files: {}\", msg),\n@@ -335,8 +341,7 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n // WriteMode.\n // default_config is a string of toml data to be used to configure rustfmt.\n pub fn run(args: Vec<String>, write_mode: WriteMode, default_config: &str) {\n-    config::set_config(default_config);\n-\n-    let mut call_ctxt = RustFmtCalls { input_path: None, write_mode: write_mode };\n+    let config = Some(Box::new(config::Config::from_toml(default_config)));\n+    let mut call_ctxt = RustFmtCalls { input_path: None, write_mode: write_mode, config: config };\n     rustc_driver::run_compiler(&args, &mut call_ctxt);\n }"}, {"sha": "78d611253dd3fec11f6f34532672661fcb585868", "filename": "src/rewrite.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -12,6 +12,8 @@\n \n use syntax::codemap::CodeMap;\n \n+use config::Config;\n+\n pub trait Rewrite {\n     /// Rewrite self into offset and width.\n     /// `offset` is the indentation of the first line. The next lines\n@@ -25,4 +27,5 @@ pub trait Rewrite {\n \n pub struct RewriteContext<'a> {\n     pub codemap: &'a CodeMap,\n+    pub config: &'a Config,\n }"}, {"sha": "88b5d4b18dccc2ddf84599f52472d5e132a2bd13", "filename": "src/visitor.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -13,6 +13,7 @@ use syntax::codemap::{self, CodeMap, Span, BytePos};\n use syntax::visit;\n \n use utils;\n+use config::Config;\n \n use SKIP_ANNOTATION;\n use changes::ChangeSet;\n@@ -24,6 +25,7 @@ pub struct FmtVisitor<'a> {\n     pub last_pos: BytePos,\n     // TODO RAII util for indenting\n     pub block_indent: usize,\n+    pub config: &'a Config,\n }\n \n impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n@@ -33,14 +35,12 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n         let offset = self.changes.cur_offset_span(ex.span);\n-        match ex.rewrite(&RewriteContext { codemap: self.codemap },\n-                         config!(max_width) - offset,\n-                         offset) {\n-            Some(new_str) => {\n-                self.changes.push_str_span(ex.span, &new_str);\n-                self.last_pos = ex.span.hi;\n-            }\n-            None => { self.last_pos = ex.span.lo; }\n+        let context = RewriteContext { codemap: self.codemap, config: self.config };\n+        let rewrite = ex.rewrite(&context, self.config.max_width - offset, offset);\n+\n+        if let Some(new_str) = rewrite {\n+            self.changes.push_str_span(ex.span, &new_str);\n+            self.last_pos = ex.span.hi;\n         }\n     }\n \n@@ -72,7 +72,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n         self.changes.push_str_span(b.span, \"{\");\n         self.last_pos = self.last_pos + BytePos(1);\n-        self.block_indent += config!(tab_spaces);\n+        self.block_indent += self.config.tab_spaces;\n \n         for stmt in &b.stmts {\n             self.visit_stmt(&stmt)\n@@ -85,7 +85,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             None => {}\n         }\n \n-        self.block_indent -= config!(tab_spaces);\n+        self.block_indent -= self.config.tab_spaces;\n         // TODO we should compress any newlines here to just one\n         self.format_missing_with_indent(b.span.hi - BytePos(1));\n         self.changes.push_str_span(b.span, \"}\");\n@@ -162,8 +162,8 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 match vp.node {\n                     ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n                         let block_indent = self.block_indent;\n-                        let one_line_budget = config!(max_width) - block_indent;\n-                        let multi_line_budget = config!(ideal_width) - block_indent;\n+                        let one_line_budget = self.config.max_width - block_indent;\n+                        let multi_line_budget = self.config.ideal_width - block_indent;\n                         let formatted = self.rewrite_use_list(block_indent,\n                                                               one_line_budget,\n                                                               multi_line_budget,\n@@ -183,6 +183,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                             };\n                             self.format_missing(span_end);\n                         }\n+\n                         self.last_pos = item.span.hi;\n                     }\n                     ast::ViewPath_::ViewPathGlob(_) => {\n@@ -195,9 +196,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             ast::Item_::ItemImpl(..) |\n             ast::Item_::ItemMod(_) |\n             ast::Item_::ItemTrait(..) => {\n-                self.block_indent += config!(tab_spaces);\n+                self.block_indent += self.config.tab_spaces;\n                 visit::walk_item(self, item);\n-                self.block_indent -= config!(tab_spaces);\n+                self.block_indent -= self.config.tab_spaces;\n             }\n             ast::Item_::ItemExternCrate(_) => {\n                 self.format_missing_with_indent(item.span.lo);\n@@ -273,12 +274,13 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n }\n \n impl<'a> FmtVisitor<'a> {\n-    pub fn from_codemap<'b>(codemap: &'b CodeMap) -> FmtVisitor<'b> {\n+    pub fn from_codemap<'b>(codemap: &'b CodeMap, config: &'b Config) -> FmtVisitor<'b> {\n         FmtVisitor {\n             codemap: codemap,\n             changes: ChangeSet::from_codemap(codemap),\n             last_pos: BytePos(0),\n             block_indent: 0,\n+            config: config\n         }\n     }\n "}, {"sha": "4b29376ffa77b1f00e7d498f106c24d9e940afc9", "filename": "tests/system.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "patch": "@@ -26,39 +26,44 @@ fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n     path.to_str().expect(\"Couldn't stringify path.\").to_owned()\n }\n \n-// Integration tests and idempotence tests. The files in the tests/source are\n-// formatted and compared to their equivalent in tests/target. The target file\n-// and config can be overriden by annotations in the source file. The input and\n-// output must match exactly.\n-// Files in tests/target are checked to be unaltered by rustfmt.\n-// FIXME(#28) would be good to check for error messages and fail on them, or at least report.\n+// Integration tests. The files in the tests/source are formatted and compared\n+// to their equivalent in tests/target. The target file and config can be\n+// overriden by annotations in the source file. The input and output must match\n+// exactly.\n+// FIXME(#28) would be good to check for error messages and fail on them, or at\n+// least report.\n #[test]\n fn system_tests() {\n-    // Get all files in the tests/target directory\n-    let files = fs::read_dir(\"tests/target\").ok().expect(\"Couldn't read dir 1.\");\n-    let files = files.chain(fs::read_dir(\"tests\").ok().expect(\"Couldn't read dir 2.\"));\n-    let files = files.chain(fs::read_dir(\"src/bin\").ok().expect(\"Couldn't read dir 3.\"));\n+    // Get all files in the tests/source directory\n+    let files = fs::read_dir(\"tests/source\").ok().expect(\"Couldn't read source dir.\");\n     // turn a DirEntry into a String that represents the relative path to the file\n     let files = files.map(get_path_string);\n-    // hack because there's no `IntoIterator` impl for `[T; N]`\n-    let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n     let (count, fails) = check_files(files);\n \n     // Display results\n-    println!(\"Ran {} idempotent tests.\", count);\n-    assert!(fails == 0, \"{} idempotent tests failed\", fails);\n+    println!(\"Ran {} system tests.\", count);\n+    assert!(fails == 0, \"{} system tests failed\", fails);\n+}\n \n-    // Get all files in the tests/source directory\n-    let files = fs::read_dir(\"tests/source\").ok().expect(\"Couldn't read dir 4.\");\n+// Idempotence tests. Files in tests/target are checked to be unaltered by\n+// rustfmt.\n+#[test]\n+fn idempotence_tests() {\n+    // Get all files in the tests/target directory\n+    let files = fs::read_dir(\"tests/target\").ok().expect(\"Couldn't read target dir.\");\n+    let files = files.chain(fs::read_dir(\"tests\").ok().expect(\"Couldn't read tests dir.\"));\n+    let files = files.chain(fs::read_dir(\"src/bin\").ok().expect(\"Couldn't read src dir.\"));\n     // turn a DirEntry into a String that represents the relative path to the file\n     let files = files.map(get_path_string);\n+    // hack because there's no `IntoIterator` impl for `[T; N]`\n+    let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n     let (count, fails) = check_files(files);\n \n     // Display results\n-    println!(\"Ran {} system tests.\", count);\n-    assert!(fails == 0, \"{} system tests failed\", fails);\n+    println!(\"Ran {} idempotent tests.\", count);\n+    assert!(fails == 0, \"{} idempotent tests failed\", fails);\n }\n \n // For each file, run rustfmt and collect the output.\n@@ -71,12 +76,9 @@ fn check_files<I>(files: I) -> (u32, u32)\n \n     for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n         println!(\"Testing '{}'...\", file_name);\n-        match idempotent_check(file_name) {\n-            Ok(()) => {},\n-            Err(m) => {\n-                print_mismatches(m);\n-                fails += 1;\n-            },\n+        if let Err(msg) = idempotent_check(file_name) {\n+            print_mismatches(msg);\n+            fails += 1;\n         }\n         count += 1;\n     }"}]}