{"sha": "090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MGIyNDcwNTZhOWRkMmQ0ZDRhMzJjNjMxZmUyZjBkZGQzZTc0NGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-09T03:46:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-16T02:00:19Z"}, "message": "Spawn new tasks onto the primary scheduler by default. #3760", "tree": {"sha": "b7b9d7ab483fa7150480f90c9a5ad69905753685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7b9d7ab483fa7150480f90c9a5ad69905753685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "html_url": "https://github.com/rust-lang/rust/commit/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989667e545cb45265d3cb4b19500224459c3bf8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/989667e545cb45265d3cb4b19500224459c3bf8c", "html_url": "https://github.com/rust-lang/rust/commit/989667e545cb45265d3cb4b19500224459c3bf8c"}], "stats": {"total": 234, "additions": 145, "deletions": 89}, "files": [{"sha": "86d38a18c50b5e3e316ea929cdf4ee774144aaec", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 41, "deletions": 59, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "patch": "@@ -52,7 +52,7 @@ use prelude::*;\n use ptr;\n use result;\n use task::local_data_priv::{local_get, local_set};\n-use task::rt::{task_id, rust_task};\n+use task::rt::{task_id, sched_id, rust_task};\n use task;\n use util;\n use util::replace;\n@@ -62,6 +62,12 @@ pub mod local_data;\n pub mod rt;\n pub mod spawn;\n \n+/// A handle to a scheduler\n+#[deriving_eq]\n+pub enum Scheduler {\n+    SchedulerHandle(sched_id)\n+}\n+\n /// A handle to a task\n #[deriving_eq]\n pub enum Task {\n@@ -95,7 +101,21 @@ impl TaskResult : Eq {\n }\n \n /// Scheduler modes\n+#[deriving_eq]\n pub enum SchedMode {\n+    /// Run task on the default scheduler\n+    DefaultScheduler,\n+    /// Run task on the current scheduler\n+    CurrentScheduler,\n+    /// Run task on a specific scheduler\n+    ExistingScheduler(Scheduler),\n+    /**\n+     * Tasks are scheduled on the main OS thread\n+     *\n+     * The main OS thread is the thread used to launch the runtime which,\n+     * in most cases, is the process's initial thread as created by the OS.\n+     */\n+    PlatformThread,\n     /// All tasks run in the same OS thread\n     SingleThreaded,\n     /// Tasks are distributed among available CPUs\n@@ -104,53 +124,6 @@ pub enum SchedMode {\n     ThreadPerTask,\n     /// Tasks are distributed among a fixed number of OS threads\n     ManualThreads(uint),\n-    /**\n-     * Tasks are scheduled on the main OS thread\n-     *\n-     * The main OS thread is the thread used to launch the runtime which,\n-     * in most cases, is the process's initial thread as created by the OS.\n-     */\n-    PlatformThread\n-}\n-\n-impl SchedMode : cmp::Eq {\n-    pure fn eq(&self, other: &SchedMode) -> bool {\n-        match (*self) {\n-            SingleThreaded => {\n-                match (*other) {\n-                    SingleThreaded => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerCore => {\n-                match (*other) {\n-                    ThreadPerCore => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerTask => {\n-                match (*other) {\n-                    ThreadPerTask => true,\n-                    _ => false\n-                }\n-            }\n-            ManualThreads(e0a) => {\n-                match (*other) {\n-                    ManualThreads(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            PlatformThread => {\n-                match (*other) {\n-                    PlatformThread => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &SchedMode) -> bool {\n-        !(*self).eq(other)\n-    }\n }\n \n /**\n@@ -204,7 +177,7 @@ pub type TaskOpts = {\n     linked: bool,\n     supervised: bool,\n     mut notify_chan: Option<Chan<TaskResult>>,\n-    sched: Option<SchedOpts>,\n+    sched: SchedOpts,\n };\n \n /**\n@@ -370,7 +343,7 @@ impl TaskBuilder {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n                 mut notify_chan: move notify_chan,\n-                sched: Some({ mode: mode, foreign_stack_size: None})\n+                sched: { mode: mode, foreign_stack_size: None}\n             },\n             can_not_copy: None,\n             .. self.consume()\n@@ -486,7 +459,10 @@ pub fn default_task_opts() -> TaskOpts {\n         linked: true,\n         supervised: false,\n         mut notify_chan: None,\n-        sched: None\n+        sched: {\n+            mode: DefaultScheduler,\n+            foreign_stack_size: None\n+        }\n     }\n }\n \n@@ -539,10 +515,9 @@ pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n \n pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     /*!\n-     * Creates a new scheduler and executes a task on it\n-     *\n-     * Tasks subsequently spawned by that task will also execute on\n-     * the new scheduler. When there are no more tasks to execute the\n+     * Creates a new task on a new or existing scheduler\n+\n+     * When there are no more tasks to execute the\n      * scheduler terminates.\n      *\n      * # Failure\n@@ -590,6 +565,10 @@ pub fn get_task() -> Task {\n     TaskHandle(rt::get_task_id())\n }\n \n+pub fn get_scheduler() -> Scheduler {\n+    SchedulerHandle(rt::rust_get_sched_id())\n+}\n+\n /**\n  * Temporarily make the task unkillable\n  *\n@@ -927,16 +906,19 @@ fn test_spawn_sched() {\n }\n \n #[test]\n-fn test_spawn_sched_childs_on_same_sched() {\n+fn test_spawn_sched_childs_on_default_sched() {\n     let po = oldcomm::Port();\n     let ch = oldcomm::Chan(&po);\n \n+    // Assuming tests run on the default scheduler\n+    let default_id = rt::rust_get_sched_id();\n+\n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = rt::rust_get_sched_id();\n         do spawn {\n             let child_sched_id = rt::rust_get_sched_id();\n-            // This should be on the same scheduler\n-            assert parent_sched_id == child_sched_id;\n+            assert parent_sched_id != child_sched_id;\n+            assert child_sched_id == default_id;\n             oldcomm::send(ch, ());\n         };\n     };\n@@ -1206,7 +1188,7 @@ fn test_spawn_thread_on_demand() {\n \n         let (port2, chan2) = pipes::stream();\n \n-        do spawn() |move chan2| {\n+        do spawn_sched(CurrentScheduler) |move chan2| {\n             chan2.send(());\n         }\n "}, {"sha": "e3afa7c45353e4d4d7d61cb05f0cb3764baef151", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "patch": "@@ -88,6 +88,7 @@ use task::rt::rust_closure;\n use task::rt;\n use task::{Failure, ManualThreads, PlatformThread, SchedOpts, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult, ThreadPerCore, ThreadPerTask};\n+use task::{ExistingScheduler, SchedulerHandle};\n use task::{default_task_opts, unkillable};\n use uint;\n use util;\n@@ -525,9 +526,9 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n             // Create child task.\n-            let new_task = match opts.sched {\n-              None             => rt::new_task(),\n-              Some(sched_opts) => new_task_in_new_sched(sched_opts)\n+            let new_task = match opts.sched.mode {\n+                DefaultScheduler => rt::new_task(),\n+                _ => new_task_in_sched(opts.sched)\n             };\n             assert !new_task.is_null();\n             // Getting killed after here would leak the task.\n@@ -631,12 +632,16 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n         }\n     }\n \n-    fn new_task_in_new_sched(opts: SchedOpts) -> *rust_task {\n+    fn new_task_in_sched(opts: SchedOpts) -> *rust_task {\n         if opts.foreign_stack_size != None {\n             fail ~\"foreign_stack_size scheduler option unimplemented\";\n         }\n \n         let num_threads = match opts.mode {\n+          DefaultScheduler\n+          | CurrentScheduler\n+          | ExistingScheduler(*)\n+          | PlatformThread => 0u, /* Won't be used */\n           SingleThreaded => 1u,\n           ThreadPerCore => rt::rust_num_threads(),\n           ThreadPerTask => {\n@@ -648,13 +653,13 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n             }\n             threads\n           }\n-          PlatformThread => 0u /* Won't be used */\n         };\n \n-        let sched_id = if opts.mode != PlatformThread {\n-            rt::rust_new_sched(num_threads)\n-        } else {\n-            rt::rust_osmain_sched_id()\n+        let sched_id = match opts.mode {\n+            CurrentScheduler => rt::rust_get_sched_id(),\n+            ExistingScheduler(SchedulerHandle(id)) => id,\n+            PlatformThread => rt::rust_osmain_sched_id(),\n+            _ => rt::rust_new_sched(num_threads)\n         };\n         rt::rust_new_task_in_sched(sched_id)\n     }"}, {"sha": "803da32cbc8ac7cffa5c8c6631ce5fdc31b69bee", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "patch": "@@ -43,8 +43,8 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     rust_kernel *kernel = new rust_kernel(env);\n \n-    // Create the main scheduler and the main task\n-    rust_sched_id sched_id = kernel->create_scheduler(env->num_sched_threads);\n+    // Create the main task\n+    rust_sched_id sched_id = kernel->main_sched_id();\n     rust_scheduler *sched = kernel->get_scheduler_by_id(sched_id);\n     assert(sched != NULL);\n     rust_task *root_task = sched->create_task(NULL, \"main\");"}, {"sha": "cbc58e85db614f4b12581e71a191230dcad75f75", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "patch": "@@ -652,7 +652,10 @@ new_task_common(rust_scheduler *sched, rust_task *parent) {\n extern \"C\" CDECL rust_task*\n new_task() {\n     rust_task *task = rust_get_current_task();\n-    return new_task_common(task->sched, task);\n+    rust_sched_id sched_id = task->kernel->main_sched_id();\n+    rust_scheduler *sched = task->kernel->get_scheduler_by_id(sched_id);\n+    assert(sched != NULL && \"should always have a main scheduler\");\n+    return new_task_common(sched, task);\n }\n \n extern \"C\" CDECL rust_task*"}, {"sha": "cc98b474ee35731384965fc56836030837a5a0e4", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 74, "deletions": 17, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "patch": "@@ -30,6 +30,7 @@ rust_kernel::rust_kernel(rust_env *env) :\n     rval(0),\n     max_sched_id(1),\n     killed(false),\n+    already_exiting(false),\n     sched_reaper(this),\n     osmain_driver(NULL),\n     non_weak_tasks(0),\n@@ -38,13 +39,20 @@ rust_kernel::rust_kernel(rust_env *env) :\n     env(env)\n \n {\n-\n     // Create the single threaded scheduler that will run on the platform's\n     // main thread\n-    rust_manual_sched_launcher_factory *launchfac =\n+    rust_manual_sched_launcher_factory *osmain_launchfac =\n         new rust_manual_sched_launcher_factory();\n-    osmain_scheduler = create_scheduler(launchfac, 1, false);\n-    osmain_driver = launchfac->get_driver();\n+    osmain_scheduler = create_scheduler(osmain_launchfac, 1, false);\n+    osmain_driver = osmain_launchfac->get_driver();\n+\n+    // Create the primary scheduler\n+    rust_thread_sched_launcher_factory *main_launchfac =\n+        new rust_thread_sched_launcher_factory();\n+    main_scheduler = create_scheduler(main_launchfac,\n+                                      env->num_sched_threads,\n+                                      false);\n+\n     sched_reaper.start();\n }\n \n@@ -103,15 +111,22 @@ rust_kernel::create_scheduler(rust_sched_launcher_factory *launchfac,\n     {\n         scoped_lock with(sched_lock);\n \n+        /*if (sched_table.size() == 2) {\n+            // The main and OS main schedulers may not exit while there are\n+            // other schedulers\n+            KLOG_(\"Disallowing main scheduler to exit\");\n+            rust_scheduler *main_sched =\n+                get_scheduler_by_id_nolock(main_scheduler);\n+            assert(main_sched != NULL);\n+            main_sched->disallow_exit();\n+        }\n         if (sched_table.size() == 1) {\n-            // The OS main scheduler may not exit while there are other\n-            // schedulers\n             KLOG_(\"Disallowing osmain scheduler to exit\");\n-            rust_scheduler *sched =\n+            rust_scheduler *osmain_sched =\n                 get_scheduler_by_id_nolock(osmain_scheduler);\n-            assert(sched != NULL);\n-            sched->disallow_exit();\n-        }\n+            assert(osmain_sched != NULL);\n+            osmain_sched->disallow_exit();\n+            }*/\n \n         id = max_sched_id++;\n         assert(id != INTPTR_MAX && \"Hit the maximum scheduler id\");\n@@ -175,14 +190,21 @@ rust_kernel::wait_for_schedulers()\n             sched_table.erase(iter);\n             sched->join_task_threads();\n             sched->deref();\n+            /*if (sched_table.size() == 2) {\n+                KLOG_(\"Allowing main scheduler to exit\");\n+                // It's only the main schedulers left. Tell them to exit\n+                rust_scheduler *main_sched =\n+                    get_scheduler_by_id_nolock(main_scheduler);\n+                assert(main_sched != NULL);\n+                main_sched->allow_exit();\n+            }\n             if (sched_table.size() == 1) {\n                 KLOG_(\"Allowing osmain scheduler to exit\");\n-                // It's only the osmain scheduler left. Tell it to exit\n-                rust_scheduler *sched =\n+                rust_scheduler *osmain_sched =\n                     get_scheduler_by_id_nolock(osmain_scheduler);\n-                assert(sched != NULL);\n-                sched->allow_exit();\n-            }\n+                assert(osmain_sched != NULL);\n+                osmain_sched->allow_exit();\n+            }*/\n         }\n         if (!sched_table.empty()) {\n             sched_lock.wait();\n@@ -318,13 +340,31 @@ rust_kernel::register_task() {\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n }\n \n+void\n+rust_kernel::allow_scheduler_exit() {\n+    scoped_lock with(sched_lock);\n+\n+    KLOG_(\"Allowing main scheduler to exit\");\n+    // It's only the main schedulers left. Tell them to exit\n+    rust_scheduler *main_sched =\n+        get_scheduler_by_id_nolock(main_scheduler);\n+    assert(main_sched != NULL);\n+    main_sched->allow_exit();\n+\n+    KLOG_(\"Allowing osmain scheduler to exit\");\n+    rust_scheduler *osmain_sched =\n+        get_scheduler_by_id_nolock(osmain_scheduler);\n+    assert(osmain_sched != NULL);\n+    osmain_sched->allow_exit();\n+}\n+\n void\n rust_kernel::unregister_task() {\n     KLOG_(\"Unregistering task\");\n     uintptr_t new_non_weak_tasks = sync::decrement(non_weak_tasks);\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n     if (new_non_weak_tasks == 0) {\n-        end_weak_tasks();\n+        begin_shutdown();\n     }\n }\n \n@@ -338,7 +378,7 @@ rust_kernel::weaken_task(rust_port_id chan) {\n     uintptr_t new_non_weak_tasks = sync::decrement(non_weak_tasks);\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n     if (new_non_weak_tasks == 0) {\n-        end_weak_tasks();\n+        begin_shutdown();\n     }\n }\n \n@@ -374,6 +414,23 @@ rust_kernel::end_weak_tasks() {\n     }\n }\n \n+void\n+rust_kernel::begin_shutdown() {\n+    {\n+        scoped_lock with(sched_lock);\n+        // FIXME #4410: This shouldn't be necessary, but because of\n+        // unweaken_task this may end up getting called multiple times.\n+        if (already_exiting) {\n+            return;\n+        } else {\n+            already_exiting = true;\n+        }\n+    }\n+\n+    allow_scheduler_exit();\n+    end_weak_tasks();\n+}\n+\n bool\n rust_kernel::send_to_port(rust_port_id chan, void *sptr) {\n     KLOG_(\"rust_port_id*_send port: 0x%\" PRIxPTR, (uintptr_t) chan);"}, {"sha": "13fd893417261d614770a80f7d15d8e19b36ddee", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/090b247056a9dd2d4d4a32c631fe2f0ddd3e744d/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=090b247056a9dd2d4d4a32c631fe2f0ddd3e744d", "patch": "@@ -82,7 +82,8 @@ class rust_kernel {\n     lock_and_signal rval_lock;\n     int rval;\n \n-    // Protects max_sched_id and sched_table, join_list, killed\n+    // Protects max_sched_id and sched_table, join_list, killed,\n+    // already_exiting\n     lock_and_signal sched_lock;\n     // The next scheduler id\n     rust_sched_id max_sched_id;\n@@ -95,8 +96,13 @@ class rust_kernel {\n     // task group fails). This propagates to all new schedulers and tasks\n     // created after it is set.\n     bool killed;\n+    bool already_exiting;\n+\n \n     rust_sched_reaper sched_reaper;\n+\n+    // The primary scheduler\n+    rust_sched_id main_scheduler;\n     // The single-threaded scheduler that uses the main thread\n     rust_sched_id osmain_scheduler;\n     // Runs the single-threaded scheduler that executes tasks\n@@ -111,7 +117,9 @@ class rust_kernel {\n     std::vector<rust_port_id> weak_task_chans;\n \n     rust_scheduler* get_scheduler_by_id_nolock(rust_sched_id id);\n+    void allow_scheduler_exit();\n     void end_weak_tasks();\n+    void begin_shutdown();\n \n     // Used to communicate with the process-side, global libuv loop\n     uintptr_t global_loop_chan;\n@@ -155,6 +163,7 @@ class rust_kernel {\n \n     void set_exit_status(int code);\n \n+    rust_sched_id main_sched_id() { return main_scheduler; }\n     rust_sched_id osmain_sched_id() { return osmain_scheduler; }\n \n     void register_task();"}]}