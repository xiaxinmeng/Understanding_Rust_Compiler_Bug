{"sha": "7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNjlhOGMyYjc4YzVkMjMyMDVkZTFjYWJiNGMyYTY1MjI5ZGJkOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-31T07:46:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-31T07:46:14Z"}, "message": "Auto merge of #86264 - crlf0710:trait_upcasting_part1, r=nikomatsakis\n\nTrait upcasting coercion (part1)\n\nThis revives the first part of earlier PR #60900 .\n\nIt's not very clear to me which parts of that pr was design decisions, so i decide to cut it into pieces and land them incrementally. This allows more eyes on the details.\n\nThis is the first part, it adds feature gates, adds feature gates tests, and implemented the unsize conversion part.\n(I hope i have dealt with the `ExistentialTraitRef` values correctly...)\n\nThe next part will be implementing the pointer casting.", "tree": {"sha": "e2afdc516470e471a88c40ce97494138dfa1c740", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2afdc516470e471a88c40ce97494138dfa1c740"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "html_url": "https://github.com/rust-lang/rust/commit/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b0b07d41f07e1ba5808693d900903499ccf7a32", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b0b07d41f07e1ba5808693d900903499ccf7a32", "html_url": "https://github.com/rust-lang/rust/commit/6b0b07d41f07e1ba5808693d900903499ccf7a32"}, {"sha": "a28ee25483d92b7924752651d9c751ae2c4f2c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28ee25483d92b7924752651d9c751ae2c4f2c34", "html_url": "https://github.com/rust-lang/rust/commit/a28ee25483d92b7924752651d9c751ae2c4f2c34"}], "stats": {"total": 531, "additions": 504, "deletions": 27}, "files": [{"sha": "638330c904d756712da48ad1bb3f98969791c4c1", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -683,6 +683,10 @@ declare_features! (\n     /// Allows the `?` operator in const contexts.\n     (active, const_try, \"1.56.0\", Some(74935), None),\n \n+    /// Allows upcasting trait objects via supertraits.\n+    /// Trait upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n+    (incomplete, trait_upcasting, \"1.56.0\", Some(65991), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "1ac489f600a4049c2bc5ac466177af5847d713fe", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -1270,6 +1270,7 @@ symbols! {\n         trace_macros,\n         track_caller,\n         trait_alias,\n+        trait_upcasting,\n         transmute,\n         transparent,\n         transparent_enums,"}, {"sha": "c7bf1f2a94319bc128ee6d5ee16f141e9752546d", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -693,22 +693,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let may_apply = match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                // Upcasts permit two things:\n-                //\n-                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n-                //\n-                // Note that neither of these changes requires any\n-                // change at runtime. Eventually this will be\n-                // generalized.\n-                //\n-                // We always upcast when we can because of reason\n-                // #2 (region bounds).\n-                data_a.principal_def_id() == data_b.principal_def_id()\n-                    && data_b\n-                        .auto_traits()\n-                        // All of a's auto traits need to be in b's auto traits.\n-                        .all(|b| data_a.auto_traits().any(|a| a == b))\n+                // See `confirm_builtin_unsize_candidate` for more info.\n+                let auto_traits_compatible = data_b\n+                    .auto_traits()\n+                    // All of a's auto traits need to be in b's auto traits.\n+                    .all(|b| data_a.auto_traits().any(|a| a == b));\n+                auto_traits_compatible\n             }\n \n             // `T` -> `Trait`"}, {"sha": "0c2099593a2616c4a026bf5577919cc04f1d1a8c", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -703,10 +703,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // See `assemble_candidates_for_unsizing` for more info.\n-                let iter = data_a\n-                    .principal()\n-                    .map(|b| b.map_bound(ty::ExistentialPredicate::Trait))\n+                // Upcast coercions permit several things:\n+                //\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n+                // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`\n+                //\n+                // Note that neither of the first two of these changes requires any\n+                // change at runtime. The third needs to change pointer metadata at runtime.\n+                //\n+                // We always perform upcasting coercions when we can because of reason\n+                // #2 (region bounds).\n+\n+                // We already checked the compatiblity of auto traits within `assemble_candidates_for_unsizing`.\n+\n+                let principal_a = data_a.principal();\n+                let principal_def_id_b = data_b.principal_def_id();\n+\n+                let existential_predicate = if let Some(principal_a) = principal_a {\n+                    let source_trait_ref = principal_a.with_self_ty(tcx, source);\n+                    let target_trait_did = principal_def_id_b.ok_or_else(|| Unimplemented)?;\n+                    let upcast_idx = util::supertraits(tcx, source_trait_ref)\n+                        .position(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n+                        .ok_or_else(|| Unimplemented)?;\n+                    // FIXME(crlf0710): This is less than ideal, for example,\n+                    // if the trait is defined as `trait Foo: Bar<u32> + Bar<i32>`,\n+                    // the coercion from Box<Foo> to Box<dyn Bar<_>> is actually ambiguous.\n+                    // We currently make this coercion fail for now.\n+                    //\n+                    // see #65991 for more information.\n+                    if util::supertraits(tcx, source_trait_ref)\n+                        .skip(upcast_idx + 1)\n+                        .any(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n+                    {\n+                        return Err(Unimplemented);\n+                    }\n+                    let target_trait_ref =\n+                        util::supertraits(tcx, source_trait_ref).nth(upcast_idx).unwrap();\n+                    let existential_predicate = target_trait_ref.map_bound(|trait_ref| {\n+                        ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n+                            tcx, trait_ref,\n+                        ))\n+                    });\n+                    Some(existential_predicate)\n+                } else if principal_def_id_b.is_none() {\n+                    None\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+\n+                let iter = existential_predicate\n                     .into_iter()\n                     .chain(\n                         data_a"}, {"sha": "a83b39a110834d7aafeb3867d9e70115b69f9b17", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -576,6 +576,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         )];\n \n         let mut has_unsized_tuple_coercion = false;\n+        let mut has_trait_upcasting_coercion = false;\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -590,7 +591,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n                     if unsize_did == trait_pred.def_id() {\n+                        let self_ty = trait_pred.self_ty();\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n+                        if let (ty::Dynamic(ref data_a, ..), ty::Dynamic(ref data_b, ..)) =\n+                            (self_ty.kind(), unsize_ty.kind())\n+                        {\n+                            if data_a.principal_def_id() != data_b.principal_def_id() {\n+                                debug!(\"coerce_unsized: found trait upcasting coercion\");\n+                                has_trait_upcasting_coercion = true;\n+                            }\n+                        }\n                         if let ty::Tuple(..) = unsize_ty.kind() {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n@@ -666,6 +676,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             .emit();\n         }\n \n+        if has_trait_upcasting_coercion && !self.tcx().features().trait_upcasting {\n+            feature_err(\n+                &self.tcx.sess.parse_sess,\n+                sym::trait_upcasting,\n+                self.cause.span,\n+                \"trait upcasting coercion is experimental\",\n+            )\n+            .emit();\n+        }\n+\n         Ok(coercion)\n     }\n "}, {"sha": "e4102f1cfa75d1ea48049b16d3a788d5e0b95944", "filename": "src/test/ui/feature-gates/feature-gate-trait_upcasting.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,13 @@\n+trait Foo {}\n+\n+trait Bar: Foo {}\n+\n+impl Foo for () {}\n+\n+impl Bar for () {}\n+\n+fn main() {\n+    let bar: &dyn Bar = &();\n+    let foo: &dyn Foo = bar;\n+    //~^ ERROR trait upcasting coercion is experimental [E0658]\n+}"}, {"sha": "bc13a5d7d7b46b171ccb7db7416a3aa3e9d8b589", "filename": "src/test/ui/feature-gates/feature-gate-trait_upcasting.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: trait upcasting coercion is experimental\n+  --> $DIR/feature-gate-trait_upcasting.rs:11:25\n+   |\n+LL |     let foo: &dyn Foo = bar;\n+   |                         ^^^\n+   |\n+   = note: see issue #65991 <https://github.com/rust-lang/rust/issues/65991> for more information\n+   = help: add `#![feature(trait_upcasting)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "2072f9c47e2a65dd766fbb707d13e5eec0e44578", "filename": "src/test/ui/issues/issue-11515.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Fissues%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Fissues%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11515.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -1,10 +1,10 @@\n #![feature(box_syntax)]\n \n struct Test {\n-    func: Box<dyn FnMut() + 'static>\n+    func: Box<dyn FnMut() + 'static>,\n }\n \n fn main() {\n     let closure: Box<dyn Fn() + 'static> = Box::new(|| ());\n-    let test = box Test { func: closure }; //~ ERROR mismatched types\n+    let test = box Test { func: closure }; //~ ERROR trait upcasting coercion is experimental [E0658]\n }"}, {"sha": "a70e7c416bc0f3157df6e54901e8eb25a91f80f5", "filename": "src/test/ui/issues/issue-11515.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -1,12 +1,12 @@\n-error[E0308]: mismatched types\n+error[E0658]: trait upcasting coercion is experimental\n   --> $DIR/issue-11515.rs:9:33\n    |\n LL |     let test = box Test { func: closure };\n-   |                                 ^^^^^^^ expected trait `FnMut`, found trait `Fn`\n+   |                                 ^^^^^^^\n    |\n-   = note: expected struct `Box<(dyn FnMut() + 'static)>`\n-              found struct `Box<(dyn Fn() + 'static)>`\n+   = note: see issue #65991 <https://github.com/rust-lang/rust/issues/65991> for more information\n+   = help: add `#![feature(trait_upcasting)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "277d9eabe4fb2ce7737c333e2da5c1e565854462", "filename": "src/test/ui/traits/trait-upcasting/issue-11515-upcast-fn_mut-fn.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fissue-11515-upcast-fn_mut-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fissue-11515-upcast-fn_mut-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fissue-11515-upcast-fn_mut-fn.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+#![feature(box_syntax, trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+struct Test {\n+    func: Box<dyn FnMut() + 'static>,\n+}\n+\n+fn main() {\n+    let closure: Box<dyn Fn() + 'static> = Box::new(|| ());\n+    let mut test = box Test { func: closure };\n+    (test.func)();\n+}"}, {"sha": "6986ad6217240423c3772114e11ddbb9fa3c943a", "filename": "src/test/ui/traits/trait-upcasting/multiple-occurence-ambiguousity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,22 @@\n+// check-fail\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Bar<T> {\n+    fn bar(&self, _: T) {}\n+}\n+\n+trait Foo : Bar<i32> + Bar<u32> {\n+    fn foo(&self, _: ()) {}\n+}\n+\n+struct S;\n+\n+impl Bar<i32> for S {}\n+impl Bar<u32> for S {}\n+impl Foo for S {}\n+\n+fn main() {\n+    let s: &dyn Foo = &S;\n+    let t: &dyn Bar<_> = s; //~ ERROR mismatched types\n+}"}, {"sha": "e9670ad7def4db1505c8e49573eef04b748731b9", "filename": "src/test/ui/traits/trait-upcasting/multiple-occurence-ambiguousity.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/multiple-occurence-ambiguousity.rs:21:26\n+   |\n+LL |     let t: &dyn Bar<_> = s;\n+   |            -----------   ^ expected trait `Bar`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Bar<_>`\n+              found reference `&dyn Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1a0e5072843fe2ac0cd9f362127035f5d589744d", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,33 @@\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: Bar<i32> + Bar<u32> {}\n+trait Bar<T> {\n+    fn bar(&self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+fn test_specific(x: &dyn Foo) {\n+    let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n+                                //~^ ERROR non-primitive cast\n+                                //~^^ ERROR the trait bound `&dyn Foo: Bar<i32>` is not satisfied\n+    let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n+                                //~^ ERROR non-primitive cast\n+                                //~^^ ERROR the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+}\n+\n+fn test_unknown_version(x: &dyn Foo) {\n+    let _ = x as &dyn Bar<_>; // Ambiguous\n+                              //~^ ERROR non-primitive cast\n+                              //~^^ ERROR the trait bound `&dyn Foo: Bar<_>` is not satisfied\n+}\n+\n+fn test_infer_version(x: &dyn Foo) {\n+    let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n+                              //~^ ERROR non-primitive cast\n+                              //~^^ ERROR the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+    let _: Option<u32> = a.bar();\n+}\n+\n+fn main() {}"}, {"sha": "6aaa8a4a90437947272c6a97a8cdea1f40b431c2", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,80 @@\n+error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<i32>`\n+  --> $DIR/type-checking-test-1.rs:12:13\n+   |\n+LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n+   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let _ = &x as &dyn Bar<i32>; // FIXME: OK, eventually\n+   |             ^\n+\n+error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<u32>`\n+  --> $DIR/type-checking-test-1.rs:15:13\n+   |\n+LL |     let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n+   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let _ = &x as &dyn Bar<u32>; // FIXME: OK, eventually\n+   |             ^\n+\n+error[E0277]: the trait bound `&dyn Foo: Bar<i32>` is not satisfied\n+  --> $DIR/type-checking-test-1.rs:12:13\n+   |\n+LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n+   |             ^ the trait `Bar<i32>` is not implemented for `&dyn Foo`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<i32>`\n+\n+error[E0277]: the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+  --> $DIR/type-checking-test-1.rs:15:13\n+   |\n+LL |     let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n+   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<u32>`\n+\n+error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<_>`\n+  --> $DIR/type-checking-test-1.rs:21:13\n+   |\n+LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n+   |             ^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let _ = &x as &dyn Bar<_>; // Ambiguous\n+   |             ^\n+\n+error[E0277]: the trait bound `&dyn Foo: Bar<_>` is not satisfied\n+  --> $DIR/type-checking-test-1.rs:21:13\n+   |\n+LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n+   |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<_>`\n+\n+error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<u32>`\n+  --> $DIR/type-checking-test-1.rs:27:13\n+   |\n+LL |     let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n+   |             ^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let a = &x as &dyn Bar<_>; // FIXME: OK, eventually\n+   |             ^\n+\n+error[E0277]: the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+  --> $DIR/type-checking-test-1.rs:27:13\n+   |\n+LL |     let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n+   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<u32>`\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0277, E0605.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "326df74211eff9b0992a8d97aab62e912ae8f8d8", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,34 @@\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<T>: Bar<i32> + Bar<T> {}\n+trait Bar<T> {\n+    fn bar(&self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+fn test_specific(x: &dyn Foo<i32>) {\n+    let _ = x as &dyn Bar<i32>; // OK\n+}\n+\n+fn test_specific2(x: &dyn Foo<u32>) {\n+    let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n+                                //~^ ERROR non-primitive cast\n+                                //~^^ ERROR the trait bound `&dyn Foo<u32>: Bar<i32>` is not satisfied\n+}\n+\n+fn test_specific3(x: &dyn Foo<i32>) {\n+    let _ = x as &dyn Bar<u32>; // Error\n+                                //~^ ERROR non-primitive cast\n+                                //~^^ ERROR the trait bound `&dyn Foo<i32>: Bar<u32>` is not satisfied\n+}\n+\n+fn test_infer_arg(x: &dyn Foo<u32>) {\n+    let a = x as &dyn Bar<_>; // Ambiguous\n+                              //~^ ERROR non-primitive cast\n+                              //~^^ ERROR the trait bound `&dyn Foo<u32>: Bar<_>` is not satisfied\n+    let _ = a.bar();\n+}\n+\n+fn main() {}"}, {"sha": "a38f8a146043ef45d5beaa9615bc18ba3bad18cf", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,61 @@\n+error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<i32>`\n+  --> $DIR/type-checking-test-2.rs:16:13\n+   |\n+LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n+   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let _ = &x as &dyn Bar<i32>; // FIXME: OK, eventually\n+   |             ^\n+\n+error[E0277]: the trait bound `&dyn Foo<u32>: Bar<i32>` is not satisfied\n+  --> $DIR/type-checking-test-2.rs:16:13\n+   |\n+LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n+   |             ^ the trait `Bar<i32>` is not implemented for `&dyn Foo<u32>`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<i32>`\n+\n+error[E0605]: non-primitive cast: `&dyn Foo<i32>` as `&dyn Bar<u32>`\n+  --> $DIR/type-checking-test-2.rs:22:13\n+   |\n+LL |     let _ = x as &dyn Bar<u32>; // Error\n+   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let _ = &x as &dyn Bar<u32>; // Error\n+   |             ^\n+\n+error[E0277]: the trait bound `&dyn Foo<i32>: Bar<u32>` is not satisfied\n+  --> $DIR/type-checking-test-2.rs:22:13\n+   |\n+LL |     let _ = x as &dyn Bar<u32>; // Error\n+   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo<i32>`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<u32>`\n+\n+error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<_>`\n+  --> $DIR/type-checking-test-2.rs:28:13\n+   |\n+LL |     let a = x as &dyn Bar<_>; // Ambiguous\n+   |             ^^^^^^^^^^^^^^^^ invalid cast\n+   |\n+help: consider borrowing the value\n+   |\n+LL |     let a = &x as &dyn Bar<_>; // Ambiguous\n+   |             ^\n+\n+error[E0277]: the trait bound `&dyn Foo<u32>: Bar<_>` is not satisfied\n+  --> $DIR/type-checking-test-2.rs:28:13\n+   |\n+LL |     let a = x as &dyn Bar<_>; // Ambiguous\n+   |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo<u32>`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<_>`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0277, E0605.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "49c24e404dc6e68333c853147dec8d0d3ee05275", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-3.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,22 @@\n+// ignore-compare-mode-nll\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<'a>: Bar<'a> {}\n+trait Bar<'a> {}\n+\n+fn test_correct(x: &dyn Foo<'static>) {\n+    let _ = x as &dyn Bar<'static>;\n+}\n+\n+fn test_wrong1<'a>(x: &dyn Foo<'static>, y: &'a u32) {\n+    let _ = x as &dyn Bar<'a>; // Error\n+                               //~^ ERROR mismatched types\n+}\n+\n+fn test_wrong2<'a>(x: &dyn Foo<'a>) {\n+    let _ = x as &dyn Bar<'static>; // Error\n+                                    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "593ee0a34300ac5833fdd2404161785900055a28", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-3.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-3.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,33 @@\n+error[E0308]: mismatched types\n+  --> $DIR/type-checking-test-3.rs:13:13\n+   |\n+LL |     let _ = x as &dyn Bar<'a>; // Error\n+   |             ^ lifetime mismatch\n+   |\n+   = note: expected trait object `dyn Bar<'a>`\n+              found trait object `dyn Bar<'static>`\n+note: the lifetime `'a` as defined on the function body at 12:16...\n+  --> $DIR/type-checking-test-3.rs:12:16\n+   |\n+LL | fn test_wrong1<'a>(x: &dyn Foo<'static>, y: &'a u32) {\n+   |                ^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-checking-test-3.rs:18:13\n+   |\n+LL |     let _ = x as &dyn Bar<'static>; // Error\n+   |             ^ lifetime mismatch\n+   |\n+   = note: expected trait object `dyn Bar<'static>`\n+              found trait object `dyn Bar<'a>`\n+note: the lifetime `'a` as defined on the function body at 17:16...\n+  --> $DIR/type-checking-test-3.rs:17:16\n+   |\n+LL | fn test_wrong2<'a>(x: &dyn Foo<'a>) {\n+   |                ^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "9b27fd46f7acd980e8d1cdbd6fab2aa6d5251156", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-4.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-4.rs?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,32 @@\n+// ignore-compare-mode-nll\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<'a>: Bar<'a, 'a> {}\n+trait Bar<'a, 'b> {\n+    fn get_b(&self) -> Option<&'a u32> {\n+        None\n+    }\n+}\n+\n+fn test_correct(x: &dyn Foo<'static>) {\n+    let _ = x as &dyn Bar<'static, 'static>;\n+}\n+\n+fn test_wrong1<'a>(x: &dyn Foo<'static>, y: &'a u32) {\n+    let _ = x as &dyn Bar<'static, 'a>; // Error\n+                                        //~^ ERROR mismatched types\n+}\n+\n+fn test_wrong2<'a>(x: &dyn Foo<'static>, y: &'a u32) {\n+    let _ = x as &dyn Bar<'a, 'static>; // Error\n+                                        //~^ ERROR mismatched types\n+}\n+\n+fn test_wrong3<'a>(x: &dyn Foo<'a>) -> Option<&'static u32> {\n+    let y = x as &dyn Bar<'_, '_>;\n+    //~^ ERROR `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+    y.get_b() // ERROR\n+}\n+\n+fn main() {}"}, {"sha": "811e524eda78b9f349949b57d129e21f78807188", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-4.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7069a8c2b78c5d23205de1cabb4c2a65229dbd8f/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-4.stderr?ref=7069a8c2b78c5d23205de1cabb4c2a65229dbd8f", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: mismatched types\n+  --> $DIR/type-checking-test-4.rs:17:13\n+   |\n+LL |     let _ = x as &dyn Bar<'static, 'a>; // Error\n+   |             ^ lifetime mismatch\n+   |\n+   = note: expected trait object `dyn Bar<'static, 'a>`\n+              found trait object `dyn Bar<'static, 'static>`\n+note: the lifetime `'a` as defined on the function body at 16:16...\n+  --> $DIR/type-checking-test-4.rs:16:16\n+   |\n+LL | fn test_wrong1<'a>(x: &dyn Foo<'static>, y: &'a u32) {\n+   |                ^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-checking-test-4.rs:22:13\n+   |\n+LL |     let _ = x as &dyn Bar<'a, 'static>; // Error\n+   |             ^ lifetime mismatch\n+   |\n+   = note: expected trait object `dyn Bar<'a, 'static>`\n+              found trait object `dyn Bar<'static, 'static>`\n+note: the lifetime `'a` as defined on the function body at 21:16...\n+  --> $DIR/type-checking-test-4.rs:21:16\n+   |\n+LL | fn test_wrong2<'a>(x: &dyn Foo<'static>, y: &'a u32) {\n+   |                ^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/type-checking-test-4.rs:27:27\n+   |\n+LL | fn test_wrong3<'a>(x: &dyn Foo<'a>) -> Option<&'static u32> {\n+   |                       ------------ this data with lifetime `'a`...\n+LL |     let y = x as &dyn Bar<'_, '_>;\n+   |             -             ^^\n+   |             |\n+   |             ...is captured here...\n+LL |\n+LL |     y.get_b() // ERROR\n+   |     --------- ...and is required to live as long as `'static` here\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0759.\n+For more information about an error, try `rustc --explain E0308`."}]}