{"sha": "72f8043d44a8925e469daf5c10e2630c80c2a7d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZjgwNDNkNDRhODkyNWU0NjlkYWY1YzEwZTI2MzBjODBjMmE3ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-12T02:35:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-12T02:35:55Z"}, "message": "Auto merge of #63469 - Centril:refactor-parser, r=petrochenkov\n\nlibsyntax: Refactor `parser.rs` into reasonably sized logical units\n\nHere we split `parser.rs` (~7.9 KLOC) into more reasonably sized files (all < 1.8 KLOC):\n\n- `./src/libsyntax/parse/`\n   - `parser.rs`\n   - `parser/`\n      - `pat.rs`\n      - `expr.rs`\n      - `stmt.rs`\n      - `ty.rs`\n      - `path.rs`\n      - `generics.rs`\n      - `item.rs`\n      - `module.rs`\n\nCloses https://github.com/rust-lang/rust/issues/60015.\n\nr? @petrochenkov", "tree": {"sha": "ae11e076aa3700557bc05ac3905f119a3c8f39e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae11e076aa3700557bc05ac3905f119a3c8f39e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "html_url": "https://github.com/rust-lang/rust/commit/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "899efd510849d9b947078b19377a379359e46a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/899efd510849d9b947078b19377a379359e46a63", "html_url": "https://github.com/rust-lang/rust/commit/899efd510849d9b947078b19377a379359e46a63"}, {"sha": "bcfcbfc923aa821332d8ae8ce977f311764768b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfcbfc923aa821332d8ae8ce977f311764768b1", "html_url": "https://github.com/rust-lang/rust/commit/bcfcbfc923aa821332d8ae8ce977f311764768b1"}], "stats": {"total": 13079, "additions": 6606, "deletions": 6473}, "files": [{"sha": "1c1428c5713f70b146192b66c97fe6efdde67d23", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 308, "deletions": 6473, "changes": 6781, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4"}, {"sha": "4432c1329cbfeb9aa4bdc8d1309a2b53f22bed54", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "added", "additions": 1748, "deletions": 0, "changes": 1748, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,1748 @@\n+use super::{Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle};\n+use super::{BlockMode, SemiColonMode};\n+use super::{SeqSep, TokenExpectType};\n+\n+use crate::maybe_recover_from_interpolated_ty_qpath;\n+use crate::ptr::P;\n+use crate::ast::{self, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode};\n+use crate::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n+use crate::ast::{Ty, TyKind, FunctionRetTy, Arg, FnDecl};\n+use crate::ast::{BinOpKind, BinOp, UnOp};\n+use crate::ast::{Mac_, AnonConst, Field};\n+\n+use crate::parse::classify;\n+use crate::parse::token::{self, Token};\n+use crate::parse::diagnostics::{Error};\n+use crate::print::pprust;\n+use crate::source_map::{self, respan, Span};\n+use crate::symbol::{kw, sym};\n+use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n+\n+use std::mem;\n+use errors::Applicability;\n+use rustc_data_structures::thin_vec::ThinVec;\n+\n+/// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression\n+/// dropped into the token stream, which happens while parsing the result of\n+/// macro expansion). Placement of these is not as complex as I feared it would\n+/// be. The important thing is to make sure that lookahead doesn't balk at\n+/// `token::Interpolated` tokens.\n+macro_rules! maybe_whole_expr {\n+    ($p:expr) => {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n+            match &**nt {\n+                token::NtExpr(e) | token::NtLiteral(e) => {\n+                    let e = e.clone();\n+                    $p.bump();\n+                    return Ok(e);\n+                }\n+                token::NtPath(path) => {\n+                    let path = path.clone();\n+                    $p.bump();\n+                    return Ok($p.mk_expr(\n+                        $p.token.span, ExprKind::Path(None, path), ThinVec::new()\n+                    ));\n+                }\n+                token::NtBlock(block) => {\n+                    let block = block.clone();\n+                    $p.bump();\n+                    return Ok($p.mk_expr(\n+                        $p.token.span, ExprKind::Block(block, None), ThinVec::new()\n+                    ));\n+                }\n+                // N.B: `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n+                _ => {},\n+            };\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum LhsExpr {\n+    NotYetParsed,\n+    AttributesParsed(ThinVec<Attribute>),\n+    AlreadyParsed(P<Expr>),\n+}\n+\n+impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n+        if let Some(attrs) = o {\n+            LhsExpr::AttributesParsed(attrs)\n+        } else {\n+            LhsExpr::NotYetParsed\n+        }\n+    }\n+}\n+\n+impl From<P<Expr>> for LhsExpr {\n+    fn from(expr: P<Expr>) -> Self {\n+        LhsExpr::AlreadyParsed(expr)\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses an expression.\n+    #[inline]\n+    pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        self.parse_expr_res(Restrictions::empty(), None)\n+    }\n+\n+    fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n+        self.parse_paren_comma_seq(|p| {\n+            match p.parse_expr() {\n+                Ok(expr) => Ok(expr),\n+                Err(mut err) => match p.token.kind {\n+                    token::Ident(name, false)\n+                    if name == kw::Underscore && p.look_ahead(1, |t| {\n+                        t == &token::Comma\n+                    }) => {\n+                        // Special-case handling of `foo(_, _, _)`\n+                        err.emit();\n+                        let sp = p.token.span;\n+                        p.bump();\n+                        Ok(p.mk_expr(sp, ExprKind::Err, ThinVec::new()))\n+                    }\n+                    _ => Err(err),\n+                },\n+            }\n+        }).map(|(r, _)| r)\n+    }\n+\n+    /// Parses an expression, subject to the given restrictions.\n+    #[inline]\n+    pub(super) fn parse_expr_res(\n+        &mut self,\n+        r: Restrictions,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>\n+    ) -> PResult<'a, P<Expr>> {\n+        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n+    }\n+\n+    /// Parses an associative expression.\n+    ///\n+    /// This parses an expression accounting for associativity and precedence of the operators in\n+    /// the expression.\n+    #[inline]\n+    fn parse_assoc_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, P<Expr>> {\n+        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n+    }\n+\n+    /// Parses an associative expression with operators of at least `min_prec` precedence.\n+    pub(super) fn parse_assoc_expr_with(\n+        &mut self,\n+        min_prec: usize,\n+        lhs: LhsExpr,\n+    ) -> PResult<'a, P<Expr>> {\n+        let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n+            expr\n+        } else {\n+            let attrs = match lhs {\n+                LhsExpr::AttributesParsed(attrs) => Some(attrs),\n+                _ => None,\n+            };\n+            if [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind) {\n+                return self.parse_prefix_range_expr(attrs);\n+            } else {\n+                self.parse_prefix_expr(attrs)?\n+            }\n+        };\n+        let last_type_ascription_set = self.last_type_ascription.is_some();\n+\n+        match (self.expr_is_complete(&lhs), AssocOp::from_token(&self.token)) {\n+            (true, None) => {\n+                self.last_type_ascription = None;\n+                // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n+                return Ok(lhs);\n+            }\n+            (false, _) => {} // continue parsing the expression\n+            // An exhaustive check is done in the following block, but these are checked first\n+            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n+            // want to keep their span info to improve diagnostics in these cases in a later stage.\n+            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n+            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n+            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n+            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n+            // `if x { a } else { b } && if y { c } else { d }`\n+            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n+                self.last_type_ascription = None;\n+                // These cases are ambiguous and can't be identified in the parser alone\n+                let sp = self.sess.source_map().start_point(self.token.span);\n+                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n+                return Ok(lhs);\n+            }\n+            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => {\n+                self.last_type_ascription = None;\n+                return Ok(lhs);\n+            }\n+            (true, Some(_)) => {\n+                // We've found an expression that would be parsed as a statement, but the next\n+                // token implies this should be parsed as an expression.\n+                // For example: `if let Some(x) = x { x } else { 0 } / 2`\n+                let mut err = self.struct_span_err(self.token.span, &format!(\n+                    \"expected expression, found `{}`\",\n+                    pprust::token_to_string(&self.token),\n+                ));\n+                err.span_label(self.token.span, \"expected expression\");\n+                self.sess.expr_parentheses_needed(\n+                    &mut err,\n+                    lhs.span,\n+                    Some(pprust::expr_to_string(&lhs),\n+                ));\n+                err.emit();\n+            }\n+        }\n+        self.expected_tokens.push(TokenType::Operator);\n+        while let Some(op) = AssocOp::from_token(&self.token) {\n+\n+            // Adjust the span for interpolated LHS to point to the `$lhs` token and not to what\n+            // it refers to. Interpolated identifiers are unwrapped early and never show up here\n+            // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n+            // it as \"interpolated\", it doesn't change the answer for non-interpolated idents.\n+            let lhs_span = match (self.prev_token_kind, &lhs.node) {\n+                (PrevTokenKind::Interpolated, _) => self.prev_span,\n+                (PrevTokenKind::Ident, &ExprKind::Path(None, ref path))\n+                    if path.segments.len() == 1 => self.prev_span,\n+                _ => lhs.span,\n+            };\n+\n+            let cur_op_span = self.token.span;\n+            let restrictions = if op.is_assign_like() {\n+                self.restrictions & Restrictions::NO_STRUCT_LITERAL\n+            } else {\n+                self.restrictions\n+            };\n+            let prec = op.precedence();\n+            if prec < min_prec {\n+                break;\n+            }\n+            // Check for deprecated `...` syntax\n+            if self.token == token::DotDotDot && op == AssocOp::DotDotEq {\n+                self.err_dotdotdot_syntax(self.token.span);\n+            }\n+\n+            self.bump();\n+            if op.is_comparison() {\n+                self.check_no_chained_comparison(&lhs, &op);\n+            }\n+            // Special cases:\n+            if op == AssocOp::As {\n+                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n+                continue\n+            } else if op == AssocOp::Colon {\n+                let maybe_path = self.could_ascription_be_path(&lhs.node);\n+                self.last_type_ascription = Some((self.prev_span, maybe_path));\n+\n+                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n+                continue\n+            } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n+                // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n+                // generalise it to the Fixity::None code.\n+                //\n+                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n+                // two variants are handled with `parse_prefix_range_expr` call above.\n+                let rhs = if self.is_at_start_of_range_notation_rhs() {\n+                    Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n+                } else {\n+                    None\n+                };\n+                let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                    x.span\n+                } else {\n+                    cur_op_span\n+                });\n+                let limits = if op == AssocOp::DotDot {\n+                    RangeLimits::HalfOpen\n+                } else {\n+                    RangeLimits::Closed\n+                };\n+\n+                let r = self.mk_range(Some(lhs), rhs, limits)?;\n+                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n+                break\n+            }\n+\n+            let fixity = op.fixity();\n+            let prec_adjustment = match fixity {\n+                Fixity::Right => 0,\n+                Fixity::Left => 1,\n+                // We currently have no non-associative operators that are not handled above by\n+                // the special cases. The code is here only for future convenience.\n+                Fixity::None => 1,\n+            };\n+            let rhs = self.with_res(\n+                restrictions - Restrictions::STMT_EXPR,\n+                |this| this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n+            )?;\n+\n+            // Make sure that the span of the parent node is larger than the span of lhs and rhs,\n+            // including the attributes.\n+            let lhs_span = lhs\n+                .attrs\n+                .iter()\n+                .filter(|a| a.style == AttrStyle::Outer)\n+                .next()\n+                .map_or(lhs_span, |a| a.span);\n+            let span = lhs_span.to(rhs.span);\n+            lhs = match op {\n+                AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n+                AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n+                AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n+                AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n+                AssocOp::Greater | AssocOp::GreaterEqual => {\n+                    let ast_op = op.to_ast_binop().unwrap();\n+                    let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n+                    self.mk_expr(span, binary, ThinVec::new())\n+                }\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                AssocOp::AssignOp(k) => {\n+                    let aop = match k {\n+                        token::Plus =>    BinOpKind::Add,\n+                        token::Minus =>   BinOpKind::Sub,\n+                        token::Star =>    BinOpKind::Mul,\n+                        token::Slash =>   BinOpKind::Div,\n+                        token::Percent => BinOpKind::Rem,\n+                        token::Caret =>   BinOpKind::BitXor,\n+                        token::And =>     BinOpKind::BitAnd,\n+                        token::Or =>      BinOpKind::BitOr,\n+                        token::Shl =>     BinOpKind::Shl,\n+                        token::Shr =>     BinOpKind::Shr,\n+                    };\n+                    let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n+                    self.mk_expr(span, aopexpr, ThinVec::new())\n+                }\n+                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n+                    self.bug(\"AssocOp should have been handled by special case\")\n+                }\n+            };\n+\n+            if let Fixity::None = fixity { break }\n+        }\n+        if last_type_ascription_set {\n+            self.last_type_ascription = None;\n+        }\n+        Ok(lhs)\n+    }\n+\n+    /// Checks if this expression is a successfully parsed statement.\n+    fn expr_is_complete(&self, e: &Expr) -> bool {\n+        self.restrictions.contains(Restrictions::STMT_EXPR) &&\n+            !classify::expr_requires_semi_to_be_stmt(e)\n+    }\n+\n+    fn is_at_start_of_range_notation_rhs(&self) -> bool {\n+        if self.token.can_begin_expr() {\n+            // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n+            if self.token == token::OpenDelim(token::Brace) {\n+                return !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr`\n+    fn parse_prefix_range_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>\n+    ) -> PResult<'a, P<Expr>> {\n+        // Check for deprecated `...` syntax\n+        if self.token == token::DotDotDot {\n+            self.err_dotdotdot_syntax(self.token.span);\n+        }\n+\n+        debug_assert!([token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind),\n+                      \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotEq\",\n+                      self.token);\n+        let tok = self.token.clone();\n+        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+        let lo = self.token.span;\n+        let mut hi = self.token.span;\n+        self.bump();\n+        let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+            // RHS must be parsed with more associativity than the dots.\n+            let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n+            Some(self.parse_assoc_expr_with(next_prec, LhsExpr::NotYetParsed)\n+                .map(|x| {\n+                    hi = x.span;\n+                    x\n+                })?)\n+        } else {\n+            None\n+        };\n+        let limits = if tok == token::DotDot {\n+            RangeLimits::HalfOpen\n+        } else {\n+            RangeLimits::Closed\n+        };\n+\n+        let r = self.mk_range(None, opt_end, limits)?;\n+        Ok(self.mk_expr(lo.to(hi), r, attrs))\n+    }\n+\n+    /// Parse a prefix-unary-operator expr\n+    fn parse_prefix_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>\n+    ) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+        let lo = self.token.span;\n+        // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n+        let (hi, ex) = match self.token.kind {\n+            token::Not => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n+            }\n+            // Suggest `!` for bitwise negation when encountering a `~`\n+            token::Tilde => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                let span_of_tilde = lo;\n+                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n+                    .span_suggestion_short(\n+                        span_of_tilde,\n+                        \"use `!` to perform bitwise negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n+            }\n+            token::BinOp(token::Minus) => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), self.mk_unary(UnOp::Neg, e))\n+            }\n+            token::BinOp(token::Star) => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), self.mk_unary(UnOp::Deref, e))\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                self.expect_and()?;\n+                let m = self.parse_mutability();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), ExprKind::AddrOf(m, e))\n+            }\n+            token::Ident(..) if self.token.is_keyword(kw::Box) => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), ExprKind::Box(e))\n+            }\n+            token::Ident(..) if self.token.is_ident_named(sym::not) => {\n+                // `not` is just an ordinary identifier in Rust-the-language,\n+                // but as `rustc`-the-compiler, we can issue clever diagnostics\n+                // for confused users who really want to say `!`\n+                let token_cannot_continue_expr = |t: &Token| match t.kind {\n+                    // These tokens can start an expression after `!`, but\n+                    // can't continue an expression after an ident\n+                    token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n+                    token::Literal(..) | token::Pound => true,\n+                    _ => t.is_whole_expr(),\n+                };\n+                let cannot_continue_expr = self.look_ahead(1, token_cannot_continue_expr);\n+                if cannot_continue_expr {\n+                    self.bump();\n+                    // Emit the error ...\n+                    self.struct_span_err(\n+                        self.token.span,\n+                        &format!(\"unexpected {} after identifier\",self.this_token_descr())\n+                    )\n+                    .span_suggestion_short(\n+                        // Span the `not` plus trailing whitespace to avoid\n+                        // trailing whitespace after the `!` in our suggestion\n+                        self.sess.source_map()\n+                            .span_until_non_whitespace(lo.to(self.token.span)),\n+                        \"use `!` to perform logical negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n+                    // \u2014and recover! (just as if we were in the block\n+                    // for the `token::Not` arm)\n+                    let e = self.parse_prefix_expr(None);\n+                    let (span, e) = self.interpolated_or_expr_span(e)?;\n+                    (lo.to(span), self.mk_unary(UnOp::Not, e))\n+                } else {\n+                    return self.parse_dot_or_call_expr(Some(attrs));\n+                }\n+            }\n+            _ => { return self.parse_dot_or_call_expr(Some(attrs)); }\n+        };\n+        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n+    }\n+\n+    /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n+    fn interpolated_or_expr_span(\n+        &self,\n+        expr: PResult<'a, P<Expr>>,\n+    ) -> PResult<'a, (Span, P<Expr>)> {\n+        expr.map(|e| {\n+            if self.prev_token_kind == PrevTokenKind::Interpolated {\n+                (self.prev_span, e)\n+            } else {\n+                (e.span, e)\n+            }\n+        })\n+    }\n+\n+    fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n+                           expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n+                           -> PResult<'a, P<Expr>> {\n+        let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n+            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), ThinVec::new())\n+        };\n+\n+        // Save the state of the parser before parsing type normally, in case there is a\n+        // LessThan comparison after this cast.\n+        let parser_snapshot_before_type = self.clone();\n+        match self.parse_ty_no_plus() {\n+            Ok(rhs) => {\n+                Ok(mk_expr(self, rhs))\n+            }\n+            Err(mut type_err) => {\n+                // Rewind to before attempting to parse the type with generics, to recover\n+                // from situations like `x as usize < y` in which we first tried to parse\n+                // `usize < y` as a type with generic arguments.\n+                let parser_snapshot_after_type = self.clone();\n+                mem::replace(self, parser_snapshot_before_type);\n+\n+                match self.parse_path(PathStyle::Expr) {\n+                    Ok(path) => {\n+                        let (op_noun, op_verb) = match self.token.kind {\n+                            token::Lt => (\"comparison\", \"comparing\"),\n+                            token::BinOp(token::Shl) => (\"shift\", \"shifting\"),\n+                            _ => {\n+                                // We can end up here even without `<` being the next token, for\n+                                // example because `parse_ty_no_plus` returns `Err` on keywords,\n+                                // but `parse_path` returns `Ok` on them due to error recovery.\n+                                // Return original error and parser state.\n+                                mem::replace(self, parser_snapshot_after_type);\n+                                return Err(type_err);\n+                            }\n+                        };\n+\n+                        // Successfully parsed the type path leaving a `<` yet to parse.\n+                        type_err.cancel();\n+\n+                        // Report non-fatal diagnostics, keep `x as usize` as an expression\n+                        // in AST and continue parsing.\n+                        let msg = format!(\"`<` is interpreted as a start of generic \\\n+                                           arguments for `{}`, not a {}\", path, op_noun);\n+                        let span_after_type = parser_snapshot_after_type.token.span;\n+                        let expr = mk_expr(self, P(Ty {\n+                            span: path.span,\n+                            node: TyKind::Path(None, path),\n+                            id: ast::DUMMY_NODE_ID\n+                        }));\n+\n+                        let expr_str = self.span_to_snippet(expr.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+\n+                        self.struct_span_err(self.token.span, &msg)\n+                            .span_label(\n+                                self.look_ahead(1, |t| t.span).to(span_after_type),\n+                                \"interpreted as generic arguments\"\n+                            )\n+                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_suggestion(\n+                                expr.span,\n+                                &format!(\"try {} the cast value\", op_verb),\n+                                format!(\"({})\", expr_str),\n+                                Applicability::MachineApplicable\n+                            )\n+                            .emit();\n+\n+                        Ok(expr)\n+                    }\n+                    Err(mut path_err) => {\n+                        // Couldn't parse as a path, return original error and parser state.\n+                        path_err.cancel();\n+                        mem::replace(self, parser_snapshot_after_type);\n+                        Err(type_err)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n+    fn parse_dot_or_call_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+\n+        let b = self.parse_bottom_expr();\n+        let (span, b) = self.interpolated_or_expr_span(b)?;\n+        self.parse_dot_or_call_expr_with(b, span, attrs)\n+    }\n+\n+    pub(super) fn parse_dot_or_call_expr_with(\n+        &mut self,\n+        e0: P<Expr>,\n+        lo: Span,\n+        mut attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n+        // Stitch the list of outer attributes onto the return value.\n+        // A little bit ugly, but the best way given the current code\n+        // structure\n+        self.parse_dot_or_call_expr_with_(e0, lo).map(|expr|\n+            expr.map(|mut expr| {\n+                attrs.extend::<Vec<_>>(expr.attrs.into());\n+                expr.attrs = attrs;\n+                match expr.node {\n+                    ExprKind::If(..) if !expr.attrs.is_empty() => {\n+                        // Just point to the first attribute in there...\n+                        let span = expr.attrs[0].span;\n+                        self.span_err(span, \"attributes are not yet allowed on `if` expressions\");\n+                    }\n+                    _ => {}\n+                }\n+                expr\n+            })\n+        )\n+    }\n+\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let mut e = e0;\n+        let mut hi;\n+        loop {\n+            // expr?\n+            while self.eat(&token::Question) {\n+                let hi = self.prev_span;\n+                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n+            }\n+\n+            // expr.f\n+            if self.eat(&token::Dot) {\n+                match self.token.kind {\n+                    token::Ident(..) => {\n+                        e = self.parse_dot_suffix(e, lo)?;\n+                    }\n+                    token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n+                        let span = self.token.span;\n+                        self.bump();\n+                        let field = ExprKind::Field(e, Ident::new(symbol, span));\n+                        e = self.mk_expr(lo.to(span), field, ThinVec::new());\n+\n+                        self.expect_no_suffix(span, \"a tuple index\", suffix);\n+                    }\n+                    token::Literal(token::Lit { kind: token::Float, symbol, .. }) => {\n+                      self.bump();\n+                      let fstr = symbol.as_str();\n+                      let msg = format!(\"unexpected token: `{}`\", symbol);\n+                      let mut err = self.diagnostic().struct_span_err(self.prev_span, &msg);\n+                      err.span_label(self.prev_span, \"unexpected token\");\n+                      if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n+                          let float = match fstr.parse::<f64>().ok() {\n+                              Some(f) => f,\n+                              None => continue,\n+                          };\n+                          let sugg = pprust::to_string(|s| {\n+                              s.popen();\n+                              s.print_expr(&e);\n+                              s.s.word( \".\");\n+                              s.print_usize(float.trunc() as usize);\n+                              s.pclose();\n+                              s.s.word(\".\");\n+                              s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n+                          });\n+                          err.span_suggestion(\n+                              lo.to(self.prev_span),\n+                              \"try parenthesizing the first index\",\n+                              sugg,\n+                              Applicability::MachineApplicable\n+                          );\n+                      }\n+                      return Err(err);\n+\n+                    }\n+                    _ => {\n+                        // FIXME Could factor this out into non_fatal_unexpected or something.\n+                        let actual = self.this_token_to_string();\n+                        self.span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual));\n+                    }\n+                }\n+                continue;\n+            }\n+            if self.expr_is_complete(&e) { break; }\n+            match self.token.kind {\n+                // expr(...)\n+                token::OpenDelim(token::Paren) => {\n+                    let seq = self.parse_paren_expr_seq().map(|es| {\n+                        let nd = self.mk_call(e, es);\n+                        let hi = self.prev_span;\n+                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n+                    });\n+                    e = self.recover_seq_parse_error(token::Paren, lo, seq);\n+                }\n+\n+                // expr[...]\n+                // Could be either an index expression or a slicing expression.\n+                token::OpenDelim(token::Bracket) => {\n+                    self.bump();\n+                    let ix = self.parse_expr()?;\n+                    hi = self.token.span;\n+                    self.expect(&token::CloseDelim(token::Bracket))?;\n+                    let index = self.mk_index(e, ix);\n+                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n+                }\n+                _ => return Ok(e)\n+            }\n+        }\n+        return Ok(e);\n+    }\n+\n+    /// Assuming we have just parsed `.`, continue parsing into an expression.\n+    fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n+            return self.mk_await_expr(self_arg, lo);\n+        }\n+\n+        let segment = self.parse_path_segment(PathStyle::Expr)?;\n+        self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n+\n+        Ok(match self.token.kind {\n+            token::OpenDelim(token::Paren) => {\n+                // Method call `expr.f()`\n+                let mut args = self.parse_paren_expr_seq()?;\n+                args.insert(0, self_arg);\n+\n+                let span = lo.to(self.prev_span);\n+                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n+            }\n+            _ => {\n+                // Field access `expr.f`\n+                if let Some(args) = segment.args {\n+                    self.span_err(args.span(),\n+                                  \"field expressions may not have generic arguments\");\n+                }\n+\n+                let span = lo.to(self.prev_span);\n+                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n+            }\n+        })\n+    }\n+\n+\n+    /// At the bottom (top?) of the precedence hierarchy,\n+    /// Parses things like parenthesized exprs, macros, `return`, etc.\n+    ///\n+    /// N.B., this does not parse outer attributes, and is private because it only works\n+    /// correctly if called from `parse_dot_or_call_expr()`.\n+    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n+        maybe_whole_expr!(self);\n+\n+        // Outer attributes are already parsed and will be\n+        // added to the return value after the fact.\n+        //\n+        // Therefore, prevent sub-parser from parsing\n+        // attributes by giving them a empty \"already parsed\" list.\n+        let mut attrs = ThinVec::new();\n+\n+        let lo = self.token.span;\n+        let mut hi = self.token.span;\n+\n+        let ex: ExprKind;\n+\n+        macro_rules! parse_lit {\n+            () => {\n+                match self.parse_lit() {\n+                    Ok(literal) => {\n+                        hi = self.prev_span;\n+                        ex = ExprKind::Lit(literal);\n+                    }\n+                    Err(mut err) => {\n+                        self.cancel(&mut err);\n+                        return Err(self.expected_expression_found());\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Note: when adding new syntax here, don't forget to adjust TokenKind::can_begin_expr().\n+        match self.token.kind {\n+            // This match arm is a special-case of the `_` match arm below and\n+            // could be removed without changing functionality, but it's faster\n+            // to have it here, especially for programs with large constants.\n+            token::Literal(_) => {\n+                parse_lit!()\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                self.bump();\n+\n+                attrs.extend(self.parse_inner_attributes()?);\n+\n+                // (e) is parenthesized e\n+                // (e,) is a tuple with only one field, e\n+                let mut es = vec![];\n+                let mut trailing_comma = false;\n+                let mut recovered = false;\n+                while self.token != token::CloseDelim(token::Paren) {\n+                    es.push(match self.parse_expr() {\n+                        Ok(es) => es,\n+                        Err(mut err) => {\n+                            // recover from parse error in tuple list\n+                            match self.token.kind {\n+                                token::Ident(name, false)\n+                                if name == kw::Underscore && self.look_ahead(1, |t| {\n+                                    t == &token::Comma\n+                                }) => {\n+                                    // Special-case handling of `Foo<(_, _, _)>`\n+                                    err.emit();\n+                                    let sp = self.token.span;\n+                                    self.bump();\n+                                    self.mk_expr(sp, ExprKind::Err, ThinVec::new())\n+                                }\n+                                _ => return Ok(\n+                                    self.recover_seq_parse_error(token::Paren, lo, Err(err)),\n+                                ),\n+                            }\n+                        }\n+                    });\n+                    recovered = self.expect_one_of(\n+                        &[],\n+                        &[token::Comma, token::CloseDelim(token::Paren)],\n+                    )?;\n+                    if self.eat(&token::Comma) {\n+                        trailing_comma = true;\n+                    } else {\n+                        trailing_comma = false;\n+                        break;\n+                    }\n+                }\n+                if !recovered {\n+                    self.bump();\n+                }\n+\n+                hi = self.prev_span;\n+                ex = if es.len() == 1 && !trailing_comma {\n+                    ExprKind::Paren(es.into_iter().nth(0).unwrap())\n+                } else {\n+                    ExprKind::Tup(es)\n+                };\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                return self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs);\n+            }\n+            token::BinOp(token::Or) | token::OrOr => {\n+                return self.parse_lambda_expr(attrs);\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                self.bump();\n+\n+                attrs.extend(self.parse_inner_attributes()?);\n+\n+                if self.eat(&token::CloseDelim(token::Bracket)) {\n+                    // Empty vector.\n+                    ex = ExprKind::Array(Vec::new());\n+                } else {\n+                    // Nonempty vector.\n+                    let first_expr = self.parse_expr()?;\n+                    if self.eat(&token::Semi) {\n+                        // Repeating array syntax: [ 0; 512 ]\n+                        let count = AnonConst {\n+                            id: ast::DUMMY_NODE_ID,\n+                            value: self.parse_expr()?,\n+                        };\n+                        self.expect(&token::CloseDelim(token::Bracket))?;\n+                        ex = ExprKind::Repeat(first_expr, count);\n+                    } else if self.eat(&token::Comma) {\n+                        // Vector with two or more elements.\n+                        let remaining_exprs = self.parse_seq_to_end(\n+                            &token::CloseDelim(token::Bracket),\n+                            SeqSep::trailing_allowed(token::Comma),\n+                            |p| Ok(p.parse_expr()?)\n+                        )?;\n+                        let mut exprs = vec![first_expr];\n+                        exprs.extend(remaining_exprs);\n+                        ex = ExprKind::Array(exprs);\n+                    } else {\n+                        // Vector with one element.\n+                        self.expect(&token::CloseDelim(token::Bracket))?;\n+                        ex = ExprKind::Array(vec![first_expr]);\n+                    }\n+                }\n+                hi = self.prev_span;\n+            }\n+            _ => {\n+                if self.eat_lt() {\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                    hi = path.span;\n+                    return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n+                }\n+                if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n+                    return self.parse_lambda_expr(attrs);\n+                }\n+                if self.eat_keyword(kw::If) {\n+                    return self.parse_if_expr(attrs);\n+                }\n+                if self.eat_keyword(kw::For) {\n+                    let lo = self.prev_span;\n+                    return self.parse_for_expr(None, lo, attrs);\n+                }\n+                if self.eat_keyword(kw::While) {\n+                    let lo = self.prev_span;\n+                    return self.parse_while_expr(None, lo, attrs);\n+                }\n+                if let Some(label) = self.eat_label() {\n+                    let lo = label.ident.span;\n+                    self.expect(&token::Colon)?;\n+                    if self.eat_keyword(kw::While) {\n+                        return self.parse_while_expr(Some(label), lo, attrs)\n+                    }\n+                    if self.eat_keyword(kw::For) {\n+                        return self.parse_for_expr(Some(label), lo, attrs)\n+                    }\n+                    if self.eat_keyword(kw::Loop) {\n+                        return self.parse_loop_expr(Some(label), lo, attrs)\n+                    }\n+                    if self.token == token::OpenDelim(token::Brace) {\n+                        return self.parse_block_expr(Some(label),\n+                                                     lo,\n+                                                     BlockCheckMode::Default,\n+                                                     attrs);\n+                    }\n+                    let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n+                    let mut err = self.fatal(msg);\n+                    err.span_label(self.token.span, msg);\n+                    return Err(err);\n+                }\n+                if self.eat_keyword(kw::Loop) {\n+                    let lo = self.prev_span;\n+                    return self.parse_loop_expr(None, lo, attrs);\n+                }\n+                if self.eat_keyword(kw::Continue) {\n+                    let label = self.eat_label();\n+                    let ex = ExprKind::Continue(label);\n+                    let hi = self.prev_span;\n+                    return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n+                }\n+                if self.eat_keyword(kw::Match) {\n+                    let match_sp = self.prev_span;\n+                    return self.parse_match_expr(attrs).map_err(|mut err| {\n+                        err.span_label(match_sp, \"while parsing this match expression\");\n+                        err\n+                    });\n+                }\n+                if self.eat_keyword(kw::Unsafe) {\n+                    return self.parse_block_expr(\n+                        None,\n+                        lo,\n+                        BlockCheckMode::Unsafe(ast::UserProvided),\n+                        attrs);\n+                }\n+                if self.is_do_catch_block() {\n+                    let mut db = self.fatal(\"found removed `do catch` syntax\");\n+                    db.help(\"Following RFC #2388, the new non-placeholder syntax is `try`\");\n+                    return Err(db);\n+                }\n+                if self.is_try_block() {\n+                    let lo = self.token.span;\n+                    assert!(self.eat_keyword(kw::Try));\n+                    return self.parse_try_block(lo, attrs);\n+                }\n+\n+                // Span::rust_2018() is somewhat expensive; don't get it repeatedly.\n+                let is_span_rust_2018 = self.token.span.rust_2018();\n+                if is_span_rust_2018 && self.check_keyword(kw::Async) {\n+                    return if self.is_async_block() { // check for `async {` and `async move {`\n+                        self.parse_async_block(attrs)\n+                    } else {\n+                        self.parse_lambda_expr(attrs)\n+                    };\n+                }\n+                if self.eat_keyword(kw::Return) {\n+                    if self.token.can_begin_expr() {\n+                        let e = self.parse_expr()?;\n+                        hi = e.span;\n+                        ex = ExprKind::Ret(Some(e));\n+                    } else {\n+                        ex = ExprKind::Ret(None);\n+                    }\n+                } else if self.eat_keyword(kw::Break) {\n+                    let label = self.eat_label();\n+                    let e = if self.token.can_begin_expr()\n+                               && !(self.token == token::OpenDelim(token::Brace)\n+                                    && self.restrictions.contains(\n+                                           Restrictions::NO_STRUCT_LITERAL)) {\n+                        Some(self.parse_expr()?)\n+                    } else {\n+                        None\n+                    };\n+                    ex = ExprKind::Break(label, e);\n+                    hi = self.prev_span;\n+                } else if self.eat_keyword(kw::Yield) {\n+                    if self.token.can_begin_expr() {\n+                        let e = self.parse_expr()?;\n+                        hi = e.span;\n+                        ex = ExprKind::Yield(Some(e));\n+                    } else {\n+                        ex = ExprKind::Yield(None);\n+                    }\n+                } else if self.eat_keyword(kw::Let) {\n+                    return self.parse_let_expr(attrs);\n+                } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n+                    let (await_hi, e_kind) = self.parse_incorrect_await_syntax(lo, self.prev_span)?;\n+                    hi = await_hi;\n+                    ex = e_kind;\n+                } else if self.token.is_path_start() {\n+                    let path = self.parse_path(PathStyle::Expr)?;\n+\n+                    // `!`, as an operator, is prefix, so we know this isn't that\n+                    if self.eat(&token::Not) {\n+                        // MACRO INVOCATION expression\n+                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        hi = self.prev_span;\n+                        ex = ExprKind::Mac(respan(lo.to(hi), Mac_ {\n+                            path,\n+                            tts,\n+                            delim,\n+                            prior_type_ascription: self.last_type_ascription,\n+                        }));\n+                    } else if self.check(&token::OpenDelim(token::Brace)) {\n+                        if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n+                            return expr;\n+                        } else {\n+                            hi = path.span;\n+                            ex = ExprKind::Path(None, path);\n+                        }\n+                    } else {\n+                        hi = path.span;\n+                        ex = ExprKind::Path(None, path);\n+                    }\n+                } else {\n+                    if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n+                        // Don't complain about bare semicolons after unclosed braces\n+                        // recovery in order to keep the error count down. Fixing the\n+                        // delimiters will possibly also fix the bare semicolon found in\n+                        // expression context. For example, silence the following error:\n+                        // ```\n+                        // error: expected expression, found `;`\n+                        //  --> file.rs:2:13\n+                        //   |\n+                        // 2 |     foo(bar(;\n+                        //   |             ^ expected expression\n+                        // ```\n+                        self.bump();\n+                        return Ok(self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()));\n+                    }\n+                    parse_lit!()\n+                }\n+            }\n+        }\n+\n+        let expr = self.mk_expr(lo.to(hi), ex, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n+\n+    /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n+    crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_whole_expr!(self);\n+\n+        let minus_lo = self.token.span;\n+        let minus_present = self.eat(&token::BinOp(token::Minus));\n+        let lo = self.token.span;\n+        let literal = self.parse_lit()?;\n+        let hi = self.prev_span;\n+        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n+\n+        if minus_present {\n+            let minus_hi = self.prev_span;\n+            let unary = self.mk_unary(UnOp::Neg, expr);\n+            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n+        } else {\n+            Ok(expr)\n+        }\n+    }\n+\n+    /// Parses a block or unsafe block.\n+    crate fn parse_block_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        lo: Span,\n+        blk_mode: BlockCheckMode,\n+        outer_attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+\n+        let mut attrs = outer_attrs;\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let blk = self.parse_block_tail(lo, blk_mode)?;\n+        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs));\n+    }\n+\n+    /// Parses `move |args| expr`.\n+    fn parse_lambda_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+\n+        let movability = if self.eat_keyword(kw::Static) {\n+            Movability::Static\n+        } else {\n+            Movability::Movable\n+        };\n+\n+        let asyncness = if self.token.span.rust_2018() {\n+            self.parse_asyncness()\n+        } else {\n+            IsAsync::NotAsync\n+        };\n+        if asyncness.is_async() {\n+            // Feature gate `async ||` closures.\n+            self.sess.async_closure_spans.borrow_mut().push(self.prev_span);\n+        }\n+\n+        let capture_clause = self.parse_capture_clause();\n+        let decl = self.parse_fn_block_decl()?;\n+        let decl_hi = self.prev_span;\n+        let body = match decl.output {\n+            FunctionRetTy::Default(_) => {\n+                let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n+                self.parse_expr_res(restrictions, None)?\n+            },\n+            _ => {\n+                // If an explicit return type is given, require a\n+                // block to appear (RFC 968).\n+                let body_lo = self.token.span;\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n+            }\n+        };\n+\n+        Ok(self.mk_expr(\n+            lo.to(body.span),\n+            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, lo.to(decl_hi)),\n+            attrs))\n+    }\n+\n+    /// Parse an optional `move` prefix to a closure lke construct.\n+    fn parse_capture_clause(&mut self) -> CaptureBy {\n+        if self.eat_keyword(kw::Move) {\n+            CaptureBy::Value\n+        } else {\n+            CaptureBy::Ref\n+        }\n+    }\n+\n+    /// Parses the `|arg, arg|` header of a closure.\n+    fn parse_fn_block_decl(&mut self) -> PResult<'a, P<FnDecl>> {\n+        let inputs_captures = {\n+            if self.eat(&token::OrOr) {\n+                Vec::new()\n+            } else {\n+                self.expect(&token::BinOp(token::Or))?;\n+                let args = self.parse_seq_to_before_tokens(\n+                    &[&token::BinOp(token::Or), &token::OrOr],\n+                    SeqSep::trailing_allowed(token::Comma),\n+                    TokenExpectType::NoExpect,\n+                    |p| p.parse_fn_block_arg()\n+                )?.0;\n+                self.expect_or()?;\n+                args\n+            }\n+        };\n+        let output = self.parse_ret_ty(true)?;\n+\n+        Ok(P(FnDecl {\n+            inputs: inputs_captures,\n+            output,\n+            c_variadic: false\n+        }))\n+    }\n+\n+    /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n+    fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_arg_attributes()?;\n+        let pat = self.parse_pat(Some(\"argument name\"))?;\n+        let t = if self.eat(&token::Colon) {\n+            self.parse_ty()?\n+        } else {\n+            P(Ty {\n+                id: ast::DUMMY_NODE_ID,\n+                node: TyKind::Infer,\n+                span: self.prev_span,\n+            })\n+        };\n+        let span = lo.to(self.token.span);\n+        Ok(Arg {\n+            attrs: attrs.into(),\n+            ty: t,\n+            pat,\n+            span,\n+            id: ast::DUMMY_NODE_ID\n+        })\n+    }\n+\n+    /// Parses an `if` expression (`if` token already eaten).\n+    fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let cond = self.parse_cond_expr()?;\n+\n+        // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n+        // verify that the last statement is either an implicit return (no `;`) or an explicit\n+        // return. This won't catch blocks with an explicit `return`, but that would be caught by\n+        // the dead code lint.\n+        if self.eat_keyword(kw::Else) || !cond.returns() {\n+            let sp = self.sess.source_map().next_point(lo);\n+            let mut err = self.diagnostic()\n+                .struct_span_err(sp, \"missing condition for `if` statemement\");\n+            err.span_label(sp, \"expected if condition here\");\n+            return Err(err)\n+        }\n+        let not_block = self.token != token::OpenDelim(token::Brace);\n+        let thn = self.parse_block().map_err(|mut err| {\n+            if not_block {\n+                err.span_label(lo, \"this `if` statement has a condition, but no block\");\n+            }\n+            err\n+        })?;\n+        let mut els: Option<P<Expr>> = None;\n+        let mut hi = thn.span;\n+        if self.eat_keyword(kw::Else) {\n+            let elexpr = self.parse_else_expr()?;\n+            hi = elexpr.span;\n+            els = Some(elexpr);\n+        }\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n+    }\n+\n+    /// Parse the condition of a `if`- or `while`-expression\n+    fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        if let ExprKind::Let(..) = cond.node {\n+            // Remove the last feature gating of a `let` expression since it's stable.\n+            let last = self.sess.let_chains_spans.borrow_mut().pop();\n+            debug_assert_eq!(cond.span, last.unwrap());\n+        }\n+\n+        Ok(cond)\n+    }\n+\n+    /// Parses a `let $pats = $expr` pseudo-expression.\n+    /// The `let` token has already been eaten.\n+    fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let pats = self.parse_pats()?;\n+        self.expect(&token::Eq)?;\n+        let expr = self.with_res(\n+            Restrictions::NO_STRUCT_LITERAL,\n+            |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n+        )?;\n+        let span = lo.to(expr.span);\n+        self.sess.let_chains_spans.borrow_mut().push(span);\n+        Ok(self.mk_expr(span, ExprKind::Let(pats, expr), attrs))\n+    }\n+\n+    /// `else` token already eaten\n+    fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        if self.eat_keyword(kw::If) {\n+            return self.parse_if_expr(ThinVec::new());\n+        } else {\n+            let blk = self.parse_block()?;\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), ThinVec::new()));\n+        }\n+    }\n+\n+    /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n+    fn parse_for_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n+\n+        // Record whether we are about to parse `for (`.\n+        // This is used below for recovery in case of `for ( $stuff ) $block`\n+        // in which case we will suggest `for $stuff $block`.\n+        let begin_paren = match self.token.kind {\n+            token::OpenDelim(token::Paren) => Some(self.token.span),\n+            _ => None,\n+        };\n+\n+        let pat = self.parse_top_level_pat()?;\n+        if !self.eat_keyword(kw::In) {\n+            let in_span = self.prev_span.between(self.token.span);\n+            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+                .span_suggestion_short(\n+                    in_span,\n+                    \"try adding `in` here\", \" in \".into(),\n+                    // has been misleading, at least in the past (closed Issue #48492)\n+                    Applicability::MaybeIncorrect\n+                )\n+                .emit();\n+        }\n+        let in_span = self.prev_span;\n+        self.check_for_for_in_in_typo(in_span);\n+        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n+\n+        let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+\n+        let hi = self.prev_span;\n+        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_label), attrs))\n+    }\n+\n+    /// Parses a `while` or `while let` expression (`while` token already eaten).\n+    fn parse_while_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_cond_expr()?;\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        let span = span_lo.to(body.span);\n+        Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs))\n+    }\n+\n+    /// Parse `loop {...}`, `loop` token already eaten.\n+    fn parse_loop_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        let span = span_lo.to(body.span);\n+        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n+    }\n+\n+    fn eat_label(&mut self) -> Option<Label> {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.token.span;\n+            self.bump();\n+            Some(Label { ident: Ident::new(ident.name, span) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // `match` token already eaten\n+    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let match_span = self.prev_span;\n+        let lo = self.prev_span;\n+        let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+        if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n+            if self.token == token::Semi {\n+                e.span_suggestion_short(\n+                    match_span,\n+                    \"try removing this `match`\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect // speculative\n+                );\n+            }\n+            return Err(e)\n+        }\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let mut arms: Vec<Arm> = Vec::new();\n+        while self.token != token::CloseDelim(token::Brace) {\n+            match self.parse_arm() {\n+                Ok(arm) => arms.push(arm),\n+                Err(mut e) => {\n+                    // Recover by skipping to the end of the block.\n+                    e.emit();\n+                    self.recover_stmt();\n+                    let span = lo.to(self.token.span);\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        self.bump();\n+                    }\n+                    return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n+                }\n+            }\n+        }\n+        let hi = self.token.span;\n+        self.bump();\n+        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n+    }\n+\n+    crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+        let pats = self.parse_pats()?;\n+        let guard = if self.eat_keyword(kw::If) {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        };\n+        let arrow_span = self.token.span;\n+        self.expect(&token::FatArrow)?;\n+        let arm_start_span = self.token.span;\n+\n+        let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)\n+            .map_err(|mut err| {\n+                err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n+                err\n+            })?;\n+\n+        let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n+            && self.token != token::CloseDelim(token::Brace);\n+\n+        let hi = self.token.span;\n+\n+        if require_comma {\n+            let cm = self.sess.source_map();\n+            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n+                .map_err(|mut err| {\n+                    match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n+                        (Ok(ref expr_lines), Ok(ref arm_start_lines))\n+                        if arm_start_lines.lines[0].end_col == expr_lines.lines[0].end_col\n+                            && expr_lines.lines.len() == 2\n+                            && self.token == token::FatArrow => {\n+                            // We check whether there's any trailing code in the parse span,\n+                            // if there isn't, we very likely have the following:\n+                            //\n+                            // X |     &Y => \"y\"\n+                            //   |        --    - missing comma\n+                            //   |        |\n+                            //   |        arrow_span\n+                            // X |     &X => \"x\"\n+                            //   |      - ^^ self.token.span\n+                            //   |      |\n+                            //   |      parsed until here as `\"y\" & X`\n+                            err.span_suggestion_short(\n+                                cm.next_point(arm_start_span),\n+                                \"missing a comma here to end this `match` arm\",\n+                                \",\".to_owned(),\n+                                Applicability::MachineApplicable\n+                            );\n+                        }\n+                        _ => {\n+                            err.span_label(arrow_span,\n+                                           \"while parsing the `match` arm starting here\");\n+                        }\n+                    }\n+                    err\n+                })?;\n+        } else {\n+            self.eat(&token::Comma);\n+        }\n+\n+        Ok(ast::Arm {\n+            attrs,\n+            pats,\n+            guard,\n+            body: expr,\n+            span: lo.to(hi),\n+        })\n+    }\n+\n+    /// Parses a `try {...}` expression (`try` token already eaten).\n+    fn parse_try_block(\n+        &mut self,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        if self.eat_keyword(kw::Catch) {\n+            let mut error = self.struct_span_err(self.prev_span,\n+                                                 \"keyword `catch` cannot follow a `try` block\");\n+            error.help(\"try using `match` on the result of the `try` block instead\");\n+            error.emit();\n+            Err(error)\n+        } else {\n+            Ok(self.mk_expr(span_lo.to(body.span), ExprKind::TryBlock(body), attrs))\n+        }\n+    }\n+\n+    fn is_do_catch_block(&self) -> bool {\n+        self.token.is_keyword(kw::Do) &&\n+        self.is_keyword_ahead(1, &[kw::Catch]) &&\n+        self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n+        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n+    }\n+\n+    fn is_try_block(&self) -> bool {\n+        self.token.is_keyword(kw::Try) &&\n+        self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n+        self.token.span.rust_2018() &&\n+        // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n+        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n+    }\n+\n+    /// Parses an `async move? {...}` expression.\n+    pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let span_lo = self.token.span;\n+        self.expect_keyword(kw::Async)?;\n+        let capture_clause = self.parse_capture_clause();\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        Ok(self.mk_expr(\n+            span_lo.to(body.span),\n+            ExprKind::Async(capture_clause, ast::DUMMY_NODE_ID, body), attrs))\n+    }\n+\n+    fn is_async_block(&self) -> bool {\n+        self.token.is_keyword(kw::Async) &&\n+        (\n+            ( // `async move {`\n+                self.is_keyword_ahead(1, &[kw::Move]) &&\n+                self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n+            ) || ( // `async {`\n+                self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+            )\n+        )\n+    }\n+\n+    fn maybe_parse_struct_expr(\n+        &mut self,\n+        lo: Span,\n+        path: &ast::Path,\n+        attrs: &ThinVec<Attribute>,\n+    ) -> Option<PResult<'a, P<Expr>>> {\n+        let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n+        let certainly_not_a_block = || self.look_ahead(1, |t| t.is_ident()) && (\n+            // `{ ident, ` cannot start a block\n+            self.look_ahead(2, |t| t == &token::Comma) ||\n+            self.look_ahead(2, |t| t == &token::Colon) && (\n+                // `{ ident: token, ` cannot start a block\n+                self.look_ahead(4, |t| t == &token::Comma) ||\n+                // `{ ident: ` cannot start a block unless it's a type ascription `ident: Type`\n+                self.look_ahead(3, |t| !t.can_begin_type())\n+            )\n+        );\n+\n+        if struct_allowed || certainly_not_a_block() {\n+            // This is a struct literal, but we don't can't accept them here\n+            let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n+            if let (Ok(expr), false) = (&expr, struct_allowed) {\n+                self.struct_span_err(\n+                    expr.span,\n+                    \"struct literals are not allowed here\",\n+                )\n+                .multipart_suggestion(\n+                    \"surround the struct literal with parentheses\",\n+                    vec![\n+                        (lo.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            }\n+            return Some(expr);\n+        }\n+        None\n+    }\n+\n+    pub(super) fn parse_struct_expr(\n+        &mut self,\n+        lo: Span,\n+        pth: ast::Path,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let struct_sp = lo.to(self.prev_span);\n+        self.bump();\n+        let mut fields = Vec::new();\n+        let mut base = None;\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        while self.token != token::CloseDelim(token::Brace) {\n+            if self.eat(&token::DotDot) {\n+                let exp_span = self.prev_span;\n+                match self.parse_expr() {\n+                    Ok(e) => {\n+                        base = Some(e);\n+                    }\n+                    Err(mut e) => {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n+                if self.token == token::Comma {\n+                    self.struct_span_err(\n+                        exp_span.to(self.prev_span),\n+                        \"cannot use a comma after the base struct\",\n+                    )\n+                    .span_suggestion_short(\n+                        self.token.span,\n+                        \"remove this comma\",\n+                        String::new(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .note(\"the base struct must always be the last field\")\n+                    .emit();\n+                    self.recover_stmt();\n+                }\n+                break;\n+            }\n+\n+            let mut recovery_field = None;\n+            if let token::Ident(name, _) = self.token.kind {\n+                if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n+                    // Use in case of error after field-looking code: `S { foo: () with a }`\n+                    recovery_field = Some(ast::Field {\n+                        ident: Ident::new(name, self.token.span),\n+                        span: self.token.span,\n+                        expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n+                        is_shorthand: false,\n+                        attrs: ThinVec::new(),\n+                    });\n+                }\n+            }\n+            let mut parsed_field = None;\n+            match self.parse_field() {\n+                Ok(f) => parsed_field = Some(f),\n+                Err(mut e) => {\n+                    e.span_label(struct_sp, \"while parsing this struct\");\n+                    e.emit();\n+\n+                    // If the next token is a comma, then try to parse\n+                    // what comes next as additional fields, rather than\n+                    // bailing out until next `}`.\n+                    if self.token != token::Comma {\n+                        self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n+                        if self.token != token::Comma {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            match self.expect_one_of(&[token::Comma],\n+                                     &[token::CloseDelim(token::Brace)]) {\n+                Ok(_) => if let Some(f) = parsed_field.or(recovery_field) {\n+                    // only include the field if there's no parse error for the field name\n+                    fields.push(f);\n+                }\n+                Err(mut e) => {\n+                    if let Some(f) = recovery_field {\n+                        fields.push(f);\n+                    }\n+                    e.span_label(struct_sp, \"while parsing this struct\");\n+                    e.emit();\n+                    self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n+                    self.eat(&token::Comma);\n+                }\n+            }\n+        }\n+\n+        let span = lo.to(self.token.span);\n+        self.expect(&token::CloseDelim(token::Brace))?;\n+        return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n+    }\n+\n+    /// Parse ident (COLON expr)?\n+    fn parse_field(&mut self) -> PResult<'a, Field> {\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+\n+        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n+        let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| {\n+            t == &token::Colon || t == &token::Eq\n+        }) {\n+            let fieldname = self.parse_field_name()?;\n+\n+            // Check for an equals token. This means the source incorrectly attempts to\n+            // initialize a field with an eq rather than a colon.\n+            if self.token == token::Eq {\n+                self.diagnostic()\n+                    .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n+                    .span_suggestion(\n+                        fieldname.span.shrink_to_hi().to(self.token.span),\n+                        \"replace equals symbol with a colon\",\n+                        \":\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            }\n+            self.bump(); // `:`\n+            (fieldname, self.parse_expr()?, false)\n+        } else {\n+            let fieldname = self.parse_ident_common(false)?;\n+\n+            // Mimic `x: x` for the `x` field shorthand.\n+            let path = ast::Path::from_ident(fieldname);\n+            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n+            (fieldname, expr, true)\n+        };\n+        Ok(ast::Field {\n+            ident: fieldname,\n+            span: lo.to(expr.span),\n+            expr,\n+            is_shorthand,\n+            attrs: attrs.into(),\n+        })\n+    }\n+\n+    fn err_dotdotdot_syntax(&self, span: Span) {\n+        self.struct_span_err(span, \"unexpected token: `...`\")\n+            .span_suggestion(\n+                span,\n+                \"use `..` for an exclusive range\", \"..\".to_owned(),\n+                Applicability::MaybeIncorrect\n+            )\n+            .span_suggestion(\n+                span,\n+                \"or `..=` for an inclusive range\", \"..=\".to_owned(),\n+                Applicability::MaybeIncorrect\n+            )\n+            .emit();\n+    }\n+\n+    fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {\n+        ExprKind::AssignOp(binop, lhs, rhs)\n+    }\n+\n+    fn mk_range(\n+        &self,\n+        start: Option<P<Expr>>,\n+        end: Option<P<Expr>>,\n+        limits: RangeLimits\n+    ) -> PResult<'a, ExprKind> {\n+        if end.is_none() && limits == RangeLimits::Closed {\n+            Err(self.span_fatal_err(self.token.span, Error::InclusiveRangeWithNoEnd))\n+        } else {\n+            Ok(ExprKind::Range(start, end, limits))\n+        }\n+    }\n+\n+    fn mk_unary(&self, unop: UnOp, expr: P<Expr>) -> ExprKind {\n+        ExprKind::Unary(unop, expr)\n+    }\n+\n+    fn mk_binary(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {\n+        ExprKind::Binary(binop, lhs, rhs)\n+    }\n+\n+    fn mk_index(&self, expr: P<Expr>, idx: P<Expr>) -> ExprKind {\n+        ExprKind::Index(expr, idx)\n+    }\n+\n+    fn mk_call(&self, f: P<Expr>, args: Vec<P<Expr>>) -> ExprKind {\n+        ExprKind::Call(f, args)\n+    }\n+\n+    fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let span = lo.to(self.prev_span);\n+        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), ThinVec::new());\n+        self.recover_from_await_method_call();\n+        Ok(await_expr)\n+    }\n+\n+    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+        P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n+    }\n+}"}, {"sha": "54f24f8ef2b21716c9643076603883676ff8636d", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,276 @@\n+use super::{Parser, PResult};\n+\n+use crate::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n+use crate::parse::token;\n+use crate::source_map::DUMMY_SP;\n+use crate::symbol::kw;\n+\n+impl<'a> Parser<'a> {\n+    /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n+    ///\n+    /// ```\n+    /// BOUND = LT_BOUND (e.g., `'a`)\n+    /// ```\n+    fn parse_lt_param_bounds(&mut self) -> GenericBounds {\n+        let mut lifetimes = Vec::new();\n+        while self.check_lifetime() {\n+            lifetimes.push(ast::GenericBound::Outlives(self.expect_lifetime()));\n+\n+            if !self.eat_plus() {\n+                break\n+            }\n+        }\n+        lifetimes\n+    }\n+\n+    /// Matches `typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?`.\n+    fn parse_ty_param(&mut self,\n+                      preceding_attrs: Vec<Attribute>)\n+                      -> PResult<'a, GenericParam> {\n+        let ident = self.parse_ident()?;\n+\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_generic_bounds(Some(self.prev_span))?\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+\n+        Ok(GenericParam {\n+            ident,\n+            id: ast::DUMMY_NODE_ID,\n+            attrs: preceding_attrs.into(),\n+            bounds,\n+            kind: GenericParamKind::Type {\n+                default,\n+            }\n+        })\n+    }\n+\n+    fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n+        self.expect_keyword(kw::Const)?;\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+\n+        Ok(GenericParam {\n+            ident,\n+            id: ast::DUMMY_NODE_ID,\n+            attrs: preceding_attrs.into(),\n+            bounds: Vec::new(),\n+            kind: GenericParamKind::Const {\n+                ty,\n+            }\n+        })\n+    }\n+\n+    /// Parses a (possibly empty) list of lifetime and type parameters, possibly including\n+    /// a trailing comma and erroneous trailing attributes.\n+    crate fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n+        let mut params = Vec::new();\n+        loop {\n+            let attrs = self.parse_outer_attributes()?;\n+            if self.check_lifetime() {\n+                let lifetime = self.expect_lifetime();\n+                // Parse lifetime parameter.\n+                let bounds = if self.eat(&token::Colon) {\n+                    self.parse_lt_param_bounds()\n+                } else {\n+                    Vec::new()\n+                };\n+                params.push(ast::GenericParam {\n+                    ident: lifetime.ident,\n+                    id: lifetime.id,\n+                    attrs: attrs.into(),\n+                    bounds,\n+                    kind: ast::GenericParamKind::Lifetime,\n+                });\n+            } else if self.check_keyword(kw::Const) {\n+                // Parse const parameter.\n+                params.push(self.parse_const_param(attrs)?);\n+            } else if self.check_ident() {\n+                // Parse type parameter.\n+                params.push(self.parse_ty_param(attrs)?);\n+            } else {\n+                // Check for trailing attributes and stop parsing.\n+                if !attrs.is_empty() {\n+                    if !params.is_empty() {\n+                        self.struct_span_err(\n+                            attrs[0].span,\n+                            &format!(\"trailing attribute after generic parameter\"),\n+                        )\n+                        .span_label(attrs[0].span, \"attributes must go before parameters\")\n+                        .emit();\n+                    } else {\n+                        self.struct_span_err(\n+                            attrs[0].span,\n+                            &format!(\"attribute without generic parameters\"),\n+                        )\n+                        .span_label(\n+                            attrs[0].span,\n+                            \"attributes are only permitted when preceding parameters\",\n+                        )\n+                        .emit();\n+                    }\n+                }\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+        Ok(params)\n+    }\n+\n+    /// Parses a set of optional generic type parameter declarations. Where\n+    /// clauses are not parsed here, and must be added later via\n+    /// `parse_where_clause()`.\n+    ///\n+    /// matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n+    ///                  | ( < lifetimes , typaramseq ( , )? > )\n+    /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n+    pub(super) fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n+        let span_lo = self.token.span;\n+        let (params, span) = if self.eat_lt() {\n+            let params = self.parse_generic_params()?;\n+            self.expect_gt()?;\n+            (params, span_lo.to(self.prev_span))\n+        } else {\n+            (vec![], self.prev_span.between(self.token.span))\n+        };\n+        Ok(ast::Generics {\n+            params,\n+            where_clause: WhereClause {\n+                predicates: Vec::new(),\n+                span: DUMMY_SP,\n+            },\n+            span,\n+        })\n+    }\n+\n+    /// Parses an optional where-clause and places it in `generics`.\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// where T : Trait<U, V> + 'b, 'a : 'b\n+    /// ```\n+    pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n+        let mut where_clause = WhereClause {\n+            predicates: Vec::new(),\n+            span: self.prev_span.to(self.prev_span),\n+        };\n+\n+        if !self.eat_keyword(kw::Where) {\n+            return Ok(where_clause);\n+        }\n+        let lo = self.prev_span;\n+\n+        // We are considering adding generics to the `where` keyword as an alternative higher-rank\n+        // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n+        // change we parse those generics now, but report an error.\n+        if self.choose_generics_over_qpath() {\n+            let generics = self.parse_generics()?;\n+            self.struct_span_err(\n+                generics.span,\n+                \"generic parameters on `where` clauses are reserved for future use\",\n+            )\n+                .span_label(generics.span, \"currently unsupported\")\n+                .emit();\n+        }\n+\n+        loop {\n+            let lo = self.token.span;\n+            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n+                let lifetime = self.expect_lifetime();\n+                // Bounds starting with a colon are mandatory, but possibly empty.\n+                self.expect(&token::Colon)?;\n+                let bounds = self.parse_lt_param_bounds();\n+                where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                    ast::WhereRegionPredicate {\n+                        span: lo.to(self.prev_span),\n+                        lifetime,\n+                        bounds,\n+                    }\n+                ));\n+            } else if self.check_type() {\n+                // Parse optional `for<'a, 'b>`.\n+                // This `for` is parsed greedily and applies to the whole predicate,\n+                // the bounded type can have its own `for` applying only to it.\n+                // Examples:\n+                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n+                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+                // Parse type with mandatory colon and (possibly empty) bounds,\n+                // or with mandatory equality sign and the second type.\n+                let ty = self.parse_ty()?;\n+                if self.eat(&token::Colon) {\n+                    let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                        ast::WhereBoundPredicate {\n+                            span: lo.to(self.prev_span),\n+                            bound_generic_params: lifetime_defs,\n+                            bounded_ty: ty,\n+                            bounds,\n+                        }\n+                    ));\n+                // FIXME: Decide what should be used here, `=` or `==`.\n+                // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n+                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+                    let rhs_ty = self.parse_ty()?;\n+                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n+                        ast::WhereEqPredicate {\n+                            span: lo.to(self.prev_span),\n+                            lhs_ty: ty,\n+                            rhs_ty,\n+                            id: ast::DUMMY_NODE_ID,\n+                        }\n+                    ));\n+                } else {\n+                    return self.unexpected();\n+                }\n+            } else {\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+\n+        where_clause.span = lo.to(self.prev_span);\n+        Ok(where_clause)\n+    }\n+\n+    pub(super) fn choose_generics_over_qpath(&self) -> bool {\n+        // There's an ambiguity between generic parameters and qualified paths in impls.\n+        // If we see `<` it may start both, so we have to inspect some following tokens.\n+        // The following combinations can only start generics,\n+        // but not qualified paths (with one exception):\n+        //     `<` `>` - empty generic parameters\n+        //     `<` `#` - generic parameters with attributes\n+        //     `<` (LIFETIME|IDENT) `>` - single generic parameter\n+        //     `<` (LIFETIME|IDENT) `,` - first generic parameter in a list\n+        //     `<` (LIFETIME|IDENT) `:` - generic parameter with bounds\n+        //     `<` (LIFETIME|IDENT) `=` - generic parameter with a default\n+        //     `<` const                - generic const parameter\n+        // The only truly ambiguous case is\n+        //     `<` IDENT `>` `::` IDENT ...\n+        // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n+        // because this is what almost always expected in practice, qualified paths in impls\n+        // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n+        self.token == token::Lt &&\n+            (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt) ||\n+             self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n+                self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n+                                       t == &token::Colon || t == &token::Eq) ||\n+            self.is_keyword_ahead(1, &[kw::Const]))\n+    }\n+}"}, {"sha": "e85ef9cc974194f0a1576f4f01f3038442a9dd24", "filename": "src/libsyntax/parse/parser/item.rs", "status": "added", "additions": 1915, "deletions": 0, "changes": 1915, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,1915 @@\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n+\n+use crate::maybe_whole;\n+use crate::ptr::P;\n+use crate::ast::{self, Ident, Attribute, AttrStyle};\n+use crate::ast::{Item, ItemKind, ImplItem, TraitItem, TraitItemKind};\n+use crate::ast::{UseTree, UseTreeKind, PathSegment};\n+use crate::ast::{IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use crate::ast::{Visibility, VisibilityKind, Mutability, FnDecl, FnHeader};\n+use crate::ast::{ForeignItem, ForeignItemKind};\n+use crate::ast::{Ty, TyKind, GenericBounds, TraitRef};\n+use crate::ast::{EnumDef, VariantData, StructField, AnonConst};\n+use crate::ast::{Mac, Mac_, MacDelimiter};\n+use crate::ext::base::DummyResult;\n+use crate::parse::token;\n+use crate::parse::parser::maybe_append;\n+use crate::parse::diagnostics::{Error};\n+use crate::tokenstream::{TokenTree, TokenStream};\n+use crate::source_map::{respan, Span, Spanned};\n+use crate::symbol::{kw, sym};\n+\n+use std::mem;\n+use log::debug;\n+use rustc_target::spec::abi::{Abi};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+\n+/// Whether the type alias or associated type is a concrete type or an opaque type\n+#[derive(Debug)]\n+pub enum AliasKind {\n+    /// Just a new name for the same type\n+    Weak(P<Ty>),\n+    /// Only trait impls of the type will be usable, not the actual type itself\n+    OpaqueTy(GenericBounds),\n+}\n+\n+pub(super) type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n+\n+impl<'a> Parser<'a> {\n+    pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n+        let attrs = self.parse_outer_attributes()?;\n+        self.parse_item_(attrs, true, false)\n+    }\n+\n+    pub(super) fn parse_item_(\n+        &mut self,\n+        attrs: Vec<Attribute>,\n+        macros_allowed: bool,\n+        attributes_allowed: bool,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let mut unclosed_delims = vec![];\n+        let (ret, tokens) = self.collect_tokens(|this| {\n+            let item = this.parse_item_implementation(attrs, macros_allowed, attributes_allowed);\n+            unclosed_delims.append(&mut this.unclosed_delims);\n+            item\n+        })?;\n+        self.unclosed_delims.append(&mut unclosed_delims);\n+\n+        // Once we've parsed an item and recorded the tokens we got while\n+        // parsing we may want to store `tokens` into the item we're about to\n+        // return. Note, though, that we specifically didn't capture tokens\n+        // related to outer attributes. The `tokens` field here may later be\n+        // used with procedural macros to convert this item back into a token\n+        // stream, but during expansion we may be removing attributes as we go\n+        // along.\n+        //\n+        // If we've got inner attributes then the `tokens` we've got above holds\n+        // these inner attributes. If an inner attribute is expanded we won't\n+        // actually remove it from the token stream, so we'll just keep yielding\n+        // it (bad!). To work around this case for now we just avoid recording\n+        // `tokens` if we detect any inner attributes. This should help keep\n+        // expansion correct, but we should fix this bug one day!\n+        Ok(ret.map(|item| {\n+            item.map(|mut i| {\n+                if !i.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+                    i.tokens = Some(tokens);\n+                }\n+                i\n+            })\n+        }))\n+    }\n+\n+    /// Parses one of the items allowed by the flags.\n+    fn parse_item_implementation(\n+        &mut self,\n+        attrs: Vec<Attribute>,\n+        macros_allowed: bool,\n+        attributes_allowed: bool,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        maybe_whole!(self, NtItem, |item| {\n+            let mut item = item.into_inner();\n+            let mut attrs = attrs;\n+            mem::swap(&mut item.attrs, &mut attrs);\n+            item.attrs.extend(attrs);\n+            Some(P(item))\n+        });\n+\n+        let lo = self.token.span;\n+\n+        let visibility = self.parse_visibility(false)?;\n+\n+        if self.eat_keyword(kw::Use) {\n+            // USE ITEM\n+            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n+            self.expect(&token::Semi)?;\n+\n+            let span = lo.to(self.prev_span);\n+            let item =\n+                self.mk_item(span, Ident::invalid(), item_, visibility, attrs);\n+            return Ok(Some(item));\n+        }\n+\n+        if self.eat_keyword(kw::Extern) {\n+            let extern_sp = self.prev_span;\n+            if self.eat_keyword(kw::Crate) {\n+                return Ok(Some(self.parse_item_extern_crate(lo, visibility, attrs)?));\n+            }\n+\n+            let opt_abi = self.parse_opt_abi()?;\n+\n+            if self.eat_keyword(kw::Fn) {\n+                // EXTERN FUNCTION ITEM\n+                let fn_span = self.prev_span;\n+                let abi = opt_abi.unwrap_or(Abi::C);\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(Unsafety::Normal,\n+                                       respan(fn_span, IsAsync::NotAsync),\n+                                       respan(fn_span, Constness::NotConst),\n+                                       abi)?;\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                return Ok(Some(item));\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                return Ok(Some(\n+                    self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n+                ));\n+            }\n+\n+            self.unexpected()?;\n+        }\n+\n+        if self.is_static_global() {\n+            self.bump();\n+            // STATIC ITEM\n+            let m = self.parse_mutability();\n+            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Const) {\n+            let const_span = self.prev_span;\n+            if self.check_keyword(kw::Fn)\n+                || (self.check_keyword(kw::Unsafe)\n+                    && self.is_keyword_ahead(1, &[kw::Fn])) {\n+                // CONST FUNCTION ITEM\n+                let unsafety = self.parse_unsafety();\n+                self.bump();\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(unsafety,\n+                                       respan(const_span, IsAsync::NotAsync),\n+                                       respan(const_span, Constness::Const),\n+                                       Abi::Rust)?;\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                return Ok(Some(item));\n+            }\n+\n+            // CONST ITEM\n+            if self.eat_keyword(kw::Mut) {\n+                let prev_span = self.prev_span;\n+                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n+                    .span_label(prev_span, \"cannot be mutable\")\n+                    .span_suggestion(\n+                        const_span,\n+                        \"you might want to declare a static instead\",\n+                        \"static\".to_owned(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n+            }\n+            let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+\n+        // Parse `async unsafe? fn`.\n+        if self.check_keyword(kw::Async) {\n+            let async_span = self.token.span;\n+            if self.is_keyword_ahead(1, &[kw::Fn])\n+                || self.is_keyword_ahead(2, &[kw::Fn])\n+            {\n+                // ASYNC FUNCTION ITEM\n+                self.bump(); // `async`\n+                let unsafety = self.parse_unsafety(); // `unsafe`?\n+                self.expect_keyword(kw::Fn)?; // `fn`\n+                let fn_span = self.prev_span;\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(unsafety,\n+                                    respan(async_span, IsAsync::Async {\n+                                        closure_id: ast::DUMMY_NODE_ID,\n+                                        return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                                    }),\n+                                    respan(fn_span, Constness::NotConst),\n+                                    Abi::Rust)?;\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                self.ban_async_in_2015(async_span);\n+                return Ok(Some(item));\n+            }\n+        }\n+        if self.check_keyword(kw::Unsafe) &&\n+            self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n+        {\n+            // UNSAFE TRAIT ITEM\n+            self.bump(); // `unsafe`\n+            let is_auto = if self.eat_keyword(kw::Trait) {\n+                IsAuto::No\n+            } else {\n+                self.expect_keyword(kw::Auto)?;\n+                self.expect_keyword(kw::Trait)?;\n+                IsAuto::Yes\n+            };\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.check_keyword(kw::Impl) ||\n+           self.check_keyword(kw::Unsafe) &&\n+                self.is_keyword_ahead(1, &[kw::Impl]) ||\n+           self.check_keyword(kw::Default) &&\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n+            // IMPL ITEM\n+            let defaultness = self.parse_defaultness();\n+            let unsafety = self.parse_unsafety();\n+            self.expect_keyword(kw::Impl)?;\n+            let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n+            let span = lo.to(self.prev_span);\n+            return Ok(Some(self.mk_item(span, ident, item, visibility,\n+                                        maybe_append(attrs, extra_attrs))));\n+        }\n+        if self.check_keyword(kw::Fn) {\n+            // FUNCTION ITEM\n+            self.bump();\n+            let fn_span = self.prev_span;\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(Unsafety::Normal,\n+                                   respan(fn_span, IsAsync::NotAsync),\n+                                   respan(fn_span, Constness::NotConst),\n+                                   Abi::Rust)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.check_keyword(kw::Unsafe)\n+            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n+            // UNSAFE FUNCTION ITEM\n+            self.bump(); // `unsafe`\n+            // `{` is also expected after `unsafe`, in case of error, include it in the diagnostic\n+            self.check(&token::OpenDelim(token::Brace));\n+            let abi = if self.eat_keyword(kw::Extern) {\n+                self.parse_opt_abi()?.unwrap_or(Abi::C)\n+            } else {\n+                Abi::Rust\n+            };\n+            self.expect_keyword(kw::Fn)?;\n+            let fn_span = self.prev_span;\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(Unsafety::Unsafe,\n+                                   respan(fn_span, IsAsync::NotAsync),\n+                                   respan(fn_span, Constness::NotConst),\n+                                   abi)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Mod) {\n+            // MODULE ITEM\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_mod(&attrs[..])?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if let Some(type_) = self.eat_type() {\n+            let (ident, alias, generics) = type_?;\n+            // TYPE ITEM\n+            let item_ = match alias {\n+                AliasKind::Weak(ty) => ItemKind::TyAlias(ty, generics),\n+                AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n+            };\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    attrs);\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Enum) {\n+            // ENUM ITEM\n+            let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.check_keyword(kw::Trait)\n+            || (self.check_keyword(kw::Auto)\n+                && self.is_keyword_ahead(1, &[kw::Trait]))\n+        {\n+            let is_auto = if self.eat_keyword(kw::Trait) {\n+                IsAuto::No\n+            } else {\n+                self.expect_keyword(kw::Auto)?;\n+                self.expect_keyword(kw::Trait)?;\n+                IsAuto::Yes\n+            };\n+            // TRAIT ITEM\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_trait(is_auto, Unsafety::Normal)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Struct) {\n+            // STRUCT ITEM\n+            let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.is_union_item() {\n+            // UNION ITEM\n+            self.bump();\n+            let (ident, item_, extra_attrs) = self.parse_item_union()?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n+            return Ok(Some(macro_def));\n+        }\n+\n+        // Verify whether we have encountered a struct or method definition where the user forgot to\n+        // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n+        if visibility.node.is_pub() &&\n+            self.check_ident() &&\n+            self.look_ahead(1, |t| *t != token::Not)\n+        {\n+            // Space between `pub` keyword and the identifier\n+            //\n+            //     pub   S {}\n+            //        ^^^ `sp` points here\n+            let sp = self.prev_span.between(self.token.span);\n+            let full_sp = self.prev_span.to(self.token.span);\n+            let ident_sp = self.token.span;\n+            if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n+                // possible public struct definition where `struct` was forgotten\n+                let ident = self.parse_ident().unwrap();\n+                let msg = format!(\"add `struct` here to parse `{}` as a public struct\",\n+                                  ident);\n+                let mut err = self.diagnostic()\n+                    .struct_span_err(sp, \"missing `struct` for struct definition\");\n+                err.span_suggestion_short(\n+                    sp, &msg, \" struct \".into(), Applicability::MaybeIncorrect // speculative\n+                );\n+                return Err(err);\n+            } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n+                let ident = self.parse_ident().unwrap();\n+                self.bump();  // `(`\n+                let kw_name = if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n+                    .map_err(|mut e| e.cancel())\n+                {\n+                    \"method\"\n+                } else {\n+                    \"function\"\n+                };\n+                self.consume_block(token::Paren);\n+                let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+                    self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n+                    self.bump();  // `{`\n+                    (\"fn\", kw_name, false)\n+                } else if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.bump();  // `{`\n+                    (\"fn\", kw_name, false)\n+                } else if self.check(&token::Colon) {\n+                    let kw = \"struct\";\n+                    (kw, kw, false)\n+                } else {\n+                    (\"fn` or `struct\", \"function or struct\", true)\n+                };\n+\n+                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                if !ambiguous {\n+                    self.consume_block(token::Brace);\n+                    let suggestion = format!(\"add `{}` here to parse `{}` as a public {}\",\n+                                             kw,\n+                                             ident,\n+                                             kw_name);\n+                    err.span_suggestion_short(\n+                        sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n+                    );\n+                } else {\n+                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                        err.span_suggestion(\n+                            full_sp,\n+                            \"if you meant to call a macro, try\",\n+                            format!(\"{}!\", snippet),\n+                            // this is the `ambiguous` conditional branch\n+                            Applicability::MaybeIncorrect\n+                        );\n+                    } else {\n+                        err.help(\"if you meant to call a macro, remove the `pub` \\\n+                                  and add a trailing `!` after the identifier\");\n+                    }\n+                }\n+                return Err(err);\n+            } else if self.look_ahead(1, |t| *t == token::Lt) {\n+                let ident = self.parse_ident().unwrap();\n+                self.eat_to_tokens(&[&token::Gt]);\n+                self.bump();  // `>`\n+                let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n+                    if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n+                        .map_err(|mut e| e.cancel())\n+                    {\n+                        (\"fn\", \"method\", false)\n+                    } else {\n+                        (\"fn\", \"function\", false)\n+                    }\n+                } else if self.check(&token::OpenDelim(token::Brace)) {\n+                    (\"struct\", \"struct\", false)\n+                } else {\n+                    (\"fn` or `struct\", \"function or struct\", true)\n+                };\n+                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                if !ambiguous {\n+                    err.span_suggestion_short(\n+                        sp,\n+                        &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                        format!(\" {} \", kw),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                return Err(err);\n+            }\n+        }\n+        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, visibility)\n+    }\n+\n+    /// This is the fall-through for parsing items.\n+    fn parse_macro_use_or_failure(\n+        &mut self,\n+        attrs: Vec<Attribute> ,\n+        macros_allowed: bool,\n+        attributes_allowed: bool,\n+        lo: Span,\n+        visibility: Visibility\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        if macros_allowed && self.token.is_path_start() &&\n+                !(self.is_async_fn() && self.token.span.rust_2015()) {\n+            // MACRO INVOCATION ITEM\n+\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&visibility.node, prev_span);\n+\n+            let mac_lo = self.token.span;\n+\n+            // item macro.\n+            let path = self.parse_path(PathStyle::Mod)?;\n+            self.expect(&token::Not)?;\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n+            }\n+\n+            let hi = self.prev_span;\n+            let mac = respan(mac_lo.to(hi), Mac_ {\n+                path,\n+                tts,\n+                delim,\n+                prior_type_ascription: self.last_type_ascription,\n+            });\n+            let item =\n+                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n+            return Ok(Some(item));\n+        }\n+\n+        // FAILURE TO PARSE ITEM\n+        match visibility.node {\n+            VisibilityKind::Inherited => {}\n+            _ => {\n+                return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n+            }\n+        }\n+\n+        if !attributes_allowed && !attrs.is_empty() {\n+            self.expected_item_err(&attrs)?;\n+        }\n+        Ok(None)\n+    }\n+\n+    /// Emits an expected-item-after-attributes error.\n+    fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a,  ()> {\n+        let message = match attrs.last() {\n+            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n+            _ => \"expected item after attributes\",\n+        };\n+\n+        let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n+        if attrs.last().unwrap().is_sugared_doc {\n+            err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n+        }\n+        Err(err)\n+    }\n+\n+    pub(super) fn is_async_fn(&self) -> bool {\n+        self.token.is_keyword(kw::Async) &&\n+            self.is_keyword_ahead(1, &[kw::Fn])\n+    }\n+\n+    /// Parses a macro invocation inside a `trait`, `impl` or `extern` block.\n+    fn parse_assoc_macro_invoc(&mut self, item_kind: &str, vis: Option<&Visibility>,\n+                               at_end: &mut bool) -> PResult<'a, Option<Mac>>\n+    {\n+        if self.token.is_path_start() &&\n+                !(self.is_async_fn() && self.token.span.rust_2015()) {\n+            let prev_span = self.prev_span;\n+            let lo = self.token.span;\n+            let path = self.parse_path(PathStyle::Mod)?;\n+\n+            if path.segments.len() == 1 {\n+                if !self.eat(&token::Not) {\n+                    return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n+                }\n+            } else {\n+                self.expect(&token::Not)?;\n+            }\n+\n+            if let Some(vis) = vis {\n+                self.complain_if_pub_macro(&vis.node, prev_span);\n+            }\n+\n+            *at_end = true;\n+\n+            // eat a matched-delimiter token tree:\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace {\n+                self.expect(&token::Semi)?;\n+            }\n+\n+            Ok(Some(respan(lo.to(self.prev_span), Mac_ {\n+                path,\n+                tts,\n+                delim,\n+                prior_type_ascription: self.last_type_ascription,\n+            })))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn missing_assoc_item_kind_err(&self, item_type: &str, prev_span: Span)\n+                                   -> DiagnosticBuilder<'a>\n+    {\n+        let expected_kinds = if item_type == \"extern\" {\n+            \"missing `fn`, `type`, or `static`\"\n+        } else {\n+            \"missing `fn`, `type`, or `const`\"\n+        };\n+\n+        // Given this code `path(`, it seems like this is not\n+        // setting the visibility of a macro invocation, but rather\n+        // a mistyped method declaration.\n+        // Create a diagnostic pointing out that `fn` is missing.\n+        //\n+        // x |     pub path(&self) {\n+        //   |        ^ missing `fn`, `type`, or `const`\n+        //     pub  path(\n+        //        ^^ `sp` below will point to this\n+        let sp = prev_span.between(self.prev_span);\n+        let mut err = self.diagnostic().struct_span_err(\n+            sp,\n+            &format!(\"{} for {}-item declaration\",\n+                     expected_kinds, item_type));\n+        err.span_label(sp, expected_kinds);\n+        err\n+    }\n+\n+    /// Parses an implementation item, `impl` keyword is already parsed.\n+    ///\n+    ///    impl<'a, T> TYPE { /* impl items */ }\n+    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n+    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    ///\n+    /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n+    ///     `impl` GENERICS `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n+    ///     `impl` GENERICS `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    fn parse_item_impl(&mut self, unsafety: Unsafety, defaultness: Defaultness)\n+                       -> PResult<'a, ItemInfo> {\n+        // First, parse generic parameters if necessary.\n+        let mut generics = if self.choose_generics_over_qpath() {\n+            self.parse_generics()?\n+        } else {\n+            ast::Generics::default()\n+        };\n+\n+        // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n+        let polarity = if self.check(&token::Not) && self.look_ahead(1, |t| t.can_begin_type()) {\n+            self.bump(); // `!`\n+            ast::ImplPolarity::Negative\n+        } else {\n+            ast::ImplPolarity::Positive\n+        };\n+\n+        // Parse both types and traits as a type, then reinterpret if necessary.\n+        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n+        let ty_first = if self.token.is_keyword(kw::For) &&\n+                          self.look_ahead(1, |t| t != &token::Lt) {\n+            let span = self.prev_span.between(self.token.span);\n+            self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n+            P(Ty { node: TyKind::Path(None, err_path(span)), span, id: ast::DUMMY_NODE_ID })\n+        } else {\n+            self.parse_ty()?\n+        };\n+\n+        // If `for` is missing we try to recover.\n+        let has_for = self.eat_keyword(kw::For);\n+        let missing_for_span = self.prev_span.between(self.token.span);\n+\n+        let ty_second = if self.token == token::DotDot {\n+            // We need to report this error after `cfg` expansion for compatibility reasons\n+            self.bump(); // `..`, do not add it to expected tokens\n+            Some(DummyResult::raw_ty(self.prev_span, true))\n+        } else if has_for || self.token.can_begin_type() {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+\n+        generics.where_clause = self.parse_where_clause()?;\n+\n+        let (impl_items, attrs) = self.parse_impl_body()?;\n+\n+        let item_kind = match ty_second {\n+            Some(ty_second) => {\n+                // impl Trait for Type\n+                if !has_for {\n+                    self.struct_span_err(missing_for_span, \"missing `for` in a trait impl\")\n+                        .span_suggestion_short(\n+                            missing_for_span,\n+                            \"add `for` here\",\n+                            \" for \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        ).emit();\n+                }\n+\n+                let ty_first = ty_first.into_inner();\n+                let path = match ty_first.node {\n+                    // This notably includes paths passed through `ty` macro fragments (#46438).\n+                    TyKind::Path(None, path) => path,\n+                    _ => {\n+                        self.span_err(ty_first.span, \"expected a trait, found type\");\n+                        err_path(ty_first.span)\n+                    }\n+                };\n+                let trait_ref = TraitRef { path, ref_id: ty_first.id };\n+\n+                ItemKind::Impl(unsafety, polarity, defaultness,\n+                               generics, Some(trait_ref), ty_second, impl_items)\n+            }\n+            None => {\n+                // impl Type\n+                ItemKind::Impl(unsafety, polarity, defaultness,\n+                               generics, None, ty_first, impl_items)\n+            }\n+        };\n+\n+        Ok((Ident::invalid(), item_kind, Some(attrs)))\n+    }\n+\n+    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+        let attrs = self.parse_inner_attributes()?;\n+\n+        let mut impl_items = Vec::new();\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            let mut at_end = false;\n+            match self.parse_impl_item(&mut at_end) {\n+                Ok(impl_item) => impl_items.push(impl_item),\n+                Err(mut err) => {\n+                    err.emit();\n+                    if !at_end {\n+                        self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                    }\n+                }\n+            }\n+        }\n+        Ok((impl_items, attrs))\n+    }\n+\n+    /// Parses an impl item.\n+    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n+        maybe_whole!(self, NtImplItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let mut unclosed_delims = vec![];\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            let item = this.parse_impl_item_(at_end, attrs);\n+            unclosed_delims.append(&mut this.unclosed_delims);\n+            item\n+        })?;\n+        self.unclosed_delims.append(&mut unclosed_delims);\n+\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_impl_item_(&mut self,\n+                        at_end: &mut bool,\n+                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n+        let lo = self.token.span;\n+        let vis = self.parse_visibility(false)?;\n+        let defaultness = self.parse_defaultness();\n+        let (name, node, generics) = if let Some(type_) = self.eat_type() {\n+            let (name, alias, generics) = type_?;\n+            let kind = match alias {\n+                AliasKind::Weak(typ) => ast::ImplItemKind::TyAlias(typ),\n+                AliasKind::OpaqueTy(bounds) => ast::ImplItemKind::OpaqueTy(bounds),\n+            };\n+            (name, kind, generics)\n+        } else if self.is_const_item() {\n+            // This parses the grammar:\n+            //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n+            self.expect_keyword(kw::Const)?;\n+            let name = self.parse_ident()?;\n+            self.expect(&token::Colon)?;\n+            let typ = self.parse_ty()?;\n+            self.expect(&token::Eq)?;\n+            let expr = self.parse_expr()?;\n+            self.expect(&token::Semi)?;\n+            (name, ast::ImplItemKind::Const(typ, expr), ast::Generics::default())\n+        } else {\n+            let (name, inner_attrs, generics, node) = self.parse_impl_method(&vis, at_end)?;\n+            attrs.extend(inner_attrs);\n+            (name, node, generics)\n+        };\n+\n+        Ok(ImplItem {\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(self.prev_span),\n+            ident: name,\n+            vis,\n+            defaultness,\n+            attrs,\n+            generics,\n+            node,\n+            tokens: None,\n+        })\n+    }\n+\n+    /// Parses defaultness (i.e., `default` or nothing).\n+    fn parse_defaultness(&mut self) -> Defaultness {\n+        // `pub` is included for better error messages\n+        if self.check_keyword(kw::Default) &&\n+            self.is_keyword_ahead(1, &[\n+                kw::Impl,\n+                kw::Const,\n+                kw::Fn,\n+                kw::Unsafe,\n+                kw::Extern,\n+                kw::Type,\n+                kw::Pub,\n+            ])\n+        {\n+            self.bump(); // `default`\n+            Defaultness::Default\n+        } else {\n+            Defaultness::Final\n+        }\n+    }\n+\n+    /// Returns `true` if we are looking at `const ID`\n+    /// (returns `false` for things like `const fn`, etc.).\n+    fn is_const_item(&self) -> bool {\n+        self.token.is_keyword(kw::Const) &&\n+            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n+    }\n+\n+    /// Parse a method or a macro invocation in a trait impl.\n+    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n+                         -> PResult<'a, (Ident, Vec<Attribute>, ast::Generics,\n+                             ast::ImplItemKind)> {\n+        // code copied from parse_macro_use_or_failure... abstraction!\n+        if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n+            // method macro\n+            Ok((Ident::invalid(), vec![], ast::Generics::default(),\n+                ast::ImplItemKind::Macro(mac)))\n+        } else {\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n+            let decl = self.parse_fn_decl_with_self(|p| {\n+                p.parse_arg_general(true, false, |_| true)\n+            })?;\n+            generics.where_clause = self.parse_where_clause()?;\n+            *at_end = true;\n+            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n+            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n+                ast::MethodSig { header, decl },\n+                body\n+            )))\n+        }\n+    }\n+\n+    /// Parses all the \"front matter\" for a `fn` declaration, up to\n+    /// and including the `fn` keyword:\n+    ///\n+    /// - `const fn`\n+    /// - `unsafe fn`\n+    /// - `const unsafe fn`\n+    /// - `extern fn`\n+    /// - etc.\n+    fn parse_fn_front_matter(&mut self)\n+        -> PResult<'a, (\n+            Spanned<Constness>,\n+            Unsafety,\n+            Spanned<IsAsync>,\n+            Abi\n+        )>\n+    {\n+        let is_const_fn = self.eat_keyword(kw::Const);\n+        let const_span = self.prev_span;\n+        let asyncness = self.parse_asyncness();\n+        if let IsAsync::Async { .. } = asyncness {\n+            self.ban_async_in_2015(self.prev_span);\n+        }\n+        let asyncness = respan(self.prev_span, asyncness);\n+        let unsafety = self.parse_unsafety();\n+        let (constness, unsafety, abi) = if is_const_fn {\n+            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n+        } else {\n+            let abi = if self.eat_keyword(kw::Extern) {\n+                self.parse_opt_abi()?.unwrap_or(Abi::C)\n+            } else {\n+                Abi::Rust\n+            };\n+            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n+        };\n+        if !self.eat_keyword(kw::Fn) {\n+            // It is possible for `expect_one_of` to recover given the contents of\n+            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n+            // account for this.\n+            if !self.expect_one_of(&[], &[])? { unreachable!() }\n+        }\n+        Ok((constness, unsafety, asyncness, abi))\n+    }\n+\n+    /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, is_auto: IsAuto, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+        let ident = self.parse_ident()?;\n+        let mut tps = self.parse_generics()?;\n+\n+        // Parse optional colon and supertrait bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_generic_bounds(Some(self.prev_span))?\n+        } else {\n+            Vec::new()\n+        };\n+\n+        if self.eat(&token::Eq) {\n+            // it's a trait alias\n+            let bounds = self.parse_generic_bounds(None)?;\n+            tps.where_clause = self.parse_where_clause()?;\n+            self.expect(&token::Semi)?;\n+            if is_auto == IsAuto::Yes {\n+                let msg = \"trait aliases cannot be `auto`\";\n+                self.struct_span_err(self.prev_span, msg)\n+                    .span_label(self.prev_span, msg)\n+                    .emit();\n+            }\n+            if unsafety != Unsafety::Normal {\n+                let msg = \"trait aliases cannot be `unsafe`\";\n+                self.struct_span_err(self.prev_span, msg)\n+                    .span_label(self.prev_span, msg)\n+                    .emit();\n+            }\n+            Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n+        } else {\n+            // it's a normal trait\n+            tps.where_clause = self.parse_where_clause()?;\n+            self.expect(&token::OpenDelim(token::Brace))?;\n+            let mut trait_items = vec![];\n+            while !self.eat(&token::CloseDelim(token::Brace)) {\n+                if let token::DocComment(_) = self.token.kind {\n+                    if self.look_ahead(1,\n+                    |tok| tok == &token::CloseDelim(token::Brace)) {\n+                        self.diagnostic().struct_span_err_with_code(\n+                            self.token.span,\n+                            \"found a documentation comment that doesn't document anything\",\n+                            DiagnosticId::Error(\"E0584\".into()),\n+                        )\n+                        .help(\n+                            \"doc comments must come before what they document, maybe a \\\n+                            comment was intended with `//`?\",\n+                        )\n+                        .emit();\n+                        self.bump();\n+                        continue;\n+                    }\n+                }\n+                let mut at_end = false;\n+                match self.parse_trait_item(&mut at_end) {\n+                    Ok(item) => trait_items.push(item),\n+                    Err(mut e) => {\n+                        e.emit();\n+                        if !at_end {\n+                            self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                        }\n+                    }\n+                }\n+            }\n+            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, trait_items), None))\n+        }\n+    }\n+\n+    /// Parses the items in a trait declaration.\n+    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n+        maybe_whole!(self, NtTraitItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let mut unclosed_delims = vec![];\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            let item = this.parse_trait_item_(at_end, attrs);\n+            unclosed_delims.append(&mut this.unclosed_delims);\n+            item\n+        })?;\n+        self.unclosed_delims.append(&mut unclosed_delims);\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_trait_item_(&mut self,\n+                         at_end: &mut bool,\n+                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n+        let lo = self.token.span;\n+        self.eat_bad_pub();\n+        let (name, node, generics) = if self.eat_keyword(kw::Type) {\n+            self.parse_trait_item_assoc_ty()?\n+        } else if self.is_const_item() {\n+            self.expect_keyword(kw::Const)?;\n+            let ident = self.parse_ident()?;\n+            self.expect(&token::Colon)?;\n+            let ty = self.parse_ty()?;\n+            let default = if self.eat(&token::Eq) {\n+                let expr = self.parse_expr()?;\n+                self.expect(&token::Semi)?;\n+                Some(expr)\n+            } else {\n+                self.expect(&token::Semi)?;\n+                None\n+            };\n+            (ident, TraitItemKind::Const(ty, default), ast::Generics::default())\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n+            // trait item macro.\n+            (Ident::invalid(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n+        } else {\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n+\n+            let decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n+                // This is somewhat dubious; We don't want to allow\n+                // argument names to be left off if there is a\n+                // definition...\n+\n+                // We don't allow argument names to be left off in edition 2018.\n+                let is_name_required = p.token.span.rust_2018();\n+                p.parse_arg_general(true, false, |_| is_name_required)\n+            })?;\n+            generics.where_clause = self.parse_where_clause()?;\n+\n+            let sig = ast::MethodSig {\n+                header: FnHeader {\n+                    unsafety,\n+                    constness,\n+                    abi,\n+                    asyncness,\n+                },\n+                decl,\n+            };\n+\n+            let body = match self.token.kind {\n+                token::Semi => {\n+                    self.bump();\n+                    *at_end = true;\n+                    debug!(\"parse_trait_methods(): parsing required method\");\n+                    None\n+                }\n+                token::OpenDelim(token::Brace) => {\n+                    debug!(\"parse_trait_methods(): parsing provided method\");\n+                    *at_end = true;\n+                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    attrs.extend(inner_attrs.iter().cloned());\n+                    Some(body)\n+                }\n+                token::Interpolated(ref nt) => {\n+                    match **nt {\n+                        token::NtBlock(..) => {\n+                            *at_end = true;\n+                            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                            attrs.extend(inner_attrs.iter().cloned());\n+                            Some(body)\n+                        }\n+                        _ => {\n+                            return self.expected_semi_or_open_brace();\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    return self.expected_semi_or_open_brace();\n+                }\n+            };\n+            (ident, ast::TraitItemKind::Method(sig, body), generics)\n+        };\n+\n+        Ok(TraitItem {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: name,\n+            attrs,\n+            generics,\n+            node,\n+            span: lo.to(self.prev_span),\n+            tokens: None,\n+        })\n+    }\n+\n+    /// Parses the following grammar:\n+    ///\n+    ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n+    fn parse_trait_item_assoc_ty(&mut self)\n+        -> PResult<'a, (Ident, TraitItemKind, ast::Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_generic_bounds(None)?\n+        } else {\n+            Vec::new()\n+        };\n+        generics.where_clause = self.parse_where_clause()?;\n+\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+        self.expect(&token::Semi)?;\n+\n+        Ok((ident, TraitItemKind::Type(bounds, default), generics))\n+    }\n+\n+    /// Parses a `UseTree`.\n+    ///\n+    /// ```\n+    /// USE_TREE = [`::`] `*` |\n+    ///            [`::`] `{` USE_TREE_LIST `}` |\n+    ///            PATH `::` `*` |\n+    ///            PATH `::` `{` USE_TREE_LIST `}` |\n+    ///            PATH [`as` IDENT]\n+    /// ```\n+    fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n+        let lo = self.token.span;\n+\n+        let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo() };\n+        let kind = if self.check(&token::OpenDelim(token::Brace)) ||\n+                      self.check(&token::BinOp(token::Star)) ||\n+                      self.is_import_coupler() {\n+            // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n+            let mod_sep_ctxt = self.token.span.ctxt();\n+            if self.eat(&token::ModSep) {\n+                prefix.segments.push(\n+                    PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n+                );\n+            }\n+\n+            if self.eat(&token::BinOp(token::Star)) {\n+                UseTreeKind::Glob\n+            } else {\n+                UseTreeKind::Nested(self.parse_use_tree_list()?)\n+            }\n+        } else {\n+            // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n+            prefix = self.parse_path(PathStyle::Mod)?;\n+\n+            if self.eat(&token::ModSep) {\n+                if self.eat(&token::BinOp(token::Star)) {\n+                    UseTreeKind::Glob\n+                } else {\n+                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n+                }\n+            } else {\n+                UseTreeKind::Simple(self.parse_rename()?, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID)\n+            }\n+        };\n+\n+        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n+    }\n+\n+    /// Parses a `UseTreeKind::Nested(list)`.\n+    ///\n+    /// ```\n+    /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n+    /// ```\n+    fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n+        self.parse_delim_comma_seq(token::Brace, |p| Ok((p.parse_use_tree()?, ast::DUMMY_NODE_ID)))\n+            .map(|(r, _)| r)\n+    }\n+\n+    fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n+        if self.eat_keyword(kw::As) {\n+            self.parse_ident_or_underscore().map(Some)\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n+        match self.token.kind {\n+            token::Ident(name, false) if name == kw::Underscore => {\n+                let span = self.token.span;\n+                self.bump();\n+                Ok(Ident::new(name, span))\n+            }\n+            _ => self.parse_ident(),\n+        }\n+    }\n+\n+    /// Parses `extern crate` links.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// extern crate foo;\n+    /// extern crate bar as foo;\n+    /// ```\n+    fn parse_item_extern_crate(\n+        &mut self,\n+        lo: Span,\n+        visibility: Visibility,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, P<Item>> {\n+        // Accept `extern crate name-like-this` for better diagnostics\n+        let orig_name = self.parse_crate_name_with_dashes()?;\n+        let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n+            (rename, Some(orig_name.name))\n+        } else {\n+            (orig_name, None)\n+        };\n+        self.expect(&token::Semi)?;\n+\n+        let span = lo.to(self.prev_span);\n+        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n+    }\n+\n+    fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n+        let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n+        let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n+                              in the code\";\n+        let mut ident = if self.token.is_keyword(kw::SelfLower) {\n+            self.parse_path_segment_ident()\n+        } else {\n+            self.parse_ident()\n+        }?;\n+        let mut idents = vec![];\n+        let mut replacement = vec![];\n+        let mut fixed_crate_name = false;\n+        // Accept `extern crate name-like-this` for better diagnostics\n+        let dash = token::BinOp(token::BinOpToken::Minus);\n+        if self.token == dash {  // Do not include `-` as part of the expected tokens list\n+            while self.eat(&dash) {\n+                fixed_crate_name = true;\n+                replacement.push((self.prev_span, \"_\".to_string()));\n+                idents.push(self.parse_ident()?);\n+            }\n+        }\n+        if fixed_crate_name {\n+            let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n+            let mut fixed_name = format!(\"{}\", ident.name);\n+            for part in idents {\n+                fixed_name.push_str(&format!(\"_{}\", part.name));\n+            }\n+            ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n+\n+            self.struct_span_err(fixed_name_sp, error_msg)\n+                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n+                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n+                .emit();\n+        }\n+        Ok(ident)\n+    }\n+\n+    /// Parses an item-position function declaration.\n+    fn parse_item_fn(\n+        &mut self,\n+        unsafety: Unsafety,\n+        asyncness: Spanned<IsAsync>,\n+        constness: Spanned<Constness>,\n+        abi: Abi\n+    ) -> PResult<'a, ItemInfo> {\n+        let (ident, mut generics) = self.parse_fn_header()?;\n+        let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n+        let decl = self.parse_fn_decl(allow_c_variadic)?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let header = FnHeader { unsafety, asyncness, constness, abi };\n+        Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n+    }\n+\n+    /// Parses the name and optional generic types of a function header.\n+    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, ast::Generics)> {\n+        let id = self.parse_ident()?;\n+        let generics = self.parse_generics()?;\n+        Ok((id, generics))\n+    }\n+\n+    /// Parses the argument list and result type of a function declaration.\n+    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n+        let (args, c_variadic) = self.parse_fn_args(true, allow_c_variadic)?;\n+        let ret_ty = self.parse_ret_ty(true)?;\n+\n+        Ok(P(FnDecl {\n+            inputs: args,\n+            output: ret_ty,\n+            c_variadic,\n+        }))\n+    }\n+\n+    /// Parses `extern` for foreign ABIs modules.\n+    ///\n+    /// `extern` is expected to have been\n+    /// consumed before calling this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// extern \"C\" {}\n+    /// extern {}\n+    /// ```\n+    fn parse_item_foreign_mod(\n+        &mut self,\n+        lo: Span,\n+        opt_abi: Option<Abi>,\n+        visibility: Visibility,\n+        mut attrs: Vec<Attribute>,\n+        extern_sp: Span,\n+    ) -> PResult<'a, P<Item>> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+\n+        let abi = opt_abi.unwrap_or(Abi::C);\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let mut foreign_items = vec![];\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            foreign_items.push(self.parse_foreign_item(extern_sp)?);\n+        }\n+\n+        let prev_span = self.prev_span;\n+        let m = ast::ForeignMod {\n+            abi,\n+            items: foreign_items\n+        };\n+        let invalid = Ident::invalid();\n+        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n+    }\n+\n+    /// Parses a foreign item.\n+    crate fn parse_foreign_item(&mut self, extern_sp: Span) -> PResult<'a, ForeignItem> {\n+        maybe_whole!(self, NtForeignItem, |ni| ni);\n+\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+        let visibility = self.parse_visibility(false)?;\n+\n+        // FOREIGN STATIC ITEM\n+        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n+        if self.check_keyword(kw::Static) || self.token.is_keyword(kw::Const) {\n+            if self.token.is_keyword(kw::Const) {\n+                self.diagnostic()\n+                    .struct_span_err(self.token.span, \"extern items cannot be `const`\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"try using a static value\",\n+                        \"static\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    ).emit();\n+            }\n+            self.bump(); // `static` or `const`\n+            return Ok(self.parse_item_foreign_static(visibility, lo, attrs)?);\n+        }\n+        // FOREIGN FUNCTION ITEM\n+        if self.check_keyword(kw::Fn) {\n+            return Ok(self.parse_item_foreign_fn(visibility, lo, attrs, extern_sp)?);\n+        }\n+        // FOREIGN TYPE ITEM\n+        if self.check_keyword(kw::Type) {\n+            return Ok(self.parse_item_foreign_type(visibility, lo, attrs)?);\n+        }\n+\n+        match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n+            Some(mac) => {\n+                Ok(\n+                    ForeignItem {\n+                        ident: Ident::invalid(),\n+                        span: lo.to(self.prev_span),\n+                        id: ast::DUMMY_NODE_ID,\n+                        attrs,\n+                        vis: visibility,\n+                        node: ForeignItemKind::Macro(mac),\n+                    }\n+                )\n+            }\n+            None => {\n+                if !attrs.is_empty()  {\n+                    self.expected_item_err(&attrs)?;\n+                }\n+\n+                self.unexpected()\n+            }\n+        }\n+    }\n+\n+    /// Parses a function declaration from a foreign module.\n+    fn parse_item_foreign_fn(\n+        &mut self,\n+        vis: ast::Visibility,\n+        lo: Span,\n+        attrs: Vec<Attribute>,\n+        extern_sp: Span,\n+    ) -> PResult<'a, ForeignItem> {\n+        self.expect_keyword(kw::Fn)?;\n+\n+        let (ident, mut generics) = self.parse_fn_header()?;\n+        let decl = self.parse_fn_decl(true)?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        let hi = self.token.span;\n+        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n+        Ok(ast::ForeignItem {\n+            ident,\n+            attrs,\n+            node: ForeignItemKind::Fn(decl, generics),\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            vis,\n+        })\n+    }\n+\n+    /// Parses a static item from a foreign module.\n+    /// Assumes that the `static` keyword is already parsed.\n+    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                                 -> PResult<'a, ForeignItem> {\n+        let mutbl = self.parse_mutability();\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        let hi = self.token.span;\n+        self.expect(&token::Semi)?;\n+        Ok(ForeignItem {\n+            ident,\n+            attrs,\n+            node: ForeignItemKind::Static(ty, mutbl),\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            vis,\n+        })\n+    }\n+\n+    /// Parses a type from a foreign module.\n+    fn parse_item_foreign_type(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                             -> PResult<'a, ForeignItem> {\n+        self.expect_keyword(kw::Type)?;\n+\n+        let ident = self.parse_ident()?;\n+        let hi = self.token.span;\n+        self.expect(&token::Semi)?;\n+        Ok(ast::ForeignItem {\n+            ident,\n+            attrs,\n+            node: ForeignItemKind::Ty,\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            vis\n+        })\n+    }\n+\n+    fn is_static_global(&mut self) -> bool {\n+        if self.check_keyword(kw::Static) {\n+            // Check if this could be a closure\n+            !self.look_ahead(1, |token| {\n+                if token.is_keyword(kw::Move) {\n+                    return true;\n+                }\n+                match token.kind {\n+                    token::BinOp(token::Or) | token::OrOr => true,\n+                    _ => false,\n+                }\n+            })\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n+        let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        self.expect(&token::Eq)?;\n+        let e = self.parse_expr()?;\n+        self.expect(&token::Semi)?;\n+        let item = match m {\n+            Some(m) => ItemKind::Static(ty, m, e),\n+            None => ItemKind::Const(ty, e),\n+        };\n+        Ok((id, item, None))\n+    }\n+\n+    /// Parses `type Foo = Bar;` or returns `None`\n+    /// without modifying the parser state.\n+    fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, ast::Generics)>> {\n+        // This parses the grammar:\n+        //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n+        if self.eat_keyword(kw::Type) {\n+            Some(self.parse_type_alias())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Parses a type alias or opaque type.\n+    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, AliasKind, ast::Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut tps = self.parse_generics()?;\n+        tps.where_clause = self.parse_where_clause()?;\n+        self.expect(&token::Eq)?;\n+        let alias = if self.check_keyword(kw::Impl) {\n+            self.bump();\n+            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            AliasKind::OpaqueTy(bounds)\n+        } else {\n+            let ty = self.parse_ty()?;\n+            AliasKind::Weak(ty)\n+        };\n+        self.expect(&token::Semi)?;\n+        Ok((ident, alias, tps))\n+    }\n+\n+    /// Parses an enum declaration.\n+    fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n+        let id = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+\n+        let enum_definition = self.parse_enum_def(&generics).map_err(|e| {\n+            self.recover_stmt();\n+            self.eat(&token::CloseDelim(token::Brace));\n+            e\n+        })?;\n+        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n+    }\n+\n+    /// Parses the part of an enum declaration following the `{`.\n+    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> PResult<'a, EnumDef> {\n+        let mut variants = Vec::new();\n+        while self.token != token::CloseDelim(token::Brace) {\n+            let variant_attrs = self.parse_outer_attributes()?;\n+            let vlo = self.token.span;\n+\n+            self.eat_bad_pub();\n+            let ident = self.parse_ident()?;\n+\n+            let struct_def = if self.check(&token::OpenDelim(token::Brace)) {\n+                // Parse a struct variant.\n+                let (fields, recovered) = self.parse_record_struct_body()?;\n+                VariantData::Struct(fields, recovered)\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                VariantData::Tuple(\n+                    self.parse_tuple_struct_body()?,\n+                    ast::DUMMY_NODE_ID,\n+                )\n+            } else {\n+                VariantData::Unit(ast::DUMMY_NODE_ID)\n+            };\n+\n+            let disr_expr = if self.eat(&token::Eq) {\n+                Some(AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: self.parse_expr()?,\n+                })\n+            } else {\n+                None\n+            };\n+\n+            let vr = ast::Variant_ {\n+                ident,\n+                id: ast::DUMMY_NODE_ID,\n+                attrs: variant_attrs,\n+                data: struct_def,\n+                disr_expr,\n+            };\n+            variants.push(respan(vlo.to(self.prev_span), vr));\n+\n+            if !self.eat(&token::Comma) {\n+                if self.token.is_ident() && !self.token.is_reserved_ident() {\n+                    let sp = self.sess.source_map().next_point(self.prev_span);\n+                    self.struct_span_err(sp, \"missing comma\")\n+                        .span_suggestion_short(\n+                            sp,\n+                            \"missing comma\",\n+                            \",\".to_owned(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        self.expect(&token::CloseDelim(token::Brace))?;\n+\n+        Ok(ast::EnumDef { variants })\n+    }\n+\n+    /// Parses `struct Foo { ... }`.\n+    fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n+        let class_name = self.parse_ident()?;\n+\n+        let mut generics = self.parse_generics()?;\n+\n+        // There is a special case worth noting here, as reported in issue #17904.\n+        // If we are parsing a tuple struct it is the case that the where clause\n+        // should follow the field list. Like so:\n+        //\n+        // struct Foo<T>(T) where T: Copy;\n+        //\n+        // If we are parsing a normal record-style struct it is the case\n+        // that the where clause comes before the body, and after the generics.\n+        // So if we look ahead and see a brace or a where-clause we begin\n+        // parsing a record style struct.\n+        //\n+        // Otherwise if we look ahead and see a paren we parse a tuple-style\n+        // struct.\n+\n+        let vdata = if self.token.is_keyword(kw::Where) {\n+            generics.where_clause = self.parse_where_clause()?;\n+            if self.eat(&token::Semi) {\n+                // If we see a: `struct Foo<T> where T: Copy;` style decl.\n+                VariantData::Unit(ast::DUMMY_NODE_ID)\n+            } else {\n+                // If we see: `struct Foo<T> where T: Copy { ... }`\n+                let (fields, recovered) = self.parse_record_struct_body()?;\n+                VariantData::Struct(fields, recovered)\n+            }\n+        // No `where` so: `struct Foo<T>;`\n+        } else if self.eat(&token::Semi) {\n+            VariantData::Unit(ast::DUMMY_NODE_ID)\n+        // Record-style struct definition\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let (fields, recovered) = self.parse_record_struct_body()?;\n+            VariantData::Struct(fields, recovered)\n+        // Tuple-style struct definition with optional where-clause.\n+        } else if self.token == token::OpenDelim(token::Paren) {\n+            let body = VariantData::Tuple(self.parse_tuple_struct_body()?, ast::DUMMY_NODE_ID);\n+            generics.where_clause = self.parse_where_clause()?;\n+            self.expect(&token::Semi)?;\n+            body\n+        } else {\n+            let token_str = self.this_token_descr();\n+            let mut err = self.fatal(&format!(\n+                \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n+                token_str\n+            ));\n+            err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n+            return Err(err);\n+        };\n+\n+        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n+    }\n+\n+    /// Parses `union Foo { ... }`.\n+    fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> {\n+        let class_name = self.parse_ident()?;\n+\n+        let mut generics = self.parse_generics()?;\n+\n+        let vdata = if self.token.is_keyword(kw::Where) {\n+            generics.where_clause = self.parse_where_clause()?;\n+            let (fields, recovered) = self.parse_record_struct_body()?;\n+            VariantData::Struct(fields, recovered)\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let (fields, recovered) = self.parse_record_struct_body()?;\n+            VariantData::Struct(fields, recovered)\n+        } else {\n+            let token_str = self.this_token_descr();\n+            let mut err = self.fatal(&format!(\n+                \"expected `where` or `{{` after union name, found {}\", token_str));\n+            err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n+            return Err(err);\n+        };\n+\n+        Ok((class_name, ItemKind::Union(vdata, generics), None))\n+    }\n+\n+    pub(super) fn is_union_item(&self) -> bool {\n+        self.token.is_keyword(kw::Union) &&\n+        self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+    }\n+\n+    fn parse_record_struct_body(\n+        &mut self,\n+    ) -> PResult<'a, (Vec<StructField>, /* recovered */ bool)> {\n+        let mut fields = Vec::new();\n+        let mut recovered = false;\n+        if self.eat(&token::OpenDelim(token::Brace)) {\n+            while self.token != token::CloseDelim(token::Brace) {\n+                let field = self.parse_struct_decl_field().map_err(|e| {\n+                    self.recover_stmt();\n+                    recovered = true;\n+                    e\n+                });\n+                match field {\n+                    Ok(field) => fields.push(field),\n+                    Err(mut err) => {\n+                        err.emit();\n+                    }\n+                }\n+            }\n+            self.eat(&token::CloseDelim(token::Brace));\n+        } else {\n+            let token_str = self.this_token_descr();\n+            let mut err = self.fatal(&format!(\n+                    \"expected `where`, or `{{` after struct name, found {}\", token_str));\n+            err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n+            return Err(err);\n+        }\n+\n+        Ok((fields, recovered))\n+    }\n+\n+    fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n+        // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n+        // Unit like structs are handled in parse_item_struct function\n+        self.parse_paren_comma_seq(|p| {\n+            let attrs = p.parse_outer_attributes()?;\n+            let lo = p.token.span;\n+            let vis = p.parse_visibility(true)?;\n+            let ty = p.parse_ty()?;\n+            Ok(StructField {\n+                span: lo.to(ty.span),\n+                vis,\n+                ident: None,\n+                id: ast::DUMMY_NODE_ID,\n+                ty,\n+                attrs,\n+            })\n+        }).map(|(r, _)| r)\n+    }\n+\n+    /// Parses an element of a struct declaration.\n+    fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+        let vis = self.parse_visibility(false)?;\n+        self.parse_single_struct_field(lo, vis, attrs)\n+    }\n+\n+    /// Parses a structure field declaration.\n+    fn parse_single_struct_field(&mut self,\n+                                     lo: Span,\n+                                     vis: Visibility,\n+                                     attrs: Vec<Attribute> )\n+                                     -> PResult<'a, StructField> {\n+        let mut seen_comma: bool = false;\n+        let a_var = self.parse_name_and_ty(lo, vis, attrs)?;\n+        if self.token == token::Comma {\n+            seen_comma = true;\n+        }\n+        match self.token.kind {\n+            token::Comma => {\n+                self.bump();\n+            }\n+            token::CloseDelim(token::Brace) => {}\n+            token::DocComment(_) => {\n+                let previous_span = self.prev_span;\n+                let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n+                self.bump(); // consume the doc comment\n+                let comma_after_doc_seen = self.eat(&token::Comma);\n+                // `seen_comma` is always false, because we are inside doc block\n+                // condition is here to make code more readable\n+                if seen_comma == false && comma_after_doc_seen == true {\n+                    seen_comma = true;\n+                }\n+                if comma_after_doc_seen || self.token == token::CloseDelim(token::Brace) {\n+                    err.emit();\n+                } else {\n+                    if seen_comma == false {\n+                        let sp = self.sess.source_map().next_point(previous_span);\n+                        err.span_suggestion(\n+                            sp,\n+                            \"missing comma here\",\n+                            \",\".into(),\n+                            Applicability::MachineApplicable\n+                        );\n+                    }\n+                    return Err(err);\n+                }\n+            }\n+            _ => {\n+                let sp = self.sess.source_map().next_point(self.prev_span);\n+                let mut err = self.struct_span_err(sp, &format!(\"expected `,`, or `}}`, found {}\",\n+                                                                self.this_token_descr()));\n+                if self.token.is_ident() {\n+                    // This is likely another field; emit the diagnostic and keep going\n+                    err.span_suggestion(\n+                        sp,\n+                        \"try adding a comma\",\n+                        \",\".into(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                } else {\n+                    return Err(err)\n+                }\n+            }\n+        }\n+        Ok(a_var)\n+    }\n+\n+    /// Parses a structure field.\n+    fn parse_name_and_ty(\n+        &mut self,\n+        lo: Span,\n+        vis: Visibility,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, StructField> {\n+        let name = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        Ok(StructField {\n+            span: lo.to(self.prev_span),\n+            ident: Some(name),\n+            vis,\n+            id: ast::DUMMY_NODE_ID,\n+            ty,\n+            attrs,\n+        })\n+    }\n+\n+    pub(super) fn eat_macro_def(\n+        &mut self,\n+        attrs: &[Attribute],\n+        vis: &Visibility,\n+        lo: Span\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let token_lo = self.token.span;\n+        let (ident, def) = if self.eat_keyword(kw::Macro) {\n+            let ident = self.parse_ident()?;\n+            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n+                match self.parse_token_tree() {\n+                    TokenTree::Delimited(_, _, tts) => tts,\n+                    _ => unreachable!(),\n+                }\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                let args = self.parse_token_tree();\n+                let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_token_tree()\n+                } else {\n+                    self.unexpected()?;\n+                    unreachable!()\n+                };\n+                TokenStream::new(vec![\n+                    args.into(),\n+                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n+                    body.into(),\n+                ])\n+            } else {\n+                self.unexpected()?;\n+                unreachable!()\n+            };\n+\n+            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+        } else if self.check_keyword(sym::macro_rules) &&\n+                  self.look_ahead(1, |t| *t == token::Not) &&\n+                  self.look_ahead(2, |t| t.is_ident()) {\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&vis.node, prev_span);\n+            self.bump();\n+            self.bump();\n+\n+            let ident = self.parse_ident()?;\n+            let (delim, tokens) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n+            }\n+\n+            (ident, ast::MacroDef { tokens, legacy: true })\n+        } else {\n+            return Ok(None);\n+        };\n+\n+        let span = lo.to(self.prev_span);\n+        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n+    }\n+\n+    fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n+        match *vis {\n+            VisibilityKind::Inherited => {}\n+            _ => {\n+                let mut err = if self.token.is_keyword(sym::macro_rules) {\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n+                    err.span_suggestion(\n+                        sp,\n+                        \"try exporting the macro\",\n+                        \"#[macro_export]\".to_owned(),\n+                        Applicability::MaybeIncorrect // speculative\n+                    );\n+                    err\n+                } else {\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n+                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n+                    err\n+                };\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    fn mk_item(&self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n+               attrs: Vec<Attribute>) -> P<Item> {\n+        P(Item {\n+            ident,\n+            attrs,\n+            id: ast::DUMMY_NODE_ID,\n+            node,\n+            vis,\n+            span,\n+            tokens: None,\n+        })\n+    }\n+}"}, {"sha": "58a7ffba948b3a0f81377e5067f751824f2243e6", "filename": "src/libsyntax/parse/parser/module.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,332 @@\n+use super::{Parser, PResult};\n+use super::item::ItemInfo;\n+\n+use crate::attr;\n+use crate::ast::{self, Ident, Attribute, ItemKind, Mod, Crate};\n+use crate::parse::{new_sub_parser_from_file, DirectoryOwnership};\n+use crate::parse::token::{self, TokenKind};\n+use crate::parse::diagnostics::{Error};\n+use crate::source_map::{SourceMap, Span, DUMMY_SP, FileName};\n+use crate::symbol::sym;\n+\n+use std::path::{self, Path, PathBuf};\n+\n+/// Information about the path to a module.\n+pub struct ModulePath {\n+    name: String,\n+    path_exists: bool,\n+    pub result: Result<ModulePathSuccess, Error>,\n+}\n+\n+pub struct ModulePathSuccess {\n+    pub path: PathBuf,\n+    pub directory_ownership: DirectoryOwnership,\n+    warn: bool,\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a source module as a crate. This is the main entry point for the parser.\n+    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n+        let lo = self.token.span;\n+        let krate = Ok(ast::Crate {\n+            attrs: self.parse_inner_attributes()?,\n+            module: self.parse_mod_items(&token::Eof, lo)?,\n+            span: lo.to(self.token.span),\n+        });\n+        krate\n+    }\n+\n+    /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n+    pub(super) fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n+        let (in_cfg, outer_attrs) = {\n+            let mut strip_unconfigured = crate::config::StripUnconfigured {\n+                sess: self.sess,\n+                features: None, // don't perform gated feature checking\n+            };\n+            let mut outer_attrs = outer_attrs.to_owned();\n+            strip_unconfigured.process_cfg_attrs(&mut outer_attrs);\n+            (!self.cfg_mods || strip_unconfigured.in_cfg(&outer_attrs), outer_attrs)\n+        };\n+\n+        let id_span = self.token.span;\n+        let id = self.parse_ident()?;\n+        if self.eat(&token::Semi) {\n+            if in_cfg && self.recurse_into_file_modules {\n+                // This mod is in an external file. Let's go get it!\n+                let ModulePathSuccess { path, directory_ownership, warn } =\n+                    self.submod_path(id, &outer_attrs, id_span)?;\n+                let (module, mut attrs) =\n+                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n+                // Record that we fetched the mod from an external file\n+                if warn {\n+                    let attr = attr::mk_attr_outer(\n+                        attr::mk_word_item(Ident::with_empty_ctxt(sym::warn_directory_ownership)));\n+                    attr::mark_known(&attr);\n+                    attrs.push(attr);\n+                }\n+                Ok((id, ItemKind::Mod(module), Some(attrs)))\n+            } else {\n+                let placeholder = ast::Mod {\n+                    inner: DUMMY_SP,\n+                    items: Vec::new(),\n+                    inline: false\n+                };\n+                Ok((id, ItemKind::Mod(placeholder), None))\n+            }\n+        } else {\n+            let old_directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n+\n+            self.expect(&token::OpenDelim(token::Brace))?;\n+            let mod_inner_lo = self.token.span;\n+            let attrs = self.parse_inner_attributes()?;\n+            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n+\n+            self.directory = old_directory;\n+            Ok((id, ItemKind::Mod(module), Some(attrs)))\n+        }\n+    }\n+\n+    /// Given a termination token, parses all of the items in a module.\n+    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n+        let mut items = vec![];\n+        while let Some(item) = self.parse_item()? {\n+            items.push(item);\n+            self.maybe_consume_incorrect_semicolon(&items);\n+        }\n+\n+        if !self.eat(term) {\n+            let token_str = self.this_token_descr();\n+            if !self.maybe_consume_incorrect_semicolon(&items) {\n+                let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n+                err.span_label(self.token.span, \"expected item\");\n+                return Err(err);\n+            }\n+        }\n+\n+        let hi = if self.token.span.is_dummy() {\n+            inner_lo\n+        } else {\n+            self.prev_span\n+        };\n+\n+        Ok(Mod {\n+            inner: inner_lo.to(hi),\n+            items,\n+            inline: true\n+        })\n+    }\n+\n+    fn submod_path(\n+        &mut self,\n+        id: ast::Ident,\n+        outer_attrs: &[Attribute],\n+        id_sp: Span\n+    ) -> PResult<'a, ModulePathSuccess> {\n+        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n+            return Ok(ModulePathSuccess {\n+                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n+                    // All `#[path]` files are treated as though they are a `mod.rs` file.\n+                    // This means that `mod foo;` declarations inside `#[path]`-included\n+                    // files are siblings,\n+                    //\n+                    // Note that this will produce weirdness when a file named `foo.rs` is\n+                    // `#[path]` included and contains a `mod foo;` declaration.\n+                    // If you encounter this, it's your own darn fault :P\n+                    Some(_) => DirectoryOwnership::Owned { relative: None },\n+                    _ => DirectoryOwnership::UnownedViaMod(true),\n+                },\n+                path,\n+                warn: false,\n+            });\n+        }\n+\n+        let relative = match self.directory.ownership {\n+            DirectoryOwnership::Owned { relative } => relative,\n+            DirectoryOwnership::UnownedViaBlock |\n+            DirectoryOwnership::UnownedViaMod(_) => None,\n+        };\n+        let paths = Parser::default_submod_path(\n+                        id, relative, &self.directory.path, self.sess.source_map());\n+\n+        match self.directory.ownership {\n+            DirectoryOwnership::Owned { .. } => {\n+                paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n+            },\n+            DirectoryOwnership::UnownedViaBlock => {\n+                let msg =\n+                    \"Cannot declare a non-inline module inside a block \\\n+                    unless it has a path attribute\";\n+                let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n+                if paths.path_exists {\n+                    let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\",\n+                                      paths.name);\n+                    err.span_note(id_sp, &msg);\n+                }\n+                Err(err)\n+            }\n+            DirectoryOwnership::UnownedViaMod(warn) => {\n+                if warn {\n+                    if let Ok(result) = paths.result {\n+                        return Ok(ModulePathSuccess { warn: true, ..result });\n+                    }\n+                }\n+                let mut err = self.diagnostic().struct_span_err(id_sp,\n+                    \"cannot declare a new module at this location\");\n+                if !id_sp.is_dummy() {\n+                    let src_path = self.sess.source_map().span_to_filename(id_sp);\n+                    if let FileName::Real(src_path) = src_path {\n+                        if let Some(stem) = src_path.file_stem() {\n+                            let mut dest_path = src_path.clone();\n+                            dest_path.set_file_name(stem);\n+                            dest_path.push(\"mod.rs\");\n+                            err.span_note(id_sp,\n+                                    &format!(\"maybe move this module `{}` to its own \\\n+                                                directory via `{}`\", src_path.display(),\n+                                            dest_path.display()));\n+                        }\n+                    }\n+                }\n+                if paths.path_exists {\n+                    err.span_note(id_sp,\n+                                  &format!(\"... or maybe `use` the module `{}` instead \\\n+                                            of possibly redeclaring it\",\n+                                           paths.name));\n+                }\n+                Err(err)\n+            }\n+        }\n+    }\n+\n+    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+        if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+            let s = s.as_str();\n+\n+            // On windows, the base path might have the form\n+            // `\\\\?\\foo\\bar` in which case it does not tolerate\n+            // mixed `/` and `\\` separators, so canonicalize\n+            // `/` to `\\`.\n+            #[cfg(windows)]\n+            let s = s.replace(\"/\", \"\\\\\");\n+            Some(dir_path.join(s))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns a path to a module.\n+    pub fn default_submod_path(\n+        id: ast::Ident,\n+        relative: Option<ast::Ident>,\n+        dir_path: &Path,\n+        source_map: &SourceMap) -> ModulePath\n+    {\n+        // If we're in a foo.rs file instead of a mod.rs file,\n+        // we need to look for submodules in\n+        // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n+        // `./<id>.rs` and `./<id>/mod.rs`.\n+        let relative_prefix_string;\n+        let relative_prefix = if let Some(ident) = relative {\n+            relative_prefix_string = format!(\"{}{}\", ident.as_str(), path::MAIN_SEPARATOR);\n+            &relative_prefix_string\n+        } else {\n+            \"\"\n+        };\n+\n+        let mod_name = id.to_string();\n+        let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n+        let secondary_path_str = format!(\"{}{}{}mod.rs\",\n+                                         relative_prefix, mod_name, path::MAIN_SEPARATOR);\n+        let default_path = dir_path.join(&default_path_str);\n+        let secondary_path = dir_path.join(&secondary_path_str);\n+        let default_exists = source_map.file_exists(&default_path);\n+        let secondary_exists = source_map.file_exists(&secondary_path);\n+\n+        let result = match (default_exists, secondary_exists) {\n+            (true, false) => Ok(ModulePathSuccess {\n+                path: default_path,\n+                directory_ownership: DirectoryOwnership::Owned {\n+                    relative: Some(id),\n+                },\n+                warn: false,\n+            }),\n+            (false, true) => Ok(ModulePathSuccess {\n+                path: secondary_path,\n+                directory_ownership: DirectoryOwnership::Owned {\n+                    relative: None,\n+                },\n+                warn: false,\n+            }),\n+            (false, false) => Err(Error::FileNotFoundForModule {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+                dir_path: dir_path.display().to_string(),\n+            }),\n+            (true, true) => Err(Error::DuplicatePaths {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+            }),\n+        };\n+\n+        ModulePath {\n+            name: mod_name,\n+            path_exists: default_exists || secondary_exists,\n+            result,\n+        }\n+    }\n+\n+    /// Reads a module from a source file.\n+    fn eval_src_mod(\n+        &mut self,\n+        path: PathBuf,\n+        directory_ownership: DirectoryOwnership,\n+        name: String,\n+        id_sp: Span,\n+    ) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+        let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n+        if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n+            let mut err = String::from(\"circular modules: \");\n+            let len = included_mod_stack.len();\n+            for p in &included_mod_stack[i.. len] {\n+                err.push_str(&p.to_string_lossy());\n+                err.push_str(\" -> \");\n+            }\n+            err.push_str(&path.to_string_lossy());\n+            return Err(self.span_fatal(id_sp, &err[..]));\n+        }\n+        included_mod_stack.push(path.clone());\n+        drop(included_mod_stack);\n+\n+        let mut p0 =\n+            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n+        p0.cfg_mods = self.cfg_mods;\n+        let mod_inner_lo = p0.token.span;\n+        let mod_attrs = p0.parse_inner_attributes()?;\n+        let mut m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n+        m0.inline = false;\n+        self.sess.included_mod_stack.borrow_mut().pop();\n+        Ok((m0, mod_attrs))\n+    }\n+\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n+        if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+            self.directory.path.to_mut().push(&path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n+        } else {\n+            // We have to push on the current module name in the case of relative\n+            // paths in order to ensure that any additional module paths from inline\n+            // `mod x { ... }` come after the relative extension.\n+            //\n+            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+            if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n+                if let Some(ident) = relative.take() { // remove the relative offset\n+                    self.directory.path.to_mut().push(ident.as_str());\n+                }\n+            }\n+            self.directory.path.to_mut().push(&id.as_str());\n+        }\n+    }\n+}"}, {"sha": "5cc428a4df1dec91d40d64d71293857839f3947f", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "added", "additions": 634, "deletions": 0, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,634 @@\n+use super::{Parser, PResult, PathStyle};\n+\n+use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n+use crate::ptr::P;\n+use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac_};\n+use crate::ast::{BindingMode, Ident, Mutability, Expr, ExprKind};\n+use crate::parse::token::{self};\n+use crate::print::pprust;\n+use crate::source_map::{respan, Span, Spanned};\n+use crate::symbol::kw;\n+use crate::ThinVec;\n+\n+use errors::{Applicability, DiagnosticBuilder};\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a pattern.\n+    pub fn parse_pat(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n+        self.parse_pat_with_range_pat(true, expected)\n+    }\n+\n+    /// Parses patterns, separated by '|' s.\n+    pub(super) fn parse_pats(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n+        // Allow a '|' before the pats (RFC 1925 + RFC 2530)\n+        self.eat(&token::BinOp(token::Or));\n+\n+        let mut pats = Vec::new();\n+        loop {\n+            pats.push(self.parse_top_level_pat()?);\n+\n+            if self.token == token::OrOr {\n+                self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"use a single `|` to specify multiple patterns\",\n+                        \"|\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n+                self.bump();\n+            } else if self.eat(&token::BinOp(token::Or)) {\n+                // This is a No-op. Continue the loop to parse the next\n+                // pattern.\n+            } else {\n+                return Ok(pats);\n+            }\n+        };\n+    }\n+\n+    /// A wrapper around `parse_pat` with some special error handling for the\n+    /// \"top-level\" patterns in a match arm, `for` loop, `let`, &c. (in contrast\n+    /// to subpatterns within such).\n+    pub(super) fn parse_top_level_pat(&mut self) -> PResult<'a, P<Pat>> {\n+        let pat = self.parse_pat(None)?;\n+        if self.token == token::Comma {\n+            // An unexpected comma after a top-level pattern is a clue that the\n+            // user (perhaps more accustomed to some other language) forgot the\n+            // parentheses in what should have been a tuple pattern; return a\n+            // suggestion-enhanced error here rather than choking on the comma\n+            // later.\n+            let comma_span = self.token.span;\n+            self.bump();\n+            if let Err(mut err) = self.skip_pat_list() {\n+                // We didn't expect this to work anyway; we just wanted\n+                // to advance to the end of the comma-sequence so we know\n+                // the span to suggest parenthesizing\n+                err.cancel();\n+            }\n+            let seq_span = pat.span.to(self.prev_span);\n+            let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n+            if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n+                err.span_suggestion(\n+                    seq_span,\n+                    \"try adding parentheses to match on a tuple..\",\n+                    format!(\"({})\", seq_snippet),\n+                    Applicability::MachineApplicable\n+                ).span_suggestion(\n+                    seq_span,\n+                    \"..or a vertical bar to match on multiple alternatives\",\n+                    format!(\"{}\", seq_snippet.replace(\",\", \" |\")),\n+                    Applicability::MachineApplicable\n+                );\n+            }\n+            return Err(err);\n+        }\n+        Ok(pat)\n+    }\n+\n+    /// Parse and throw away a parentesized comma separated\n+    /// sequence of patterns until `)` is reached.\n+    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(())\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n+    /// allowed).\n+    fn parse_pat_with_range_pat(\n+        &mut self,\n+        allow_range_pat: bool,\n+        expected: Option<&'static str>,\n+    ) -> PResult<'a, P<Pat>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n+        maybe_whole!(self, NtPat, |x| x);\n+\n+        let lo = self.token.span;\n+        let pat;\n+        match self.token.kind {\n+            token::BinOp(token::And) | token::AndAnd => {\n+                // Parse &pat / &mut pat\n+                self.expect_and()?;\n+                let mutbl = self.parse_mutability();\n+                if let token::Lifetime(name) = self.token.kind {\n+                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n+                    err.span_label(self.token.span, \"unexpected lifetime\");\n+                    return Err(err);\n+                }\n+                let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+                pat = PatKind::Ref(subpat, mutbl);\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                // Parse a tuple or parenthesis pattern.\n+                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+                // Here, `(pat,)` is a tuple pattern.\n+                // For backward compatibility, `(..)` is a tuple pattern as well.\n+                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n+                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+                } else {\n+                    PatKind::Tuple(fields)\n+                };\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                // Parse `[pat, pat,...]` as a slice pattern.\n+                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n+                pat = PatKind::Slice(slice);\n+            }\n+            token::DotDot => {\n+                self.bump();\n+                pat = if self.is_pat_range_end_start() {\n+                    // Parse `..42` for recovery.\n+                    self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n+                } else {\n+                    // A rest pattern `..`.\n+                    PatKind::Rest\n+                };\n+            }\n+            token::DotDotEq => {\n+                // Parse `..=42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+            }\n+            token::DotDotDot => {\n+                // Parse `...42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n+            }\n+            // At this point, token != &, &&, (, [\n+            _ => if self.eat_keyword(kw::Underscore) {\n+                // Parse _\n+                pat = PatKind::Wild;\n+            } else if self.eat_keyword(kw::Mut) {\n+                // Parse mut ident @ pat / mut ref ident @ pat\n+                let mutref_span = self.prev_span.to(self.token.span);\n+                let binding_mode = if self.eat_keyword(kw::Ref) {\n+                    self.diagnostic()\n+                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n+                        .span_suggestion(\n+                            mutref_span,\n+                            \"try switching the order\",\n+                            \"ref mut\".into(),\n+                            Applicability::MachineApplicable\n+                        ).emit();\n+                    BindingMode::ByRef(Mutability::Mutable)\n+                } else {\n+                    BindingMode::ByValue(Mutability::Mutable)\n+                };\n+                pat = self.parse_pat_ident(binding_mode)?;\n+            } else if self.eat_keyword(kw::Ref) {\n+                // Parse ref ident @ pat / ref mut ident @ pat\n+                let mutbl = self.parse_mutability();\n+                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n+            } else if self.eat_keyword(kw::Box) {\n+                // Parse box pat\n+                let subpat = self.parse_pat_with_range_pat(false, None)?;\n+                pat = PatKind::Box(subpat);\n+            } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n+                      self.parse_as_ident() {\n+                // Parse ident @ pat\n+                // This can give false positives and parse nullary enums,\n+                // they are dealt with later in resolve\n+                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                pat = self.parse_pat_ident(binding_mode)?;\n+            } else if self.token.is_path_start() {\n+                // Parse pattern starting with a path\n+                let (qself, path) = if self.eat_lt() {\n+                    // Parse a qualified path\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                    (Some(qself), path)\n+                } else {\n+                    // Parse an unqualified path\n+                    (None, self.parse_path(PathStyle::Expr)?)\n+                };\n+                match self.token.kind {\n+                    token::Not if qself.is_none() => {\n+                        // Parse macro invocation\n+                        self.bump();\n+                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        let mac = respan(lo.to(self.prev_span), Mac_ {\n+                            path,\n+                            tts,\n+                            delim,\n+                            prior_type_ascription: self.last_type_ascription,\n+                        });\n+                        pat = PatKind::Mac(mac);\n+                    }\n+                    token::DotDotDot | token::DotDotEq | token::DotDot => {\n+                        let (end_kind, form) = match self.token.kind {\n+                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n+                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n+                                         (checked above)\"),\n+                        };\n+                        let op_span = self.token.span;\n+                        // Parse range\n+                        let span = lo.to(self.prev_span);\n+                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+                        self.bump();\n+                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        if qself.is_some() {\n+                            let msg = \"unexpected `{` after qualified path\";\n+                            let mut err = self.fatal(msg);\n+                            err.span_label(self.token.span, msg);\n+                            return Err(err);\n+                        }\n+                        // Parse struct pattern\n+                        self.bump();\n+                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+                            e.emit();\n+                            self.recover_stmt();\n+                            (vec![], true)\n+                        });\n+                        self.bump();\n+                        pat = PatKind::Struct(path, fields, etc);\n+                    }\n+                    token::OpenDelim(token::Paren) => {\n+                        if qself.is_some() {\n+                            let msg = \"unexpected `(` after qualified path\";\n+                            let mut err = self.fatal(msg);\n+                            err.span_label(self.token.span, msg);\n+                            return Err(err);\n+                        }\n+                        // Parse tuple struct or enum pattern\n+                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+                        pat = PatKind::TupleStruct(path, fields)\n+                    }\n+                    _ => pat = PatKind::Path(qself, path),\n+                }\n+            } else {\n+                // Try to parse everything else as literal with optional minus\n+                match self.parse_literal_maybe_minus() {\n+                    Ok(begin) => {\n+                        let op_span = self.token.span;\n+                        if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n+                                self.check(&token::DotDotDot) {\n+                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n+                            } else if self.eat(&token::DotDotEq) {\n+                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n+                            } else if self.eat(&token::DotDot) {\n+                                (RangeEnd::Excluded, \"..\")\n+                            } else {\n+                                panic!(\"impossible case: we already matched \\\n+                                        on a range-operator token\")\n+                            };\n+                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n+                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n+                        } else {\n+                            pat = PatKind::Lit(begin);\n+                        }\n+                    }\n+                    Err(mut err) => {\n+                        self.cancel(&mut err);\n+                        let expected = expected.unwrap_or(\"pattern\");\n+                        let msg = format!(\n+                            \"expected {}, found {}\",\n+                            expected,\n+                            self.this_token_descr(),\n+                        );\n+                        let mut err = self.fatal(&msg);\n+                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n+                        let sp = self.sess.source_map().start_point(self.token.span);\n+                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+                        }\n+                        return Err(err);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let pat = self.mk_pat(lo.to(self.prev_span), pat);\n+        let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n+\n+        if !allow_range_pat {\n+            match pat.node {\n+                PatKind::Range(\n+                    _, _, Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n+                ) => {},\n+                PatKind::Range(..) => {\n+                    let mut err = self.struct_span_err(\n+                        pat.span,\n+                        \"the range pattern here has ambiguous interpretation\",\n+                    );\n+                    err.span_suggestion(\n+                        pat.span,\n+                        \"add parentheses to clarify the precedence\",\n+                        format!(\"({})\", pprust::pat_to_string(&pat)),\n+                        // \"ambiguous interpretation\" implies that we have to be guessing\n+                        Applicability::MaybeIncorrect\n+                    );\n+                    return Err(err);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        Ok(pat)\n+    }\n+\n+    // Helper function to decide whether to parse as ident binding\n+    // or to try to do something more complex like range patterns.\n+    fn parse_as_ident(&mut self) -> bool {\n+        self.look_ahead(1, |t| match t.kind {\n+            token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n+            token::DotDotDot | token::DotDotEq | token::DotDot |\n+            token::ModSep | token::Not => false,\n+            _ => true,\n+        })\n+    }\n+\n+    /// Is the current token suitable as the start of a range patterns end?\n+    fn is_pat_range_end_start(&self) -> bool {\n+        self.token.is_path_start() // e.g. `MY_CONST`;\n+            || self.token == token::Dot // e.g. `.5` for recovery;\n+            || self.token.can_begin_literal_or_bool() // e.g. `42`.\n+            || self.token.is_whole_expr()\n+    }\n+\n+    /// Parse a range-to pattern, e.g. `..X` and `..=X` for recovery.\n+    fn parse_pat_range_to(&mut self, re: RangeEnd, form: &str) -> PResult<'a, PatKind> {\n+        let lo = self.prev_span;\n+        let end = self.parse_pat_range_end()?;\n+        let range_span = lo.to(end.span);\n+        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n+\n+        self.diagnostic()\n+            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n+            .span_suggestion(\n+                range_span,\n+                \"try using the minimum value for the type\",\n+                format!(\"MIN{}{}\", form, pprust::expr_to_string(&end)),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n+\n+        Ok(PatKind::Range(begin, end, respan(lo, re)))\n+    }\n+\n+    /// Parse the end of a `X..Y`, `X..=Y`, or `X...Y` range pattern  or recover\n+    /// if that end is missing treating it as `X..`, `X..=`, or `X...` respectively.\n+    fn parse_pat_range_end_opt(&mut self, begin: &Expr, form: &str) -> PResult<'a, P<Expr>> {\n+        if self.is_pat_range_end_start() {\n+            // Parsing e.g. `X..=Y`.\n+            self.parse_pat_range_end()\n+        } else {\n+            // Parsing e.g. `X..`.\n+            let range_span = begin.span.to(self.prev_span);\n+\n+            self.diagnostic()\n+                .struct_span_err(\n+                    range_span,\n+                    &format!(\"`X{}` range patterns are not supported\", form),\n+                )\n+                .span_suggestion(\n+                    range_span,\n+                    \"try using the maximum value for the type\",\n+                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n+                    Applicability::HasPlaceholders,\n+                )\n+                .emit();\n+\n+            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n+        }\n+    }\n+\n+    fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n+        if self.token.is_path_start() {\n+            let lo = self.token.span;\n+            let (qself, path) = if self.eat_lt() {\n+                // Parse a qualified path\n+                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                (Some(qself), path)\n+            } else {\n+                // Parse an unqualified path\n+                (None, self.parse_path(PathStyle::Expr)?)\n+            };\n+            let hi = self.prev_span;\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n+        } else {\n+            self.parse_literal_maybe_minus()\n+        }\n+    }\n+\n+    /// Parses `ident` or `ident @ pat`.\n+    /// used by the copy foo and ref foo patterns to give a good\n+    /// error message when parsing mistakes like `ref foo(a, b)`.\n+    fn parse_pat_ident(&mut self,\n+                       binding_mode: ast::BindingMode)\n+                       -> PResult<'a, PatKind> {\n+        let ident = self.parse_ident()?;\n+        let sub = if self.eat(&token::At) {\n+            Some(self.parse_pat(Some(\"binding pattern\"))?)\n+        } else {\n+            None\n+        };\n+\n+        // just to be friendly, if they write something like\n+        //   ref Some(i)\n+        // we end up here with ( as the current token.  This shortly\n+        // leads to a parse error.  Note that if there is no explicit\n+        // binding mode then we do not end up here, because the lookahead\n+        // will direct us over to parse_enum_variant()\n+        if self.token == token::OpenDelim(token::Paren) {\n+            return Err(self.span_fatal(\n+                self.prev_span,\n+                \"expected identifier, found enum pattern\"))\n+        }\n+\n+        Ok(PatKind::Ident(binding_mode, ident, sub))\n+    }\n+\n+    /// Parses the fields of a struct-like pattern.\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<Spanned<FieldPat>>, bool)> {\n+        let mut fields = Vec::new();\n+        let mut etc = false;\n+        let mut ate_comma = true;\n+        let mut delayed_err: Option<DiagnosticBuilder<'a>> = None;\n+        let mut etc_span = None;\n+\n+        while self.token != token::CloseDelim(token::Brace) {\n+            let attrs = match self.parse_outer_attributes() {\n+                Ok(attrs) => attrs,\n+                Err(err) => {\n+                    if let Some(mut delayed) = delayed_err {\n+                        delayed.emit();\n+                    }\n+                    return Err(err);\n+                },\n+            };\n+            let lo = self.token.span;\n+\n+            // check that a comma comes after every field\n+            if !ate_comma {\n+                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n+                if let Some(mut delayed) = delayed_err {\n+                    delayed.emit();\n+                }\n+                return Err(err);\n+            }\n+            ate_comma = false;\n+\n+            if self.check(&token::DotDot) || self.token == token::DotDotDot {\n+                etc = true;\n+                let mut etc_sp = self.token.span;\n+\n+                if self.token == token::DotDotDot { // Issue #46718\n+                    // Accept `...` as if it were `..` to avoid further errors\n+                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+                        .span_suggestion(\n+                            self.token.span,\n+                            \"to omit remaining fields, use one fewer `.`\",\n+                            \"..\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        )\n+                        .emit();\n+                }\n+                self.bump();  // `..` || `...`\n+\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    etc_span = Some(etc_sp);\n+                    break;\n+                }\n+                let token_str = self.this_token_descr();\n+                let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n+\n+                err.span_label(self.token.span, \"expected `}`\");\n+                let mut comma_sp = None;\n+                if self.token == token::Comma { // Issue #49257\n+                    let nw_span = self.sess.source_map().span_until_non_whitespace(self.token.span);\n+                    etc_sp = etc_sp.to(nw_span);\n+                    err.span_label(etc_sp,\n+                                   \"`..` must be at the end and cannot have a trailing comma\");\n+                    comma_sp = Some(self.token.span);\n+                    self.bump();\n+                    ate_comma = true;\n+                }\n+\n+                etc_span = Some(etc_sp.until(self.token.span));\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    // If the struct looks otherwise well formed, recover and continue.\n+                    if let Some(sp) = comma_sp {\n+                        err.span_suggestion_short(\n+                            sp,\n+                            \"remove this comma\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    err.emit();\n+                    break;\n+                } else if self.token.is_ident() && ate_comma {\n+                    // Accept fields coming after `..,`.\n+                    // This way we avoid \"pattern missing fields\" errors afterwards.\n+                    // We delay this error until the end in order to have a span for a\n+                    // suggested fix.\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                        return Err(err);\n+                    } else {\n+                        delayed_err = Some(err);\n+                    }\n+                } else {\n+                    if let Some(mut err) = delayed_err {\n+                        err.emit();\n+                    }\n+                    return Err(err);\n+                }\n+            }\n+\n+            fields.push(match self.parse_pat_field(lo, attrs) {\n+                Ok(field) => field,\n+                Err(err) => {\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                    }\n+                    return Err(err);\n+                }\n+            });\n+            ate_comma = self.eat(&token::Comma);\n+        }\n+\n+        if let Some(mut err) = delayed_err {\n+            if let Some(etc_span) = etc_span {\n+                err.multipart_suggestion(\n+                    \"move the `..` to the end of the field list\",\n+                    vec![\n+                        (etc_span, String::new()),\n+                        (self.token.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n+        }\n+        return Ok((fields, etc));\n+    }\n+\n+    fn parse_pat_field(\n+        &mut self,\n+        lo: Span,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, Spanned<FieldPat>> {\n+        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n+        let hi;\n+        let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n+            // Parsing a pattern of the form \"fieldname: pat\"\n+            let fieldname = self.parse_field_name()?;\n+            self.bump();\n+            let pat = self.parse_pat(None)?;\n+            hi = pat.span;\n+            (pat, fieldname, false)\n+        } else {\n+            // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n+            let is_box = self.eat_keyword(kw::Box);\n+            let boxed_span = self.token.span;\n+            let is_ref = self.eat_keyword(kw::Ref);\n+            let is_mut = self.eat_keyword(kw::Mut);\n+            let fieldname = self.parse_ident()?;\n+            hi = self.prev_span;\n+\n+            let bind_type = match (is_ref, is_mut) {\n+                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n+                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n+                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n+                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n+            };\n+\n+            let fieldpat = self.mk_pat_ident(boxed_span.to(hi), bind_type, fieldname);\n+            let subpat = if is_box {\n+                self.mk_pat(lo.to(hi), PatKind::Box(fieldpat))\n+            } else {\n+                fieldpat\n+            };\n+            (subpat, fieldname, true)\n+        };\n+\n+        Ok(Spanned {\n+            span: lo.to(hi),\n+            node: FieldPat {\n+                ident: fieldname,\n+                pat: subpat,\n+                is_shorthand,\n+                attrs: attrs.into(),\n+           }\n+        })\n+    }\n+\n+    pub(super) fn mk_pat_ident(&self, span: Span, bm: BindingMode, ident: Ident) -> P<Pat> {\n+        self.mk_pat(span, PatKind::Ident(bm, ident, None))\n+    }\n+\n+    fn mk_pat(&self, span: Span, node: PatKind) -> P<Pat> {\n+        P(Pat { node, span, id: ast::DUMMY_NODE_ID })\n+    }\n+}"}, {"sha": "3eb4d45045a9e00b32338d7f8050410d909b1236", "filename": "src/libsyntax/parse/parser/path.rs", "status": "added", "additions": 474, "deletions": 0, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,474 @@\n+use super::{Parser, PResult, TokenType};\n+\n+use crate::{maybe_whole, ThinVec};\n+use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n+use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use crate::parse::token::{self, Token};\n+use crate::source_map::{Span, BytePos};\n+use crate::symbol::kw;\n+\n+use std::mem;\n+use log::debug;\n+use errors::{Applicability};\n+\n+/// Specifies how to parse a path.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum PathStyle {\n+    /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n+    /// with something else. For example, in expressions `segment < ....` can be interpreted\n+    /// as a comparison and `segment ( ....` can be interpreted as a function call.\n+    /// In all such contexts the non-path interpretation is preferred by default for practical\n+    /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n+    /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n+    Expr,\n+    /// In other contexts, notably in types, no ambiguity exists and paths can be written\n+    /// without the disambiguator, e.g., `x<y>` - unambiguously a path.\n+    /// Paths with disambiguators are still accepted, `x::<Y>` - unambiguously a path too.\n+    Type,\n+    /// A path with generic arguments disallowed, e.g., `foo::bar::Baz`, used in imports,\n+    /// visibilities or attributes.\n+    /// Technically, this variant is unnecessary and e.g., `Expr` can be used instead\n+    /// (paths in \"mod\" contexts have to be checked later for absence of generic arguments\n+    /// anyway, due to macros), but it is used to avoid weird suggestions about expected\n+    /// tokens when something goes wrong.\n+    Mod,\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a qualified path.\n+    /// Assumes that the leading `<` has been parsed already.\n+    ///\n+    /// `qualified_path = <type [as trait_ref]>::path`\n+    ///\n+    /// # Examples\n+    /// `<T>::default`\n+    /// `<T as U>::a`\n+    /// `<T as U>::F::a<S>` (without disambiguator)\n+    /// `<T as U>::F::a::<S>` (with disambiguator)\n+    pub(super) fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, Path)> {\n+        let lo = self.prev_span;\n+        let ty = self.parse_ty()?;\n+\n+        // `path` will contain the prefix of the path up to the `>`,\n+        // if any (e.g., `U` in the `<T as U>::*` examples\n+        // above). `path_span` has the span of that path, or an empty\n+        // span in the case of something like `<T>::Bar`.\n+        let (mut path, path_span);\n+        if self.eat_keyword(kw::As) {\n+            let path_lo = self.token.span;\n+            path = self.parse_path(PathStyle::Type)?;\n+            path_span = path_lo.to(self.prev_span);\n+        } else {\n+            path_span = self.token.span.to(self.token.span);\n+            path = ast::Path { segments: Vec::new(), span: path_span };\n+        }\n+\n+        // See doc comment for `unmatched_angle_bracket_count`.\n+        self.expect(&token::Gt)?;\n+        if self.unmatched_angle_bracket_count > 0 {\n+            self.unmatched_angle_bracket_count -= 1;\n+            debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+        }\n+\n+        self.expect(&token::ModSep)?;\n+\n+        let qself = QSelf { ty, path_span, position: path.segments.len() };\n+        self.parse_path_segments(&mut path.segments, style)?;\n+\n+        Ok((qself, Path { segments: path.segments, span: lo.to(self.prev_span) }))\n+    }\n+\n+    /// Parses simple paths.\n+    ///\n+    /// `path = [::] segment+`\n+    /// `segment = ident | ident[::]<args> | ident[::](args) [-> type]`\n+    ///\n+    /// # Examples\n+    /// `a::b::C<D>` (without disambiguator)\n+    /// `a::b::C::<D>` (with disambiguator)\n+    /// `Fn(Args)` (without disambiguator)\n+    /// `Fn::(Args)` (with disambiguator)\n+    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+        maybe_whole!(self, NtPath, |path| {\n+            if style == PathStyle::Mod &&\n+               path.segments.iter().any(|segment| segment.args.is_some()) {\n+                self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n+            }\n+            path\n+        });\n+\n+        let lo = self.meta_var_span.unwrap_or(self.token.span);\n+        let mut segments = Vec::new();\n+        let mod_sep_ctxt = self.token.span.ctxt();\n+        if self.eat(&token::ModSep) {\n+            segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n+        }\n+        self.parse_path_segments(&mut segments, style)?;\n+\n+        Ok(Path { segments, span: lo.to(self.prev_span) })\n+    }\n+\n+    /// Like `parse_path`, but also supports parsing `Word` meta items into paths for\n+    /// backwards-compatibility. This is used when parsing derive macro paths in `#[derive]`\n+    /// attributes.\n+    pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+        let meta_ident = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtMeta(ref meta) => match meta.node {\n+                    ast::MetaItemKind::Word => Some(meta.path.clone()),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        if let Some(path) = meta_ident {\n+            self.bump();\n+            return Ok(path);\n+        }\n+        self.parse_path(style)\n+    }\n+\n+    crate fn parse_path_segments(&mut self,\n+                           segments: &mut Vec<PathSegment>,\n+                           style: PathStyle)\n+                           -> PResult<'a, ()> {\n+        loop {\n+            let segment = self.parse_path_segment(style)?;\n+            if style == PathStyle::Expr {\n+                // In order to check for trailing angle brackets, we must have finished\n+                // recursing (`parse_path_segment` can indirectly call this function),\n+                // that is, the next token must be the highlighted part of the below example:\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                      ^ here\n+                //\n+                // As opposed to the below highlight (if we had only finished the first\n+                // recursion):\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                     ^ here\n+                //\n+                // `PathStyle::Expr` is only provided at the root invocation and never in\n+                // `parse_path_segment` to recurse and therefore can be checked to maintain\n+                // this invariant.\n+                self.check_trailing_angle_brackets(&segment, token::ModSep);\n+            }\n+            segments.push(segment);\n+\n+            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+                return Ok(());\n+            }\n+        }\n+    }\n+\n+    pub(super) fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n+        let ident = self.parse_path_segment_ident()?;\n+\n+        let is_args_start = |token: &Token| match token.kind {\n+            token::Lt | token::BinOp(token::Shl) | token::OpenDelim(token::Paren)\n+            | token::LArrow => true,\n+            _ => false,\n+        };\n+        let check_args_start = |this: &mut Self| {\n+            this.expected_tokens.extend_from_slice(\n+                &[TokenType::Token(token::Lt), TokenType::Token(token::OpenDelim(token::Paren))]\n+            );\n+            is_args_start(&this.token)\n+        };\n+\n+        Ok(if style == PathStyle::Type && check_args_start(self) ||\n+              style != PathStyle::Mod && self.check(&token::ModSep)\n+                                      && self.look_ahead(1, |t| is_args_start(t)) {\n+            // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n+            // it isn't, then we reset the unmatched angle bracket count as we're about to start\n+            // parsing a new path.\n+            if style == PathStyle::Expr {\n+                self.unmatched_angle_bracket_count = 0;\n+                self.max_angle_bracket_count = 0;\n+            }\n+\n+            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n+            self.eat(&token::ModSep);\n+            let lo = self.token.span;\n+            let args = if self.eat_lt() {\n+                // `<'a, T, A = U>`\n+                let (args, constraints) =\n+                    self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n+                self.expect_gt()?;\n+                let span = lo.to(self.prev_span);\n+                AngleBracketedArgs { args, constraints, span }.into()\n+            } else {\n+                // `(T, U) -> R`\n+                let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n+                let span = lo.to(self.prev_span);\n+                let output = if self.eat(&token::RArrow) {\n+                    Some(self.parse_ty_common(false, false, false)?)\n+                } else {\n+                    None\n+                };\n+                ParenthesizedArgs { inputs, output, span }.into()\n+            };\n+\n+            PathSegment { ident, args, id: ast::DUMMY_NODE_ID }\n+        } else {\n+            // Generic arguments are not found.\n+            PathSegment::from_ident(ident)\n+        })\n+    }\n+\n+    pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n+        match self.token.kind {\n+            token::Ident(name, _) if name.is_path_segment_keyword() => {\n+                let span = self.token.span;\n+                self.bump();\n+                Ok(Ident::new(name, span))\n+            }\n+            _ => self.parse_ident(),\n+        }\n+    }\n+\n+    /// Parses generic args (within a path segment) with recovery for extra leading angle brackets.\n+    /// For the purposes of understanding the parsing logic of generic arguments, this function\n+    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n+    /// had the correct amount of leading angle brackets.\n+    ///\n+    /// ```ignore (diagnostics)\n+    /// bar::<<<<T as Foo>::Output>();\n+    ///      ^^ help: remove extra angle brackets\n+    /// ```\n+    fn parse_generic_args_with_leaning_angle_bracket_recovery(\n+        &mut self,\n+        style: PathStyle,\n+        lo: Span,\n+    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+        // We need to detect whether there are extra leading left angle brackets and produce an\n+        // appropriate error and suggestion. This cannot be implemented by looking ahead at\n+        // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n+        // then there won't be matching `>` tokens to find.\n+        //\n+        // To explain how this detection works, consider the following example:\n+        //\n+        // ```ignore (diagnostics)\n+        // bar::<<<<T as Foo>::Output>();\n+        //      ^^ help: remove extra angle brackets\n+        // ```\n+        //\n+        // Parsing of the left angle brackets starts in this function. We start by parsing the\n+        // `<` token (incrementing the counter of unmatched angle brackets on `Parser` via\n+        // `eat_lt`):\n+        //\n+        // *Upcoming tokens:* `<<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 1\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // This has the effect of recursing as this function is called if a `<` character\n+        // is found within the expected generic arguments:\n+        //\n+        // *Upcoming tokens:* `<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // Eventually we will have recursed until having consumed all of the `<` tokens and\n+        // this will be reflected in the count:\n+        //\n+        // *Upcoming tokens:* `T as Foo>::Output>;`\n+        // *Unmatched count:* 4\n+        // `parse_path_segment` calls deep:* 3\n+        //\n+        // The parser will continue until reaching the first `>` - this will decrement the\n+        // unmatched angle bracket count and return to the parent invocation of this function\n+        // having succeeded in parsing:\n+        //\n+        // *Upcoming tokens:* `::Output>;`\n+        // *Unmatched count:* 3\n+        // *`parse_path_segment` calls deep:* 2\n+        //\n+        // This will continue until the next `>` character which will also return successfully\n+        // to the parent invocation of this function and decrement the count:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // At this point, this function will expect to find another matching `>` character but\n+        // won't be able to and will return an error. This will continue all the way up the\n+        // call stack until the first invocation:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // In doing this, we have managed to work out how many unmatched leading left angle\n+        // brackets there are, but we cannot recover as the unmatched angle brackets have\n+        // already been consumed. To remedy this, we keep a snapshot of the parser state\n+        // before we do the above. We can then inspect whether we ended up with a parsing error\n+        // and unmatched left angle brackets and if so, restore the parser state before we\n+        // consumed any `<` characters to emit an error and consume the erroneous tokens to\n+        // recover by attempting to parse again.\n+        //\n+        // In practice, the recursion of this function is indirect and there will be other\n+        // locations that consume some `<` characters - as long as we update the count when\n+        // this happens, it isn't an issue.\n+\n+        let is_first_invocation = style == PathStyle::Expr;\n+        // Take a snapshot before attempting to parse - we can restore this later.\n+        let snapshot = if is_first_invocation {\n+            Some(self.clone())\n+        } else {\n+            None\n+        };\n+\n+        debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n+        match self.parse_generic_args() {\n+            Ok(value) => Ok(value),\n+            Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n+                // Cancel error from being unable to find `>`. We know the error\n+                // must have been this due to a non-zero unmatched angle bracket\n+                // count.\n+                e.cancel();\n+\n+                // Swap `self` with our backup of the parser state before attempting to parse\n+                // generic arguments.\n+                let snapshot = mem::replace(self, snapshot.unwrap());\n+\n+                debug!(\n+                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n+                     snapshot.count={:?}\",\n+                    snapshot.unmatched_angle_bracket_count,\n+                );\n+\n+                // Eat the unmatched angle brackets.\n+                for _ in 0..snapshot.unmatched_angle_bracket_count {\n+                    self.eat_lt();\n+                }\n+\n+                // Make a span over ${unmatched angle bracket count} characters.\n+                let span = lo.with_hi(\n+                    lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n+                );\n+                let plural = snapshot.unmatched_angle_bracket_count > 1;\n+                self.diagnostic()\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"unmatched angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                    )\n+                    .span_suggestion(\n+                        span,\n+                        &format!(\n+                            \"remove extra angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+\n+                // Try again without unmatched angle bracket characters.\n+                self.parse_generic_args()\n+            },\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n+    /// possibly including trailing comma.\n+    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+        let mut args = Vec::new();\n+        let mut constraints = Vec::new();\n+        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n+        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n+\n+        let args_lo = self.token.span;\n+\n+        loop {\n+            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n+                // Parse lifetime argument.\n+                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else if self.check_ident() && self.look_ahead(1,\n+                    |t| t == &token::Eq || t == &token::Colon) {\n+                // Parse associated type constraint.\n+                let lo = self.token.span;\n+                let ident = self.parse_ident()?;\n+                let kind = if self.eat(&token::Eq) {\n+                    AssocTyConstraintKind::Equality {\n+                        ty: self.parse_ty()?,\n+                    }\n+                } else if self.eat(&token::Colon) {\n+                    AssocTyConstraintKind::Bound {\n+                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n+                    }\n+                } else {\n+                    unreachable!();\n+                };\n+                let span = lo.to(self.prev_span);\n+                constraints.push(AssocTyConstraint {\n+                    id: ast::DUMMY_NODE_ID,\n+                    ident,\n+                    kind,\n+                    span,\n+                });\n+                assoc_ty_constraints.push(span);\n+            } else if self.check_const_arg() {\n+                // Parse const argument.\n+                let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n+                    self.parse_block_expr(\n+                        None, self.token.span, BlockCheckMode::Default, ThinVec::new()\n+                    )?\n+                } else if self.token.is_ident() {\n+                    // FIXME(const_generics): to distinguish between idents for types and consts,\n+                    // we should introduce a GenericArg::Ident in the AST and distinguish when\n+                    // lowering to the HIR. For now, idents for const args are not permitted.\n+                    if self.token.is_keyword(kw::True) || self.token.is_keyword(kw::False) {\n+                        self.parse_literal_maybe_minus()?\n+                    } else {\n+                        return Err(\n+                            self.fatal(\"identifiers may currently not be used for const generics\")\n+                        );\n+                    }\n+                } else {\n+                    self.parse_literal_maybe_minus()?\n+                };\n+                let value = AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: expr,\n+                };\n+                args.push(GenericArg::Const(value));\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else if self.check_type() {\n+                // Parse type argument.\n+                args.push(GenericArg::Type(self.parse_ty()?));\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else {\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+\n+        // FIXME: we would like to report this in ast_validation instead, but we currently do not\n+        // preserve ordering of generic parameters with respect to associated type binding, so we\n+        // lose that information after parsing.\n+        if misplaced_assoc_ty_constraints.len() > 0 {\n+            let mut err = self.struct_span_err(\n+                args_lo.to(self.prev_span),\n+                \"associated type bindings must be declared after generic parameters\",\n+            );\n+            for span in misplaced_assoc_ty_constraints {\n+                err.span_label(\n+                    span,\n+                    \"this associated type binding should be moved after the generic parameters\",\n+                );\n+            }\n+            err.emit();\n+        }\n+\n+        Ok((args, constraints))\n+    }\n+}"}, {"sha": "f182edcbff4372e40cad2383f943db1bd7bf75b1", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,458 @@\n+use super::{Parser, PResult, Restrictions, PrevTokenKind, SemiColonMode, BlockMode};\n+use super::expr::LhsExpr;\n+use super::path::PathStyle;\n+\n+use crate::ptr::P;\n+use crate::{maybe_whole, ThinVec};\n+use crate::ast::{self, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n+use crate::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac_, MacDelimiter};\n+use crate::ext::base::DummyResult;\n+use crate::parse::{classify, DirectoryOwnership};\n+use crate::parse::diagnostics::Error;\n+use crate::parse::token::{self};\n+use crate::source_map::{respan, Span};\n+use crate::symbol::{kw, sym};\n+\n+use std::mem;\n+use errors::Applicability;\n+\n+impl<'a> Parser<'a> {\n+    /// Parse a statement. This stops just before trailing semicolons on everything but items.\n+    /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n+    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+        Ok(self.parse_stmt_(true))\n+    }\n+\n+    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n+            None\n+        })\n+    }\n+\n+    fn parse_stmt_without_recovery(\n+        &mut self,\n+        macro_legacy_warnings: bool,\n+    ) -> PResult<'a, Option<Stmt>> {\n+        maybe_whole!(self, NtStmt, |x| Some(x));\n+\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+\n+        Ok(Some(if self.eat_keyword(kw::Let) {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Local(self.parse_local(attrs.into())?),\n+                span: lo.to(self.prev_span),\n+            }\n+        } else if let Some(macro_def) = self.eat_macro_def(\n+            &attrs,\n+            &respan(lo, VisibilityKind::Inherited),\n+            lo,\n+        )? {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Item(macro_def),\n+                span: lo.to(self.prev_span),\n+            }\n+        // Starts like a simple path, being careful to avoid contextual keywords\n+        // such as a union items, item with `crate` visibility or auto trait items.\n+        // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n+        // like a path (1 token), but it fact not a path.\n+        // `union::b::c` - path, `union U { ... }` - not a path.\n+        // `crate::b::c` - path, `crate struct S;` - not a path.\n+        } else if self.token.is_path_start() &&\n+                  !self.token.is_qpath_start() &&\n+                  !self.is_union_item() &&\n+                  !self.is_crate_vis() &&\n+                  !self.is_auto_trait_item() &&\n+                  !self.is_async_fn() {\n+            let path = self.parse_path(PathStyle::Expr)?;\n+\n+            if !self.eat(&token::Not) {\n+                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_struct_expr(lo, path, ThinVec::new())?\n+                } else {\n+                    let hi = self.prev_span;\n+                    self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n+                };\n+\n+                let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n+                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+                })?;\n+\n+                return Ok(Some(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(expr),\n+                    span: lo.to(self.prev_span),\n+                }));\n+            }\n+\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            let hi = self.prev_span;\n+\n+            let style = if delim == MacDelimiter::Brace {\n+                MacStmtStyle::Braces\n+            } else {\n+                MacStmtStyle::NoBraces\n+            };\n+\n+            let mac = respan(lo.to(hi), Mac_ {\n+                path,\n+                tts,\n+                delim,\n+                prior_type_ascription: self.last_type_ascription,\n+            });\n+            let node = if delim == MacDelimiter::Brace ||\n+                          self.token == token::Semi || self.token == token::Eof {\n+                StmtKind::Mac(P((mac, style, attrs.into())))\n+            }\n+            // We used to incorrectly stop parsing macro-expanded statements here.\n+            // If the next token will be an error anyway but could have parsed with the\n+            // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+            else if macro_legacy_warnings &&\n+                    self.token.can_begin_expr() &&\n+                    match self.token.kind {\n+                // These can continue an expression, so we can't stop parsing and warn.\n+                token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                token::BinOp(token::And) | token::BinOp(token::Or) |\n+                token::AndAnd | token::OrOr |\n+                token::DotDot | token::DotDotDot | token::DotDotEq => false,\n+                _ => true,\n+            } {\n+                self.warn_missing_semicolon();\n+                StmtKind::Mac(P((mac, style, attrs.into())))\n+            } else {\n+                let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                StmtKind::Expr(e)\n+            };\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                span: lo.to(hi),\n+                node,\n+            }\n+        } else {\n+            // FIXME: Bad copy of attrs\n+            let old_directory_ownership =\n+                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+            let item = self.parse_item_(attrs.clone(), false, true)?;\n+            self.directory.ownership = old_directory_ownership;\n+\n+            match item {\n+                Some(i) => Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: lo.to(i.span),\n+                    node: StmtKind::Item(i),\n+                },\n+                None => {\n+                    let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n+                        if !attrs.is_empty() {\n+                            if s.prev_token_kind == PrevTokenKind::DocComment {\n+                                s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n+                            } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n+                                s.span_err(\n+                                    s.token.span, \"expected statement after outer attribute\"\n+                                );\n+                            }\n+                        }\n+                    };\n+\n+                    // Do not attempt to parse an expression if we're done here.\n+                    if self.token == token::Semi {\n+                        unused_attrs(&attrs, self);\n+                        self.bump();\n+                        return Ok(None);\n+                    }\n+\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        unused_attrs(&attrs, self);\n+                        return Ok(None);\n+                    }\n+\n+                    // Remainder are line-expr stmts.\n+                    let e = self.parse_expr_res(\n+                        Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+                    Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: lo.to(e.span),\n+                        node: StmtKind::Expr(e),\n+                    }\n+                }\n+            }\n+        }))\n+    }\n+\n+    /// Parses a local variable declaration.\n+    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n+        let lo = self.prev_span;\n+        let pat = self.parse_top_level_pat()?;\n+\n+        let (err, ty) = if self.eat(&token::Colon) {\n+            // Save the state of the parser before parsing type normally, in case there is a `:`\n+            // instead of an `=` typo.\n+            let parser_snapshot_before_type = self.clone();\n+            let colon_sp = self.prev_span;\n+            match self.parse_ty() {\n+                Ok(ty) => (None, Some(ty)),\n+                Err(mut err) => {\n+                    // Rewind to before attempting to parse the type and continue parsing\n+                    let parser_snapshot_after_type = self.clone();\n+                    mem::replace(self, parser_snapshot_before_type);\n+\n+                    let snippet = self.span_to_snippet(pat.span).unwrap();\n+                    err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n+                    (Some((parser_snapshot_after_type, colon_sp, err)), None)\n+                }\n+            }\n+        } else {\n+            (None, None)\n+        };\n+        let init = match (self.parse_initializer(err.is_some()), err) {\n+            (Ok(init), None) => {  // init parsed, ty parsed\n+                init\n+            }\n+            (Ok(init), Some((_, colon_sp, mut err))) => {  // init parsed, ty error\n+                // Could parse the type as if it were the initializer, it is likely there was a\n+                // typo in the code: `:` instead of `=`. Add suggestion and emit the error.\n+                err.span_suggestion_short(\n+                    colon_sp,\n+                    \"use `=` if you meant to assign\",\n+                    \"=\".to_string(),\n+                    Applicability::MachineApplicable\n+                );\n+                err.emit();\n+                // As this was parsed successfully, continue as if the code has been fixed for the\n+                // rest of the file. It will still fail due to the emitted error, but we avoid\n+                // extra noise.\n+                init\n+            }\n+            (Err(mut init_err), Some((snapshot, _, ty_err))) => {  // init error, ty error\n+                init_err.cancel();\n+                // Couldn't parse the type nor the initializer, only raise the type error and\n+                // return to the parser state before parsing the type as the initializer.\n+                // let x: <parse_error>;\n+                mem::replace(self, snapshot);\n+                return Err(ty_err);\n+            }\n+            (Err(err), None) => {  // init error, ty parsed\n+                // Couldn't parse the initializer and we're not attempting to recover a failed\n+                // parse of the type, return the error.\n+                return Err(err);\n+            }\n+        };\n+        let hi = if self.token == token::Semi {\n+            self.token.span\n+        } else {\n+            self.prev_span\n+        };\n+        Ok(P(ast::Local {\n+            ty,\n+            pat,\n+            init,\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            attrs,\n+        }))\n+    }\n+\n+    /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n+    fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n+        if self.eat(&token::Eq) {\n+            Ok(Some(self.parse_expr()?))\n+        } else if skip_eq {\n+            Ok(Some(self.parse_expr()?))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn is_auto_trait_item(&self) -> bool {\n+        // auto trait\n+        (self.token.is_keyword(kw::Auto) &&\n+            self.is_keyword_ahead(1, &[kw::Trait]))\n+        || // unsafe auto trait\n+        (self.token.is_keyword(kw::Unsafe) &&\n+         self.is_keyword_ahead(1, &[kw::Auto]) &&\n+         self.is_keyword_ahead(2, &[kw::Trait]))\n+    }\n+\n+    /// Parses a block. No inner attributes are allowed.\n+    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+        maybe_whole!(self, NtBlock, |x| x);\n+\n+        let lo = self.token.span;\n+\n+        if !self.eat(&token::OpenDelim(token::Brace)) {\n+            let sp = self.token.span;\n+            let tok = self.this_token_descr();\n+            let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n+            let do_not_suggest_help =\n+                self.token.is_keyword(kw::In) || self.token == token::Colon;\n+\n+            if self.token.is_ident_named(sym::and) {\n+                e.span_suggestion_short(\n+                    self.token.span,\n+                    \"use `&&` instead of `and` for the boolean operator\",\n+                    \"&&\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            if self.token.is_ident_named(sym::or) {\n+                e.span_suggestion_short(\n+                    self.token.span,\n+                    \"use `||` instead of `or` for the boolean operator\",\n+                    \"||\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            // Check to see if the user has written something like\n+            //\n+            //    if (cond)\n+            //      bar;\n+            //\n+            // Which is valid in other languages, but not Rust.\n+            match self.parse_stmt_without_recovery(false) {\n+                Ok(Some(stmt)) => {\n+                    if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n+                        || do_not_suggest_help {\n+                        // if the next token is an open brace (e.g., `if a b {`), the place-\n+                        // inside-a-block suggestion would be more likely wrong than right\n+                        e.span_label(sp, \"expected `{`\");\n+                        return Err(e);\n+                    }\n+                    let mut stmt_span = stmt.span;\n+                    // expand the span to include the semicolon, if it exists\n+                    if self.eat(&token::Semi) {\n+                        stmt_span = stmt_span.with_hi(self.prev_span.hi());\n+                    }\n+                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n+                        e.span_suggestion(\n+                            stmt_span,\n+                            \"try placing this code inside a block\",\n+                            format!(\"{{ {} }}\", snippet),\n+                            // speculative, has been misleading in the past (#46836)\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                Err(mut e) => {\n+                    self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n+                    self.cancel(&mut e);\n+                }\n+                _ => ()\n+            }\n+            e.span_label(sp, \"expected `{`\");\n+            return Err(e);\n+        }\n+\n+        self.parse_block_tail(lo, BlockCheckMode::Default)\n+    }\n+\n+    /// Parses a block. Inner attributes are allowed.\n+    crate fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n+        maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n+\n+        let lo = self.token.span;\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+        Ok((self.parse_inner_attributes()?,\n+            self.parse_block_tail(lo, BlockCheckMode::Default)?))\n+    }\n+\n+    /// Parses the rest of a block expression or function body.\n+    /// Precondition: already parsed the '{'.\n+    pub(super) fn parse_block_tail(\n+        &mut self,\n+        lo: Span,\n+        s: BlockCheckMode\n+    ) -> PResult<'a, P<Block>> {\n+        let mut stmts = vec![];\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            if self.token == token::Eof {\n+                break;\n+            }\n+            let stmt = match self.parse_full_stmt(false) {\n+                Err(mut err) => {\n+                    err.emit();\n+                    self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n+                    Some(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Expr(DummyResult::raw_expr(self.token.span, true)),\n+                        span: self.token.span,\n+                    })\n+                }\n+                Ok(stmt) => stmt,\n+            };\n+            if let Some(stmt) = stmt {\n+                stmts.push(stmt);\n+            } else {\n+                // Found only `;` or `}`.\n+                continue;\n+            };\n+        }\n+        Ok(P(ast::Block {\n+            stmts,\n+            id: ast::DUMMY_NODE_ID,\n+            rules: s,\n+            span: lo.to(self.prev_span),\n+        }))\n+    }\n+\n+    /// Parses a statement, including the trailing semicolon.\n+    crate fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n+        // skip looking for a trailing semicolon when we have an interpolated statement\n+        maybe_whole!(self, NtStmt, |x| Some(x));\n+\n+        let mut stmt = match self.parse_stmt_without_recovery(macro_legacy_warnings)? {\n+            Some(stmt) => stmt,\n+            None => return Ok(None),\n+        };\n+\n+        match stmt.node {\n+            StmtKind::Expr(ref expr) if self.token != token::Eof => {\n+                // expression without semicolon\n+                if classify::expr_requires_semi_to_be_stmt(expr) {\n+                    // Just check for errors and recover; do not eat semicolon yet.\n+                    if let Err(mut e) =\n+                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                    {\n+                        e.emit();\n+                        self.recover_stmt();\n+                        // Don't complain about type errors in body tail after parse error (#57383).\n+                        let sp = expr.span.to(self.prev_span);\n+                        stmt.node = StmtKind::Expr(DummyResult::raw_expr(sp, true));\n+                    }\n+                }\n+            }\n+            StmtKind::Local(..) => {\n+                // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n+                if macro_legacy_warnings && self.token != token::Semi {\n+                    self.warn_missing_semicolon();\n+                } else {\n+                    self.expect_one_of(&[], &[token::Semi])?;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        if self.eat(&token::Semi) {\n+            stmt = stmt.add_trailing_semicolon();\n+        }\n+        stmt.span = stmt.span.to(self.prev_span);\n+        Ok(Some(stmt))\n+    }\n+\n+    fn warn_missing_semicolon(&self) {\n+        self.diagnostic().struct_span_warn(self.token.span, {\n+            &format!(\"expected `;`, found {}\", self.this_token_descr())\n+        }).note({\n+            \"This was erroneously allowed and will become a hard error in a future release\"\n+        }).emit();\n+    }\n+}"}, {"sha": "1eb3d441e698a06fd7d1748ac5d1c5439defa5b1", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f8043d44a8925e469daf5c10e2630c80c2a7d4/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=72f8043d44a8925e469daf5c10e2630c80c2a7d4", "patch": "@@ -0,0 +1,461 @@\n+use super::{Parser, PResult, PathStyle, PrevTokenKind, TokenType};\n+\n+use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n+use crate::ptr::P;\n+use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n+use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n+use crate::ast::{Mutability, AnonConst, FnDecl, Mac_};\n+use crate::parse::token::{self, Token};\n+use crate::source_map::{respan, Span};\n+use crate::symbol::{kw};\n+\n+use rustc_target::spec::abi::Abi;\n+\n+use errors::{Applicability};\n+\n+/// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n+/// `IDENT<<u8 as Trait>::AssocTy>`.\n+///\n+/// Types can also be of the form `IDENT(u8, u8) -> u8`, however this assumes\n+/// that `IDENT` is not the ident of a fn trait.\n+fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n+    t == &token::ModSep || t == &token::Lt ||\n+    t == &token::BinOp(token::Shl)\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a type.\n+    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(true, true, false)\n+    }\n+\n+    /// Parses a type in restricted contexts where `+` is not permitted.\n+    ///\n+    /// Example 1: `&'a TYPE`\n+    ///     `+` is prohibited to maintain operator priority (P(+) < P(&)).\n+    /// Example 2: `value1 as TYPE + value2`\n+    ///     `+` is prohibited to avoid interactions with expression grammar.\n+    pub(super) fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(false, true, false)\n+    }\n+\n+    /// Parses an optional return type `[ -> TY ]` in a function declaration.\n+    pub(super) fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n+        if self.eat(&token::RArrow) {\n+            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n+        } else {\n+            Ok(FunctionRetTy::Default(self.token.span.shrink_to_lo()))\n+        }\n+    }\n+\n+    pub(super) fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n+                       allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n+        maybe_whole!(self, NtTy, |x| x);\n+\n+        let lo = self.token.span;\n+        let mut impl_dyn_multi = false;\n+        let node = if self.eat(&token::OpenDelim(token::Paren)) {\n+            // `(TYPE)` is a parenthesized type.\n+            // `(TYPE,)` is a tuple with a single field of type TYPE.\n+            let mut ts = vec![];\n+            let mut last_comma = false;\n+            while self.token != token::CloseDelim(token::Paren) {\n+                ts.push(self.parse_ty()?);\n+                if self.eat(&token::Comma) {\n+                    last_comma = true;\n+                } else {\n+                    last_comma = false;\n+                    break;\n+                }\n+            }\n+            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+\n+            if ts.len() == 1 && !last_comma {\n+                let ty = ts.into_iter().nth(0).unwrap().into_inner();\n+                let maybe_bounds = allow_plus && self.token.is_like_plus();\n+                match ty.node {\n+                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n+                    TyKind::Path(None, ref path) if maybe_bounds => {\n+                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n+                    }\n+                    TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n+                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                        let path = match bounds[0] {\n+                            GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n+                            GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n+                        };\n+                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                    }\n+                    // `(TYPE)`\n+                    _ => TyKind::Paren(P(ty))\n+                }\n+            } else {\n+                TyKind::Tup(ts)\n+            }\n+        } else if self.eat(&token::Not) {\n+            // Never type `!`\n+            TyKind::Never\n+        } else if self.eat(&token::BinOp(token::Star)) {\n+            // Raw pointer\n+            TyKind::Ptr(self.parse_ptr()?)\n+        } else if self.eat(&token::OpenDelim(token::Bracket)) {\n+            // Array or slice\n+            let t = self.parse_ty()?;\n+            // Parse optional `; EXPR` in `[TYPE; EXPR]`\n+            let t = match self.maybe_parse_fixed_length_of_vec()? {\n+                None => TyKind::Slice(t),\n+                Some(length) => TyKind::Array(t, AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: length,\n+                }),\n+            };\n+            self.expect(&token::CloseDelim(token::Bracket))?;\n+            t\n+        } else if self.check(&token::BinOp(token::And)) || self.check(&token::AndAnd) {\n+            // Reference\n+            self.expect_and()?;\n+            self.parse_borrowed_pointee()?\n+        } else if self.eat_keyword_noexpect(kw::Typeof) {\n+            // `typeof(EXPR)`\n+            // In order to not be ambiguous, the type must be surrounded by parens.\n+            self.expect(&token::OpenDelim(token::Paren))?;\n+            let e = AnonConst {\n+                id: ast::DUMMY_NODE_ID,\n+                value: self.parse_expr()?,\n+            };\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            TyKind::Typeof(e)\n+        } else if self.eat_keyword(kw::Underscore) {\n+            // A type to be inferred `_`\n+            TyKind::Infer\n+        } else if self.token_is_bare_fn_keyword() {\n+            // Function pointer type\n+            self.parse_ty_bare_fn(Vec::new())?\n+        } else if self.check_keyword(kw::For) {\n+            // Function pointer type or bound list (trait object type) starting with a poly-trait.\n+            //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n+            //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n+            let lo = self.token.span;\n+            let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+            if self.token_is_bare_fn_keyword() {\n+                self.parse_ty_bare_fn(lifetime_defs)?\n+            } else {\n+                let path = self.parse_path(PathStyle::Type)?;\n+                let parse_plus = allow_plus && self.check_plus();\n+                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n+            }\n+        } else if self.eat_keyword(kw::Impl) {\n+            // Always parse bounds greedily for better error recovery.\n+            let bounds = self.parse_generic_bounds(None)?;\n+            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+            TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n+        } else if self.check_keyword(kw::Dyn) &&\n+                  (self.token.span.rust_2018() ||\n+                   self.look_ahead(1, |t| t.can_begin_bound() &&\n+                                          !can_continue_type_after_non_fn_ident(t))) {\n+            self.bump(); // `dyn`\n+            // Always parse bounds greedily for better error recovery.\n+            let bounds = self.parse_generic_bounds(None)?;\n+            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+            TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n+        } else if self.check(&token::Question) ||\n+                  self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n+            // Bound list (trait object type)\n+            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus, None)?,\n+                                TraitObjectSyntax::None)\n+        } else if self.eat_lt() {\n+            // Qualified path\n+            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n+            TyKind::Path(Some(qself), path)\n+        } else if self.token.is_path_start() {\n+            // Simple path\n+            let path = self.parse_path(PathStyle::Type)?;\n+            if self.eat(&token::Not) {\n+                // Macro invocation in type position\n+                let (delim, tts) = self.expect_delimited_token_tree()?;\n+                let node = Mac_ {\n+                    path,\n+                    tts,\n+                    delim,\n+                    prior_type_ascription: self.last_type_ascription,\n+                };\n+                TyKind::Mac(respan(lo.to(self.prev_span), node))\n+            } else {\n+                // Just a type path or bound list (trait object type) starting with a trait.\n+                //   `Type`\n+                //   `Trait1 + Trait2 + 'a`\n+                if allow_plus && self.check_plus() {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                } else {\n+                    TyKind::Path(None, path)\n+                }\n+            }\n+        } else if self.check(&token::DotDotDot) {\n+            if allow_c_variadic {\n+                self.eat(&token::DotDotDot);\n+                TyKind::CVarArgs\n+            } else {\n+                return Err(self.fatal(\n+                    \"only foreign functions are allowed to be C-variadic\"\n+                ));\n+            }\n+        } else {\n+            let msg = format!(\"expected type, found {}\", self.this_token_descr());\n+            let mut err = self.fatal(&msg);\n+            err.span_label(self.token.span, \"expected type\");\n+            self.maybe_annotate_with_ascription(&mut err, true);\n+            return Err(err);\n+        };\n+\n+        let span = lo.to(self.prev_span);\n+        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n+\n+        // Try to recover from use of `+` with incorrect priority.\n+        self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n+        self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n+        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n+    }\n+\n+    fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n+                              lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n+        let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n+        if parse_plus {\n+            self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n+            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_span))?);\n+        }\n+        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n+    }\n+\n+    fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n+        let mutbl = if self.eat_keyword(kw::Mut) {\n+            Mutability::Mutable\n+        } else if self.eat_keyword(kw::Const) {\n+            Mutability::Immutable\n+        } else {\n+            let span = self.prev_span;\n+            let msg = \"expected mut or const in raw pointer type\";\n+            self.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .help(\"use `*mut T` or `*const T` as appropriate\")\n+                .emit();\n+            Mutability::Immutable\n+        };\n+        let t = self.parse_ty_no_plus()?;\n+        Ok(MutTy { ty: t, mutbl })\n+    }\n+\n+    fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n+        if self.eat(&token::Semi) {\n+            Ok(Some(self.parse_expr()?))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n+        let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n+        let mutbl = self.parse_mutability();\n+        let ty = self.parse_ty_no_plus()?;\n+        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }));\n+    }\n+\n+    /// Is the current token one of the keywords that signals a bare function type?\n+    fn token_is_bare_fn_keyword(&mut self) -> bool {\n+        self.check_keyword(kw::Fn) ||\n+            self.check_keyword(kw::Unsafe) ||\n+            self.check_keyword(kw::Extern)\n+    }\n+\n+    /// Parses a `TyKind::BareFn` type.\n+    fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n+        /*\n+\n+        [unsafe] [extern \"ABI\"] fn (S) -> T\n+         ^~~~^           ^~~~^     ^~^    ^\n+           |               |        |     |\n+           |               |        |   Return type\n+           |               |      Argument types\n+           |               |\n+           |              ABI\n+        Function Style\n+        */\n+\n+        let unsafety = self.parse_unsafety();\n+        let abi = if self.eat_keyword(kw::Extern) {\n+            self.parse_opt_abi()?.unwrap_or(Abi::C)\n+        } else {\n+            Abi::Rust\n+        };\n+\n+        self.expect_keyword(kw::Fn)?;\n+        let (inputs, c_variadic) = self.parse_fn_args(false, true)?;\n+        let ret_ty = self.parse_ret_ty(false)?;\n+        let decl = P(FnDecl {\n+            inputs,\n+            output: ret_ty,\n+            c_variadic,\n+        });\n+        Ok(TyKind::BareFn(P(BareFnTy {\n+            abi,\n+            unsafety,\n+            generic_params,\n+            decl,\n+        })))\n+    }\n+\n+    crate fn parse_generic_bounds(&mut self,\n+                                  colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+        self.parse_generic_bounds_common(true, colon_span)\n+    }\n+\n+    /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n+    ///\n+    /// ```\n+    /// BOUND = TY_BOUND | LT_BOUND\n+    /// LT_BOUND = LIFETIME (e.g., `'a`)\n+    /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n+    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n+    /// ```\n+    fn parse_generic_bounds_common(&mut self,\n+                                   allow_plus: bool,\n+                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+        let mut bounds = Vec::new();\n+        let mut negative_bounds = Vec::new();\n+        let mut last_plus_span = None;\n+        let mut was_negative = false;\n+        loop {\n+            // This needs to be synchronized with `TokenKind::can_begin_bound`.\n+            let is_bound_start = self.check_path() || self.check_lifetime() ||\n+                                 self.check(&token::Not) || // used for error reporting only\n+                                 self.check(&token::Question) ||\n+                                 self.check_keyword(kw::For) ||\n+                                 self.check(&token::OpenDelim(token::Paren));\n+            if is_bound_start {\n+                let lo = self.token.span;\n+                let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+                let inner_lo = self.token.span;\n+                let is_negative = self.eat(&token::Not);\n+                let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n+                if self.token.is_lifetime() {\n+                    if let Some(question_span) = question {\n+                        self.span_err(question_span,\n+                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n+                    }\n+                    bounds.push(GenericBound::Outlives(self.expect_lifetime()));\n+                    if has_parens {\n+                        let inner_span = inner_lo.to(self.prev_span);\n+                        self.expect(&token::CloseDelim(token::Paren))?;\n+                        let mut err = self.struct_span_err(\n+                            lo.to(self.prev_span),\n+                            \"parenthesized lifetime bounds are not supported\"\n+                        );\n+                        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n+                            err.span_suggestion_short(\n+                                lo.to(self.prev_span),\n+                                \"remove the parentheses\",\n+                                snippet.to_owned(),\n+                                Applicability::MachineApplicable\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n+                } else {\n+                    let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+                    let path = self.parse_path(PathStyle::Type)?;\n+                    if has_parens {\n+                        self.expect(&token::CloseDelim(token::Paren))?;\n+                    }\n+                    let poly_span = lo.to(self.prev_span);\n+                    if is_negative {\n+                        was_negative = true;\n+                        if let Some(sp) = last_plus_span.or(colon_span) {\n+                            negative_bounds.push(sp.to(poly_span));\n+                        }\n+                    } else {\n+                        let poly_trait = PolyTraitRef::new(lifetime_defs, path, poly_span);\n+                        let modifier = if question.is_some() {\n+                            TraitBoundModifier::Maybe\n+                        } else {\n+                            TraitBoundModifier::None\n+                        };\n+                        bounds.push(GenericBound::Trait(poly_trait, modifier));\n+                    }\n+                }\n+            } else {\n+                break\n+            }\n+\n+            if !allow_plus || !self.eat_plus() {\n+                break\n+            } else {\n+                last_plus_span = Some(self.prev_span);\n+            }\n+        }\n+\n+        if !negative_bounds.is_empty() || was_negative {\n+            let plural = negative_bounds.len() > 1;\n+            let last_span = negative_bounds.last().map(|sp| *sp);\n+            let mut err = self.struct_span_err(\n+                negative_bounds,\n+                \"negative trait bounds are not supported\",\n+            );\n+            if let Some(sp) = last_span {\n+                err.span_label(sp, \"negative trait bounds are not supported\");\n+            }\n+            if let Some(bound_list) = colon_span {\n+                let bound_list = bound_list.to(self.prev_span);\n+                let mut new_bound_list = String::new();\n+                if !bounds.is_empty() {\n+                    let mut snippets = bounds.iter().map(|bound| bound.span())\n+                        .map(|span| self.span_to_snippet(span));\n+                    while let Some(Ok(snippet)) = snippets.next() {\n+                        new_bound_list.push_str(\" + \");\n+                        new_bound_list.push_str(&snippet);\n+                    }\n+                    new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n+                }\n+                err.span_suggestion_hidden(\n+                    bound_list,\n+                    &format!(\"remove the trait bound{}\", if plural { \"s\" } else { \"\" }),\n+                    new_bound_list,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n+        }\n+\n+        return Ok(bounds);\n+    }\n+\n+    pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n+        if self.eat_keyword(kw::For) {\n+            self.expect_lt()?;\n+            let params = self.parse_generic_params()?;\n+            self.expect_gt()?;\n+            // We rely on AST validation to rule out invalid cases: There must not be type\n+            // parameters, and the lifetime parameters must not have bounds.\n+            Ok(params)\n+        } else {\n+            Ok(Vec::new())\n+        }\n+    }\n+\n+    crate fn check_lifetime(&mut self) -> bool {\n+        self.expected_tokens.push(TokenType::Lifetime);\n+        self.token.is_lifetime()\n+    }\n+\n+    /// Parses a single lifetime `'a` or panics.\n+    crate fn expect_lifetime(&mut self) -> Lifetime {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.token.span;\n+            self.bump();\n+            Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n+        } else {\n+            self.span_bug(self.token.span, \"not a lifetime\")\n+        }\n+    }\n+}"}]}