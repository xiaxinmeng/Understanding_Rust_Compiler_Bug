{"sha": "6dca2cbba5f1a51b7623f064e9b265929f8cff72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkY2EyY2JiYTVmMWE1MWI3NjIzZjA2NGU5YjI2NTkyOWY4Y2ZmNzI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-07T22:33:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-07T22:33:52Z"}, "message": "Simplify mod completion", "tree": {"sha": "ff70e96fc2b5bbb529a6a7c5aec9da3772900a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff70e96fc2b5bbb529a6a7c5aec9da3772900a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dca2cbba5f1a51b7623f064e9b265929f8cff72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dca2cbba5f1a51b7623f064e9b265929f8cff72", "html_url": "https://github.com/rust-lang/rust/commit/6dca2cbba5f1a51b7623f064e9b265929f8cff72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dca2cbba5f1a51b7623f064e9b265929f8cff72/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca6db58762dcd0ee9b7d5fb91c85486c0b90ef4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6db58762dcd0ee9b7d5fb91c85486c0b90ef4b", "html_url": "https://github.com/rust-lang/rust/commit/ca6db58762dcd0ee9b7d5fb91c85486c0b90ef4b"}], "stats": {"total": 69, "additions": 31, "deletions": 38}, "files": [{"sha": "00e951ca95e582ccfd8c08ce1b6b69247b13f64d", "filename": "crates/completion/src/completions/mod_.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6dca2cbba5f1a51b7623f064e9b265929f8cff72/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dca2cbba5f1a51b7623f064e9b265929f8cff72/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=6dca2cbba5f1a51b7623f064e9b265929f8cff72", "patch": "@@ -1,5 +1,7 @@\n //! Completes mod declarations.\n \n+use std::iter;\n+\n use hir::{Module, ModuleSource};\n use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n use ide_db::RootDatabase;\n@@ -12,9 +14,8 @@ use crate::{context::CompletionContext, item::CompletionKind, Completions};\n /// Complete mod declaration, i.e. `mod $0 ;`\n pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     let mod_under_caret = match &ctx.mod_declaration_under_caret {\n-        Some(mod_under_caret) if mod_under_caret.item_list().is_some() => return None,\n-        Some(mod_under_caret) => mod_under_caret,\n-        None => return None,\n+        Some(mod_under_caret) if mod_under_caret.item_list().is_none() => mod_under_caret,\n+        _ => return None,\n     };\n \n     let _p = profile::span(\"completion::complete_mod\");\n@@ -49,9 +50,13 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n         .filter_map(|submodule_file| {\n             let submodule_path = source_root.path_for_file(&submodule_file)?;\n             let directory_with_submodule = submodule_path.parent()?;\n-            match submodule_path.name_and_extension()? {\n-                (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n-                (\"mod\", Some(\"rs\")) => {\n+            let (name, ext) = submodule_path.name_and_extension()?;\n+            if ext != Some(\"rs\") {\n+                return None;\n+            }\n+            match name {\n+                \"lib\" | \"main\" => None,\n+                \"mod\" => {\n                     if directory_with_submodule.parent()? == directory_to_look_for_submodules {\n                         match directory_with_submodule.name_and_extension()? {\n                             (directory_name, None) => Some(directory_name.to_owned()),\n@@ -61,9 +66,7 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n                         None\n                     }\n                 }\n-                (file_name, Some(\"rs\"))\n-                    if directory_with_submodule == directory_to_look_for_submodules =>\n-                {\n+                file_name if directory_with_submodule == directory_to_look_for_submodules => {\n                     Some(file_name.to_owned())\n                 }\n                 _ => None,\n@@ -73,7 +76,7 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n         .for_each(|submodule_name| {\n             let mut label = submodule_name;\n             if mod_under_caret.semicolon_token().is_none() {\n-                label.push(';')\n+                label.push(';');\n             }\n             CompletionItem::new(CompletionKind::Magic, ctx.source_range(), &label)\n                 .kind(CompletionItemKind::Module)\n@@ -89,11 +92,13 @@ fn directory_to_look_for_submodules(\n     module_file_path: &VfsPath,\n ) -> Option<VfsPath> {\n     let directory_with_module_path = module_file_path.parent()?;\n-    let base_directory = match module_file_path.name_and_extension()? {\n-        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n-            Some(directory_with_module_path)\n-        }\n-        (regular_rust_file_name, Some(\"rs\")) => {\n+    let (name, ext) = module_file_path.name_and_extension()?;\n+    if ext != Some(\"rs\") {\n+        return None;\n+    }\n+    let base_directory = match name {\n+        \"mod\" | \"lib\" | \"main\" => Some(directory_with_module_path),\n+        regular_rust_file_name => {\n             if matches!(\n                 (\n                     directory_with_module_path\n@@ -110,37 +115,25 @@ fn directory_to_look_for_submodules(\n                 directory_with_module_path.join(regular_rust_file_name)\n             }\n         }\n-        _ => None,\n     }?;\n \n-    let mut resulting_path = base_directory;\n-    for module in module_chain_to_containing_module_file(module, db) {\n-        if let Some(name) = module.name(db) {\n-            resulting_path = resulting_path.join(&name.to_string())?;\n-        }\n-    }\n-\n-    Some(resulting_path)\n+    module_chain_to_containing_module_file(module, db)\n+        .into_iter()\n+        .filter_map(|module| module.name(db))\n+        .try_fold(base_directory, |path, name| path.join(&name.to_string()))\n }\n \n fn module_chain_to_containing_module_file(\n     current_module: Module,\n     db: &RootDatabase,\n ) -> Vec<Module> {\n-    let mut path = Vec::new();\n-\n-    let mut current_module = Some(current_module);\n-    while let Some(ModuleSource::Module(_)) =\n-        current_module.map(|module| module.definition_source(db).value)\n-    {\n-        if let Some(module) = current_module {\n-            path.insert(0, module);\n-            current_module = module.parent(db);\n-        } else {\n-            current_module = None;\n-        }\n-    }\n-\n+    let mut path =\n+        iter::successors(Some(current_module), |current_module| current_module.parent(db))\n+            .take_while(|current_module| {\n+                matches!(current_module.definition_source(db).value, ModuleSource::Module(_))\n+            })\n+            .collect::<Vec<_>>();\n+    path.reverse();\n     path\n }\n "}]}