{"sha": "0428f0d234319649ce7b7d1571ec169d58a6642e", "node_id": "C_kwDOAAsO6NoAKDA0MjhmMGQyMzQzMTk2NDljZTdiN2QxNTcxZWMxNjlkNThhNjY0MmU", "commit": {"author": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2022-08-10T18:56:44Z"}, "committer": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2022-08-10T19:07:07Z"}, "message": "Add labels to if_let_mutex", "tree": {"sha": "9bc46add9c733ad655e51cbf5c5d4648a4f0cc68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bc46add9c733ad655e51cbf5c5d4648a4f0cc68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0428f0d234319649ce7b7d1571ec169d58a6642e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0428f0d234319649ce7b7d1571ec169d58a6642e", "html_url": "https://github.com/rust-lang/rust/commit/0428f0d234319649ce7b7d1571ec169d58a6642e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0428f0d234319649ce7b7d1571ec169d58a6642e/comments", "author": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a73a454186c6795e692108b878492f8e25cd558", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a73a454186c6795e692108b878492f8e25cd558", "html_url": "https://github.com/rust-lang/rust/commit/6a73a454186c6795e692108b878492f8e25cd558"}], "stats": {"total": 66, "additions": 40, "deletions": 26}, "files": [{"sha": "b6f9fefdee99a5ce4e4ac4410cf8d3def1c4aa42", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0428f0d234319649ce7b7d1571ec169d58a6642e/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0428f0d234319649ce7b7d1571ec169d58a6642e/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=0428f0d234319649ce7b7d1571ec169d58a6642e", "patch": "@@ -1,8 +1,9 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n+use rustc_errors::Diagnostic;\n use rustc_hir::intravisit::{self as visit, Visitor};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -45,16 +46,8 @@ declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        let mut arm_visit = ArmVisitor {\n-            mutex_lock_called: false,\n-            found_mutex: None,\n-            cx,\n-        };\n-        let mut op_visit = OppVisitor {\n-            mutex_lock_called: false,\n-            found_mutex: None,\n-            cx,\n-        };\n+        let mut arm_visit = ArmVisitor { found_mutex: None, cx };\n+        let mut op_visit = OppVisitor { found_mutex: None, cx };\n         if let Some(higher::IfLet {\n             let_expr,\n             if_then,\n@@ -63,18 +56,28 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n         }) = higher::IfLet::hir(cx, expr)\n         {\n             op_visit.visit_expr(let_expr);\n-            if op_visit.mutex_lock_called {\n+            if let Some(op_mutex) = op_visit.found_mutex {\n                 arm_visit.visit_expr(if_then);\n                 arm_visit.visit_expr(if_else);\n \n-                if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n-                    span_lint_and_help(\n+                if let Some(arm_mutex) = arm_visit.found_mutex_if_same_as(op_mutex) {\n+                    let diag = |diag: &mut Diagnostic| {\n+                        diag.span_label(\n+                            op_mutex.span,\n+                            \"This Mutex will remain locked for the entire `if let`-block...\",\n+                        );\n+                        diag.span_label(\n+                            arm_mutex.span,\n+                            \"... and is tried to lock again here, which will always deadlock.\",\n+                        );\n+                        diag.help(\"move the lock call outside of the `if let ...` expression\");\n+                    };\n+                    span_lint_and_then(\n                         cx,\n                         IF_LET_MUTEX,\n                         expr.span,\n                         \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n-                        None,\n-                        \"move the lock call outside of the `if let ...` expression\",\n+                        diag,\n                     );\n                 }\n             }\n@@ -84,7 +87,6 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n \n /// Checks if `Mutex::lock` is called in the `if let` expr.\n pub struct OppVisitor<'a, 'tcx> {\n-    mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n@@ -93,7 +95,6 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n             self.found_mutex = Some(mutex);\n-            self.mutex_lock_called = true;\n             return;\n         }\n         visit::walk_expr(self, expr);\n@@ -102,7 +103,6 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n \n /// Checks if `Mutex::lock` is called in any of the branches.\n pub struct ArmVisitor<'a, 'tcx> {\n-    mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n@@ -111,17 +111,19 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n             self.found_mutex = Some(mutex);\n-            self.mutex_lock_called = true;\n             return;\n         }\n         visit::walk_expr(self, expr);\n     }\n }\n \n impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n-    fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n-        self.found_mutex\n-            .map_or(false, |arm_mutex| SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex))\n+    fn found_mutex_if_same_as(&self, op_mutex: &Expr<'_>) -> Option<&Expr<'_>> {\n+        self.found_mutex.and_then(|arm_mutex| {\n+            SpanlessEq::new(self.cx)\n+                .eq_expr(op_mutex, arm_mutex)\n+                .then_some(arm_mutex)\n+        })\n     }\n }\n "}, {"sha": "6dbfc4be41272f2166631447a1a9e4aebca80b5e", "filename": "tests/ui/if_let_mutex.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0428f0d234319649ce7b7d1571ec169d58a6642e/tests%2Fui%2Fif_let_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0428f0d234319649ce7b7d1571ec169d58a6642e/tests%2Fui%2Fif_let_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.stderr?ref=0428f0d234319649ce7b7d1571ec169d58a6642e", "patch": "@@ -1,10 +1,14 @@\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:10:5\n    |\n-LL | /     if let Err(locked) = m.lock() {\n+LL |       if let Err(locked) = m.lock() {\n+   |       ^                    - This Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(locked);\n LL | |     } else {\n LL | |         let lock = m.lock().unwrap();\n+   | |                    - ... and is tried to lock again here, which will always deadlock.\n LL | |         do_stuff(lock);\n LL | |     };\n    | |_____^\n@@ -15,10 +19,14 @@ LL | |     };\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:22:5\n    |\n-LL | /     if let Some(locked) = m.lock().unwrap().deref() {\n+LL |       if let Some(locked) = m.lock().unwrap().deref() {\n+   |       ^                     - This Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(locked);\n LL | |     } else {\n LL | |         let lock = m.lock().unwrap();\n+   | |                    - ... and is tried to lock again here, which will always deadlock.\n LL | |         do_stuff(lock);\n LL | |     };\n    | |_____^\n@@ -28,10 +36,14 @@ LL | |     };\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:43:5\n    |\n-LL | /     if let Ok(i) = mutex.lock() {\n+LL |       if let Ok(i) = mutex.lock() {\n+   |       ^              ----- This Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(i);\n LL | |     } else {\n LL | |         let _x = mutex.lock();\n+   | |                  ----- ... and is tried to lock again here, which will always deadlock.\n LL | |     };\n    | |_____^\n    |"}]}