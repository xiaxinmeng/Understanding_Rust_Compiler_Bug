{"sha": "0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNWRhZTAzMjJhYzQ3ZWE0NTdhYWZhZGMxMWZjMGViNmM4ZjI0NDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-21T19:27:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "switch to use `VerifyBound` instead of `RegionTest`", "tree": {"sha": "9f2d2788632f80ca5ca05d76fa28f6b03fe4391c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f2d2788632f80ca5ca05d76fa28f6b03fe4391c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "html_url": "https://github.com/rust-lang/rust/commit/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2392a093977815bffe1a9a324ab8235d1802fbe4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2392a093977815bffe1a9a324ab8235d1802fbe4", "html_url": "https://github.com/rust-lang/rust/commit/2392a093977815bffe1a9a324ab8235d1802fbe4"}], "stats": {"total": 99, "additions": 27, "deletions": 72}, "files": [{"sha": "a0bc734d5d75af2ae8160a135859768623231e86", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "patch": "@@ -16,7 +16,7 @@ use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelatio\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::region_constraints::{GenericKind, VarInfos};\n+use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n@@ -160,33 +160,7 @@ pub struct TypeTest<'tcx> {\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n-    pub test: RegionTest,\n-}\n-\n-/// A \"test\" that can be applied to some \"subject region\" `'x`. These are used to\n-/// describe type constraints. Tests do not presently affect the\n-/// region values that get inferred for each variable; they only\n-/// examine the results *after* inference.  This means they can\n-/// conveniently include disjuction (\"a or b must be true\").\n-#[derive(Clone, Debug)]\n-pub enum RegionTest {\n-    /// The subject region `'x` must by outlived by the given region.\n-    ///\n-    /// This test comes from e.g. a where clause like `T: 'a`, which\n-    /// implies that we know that `T: 'a`. Therefore, if we are trying\n-    /// to prove that `T: 'x`, we can do so by showing that `'a: 'x`.\n-    IsOutlivedBy(RegionVid),\n-\n-    /// Any of the given tests are true.\n-    ///\n-    /// This test comes from e.g. a where clause like `T: 'a + 'b`,\n-    /// which implies that we know that `T: 'a` and that `T:\n-    /// 'b`. Therefore, if we are trying to prove that `T: 'x`, we can\n-    /// do so by showing that `'a: 'x` *or* `'b: 'x`.\n-    Any(Vec<RegionTest>),\n-\n-    /// All of the given tests are true.\n-    All(Vec<RegionTest>),\n+    pub verify_bound: VerifyBound<'tcx>,\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -571,7 +545,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(mir, type_test.lower_bound, &type_test.test) {\n+            if self.eval_verify_bound(mir, type_test.lower_bound, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -678,7 +652,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             generic_kind,\n             lower_bound,\n             locations,\n-            test: _,\n+            verify_bound: _,\n         } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n@@ -705,7 +679,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_region_test(mir, ur, &type_test.test) {\n+            if self.eval_verify_bound(mir, ur, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -877,22 +851,32 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Test if `test` is true when applied to `lower_bound` at\n     /// `point`, and returns true or false.\n-    fn eval_region_test(&self, mir: &Mir<'tcx>, lower_bound: RegionVid, test: &RegionTest) -> bool {\n+    fn eval_verify_bound(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        lower_bound: RegionVid,\n+        verify_bound: &VerifyBound<'tcx>,\n+    ) -> bool {\n         debug!(\n-            \"eval_region_test(lower_bound={:?}, test={:?})\",\n-            lower_bound, test\n+            \"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\",\n+            lower_bound, verify_bound\n         );\n \n-        match test {\n-            RegionTest::IsOutlivedBy(r) => self.eval_outlives(mir, *r, lower_bound),\n+        match verify_bound {\n+            VerifyBound::IfEq(..) => false, // FIXME\n+\n+            VerifyBound::OutlivedBy(r) => {\n+                let r_vid = self.to_region_vid(r);\n+                self.eval_outlives(mir, r_vid, lower_bound)\n+            }\n \n-            RegionTest::Any(tests) => tests\n+            VerifyBound::AnyBound(verify_bounds) => verify_bounds\n                 .iter()\n-                .any(|test| self.eval_region_test(mir, lower_bound, test)),\n+                .any(|verify_bound| self.eval_verify_bound(mir, lower_bound, verify_bound)),\n \n-            RegionTest::All(tests) => tests\n+            VerifyBound::AllBounds(verify_bounds) => verify_bounds\n                 .iter()\n-                .all(|test| self.eval_region_test(mir, lower_bound, test)),\n+                .all(|verify_bound| self.eval_verify_bound(mir, lower_bound, verify_bound)),\n         }\n     }\n "}, {"sha": "0ad6183960da93bd522c410fd5a039b9b210f23c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "patch": "@@ -11,7 +11,7 @@\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n+use borrow_check::nll::region_infer::TypeTest;\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -140,44 +140,15 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         &self,\n         generic_kind: GenericKind<'tcx>,\n         region: ty::Region<'tcx>,\n-        bound: VerifyBound<'tcx>,\n+        verify_bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n \n-        let test = self.verify_bound_to_region_test(&bound);\n-\n         TypeTest {\n             generic_kind,\n             lower_bound,\n             locations: self.locations,\n-            test,\n-        }\n-    }\n-\n-    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n-        match verify_bound {\n-            VerifyBound::IfEq(..) => {\n-                // FIXME: always false right now\n-                RegionTest::Any(vec![])\n-            }\n-\n-            VerifyBound::OutlivedBy(r) => RegionTest::IsOutlivedBy(\n-                self.to_region_vid(r)\n-            ),\n-\n-            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-\n-            VerifyBound::AllBounds(bounds) => RegionTest::All(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n+            verify_bound,\n         }\n     }\n "}]}