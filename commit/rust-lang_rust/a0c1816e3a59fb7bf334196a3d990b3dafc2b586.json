{"sha": "a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "node_id": "C_kwDOAAsO6NoAKGEwYzE4MTZlM2E1OWZiN2JmMzM0MTk2YTNkOTkwYjNkYWZjMmI1ODY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-03T17:51:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-03T17:55:30Z"}, "message": "Simplify", "tree": {"sha": "703ec57ef2a805b5138459ef3df42f218cdc5546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/703ec57ef2a805b5138459ef3df42f218cdc5546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "html_url": "https://github.com/rust-lang/rust/commit/a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98c0578f157fbd04af6106c658886bbeb1091f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/98c0578f157fbd04af6106c658886bbeb1091f1c", "html_url": "https://github.com/rust-lang/rust/commit/98c0578f157fbd04af6106c658886bbeb1091f1c"}], "stats": {"total": 219, "additions": 113, "deletions": 106}, "files": [{"sha": "7c6d72a031ebce85aa29d7b66118495ab6ecd5a2", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "patch": "@@ -32,74 +32,11 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         _ => return,\n     };\n \n-    let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);\n-    let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n-    let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock));\n-    let in_trait = matches!(kind, Some(ItemListKind::Trait));\n-    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl));\n-    let in_inherent_impl = matches!(kind, Some(ItemListKind::Impl));\n-    let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n-    let in_block = matches!(kind, None);\n-\n-    if in_trait_impl {\n+    if matches!(kind, Some(ItemListKind::TraitImpl)) {\n         trait_impl::complete_trait_impl(acc, ctx);\n     }\n-    let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n-\n-    'block: loop {\n-        if ctx.is_non_trivial_path() {\n-            break 'block;\n-        }\n-        if !in_trait_impl {\n-            if ctx.qualifier_ctx.unsafe_tok.is_some() {\n-                if in_item_list || in_assoc_non_trait_impl {\n-                    add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n-                }\n-                if in_item_list {\n-                    add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n-                    if no_qualifiers {\n-                        add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n-                    }\n-                }\n-                break 'block;\n-            }\n-\n-            if in_item_list {\n-                add_keyword(\"enum\", \"enum $1 {\\n    $0\\n}\");\n-                add_keyword(\"mod\", \"mod $0\");\n-                add_keyword(\"static\", \"static $0\");\n-                add_keyword(\"struct\", \"struct $0\");\n-                add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n-                add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n-                add_keyword(\"use\", \"use $0\");\n-                if no_qualifiers {\n-                    add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n-                }\n-            }\n \n-            if !in_trait && !in_block && no_qualifiers {\n-                add_keyword(\"pub(crate)\", \"pub(crate)\");\n-                add_keyword(\"pub(super)\", \"pub(super)\");\n-                add_keyword(\"pub\", \"pub\");\n-            }\n-\n-            if in_extern_block {\n-                add_keyword(\"fn\", \"fn $1($2);\");\n-            } else {\n-                if !in_inherent_impl {\n-                    if !in_trait {\n-                        add_keyword(\"extern\", \"extern $0\");\n-                    }\n-                    add_keyword(\"type\", \"type $0\");\n-                }\n-\n-                add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n-                add_keyword(\"unsafe\", \"unsafe\");\n-                add_keyword(\"const\", \"const $0\");\n-            }\n-        }\n-        break 'block;\n-    }\n+    add_keywords(acc, ctx, kind);\n \n     if kind.is_none() {\n         // this is already handled by expression\n@@ -132,3 +69,68 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         None => {}\n     }\n }\n+\n+fn add_keywords(acc: &mut Completions, ctx: &CompletionContext, kind: Option<&ItemListKind>) {\n+    if ctx.is_non_trivial_path() {\n+        return;\n+    }\n+    let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n+\n+    let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);\n+    let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n+    let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock));\n+    let in_trait = matches!(kind, Some(ItemListKind::Trait));\n+    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl));\n+    let in_inherent_impl = matches!(kind, Some(ItemListKind::Impl));\n+    let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n+    let in_block = matches!(kind, None);\n+\n+    if !in_trait_impl {\n+        if ctx.qualifier_ctx.unsafe_tok.is_some() {\n+            if in_item_list || in_assoc_non_trait_impl {\n+                add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+            }\n+            if in_item_list {\n+                add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+                if no_qualifiers {\n+                    add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n+                }\n+            }\n+            return;\n+        }\n+\n+        if in_item_list {\n+            add_keyword(\"enum\", \"enum $1 {\\n    $0\\n}\");\n+            add_keyword(\"mod\", \"mod $0\");\n+            add_keyword(\"static\", \"static $0\");\n+            add_keyword(\"struct\", \"struct $0\");\n+            add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+            add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n+            add_keyword(\"use\", \"use $0\");\n+            if no_qualifiers {\n+                add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n+            }\n+        }\n+\n+        if !in_trait && !in_block && no_qualifiers {\n+            add_keyword(\"pub(crate)\", \"pub(crate)\");\n+            add_keyword(\"pub(super)\", \"pub(super)\");\n+            add_keyword(\"pub\", \"pub\");\n+        }\n+\n+        if in_extern_block {\n+            add_keyword(\"fn\", \"fn $1($2);\");\n+        } else {\n+            if !in_inherent_impl {\n+                if !in_trait {\n+                    add_keyword(\"extern\", \"extern $0\");\n+                }\n+                add_keyword(\"type\", \"type $0\");\n+            }\n+\n+            add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+            add_keyword(\"unsafe\", \"unsafe\");\n+            add_keyword(\"const\", \"const $0\");\n+        }\n+    }\n+}"}, {"sha": "8a2bbae73f4c42dddc6d798be0834fb5860c481f", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "patch": "@@ -43,7 +43,10 @@ use syntax::{\n use text_edit::TextEdit;\n \n use crate::{\n-    context::{ItemListKind, NameContext, NameKind, NameRefContext, PathCompletionCtx, PathKind},\n+    context::{\n+        IdentContext, ItemListKind, NameContext, NameKind, NameRefContext, PathCompletionCtx,\n+        PathKind,\n+    },\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n@@ -78,47 +81,49 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n }\n \n fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, TextRange, ast::Impl)> {\n-    let token = ctx.token.clone();\n-\n-    if let Some(NameContext { name, kind, .. }) = ctx.name_ctx() {\n-        let kind = match kind {\n-            NameKind::Const => ImplCompletionKind::Const,\n-            NameKind::Function => ImplCompletionKind::Fn,\n-            NameKind::TypeAlias => ImplCompletionKind::TypeAlias,\n-            _ => return None,\n-        };\n-        let item = match name {\n-            Some(name) => name.syntax().parent(),\n-            None => {\n-                if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n-                    .parent()\n-            }\n-        }?;\n-        return Some((\n-            kind,\n-            replacement_range(ctx, &item),\n-            // item -> ASSOC_ITEM_LIST -> IMPL\n-            ast::Impl::cast(item.parent()?.parent()?)?,\n-        ));\n-    } else if let Some(NameRefContext {\n-        nameref,\n-        path_ctx:\n-            Some(PathCompletionCtx { kind: PathKind::Item { kind: ItemListKind::TraitImpl }, .. }),\n-        ..\n-    }) = ctx.nameref_ctx()\n-    {\n-        if !ctx.is_non_trivial_path() {\n-            return Some((\n-                ImplCompletionKind::All,\n-                match nameref {\n-                    Some(name) => name.syntax().text_range(),\n-                    None => TextRange::empty(ctx.position.offset),\n-                },\n-                ctx.impl_def.clone()?,\n-            ));\n+    match &ctx.ident_ctx {\n+        IdentContext::Name(NameContext { name, kind, .. }) => {\n+            let kind = match kind {\n+                NameKind::Const => ImplCompletionKind::Const,\n+                NameKind::Function => ImplCompletionKind::Fn,\n+                NameKind::TypeAlias => ImplCompletionKind::TypeAlias,\n+                _ => return None,\n+            };\n+            let token = ctx.token.clone();\n+            let item = match name {\n+                Some(name) => name.syntax().parent(),\n+                None => {\n+                    if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n+                        .parent()\n+                }\n+            }?;\n+            Some((\n+                kind,\n+                replacement_range(ctx, &item),\n+                // item -> ASSOC_ITEM_LIST -> IMPL\n+                ast::Impl::cast(item.parent()?.parent()?)?,\n+            ))\n         }\n+        IdentContext::NameRef(NameRefContext {\n+            nameref,\n+            path_ctx:\n+                Some(\n+                    path_ctx @ PathCompletionCtx {\n+                        kind: PathKind::Item { kind: ItemListKind::TraitImpl },\n+                        ..\n+                    },\n+                ),\n+            ..\n+        }) if path_ctx.is_trivial_path() => Some((\n+            ImplCompletionKind::All,\n+            match nameref {\n+                Some(name) => name.syntax().text_range(),\n+                None => TextRange::empty(ctx.position.offset),\n+            },\n+            ctx.impl_def.clone()?,\n+        )),\n+        _ => None,\n     }\n-    None\n }\n \n fn add_function_impl("}, {"sha": "d41ca88e890980fb97c7010ae4b2b4405366f33d", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c1816e3a59fb7bf334196a3d990b3dafc2b586/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a0c1816e3a59fb7bf334196a3d990b3dafc2b586", "patch": "@@ -109,7 +109,7 @@ pub(crate) struct PathCompletionCtx {\n }\n \n impl PathCompletionCtx {\n-    fn is_trivial_path(&self) -> bool {\n+    pub(super) fn is_trivial_path(&self) -> bool {\n         matches!(\n             self,\n             PathCompletionCtx {"}]}