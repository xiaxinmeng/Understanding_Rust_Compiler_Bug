{"sha": "b545751597a8cdeee4554338318f0ed6339634fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NDU3NTE1OTdhOGNkZWVlNDU1NDMzODMxOGYwZWQ2MzM5NjM0ZmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-06T19:38:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Rework the idle callback to have a safer interface\n\nIt turns out that the uv implementation would cause use-after-free if the idle\ncallback was used after the call to `close`, and additionally nothing would ever\nreally work that well if `start()` were called twice. To change this, the\n`start` and `close` methods were removed in favor of specifying the callback at\ncreation, and allowing destruction to take care of closing the watcher.", "tree": {"sha": "e59d2c56af2c4547641b9b83b4b7939ee3a25f0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e59d2c56af2c4547641b9b83b4b7939ee3a25f0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b545751597a8cdeee4554338318f0ed6339634fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b545751597a8cdeee4554338318f0ed6339634fd", "html_url": "https://github.com/rust-lang/rust/commit/b545751597a8cdeee4554338318f0ed6339634fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b545751597a8cdeee4554338318f0ed6339634fd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08aadcc9aff233165a063df73c6436e0969f79c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08aadcc9aff233165a063df73c6436e0969f79c", "html_url": "https://github.com/rust-lang/rust/commit/d08aadcc9aff233165a063df73c6436e0969f79c"}], "stats": {"total": 165, "additions": 79, "deletions": 86}, "files": [{"sha": "b3527ce9fb4215eac74f88afbffe80ac5af23e9d", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=b545751597a8cdeee4554338318f0ed6339634fd", "patch": "@@ -19,11 +19,11 @@ pub struct IdleWatcher {\n     handle: *uvll::uv_idle_t,\n     idle_flag: bool,\n     closed: bool,\n-    callback: Option<~Callback>,\n+    callback: ~Callback,\n }\n \n impl IdleWatcher {\n-    pub fn new(loop_: &mut Loop) -> ~IdleWatcher {\n+    pub fn new(loop_: &mut Loop, cb: ~Callback) -> ~IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         assert_eq!(unsafe {\n             uvll::uv_idle_init(loop_.handle, handle)\n@@ -32,7 +32,7 @@ impl IdleWatcher {\n             handle: handle,\n             idle_flag: false,\n             closed: false,\n-            callback: None,\n+            callback: cb,\n         };\n         return me.install();\n     }\n@@ -64,12 +64,6 @@ impl IdleWatcher {\n }\n \n impl PausibleIdleCallback for IdleWatcher {\n-    fn start(&mut self, cb: ~Callback) {\n-        assert!(self.callback.is_none());\n-        self.callback = Some(cb);\n-        assert_eq!(unsafe { uvll::uv_idle_start(self.handle, idle_cb) }, 0)\n-        self.idle_flag = true;\n-    }\n     fn pause(&mut self) {\n         if self.idle_flag == true {\n             assert_eq!(unsafe {uvll::uv_idle_stop(self.handle) }, 0);\n@@ -82,84 +76,93 @@ impl PausibleIdleCallback for IdleWatcher {\n             self.idle_flag = true;\n         }\n     }\n-    fn close(&mut self) {\n-        self.pause();\n-        if !self.closed {\n-            self.closed = true;\n-            self.close_async_();\n-        }\n-    }\n }\n \n impl UvHandle<uvll::uv_idle_t> for IdleWatcher {\n     fn uv_handle(&self) -> *uvll::uv_idle_t { self.handle }\n }\n \n extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+    if status == uvll::ECANCELED { return }\n     assert_eq!(status, 0);\n     let idle: &mut IdleWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n-    assert!(idle.callback.is_some());\n-    idle.callback.get_mut_ref().call();\n+    idle.callback.call();\n+}\n+\n+impl Drop for IdleWatcher {\n+    fn drop(&mut self) {\n+        self.pause();\n+        self.close_async_();\n+    }\n }\n \n #[cfg(test)]\n mod test {\n-\n-    use Loop;\n     use super::*;\n-    use std::unstable::run_in_bare_thread;\n+    use std::rt::tube::Tube;\n+    use std::rt::rtio::{Callback, PausibleIdleCallback};\n+    use super::super::run_uv_loop;\n+\n+    struct MyCallback(Tube<int>, int);\n+    impl Callback for MyCallback {\n+        fn call(&mut self) {\n+            match *self {\n+                MyCallback(ref mut tube, val) => tube.send(val)\n+            }\n+        }\n+    }\n \n     #[test]\n-    #[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n-    fn idle_new_then_close() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let idle_watcher = { IdleWatcher::new(&mut loop_) };\n-            idle_watcher.close(||());\n+    fn not_used() {\n+        do run_uv_loop |l| {\n+            let cb = ~MyCallback(Tube::new(), 1);\n+            let _idle = IdleWatcher::new(l, cb as ~Callback);\n         }\n     }\n \n     #[test]\n-    fn idle_smoke_test() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-            let mut count = 10;\n-            let count_ptr: *mut int = &mut count;\n-            do idle_watcher.start |idle_watcher, status| {\n-                let mut idle_watcher = idle_watcher;\n-                assert!(status.is_none());\n-                if unsafe { *count_ptr == 10 } {\n-                    idle_watcher.stop();\n-                    idle_watcher.close(||());\n-                } else {\n-                    unsafe { *count_ptr = *count_ptr + 1; }\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-            assert_eq!(count, 10);\n+    fn smoke_test() {\n+        do run_uv_loop |l| {\n+            let mut tube = Tube::new();\n+            let cb = ~MyCallback(tube.clone(), 1);\n+            let mut idle = IdleWatcher::new(l, cb as ~Callback);\n+            idle.resume();\n+            tube.recv();\n         }\n     }\n \n     #[test]\n-    fn idle_start_stop_start() {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-            do idle_watcher.start |idle_watcher, status| {\n-                let mut idle_watcher = idle_watcher;\n-                assert!(status.is_none());\n-                idle_watcher.stop();\n-                do idle_watcher.start |idle_watcher, status| {\n-                    assert!(status.is_none());\n-                    let mut idle_watcher = idle_watcher;\n-                    idle_watcher.stop();\n-                    idle_watcher.close(||());\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n+    fn fun_combinations_of_methods() {\n+        do run_uv_loop |l| {\n+            let mut tube = Tube::new();\n+            let cb = ~MyCallback(tube.clone(), 1);\n+            let mut idle = IdleWatcher::new(l, cb as ~Callback);\n+            idle.resume();\n+            tube.recv();\n+            idle.pause();\n+            idle.resume();\n+            idle.resume();\n+            tube.recv();\n+            idle.pause();\n+            idle.pause();\n+            idle.resume();\n+            tube.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn pause_pauses() {\n+        do run_uv_loop |l| {\n+            let mut tube = Tube::new();\n+            let cb = ~MyCallback(tube.clone(), 1);\n+            let mut idle1 = IdleWatcher::new(l, cb as ~Callback);\n+            let cb = ~MyCallback(tube.clone(), 2);\n+            let mut idle2 = IdleWatcher::new(l, cb as ~Callback);\n+            idle2.resume();\n+            assert_eq!(tube.recv(), 2);\n+            idle2.pause();\n+            idle1.resume();\n+            assert_eq!(tube.recv(), 1);\n         }\n     }\n }"}, {"sha": "6ae2c174e18b45abadf7fd044ce40ec4d4876021", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=b545751597a8cdeee4554338318f0ed6339634fd", "patch": "@@ -148,8 +148,8 @@ impl EventLoop for UvEventLoop {\n         IdleWatcher::onetime(self.uvio.uv_loop(), f);\n     }\n \n-    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n-        IdleWatcher::new(self.uvio.uv_loop()) as ~PausibleIdleCallback\n+    fn pausible_idle_callback(&mut self, cb: ~Callback) -> ~PausibleIdleCallback {\n+        IdleWatcher::new(self.uvio.uv_loop(), cb) as ~PausibleIdleCallback\n     }\n \n     fn remote_callback(&mut self, f: ~Callback) -> ~RemoteCallback {"}, {"sha": "322c58bc2b807539e657a65e73f08987d53f5ec0", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=b545751597a8cdeee4554338318f0ed6339634fd", "patch": "@@ -107,7 +107,7 @@ impl BasicLoop {\n             match self.idle {\n                 Some(idle) => {\n                     if (*idle).active {\n-                        (*idle).work.get_mut_ref().call();\n+                        (*idle).work.call();\n                     }\n                 }\n                 None => {}\n@@ -150,8 +150,8 @@ impl EventLoop for BasicLoop {\n     }\n \n     // XXX: Seems like a really weird requirement to have an event loop provide.\n-    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n-        let callback = ~BasicPausible::new(self);\n+    fn pausible_idle_callback(&mut self, cb: ~Callback) -> ~PausibleIdleCallback {\n+        let callback = ~BasicPausible::new(self, cb);\n         rtassert!(self.idle.is_none());\n         unsafe {\n             let cb_ptr: &*mut BasicPausible = cast::transmute(&callback);\n@@ -204,36 +204,27 @@ impl Drop for BasicRemote {\n \n struct BasicPausible {\n     eloop: *mut BasicLoop,\n-    work: Option<~Callback>,\n+    work: ~Callback,\n     active: bool,\n }\n \n impl BasicPausible {\n-    fn new(eloop: &mut BasicLoop) -> BasicPausible {\n+    fn new(eloop: &mut BasicLoop, cb: ~Callback) -> BasicPausible {\n         BasicPausible {\n             active: false,\n-            work: None,\n+            work: cb,\n             eloop: eloop,\n         }\n     }\n }\n \n impl PausibleIdleCallback for BasicPausible {\n-    fn start(&mut self, f: ~Callback) {\n-        rtassert!(!self.active && self.work.is_none());\n-        self.active = true;\n-        self.work = Some(f);\n-    }\n     fn pause(&mut self) {\n         self.active = false;\n     }\n     fn resume(&mut self) {\n         self.active = true;\n     }\n-    fn close(&mut self) {\n-        self.active = false;\n-        self.work = None;\n-    }\n }\n \n impl Drop for BasicPausible {"}, {"sha": "1e12da8645ce76a21641eb7f98c325aaeac5678e", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b545751597a8cdeee4554338318f0ed6339634fd", "patch": "@@ -31,7 +31,7 @@ pub trait Callback {\n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, proc());\n-    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n+    fn pausible_idle_callback(&mut self, ~Callback) -> ~PausibleIdleCallback;\n     fn remote_callback(&mut self, ~Callback) -> ~RemoteCallback;\n \n     /// The asynchronous I/O services. Not all event loops may provide one\n@@ -226,10 +226,8 @@ pub trait RtioTTY {\n }\n \n pub trait PausibleIdleCallback {\n-    fn start(&mut self, f: ~Callback);\n     fn pause(&mut self);\n     fn resume(&mut self);\n-    fn close(&mut self);\n }\n \n pub trait RtioSignal {}"}, {"sha": "c2e665f4903073cda371dbb09d452d5542ab4969", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b545751597a8cdeee4554338318f0ed6339634fd/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=b545751597a8cdeee4554338318f0ed6339634fd", "patch": "@@ -169,7 +169,8 @@ impl Scheduler {\n     pub fn bootstrap(mut ~self, task: ~Task) {\n \n         // Build an Idle callback.\n-        self.idle_callback = Some(self.event_loop.pausible_idle_callback());\n+        let cb = ~SchedRunner as ~Callback;\n+        self.idle_callback = Some(self.event_loop.pausible_idle_callback(cb));\n \n         // Initialize the TLS key.\n         local_ptr::init_tls_key();\n@@ -184,7 +185,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        self.idle_callback.get_mut_ref().start(~SchedRunner as ~Callback);\n+        self.idle_callback.get_mut_ref().resume();\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n@@ -202,7 +203,7 @@ impl Scheduler {\n \n         // Close the idle callback.\n         let mut sched: ~Scheduler = Local::take();\n-        sched.idle_callback.get_mut_ref().close();\n+        sched.idle_callback.take();\n         // Make one go through the loop to run the close callback.\n         sched.run();\n "}]}