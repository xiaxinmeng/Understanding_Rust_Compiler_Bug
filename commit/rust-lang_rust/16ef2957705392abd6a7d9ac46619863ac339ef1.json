{"sha": "16ef2957705392abd6a7d9ac46619863ac339ef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZWYyOTU3NzA1MzkyYWJkNmE3ZDlhYzQ2NjE5ODYzYWMzMzllZjE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-04-29T02:54:03Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-05-20T15:12:48Z"}, "message": "Accumulation of various drive-by cosmetic changes.", "tree": {"sha": "7928600c47ef6cadee048ebea923fad52b1b89fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7928600c47ef6cadee048ebea923fad52b1b89fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16ef2957705392abd6a7d9ac46619863ac339ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16ef2957705392abd6a7d9ac46619863ac339ef1", "html_url": "https://github.com/rust-lang/rust/commit/16ef2957705392abd6a7d9ac46619863ac339ef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16ef2957705392abd6a7d9ac46619863ac339ef1/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "589beb979c0f1a9736e02e578913db88398c3ba5", "url": "https://api.github.com/repos/rust-lang/rust/commits/589beb979c0f1a9736e02e578913db88398c3ba5", "html_url": "https://github.com/rust-lang/rust/commit/589beb979c0f1a9736e02e578913db88398c3ba5"}], "stats": {"total": 96, "additions": 45, "deletions": 51}, "files": [{"sha": "d043a32f06bd108b71a13e564366a043668fd209", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -168,7 +168,7 @@ rustc_queries! {\n         query predicates_defined_on(_: DefId)\n             -> Lrc<ty::GenericPredicates<'tcx>> {}\n \n-        /// Returns the predicates written explicit by the user.\n+        /// Returns the predicates written explicitly by the user.\n         query explicit_predicates_of(_: DefId)\n             -> Lrc<ty::GenericPredicates<'tcx>> {}\n \n@@ -216,17 +216,17 @@ rustc_queries! {\n             _: DefId\n         ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}\n \n-        /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n-        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n-        /// the feature gate active)\n+        /// Returns `true` if this is a const fn, use the `is_const_fn` to know whether your crate\n+        /// actually sees it as const fn (e.g., the const-fn-ness might be unstable and you might\n+        /// not have the feature gate active).\n         ///\n         /// **Do not call this function manually.** It is only meant to cache the base data for the\n         /// `is_const_fn` function.\n         query is_const_fn_raw(key: DefId) -> bool {\n             desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n         }\n \n-        /// Returns true if calls to the function may be promoted\n+        /// Returns `true` if calls to the function may be promoted.\n         ///\n         /// This is either because the function is e.g., a tuple-struct or tuple-variant\n         /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n@@ -237,36 +237,34 @@ rustc_queries! {\n \n         query const_fn_is_allowed_fn_ptr(_: DefId) -> bool {}\n \n-        /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+        /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n         query is_foreign_item(_: DefId) -> bool {}\n \n         /// Returns `Some(mutability)` if the node pointed to by `def_id` is a static item.\n         query static_mutability(_: DefId) -> Option<hir::Mutability> {}\n \n-        /// Get a map with the variance of every item; use `item_variance`\n-        /// instead.\n+        /// Gets a map with the variance of every item; use `item_variance` instead.\n         query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap<'tcx>> {\n             desc { \"computing the variances for items in this crate\" }\n         }\n \n-        /// Maps from def-id of a type or region parameter to its\n-        /// (inferred) variance.\n+        /// Maps from def-ID of a type or region parameter to its (inferred) variance.\n         query variances_of(_: DefId) -> &'tcx [ty::Variance] {}\n     }\n \n     TypeChecking {\n-        /// Maps from def-id of a type to its (inferred) outlives.\n+        /// Maps from def-ID of a type to its (inferred) outlives.\n         query inferred_outlives_crate(_: CrateNum)\n             -> Lrc<ty::CratePredicatesMap<'tcx>> {\n             desc { \"computing the inferred outlives predicates for items in this crate\" }\n         }\n     }\n \n     Other {\n-        /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+        /// Maps from an impl/trait def-ID to a list of the def-ids of its items.\n         query associated_item_def_ids(_: DefId) -> Lrc<Vec<DefId>> {}\n \n-        /// Maps from a trait item to the trait item \"descriptor\"\n+        /// Maps from a trait item to the trait item \"descriptor\".\n         query associated_item(_: DefId) -> ty::AssociatedItem {}\n \n         query impl_trait_ref(_: DefId) -> Option<ty::TraitRef<'tcx>> {}\n@@ -276,7 +274,7 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        /// Maps a DefId of a type to a list of its inherent impls.\n+        /// Maps a def-ID of a type to a list of its inherent impls.\n         /// Contains implementations of methods that are inherent to a type.\n         /// Methods in these implementations don't need to be exported.\n         query inherent_impls(_: DefId) -> Lrc<Vec<DefId>> {\n@@ -300,7 +298,7 @@ rustc_queries! {\n             desc { |tcx| \"linting {}\", key.describe_as_module(tcx) }\n         }\n \n-        /// Checks the attributes in the module\n+        /// Checks the attributes in the module.\n         query check_mod_attrs(key: DefId) -> () {\n             desc { |tcx| \"checking attributes in {}\", key.describe_as_module(tcx) }\n         }\n@@ -309,7 +307,7 @@ rustc_queries! {\n             desc { |tcx| \"checking for unstable API usage in {}\", key.describe_as_module(tcx) }\n         }\n \n-        /// Checks the loops in the module\n+        /// Checks the loops in the module.\n         query check_mod_loops(key: DefId) -> () {\n             desc { |tcx| \"checking loops in {}\", key.describe_as_module(tcx) }\n         }\n@@ -338,7 +336,7 @@ rustc_queries! {\n             desc { |tcx| \"collecting item types in {}\", key.describe_as_module(tcx) }\n         }\n \n-        /// Caches CoerceUnsized kinds for impls on custom types.\n+        /// Caches `CoerceUnsized` kinds for impls on custom types.\n         query coerce_unsized_info(_: DefId)\n             -> ty::adjustment::CoerceUnsizedInfo {}\n     }\n@@ -375,7 +373,7 @@ rustc_queries! {\n     BorrowChecking {\n         query borrowck(_: DefId) -> Lrc<BorrowCheckResult> {}\n \n-        /// Borrow checks the function body. If this is a closure, returns\n+        /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n         query mir_borrowck(_: DefId) -> mir::BorrowCheckResult<'tcx> {}\n     }\n@@ -401,11 +399,11 @@ rustc_queries! {\n     }\n \n     Other {\n-        /// Evaluate a constant without running sanity checks\n+        /// Evaluates a constant without running sanity checks.\n         ///\n         /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n         /// during validation. Please add a comment to every use site explaining why using\n-        /// `const_eval` isn't sufficient\n+        /// `const_eval` isn't sufficient.\n         query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalRawResult<'tcx> {\n             no_force\n@@ -660,12 +658,12 @@ rustc_queries! {\n     }\n \n     Linking {\n-        // The DefIds of all non-generic functions and statics in the given crate\n+        // The `DefId`s of all non-generic functions and statics in the given crate\n         // that can be reached from outside the crate.\n         //\n         // We expect this items to be available for being linked to.\n         //\n-        // This query can also be called for LOCAL_CRATE. In this case it will\n+        // This query can also be called for `LOCAL_CRATE`. In this case it will\n         // compute which items will be reachable to other crates, taking into account\n         // the kind of crate that is currently compiled. Crates with only a\n         // C interface have fewer reachable things."}, {"sha": "578d8bbedf39e0881783fa7dc999471ae4758f61", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -123,12 +123,10 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // Predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let mut predicates: Vec<_> =\n-                    predicates.predicates\n-                              .iter()\n-                              .map(|(p, _)| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n-                              .collect();\n-\n+                let mut predicates: Vec<_> = predicates.predicates\n+                    .iter()\n+                    .map(|(pred, _)| pred.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n+                    .collect();\n                 debug!(\"super_predicates: data={:?} predicates={:?}\",\n                        data, predicates);\n \n@@ -150,8 +148,8 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // predicates.\n             }\n             ty::Predicate::Subtype(..) => {\n-                // Currently, we do not \"elaborate\" predicates like `X\n-                // <: Y`, though conceivably we might.\n+                // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n+                // though conceivably we might.\n             }\n             ty::Predicate::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate."}, {"sha": "c55e508c8b5295d2d0f9541ad53a9ab8cd403291", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -1075,25 +1075,25 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Predicate<'tcx> {\n-    /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n+    /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where `'a: 'b`\n+    /// `where 'a: 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n-    /// where `T: 'a`\n+    /// `where T: 'a`\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n \n-    /// where `<T as TraitRef>::Name == X`, approximately.\n+    /// `where <T as TraitRef>::Name == X`, approximately.\n     /// See the `ProjectionPredicate` struct for details.\n     Projection(PolyProjectionPredicate<'tcx>),\n \n     /// no syntax: `T` well-formed\n     WellFormed(Ty<'tcx>),\n \n-    /// trait must be object-safe\n+    /// Trait must be object-safe.\n     ObjectSafe(DefId),\n \n     /// No direct syntax. May be thought of as `where T: FnFoo<...>`"}, {"sha": "be52b7e6451982d21aeb0df0ab282b7e2dff5ecf", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -100,8 +100,7 @@ pub use self::on_disk_cache::OnDiskCache;\n \n rustc_query_append! { [define_queries!][ <'tcx>\n     Other {\n-        /// Run analysis passes on the crate\n+        /// Runs analysis passes on the crate.\n         [] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n-\n     },\n ]}"}, {"sha": "32d182edfdcdebbc231b0fbea5b131d141e1af1d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -1502,7 +1502,6 @@ enum StorageDeadOrDrop<'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-\n     /// Adds a suggestion when a closure is invoked twice with a moved variable or when a closure\n     /// is moved after being invoked.\n     ///"}, {"sha": "06605695630f391ce03038ed0b2a1c91d0ba11e3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -702,7 +702,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n \n     /// Instantiates the path for the given trait reference, assuming that it's\n-    /// bound to a valid trait type. Returns the def_id for the defining trait.\n+    /// bound to a valid trait type. Returns the def-ID for the defining trait.\n     /// The type _cannot_ be a type other than a trait type.\n     ///\n     /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T = X>`\n@@ -1035,7 +1035,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                         pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n \n                     // If the projection output contains `Self`, force the user to\n-                    // elaborate it explicitly to avoid a bunch of complexity.\n+                    // elaborate it explicitly to avoid a lot of complexity.\n                     //\n                     // The \"classicaly useful\" case is the following:\n                     // ```\n@@ -1044,14 +1044,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     //     }\n                     // ```\n                     //\n-                    // Here, the user could theoretically write `dyn MyTrait<Output=X>`,\n+                    // Here, the user could theoretically write `dyn MyTrait<Output = X>`,\n                     // but actually supporting that would \"expand\" to an infinitely-long type\n-                    // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput=X, Output=<\u03c4 as MyTrait>::MyOutput`.\n+                    // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput = X, Output = <\u03c4 as MyTrait>::MyOutput`.\n                     //\n-                    // Instead, we force the user to write `dyn MyTrait<MyOutput=X, Output=X>`,\n+                    // Instead, we force the user to write `dyn MyTrait<MyOutput = X, Output = X>`,\n                     // which is uglier but works. See the discussion in #56288 for alternatives.\n                     if !references_self {\n-                        // Include projections defined on supertraits,\n+                        // Include projections defined on supertraits.\n                         projection_bounds.push((pred, DUMMY_SP))\n                     }\n                 }\n@@ -2138,7 +2138,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<(ty::Predicate<'tcx>, Span)>\n     {\n-        // If it could be sized, and is, add the sized predicate.\n+        // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {\n                 let trait_ref = ty::TraitRef {"}, {"sha": "104c8e25d138f9554e17e19b926b779545a11021", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef2957705392abd6a7d9ac46619863ac339ef1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=16ef2957705392abd6a7d9ac46619863ac339ef1", "patch": "@@ -684,9 +684,9 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n     tcx.alloc_adt_def(def_id, kind, variants, repr)\n }\n \n-/// Ensures that the super-predicates of the trait with `DefId`\n-/// trait_def_id are converted and stored. This also ensures that\n-/// the transitive super-predicates are converted;\n+/// Ensures that the super-predicates of the trait with a `DefId`\n+/// of `trait_def_id` are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted.\n fn super_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_def_id: DefId,\n@@ -707,14 +707,14 @@ fn super_predicates_of<'a, 'tcx>(\n \n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo : Bar + Zed`.\n+    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n     let self_param_ty = tcx.mk_self_type();\n     let superbounds1 = compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n-    // Convert any explicit superbounds in the where clause,\n-    // e.g., `trait Foo where Self : Bar`.\n+    // Convert any explicit superbounds in the wheree-clause,\n+    // e.g., `trait Foo where Self: Bar`.\n     // In the case of trait aliases, however, we include all bounds in the where clause,\n     // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n     // as one of its \"superpredicates\"."}]}