{"sha": "4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "node_id": "C_kwDOAAsO6NoAKDRmZjliZWRiZWRiNmRlZGY0NmUwM2Q3Y2UyNjQ4ZTI0NTE0ZjliYTg", "commit": {"author": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2022-06-20T10:48:09Z"}, "committer": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2022-06-20T10:48:09Z"}, "message": "Display witnesses of non-exhaustive match\n\nReporting format follows rustc and shows at most three witnesses.", "tree": {"sha": "c31e9b7948f15e39967277fa77cc2a4bf5dbd146", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c31e9b7948f15e39967277fa77cc2a4bf5dbd146"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "html_url": "https://github.com/rust-lang/rust/commit/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad6810e90bf89a4ef0ae21349d077050bc2a4fa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6810e90bf89a4ef0ae21349d077050bc2a4fa2", "html_url": "https://github.com/rust-lang/rust/commit/ad6810e90bf89a4ef0ae21349d077050bc2a4fa2"}], "stats": {"total": 400, "additions": 320, "deletions": 80}, "files": [{"sha": "e9743b4dfe7c7c8d46e51ddbadf0211eb4c9f46a", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "patch": "@@ -4,9 +4,10 @@\n \n use std::sync::Arc;\n \n-use hir_def::{path::path, resolver::HasResolver, AssocItemId, DefWithBodyId, HasModule};\n+use hir_def::{path::path, resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId, HasModule};\n use hir_expand::name;\n use itertools::Either;\n+use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use typed_arena::Arena;\n \n@@ -17,7 +18,8 @@ use crate::{\n         deconstruct_pat::DeconstructedPat,\n         usefulness::{compute_match_usefulness, MatchCheckCtx},\n     },\n-    InferenceResult, TyExt,\n+    display::HirDisplay,\n+    InferenceResult, Ty, TyExt,\n };\n \n pub(crate) use hir_def::{\n@@ -37,6 +39,7 @@ pub enum BodyValidationDiagnostic {\n     },\n     MissingMatchArms {\n         match_expr: ExprId,\n+        uncovered_patterns: String,\n     },\n }\n \n@@ -211,10 +214,11 @@ impl ExprValidator {\n         // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200\n \n         let witnesses = report.non_exhaustiveness_witnesses;\n-        // FIXME Report witnesses\n-        // eprintln!(\"compute_match_usefulness(..) -> {:?}\", &witnesses);\n         if !witnesses.is_empty() {\n-            self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms { match_expr: id });\n+            self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms {\n+                match_expr: id,\n+                uncovered_patterns: missing_match_arms(&cx, match_expr_ty, witnesses, arms),\n+            });\n         }\n     }\n \n@@ -367,3 +371,40 @@ fn types_of_subpatterns_do_match(pat: PatId, body: &Body, infer: &InferenceResul\n     walk(pat, body, infer, &mut has_type_mismatches);\n     !has_type_mismatches\n }\n+\n+fn missing_match_arms<'p>(\n+    cx: &MatchCheckCtx<'_, 'p>,\n+    scrut_ty: &Ty,\n+    witnesses: Vec<DeconstructedPat<'p>>,\n+    arms: &[MatchArm],\n+) -> String {\n+    let non_empty_enum = match scrut_ty.as_adt() {\n+        Some((AdtId::EnumId(e), _)) => !cx.db.enum_data(e).variants.is_empty(),\n+        _ => false,\n+    };\n+    if arms.is_empty() && !non_empty_enum {\n+        format!(\"type `{}` is non-empty\", scrut_ty.display(cx.db))\n+    } else {\n+        const LIMIT: usize = 3;\n+        match &*witnesses {\n+            [witness] => format!(\"`{}` not covered\", witness.to_pat(&cx).display(cx.db)),\n+            [head @ .., tail] if head.len() < LIMIT => {\n+                let head: Vec<_> = head.iter().map(|w| w.to_pat(cx)).collect();\n+                format!(\n+                    \"`{}` and `{}` not covered\",\n+                    head.iter().map(|p| p.display(cx.db)).join(\"`, `\"),\n+                    tail.to_pat(&cx).display(cx.db)\n+                )\n+            }\n+            _ => {\n+                let (head, tail) = witnesses.split_at(LIMIT);\n+                let head: Vec<_> = head.iter().map(|w| w.to_pat(cx)).collect();\n+                format!(\n+                    \"`{}` and {} more not covered\",\n+                    head.iter().map(|p| p.display(cx.db)).join(\"`, `\"),\n+                    tail.len()\n+                )\n+            }\n+        }\n+    }\n+}"}, {"sha": "276246f266c8ad598a099220f913848864fd51a0", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 135, "deletions": 5, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "patch": "@@ -10,11 +10,19 @@ mod pat_util;\n pub(crate) mod deconstruct_pat;\n pub(crate) mod usefulness;\n \n-use hir_def::{body::Body, expr::PatId, EnumVariantId, LocalFieldId, VariantId};\n+use chalk_ir::Mutability;\n+use hir_def::{\n+    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, HasModule, LocalFieldId,\n+    VariantId,\n+};\n+use hir_expand::name::{name, Name};\n use stdx::{always, never};\n \n use crate::{\n-    db::HirDatabase, infer::BindingMode, InferenceResult, Interner, Substitution, Ty, TyKind,\n+    db::HirDatabase,\n+    display::{HirDisplay, HirDisplayError, HirFormatter},\n+    infer::BindingMode,\n+    InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n };\n \n use self::pat_util::EnumerateAndAdjustIterator;\n@@ -49,6 +57,7 @@ pub(crate) enum PatKind {\n \n     /// `x`, `ref x`, `x @ P`, etc.\n     Binding {\n+        name: Name,\n         subpattern: Option<Pat>,\n     },\n \n@@ -148,7 +157,7 @@ impl<'a> PatCtxt<'a> {\n                     }\n                     _ => (),\n                 }\n-                PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n+                PatKind::Binding { name: name.clone(), subpattern: self.lower_opt_pattern(subpat) }\n             }\n \n             hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n@@ -282,6 +291,127 @@ impl<'a> PatCtxt<'a> {\n     }\n }\n \n+impl HirDisplay for Pat {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match &*self.kind {\n+            PatKind::Wild => write!(f, \"_\"),\n+            PatKind::Binding { name, subpattern } => {\n+                write!(f, \"{name}\")?;\n+                if let Some(subpattern) = subpattern {\n+                    write!(f, \" @ \")?;\n+                    subpattern.hir_fmt(f)?;\n+                }\n+                Ok(())\n+            }\n+            PatKind::Variant { subpatterns, .. } | PatKind::Leaf { subpatterns } => {\n+                let variant = match *self.kind {\n+                    PatKind::Variant { enum_variant, .. } => Some(VariantId::from(enum_variant)),\n+                    _ => self.ty.as_adt().and_then(|(adt, _)| match adt {\n+                        AdtId::StructId(s) => Some(s.into()),\n+                        AdtId::UnionId(u) => Some(u.into()),\n+                        AdtId::EnumId(_) => None,\n+                    }),\n+                };\n+\n+                if let Some(variant) = variant {\n+                    match variant {\n+                        VariantId::EnumVariantId(v) => {\n+                            let data = f.db.enum_data(v.parent);\n+                            write!(f, \"{}\", data.variants[v.local_id].name)?;\n+                        }\n+                        VariantId::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n+                        VariantId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name)?,\n+                    };\n+\n+                    let variant_data = variant.variant_data(f.db.upcast());\n+                    if let VariantData::Record(rec_fields) = &*variant_data {\n+                        write!(f, \" {{ \")?;\n+\n+                        let mut printed = 0;\n+                        let subpats = subpatterns\n+                            .iter()\n+                            .filter(|p| !matches!(*p.pattern.kind, PatKind::Wild))\n+                            .map(|p| {\n+                                printed += 1;\n+                                WriteWith(move |f| {\n+                                    write!(f, \"{}: \", rec_fields[p.field].name)?;\n+                                    p.pattern.hir_fmt(f)\n+                                })\n+                            });\n+                        f.write_joined(subpats, \", \")?;\n+\n+                        if printed < rec_fields.len() {\n+                            write!(f, \"{}..\", if printed > 0 { \", \" } else { \"\" })?;\n+                        }\n+\n+                        return write!(f, \" }}\");\n+                    }\n+                }\n+\n+                let num_fields = variant\n+                    .map_or(subpatterns.len(), |v| v.variant_data(f.db.upcast()).fields().len());\n+                if num_fields != 0 || variant.is_none() {\n+                    write!(f, \"(\")?;\n+                    let subpats = (0..num_fields).map(|i| {\n+                        WriteWith(move |f| {\n+                            let fid = LocalFieldId::from_raw((i as u32).into());\n+                            if let Some(p) = subpatterns.get(i) {\n+                                if p.field == fid {\n+                                    return p.pattern.hir_fmt(f);\n+                                }\n+                            }\n+                            if let Some(p) = subpatterns.iter().find(|p| p.field == fid) {\n+                                p.pattern.hir_fmt(f)\n+                            } else {\n+                                write!(f, \"_\")\n+                            }\n+                        })\n+                    });\n+                    f.write_joined(subpats, \", \")?;\n+                    if let (TyKind::Tuple(..), 1) = (self.ty.kind(Interner), num_fields) {\n+                        write!(f, \",\")?;\n+                    }\n+                    write!(f, \")\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            PatKind::Deref { subpattern } => {\n+                match self.ty.kind(Interner) {\n+                    TyKind::Adt(adt, _) if is_box(adt.0, f.db) => write!(f, \"box \")?,\n+                    &TyKind::Ref(mutbl, ..) => {\n+                        write!(f, \"&{}\", if mutbl == Mutability::Mut { \"mut \" } else { \"\" })?\n+                    }\n+                    _ => never!(\"{:?} is a bad Deref pattern type\", self.ty),\n+                }\n+                subpattern.hir_fmt(f)\n+            }\n+            PatKind::LiteralBool { value } => write!(f, \"{}\", value),\n+            PatKind::Or { pats } => f.write_joined(pats.iter(), \" | \"),\n+        }\n+    }\n+}\n+\n+struct WriteWith<F>(F)\n+where\n+    F: Fn(&mut HirFormatter) -> Result<(), HirDisplayError>;\n+\n+impl<F> HirDisplay for WriteWith<F>\n+where\n+    F: Fn(&mut HirFormatter) -> Result<(), HirDisplayError>,\n+{\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        (self.0)(f)\n+    }\n+}\n+\n+fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n+    let owned_box = name![owned_box].to_smol_str();\n+    let krate = adt.module(db.upcast()).krate();\n+    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    Some(adt) == box_adt\n+}\n+\n pub(crate) trait PatternFoldable: Sized {\n     fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n@@ -357,8 +487,8 @@ impl PatternFoldable for PatKind {\n     fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n         match self {\n             PatKind::Wild => PatKind::Wild,\n-            PatKind::Binding { subpattern } => {\n-                PatKind::Binding { subpattern: subpattern.fold_with(folder) }\n+            PatKind::Binding { name, subpattern } => {\n+                PatKind::Binding { name: name.clone(), subpattern: subpattern.fold_with(folder) }\n             }\n             PatKind::Variant { substs, enum_variant, subpatterns } => PatKind::Variant {\n                 substs: substs.fold_with(folder),"}, {"sha": "7011ed9f10687a902192354e23e9db5b33a285c9", "filename": "crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 87, "deletions": 20, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "patch": "@@ -51,13 +51,13 @@ use std::{\n use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n use stdx::never;\n-use syntax::SmolStr;\n \n use crate::{infer::normalize, AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n \n use super::{\n+    is_box,\n     usefulness::{helper::Captures, MatchCheckCtx, PatCtxt},\n-    Pat, PatKind,\n+    FieldPat, Pat, PatKind,\n };\n \n use self::Constructor::*;\n@@ -144,6 +144,24 @@ impl IntRange {\n         }\n     }\n \n+    fn to_pat(&self, _cx: &MatchCheckCtx, ty: Ty) -> Pat {\n+        match ty.kind(Interner) {\n+            TyKind::Scalar(Scalar::Bool) => {\n+                let kind = match self.boundaries() {\n+                    (0, 0) => PatKind::LiteralBool { value: false },\n+                    (1, 1) => PatKind::LiteralBool { value: true },\n+                    (0, 1) => PatKind::Wild,\n+                    (lo, hi) => {\n+                        never!(\"bad range for bool pattern: {}..={}\", lo, hi);\n+                        PatKind::Wild\n+                    }\n+                };\n+                Pat { ty, kind: kind.into() }\n+            }\n+            _ => unimplemented!(),\n+        }\n+    }\n+\n     /// See `Constructor::is_covered_by`\n     fn is_covered_by(&self, other: &Self) -> bool {\n         if self.intersection(other).is_some() {\n@@ -363,7 +381,7 @@ impl Constructor {\n                 TyKind::Tuple(arity, ..) => arity,\n                 TyKind::Ref(..) => 1,\n                 TyKind::Adt(adt, ..) => {\n-                    if adt_is_box(adt.0, pcx.cx) {\n+                    if is_box(adt.0, pcx.cx.db) {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         1\n@@ -782,7 +800,7 @@ impl<'p> Fields<'p> {\n                 }\n                 TyKind::Ref(.., rty) => Fields::wildcards_from_tys(cx, once(rty.clone())),\n                 &TyKind::Adt(AdtId(adt), ref substs) => {\n-                    if adt_is_box(adt, cx) {\n+                    if is_box(adt, cx.db) {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         let subst_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n@@ -865,8 +883,8 @@ impl<'p> DeconstructedPat<'p> {\n         let ctor;\n         let fields;\n         match pat.kind.as_ref() {\n-            PatKind::Binding { subpattern: Some(subpat) } => return mkpat(subpat),\n-            PatKind::Binding { subpattern: None } | PatKind::Wild => {\n+            PatKind::Binding { subpattern: Some(subpat), .. } => return mkpat(subpat),\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {\n                 ctor = Wildcard;\n                 fields = Fields::empty();\n             }\n@@ -889,7 +907,7 @@ impl<'p> DeconstructedPat<'p> {\n                         }\n                         fields = Fields::from_iter(cx, wilds)\n                     }\n-                    TyKind::Adt(adt, substs) if adt_is_box(adt.0, cx) => {\n+                    TyKind::Adt(adt, substs) if is_box(adt.0, cx.db) => {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n@@ -963,10 +981,67 @@ impl<'p> DeconstructedPat<'p> {\n         DeconstructedPat::new(ctor, fields, pat.ty.clone())\n     }\n \n-    // // FIXME(iDawer): implement reporting of noncovered patterns\n-    // pub(crate) fn to_pat(&self, _cx: &MatchCheckCtx<'_, 'p>) -> Pat {\n-    //     Pat { ty: self.ty.clone(), kind: PatKind::Wild.into() }\n-    // }\n+    pub(crate) fn to_pat(&self, cx: &MatchCheckCtx<'_, 'p>) -> Pat {\n+        let mut subpatterns = self.iter_fields().map(|p| p.to_pat(cx));\n+        let pat = match &self.ctor {\n+            Single | Variant(_) => match self.ty.kind(Interner) {\n+                TyKind::Tuple(..) => PatKind::Leaf {\n+                    subpatterns: subpatterns\n+                        .zip(0u32..)\n+                        .map(|(p, i)| FieldPat {\n+                            field: LocalFieldId::from_raw(i.into()),\n+                            pattern: p,\n+                        })\n+                        .collect(),\n+                },\n+                TyKind::Adt(adt, _) if is_box(adt.0, cx.db) => {\n+                    // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n+                    // of `std`). So this branch is only reachable when the feature is enabled and\n+                    // the pattern is a box pattern.\n+                    PatKind::Deref { subpattern: subpatterns.next().unwrap() }\n+                }\n+                TyKind::Adt(adt, substs) => {\n+                    let variant = self.ctor.variant_id_for_adt(adt.0);\n+                    let subpatterns = Fields::list_variant_nonhidden_fields(cx, self.ty(), variant)\n+                        .zip(subpatterns)\n+                        .map(|((field, _ty), pattern)| FieldPat { field, pattern })\n+                        .collect();\n+\n+                    if let VariantId::EnumVariantId(enum_variant) = variant {\n+                        PatKind::Variant { substs: substs.clone(), enum_variant, subpatterns }\n+                    } else {\n+                        PatKind::Leaf { subpatterns }\n+                    }\n+                }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to reconstruct the correct constant pattern here. However a string\n+                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n+                // ignore this issue.\n+                TyKind::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n+                _ => {\n+                    never!(\"unexpected ctor for type {:?} {:?}\", self.ctor, self.ty);\n+                    PatKind::Wild\n+                }\n+            },\n+            &Slice(Slice { _unimplemented: _void }) => unimplemented!(),\n+            &Str(_void) => unimplemented!(),\n+            &FloatRange(_void) => unimplemented!(),\n+            IntRange(range) => return range.to_pat(cx, self.ty.clone()),\n+            Wildcard | NonExhaustive => PatKind::Wild,\n+            Missing { .. } => {\n+                never!(\n+                    \"trying to convert a `Missing` constructor into a `Pat`; this is probably a bug,\n+                    `Missing` should have been processed in `apply_constructors`\"\n+                );\n+                PatKind::Wild\n+            }\n+            Opaque | Or => {\n+                never!(\"can't convert to pattern: {:?}\", self.ctor);\n+                PatKind::Wild\n+            }\n+        };\n+        Pat { ty: self.ty.clone(), kind: Box::new(pat) }\n+    }\n \n     pub(super) fn is_or_pat(&self) -> bool {\n         matches!(self.ctor, Or)\n@@ -980,7 +1055,7 @@ impl<'p> DeconstructedPat<'p> {\n         &self.ty\n     }\n \n-    pub(super) fn iter_fields<'a>(&'a self) -> impl Iterator<Item = &'a DeconstructedPat<'a>> + 'a {\n+    pub(super) fn iter_fields<'a>(&'a self) -> impl Iterator<Item = &'p DeconstructedPat<'p>> + 'a {\n         self.fields.iter_patterns()\n     }\n \n@@ -1023,11 +1098,3 @@ fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_, '_\n     };\n     cx.db.attrs(attr_def_id).by_key(\"non_exhaustive\").exists()\n }\n-\n-fn adt_is_box(adt: hir_def::AdtId, cx: &MatchCheckCtx<'_, '_>) -> bool {\n-    use hir_def::lang_item::LangItemTarget;\n-    match cx.db.lang_item(cx.module.krate(), SmolStr::new_inline(\"owned_box\")) {\n-        Some(LangItemTarget::StructId(box_id)) => adt == box_id.into(),\n-        _ => false,\n-    }\n-}"}, {"sha": "00a6d4584f9e10646586f2db358289c7b553ebf9", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "patch": "@@ -150,6 +150,7 @@ pub struct MismatchedArgCount {\n pub struct MissingMatchArms {\n     pub file: HirFileId,\n     pub match_expr: AstPtr<ast::Expr>,\n+    pub uncovered_patterns: String,\n }\n \n #[derive(Debug)]"}, {"sha": "1d2912b9ddffe0d976247d8524425a58b83969a6", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "patch": "@@ -1295,7 +1295,7 @@ impl DefWithBody {\n                         );\n                     }\n                 }\n-                BodyValidationDiagnostic::MissingMatchArms { match_expr } => {\n+                BodyValidationDiagnostic::MissingMatchArms { match_expr, uncovered_patterns } => {\n                     match source_map.expr_syntax(match_expr) {\n                         Ok(source_ptr) => {\n                             let root = source_ptr.file_syntax(db.upcast());\n@@ -1307,6 +1307,7 @@ impl DefWithBody {\n                                         MissingMatchArms {\n                                             file: source_ptr.file_id,\n                                             match_expr: AstPtr::new(&match_expr),\n+                                            uncovered_patterns,\n                                         }\n                                         .into(),\n                                     );"}, {"sha": "9e66fbfb7522439995e301b9c1b638b720a3f564", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=4ff9bedbedb6dedf46e03d7ce2648e24514f9ba8", "patch": "@@ -11,7 +11,7 @@ pub(crate) fn missing_match_arms(\n ) -> Diagnostic {\n     Diagnostic::new(\n         \"missing-match-arm\",\n-        \"missing match arm\",\n+        format!(\"missing match arm: {}\", d.uncovered_patterns),\n         ctx.sema.diagnostics_display_range(InFile::new(d.file, d.match_expr.clone().into())).range,\n     )\n }\n@@ -31,9 +31,9 @@ mod tests {\n             r#\"\n fn main() {\n     match () { }\n-        //^^ error: missing match arm\n+        //^^ error: missing match arm: type `()` is non-empty\n     match (()) { }\n-        //^^^^ error: missing match arm\n+        //^^^^ error: missing match arm: type `()` is non-empty\n \n     match () { _ => (), }\n     match () { () => (), }\n@@ -49,7 +49,7 @@ fn main() {\n             r#\"\n fn main() {\n     match ((), ()) { }\n-        //^^^^^^^^ error: missing match arm\n+        //^^^^^^^^ error: missing match arm: type `((), ())` is non-empty\n \n     match ((), ()) { ((), ()) => (), }\n }\n@@ -63,21 +63,21 @@ fn main() {\n             r#\"\n fn test_main() {\n     match false { }\n-        //^^^^^ error: missing match arm\n+        //^^^^^ error: missing match arm: type `bool` is non-empty\n     match false { true => (), }\n-        //^^^^^ error: missing match arm\n+        //^^^^^ error: missing match arm: `false` not covered\n     match (false, true) {}\n-        //^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^ error: missing match arm: type `(bool, bool)` is non-empty\n     match (false, true) { (true, true) => (), }\n-        //^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^ error: missing match arm: `(false, _)` not covered\n     match (false, true) {\n-        //^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^ error: missing match arm: `(true, true)` not covered\n         (false, true) => (),\n         (false, false) => (),\n         (true, false) => (),\n     }\n     match (false, true) { (true, _x) => (), }\n-        //^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^ error: missing match arm: `(false, _)` not covered\n \n     match false { true => (), false => (), }\n     match (false, true) {\n@@ -116,11 +116,11 @@ fn test_main() {\n             r#\"\n fn main() {\n     match (false, ((), false)) {}\n-        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm: type `(bool, ((), bool))` is non-empty\n     match (false, ((), false)) { (true, ((), true)) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `(false, _)` not covered\n     match (false, ((), false)) { (true, _) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `(false, _)` not covered\n \n     match (false, ((), false)) {\n         (true, ((), true)) => (),\n@@ -146,12 +146,12 @@ enum Either { A, B, }\n \n fn main() {\n     match Either::A { }\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `A` and `B` not covered\n     match Either::B { Either::A => (), }\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `B` not covered\n \n     match &Either::B {\n-        //^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^ error: missing match arm: `&B` not covered\n         Either::A => (),\n     }\n \n@@ -174,9 +174,9 @@ enum Either { A(bool), B }\n \n fn main() {\n     match Either::B { }\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `A(_)` and `B` not covered\n     match Either::B {\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `A(false)` not covered\n         Either::A(true) => (), Either::B => ()\n     }\n \n@@ -207,7 +207,7 @@ enum Either { A(bool), B(bool, bool) }\n \n fn main() {\n     match Either::A(false) {\n-        //^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^ error: missing match arm: `B(true, _)` not covered\n         Either::A(_) => (),\n         Either::B(false, _) => (),\n     }\n@@ -353,7 +353,7 @@ fn main() {\n         Either::A => (),\n     }\n     match loop { break Foo::A } {\n-        //^^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `B` not covered\n         Either::A => (),\n     }\n     match loop { break Foo::A } {\n@@ -391,17 +391,17 @@ enum Either { A { foo: bool }, B }\n fn main() {\n     let a = Either::A { foo: true };\n     match a { }\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `A { .. }` and `B` not covered\n     match a { Either::A { foo: true } => () }\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `B` not covered\n     match a {\n         Either::A { } => (),\n       //^^^^^^^^^ \ud83d\udca1 error: missing structure fields:\n       //        | - foo\n         Either::B => (),\n     }\n     match a {\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `B` not covered\n         Either::A { } => (),\n     } //^^^^^^^^^ \ud83d\udca1 error: missing structure fields:\n       //        | - foo\n@@ -432,7 +432,7 @@ enum Either {\n fn main() {\n     let a = Either::A { foo: true, bar: () };\n     match a {\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `B` not covered\n         Either::A { bar: (), foo: false } => (),\n         Either::A { foo: true, bar: () } => (),\n     }\n@@ -459,12 +459,12 @@ enum Either {\n fn main() {\n     let a = Either::B;\n     match a {\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `A { foo: false, .. }` not covered\n         Either::A { foo: true, .. } => (),\n         Either::B => (),\n     }\n     match a {\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `B` not covered\n         Either::A { .. } => (),\n     }\n \n@@ -494,14 +494,14 @@ enum Either {\n \n fn main() {\n     match Either::B {\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `A(false, _, _, true)` not covered\n         Either::A(true, .., true) => (),\n         Either::A(true, .., false) => (),\n         Either::A(false, .., false) => (),\n         Either::B => (),\n     }\n     match Either::B {\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `A(false, _, _, false)` not covered\n         Either::A(true, .., true) => (),\n         Either::A(true, .., false) => (),\n         Either::A(.., true) => (),\n@@ -538,7 +538,7 @@ fn enum_(never: Never) {\n }\n fn enum_ref(never: &Never) {\n     match never {}\n-        //^^^^^ error: missing match arm\n+        //^^^^^ error: missing match arm: type `&Never` is non-empty\n }\n fn bang(never: !) {\n     match never {}\n@@ -562,7 +562,7 @@ fn main() {\n         Some(never) => match never {},\n     }\n     match Option::<Never>::None {\n-        //^^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `None` not covered\n         Option::Some(_never) => {},\n     }\n }\n@@ -576,7 +576,7 @@ fn main() {\n             r#\"\n fn main() {\n     match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `(true, _, _)` not covered\n         (false, ..) => (),\n     }\n }\"#,\n@@ -589,7 +589,7 @@ fn main() {\n             r#\"\n fn main() {\n     match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `(_, _, true)` not covered\n         (.., false) => (),\n     }\n }\"#,\n@@ -602,7 +602,7 @@ fn main() {\n             r#\"\n fn main() {\n     match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^^^^^^^^^^^^ error: missing match arm: `(false, _, _)` not covered\n         (true, .., false) => (),\n     }\n }\"#,\n@@ -615,11 +615,11 @@ fn main() {\n             r#\"struct Foo { a: bool }\n fn main(f: Foo) {\n     match f {}\n-        //^ error: missing match arm\n+        //^ error: missing match arm: type `Foo` is non-empty\n     match f { Foo { a: true } => () }\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `Foo { a: false }` not covered\n     match &f { Foo { a: true } => () }\n-        //^^ error: missing match arm\n+        //^^ error: missing match arm: `&Foo { a: false }` not covered\n     match f { Foo { a: _ } => () }\n     match f {\n         Foo { a: true } => (),\n@@ -640,9 +640,9 @@ fn main(f: Foo) {\n             r#\"struct Foo(bool);\n fn main(f: Foo) {\n     match f {}\n-        //^ error: missing match arm\n+        //^ error: missing match arm: type `Foo` is non-empty\n     match f { Foo(true) => () }\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `Foo(false)` not covered\n     match f {\n         Foo(true) => (),\n         Foo(false) => (),\n@@ -658,7 +658,7 @@ fn main(f: Foo) {\n             r#\"struct Foo;\n fn main(f: Foo) {\n     match f {}\n-        //^ error: missing match arm\n+        //^ error: missing match arm: type `Foo` is non-empty\n     match f { Foo => () }\n }\n \"#,\n@@ -671,9 +671,9 @@ fn main(f: Foo) {\n             r#\"struct Foo { foo: bool, bar: bool }\n fn main(f: Foo) {\n     match f { Foo { foo: true, .. } => () }\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `Foo { foo: false, .. }` not covered\n     match f {\n-        //^ error: missing match arm\n+        //^ error: missing match arm: `Foo { foo: false, bar: true }` not covered\n         Foo { foo: true, .. } => (),\n         Foo { bar: false, .. } => ()\n     }\n@@ -694,7 +694,7 @@ fn main(f: Foo) {\n fn main() {\n     enum Either { A(bool), B }\n     match Either::B {\n-        //^^^^^^^^^ error: missing match arm\n+        //^^^^^^^^^ error: missing match arm: `B` not covered\n         Either::A(true | false) => (),\n     }\n }\n@@ -716,7 +716,7 @@ fn main(v: S) {\n     match v { S{..}       => {} }\n     match v { _           => {} }\n     match v { }\n-        //^ error: missing match arm\n+        //^ error: missing match arm: type `S` is non-empty\n }\n \"#,\n         );\n@@ -732,7 +732,7 @@ fn main() {\n         false     => {}\n     }\n     match true { _x @ true => {} }\n-        //^^^^ error: missing match arm\n+        //^^^^ error: missing match arm: `false` not covered\n }\n \"#,\n         );\n@@ -787,12 +787,12 @@ use lib::E;\n fn main() {\n     match E::A { _ => {} }\n     match E::A {\n-        //^^^^ error: missing match arm\n+        //^^^^ error: missing match arm: `_` not covered\n         E::A => {}\n         E::B => {}\n     }\n     match E::A {\n-        //^^^^ error: missing match arm\n+        //^^^^ error: missing match arm: `_` not covered\n         E::A | E::B => {}\n     }\n }\n@@ -811,7 +811,7 @@ fn main() {\n         false         => {}\n     }\n     match true {\n-        //^^^^ error: missing match arm\n+        //^^^^ error: missing match arm: `true` not covered\n         true if false => {}\n         false         => {}\n     }\n@@ -876,7 +876,7 @@ struct Next<T: Trait>(T::Projection);\n static __: () = {\n     let n: Next<A> = Next(E::Foo);\n     match n { Next(E::Foo) => {} }\n-    //    ^ error: missing match arm\n+    //    ^ error: missing match arm: `Next(Bar)` not covered\n     match n { Next(E::Foo | E::Bar) => {} }\n     match n { Next(E::Foo | _     ) => {} }\n     match n { Next(_      | E::Bar) => {} }\n@@ -919,7 +919,7 @@ enum Enum {\n \n fn f(ty: Enum) {\n     match ty {\n-        //^^ error: missing match arm\n+        //^^ error: missing match arm: `Type3` not covered\n         m!() => (),\n     }\n "}]}