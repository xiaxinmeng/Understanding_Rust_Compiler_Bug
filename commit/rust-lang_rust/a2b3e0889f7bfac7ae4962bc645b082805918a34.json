{"sha": "a2b3e0889f7bfac7ae4962bc645b082805918a34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYjNlMDg4OWY3YmZhYzdhZTQ5NjJiYzY0NWIwODI4MDU5MThhMzQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-09-11T16:11:21Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-09-13T21:28:11Z"}, "message": "Fix nits and refactor creation of StorageLive blocks", "tree": {"sha": "661d68debc4b861e40423f35e52c5a01f9ca9a02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/661d68debc4b861e40423f35e52c5a01f9ca9a02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2b3e0889f7bfac7ae4962bc645b082805918a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b3e0889f7bfac7ae4962bc645b082805918a34", "html_url": "https://github.com/rust-lang/rust/commit/a2b3e0889f7bfac7ae4962bc645b082805918a34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2b3e0889f7bfac7ae4962bc645b082805918a34/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d97a7d259432e50bb1c9daaeb9e1174d51f2aaee", "url": "https://api.github.com/repos/rust-lang/rust/commits/d97a7d259432e50bb1c9daaeb9e1174d51f2aaee", "html_url": "https://github.com/rust-lang/rust/commit/d97a7d259432e50bb1c9daaeb9e1174d51f2aaee"}], "stats": {"total": 127, "additions": 52, "deletions": 75}, "files": [{"sha": "4aee97d05f2fb856157689156d58961d22624b28", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 52, "deletions": 75, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a2b3e0889f7bfac7ae4962bc645b082805918a34/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b3e0889f7bfac7ae4962bc645b082805918a34/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a2b3e0889f7bfac7ae4962bc645b082805918a34", "patch": "@@ -132,7 +132,6 @@ struct SuspensionPoint {\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n     storage_liveness: liveness::LocalSet,\n-    storage_live: Option<BasicBlock>,\n }\n \n struct TransformVisitor<'a, 'tcx: 'a> {\n@@ -146,8 +145,6 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     // Mapping from Local to (type of local, generator struct index)\n     remap: HashMap<Local, (Ty<'tcx>, usize)>,\n \n-    mir_local_count: usize,\n-\n     // A map from a suspension point in a block to the locals which have live storage at that point\n     storage_liveness: HashMap<BasicBlock, liveness::LocalSet>,\n \n@@ -253,24 +250,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             let state = if let Some(resume) = resume { // Yield\n                 let state = 3 + self.suspension_points.len() as u32;\n \n-                let liveness = self.storage_liveness.get(&block).unwrap();\n-\n-                for i in 0..(self.mir_local_count) {\n-                    let l = Local::new(i);\n-                    if liveness.contains(&l) && !self.remap.contains_key(&l) {\n-                        data.statements.push(Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(l),\n-                        });\n-                    }\n-                }\n-\n                 self.suspension_points.push(SuspensionPoint {\n                     state,\n                     resume,\n                     drop,\n-                    storage_liveness: liveness.clone(),\n-                    storage_live: None,\n+                    storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n                 });\n \n                 state\n@@ -363,8 +347,8 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ignored.visit_mir(mir);\n \n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let result = liveness::liveness_of_locals(mir);\n-    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &result);\n+    let liveness = liveness::liveness_of_locals(mir);\n+    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &liveness);\n \n     let mut storage_liveness_map = HashMap::new();\n \n@@ -375,20 +359,22 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 statement_index: data.statements.len(),\n             };\n \n-            let mut storage_liveness = state_for_location(loc, &analysis, &storage_live);\n+            let storage_liveness = state_for_location(loc, &analysis, &storage_live);\n \n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n+            let mut live_locals = storage_liveness;\n+\n             // Mark locals without storage statements as always live\n-            storage_liveness.union(&ignored.0);\n+            live_locals.union(&ignored.0);\n \n             // Locals live are live at this point only if they are used across suspension points\n             // and their storage is live\n-            storage_liveness.intersect(&result.outs[block]);\n+            live_locals.intersect(&liveness.outs[block]);\n \n             // Add the locals life at this suspension point to the set of locals which live across\n             // any suspension points\n-            set.union(&storage_liveness);\n+            set.union(&live_locals);\n         }\n     }\n \n@@ -549,24 +535,11 @@ fn create_generator_drop_shim<'a, 'tcx>(\n \n     let source_info = source_info(&mir);\n \n-    let mut cases: Vec<_> = transform.suspension_points.iter().filter_map(|point| {\n-        point.drop.map(|drop| {\n-            // Make the point's storage live block goto the drop block\n-            let block = point.storage_live.unwrap();\n-            let term = Terminator {\n-                source_info,\n-                kind: TerminatorKind::Goto {\n-                    target: drop,\n-                },\n-            };\n-            mir.basic_blocks_mut()[block].terminator = Some(term);\n-            (point.state, block)\n-        })\n-    }).collect();\n+    let mut cases = create_cases(&mut mir, transform, |point| point.drop);\n \n     cases.insert(0, (0, drop_clean));\n \n-    // The returned state 1 and the  poisoned state 2 falls through to\n+    // The returned state (1) and the poisoned state (2) falls through to\n     // the default case which is just to return\n \n     insert_switch(tcx, &mut mir, cases, &transform);\n@@ -677,18 +650,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n         }\n     }\n \n-    let mut cases: Vec<_> = transform.suspension_points.iter().map(|point| {\n-        // Make the point's storage live block goto the resume block\n-        let block = point.storage_live.unwrap();\n-        let term = Terminator {\n-            source_info: source_info(mir),\n-            kind: TerminatorKind::Goto {\n-                target: point.resume,\n-            },\n-        };\n-        mir.basic_blocks_mut()[block].terminator = Some(term);\n-        (point.state, block)\n-    }).collect();\n+    let mut cases = create_cases(mir, &transform, |point| Some(point.resume));\n \n     // Jump to the entry point on the 0 state\n     cases.insert(0, (0, BasicBlock::new(0)));\n@@ -740,6 +702,46 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n+fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n+                          transform: &TransformVisitor<'a, 'tcx>,\n+                          target: F) -> Vec<(u32, BasicBlock)>\n+    where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n+    let source_info = source_info(mir);\n+\n+    transform.suspension_points.iter().filter_map(|point| {\n+        // Find the target for this suspension point, if applicable\n+        target(point).map(|target| {\n+            let block = BasicBlock::new(mir.basic_blocks().len());\n+            let mut statements = Vec::new();\n+\n+            // Create StorageLive instructions for locals with live storage\n+            for i in 0..(mir.local_decls.len()) {\n+                let l = Local::new(i);\n+                if point.storage_liveness.contains(&l) && !transform.remap.contains_key(&l) {\n+                    statements.push(Statement {\n+                        source_info,\n+                        kind: StatementKind::StorageLive(l),\n+                    });\n+                }\n+            }\n+\n+            // Then jump to the real target\n+            mir.basic_blocks_mut().push(BasicBlockData {\n+                statements,\n+                terminator: Some(Terminator {\n+                    source_info,\n+                    kind: TerminatorKind::Goto {\n+                        target,\n+                    },\n+                }),\n+                is_cleanup: false,\n+            });\n+\n+            (point.state, block)\n+        })\n+    }).collect()\n+}\n+\n impl MirPass for StateTransform {\n     fn run_pass<'a, 'tcx>(&self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -792,7 +794,6 @@ impl MirPass for StateTransform {\n             state_substs,\n             remap,\n             storage_liveness,\n-            mir_local_count: mir.local_decls.len(),\n             suspension_points: Vec::new(),\n             new_ret_local,\n             state_field,\n@@ -820,30 +821,6 @@ impl MirPass for StateTransform {\n \n         dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n \n-        // Create StorageLive instruction blocks for suspension points\n-        for point in &mut transform.suspension_points {\n-            point.storage_live = Some(BasicBlock::new(mir.basic_blocks().len()));\n-            let source_info = source_info(mir);\n-            let mut statements = Vec::new();\n-            for i in 0..(transform.mir_local_count) {\n-                let l = Local::new(i);\n-                if point.storage_liveness.contains(&l) && !transform.remap.contains_key(&l) {\n-                    statements.push(Statement {\n-                        source_info,\n-                        kind: StatementKind::StorageLive(l),\n-                    });\n-                }\n-            }\n-            mir.basic_blocks_mut().push(BasicBlockData {\n-                statements,\n-                terminator: Some(Terminator {\n-                    source_info,\n-                    kind: TerminatorKind::Unreachable,\n-                }),\n-                is_cleanup: false,\n-            });\n-        }\n-\n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,\n             &transform,"}]}