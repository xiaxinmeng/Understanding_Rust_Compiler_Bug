{"sha": "304885d959cae6b1fd6cb9aa64b70df6269d04b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNDg4NWQ5NTljYWU2YjFmZDZjYjlhYTY0YjcwZGY2MjY5ZDA0YjQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-25T18:48:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-25T18:48:48Z"}, "message": "Rollup merge of #47460 - Mark-Simulacrum:bootstrap-check, r=alexcrichton\n\nAdd ./x.py check src/{libstd,libtest,librustc}\n\nThis currently only supports a limited subset of the full compilation,\nbut is likely 90% of what people will want and is possible without\nbuilding a full compiler (and also building LLVM). In theory, this means\nthat contributors who don't want to build LLVM now have an easy way to\ncompile locally, though running tests won't work.", "tree": {"sha": "f5b8e4879fc4cc5334fbe77a8a1de14a4321c8ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5b8e4879fc4cc5334fbe77a8a1de14a4321c8ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/304885d959cae6b1fd6cb9aa64b70df6269d04b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/304885d959cae6b1fd6cb9aa64b70df6269d04b4", "html_url": "https://github.com/rust-lang/rust/commit/304885d959cae6b1fd6cb9aa64b70df6269d04b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/304885d959cae6b1fd6cb9aa64b70df6269d04b4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bdef2f8fc8112b2b7119d248567e046c49f0fbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bdef2f8fc8112b2b7119d248567e046c49f0fbb", "html_url": "https://github.com/rust-lang/rust/commit/1bdef2f8fc8112b2b7119d248567e046c49f0fbb"}, {"sha": "6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "html_url": "https://github.com/rust-lang/rust/commit/6aeb1cfb64ea04e334d296bf9a47c659116c96bf"}], "stats": {"total": 3156, "additions": 1670, "deletions": 1486}, "files": [{"sha": "55d104b182698d3901e6c3433301cdc48e8094b3", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -125,11 +125,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n-        // Pass down incremental directory, if any.\n-        if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n-            cmd.arg(format!(\"-Zincremental={}\", dir));\n-        }\n-\n         let crate_name = args.windows(2)\n             .find(|a| &*a[0] == \"--crate-name\")\n             .unwrap();"}, {"sha": "ecf9c0a75903e514f0f06b5f322c8c4e7100759c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -602,6 +602,7 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n+        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2\"\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):"}, {"sha": "79058984b13523a0dd4795aaa9ca00f6daabd9f4", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -26,6 +26,7 @@ use util::{exe, libdir, add_lib_path};\n use {Build, Mode};\n use cache::{INTERNER, Interned, Cache};\n use check;\n+use test;\n use flags::Subcommand;\n use doc;\n use tool;\n@@ -230,6 +231,7 @@ impl<'a> ShouldRun<'a> {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Kind {\n     Build,\n+    Check,\n     Test,\n     Bench,\n     Dist,\n@@ -251,13 +253,13 @@ impl<'a> Builder<'a> {\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri),\n-            Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n-                check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Rustdoc,\n-                check::Linkcheck, check::Cargotest, check::Cargo, check::Rls, check::Docs,\n-                check::ErrorIndex, check::Distcheck, check::Rustfmt, check::Miri, check::Clippy,\n-                check::RustdocJS),\n-\n-            Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n+            Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n+            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::DefaultCompiletest,\n+                test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n+                test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n+                test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n+                test::RustdocJS),\n+            Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n                 doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n@@ -304,6 +306,7 @@ impl<'a> Builder<'a> {\n     pub fn run(build: &Build) {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n@@ -493,13 +496,14 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n         }\n \n+\n         if let Some(host_linker) = self.build.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n         if let Some(target_linker) = self.build.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if cmd != \"build\" {\n+        if cmd != \"build\" && cmd != \"check\" {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n         }\n \n@@ -566,8 +570,7 @@ impl<'a> Builder<'a> {\n         // not guaranteeing correctness across builds if the compiler\n         // is changing under your feet.`\n         if self.config.incremental && compiler.stage == 0 {\n-            let incr_dir = self.incremental_dir(compiler);\n-            cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n+            cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         }\n \n         if let Some(ref on_fail) = self.config.on_fail {"}, {"sha": "0bc82c4f9f2c2571235083bca558478f6eeaf536", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 80, "deletions": 1459, "changes": 1539, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,1535 +8,156 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementation of the test-related targets of the build system.\n-//!\n-//! This file implements the various regression test suites that we execute on\n-//! our CI.\n+//! Implementation of compiling the compiler and standard library, in \"check\" mode.\n \n-use std::collections::HashSet;\n-use std::env;\n-use std::ffi::OsString;\n-use std::iter;\n-use std::fmt;\n-use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n-use std::io::Read;\n-\n-use build_helper::{self, output};\n-\n-use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n-use cache::{INTERNER, Interned};\n-use compile;\n-use dist;\n-use native;\n-use tool::{self, Tool};\n-use util::{self, dylib_path, dylib_path_var};\n-use {Build, Mode};\n-use toolstate::ToolState;\n-\n-const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n-\n-/// The two modes of the test runner; tests or benchmarks.\n-#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n-pub enum TestKind {\n-    /// Run `cargo test`\n-    Test,\n-    /// Run `cargo bench`\n-    Bench,\n-}\n-\n-impl TestKind {\n-    // Return the cargo subcommand for this test kind\n-    fn subcommand(self) -> &'static str {\n-        match self {\n-            TestKind::Test => \"test\",\n-            TestKind::Bench => \"bench\",\n-        }\n-    }\n-}\n-\n-impl fmt::Display for TestKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            TestKind::Test => \"Testing\",\n-            TestKind::Bench => \"Benchmarking\",\n-        })\n-    }\n-}\n-\n-fn try_run(build: &Build, cmd: &mut Command) -> bool {\n-    if !build.fail_fast {\n-        if !build.try_run(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n-            failures.push(format!(\"{:?}\", cmd));\n-            return false;\n-        }\n-    } else {\n-        build.run(cmd);\n-    }\n-    true\n-}\n-\n-fn try_run_quiet(build: &Build, cmd: &mut Command) {\n-    if !build.fail_fast {\n-        if !build.try_run_quiet(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n-            failures.push(format!(\"{:?}\", cmd));\n-        }\n-    } else {\n-        build.run_quiet(cmd);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Linkcheck {\n-    host: Interned<String>,\n-}\n-\n-impl Step for Linkcheck {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` will verify the validity of all our links in the\n-    /// documentation to ensure we don't have a bunch of dead ones.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let host = self.host;\n-\n-        println!(\"Linkcheck ({})\", host);\n-\n-        builder.default_doc(None);\n-\n-        let _time = util::timeit();\n-        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n-                            .arg(build.out.join(host).join(\"doc\")));\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\").default_condition(builder.build.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Linkcheck { host: run.target });\n-    }\n-}\n+use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, add_to_sysroot};\n+use builder::{RunConfig, Builder, ShouldRun, Step};\n+use {Build, Compiler, Mode};\n+use cache::Interned;\n+use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Cargotest {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Cargotest {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/cargotest\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Cargotest {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n-    /// test` to ensure that we don't regress the test suites there.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n-\n-        // Note that this is a short, cryptic, and not scoped directory name. This\n-        // is currently to minimize the length of path on Windows where we otherwise\n-        // quickly run into path name limit constraints.\n-        let out_dir = build.out.join(\"ct\");\n-        t!(fs::create_dir_all(&out_dir));\n-\n-        let _time = util::timeit();\n-        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n-        try_run(build, cmd.arg(&build.initial_cargo)\n-                          .arg(&out_dir)\n-                          .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Cargo {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Cargo {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/cargo\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for `cargo` packaged with Rust.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(self.stage, self.host);\n-\n-        builder.ensure(tool::Cargo { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-        if !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n-        // available.\n-        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n-\n-        try_run(build, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rls {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Rls {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/rls\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for the rls.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rls\");\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rls\", ToolState::TestPass);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustfmt {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Rustfmt {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/rustfmt\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for rustfmt.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rustfmt\");\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rustfmt\", ToolState::TestPass);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Miri {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Miri {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let test_miri = run.builder.build.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(test_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for miri.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n-\n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-            // miri tests need to know about the stage sysroot\n-            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            cargo.env(\"MIRI_PATH\", miri);\n-\n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"miri\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test miri: could not build\");\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Clippy {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Clippy {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = false;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/clippy\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for clippy.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n-\n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-            // clippy tests need to know about the stage sysroot\n-            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n-            cargo.env(\"HOST_LIBS\", host_libs);\n-            // clippy tests need to find the driver\n-            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n-\n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test clippy: could not build\");\n-        }\n-    }\n-}\n-\n-fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n-    // Configure PATH to find the right rustc. NB. we have to use PATH\n-    // and not RUSTC because the Cargo test suite has tests that will\n-    // fail if rustc is not spelled `rustc`.\n-    let path = builder.sysroot(compiler).join(\"bin\");\n-    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n-    env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct RustdocJS {\n-    pub host: Interned<String>,\n+pub struct Std {\n     pub target: Interned<String>,\n }\n \n-impl Step for RustdocJS {\n+impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/test/rustdoc-js\")\n+        run.path(\"src/libstd\").krate(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(RustdocJS {\n-            host: run.host,\n+        run.builder.ensure(Std {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n-        if let Some(ref nodejs) = builder.config.nodejs {\n-            let mut command = Command::new(nodejs);\n-            command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n-            builder.ensure(::doc::Std {\n-                target: self.target,\n-                stage: builder.top_stage,\n-            });\n-            builder.run(&mut command);\n-        } else {\n-            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Tidy {\n-    host: Interned<String>,\n-}\n-\n-impl Step for Tidy {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n-\n-    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` checks up on various bits and pieces of style and\n-    /// otherwise just implements a few lint-like checks that are specific to the\n-    /// compiler itself.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let host = self.host;\n-\n-        let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check ({})\", host);\n-        let mut cmd = builder.tool_cmd(Tool::Tidy);\n-        cmd.arg(build.src.join(\"src\"));\n-        if !build.config.vendor {\n-            cmd.arg(\"--no-vendor\");\n-        }\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n-        try_run(build, &mut cmd);\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/tidy\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Tidy {\n-            host: run.builder.build.build,\n-        });\n-    }\n-}\n-\n-fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n-    build.out.join(host).join(\"test\")\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Test {\n-    path: &'static str,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-static DEFAULT_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n-    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n-    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n-    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n-    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n-    Test {\n-        path: \"src/test/run-pass-valgrind\",\n-        mode: \"run-pass-valgrind\",\n-        suite: \"run-pass-valgrind\"\n-    },\n-    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n-    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n-    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n-    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n-\n-    // What this runs varies depending on the native platform being apple\n-    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct DefaultCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for DefaultCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in DEFAULT_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(DefaultCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in DEFAULT_COMPILETESTS {\n-                run.builder.ensure(DefaultCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n-            }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-// Also default, but host-only.\n-static HOST_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n-    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n-    Test {\n-        path: \"src/test/compile-fail-fulldeps\",\n-        mode: \"compile-fail\",\n-        suite: \"compile-fail-fulldeps\",\n-    },\n-    Test {\n-        path: \"src/test/incremental-fulldeps\",\n-        mode: \"incremental\",\n-        suite: \"incremental-fulldeps\",\n-    },\n-    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n-    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n-\n-    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n-    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n-    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n-    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n-    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct HostCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for HostCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in HOST_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            HOST_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(HostCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in HOST_COMPILETESTS {\n-                if test.mode == \"pretty\" {\n-                    continue;\n-                }\n-                run.builder.ensure(HostCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n-            }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Compiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for Compiletest {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.never()\n-    }\n-\n-    /// Executes the `compiletest` tool to run a suite of tests.\n-    ///\n-    /// Compiles all tests with `compiler` for `target` with the specified\n-    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n-    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let compiler = self.compiler;\n         let target = self.target;\n-        let mode = self.mode;\n-        let suite = self.suite;\n-\n-        // Skip codegen tests if they aren't enabled in configuration.\n-        if !build.config.codegen_tests && suite == \"codegen\" {\n-            return;\n-        }\n-\n-        if suite == \"debuginfo\" {\n-            // Skip debuginfo tests on MSVC\n-            if build.build.contains(\"msvc\") {\n-                return;\n-            }\n-\n-            if mode == \"debuginfo-XXX\" {\n-                return if build.build.contains(\"apple\") {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-lldb\",\n-                        ..self\n-                    });\n-                } else {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-gdb\",\n-                        ..self\n-                    });\n-                };\n-            }\n-\n-            builder.ensure(dist::DebuggerScripts {\n-                sysroot: builder.sysroot(compiler),\n-                host: target\n-            });\n-        }\n-\n-        if suite.ends_with(\"fulldeps\") ||\n-            // FIXME: Does pretty need librustc compiled? Note that there are\n-            // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\" ||\n-            mode == \"rustdoc\" ||\n-            mode == \"run-make\" {\n-            builder.ensure(compile::Rustc { compiler, target });\n-        }\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        builder.ensure(native::TestHelpers { target });\n-        builder.ensure(RemoteCopyLibs { compiler, target });\n-\n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n-        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n-\n-        // compiletest currently has... a lot of arguments, so let's just pass all\n-        // of them!\n-\n-        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n-        cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n-\n-        // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" || mode == \"run-make\" {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n-        }\n-\n-        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n-        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n-        cmd.arg(\"--mode\").arg(mode);\n-        cmd.arg(\"--target\").arg(target);\n-        cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n-\n-        if let Some(ref nodejs) = build.config.nodejs {\n-            cmd.arg(\"--nodejs\").arg(nodejs);\n-        }\n-\n-        let mut flags = vec![\"-Crpath\".to_string()];\n-        if build.config.rust_optimize_tests {\n-            flags.push(\"-O\".to_string());\n-        }\n-        if build.config.rust_debuginfo_tests {\n-            flags.push(\"-g\".to_string());\n-        }\n-        flags.push(\"-Zmiri -Zunstable-options\".to_string());\n-        flags.push(build.config.cmd.rustc_args().join(\" \"));\n-\n-        if let Some(linker) = build.linker(target) {\n-            cmd.arg(\"--linker\").arg(linker);\n-        }\n-\n-        let hostflags = flags.clone();\n-        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n-\n-        let mut targetflags = flags.clone();\n-        targetflags.push(format!(\"-Lnative={}\",\n-                                 build.test_helpers_out(target).display()));\n-        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n-\n-        cmd.arg(\"--docck-python\").arg(build.python());\n-\n-        if build.build.ends_with(\"apple-darwin\") {\n-            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n-            // LLDB plugin's compiled module which only works with the system python\n-            // (namely not Homebrew-installed python)\n-            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n-        } else {\n-            cmd.arg(\"--lldb-python\").arg(build.python());\n-        }\n-\n-        if let Some(ref gdb) = build.config.gdb {\n-            cmd.arg(\"--gdb\").arg(gdb);\n-        }\n-        if let Some(ref vers) = build.lldb_version {\n-            cmd.arg(\"--lldb-version\").arg(vers);\n-        }\n-        if let Some(ref dir) = build.lldb_python_dir {\n-            cmd.arg(\"--lldb-python-dir\").arg(dir);\n-        }\n-\n-        cmd.args(&build.config.cmd.test_args());\n-\n-        if build.is_verbose() {\n-            cmd.arg(\"--verbose\");\n-        }\n-\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n-\n-        if build.config.llvm_enabled {\n-            let llvm_config = build.llvm_config(target);\n-            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-            cmd.arg(\"--llvm-version\").arg(llvm_version);\n-            if !build.is_rust_llvm(target) {\n-                cmd.arg(\"--system-llvm\");\n-            }\n-\n-            // Only pass correct values for these flags for the `run-make` suite as it\n-            // requires that a C++ compiler was configured which isn't always the case.\n-            if suite == \"run-make\" {\n-                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n-                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-                cmd.arg(\"--cc\").arg(build.cc(target))\n-                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n-                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n-                .arg(\"--llvm-components\").arg(llvm_components.trim())\n-                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n-                if let Some(ar) = build.ar(target) {\n-                    cmd.arg(\"--ar\").arg(ar);\n-                }\n-            }\n-        }\n-        if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n-            return;\n-        }\n+        let compiler = builder.compiler(0, build.build);\n \n-        if suite != \"run-make\" {\n-            cmd.arg(\"--cc\").arg(\"\")\n-               .arg(\"--cxx\").arg(\"\")\n-               .arg(\"--cflags\").arg(\"\")\n-               .arg(\"--llvm-components\").arg(\"\")\n-               .arg(\"--llvm-cxxflags\").arg(\"\");\n-        }\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n \n-        if build.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n-        }\n-\n-        // Running a C compiler on MSVC requires a few env vars to be set, to be\n-        // sure to set them here.\n-        //\n-        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n-        // rather than stomp over it.\n-        if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].env() {\n-                if k != \"PATH\" {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        build.add_rust_test_threads(&mut cmd);\n-\n-        if build.config.sanitizers {\n-            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n-        }\n-\n-        if build.config.profiler {\n-            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n-        }\n-\n-        cmd.arg(\"--adb-path\").arg(\"adb\");\n-        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n-        if target.contains(\"android\") {\n-            // Assume that cc for this target comes from the android sysroot\n-            cmd.arg(\"--android-cross-path\")\n-               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n-        } else {\n-            cmd.arg(\"--android-cross-path\").arg(\"\");\n-        }\n-\n-        build.ci_env.force_coloring_in_ci(&mut cmd);\n-\n-        let _time = util::timeit();\n-        try_run(build, &mut cmd);\n+        let out_dir = build.stage_out(compiler, Mode::Libstd);\n+        build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n+        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n+        std_cargo(build, &compiler, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &libstd_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Docs {\n-    compiler: Compiler,\n+pub struct Rustc {\n+    pub target: Interned<String>,\n }\n \n-impl Step for Docs {\n+impl Step for Rustc {\n     type Output = ();\n-    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/doc\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Docs {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n-    }\n-\n-    /// Run `rustdoc --test` for all documentation in `src/doc`.\n-    ///\n-    /// This will run all tests in our markdown documentation (e.g. the book)\n-    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n-    /// `compiler`.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n-\n-        // Do a breadth-first traversal of the `src/doc` directory and just run\n-        // tests for all files that end in `*.md`\n-        let mut stack = vec![build.src.join(\"src/doc\")];\n-        let _time = util::timeit();\n-        let _folder = build.fold_output(|| \"test_docs\");\n-\n-        while let Some(p) = stack.pop() {\n-            if p.is_dir() {\n-                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n-                continue\n-            }\n-\n-            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n-                continue;\n-            }\n-\n-            // The nostarch directory in the book is for no starch, and so isn't\n-            // guaranteed to build. We don't care if it doesn't build, so skip it.\n-            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n-                continue;\n-            }\n-\n-            markdown_test(builder, compiler, &p);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct ErrorIndex {\n-    compiler: Compiler,\n-}\n-\n-impl Step for ErrorIndex {\n-    type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/error_index_generator\")\n+        run.path(\"src/librustc\").krate(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(ErrorIndex {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n-    }\n-\n-    /// Run the error index generator tool to execute the tests located in the error\n-    /// index.\n-    ///\n-    /// The `error_index_generator` tool lives in `src/tools` and is used to\n-    /// generate a markdown file from the error indexes of the code base which is\n-    /// then passed to `rustdoc --test`.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n-\n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-\n-        let dir = testdir(build, compiler.host);\n-        t!(fs::create_dir_all(&dir));\n-        let output = dir.join(\"error-index.md\");\n-\n-        let _time = util::timeit();\n-        build.run(builder.tool_cmd(Tool::ErrorIndex)\n-                    .arg(\"markdown\")\n-                    .arg(&output)\n-                    .env(\"CFG_BUILD\", &build.build)\n-                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n-\n-        markdown_test(builder, compiler, &output);\n-    }\n-}\n-\n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n-    let build = builder.build;\n-    let mut file = t!(File::open(markdown));\n-    let mut contents = String::new();\n-    t!(file.read_to_string(&mut contents));\n-    if !contents.contains(\"```\") {\n-        return;\n-    }\n-\n-    println!(\"doc tests for: {}\", markdown.display());\n-    let mut cmd = builder.rustdoc_cmd(compiler.host);\n-    build.add_rust_test_threads(&mut cmd);\n-    cmd.arg(\"--test\");\n-    cmd.arg(markdown);\n-    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-\n-    let test_args = build.config.cmd.test_args().join(\" \");\n-    cmd.arg(\"--test-args\").arg(test_args);\n-\n-    if build.config.quiet_tests {\n-        try_run_quiet(build, &mut cmd);\n-    } else {\n-        try_run(build, &mut cmd);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct CrateLibrustc {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n-}\n-\n-impl Step for CrateLibrustc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"rustc-main\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-        let compiler = builder.compiler(builder.top_stage, run.host);\n-\n-        let make = |name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(CrateLibrustc {\n-                compiler,\n-                target: run.target,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n-\n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"rustc-main\") {\n-                if path.ends_with(krate_path) {\n-                    make(Some(name));\n-                }\n-            }\n-        } else {\n-            make(None);\n-        }\n-    }\n-\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Crate {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: Mode::Librustc,\n-            test_kind: self.test_kind,\n-            krate: self.krate,\n+        run.builder.ensure(Rustc {\n+            target: run.target,\n         });\n     }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Crate {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: Mode,\n-    test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n-}\n-\n-impl Step for Crate {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"std\").krate(\"test\")\n-    }\n \n-    fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-        let compiler = builder.compiler(builder.top_stage, run.host);\n-\n-        let make = |mode: Mode, name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(Crate {\n-                compiler,\n-                target: run.target,\n-                mode,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n-\n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"std\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libstd, Some(name));\n-                }\n-            }\n-            for (name, krate_path) in builder.crates(\"test\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libtest, Some(name));\n-                }\n-            }\n-        } else {\n-            make(Mode::Libstd, None);\n-            make(Mode::Libtest, None);\n-        }\n-    }\n-\n-    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n-    /// by a `Cargo.toml`\n-    ///\n-    /// This is what runs tests for crates like the standard library, compiler, etc.\n-    /// It essentially is the driver for running `cargo test`.\n+    /// Build the compiler.\n     ///\n-    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n-    /// arguments, and those arguments are discovered from `cargo metadata`.\n+    /// This will build the compiler for a particular stage of the build using\n+    /// the `compiler` targeting the `target` architecture. The artifacts\n+    /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let compiler = self.compiler;\n+        let compiler = builder.compiler(0, build.build);\n         let target = self.target;\n-        let mode = self.mode;\n-        let test_kind = self.test_kind;\n-        let krate = self.krate;\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        builder.ensure(RemoteCopyLibs { compiler, target });\n-\n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if build.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n-        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n-        let (name, root) = match mode {\n-            Mode::Libstd => {\n-                compile::std_cargo(build, &compiler, target, &mut cargo);\n-                (\"libstd\", \"std\")\n-            }\n-            Mode::Libtest => {\n-                compile::test_cargo(build, &compiler, target, &mut cargo);\n-                (\"libtest\", \"test\")\n-            }\n-            Mode::Librustc => {\n-                builder.ensure(compile::Rustc { compiler, target });\n-                compile::rustc_cargo(build, target, &mut cargo);\n-                (\"librustc\", \"rustc-main\")\n-            }\n-            _ => panic!(\"can only test libraries\"),\n-        };\n-        let root = INTERNER.intern_string(String::from(root));\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n-        });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n-                &compiler.host, target);\n-\n-        // Build up the base `cargo test` command.\n-        //\n-        // Pass in some standard flags then iterate over the graph we've discovered\n-        // in `cargo metadata` with the maps above and figure out what `-p`\n-        // arguments need to get passed.\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        match krate {\n-            Some(krate) => {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n-            None => {\n-                let mut visited = HashSet::new();\n-                let mut next = vec![root];\n-                while let Some(name) = next.pop() {\n-                    // Right now jemalloc and the sanitizer crates are\n-                    // target-specific crate in the sense that it's not present\n-                    // on all platforms. Custom skip it here for now, but if we\n-                    // add more this probably wants to get more generalized.\n-                    //\n-                    // Also skip `build_helper` as it's not compiled normally\n-                    // for target during the bootstrap and it's just meant to be\n-                    // a helper crate, not tested. If it leaks through then it\n-                    // ends up messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") &&\n-                       *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n-                       name != \"dlmalloc\" {\n-                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                    }\n-                    for dep in build.crates[&name].deps.iter() {\n-                        if visited.insert(dep) {\n-                            next.push(*dep);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // The tests are going to run with the *target* libraries, so we need to\n-        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n-        //\n-        // Note that to run the compiler we need to run with the *host* libraries,\n-        // but our wrapper scripts arrange for that to be the case anyway.\n-        let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n-        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n \n-        if build.config.quiet_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n+        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n-        let _time = util::timeit();\n-\n-        if target.contains(\"emscripten\") {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n-        } else if target.starts_with(\"wasm32\") {\n-            // On the wasm32-unknown-unknown target we're using LTO which is\n-            // incompatible with `-C prefer-dynamic`, so disable that here\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-            let node = build.config.nodejs.as_ref()\n-                .expect(\"nodejs not configured\");\n-            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n-                                 node.display(),\n-                                 build.src.display());\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n-        } else if build.remote_tested(target) {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      format!(\"{} run\",\n-                              builder.tool_exe(Tool::RemoteTestClient).display()));\n-        }\n-        try_run(build, &mut cargo);\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n+        rustc_cargo(build, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &librustc_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n-    host: Interned<String>,\n-    test_kind: TestKind,\n+pub struct Test {\n+    pub target: Interned<String>,\n }\n \n-impl Step for Rustdoc {\n+impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+        run.path(\"src/libtest\").krate(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-\n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n-\n-        builder.ensure(Rustdoc {\n-            host: run.host,\n-            test_kind,\n+        run.builder.ensure(Test {\n+            target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let test_kind = self.test_kind;\n-\n-        let compiler = builder.compiler(builder.top_stage, self.host);\n-        let target = compiler.host;\n-\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 target,\n-                                                 test_kind.subcommand(),\n-                                                 \"src/tools/rustdoc\");\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n-\n-        cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n-\n-        if build.config.quiet_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n-        let _time = util::timeit();\n+        let target = self.target;\n+        let compiler = builder.compiler(0, build.build);\n \n-        try_run(build, &mut cargo);\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libtest);\n+        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n+        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n+        test_cargo(build, &compiler, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &libtest_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n     }\n }\n \n-fn envify(s: &str) -> String {\n-    s.chars().map(|c| {\n-        match c {\n-            '-' => '_',\n-            c => c,\n-        }\n-    }).flat_map(|c| c.to_uppercase()).collect()\n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd-check.stamp\")\n }\n \n-/// Some test suites are run inside emulators or on remote devices, and most\n-/// of our test binaries are linked dynamically which means we need to ship\n-/// the standard library and such to the emulator ahead of time. This step\n-/// represents this and is a dependency of all test suites.\n-///\n-/// Most of the time this is a noop. For some steps such as shipping data to\n-/// QEMU we have to build our own tools so we've got conditional dependencies\n-/// on those programs as well. Note that the remote test client is built for\n-/// the build target (us) and the server is built for the target.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct RemoteCopyLibs {\n-    compiler: Compiler,\n-    target: Interned<String>,\n+/// Cargo's output path for libtest in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest-check.stamp\")\n }\n \n-impl Step for RemoteCopyLibs {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.never()\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-        let target = self.target;\n-        if !build.remote_tested(target) {\n-            return\n-        }\n-\n-        builder.ensure(compile::Test { compiler, target });\n-\n-        println!(\"REMOTE copy libs to emulator ({})\", target);\n-        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n-\n-        let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n-\n-        // Spawn the emulator and wait for it to come online\n-        let tool = builder.tool_exe(Tool::RemoteTestClient);\n-        let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\")\n-           .arg(target)\n-           .arg(&server)\n-           .arg(build.out.join(\"tmp\"));\n-        if let Some(rootfs) = build.qemu_rootfs(target) {\n-            cmd.arg(rootfs);\n-        }\n-        build.run(&mut cmd);\n-\n-        // Push all our dylibs to the emulator\n-        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n-            let f = t!(f);\n-            let name = f.file_name().into_string().unwrap();\n-            if util::is_dylib(&name) {\n-                build.run(Command::new(&tool)\n-                                  .arg(\"push\")\n-                                  .arg(f.path()));\n-            }\n-        }\n-    }\n+/// Cargo's output path for librustc in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Distcheck;\n-\n-impl Step for Distcheck {\n-    type Output = ();\n-    const ONLY_BUILD: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"distcheck\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Distcheck);\n-    }\n-\n-    /// Run \"distcheck\", a 'make check' from a tarball\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n-        println!(\"Distcheck\");\n-        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n-        let _ = fs::remove_dir_all(&dir);\n-        t!(fs::create_dir_all(&dir));\n-\n-        // Guarantee that these are built before we begin running.\n-        builder.ensure(dist::PlainSourceTarball);\n-        builder.ensure(dist::Src);\n-\n-        let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::PlainSourceTarball))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n-        build.run(&mut cmd);\n-        build.run(Command::new(\"./configure\")\n-                         .args(&build.config.configure_args)\n-                         .arg(\"--enable-vendor\")\n-                         .current_dir(&dir));\n-        build.run(Command::new(build_helper::make(&build.build))\n-                         .arg(\"check\")\n-                         .current_dir(&dir));\n-\n-        // Now make sure that rust-src has all of libstd's dependencies\n-        println!(\"Distcheck rust-src\");\n-        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n-        let _ = fs::remove_dir_all(&dir);\n-        t!(fs::create_dir_all(&dir));\n-\n-        let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::Src))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n-        build.run(&mut cmd);\n-\n-        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-        build.run(Command::new(&build.initial_cargo)\n-                         .arg(\"generate-lockfile\")\n-                         .arg(\"--manifest-path\")\n-                         .arg(&toml)\n-                         .current_dir(&dir));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Bootstrap;\n-\n-impl Step for Bootstrap {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n-\n-    /// Test the build system itself\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let mut cmd = Command::new(&build.initial_cargo);\n-        cmd.arg(\"test\")\n-           .current_dir(build.src.join(\"src/bootstrap\"))\n-           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-           .env(\"RUSTC\", &build.initial_rustc);\n-        if !build.fail_fast {\n-            cmd.arg(\"--no-fail-fast\");\n-        }\n-        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n-        try_run(build, &mut cmd);\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/bootstrap\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Bootstrap);\n-    }\n-}"}, {"sha": "21bbd82dd333a725df98687ff1ad0559ae54fc7b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -108,7 +108,8 @@ impl Step for Std {\n         std_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &libstd_stamp(build, compiler, target));\n+                  &libstd_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -360,7 +361,8 @@ impl Step for Test {\n         test_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &libtest_stamp(build, compiler, target));\n+                  &libtest_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(TestLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -488,7 +490,8 @@ impl Step for Rustc {\n         rustc_cargo(build, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &librustc_stamp(build, compiler, target));\n+                  &librustc_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(RustcLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -755,7 +758,7 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     for path in read_stamp_file(stamp) {\n         copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n@@ -785,7 +788,7 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n+pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool) {\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     cargo.arg(\"--message-format\").arg(\"json\")\n@@ -836,7 +839,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n-               !is_dylib(&filename) {\n+               !is_dylib(&filename) &&\n+               !(is_check && filename.ends_with(\".rmeta\")) {\n                 continue\n             }\n "}, {"sha": "478e496078add23a5b85842e820ecf78b41335c0", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -48,6 +48,9 @@ pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n     },\n+    Check {\n+        paths: Vec<PathBuf>,\n+    },\n     Doc {\n         paths: Vec<PathBuf>,\n     },\n@@ -88,6 +91,7 @@ Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n     build       Compile either the compiler or libraries\n+    check       Compile either the compiler or libraries, using cargo check\n     test        Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n@@ -128,6 +132,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         // there on out.\n         let subcommand = args.iter().find(|&s|\n             (s == \"build\")\n+            || (s == \"check\")\n             || (s == \"test\")\n             || (s == \"bench\")\n             || (s == \"doc\")\n@@ -217,6 +222,21 @@ Arguments:\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n+            }\n+            \"check\" => {\n+                subcommand_help.push_str(\"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to compile. For example:\n+\n+        ./x.py check src/libcore\n+        ./x.py check src/libcore src/libproc_macro\n+\n+    If no arguments are passed then the complete artifacts are compiled: std, test, and rustc. Note\n+    also that since we use `cargo check`, by default this will automatically enable incremental\n+    compilation, so there's no need to pass it separately, though it won't hurt. We also completely\n+    ignore the stage passed, as there's no way to compile in non-stage 0 without actually building\n+    the compiler.\");\n             }\n             \"test\" => {\n                 subcommand_help.push_str(\"\\n\n@@ -286,6 +306,9 @@ Arguments:\n             \"build\" => {\n                 Subcommand::Build { paths: paths }\n             }\n+            \"check\" => {\n+                Subcommand::Check { paths: paths }\n+            }\n             \"test\" => {\n                 Subcommand::Test {\n                     paths,"}, {"sha": "565320c95217639aa8a3182e22de466a1bf3b46d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -150,6 +150,7 @@ use util::{exe, libdir, OutputFolder, CiEnv};\n mod cc_detect;\n mod channel;\n mod check;\n+mod test;\n mod clean;\n mod compile;\n mod metadata;\n@@ -449,12 +450,6 @@ impl Build {\n         out\n     }\n \n-    /// Get the directory for incremental by-products when using the\n-    /// given compiler.\n-    fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n-        self.out.join(&*compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n-    }\n-\n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///"}, {"sha": "5faec27943847e5a63314d807667baeaa9e80866", "filename": "src/bootstrap/test.rs", "status": "added", "additions": 1542, "deletions": 0, "changes": 1542, "blob_url": "https://github.com/rust-lang/rust/blob/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/304885d959cae6b1fd6cb9aa64b70df6269d04b4/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=304885d959cae6b1fd6cb9aa64b70df6269d04b4", "patch": "@@ -0,0 +1,1542 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the test-related targets of the build system.\n+//!\n+//! This file implements the various regression test suites that we execute on\n+//! our CI.\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::ffi::OsString;\n+use std::iter;\n+use std::fmt;\n+use std::fs::{self, File};\n+use std::path::{PathBuf, Path};\n+use std::process::Command;\n+use std::io::Read;\n+\n+use build_helper::{self, output};\n+\n+use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n+use cache::{INTERNER, Interned};\n+use compile;\n+use dist;\n+use native;\n+use tool::{self, Tool};\n+use util::{self, dylib_path, dylib_path_var};\n+use {Build, Mode};\n+use toolstate::ToolState;\n+\n+const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n+\n+/// The two modes of the test runner; tests or benchmarks.\n+#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n+pub enum TestKind {\n+    /// Run `cargo test`\n+    Test,\n+    /// Run `cargo bench`\n+    Bench,\n+}\n+\n+impl TestKind {\n+    // Return the cargo subcommand for this test kind\n+    fn subcommand(self) -> &'static str {\n+        match self {\n+            TestKind::Test => \"test\",\n+            TestKind::Bench => \"bench\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for TestKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            TestKind::Test => \"Testing\",\n+            TestKind::Bench => \"Benchmarking\",\n+        })\n+    }\n+}\n+\n+fn try_run(build: &Build, cmd: &mut Command) -> bool {\n+    if !build.fail_fast {\n+        if !build.try_run(cmd) {\n+            let mut failures = build.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+            return false;\n+        }\n+    } else {\n+        build.run(cmd);\n+    }\n+    true\n+}\n+\n+fn try_run_quiet(build: &Build, cmd: &mut Command) {\n+    if !build.fail_fast {\n+        if !build.try_run_quiet(cmd) {\n+            let mut failures = build.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+        }\n+    } else {\n+        build.run_quiet(cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Linkcheck {\n+    host: Interned<String>,\n+}\n+\n+impl Step for Linkcheck {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will verify the validity of all our links in the\n+    /// documentation to ensure we don't have a bunch of dead ones.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        println!(\"Linkcheck ({})\", host);\n+\n+        builder.default_doc(None);\n+\n+        let _time = util::timeit();\n+        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n+                            .arg(build.out.join(host).join(\"doc\")));\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.path(\"src/tools/linkchecker\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Linkcheck { host: run.target });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargotest {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Cargotest {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/cargotest\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Cargotest {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n+    /// test` to ensure that we don't regress the test suites there.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = builder.compiler(self.stage, self.host);\n+        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+\n+        // Note that this is a short, cryptic, and not scoped directory name. This\n+        // is currently to minimize the length of path on Windows where we otherwise\n+        // quickly run into path name limit constraints.\n+        let out_dir = build.out.join(\"ct\");\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let _time = util::timeit();\n+        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n+        try_run(build, cmd.arg(&build.initial_cargo)\n+                          .arg(&out_dir)\n+                          .env(\"RUSTC\", builder.rustc(compiler))\n+                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargo {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Cargo {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/cargo\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Cargo {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for `cargo` packaged with Rust.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = builder.compiler(self.stage, self.host);\n+\n+        builder.ensure(tool::Cargo { compiler, target: self.host });\n+        let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n+        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        if !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n+        // available.\n+        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n+\n+        try_run(build, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rls {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Rls {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rls\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rls {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for the rls.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        builder.ensure(tool::Rls { compiler, target: self.host });\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\");\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        if try_run(build, &mut cargo) {\n+            build.save_toolstate(\"rls\", ToolState::TestPass);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustfmt {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Rustfmt {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rustfmt\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustfmt {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for rustfmt.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\");\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        if try_run(build, &mut cargo) {\n+            build.save_toolstate(\"rustfmt\", ToolState::TestPass);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Miri {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Miri {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let test_miri = run.builder.build.config.test_miri;\n+        run.path(\"src/tools/miri\").default_condition(test_miri)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Miri {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for miri.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run(build, &mut cargo) {\n+                build.save_toolstate(\"miri\", ToolState::TestPass);\n+            }\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Clippy {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Clippy {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/clippy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for clippy.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n+            cargo.env(\"HOST_LIBS\", host_libs);\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run(build, &mut cargo) {\n+                build.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n+            }\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n+    }\n+}\n+\n+fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n+    // Configure PATH to find the right rustc. NB. we have to use PATH\n+    // and not RUSTC because the Cargo test suite has tests that will\n+    // fail if rustc is not spelled `rustc`.\n+    let path = builder.sysroot(compiler).join(\"bin\");\n+    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+    env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocJS {\n+    pub host: Interned<String>,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustdocJS {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/test/rustdoc-js\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustdocJS {\n+            host: run.host,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        if let Some(ref nodejs) = builder.config.nodejs {\n+            let mut command = Command::new(nodejs);\n+            command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n+            builder.ensure(::doc::Std {\n+                target: self.target,\n+                stage: builder.top_stage,\n+            });\n+            builder.run(&mut command);\n+        } else {\n+            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Tidy {\n+    host: Interned<String>,\n+}\n+\n+impl Step for Tidy {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` checks up on various bits and pieces of style and\n+    /// otherwise just implements a few lint-like checks that are specific to the\n+    /// compiler itself.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        let _folder = build.fold_output(|| \"tidy\");\n+        println!(\"tidy check ({})\", host);\n+        let mut cmd = builder.tool_cmd(Tool::Tidy);\n+        cmd.arg(build.src.join(\"src\"));\n+        if !build.config.vendor {\n+            cmd.arg(\"--no-vendor\");\n+        }\n+        if build.config.quiet_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+        try_run(build, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/tidy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Tidy {\n+            host: run.builder.build.build,\n+        });\n+    }\n+}\n+\n+fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n+    build.out.join(host).join(\"test\")\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct Test {\n+    path: &'static str,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+static DEFAULT_COMPILETESTS: &[Test] = &[\n+    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n+    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n+    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n+    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n+    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n+    Test {\n+        path: \"src/test/run-pass-valgrind\",\n+        mode: \"run-pass-valgrind\",\n+        suite: \"run-pass-valgrind\"\n+    },\n+    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n+    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n+    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n+    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n+\n+    // What this runs varies depending on the native platform being apple\n+    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n+];\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct DefaultCompiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+impl Step for DefaultCompiletest {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        for test in DEFAULT_COMPILETESTS {\n+            run = run.path(test.path);\n+        }\n+        run\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+        let test = run.path.map(|path| {\n+            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n+                path.ends_with(test.path)\n+            }).unwrap_or_else(|| {\n+                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n+            })\n+        });\n+\n+        if let Some(test) = test {\n+            run.builder.ensure(DefaultCompiletest {\n+                compiler,\n+                target: run.target,\n+                mode: test.mode,\n+                suite: test.suite,\n+            });\n+        } else {\n+            for test in DEFAULT_COMPILETESTS {\n+                run.builder.ensure(DefaultCompiletest {\n+                    compiler,\n+                    target: run.target,\n+                    mode: test.mode,\n+                    suite: test.suite\n+                });\n+            }\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Compiletest {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: self.mode,\n+            suite: self.suite,\n+        })\n+    }\n+}\n+\n+// Also default, but host-only.\n+static HOST_COMPILETESTS: &[Test] = &[\n+    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n+    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n+    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n+    Test {\n+        path: \"src/test/compile-fail-fulldeps\",\n+        mode: \"compile-fail\",\n+        suite: \"compile-fail-fulldeps\",\n+    },\n+    Test {\n+        path: \"src/test/incremental-fulldeps\",\n+        mode: \"incremental\",\n+        suite: \"incremental-fulldeps\",\n+    },\n+    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n+    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n+\n+    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n+    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n+    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n+    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n+    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n+    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n+];\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct HostCompiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+impl Step for HostCompiletest {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        for test in HOST_COMPILETESTS {\n+            run = run.path(test.path);\n+        }\n+        run\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+        let test = run.path.map(|path| {\n+            HOST_COMPILETESTS.iter().find(|&&test| {\n+                path.ends_with(test.path)\n+            }).unwrap_or_else(|| {\n+                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n+            })\n+        });\n+\n+        if let Some(test) = test {\n+            run.builder.ensure(HostCompiletest {\n+                compiler,\n+                target: run.target,\n+                mode: test.mode,\n+                suite: test.suite,\n+            });\n+        } else {\n+            for test in HOST_COMPILETESTS {\n+                if test.mode == \"pretty\" {\n+                    continue;\n+                }\n+                run.builder.ensure(HostCompiletest {\n+                    compiler,\n+                    target: run.target,\n+                    mode: test.mode,\n+                    suite: test.suite\n+                });\n+            }\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Compiletest {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: self.mode,\n+            suite: self.suite,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct Compiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+}\n+\n+impl Step for Compiletest {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    /// Executes the `compiletest` tool to run a suite of tests.\n+    ///\n+    /// Compiles all tests with `compiler` for `target` with the specified\n+    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n+    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let suite = self.suite;\n+\n+        // Skip codegen tests if they aren't enabled in configuration.\n+        if !build.config.codegen_tests && suite == \"codegen\" {\n+            return;\n+        }\n+\n+        if suite == \"debuginfo\" {\n+            // Skip debuginfo tests on MSVC\n+            if build.build.contains(\"msvc\") {\n+                return;\n+            }\n+\n+            if mode == \"debuginfo-XXX\" {\n+                return if build.build.contains(\"apple\") {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-lldb\",\n+                        ..self\n+                    });\n+                } else {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-gdb\",\n+                        ..self\n+                    });\n+                };\n+            }\n+\n+            builder.ensure(dist::DebuggerScripts {\n+                sysroot: builder.sysroot(compiler),\n+                host: target\n+            });\n+        }\n+\n+        if suite.ends_with(\"fulldeps\") ||\n+            // FIXME: Does pretty need librustc compiled? Note that there are\n+            // fulldeps test suites with mode = pretty as well.\n+            mode == \"pretty\" ||\n+            mode == \"rustdoc\" ||\n+            mode == \"run-make\" {\n+            builder.ensure(compile::Rustc { compiler, target });\n+        }\n+\n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(native::TestHelpers { target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, &compiler.host, target);\n+        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n+\n+        // compiletest currently has... a lot of arguments, so let's just pass all\n+        // of them!\n+\n+        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n+\n+        // Avoid depending on rustdoc when we don't need it.\n+        if mode == \"rustdoc\" || mode == \"run-make\" {\n+            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n+        }\n+\n+        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--mode\").arg(mode);\n+        cmd.arg(\"--target\").arg(target);\n+        cmd.arg(\"--host\").arg(&*compiler.host);\n+        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n+\n+        if let Some(ref nodejs) = build.config.nodejs {\n+            cmd.arg(\"--nodejs\").arg(nodejs);\n+        }\n+\n+        let mut flags = vec![\"-Crpath\".to_string()];\n+        if build.config.rust_optimize_tests {\n+            flags.push(\"-O\".to_string());\n+        }\n+        if build.config.rust_debuginfo_tests {\n+            flags.push(\"-g\".to_string());\n+        }\n+        flags.push(\"-Zmiri -Zunstable-options\".to_string());\n+        flags.push(build.config.cmd.rustc_args().join(\" \"));\n+\n+        if let Some(linker) = build.linker(target) {\n+            cmd.arg(\"--linker\").arg(linker);\n+        }\n+\n+        let hostflags = flags.clone();\n+        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+\n+        let mut targetflags = flags.clone();\n+        targetflags.push(format!(\"-Lnative={}\",\n+                                 build.test_helpers_out(target).display()));\n+        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+\n+        cmd.arg(\"--docck-python\").arg(build.python());\n+\n+        if build.build.ends_with(\"apple-darwin\") {\n+            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n+            // LLDB plugin's compiled module which only works with the system python\n+            // (namely not Homebrew-installed python)\n+            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n+        } else {\n+            cmd.arg(\"--lldb-python\").arg(build.python());\n+        }\n+\n+        if let Some(ref gdb) = build.config.gdb {\n+            cmd.arg(\"--gdb\").arg(gdb);\n+        }\n+        if let Some(ref vers) = build.lldb_version {\n+            cmd.arg(\"--lldb-version\").arg(vers);\n+        }\n+        if let Some(ref dir) = build.lldb_python_dir {\n+            cmd.arg(\"--lldb-python-dir\").arg(dir);\n+        }\n+\n+        cmd.args(&build.config.cmd.test_args());\n+\n+        if build.is_verbose() {\n+            cmd.arg(\"--verbose\");\n+        }\n+\n+        if build.config.quiet_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+\n+        if build.config.llvm_enabled {\n+            let llvm_config = build.llvm_config(target);\n+            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+            cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            if !build.is_rust_llvm(target) {\n+                cmd.arg(\"--system-llvm\");\n+            }\n+\n+            // Only pass correct values for these flags for the `run-make` suite as it\n+            // requires that a C++ compiler was configured which isn't always the case.\n+            if suite == \"run-make\" {\n+                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n+                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n+                cmd.arg(\"--cc\").arg(build.cc(target))\n+                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n+                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n+                .arg(\"--llvm-components\").arg(llvm_components.trim())\n+                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                if let Some(ar) = build.ar(target) {\n+                    cmd.arg(\"--ar\").arg(ar);\n+                }\n+            }\n+        }\n+        if suite == \"run-make\" && !build.config.llvm_enabled {\n+            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n+            return;\n+        }\n+\n+        if suite != \"run-make\" {\n+            cmd.arg(\"--cc\").arg(\"\")\n+               .arg(\"--cxx\").arg(\"\")\n+               .arg(\"--cflags\").arg(\"\")\n+               .arg(\"--llvm-components\").arg(\"\")\n+               .arg(\"--llvm-cxxflags\").arg(\"\");\n+        }\n+\n+        if build.remote_tested(target) {\n+            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n+        }\n+\n+        // Running a C compiler on MSVC requires a few env vars to be set, to be\n+        // sure to set them here.\n+        //\n+        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n+        // rather than stomp over it.\n+        if target.contains(\"msvc\") {\n+            for &(ref k, ref v) in build.cc[&target].env() {\n+                if k != \"PATH\" {\n+                    cmd.env(k, v);\n+                }\n+            }\n+        }\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        build.add_rust_test_threads(&mut cmd);\n+\n+        if build.config.sanitizers {\n+            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n+        }\n+\n+        if build.config.profiler {\n+            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n+        }\n+\n+        cmd.arg(\"--adb-path\").arg(\"adb\");\n+        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n+        if target.contains(\"android\") {\n+            // Assume that cc for this target comes from the android sysroot\n+            cmd.arg(\"--android-cross-path\")\n+               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n+        } else {\n+            cmd.arg(\"--android-cross-path\").arg(\"\");\n+        }\n+\n+        build.ci_env.force_coloring_in_ci(&mut cmd);\n+\n+        let _time = util::timeit();\n+        try_run(build, &mut cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Docs {\n+    compiler: Compiler,\n+}\n+\n+impl Step for Docs {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/doc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Docs {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+        });\n+    }\n+\n+    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    ///\n+    /// This will run all tests in our markdown documentation (e.g. the book)\n+    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n+    /// `compiler`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Test { compiler, target: compiler.host });\n+\n+        // Do a breadth-first traversal of the `src/doc` directory and just run\n+        // tests for all files that end in `*.md`\n+        let mut stack = vec![build.src.join(\"src/doc\")];\n+        let _time = util::timeit();\n+        let _folder = build.fold_output(|| \"test_docs\");\n+\n+        while let Some(p) = stack.pop() {\n+            if p.is_dir() {\n+                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n+                continue\n+            }\n+\n+            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n+                continue;\n+            }\n+\n+            // The nostarch directory in the book is for no starch, and so isn't\n+            // guaranteed to build. We don't care if it doesn't build, so skip it.\n+            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n+                continue;\n+            }\n+\n+            markdown_test(builder, compiler, &p);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ErrorIndex {\n+    compiler: Compiler,\n+}\n+\n+impl Step for ErrorIndex {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/error_index_generator\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(ErrorIndex {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+        });\n+    }\n+\n+    /// Run the error index generator tool to execute the tests located in the error\n+    /// index.\n+    ///\n+    /// The `error_index_generator` tool lives in `src/tools` and is used to\n+    /// generate a markdown file from the error indexes of the code base which is\n+    /// then passed to `rustdoc --test`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n+\n+        let _folder = build.fold_output(|| \"test_error_index\");\n+        println!(\"Testing error-index stage{}\", compiler.stage);\n+\n+        let dir = testdir(build, compiler.host);\n+        t!(fs::create_dir_all(&dir));\n+        let output = dir.join(\"error-index.md\");\n+\n+        let _time = util::timeit();\n+        build.run(builder.tool_cmd(Tool::ErrorIndex)\n+                    .arg(\"markdown\")\n+                    .arg(&output)\n+                    .env(\"CFG_BUILD\", &build.build)\n+                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n+\n+        markdown_test(builder, compiler, &output);\n+    }\n+}\n+\n+fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n+    let build = builder.build;\n+    let mut file = t!(File::open(markdown));\n+    let mut contents = String::new();\n+    t!(file.read_to_string(&mut contents));\n+    if !contents.contains(\"```\") {\n+        return;\n+    }\n+\n+    println!(\"doc tests for: {}\", markdown.display());\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n+    build.add_rust_test_threads(&mut cmd);\n+    cmd.arg(\"--test\");\n+    cmd.arg(markdown);\n+    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+\n+    let test_args = build.config.cmd.test_args().join(\" \");\n+    cmd.arg(\"--test-args\").arg(test_args);\n+\n+    if build.config.quiet_tests {\n+        try_run_quiet(build, &mut cmd);\n+    } else {\n+        try_run(build, &mut cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateLibrustc {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: Option<Interned<String>>,\n+}\n+\n+impl Step for CrateLibrustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"rustc-main\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let make = |name: Option<Interned<String>>| {\n+            let test_kind = if builder.kind == Kind::Test {\n+                TestKind::Test\n+            } else if builder.kind == Kind::Bench {\n+                TestKind::Bench\n+            } else {\n+                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+            };\n+\n+            builder.ensure(CrateLibrustc {\n+                compiler,\n+                target: run.target,\n+                test_kind,\n+                krate: name,\n+            });\n+        };\n+\n+        if let Some(path) = run.path {\n+            for (name, krate_path) in builder.crates(\"rustc-main\") {\n+                if path.ends_with(krate_path) {\n+                    make(Some(name));\n+                }\n+            }\n+        } else {\n+            make(None);\n+        }\n+    }\n+\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Librustc,\n+            test_kind: self.test_kind,\n+            krate: self.krate,\n+        });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Crate {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: Mode,\n+    test_kind: TestKind,\n+    krate: Option<Interned<String>>,\n+}\n+\n+impl Step for Crate {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"std\").krate(\"test\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let make = |mode: Mode, name: Option<Interned<String>>| {\n+            let test_kind = if builder.kind == Kind::Test {\n+                TestKind::Test\n+            } else if builder.kind == Kind::Bench {\n+                TestKind::Bench\n+            } else {\n+                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+            };\n+\n+            builder.ensure(Crate {\n+                compiler,\n+                target: run.target,\n+                mode,\n+                test_kind,\n+                krate: name,\n+            });\n+        };\n+\n+        if let Some(path) = run.path {\n+            for (name, krate_path) in builder.crates(\"std\") {\n+                if path.ends_with(krate_path) {\n+                    make(Mode::Libstd, Some(name));\n+                }\n+            }\n+            for (name, krate_path) in builder.crates(\"test\") {\n+                if path.ends_with(krate_path) {\n+                    make(Mode::Libtest, Some(name));\n+                }\n+            }\n+        } else {\n+            make(Mode::Libstd, None);\n+            make(Mode::Libtest, None);\n+        }\n+    }\n+\n+    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n+    /// by a `Cargo.toml`\n+    ///\n+    /// This is what runs tests for crates like the standard library, compiler, etc.\n+    /// It essentially is the driver for running `cargo test`.\n+    ///\n+    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n+    /// arguments, and those arguments are discovered from `cargo metadata`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let test_kind = self.test_kind;\n+        let krate = self.krate;\n+\n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        // If we're not doing a full bootstrap but we're testing a stage2 version of\n+        // libstd, then what we're actually testing is the libstd produced in\n+        // stage1. Reflect that here by updating the compiler that we're working\n+        // with automatically.\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler.clone()\n+        };\n+\n+        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n+        let (name, root) = match mode {\n+            Mode::Libstd => {\n+                compile::std_cargo(build, &compiler, target, &mut cargo);\n+                (\"libstd\", \"std\")\n+            }\n+            Mode::Libtest => {\n+                compile::test_cargo(build, &compiler, target, &mut cargo);\n+                (\"libtest\", \"test\")\n+            }\n+            Mode::Librustc => {\n+                builder.ensure(compile::Rustc { compiler, target });\n+                compile::rustc_cargo(build, target, &mut cargo);\n+                (\"librustc\", \"rustc-main\")\n+            }\n+            _ => panic!(\"can only test libraries\"),\n+        };\n+        let root = INTERNER.intern_string(String::from(root));\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n+        });\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n+                &compiler.host, target);\n+\n+        // Build up the base `cargo test` command.\n+        //\n+        // Pass in some standard flags then iterate over the graph we've discovered\n+        // in `cargo metadata` with the maps above and figure out what `-p`\n+        // arguments need to get passed.\n+        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        match krate {\n+            Some(krate) => {\n+                cargo.arg(\"-p\").arg(krate);\n+            }\n+            None => {\n+                let mut visited = HashSet::new();\n+                let mut next = vec![root];\n+                while let Some(name) = next.pop() {\n+                    // Right now jemalloc and the sanitizer crates are\n+                    // target-specific crate in the sense that it's not present\n+                    // on all platforms. Custom skip it here for now, but if we\n+                    // add more this probably wants to get more generalized.\n+                    //\n+                    // Also skip `build_helper` as it's not compiled normally\n+                    // for target during the bootstrap and it's just meant to be\n+                    // a helper crate, not tested. If it leaks through then it\n+                    // ends up messing with various mtime calculations and such.\n+                    if !name.contains(\"jemalloc\") &&\n+                       *name != *\"build_helper\" &&\n+                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n+                       name != \"dlmalloc\" {\n+                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n+                    }\n+                    for dep in build.crates[&name].deps.iter() {\n+                        if visited.insert(dep) {\n+                            next.push(*dep);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // The tests are going to run with the *target* libraries, so we need to\n+        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n+        //\n+        // Note that to run the compiler we need to run with the *host* libraries,\n+        // but our wrapper scripts arrange for that to be the case anyway.\n+        let mut dylib_path = dylib_path();\n+        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&build.config.cmd.test_args());\n+\n+        if build.config.quiet_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        let _time = util::timeit();\n+\n+        if target.contains(\"emscripten\") {\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n+        } else if target.starts_with(\"wasm32\") {\n+            // On the wasm32-unknown-unknown target we're using LTO which is\n+            // incompatible with `-C prefer-dynamic`, so disable that here\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+            let node = build.config.nodejs.as_ref()\n+                .expect(\"nodejs not configured\");\n+            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n+                                 node.display(),\n+                                 build.src.display());\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n+        } else if build.remote_tested(target) {\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                      format!(\"{} run\",\n+                              builder.tool_exe(Tool::RemoteTestClient).display()));\n+        }\n+        try_run(build, &mut cargo);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustdoc {\n+    host: Interned<String>,\n+    test_kind: TestKind,\n+}\n+\n+impl Step for Rustdoc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+\n+        let test_kind = if builder.kind == Kind::Test {\n+            TestKind::Test\n+        } else if builder.kind == Kind::Bench {\n+            TestKind::Bench\n+        } else {\n+            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+        };\n+\n+        builder.ensure(Rustdoc {\n+            host: run.host,\n+            test_kind,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let test_kind = self.test_kind;\n+\n+        let compiler = builder.compiler(builder.top_stage, self.host);\n+        let target = compiler.host;\n+\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 target,\n+                                                 test_kind.subcommand(),\n+                                                 \"src/tools/rustdoc\");\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        });\n+        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target);\n+\n+        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&build.config.cmd.test_args());\n+\n+        if build.config.quiet_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        let _time = util::timeit();\n+\n+        try_run(build, &mut cargo);\n+    }\n+}\n+\n+fn envify(s: &str) -> String {\n+    s.chars().map(|c| {\n+        match c {\n+            '-' => '_',\n+            c => c,\n+        }\n+    }).flat_map(|c| c.to_uppercase()).collect()\n+}\n+\n+/// Some test suites are run inside emulators or on remote devices, and most\n+/// of our test binaries are linked dynamically which means we need to ship\n+/// the standard library and such to the emulator ahead of time. This step\n+/// represents this and is a dependency of all test suites.\n+///\n+/// Most of the time this is a noop. For some steps such as shipping data to\n+/// QEMU we have to build our own tools so we've got conditional dependencies\n+/// on those programs as well. Note that the remote test client is built for\n+/// the build target (us) and the server is built for the target.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RemoteCopyLibs {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+}\n+\n+impl Step for RemoteCopyLibs {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        if !build.remote_tested(target) {\n+            return\n+        }\n+\n+        builder.ensure(compile::Test { compiler, target });\n+\n+        println!(\"REMOTE copy libs to emulator ({})\", target);\n+        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n+\n+        let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n+\n+        // Spawn the emulator and wait for it to come online\n+        let tool = builder.tool_exe(Tool::RemoteTestClient);\n+        let mut cmd = Command::new(&tool);\n+        cmd.arg(\"spawn-emulator\")\n+           .arg(target)\n+           .arg(&server)\n+           .arg(build.out.join(\"tmp\"));\n+        if let Some(rootfs) = build.qemu_rootfs(target) {\n+            cmd.arg(rootfs);\n+        }\n+        build.run(&mut cmd);\n+\n+        // Push all our dylibs to the emulator\n+        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n+            let f = t!(f);\n+            let name = f.file_name().into_string().unwrap();\n+            if util::is_dylib(&name) {\n+                build.run(Command::new(&tool)\n+                                  .arg(\"push\")\n+                                  .arg(f.path()));\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Distcheck;\n+\n+impl Step for Distcheck {\n+    type Output = ();\n+    const ONLY_BUILD: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"distcheck\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Distcheck);\n+    }\n+\n+    /// Run \"distcheck\", a 'make check' from a tarball\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+\n+        println!(\"Distcheck\");\n+        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        // Guarantee that these are built before we begin running.\n+        builder.ensure(dist::PlainSourceTarball);\n+        builder.ensure(dist::Src);\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+           .arg(builder.ensure(dist::PlainSourceTarball))\n+           .arg(\"--strip-components=1\")\n+           .current_dir(&dir);\n+        build.run(&mut cmd);\n+        build.run(Command::new(\"./configure\")\n+                         .args(&build.config.configure_args)\n+                         .arg(\"--enable-vendor\")\n+                         .current_dir(&dir));\n+        build.run(Command::new(build_helper::make(&build.build))\n+                         .arg(\"check\")\n+                         .current_dir(&dir));\n+\n+        // Now make sure that rust-src has all of libstd's dependencies\n+        println!(\"Distcheck rust-src\");\n+        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+           .arg(builder.ensure(dist::Src))\n+           .arg(\"--strip-components=1\")\n+           .current_dir(&dir);\n+        build.run(&mut cmd);\n+\n+        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n+        build.run(Command::new(&build.initial_cargo)\n+                         .arg(\"generate-lockfile\")\n+                         .arg(\"--manifest-path\")\n+                         .arg(&toml)\n+                         .current_dir(&dir));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Bootstrap;\n+\n+impl Step for Bootstrap {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    /// Test the build system itself\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let mut cmd = Command::new(&build.initial_cargo);\n+        cmd.arg(\"test\")\n+           .current_dir(build.src.join(\"src/bootstrap\"))\n+           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n+           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+           .env(\"RUSTC\", &build.initial_rustc);\n+        if !build.fail_fast {\n+            cmd.arg(\"--no-fail-fast\");\n+        }\n+        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n+        try_run(build, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/bootstrap\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Bootstrap);\n+    }\n+}"}]}