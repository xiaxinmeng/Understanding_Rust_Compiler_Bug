{"sha": "7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmODlmYjdhMjBkNWNmMTk0NTFjMjRiOWI4NjMzZmY1NDYzNWUyMWU=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-04-12T08:37:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-12T08:37:57Z"}, "message": "Merge pull request #1672 from Manishearth/lifetime_sugg\n\nFix various false positives around needless_lifetime", "tree": {"sha": "310ed2a74238f762f3085353f6175ca0c063fbd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310ed2a74238f762f3085353f6175ca0c063fbd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "html_url": "https://github.com/rust-lang/rust/commit/7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ae57c55fd1963edbed30405ee0688e37553c68f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae57c55fd1963edbed30405ee0688e37553c68f", "html_url": "https://github.com/rust-lang/rust/commit/5ae57c55fd1963edbed30405ee0688e37553c68f"}, {"sha": "5f85ea8ef4e6ad9c0c0d44e427ddafe4c1dabdf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f85ea8ef4e6ad9c0c0d44e427ddafe4c1dabdf4", "html_url": "https://github.com/rust-lang/rust/commit/5f85ea8ef4e6ad9c0c0d44e427ddafe4c1dabdf4"}], "stats": {"total": 151, "additions": 111, "deletions": 40}, "files": [{"sha": "3a6a316226cb63c8c3c65b6baf7621db79edf7e7", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "patch": "@@ -98,8 +98,8 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n }\n \n /// Checks if the expressions matches\n-/// ```rust\n-/// { static __STATIC_FMTSTR: s = &[\"a\", \"b\", c]; __STATIC_FMTSTR }\n+/// ```rust, ignore\n+/// { static __STATIC_FMTSTR: &'static[&'static str] = &[\"a\", \"b\", c]; __STATIC_FMTSTR }\n /// ```\n fn check_static_str(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(expr) = get_argument_fmtstr_parts(cx, expr) {"}, {"sha": "5d726ef3389ea43b2ca29d1fa1ae4ec6514702f5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "patch": "@@ -11,7 +11,6 @@\n #![feature(conservative_impl_trait)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n-#![allow(needless_lifetimes)]\n \n extern crate syntax;\n extern crate syntax_pos;"}, {"sha": "be8e04c42df507187fc146c87d877659e5e21025", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 85, "deletions": 37, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "patch": "@@ -6,6 +6,7 @@ use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl\n use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n use utils::{in_external_macro, span_lint, last_path_segment};\n+use syntax::symbol::keywords;\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n /// relying on lifetime elision.\n@@ -58,20 +59,24 @@ impl LintPass for LifetimePass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n-            check_fn_inner(cx, decl, generics, item.span);\n+        if let ItemFn(ref decl, _, _, _, ref generics, id) = item.node {\n+            check_fn_inner(cx, decl, Some(id), generics, item.span);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if let ImplItemKind::Method(ref sig, _) = item.node {\n-            check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n+        if let ImplItemKind::Method(ref sig, id) = item.node {\n+            check_fn_inner(cx, &sig.decl, Some(id), &sig.generics, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(ref sig, _) = item.node {\n-            check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n+        if let TraitItemKind::Method(ref sig, ref body) = item.node {\n+            let body = match *body {\n+                TraitMethod::Required(_) => None,\n+                TraitMethod::Provided(id) => Some(id),\n+            };\n+            check_fn_inner(cx, &sig.decl, body, &sig.generics, item.span);\n         }\n     }\n }\n@@ -84,30 +89,32 @@ enum RefLt {\n     Named(Name),\n }\n \n-fn bound_lifetimes(bound: &TyParamBound) -> HirVec<&Lifetime> {\n-    if let TraitTyParamBound(ref trait_ref, _) = *bound {\n-        trait_ref.trait_ref\n-            .path\n-            .segments\n-            .last()\n-            .expect(\"a path must have at least one segment\")\n-            .parameters\n-            .lifetimes()\n-    } else {\n-        HirVec::new()\n-    }\n-}\n-\n-fn check_fn_inner<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, generics: &'tcx Generics, span: Span) {\n+fn check_fn_inner<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: Option<BodyId>, generics: &'tcx Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n \n-    let bounds_lts = generics.ty_params\n-        .iter()\n-        .flat_map(|typ| typ.bounds.iter().flat_map(bound_lifetimes));\n-\n-    if could_use_elision(cx, decl, &generics.lifetimes, bounds_lts) {\n+    let mut bounds_lts = Vec::new();\n+    for typ in &generics.ty_params {\n+        for bound in &typ.bounds {\n+            if let TraitTyParamBound(ref trait_ref, _) = *bound {\n+                let bounds = trait_ref.trait_ref\n+                    .path\n+                    .segments\n+                    .last()\n+                    .expect(\"a path must have at least one segment\")\n+                    .parameters\n+                    .lifetimes();\n+                for bound in bounds {\n+                    if bound.name != \"'static\" && !bound.is_elided() {\n+                        return;\n+                    }\n+                    bounds_lts.push(bound);\n+                }\n+            }\n+        }\n+    }\n+    if could_use_elision(cx, decl, body, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n                   NEEDLESS_LIFETIMES,\n                   span,\n@@ -116,11 +123,12 @@ fn check_fn_inner<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, gene\n     report_extra_lifetimes(cx, decl, generics);\n }\n \n-fn could_use_elision<'a, 'tcx: 'a, T: Iterator<Item = &'tcx Lifetime>>(\n+fn could_use_elision<'a, 'tcx: 'a>(\n     cx: &LateContext<'a, 'tcx>,\n     func: &'tcx FnDecl,\n+    body: Option<BodyId>,\n     named_lts: &'tcx [LifetimeDef],\n-    bounds_lts: T\n+    bounds_lts: Vec<&'tcx Lifetime>,\n ) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n@@ -144,8 +152,22 @@ fn could_use_elision<'a, 'tcx: 'a, T: Iterator<Item = &'tcx Lifetime>>(\n         output_visitor.visit_ty(ty);\n     }\n \n-    let input_lts = lts_from_bounds(input_visitor.into_vec(), bounds_lts);\n-    let output_lts = output_visitor.into_vec();\n+    let input_lts = match input_visitor.into_vec() {\n+        Some(lts) => lts_from_bounds(lts, bounds_lts.into_iter()),\n+        None => return false,\n+    };\n+    let output_lts = match output_visitor.into_vec() {\n+        Some(val) => val,\n+        None => return false,\n+    };\n+\n+    if let Some(body_id) = body {\n+        let mut checker = BodyLifetimeChecker { lifetimes_used_in_body: false };\n+        checker.visit_expr(&cx.tcx.hir.body(body_id).value);\n+        if checker.lifetimes_used_in_body {\n+            return false;\n+        }\n+    }\n \n     // check for lifetimes from higher scopes\n     for lt in input_lts.iter().chain(output_lts.iter()) {\n@@ -216,13 +238,15 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n struct RefVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     lts: Vec<RefLt>,\n+    abort: bool,\n }\n \n impl<'v, 't> RefVisitor<'v, 't> {\n     fn new(cx: &'v LateContext<'v, 't>) -> RefVisitor<'v, 't> {\n         RefVisitor {\n             cx: cx,\n             lts: Vec::new(),\n+            abort: false,\n         }\n     }\n \n@@ -240,8 +264,12 @@ impl<'v, 't> RefVisitor<'v, 't> {\n         }\n     }\n \n-    fn into_vec(self) -> Vec<RefLt> {\n-        self.lts\n+    fn into_vec(self) -> Option<Vec<RefLt>> {\n+        if self.abort {\n+            None\n+        } else {\n+            Some(self.lts)\n+        }\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n@@ -292,7 +320,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             },\n             TyTraitObject(ref bounds, ref lt) => {\n                 if !lt.is_elided() {\n-                    self.record(&Some(*lt));\n+                    self.abort = true;\n                 }\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n@@ -329,10 +357,13 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                     walk_ty_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n-                for lt in visitor.into_vec() {\n-                    if !allowed_lts.contains(&lt) {\n-                        return true;\n-                    }\n+                match visitor.into_vec() {\n+                    None => return false,\n+                    Some(lts) => for lt in lts {\n+                        if !allowed_lts.contains(&lt) {\n+                            return true;\n+                        }\n+                    },\n                 }\n             },\n             WherePredicate::EqPredicate(ref pred) => {\n@@ -384,3 +415,20 @@ fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx\n         span_lint(cx, UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n     }\n }\n+\n+struct BodyLifetimeChecker {\n+    lifetimes_used_in_body: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n+    // for lifetimes as parameters of generics\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n+        if lifetime.name != keywords::Invalid.name() && lifetime.name != \"'static\" {\n+            self.lifetimes_used_in_body = true;\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "ea8a483924fd9a9b558e447d4dca9755289dbce1", "filename": "tests/ui/lifetimes.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/tests%2Fui%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89fb7a20d5cf19451c24b9b8633ff54635e21e/tests%2Fui%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.rs?ref=7f89fb7a20d5cf19451c24b9b8633ff54635e21e", "patch": "@@ -128,5 +128,29 @@ fn elided_input_named_output<'a>(_arg: &str) -> &'a str { unimplemented!() }\n fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) { unimplemented!() }\n fn trait_bound<'a, T: WithLifetime<'a>>(_: &'a u8, _: T) { unimplemented!() }\n \n+// don't warn on these, see #292\n+fn trait_bound_bug<'a, T: WithLifetime<'a>>() { unimplemented!() }\n+\n+// #740\n+struct Test {\n+    vec: Vec<usize>,\n+}\n+\n+impl Test {\n+    fn iter<'a>(&'a self) -> Box<Iterator<Item = usize> + 'a> {\n+        unimplemented!()\n+    }\n+}\n+\n+\n+trait LintContext<'a> {}\n+\n+fn f<'a, T: LintContext<'a>>(_: &T) {}\n+\n+fn test<'a>(x: &'a [u8]) -> u8 {\n+    let y: &'a u8 = &x[5];\n+    *y\n+}\n+\n fn main() {\n }"}]}