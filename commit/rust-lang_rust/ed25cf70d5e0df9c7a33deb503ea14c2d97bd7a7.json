{"sha": "ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMjVjZjcwZDVlMGRmOWM3YTMzZGViNTAzZWExNGMyZDk3YmQ3YTc=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-01-31T15:52:43Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T17:28:10Z"}, "message": "Change Ty::Param to contain param ID", "tree": {"sha": "bc6e8620244d64beed8f1a9ce9059e5dfd2a0fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc6e8620244d64beed8f1a9ce9059e5dfd2a0fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "html_url": "https://github.com/rust-lang/rust/commit/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8b7b64bce772f21124b4790538ca97418cc23ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b7b64bce772f21124b4790538ca97418cc23ca", "html_url": "https://github.com/rust-lang/rust/commit/f8b7b64bce772f21124b4790538ca97418cc23ca"}], "stats": {"total": 263, "additions": 136, "deletions": 127}, "files": [{"sha": "7684ade0681d8a06fe5f45703e07fa948a273955", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -3,10 +3,10 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId,\n+    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId, TypeParamId,\n };\n use ra_arena::map::ArenaMap;\n-use ra_db::{salsa, CrateId};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n \n use crate::{\n@@ -37,10 +37,10 @@ pub trait HirDatabase: DefDatabase {\n     fn impl_self_ty(&self, def: ImplId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::impl_trait_query)]\n-    fn impl_trait(&self, def: ImplId) -> Option<TraitRef>;\n+    fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n \n     #[salsa::invoke(crate::lower::field_types_query)]\n-    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n+    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>>;\n \n     #[salsa::invoke(crate::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> PolyFnSig;\n@@ -49,8 +49,7 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n         &self,\n-        def: GenericDefId,\n-        param_idx: u32,\n+        param_id: TypeParamId,\n     ) -> Arc<[GenericPredicate]>;\n \n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n@@ -77,6 +76,8 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n     #[salsa::interned]\n+    fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n+    #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n@@ -117,3 +118,7 @@ fn infer(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n fn hir_database_is_object_safe() {\n     fn _assert_object_safe(_: &dyn HirDatabase) {}\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GlobalTypeParamId(salsa::InternId);\n+impl_intern_key!(GlobalTypeParamId);"}, {"sha": "2a95678984e9498ee3fec487fc43472f814d8fb9", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -57,17 +57,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let trait_ref = db.impl_trait(impl_id)?;\n \n                 // `CoerseUnsized` has one generic parameter for the target type.\n-                let cur_from_ty = trait_ref.substs.0.get(0)?;\n-                let cur_to_ty = trait_ref.substs.0.get(1)?;\n+                let cur_from_ty = trait_ref.value.substs.0.get(0)?;\n+                let cur_to_ty = trait_ref.value.substs.0.get(1)?;\n \n                 match (&cur_from_ty, cur_to_ty) {\n                     (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n                         // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n                         // This works for smart-pointer-like coercion, which covers all impls from std.\n                         st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n                             match (ty1, ty2) {\n-                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n-                                    if p1 != p2 =>\n+                                (Ty::Bound(idx1), Ty::Bound(idx2))\n+                                    if idx1 != idx2 =>\n                                 {\n                                     Some(((*ctor1, *ctor2), i))\n                                 }\n@@ -256,8 +256,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let unsize_generic_index = {\n                     let mut index = None;\n                     let mut multiple_param = false;\n-                    field_tys[last_field_id].walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } => {\n+                    field_tys[last_field_id].value.walk(&mut |ty| match ty {\n+                        &Ty::Bound(idx) => {\n                             if index.is_none() {\n                                 index = Some(idx);\n                             } else if Some(idx) != index {\n@@ -276,8 +276,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Check other fields do not involve it.\n                 let mut multiple_used = false;\n                 fields.for_each(|(field_id, _data)| {\n-                    field_tys[field_id].walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n+                    field_tys[field_id].value.walk(&mut |ty| match ty {\n+                        &Ty::Bound(idx) if idx == unsize_generic_index => {\n                             multiple_used = true\n                         }\n                         _ => {}"}, {"sha": "8b83784993d9db5a0f935df46b06dd9a729a734d", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -236,8 +236,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n                     let field_ty = field_def\n-                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone())\n-                        .subst(&substs);\n+                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone().subst(&substs));\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n@@ -686,7 +685,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             if let TypeCtor::FnDef(def) = a_ty.ctor {\n                 let generic_predicates = self.db.generic_predicates(def.into());\n                 for predicate in generic_predicates.iter() {\n-                    let predicate = predicate.clone().subst(&a_ty.parameters);\n+                    let predicate = predicate.clone().subst_type_params(self.db, def.into(), &a_ty.parameters);\n                     if let Some(obligation) = Obligation::from_predicate(predicate) {\n                         self.obligations.push(obligation);\n                     }"}, {"sha": "e7283f24cd35ef71ddbf0f4fc48d1583cb52a95f", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -12,7 +12,7 @@ use hir_expand::name::Name;\n use test_utils::tested_by;\n \n use super::{BindingMode, InferenceContext};\n-use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_tuple_struct_pat(\n@@ -34,8 +34,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let expected_ty = var_data\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field_tys[field].clone())\n-                .subst(&substs);\n+                .map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n@@ -65,7 +64,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for subpat in subpats {\n             let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n             let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone()).subst(&substs);\n+                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }"}, {"sha": "1e162943cbfe43e6c9a9224ac42cee4857d62760", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -45,10 +45,10 @@ use std::{fmt, iter, mem};\n \n use hir_def::{\n     expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n-    HasModule, Lookup, TraitId, TypeAliasId,\n+    HasModule, Lookup, TraitId, TypeAliasId, TypeParamId, generics::TypeParamProvenance,\n };\n-use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n+use hir_expand::name::Name;\n \n use crate::{\n     db::HirDatabase,\n@@ -288,14 +288,7 @@ pub enum Ty {\n     Projection(ProjectionTy),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    Param {\n-        /// The index of the parameter (starting with parameters from the\n-        /// surrounding impl, then the current function).\n-        idx: u32,\n-        /// The name of the parameter, for displaying.\n-        // FIXME get rid of this\n-        name: Name,\n-    },\n+    Param(TypeParamId),\n \n     /// A bound type variable. Used during trait resolution to represent Chalk\n     /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n@@ -366,15 +359,15 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub(crate) fn identity(generic_params: &Generics) -> Substs {\n+    pub(crate) fn type_params(generic_params: &Generics) -> Substs {\n         Substs(\n-            generic_params.iter().map(|(idx, p)| Ty::Param { idx, name: p.name.clone().unwrap_or_else(Name::missing) }).collect(),\n+            generic_params.iter().map(|(id, _)| Ty::Param(id)).collect(),\n         )\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n     pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n-        Substs(generic_params.iter().map(|(idx, _p)| Ty::Bound(idx)).collect())\n+        Substs(generic_params.iter().enumerate().map(|(idx, _)| Ty::Bound(idx as u32)).collect())\n     }\n \n     pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n@@ -422,11 +415,6 @@ impl SubstsBuilder {\n         self.fill((starting_from..).map(Ty::Bound))\n     }\n \n-    pub fn fill_with_params(self) -> Self {\n-        let start = self.vec.len() as u32;\n-        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n-    }\n-\n     pub fn fill_with_unknown(self) -> Self {\n         self.fill(iter::repeat(Ty::Unknown))\n     }\n@@ -762,13 +750,19 @@ pub trait TypeWalk {\n     /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n     /// if `self` is `&[T]`, where type parameter T has index 0, and the\n     /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    fn subst(self, substs: &Substs) -> Self\n+    // TODO: this should mostly not be used anymore\n+    fn subst_type_params(self, db: &impl HirDatabase, def: GenericDefId, substs: &Substs) -> Self\n     where\n         Self: Sized,\n     {\n+        let generics = generics(db, def);\n         self.fold(&mut |ty| match ty {\n-            Ty::Param { idx, name } => {\n-                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n+            Ty::Param(id) => {\n+                if let Some(idx) = generics.param_idx(id) {\n+                    substs.get(idx as usize).cloned().unwrap_or(Ty::Param(id))\n+                } else {\n+                    ty\n+                }\n             }\n             ty => ty,\n         })\n@@ -1042,7 +1036,18 @@ impl HirDisplay for Ty {\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Param(id) => {\n+                let generic_params = f.db.generic_params(id.parent);\n+                let param_data = &generic_params.types[id.local_id];\n+                match param_data.provenance {\n+                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n+                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n+                    }\n+                    TypeParamProvenance::ArgumentImplTrait => {\n+                        write!(f, \"impl TODO\")?\n+                    }\n+                }\n+            },\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 match self {"}, {"sha": "d60b594334299a76bd0944f79b3d7a6c164ab8d6", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -30,7 +30,7 @@ use crate::{\n     Binders, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate, ProjectionTy, Substs,\n     TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n-use hir_expand::name::Name;\n+use hir_def::TypeParamId;\n \n #[derive(Debug)]\n pub struct TyLoweringContext<'a, DB: HirDatabase> {\n@@ -145,7 +145,16 @@ impl Ty {\n                     ImplTraitLoweringMode::Param => {\n                         let idx = ctx.impl_trait_counter.get();\n                         ctx.impl_trait_counter.set(idx + 1);\n-                        Ty::Param { idx: idx as u32, name: Name::missing() }\n+                        if let Some(def) = ctx.resolver.generic_def() {\n+                            let generics = generics(ctx.db, def);\n+                            let param = generics\n+                                .iter()\n+                                .nth(idx as usize)\n+                                .map_or(Ty::Unknown, |(id, _)| Ty::Param(id));\n+                            param\n+                        } else {\n+                            Ty::Unknown\n+                        }\n                     }\n                     ImplTraitLoweringMode::Variable => {\n                         let idx = ctx.impl_trait_counter.get();\n@@ -176,7 +185,7 @@ impl Ty {\n     fn from_hir_only_param(\n         ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n-    ) -> Option<u32> {\n+    ) -> Option<TypeParamId> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n@@ -192,9 +201,7 @@ impl Ty {\n             _ => return None,\n         };\n         if let TypeNs::GenericParam(param_id) = resolution {\n-            let generics = generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n-            let idx = generics.param_idx(param_id);\n-            Some(idx)\n+            Some(param_id)\n         } else {\n             None\n         }\n@@ -256,28 +263,26 @@ impl Ty {\n             TypeNs::GenericParam(param_id) => {\n                 let generics =\n                     generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n-                let idx = generics.param_idx(param_id);\n                 match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n-                        // FIXME: maybe return name in resolution?\n-                        let name = generics.param_name(param_id);\n-                        Ty::Param { idx, name }\n+                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Variable => {\n+                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        Ty::Bound(idx)\n                     }\n-                    TypeParamLoweringMode::Variable => Ty::Bound(idx),\n                 }\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = generics(ctx.db, impl_id.into());\n                 let substs = match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => Substs::identity(&generics),\n+                    TypeParamLoweringMode::Placeholder => Substs::type_params(&generics),\n                     TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n                 };\n                 ctx.db.impl_self_ty(impl_id).subst(&substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(ctx.db, adt.into());\n                 let substs = match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => Substs::identity(&generics),\n+                    TypeParamLoweringMode::Placeholder => Substs::type_params(&generics),\n                     TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n                 };\n                 ctx.db.ty(adt.into()).subst(&substs)\n@@ -319,20 +324,28 @@ impl Ty {\n         self_ty: Ty,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n-        let param_idx = match self_ty {\n-            Ty::Param { idx, .. } if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => idx,\n-            Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => idx,\n-            _ => return Ty::Unknown, // Error: Ambiguous associated type\n-        };\n         let def = match ctx.resolver.generic_def() {\n             Some(def) => def,\n             None => return Ty::Unknown, // this can't actually happen\n         };\n-        let predicates = ctx.db.generic_predicates_for_param(def.into(), param_idx);\n+        let param_id = match self_ty {\n+            Ty::Param(id) if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => id,\n+            Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => {\n+                let generics = generics(ctx.db, def);\n+                let param_id = if let Some((id, _)) = generics.iter().nth(idx as usize) {\n+                    id\n+                } else {\n+                    return Ty::Unknown;\n+                };\n+                param_id\n+            },\n+            _ => return Ty::Unknown, // Error: Ambiguous associated type\n+        };\n+        let predicates = ctx.db.generic_predicates_for_param(param_id);\n         let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n             GenericPredicate::Implemented(tr) => {\n-                if let Ty::Param { idx, .. } = tr.self_ty() {\n-                    if *idx == param_idx {\n+                if let Ty::Param(id) = tr.self_ty() {\n+                    if *id == param_id {\n                         return Some(tr.trait_);\n                     }\n                 }\n@@ -530,13 +543,12 @@ impl GenericPredicate {\n                 let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n                 let generics = generics(ctx.db, generic_def);\n                 let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n-                let idx = generics.param_idx(param_id);\n                 match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n-                        let name = generics.param_name(param_id);\n-                        Ty::Param { idx, name }\n+                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Variable => {\n+                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        Ty::Bound(idx)\n                     }\n-                    TypeParamLoweringMode::Variable => Ty::Bound(idx),\n                 }\n             }\n         };\n@@ -599,17 +611,19 @@ pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> PolyFnSig {\n pub(crate) fn field_types_query(\n     db: &impl HirDatabase,\n     variant_id: VariantId,\n-) -> Arc<ArenaMap<LocalStructFieldId, Ty>> {\n+) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>> {\n     let var_data = variant_data(db, variant_id);\n-    let resolver = match variant_id {\n-        VariantId::StructId(it) => it.resolver(db),\n-        VariantId::UnionId(it) => it.resolver(db),\n-        VariantId::EnumVariantId(it) => it.parent.resolver(db),\n+    let (resolver, def): (_, GenericDefId) = match variant_id {\n+        VariantId::StructId(it) => (it.resolver(db), it.into()),\n+        VariantId::UnionId(it) => (it.resolver(db), it.into()),\n+        VariantId::EnumVariantId(it) => (it.parent.resolver(db), it.parent.into()),\n     };\n+    let generics = generics(db, def);\n     let mut res = ArenaMap::default();\n-    let ctx = TyLoweringContext::new(db, &resolver);\n+    let ctx = TyLoweringContext::new(db, &resolver)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Ty::from_hir(&ctx, &field_data.type_ref))\n+        res.insert(field_id, Binders::new(generics.len(), Ty::from_hir(&ctx, &field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -624,23 +638,20 @@ pub(crate) fn field_types_query(\n /// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n pub(crate) fn generic_predicates_for_param_query(\n     db: &impl HirDatabase,\n-    def: GenericDefId,\n-    param_idx: u32,\n+    param_id: TypeParamId,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    let resolver = param_id.parent.resolver(db);\n     let ctx = TyLoweringContext::new(db, &resolver);\n-    let generics = generics(db, def);\n+    // let generics = generics(db, def);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n         .filter(|pred| match &pred.target {\n             WherePredicateTarget::TypeRef(type_ref) => {\n-                Ty::from_hir_only_param(&ctx, type_ref) == Some(param_idx)\n+                Ty::from_hir_only_param(&ctx, type_ref) == Some(param_id)\n             }\n             WherePredicateTarget::TypeParam(local_id) => {\n-                let param_id = hir_def::TypeParamId { parent: def, local_id: *local_id };\n-                let idx = generics.param_idx(param_id);\n-                idx == param_idx\n+                *local_id == param_id.local_id\n             }\n         })\n         .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n@@ -650,8 +661,7 @@ pub(crate) fn generic_predicates_for_param_query(\n pub(crate) fn generic_predicates_for_param_recover(\n     _db: &impl HirDatabase,\n     _cycle: &[String],\n-    _def: &GenericDefId,\n-    _param_idx: &u32,\n+    _param_id: &TypeParamId,\n ) -> Arc<[GenericPredicate]> {\n     Arc::new([])\n }\n@@ -905,12 +915,12 @@ pub(crate) fn impl_self_ty_recover(\n     Binders::new(generics.len(), Ty::Unknown)\n }\n \n-pub(crate) fn impl_trait_query(db: &impl HirDatabase, impl_id: ImplId) -> Option<TraitRef> {\n+pub(crate) fn impl_trait_query(db: &impl HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n-    let generics = generics(db, impl_id.into());\n-    let ctx = TyLoweringContext::new(db, &resolver);\n-    let self_ty = db.impl_self_ty(impl_id).subst(&Substs::identity(&generics));\n+    let ctx = TyLoweringContext::new(db, &resolver)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let self_ty = db.impl_self_ty(impl_id);\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    TraitRef::from_hir(&ctx, target_trait, Some(self_ty.clone()))\n+    Some(Binders::new(self_ty.num_binders, TraitRef::from_hir(&ctx, target_trait, Some(self_ty.value.clone()))?))\n }"}, {"sha": "5283bff28f3ab4e2b1635f4364a2f39cc626230d", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -61,7 +61,7 @@ impl CrateImplBlocks {\n             for impl_id in module_data.scope.impls() {\n                 match db.impl_trait(impl_id) {\n                     Some(tr) => {\n-                        res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n+                        res.impls_by_trait.entry(tr.value.trait_).or_default().push(impl_id);\n                     }\n                     None => {\n                         let self_ty = db.impl_self_ty(impl_id);"}, {"sha": "1722563aa15d8a8de1d00af38470c519080ff4ff", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -697,7 +697,7 @@ fn test<U, T: Trait<U>>(t: T) {\n     [71; 72) 't': T\n     [77; 96) '{     ...d(); }': ()\n     [83; 84) 't': T\n-    [83; 93) 't.method()': [missing name]\n+    [83; 93) 't.method()': U\n     \"###\n     );\n }"}, {"sha": "e6f697fa346ccbd0feaeb14d025cde2e45099654", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -822,8 +822,7 @@ fn test<T: ApplyL>() {\n \"#,\n     );\n     // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n-    // FIXME: fix type parameter names going missing when going through Chalk\n-    assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]"}, {"sha": "6e97f7dd21f507c0b8218d34e63b735271321860", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -142,8 +142,9 @@ impl ToChalk for Ty {\n                 let substitution = proj_ty.parameters.to_chalk(db);\n                 chalk_ir::AliasTy { associated_ty_id, substitution }.cast().intern()\n             }\n-            Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n+            Ty::Param(id) => {\n+                let interned_id = db.intern_type_param_id(id);\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: interned_id.as_intern_id().as_usize() }\n                     .to_ty::<TypeFamily>()\n             }\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n@@ -177,7 +178,8 @@ impl ToChalk for Ty {\n             },\n             chalk_ir::TyData::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n-                Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n+                let interned_id = crate::db::GlobalTypeParamId::from_intern_id(crate::salsa::InternId::from(idx.idx));\n+                Ty::Param(db.lookup_intern_type_param_id(interned_id))\n             }\n             chalk_ir::TyData::Alias(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n@@ -524,7 +526,7 @@ fn convert_where_clauses(\n             // skip errored predicates completely\n             continue;\n         }\n-        result.push(pred.clone().subst(substs).to_chalk(db));\n+        result.push(pred.clone().subst_type_params(db, def, substs).to_chalk(db));\n     }\n     result\n }\n@@ -709,12 +711,12 @@ fn impl_block_datum(\n     let trait_ref = db\n         .impl_trait(impl_id)\n         // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n-        .expect(\"invalid impl passed to Chalk\");\n+        .expect(\"invalid impl passed to Chalk\")\n+        .value;\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = trait_ref.subst(&bound_vars);\n     let trait_ = trait_ref.trait_;\n     let impl_type = if impl_id.lookup(db).container.module(db).krate == krate {\n         chalk_rust_ir::ImplType::Local\n@@ -789,20 +791,18 @@ fn type_alias_associated_ty_value(\n         _ => panic!(\"assoc ty value should be in impl\"),\n     };\n \n-    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\"); // we don't return any assoc ty values if the impl'd trait can't be resolved\n+    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\").value; // we don't return any assoc ty values if the impl'd trait can't be resolved\n \n     let assoc_ty = db\n         .trait_data(trait_ref.trait_)\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let generic_params = generics(db, impl_id.into());\n-    let bound_vars = Substs::bound_vars(&generic_params);\n-    let ty = db.ty(type_alias.into()).subst(&bound_vars);\n-    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let ty = db.ty(type_alias.into());\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n     let value = chalk_rust_ir::AssociatedTyValue {\n         impl_id: Impl::ImplBlock(impl_id.into()).to_chalk(db),\n         associated_ty_id: assoc_ty.to_chalk(db),\n-        value: make_binders(value_bound, bound_vars.len()),\n+        value: make_binders(value_bound, ty.num_binders),\n     };\n     Arc::new(value)\n }"}, {"sha": "8fa1838bd8949ddb4187a505d1cb66aaacc4780e", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=ed25cf70d5e0df9c7a33deb503ea14c2d97bd7a7", "patch": "@@ -99,23 +99,19 @@ pub(crate) struct Generics {\n }\n \n impl Generics {\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (u32, &'a TypeParamData)> + 'a {\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n         self.parent_generics\n             .as_ref()\n             .into_iter()\n-            .flat_map(|it| it.params.types.iter())\n-            .chain(self.params.types.iter())\n-            .enumerate()\n-            .map(|(i, (_local_id, p))| (i as u32, p))\n+            .flat_map(|it| it.params.types.iter().map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p)))\n+            .chain(self.params.types.iter().map(move |(local_id, p)| (TypeParamId { parent: self.def, local_id }, p)))\n     }\n \n-    pub(crate) fn iter_parent<'a>(&'a self) -> impl Iterator<Item = (u32, &'a TypeParamData)> + 'a {\n+    pub(crate) fn iter_parent<'a>(&'a self) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n         self.parent_generics\n             .as_ref()\n             .into_iter()\n-            .flat_map(|it| it.params.types.iter())\n-            .enumerate()\n-            .map(|(i, (_local_id, p))| (i as u32, p))\n+            .flat_map(|it| it.params.types.iter().map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p)))\n     }\n \n     pub(crate) fn len(&self) -> usize {\n@@ -137,16 +133,11 @@ impl Generics {\n         (self_params, list_params, impl_trait_params)\n     }\n \n-    pub(crate) fn param_idx(&self, param: TypeParamId) -> u32 {\n-        self.find_param(param).0\n+    pub(crate) fn param_idx(&self, param: TypeParamId) -> Option<u32> {\n+        Some(self.find_param(param)?.0)\n     }\n \n-    pub(crate) fn param_name(&self, param: TypeParamId) -> Name {\n-        // FIXME make this return Option\n-        self.find_param(param).1.name.clone().unwrap_or_else(Name::missing)\n-    }\n-\n-    fn find_param(&self, param: TypeParamId) -> (u32, &TypeParamData) {\n+    fn find_param(&self, param: TypeParamId) -> Option<(u32, &TypeParamData)> {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) = self\n                 .params\n@@ -156,9 +147,10 @@ impl Generics {\n                 .find(|(_, (idx, _))| *idx == param.local_id)\n                 .unwrap();\n             let (_total, parent_len, _child) = self.len_split();\n-            return ((parent_len + idx) as u32, data);\n+            Some(((parent_len + idx) as u32, data))\n+        } else {\n+            self.parent_generics.as_ref().and_then(|g| g.find_param(param))\n         }\n-        self.parent_generics.as_ref().unwrap().find_param(param)\n     }\n }\n "}]}