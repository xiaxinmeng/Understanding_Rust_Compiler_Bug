{"sha": "87debd93285e5527d17ed89ba6930fec5fd3f263", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZGViZDkzMjg1ZTU1MjdkMTdlZDg5YmE2OTMwZmVjNWZkM2YyNjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-24T17:19:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T18:07:20Z"}, "message": "include the immediate type in the symbol name hash\n\nthe intention is to give some simple protection like link-guards\nbut not impede ability to upgrade dylib in place", "tree": {"sha": "e8f430b22085fb691067af83e623765e657d3064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f430b22085fb691067af83e623765e657d3064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87debd93285e5527d17ed89ba6930fec5fd3f263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87debd93285e5527d17ed89ba6930fec5fd3f263", "html_url": "https://github.com/rust-lang/rust/commit/87debd93285e5527d17ed89ba6930fec5fd3f263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87debd93285e5527d17ed89ba6930fec5fd3f263/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "814477a8935bb2ee666cc74f861e21cd4d1fa57a", "url": "https://api.github.com/repos/rust-lang/rust/commits/814477a8935bb2ee666cc74f861e21cd4d1fa57a", "html_url": "https://github.com/rust-lang/rust/commit/814477a8935bb2ee666cc74f861e21cd4d1fa57a"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "13a82c0baaa261ac780eb86724ade82f6ab90b82", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/87debd93285e5527d17ed89ba6930fec5fd3f263/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87debd93285e5527d17ed89ba6930fec5fd3f263/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=87debd93285e5527d17ed89ba6930fec5fd3f263", "patch": "@@ -104,7 +104,7 @@ use rustc::middle::cstore;\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty::{self, TypeFoldable};\n use rustc::middle::ty::item_path::{ItemPathBuffer, RootMode};\n-use rustc::front::map::definitions::DefPath;\n+use rustc::front::map::definitions::{DefPath, DefPathData};\n \n use std::fmt::Write;\n use syntax::parse::token::{self, InternedString};\n@@ -134,7 +134,18 @@ pub fn def_path_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_path: &DefPath) -> S\n }\n \n fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+\n+                             // path to the item this name is for\n                              def_path: &DefPath,\n+\n+                             // type of the item, without any generic\n+                             // parameters substituted; this is\n+                             // included in the hash as a kind of\n+                             // safeguard.\n+                             item_type: ty::Ty<'tcx>,\n+\n+                             // values for generic type parameters,\n+                             // if any.\n                              parameters: &[ty::Ty<'tcx>])\n                              -> String {\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n@@ -151,6 +162,13 @@ fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // truly unique path\n     hash_state.input_str(&def_path_to_string(tcx, def_path));\n \n+    // Include the main item-type. Note that, in this case, the\n+    // assertions about `needs_subst` may not hold, but this item-type\n+    // ought to be the same for every reference anyway.\n+    assert!(!item_type.has_erasable_regions());\n+    let encoded_item_type = tcx.sess.cstore.encode_type(tcx, item_type, def_id_to_string);\n+    hash_state.input(&encoded_item_type[..]);\n+\n     // also include any type parameters (for generic items)\n     for t in parameters {\n        assert!(!t.has_erasable_regions());\n@@ -185,7 +203,38 @@ fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let def_path = ccx.tcx().def_path(def_id);\n     assert_eq!(def_path.krate, def_id.krate);\n-    let hash = get_symbol_hash(ccx, &def_path, parameters.as_slice());\n+\n+    // We want to compute the \"type\" of this item. Unfortunately, some\n+    // kinds of items (e.g., closures) don't have an entry in the\n+    // item-type array. So walk back up the find the closest parent\n+    // that DOES have an entry.\n+    let mut ty_def_id = def_id;\n+    let instance_ty;\n+    loop {\n+        let key = ccx.tcx().def_key(ty_def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::TypeNs(_) |\n+            DefPathData::ValueNs(_) => {\n+                instance_ty = ccx.tcx().lookup_item_type(ty_def_id);\n+                break;\n+            }\n+            _ => {\n+                // if we're making a symbol for something, there ought\n+                // to be a value or type-def or something in there\n+                // *somewhere*\n+                ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                    panic!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                            parent\", def_id, ty_def_id);\n+                });\n+            }\n+        }\n+    }\n+\n+    // Erase regions because they may not be deterministic when hashed\n+    // and should not matter anyhow.\n+    let instance_ty = ccx.tcx().erase_regions(&instance_ty.ty);\n+\n+    let hash = get_symbol_hash(ccx, &def_path, instance_ty, parameters.as_slice());\n \n     let mut buffer = SymbolPathBuffer {\n         names: Vec::with_capacity(def_path.data.len())\n@@ -239,7 +288,7 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(ccx, &def_path, &[t]);\n+    let hash = get_symbol_hash(ccx, &def_path, t, &[]);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n "}]}