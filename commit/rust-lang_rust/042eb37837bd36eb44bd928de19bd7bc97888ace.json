{"sha": "042eb37837bd36eb44bd928de19bd7bc97888ace", "node_id": "C_kwDOAAsO6NoAKDA0MmViMzc4MzdiZDM2ZWI0NGJkOTI4ZGUxOWJkN2JjOTc4ODhhY2U", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T01:44:32Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T01:45:58Z"}, "message": "Implement register allocation for inline assembly", "tree": {"sha": "edcddac44150516d4b1d8c0e43d905d832e5b167", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edcddac44150516d4b1d8c0e43d905d832e5b167"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/042eb37837bd36eb44bd928de19bd7bc97888ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/042eb37837bd36eb44bd928de19bd7bc97888ace", "html_url": "https://github.com/rust-lang/rust/commit/042eb37837bd36eb44bd928de19bd7bc97888ace", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/042eb37837bd36eb44bd928de19bd7bc97888ace/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd87c6dab95dc1b24f136f9b28b236999e8dd2cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd87c6dab95dc1b24f136f9b28b236999e8dd2cf", "html_url": "https://github.com/rust-lang/rust/commit/fd87c6dab95dc1b24f136f9b28b236999e8dd2cf"}], "stats": {"total": 277, "additions": 207, "deletions": 70}, "files": [{"sha": "07bb2622735d7ae49693d94775299dd38a894ddd", "filename": "src/inline_asm.rs", "status": "modified", "additions": 207, "deletions": 70, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/042eb37837bd36eb44bd928de19bd7bc97888ace/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042eb37837bd36eb44bd928de19bd7bc97888ace/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=042eb37837bd36eb44bd928de19bd7bc97888ace", "patch": "@@ -6,6 +6,7 @@ use std::fmt::Write;\n \n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir::InlineAsmOperand;\n+use rustc_span::Symbol;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n@@ -115,11 +116,21 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         offset\n     };\n \n+    let mut asm_gen = InlineAssemblyGenerator {\n+        tcx: fx.tcx,\n+        arch: InlineAsmArch::X86_64,\n+        template,\n+        operands,\n+        options,\n+        registers: Vec::new(),\n+    };\n+    asm_gen.allocate_registers();\n+\n     // FIXME overlap input and output slots to save stack space\n-    for operand in operands {\n+    for (i, operand) in operands.iter().enumerate() {\n         match *operand {\n             InlineAsmOperand::In { reg, ref value } => {\n-                let reg = expect_reg(reg);\n+                let reg = asm_gen.registers[i].unwrap();\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 inputs.push((\n                     reg,\n@@ -128,7 +139,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 ));\n             }\n             InlineAsmOperand::Out { reg, late: _, place } => {\n-                let reg = expect_reg(reg);\n+                let reg = asm_gen.registers[i].unwrap();\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 if let Some(place) = place {\n                     outputs.push((\n@@ -139,7 +150,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 }\n             }\n             InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n-                let reg = expect_reg(reg);\n+                let reg = asm_gen.registers[i].unwrap();\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 inputs.push((\n                     reg,\n@@ -164,94 +175,220 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     fx.inline_asm_index += 1;\n     let asm_name = format!(\"{}__inline_asm_{}\", fx.symbol_name, inline_asm_index);\n \n-    let generated_asm = generate_asm_wrapper(\n-        &asm_name,\n-        InlineAsmArch::X86_64,\n-        options,\n-        template,\n-        clobbered_regs,\n-        &inputs,\n-        &outputs,\n-    );\n+    let generated_asm = asm_gen.generate_asm_wrapper(&asm_name, clobbered_regs, &inputs, &outputs);\n     fx.cx.global_asm.push_str(&generated_asm);\n \n     call_inline_asm(fx, &asm_name, slot_size, inputs, outputs);\n }\n \n-fn generate_asm_wrapper(\n-    asm_name: &str,\n+struct InlineAssemblyGenerator<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     arch: InlineAsmArch,\n+    template: &'a [InlineAsmTemplatePiece],\n+    operands: &'a [InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n-    template: &[InlineAsmTemplatePiece],\n-    clobbered_regs: Vec<(InlineAsmReg, Size)>,\n-    inputs: &[(InlineAsmReg, Size, Value)],\n-    outputs: &[(InlineAsmReg, Size, CPlace<'_>)],\n-) -> String {\n-    let mut generated_asm = String::new();\n-    writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n-    writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n-    writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n-\n-    generated_asm.push_str(\".intel_syntax noprefix\\n\");\n-    generated_asm.push_str(\"    push rbp\\n\");\n-    generated_asm.push_str(\"    mov rbp,rdi\\n\");\n-\n-    // Save clobbered registers\n-    if !options.contains(InlineAsmOptions::NORETURN) {\n-        // FIXME skip registers saved by the calling convention\n-        for &(reg, offset) in &clobbered_regs {\n-            save_register(&mut generated_asm, arch, reg, offset);\n-        }\n-    }\n+    registers: Vec<Option<InlineAsmReg>>,\n+}\n \n-    // Write input registers\n-    for &(reg, offset, _value) in inputs {\n-        restore_register(&mut generated_asm, arch, reg, offset);\n-    }\n+impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n+    fn allocate_registers(&mut self) {\n+        let sess = self.tcx.sess;\n+        let map = allocatable_registers(\n+            self.arch,\n+            |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+            &sess.target,\n+        );\n+        let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n+        let mut regs = vec![None; self.operands.len()];\n+\n+        // Add explicit registers to the allocated set.\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().0 = true;\n+                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(reg), late: true, ..\n+                } => {\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().1 = true;\n+                }\n+                InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n+                | InlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                    regs[i] = Some(reg);\n+                    allocated.insert(reg, (true, true));\n+                }\n+                _ => (),\n+            }\n+        }\n \n-    if options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-        generated_asm.push_str(\".att_syntax\\n\");\n-    }\n+        // Allocate out/inout/inlateout registers first because they are more constrained.\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::RegClass(class),\n+                    late: false,\n+                    ..\n+                }\n+                | InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::RegClass(class), ..\n+                } => {\n+                    let mut alloc_reg = None;\n+                    for &reg in &map[&class] {\n+                        let mut used = false;\n+                        reg.overlapping_regs(|r| {\n+                            if allocated.contains_key(&r) {\n+                                used = true;\n+                            }\n+                        });\n+\n+                        if !used {\n+                            alloc_reg = Some(reg);\n+                            break;\n+                        }\n+                    }\n+\n+                    let reg = alloc_reg.expect(\"cannot allocate registers\");\n+                    regs[i] = Some(reg);\n+                    allocated.insert(reg, (true, true));\n+                }\n+                _ => (),\n+            }\n+        }\n \n-    // The actual inline asm\n-    for piece in template {\n-        match piece {\n-            InlineAsmTemplatePiece::String(s) => {\n-                generated_asm.push_str(s);\n+        // Allocate in/lateout.\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n+                    let mut alloc_reg = None;\n+                    for &reg in &map[&class] {\n+                        let mut used = false;\n+                        reg.overlapping_regs(|r| {\n+                            if allocated.get(&r).copied().unwrap_or_default().0 {\n+                                used = true;\n+                            }\n+                        });\n+\n+                        if !used {\n+                            alloc_reg = Some(reg);\n+                            break;\n+                        }\n+                    }\n+\n+                    let reg = alloc_reg.expect(\"cannot allocate registers\");\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().0 = true;\n+                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::RegClass(class),\n+                    late: true,\n+                    ..\n+                } => {\n+                    let mut alloc_reg = None;\n+                    for &reg in &map[&class] {\n+                        let mut used = false;\n+                        reg.overlapping_regs(|r| {\n+                            if allocated.get(&r).copied().unwrap_or_default().1 {\n+                                used = true;\n+                            }\n+                        });\n+\n+                        if !used {\n+                            alloc_reg = Some(reg);\n+                            break;\n+                        }\n+                    }\n+\n+                    let reg = alloc_reg.expect(\"cannot allocate registers\");\n+                    regs[i] = Some(reg);\n+                    allocated.entry(reg).or_default().1 = true;\n+                }\n+                _ => (),\n             }\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n         }\n+\n+        self.registers = regs;\n     }\n-    generated_asm.push('\\n');\n \n-    if options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+    fn generate_asm_wrapper(\n+        &self,\n+        asm_name: &str,\n+        clobbered_regs: Vec<(InlineAsmReg, Size)>,\n+        inputs: &[(InlineAsmReg, Size, Value)],\n+        outputs: &[(InlineAsmReg, Size, CPlace<'_>)],\n+    ) -> String {\n+        let mut generated_asm = String::new();\n+        writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n+        writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n+        writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n+        writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n+\n         generated_asm.push_str(\".intel_syntax noprefix\\n\");\n-    }\n+        generated_asm.push_str(\"    push rbp\\n\");\n+        generated_asm.push_str(\"    mov rbp,rdi\\n\");\n+\n+        // Save clobbered registers\n+        if !self.options.contains(InlineAsmOptions::NORETURN) {\n+            // FIXME skip registers saved by the calling convention\n+            for &(reg, offset) in &clobbered_regs {\n+                save_register(&mut generated_asm, self.arch, reg, offset);\n+            }\n+        }\n \n-    if !options.contains(InlineAsmOptions::NORETURN) {\n-        // Read output registers\n-        for &(reg, offset, _place) in outputs {\n-            save_register(&mut generated_asm, arch, reg, offset);\n+        // Write input registers\n+        for &(reg, offset, _value) in inputs {\n+            restore_register(&mut generated_asm, self.arch, reg, offset);\n         }\n \n-        // Restore clobbered registers\n-        for &(reg, offset) in clobbered_regs.iter().rev() {\n-            restore_register(&mut generated_asm, arch, reg, offset);\n+        if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            generated_asm.push_str(\".att_syntax\\n\");\n         }\n \n-        generated_asm.push_str(\"    pop rbp\\n\");\n-        generated_asm.push_str(\"    ret\\n\");\n-    } else {\n-        generated_asm.push_str(\"    ud2\\n\");\n-    }\n+        // The actual inline asm\n+        for piece in self.template {\n+            match piece {\n+                InlineAsmTemplatePiece::String(s) => {\n+                    generated_asm.push_str(s);\n+                }\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n+                    self.registers[*operand_idx]\n+                        .unwrap()\n+                        .emit(&mut generated_asm, self.arch, *modifier)\n+                        .unwrap();\n+                }\n+            }\n+        }\n+        generated_asm.push('\\n');\n+\n+        if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            generated_asm.push_str(\".intel_syntax noprefix\\n\");\n+        }\n+\n+        if !self.options.contains(InlineAsmOptions::NORETURN) {\n+            // Read output registers\n+            for &(reg, offset, _place) in outputs {\n+                save_register(&mut generated_asm, self.arch, reg, offset);\n+            }\n \n-    generated_asm.push_str(\".att_syntax\\n\");\n-    writeln!(generated_asm, \".size {name}, .-{name}\", name = asm_name).unwrap();\n-    generated_asm.push_str(\".text\\n\");\n-    generated_asm.push_str(\"\\n\\n\");\n+            // Restore clobbered registers\n+            for &(reg, offset) in clobbered_regs.iter().rev() {\n+                restore_register(&mut generated_asm, self.arch, reg, offset);\n+            }\n+\n+            generated_asm.push_str(\"    pop rbp\\n\");\n+            generated_asm.push_str(\"    ret\\n\");\n+        } else {\n+            generated_asm.push_str(\"    ud2\\n\");\n+        }\n \n-    generated_asm\n+        generated_asm.push_str(\".att_syntax\\n\");\n+        writeln!(generated_asm, \".size {name}, .-{name}\", name = asm_name).unwrap();\n+        generated_asm.push_str(\".text\\n\");\n+        generated_asm.push_str(\"\\n\\n\");\n+\n+        generated_asm\n+    }\n }\n \n fn call_inline_asm<'tcx>("}]}