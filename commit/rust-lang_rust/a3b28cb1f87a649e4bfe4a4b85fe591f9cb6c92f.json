{"sha": "a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYjI4Y2IxZjg3YTY0OWU0YmZlNGE0Yjg1ZmU1OTFmOWNiNmM5MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-28T21:26:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-28T21:26:48Z"}, "message": "auto merge of #13819 : nick29581/rust/ty_str, r=pcwalton\n\nSimilar to my recent changes to ~[T]/&[T], these changes remove the vstore abstraction and represent str types as ~(str) and &(str). The Option<uint> in ty_str is the length of the string, None if the string is dynamically sized.", "tree": {"sha": "ff18a2d92fcaf0915fcab500549f064b16d69718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff18a2d92fcaf0915fcab500549f064b16d69718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "html_url": "https://github.com/rust-lang/rust/commit/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23262a83909392f88fdc8031ebd754f8d9b94525", "url": "https://api.github.com/repos/rust-lang/rust/commits/23262a83909392f88fdc8031ebd754f8d9b94525", "html_url": "https://github.com/rust-lang/rust/commit/23262a83909392f88fdc8031ebd754f8d9b94525"}, {"sha": "c0ff3caae1c0fb7817e09749c5f1ddae3b301ee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0ff3caae1c0fb7817e09749c5f1ddae3b301ee2", "html_url": "https://github.com/rust-lang/rust/commit/c0ff3caae1c0fb7817e09749c5f1ddae3b301ee2"}], "stats": {"total": 828, "additions": 319, "deletions": 509}, "files": [{"sha": "30cce6d15f718681c1c44e8c57c77eff2a645d11", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -138,23 +138,6 @@ pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_substs(&mut st, conv)\n }\n \n-fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::Vstore {\n-    assert_eq!(next(st), '/');\n-\n-    let c = peek(st);\n-    if '0' <= c && c <= '9' {\n-        let n = parse_uint(st);\n-        assert_eq!(next(st), '|');\n-        return ty::VstoreFixed(n);\n-    }\n-\n-    match next(st) {\n-        '~' => ty::VstoreUniq,\n-        '&' => ty::VstoreSlice(parse_region(st, conv)),\n-        c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n-    }\n-}\n-\n fn parse_size(st: &mut PState) -> Option<uint> {\n     assert_eq!(next(st), '/');\n \n@@ -361,8 +344,8 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_vec(st.tcx, mt, sz);\n       }\n       'v' => {\n-        let v = parse_vstore(st, |x,y| conv(x,y));\n-        return ty::mk_str(st.tcx, v);\n+        let sz = parse_size(st);\n+        return ty::mk_str(st.tcx, sz);\n       }\n       'T' => {\n         assert_eq!(next(st), '[');"}, {"sha": "333c45bb356b8a68a32204fb4acd1e2003d044b0", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -177,21 +177,6 @@ fn enc_bound_region(w: &mut MemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_vstore(w: &mut MemWriter, cx: &ctxt,\n-                  v: ty::Vstore,\n-                  enc_mut: |&mut MemWriter|) {\n-    mywrite!(w, \"/\");\n-    match v {\n-        ty::VstoreFixed(u) => mywrite!(w, \"{}|\", u),\n-        ty::VstoreUniq => mywrite!(w, \"~\"),\n-        ty::VstoreSlice(r) => {\n-            mywrite!(w, \"&\");\n-            enc_region(w, cx, r);\n-            enc_mut(w);\n-        }\n-    }\n-}\n-\n pub fn enc_trait_ref(w: &mut MemWriter, cx: &ctxt, s: &ty::TraitRef) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n@@ -275,9 +260,13 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n                 None => mywrite!(w, \"|\"),\n             }\n         }\n-        ty::ty_str(v) => {\n+        ty::ty_str(sz) => {\n             mywrite!(w, \"v\");\n-            enc_vstore(w, cx, v, |_| {});\n+            mywrite!(w, \"/\");\n+            match sz {\n+                Some(n) => mywrite!(w, \"{}|\", n),\n+                None => mywrite!(w, \"|\"),\n+            }\n         }\n         ty::ty_closure(ref f) => {\n             mywrite!(w, \"f\");"}, {"sha": "cf66a10f46bb02f2a046f052cc6a1ac16bada330", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -405,6 +405,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_struct(..) => check_matrix_for_wild(cx, m),\n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n           ty::ty_vec(_, None) => ctor_for_slice(m),\n+          ty::ty_str(None) => Some(single),\n           _ => check_matrix_for_wild(cx, m),\n       },\n       ty::ty_enum(eid, _) => {"}, {"sha": "c77477116a5f1604f179b4cd134d98567d0eb28a", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -68,6 +68,13 @@ impl<'a> EffectCheckVisitor<'a> {\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_str(self.tcx, base_type));\n         match ty::get(base_type).sty {\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+                ty::ty_str(None) => {\n+                    self.tcx.sess.span_err(e.span,\n+                        \"modification of string types is not allowed\");\n+                }\n+                _ => {}\n+            },\n             ty::ty_str(..) => {\n                 self.tcx.sess.span_err(e.span,\n                     \"modification of string types is not allowed\");"}, {"sha": "c15eb3a9774f96d19fe55376d4411dc20690c3ee", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -911,7 +911,7 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n                 ty::ty_box(_) => {\n                     n_box += 1;\n                 }\n-                ty::ty_uniq(_) | ty::ty_str(ty::VstoreUniq) |\n+                ty::ty_uniq(_) |\n                 ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n                 ty::ty_closure(~ty::ClosureTy { store: ty::UniqTraitStore, .. }) => {\n                     n_uniq += 1;"}, {"sha": "2d80e37db17429f908cac498d18a01a30c46723a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -174,7 +174,6 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n         ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n-        ty::ty_str(ty::VstoreUniq) |\n         ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n         }\n@@ -188,7 +187,6 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n-        ty::ty_str(ty::VstoreSlice(r)) |\n         ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(r, _), ..}) => {\n             Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n@@ -207,7 +205,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         }\n \n         ty::ty_vec(_, Some(_)) |\n-        ty::ty_str(ty::VstoreFixed(_)) => {\n+        ty::ty_str(Some(_)) => {\n             Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n@@ -1306,6 +1304,7 @@ fn element_kind(t: ty::t) -> ElementKind {\n         ty::ty_rptr(_, ty::mt{ty:ty, ..}) |\n         ty::ty_uniq(ty) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) => VecElement,\n+            ty::ty_str(None) => StrElement,\n             _ => OtherElement\n         },\n         ty::ty_vec(..) => VecElement,"}, {"sha": "eea8e129066e76f7c00866096c9fbb860aa2e0c1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -1293,40 +1293,51 @@ fn compare_values<'a>(\n                   rhs: ValueRef,\n                   rhs_t: ty::t)\n                   -> Result<'a> {\n+    fn compare_str<'a>(cx: &'a Block<'a>,\n+                       lhs: ValueRef,\n+                       rhs: ValueRef,\n+                       rhs_t: ty::t)\n+                       -> Result<'a> {\n+        let did = langcall(cx, None,\n+                           format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n+                           StrEqFnLangItem);\n+        let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n+        Result {\n+            bcx: result.bcx,\n+            val: bool_to_i1(result.bcx, result.val)\n+        }\n+    }\n+\n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n-      let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq);\n-      return rslt(rs.bcx, rs.val);\n+        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq);\n+        return rslt(rs.bcx, rs.val);\n     }\n \n     match ty::get(rhs_t).sty {\n-        ty::ty_str(ty::VstoreUniq) => {\n-            let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n-            Store(cx, lhs, scratch_lhs);\n-            let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n-            Store(cx, rhs, scratch_rhs);\n-            let did = langcall(cx, None,\n-                               format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n-                               UniqStrEqFnLangItem);\n-            let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n-            Result {\n-                bcx: result.bcx,\n-                val: bool_to_i1(result.bcx, result.val)\n-            }\n-        }\n-        ty::ty_str(_) => {\n-            let did = langcall(cx, None,\n-                               format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n-                               StrEqFnLangItem);\n-            let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n-            Result {\n-                bcx: result.bcx,\n-                val: bool_to_i1(result.bcx, result.val)\n+        ty::ty_uniq(t) => match ty::get(t).sty {\n+            ty::ty_str(None) => {\n+                let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n+                Store(cx, lhs, scratch_lhs);\n+                let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n+                Store(cx, rhs, scratch_rhs);\n+                let did = langcall(cx, None,\n+                                   format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n+                                   UniqStrEqFnLangItem);\n+                let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n+                Result {\n+                    bcx: result.bcx,\n+                    val: bool_to_i1(result.bcx, result.val)\n+                }\n             }\n-        }\n-        _ => {\n-            cx.sess().bug(\"only scalars and strings supported in compare_values\");\n-        }\n+            _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+        },\n+        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+            ty::ty_str(None) => compare_str(cx, lhs, rhs, rhs_t),\n+            _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+        },\n+        ty::ty_str(Some(_)) => compare_str(cx, lhs, rhs, rhs_t),\n+        _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n     }\n }\n "}, {"sha": "1cfaaacd11b3adb90ee917b2c71c01f2a3e2c1bf", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -270,11 +270,10 @@ impl Case {\n         self.tys.iter().position(|&ty| {\n             match ty::get(ty).sty {\n                 ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-                    ty::ty_vec(_, None) => false,\n+                    ty::ty_vec(_, None) | ty::ty_str(None)=> false,\n                     _ => true,\n                 },\n                 ty::ty_uniq(..) | ty::ty_box(..) |\n-                ty::ty_str(ty::VstoreUniq) |\n                 ty::ty_bare_fn(..) => true,\n                 // Is that everything?  Would closures or slices qualify?\n                 _ => false"}, {"sha": "6084523f7f670046da25a0d1795e8590a5b5f486", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -188,8 +188,8 @@ fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n         // `~` pointer return values never alias because ownership is transferred\n         // FIXME #6750 ~Trait cannot be directly marked as\n         // noalias because the actual object pointer is nested.\n-        ty::ty_uniq(..) | // ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-        ty::ty_str(ty::VstoreUniq) => {\n+        ty::ty_uniq(..) // | ty::ty_trait(_, _, ty::UniqTraitStore, _, _)\n+         => {\n             unsafe {\n                 llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n             }\n@@ -261,7 +261,6 @@ pub fn decl_rust_fn(ccx: &CrateContext, has_env: bool,\n             // FIXME #6750 ~Trait cannot be directly marked as\n             // noalias because the actual object pointer is nested.\n             ty::ty_uniq(..) | // ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-            ty::ty_str(ty::VstoreUniq) |\n             ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n@@ -665,7 +664,7 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n-      ty::ty_str(ty::VstoreFixed(n)) => {\n+      ty::ty_str(Some(n)) => {\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);"}, {"sha": "aee3300b3e6d861bd3671772aa25b33532de373c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -659,9 +659,10 @@ pub fn trans_call_inner<'a>(\n         match ty::get(ret_ty).sty {\n             // `~` pointer return values never alias because ownership\n             // is transferred\n-            ty::ty_uniq(..) => {\n-                attrs.push((0, NoAliasAttribute));\n-            }\n+            ty::ty_uniq(ty) => match ty::get(ty).sty {\n+                ty::ty_str(None) => {}\n+                _ => attrs.push((0, NoAliasAttribute)),\n+            },\n             _ => {}\n         }\n "}, {"sha": "6a3d2419cc6096818b2872823346b397de3e20ae", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -141,7 +141,7 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n             let dv = match ty::get(t).sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n                     match ty::get(mt.ty).sty {\n-                        ty::ty_vec(_, None) => cx.sess().bug(\"unexpected slice\"),\n+                        ty::ty_vec(_, None) | ty::ty_str(None) => cx.sess().bug(\"unexpected slice\"),\n                         _ => const_deref_ptr(cx, v),\n                     }\n                 }\n@@ -432,13 +432,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                           \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n-                  ty::ty_str(ty::VstoreSlice(..)) => {\n-                    let e1 = const_get_elt(cx, bv, [0]);\n-                    (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n-                  },\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n                   ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-                      ty::ty_vec(_, None) => {\n+                      ty::ty_vec(_, None) | ty::ty_str(None) => {\n                           let e1 = const_get_elt(cx, bv, [0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n@@ -451,7 +447,17 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_str(..) => {assert!(len > 0); len - 1},\n+                  ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+                      ty::ty_str(None) => {\n+                          assert!(len > 0);\n+                          len - 1\n+                      }\n+                      _ => len\n+                  },\n+                  ty::ty_str(Some(_)) => {\n+                      assert!(len > 0);\n+                      len - 1\n+                  },\n                   _ => len\n               };\n               if iv >= len {"}, {"sha": "49c41d5cda97457d46b2e35bfb95ebdfa54078dc", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -2182,35 +2182,29 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n             basic_type_metadata(cx, t)\n-        },\n-        ty::ty_str(ref vstore) => {\n+        }\n+        ty::ty_str(Some(len)) => {\n             let i8_t = ty::mk_i8();\n-            match *vstore {\n-                ty::VstoreFixed(len) => {\n-                    fixed_vec_metadata(cx, i8_t, len, usage_site_span)\n-                },\n-                ty::VstoreUniq  => {\n-                    let vec_metadata = vec_metadata(cx, i8_t, usage_site_span);\n-                    pointer_type_metadata(cx, t, vec_metadata)\n-                }\n-                ty::VstoreSlice(..) => {\n-                    vec_slice_metadata(cx, t, i8_t, usage_site_span)\n-                }\n-            }\n-        },\n+            fixed_vec_metadata(cx, i8_t, len, usage_site_span)\n+        }\n         ty::ty_enum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, usage_site_span).finalize(cx)\n-        },\n+        }\n         ty::ty_box(typ) => {\n             create_pointer_to_box_metadata(cx, t, typ)\n-        },\n+        }\n         ty::ty_vec(ref mt, Some(len)) => fixed_vec_metadata(cx, mt.ty, len, usage_site_span),\n         ty::ty_uniq(typ) => {\n             match ty::get(typ).sty {\n                 ty::ty_vec(ref mt, None) => {\n                     let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n+                ty::ty_str(None) => {\n+                    let i8_t = ty::mk_i8();\n+                    let vec_metadata = vec_metadata(cx, i8_t, usage_site_span);\n+                    pointer_type_metadata(cx, t, vec_metadata)\n+                }\n                 _ => {\n                     let pointee = type_metadata(cx, typ, usage_site_span);\n                     pointer_type_metadata(cx, t, pointee)\n@@ -2220,21 +2214,25 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n             match ty::get(mt.ty).sty {\n                 ty::ty_vec(ref mt, None) => vec_slice_metadata(cx, t, mt.ty, usage_site_span),\n+                ty::ty_str(None) => {\n+                    let i8_t = ty::mk_i8();\n+                    vec_slice_metadata(cx, t, i8_t, usage_site_span)\n+                }\n                 _ => {\n                     let pointee = type_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, pointee)\n                 }\n             }\n-        },\n+        }\n         ty::ty_bare_fn(ref barefnty) => {\n             subroutine_type_metadata(cx, &barefnty.sig, usage_site_span)\n-        },\n+        }\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n-        },\n+        }\n         ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, ref bounds }) => {\n             trait_metadata(cx, def_id, t, substs, store, bounds)\n-        },\n+        }\n         ty::ty_struct(def_id, ref substs) => {\n             if ty::type_is_simd(cx.tcx(), t) {\n                 let element_type = ty::simd_type(cx.tcx(), t);\n@@ -2243,7 +2241,7 @@ fn type_metadata(cx: &CrateContext,\n             } else {\n                 prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n             }\n-        },\n+        }\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,"}, {"sha": "71433d27c97a406038900a54fd9a1ac11d7af4d1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -1507,7 +1507,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n         ty::ty_float(..)   => cast_float,\n         ty::ty_ptr(..)     => cast_pointer,\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty{\n-            ty::ty_vec(_, None) => cast_other,\n+            ty::ty_vec(_, None) | ty::ty_str(None) => cast_other,\n             _ => cast_pointer,\n         },\n         ty::ty_bare_fn(..) => cast_pointer,\n@@ -1717,7 +1717,8 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n             match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) => bcx.tcx().sess.span_bug(expr.span, \"unexpected ~[T]\"),\n+                ty::ty_vec(_, None) | ty::ty_str(None)\n+                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected ~[T]\"),\n                 _ => deref_owned_pointer(bcx, expr, datum, content_ty),\n             }\n         }\n@@ -1734,7 +1735,8 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n             match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) => bcx.tcx().sess.span_bug(expr.span, \"unexpected &[T]\"),\n+                ty::ty_vec(_, None) | ty::ty_str(None)\n+                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected &[T]\"),\n                 _ => {\n                     assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n "}, {"sha": "4039bfaa9290839850484ce0a0997593cda786f9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -84,7 +84,7 @@ fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n \n         ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n             match ty::get(typ).sty {\n-                ty::ty_vec(_, None) => t,\n+                ty::ty_vec(_, None) | ty::ty_str(None) => t,\n                 _ => {\n                     let llty = sizing_type_of(ccx, typ);\n                     // Unique boxes do not allocate for zero-size types. The standard\n@@ -288,6 +288,13 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                         trans_exchange_free(bcx, llbox)\n                     })\n                 }\n+                ty::ty_str(None) => {\n+                    with_cond(bcx, not_null, |bcx| {\n+                        let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+                        let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n+                        trans_exchange_free(bcx, llbox)\n+                    })\n+                }\n                 _ => {\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty);\n@@ -296,15 +303,6 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 }\n             }\n         }\n-        ty::ty_str(ty::VstoreUniq) => {\n-            let llbox = Load(bcx, v0);\n-            let not_null = IsNotNull(bcx, llbox);\n-            with_cond(bcx, not_null, |bcx| {\n-                let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n-                let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n-                trans_exchange_free(bcx, llbox)\n-            })\n-        }\n         ty::ty_struct(did, ref substs) => {\n             let tcx = bcx.tcx();\n             match ty::ty_dtor(tcx, did) {"}, {"sha": "82f156a8bcd763a9ef9a4da25fbea7365d64041b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -55,8 +55,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n-        let str_vstore = ty::VstoreSlice(ty::ReStatic);\n-        let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n+        let str_ty = ty::mk_str_slice(bcx.tcx(), ty::ReStatic, ast::MutImmutable);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n         let len = C_uint(bcx.ccx(), s.get().len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s, false), Type::i8p(bcx.ccx()));\n@@ -122,20 +121,6 @@ impl<'a, 'b> Reflector<'a, 'b> {\n         self.visit(\"leave_\" + bracket_name, extra);\n     }\n \n-    pub fn vstore_name_and_extra(&mut self,\n-                                 t: ty::t,\n-                                 vstore: ty::Vstore)\n-                                 -> (~str, Vec<ValueRef> ) {\n-        match vstore {\n-            ty::VstoreFixed(n) => {\n-                let extra = (vec!(self.c_uint(n))).append(self.c_size_and_align(t).as_slice());\n-                (\"fixed\".to_owned(), extra)\n-            }\n-            ty::VstoreSlice(..) => (\"slice\".to_owned(), Vec::new()),\n-            ty::VstoreUniq => (\"uniq\".to_owned(), Vec::new()),\n-        }\n-    }\n-\n     pub fn leaf(&mut self, name: &str) {\n         self.visit(name, []);\n     }\n@@ -166,16 +151,16 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           ty::ty_float(ast::TyF128) => self.leaf(\"f128\"),\n \n           // Should rename to str_*/vec_*.\n-          ty::ty_str(vst) => {\n-              let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              self.visit(\"estr_\".to_owned() + name, extra.as_slice())\n+          ty::ty_str(Some(n)) => {\n+              let extra = (vec!(self.c_uint(n))).append(self.c_size_and_align(t).as_slice());\n+              self.visit(\"estr_fixed\".to_owned(), extra.as_slice())\n           }\n           ty::ty_vec(ref mt, Some(sz)) => {\n               let extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n               let extra = extra.append(self.c_mt(mt).as_slice());\n               self.visit(\"evec_fixed\".to_owned(), extra.as_slice())\n           }\n-          ty::ty_vec(..) => fail!(\"unexpected unsized vec\"),\n+          ty::ty_vec(..) | ty::ty_str(..) => fail!(\"unexpected unsized type\"),\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n@@ -187,10 +172,11 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           ty::ty_uniq(typ) => {\n               match ty::get(typ).sty {\n                   ty::ty_vec(ref mt, None) => {\n-                      let (name, extra) = (~\"uniq\", Vec::new());\n+                      let extra = Vec::new();\n                       let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(~\"evec_\" + name, extra.as_slice())\n+                      self.visit(\"evec_uniq\".to_owned(), extra.as_slice())\n                   }\n+                  ty::ty_str(None) => self.visit(\"estr_uniq\".to_owned(), &[]),\n                   _ => {\n                       let extra = self.c_mt(&ty::mt {\n                           ty: typ,\n@@ -211,6 +197,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                       let extra = extra.append(self.c_mt(mt).as_slice());\n                       self.visit(~\"evec_\" + name, extra.as_slice())\n                   }\n+                  ty::ty_str(None) => self.visit(\"estr_slice\".to_owned(), &[]),\n                   _ => {\n                       let extra = self.c_mt(mt);\n                       self.visit(\"rptr\", extra.as_slice())"}, {"sha": "435ed53d55d5efdc4aeae6a2eabffd49139747b7", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 20, "deletions": 55, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -244,7 +244,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                     let llptrval = C_cstr(ccx, (*s).clone(), false);\n                     let llptrval = PointerCast(bcx, llptrval, Type::i8p(ccx));\n                     let llsizeval = C_uint(ccx, s.get().len());\n-                    let typ = ty::mk_str(bcx.tcx(), ty::VstoreUniq);\n+                    let typ = ty::mk_uniq(bcx.tcx(), ty::mk_str(bcx.tcx(), None));\n                     let lldestval = rvalue_scratch_datum(bcx,\n                                                          typ,\n                                                          \"\");\n@@ -463,35 +463,6 @@ pub fn get_fixed_base_and_byte_len(bcx: &Block,\n     (base, len)\n }\n \n-pub fn get_base_and_byte_len_for_vec(bcx: &Block,\n-                                     llval: ValueRef,\n-                                     vec_ty: ty::t)\n-                                     -> (ValueRef, ValueRef) {\n-    /*!\n-     * Converts a vector into the slice pair.  The vector should be\n-     * stored in `llval` which should be by ref. If you have a datum,\n-     * you would probably prefer to call\n-     * `Datum::get_base_and_byte_len()`.\n-     */\n-\n-    let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n-\n-    let size = match ty::get(vec_ty).sty {\n-        ty::ty_vec(_, size) => size,\n-        _ => ccx.sess().bug(\"non-vector in get_base_and_byte_len_for_vec\"),\n-    };\n-\n-    match size {\n-        Some(n) => {\n-            let base = GEPi(bcx, llval, [0u, 0u]);\n-            let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n-            (base, len)\n-        }\n-        None => ccx.sess().bug(\"unsized vector in get_base_and_byte_len_for_vec\")\n-    }\n-}\n-\n pub fn get_base_and_len(bcx: &Block,\n                         llval: ValueRef,\n                         vec_ty: ty::t)\n@@ -505,38 +476,32 @@ pub fn get_base_and_len(bcx: &Block,\n      */\n \n     let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n \n-    let vstore = match ty::get(vec_ty).sty {\n-        ty::ty_str(vst) => vst,\n-        ty::ty_vec(_, Some(n)) => ty::VstoreFixed(n),\n-        ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n-            ty::ty_vec(_, None) => ty::VstoreSlice(r),\n+    match ty::get(vec_ty).sty {\n+        ty::ty_str(Some(n)) |\n+        ty::ty_vec(_, Some(n)) => {\n+            let base = GEPi(bcx, llval, [0u, 0u]);\n+            (base, C_uint(ccx, n))\n+        }\n+        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+            ty::ty_vec(_, None) | ty::ty_str(None) => {\n+                assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n+                let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n+                let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+                (base, count)\n+            }\n             _ => ccx.sess().bug(\"unexpected type (ty_rptr) in get_base_and_len\"),\n         },\n         ty::ty_uniq(t) => match ty::get(t).sty {\n-            ty::ty_vec(_, None) => ty::VstoreUniq,\n+            ty::ty_vec(_, None) | ty::ty_str(None) => {\n+                assert!(type_is_immediate(bcx.ccx(), vec_ty));\n+                let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n+                let body = Load(bcx, llval);\n+                (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n+            }\n             _ => ccx.sess().bug(\"unexpected type (ty_uniq) in get_base_and_len\"),\n         },\n         _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n-    };\n-\n-    match vstore {\n-        ty::VstoreFixed(n) => {\n-            let base = GEPi(bcx, llval, [0u, 0u]);\n-            (base, C_uint(ccx, n))\n-        }\n-        ty::VstoreSlice(..) => {\n-            assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n-            let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-            let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n-            (base, count)\n-        }\n-        ty::VstoreUniq => {\n-            assert!(type_is_immediate(bcx.ccx(), vec_ty));\n-            let body = Load(bcx, llval);\n-            (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n-        }\n     }\n }\n "}, {"sha": "e52c890c93eb8926c5b85e246e6382bf0f758ea4", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -116,26 +116,23 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n-        ty::ty_str(ty::VstoreUniq) |\n         ty::ty_box(..) |\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) => Type::i8p(cx),\n         ty::ty_rptr(_, mt) => {\n             match ty::get(mt.ty).sty {\n-                ty::ty_vec(_, None) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n+                ty::ty_vec(_, None) | ty::ty_str(None) => {\n+                    Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n+                }\n                 _ => Type::i8p(cx),\n             }\n         }\n \n-        ty::ty_str(ty::VstoreSlice(..)) => {\n-            Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n-        }\n-\n         ty::ty_bare_fn(..) => Type::i8p(cx),\n         ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n         ty::ty_trait(..) => Type::opaque_trait(cx),\n \n-        ty::ty_str(ty::VstoreFixed(size)) => Type::array(&Type::i8(cx), size as u64),\n+        ty::ty_str(Some(size)) => Type::array(&Type::i8(cx), size as u64),\n         ty::ty_vec(mt, Some(size)) => {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n@@ -157,7 +154,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) |\n-        ty::ty_err(..) | ty::ty_vec(_, None) => {\n+        ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str(None) => {\n             cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n                                   ty::get(t).sty))\n         }\n@@ -203,9 +200,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(cx, t),\n-      ty::ty_str(ty::VstoreUniq) => {\n-        Type::vec(cx, &Type::i8(cx)).ptr_to()\n-      }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n         // fill it in *after* placing it into the type cache. This\n@@ -221,6 +215,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_uniq(typ) => {\n           match ty::get(typ).sty {\n               ty::ty_vec(mt, None) => Type::vec(cx, &type_of(cx, mt.ty)).ptr_to(),\n+              ty::ty_str(None) => Type::vec(cx, &Type::i8(cx)).ptr_to(),\n               _ => type_of(cx, typ).ptr_to(),\n           }\n       }\n@@ -232,16 +227,15 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                   let u_ty = Type::uint_from_ty(cx, ast::TyU);\n                   Type::struct_(cx, [p_ty, u_ty], false)\n               }\n+              ty::ty_str(None) => {\n+                  // This means we get a nicer name in the output\n+                  cx.tn.find_type(\"str_slice\").unwrap()\n+              }\n               _ => type_of(cx, mt.ty).ptr_to(),\n           }\n       }\n \n-      ty::ty_str(ty::VstoreSlice(..)) => {\n-          // This means we get a nicer name in the output\n-          cx.tn.find_type(\"str_slice\").unwrap()\n-      }\n-\n-      ty::ty_str(ty::VstoreFixed(n)) => {\n+      ty::ty_str(Some(n)) => {\n           Type::array(&Type::i8(cx), (n + 1u) as u64)\n       }\n \n@@ -279,7 +273,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           }\n       }\n \n-      ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unszied ty_vec\"),\n+      ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unsized ty_vec\"),\n+      ty::ty_str(None) => cx.sess().bug(\"type_of with unsized ty_str\"),\n       ty::ty_self(..) => cx.sess().unimpl(\"type_of with ty_self\"),\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),"}, {"sha": "b87337fa240d6800b042b7e8c27ba84f3be30666", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 50, "deletions": 82, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -124,17 +124,6 @@ pub struct mt {\n     pub mutbl: ast::Mutability,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash, Show)]\n-/// Describes the \"storage mode\" of a str, whether it's fixed length or a slice.\n-pub enum Vstore {\n-    /// [T, ..N]\n-    VstoreFixed(uint),\n-    /// ~[T]\n-    VstoreUniq,\n-    /// &[T] and &mut [T]\n-    VstoreSlice(Region)\n-}\n-\n #[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum TraitStore {\n     /// ~Trait\n@@ -737,7 +726,8 @@ pub enum sty {\n     ty_enum(DefId, substs),\n     ty_box(t),\n     ty_uniq(t),\n-    ty_str(Vstore),\n+    // ty_str and ty_vec have an optional length.\n+    ty_str(Option<uint>),\n     ty_vec(mt, Option<uint>),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n@@ -815,7 +805,6 @@ pub enum type_err {\n     terr_regions_no_overlap(Region, Region),\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_vstores_differ(terr_vstore_kind, expected_found<Vstore>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_sorts(expected_found<t>),\n     terr_integer_as_char,\n@@ -1185,9 +1174,6 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         return f;\n     }\n     match &st {\n-      &ty_str(VstoreSlice(r)) => {\n-        flags |= rflags(r);\n-      }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str(_) => {}\n       // You might think that we could just return ty_err for\n@@ -1355,8 +1341,16 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: &ctxt, v: Vstore) -> t {\n-    mk_t(cx, ty_str(v))\n+pub fn mk_str(cx: &ctxt, sz: Option<uint>) -> t {\n+    mk_t(cx, ty_str(sz))\n+}\n+\n+pub fn mk_str_slice(cx: &ctxt, r: Region, m: ast::Mutability) -> t {\n+    mk_rptr(cx, r,\n+            mt {\n+                ty: mk_t(cx, ty_str(None)),\n+                mutbl: m\n+            })\n }\n \n pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: substs) -> t {\n@@ -1618,7 +1612,7 @@ pub fn type_is_self(ty: t) -> bool {\n fn type_is_slice(ty:t) -> bool {\n     match get(ty).sty {\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n-            ty_vec(_, None) => true,\n+            ty_vec(_, None) | ty_str(None) => true,\n             _ => false,\n         },\n         _ => false\n@@ -1629,8 +1623,7 @@ pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n       ty_vec(_, Some(_)) |\n-      ty_str(VstoreFixed(_)) | ty_str(VstoreSlice(_))\n-      => true,\n+      ty_str(Some(_)) => true,\n       _ => type_is_slice(ty)\n     }\n }\n@@ -1644,11 +1637,12 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n \n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n-        ty_str(_) => mk_mach_uint(ast::TyU8),\n-        ty_vec(mt, _) => mt.ty,\n+        ty_str(Some(_)) => mk_mach_uint(ast::TyU8),\n+        ty_vec(mt, Some(_)) => mt.ty,\n         ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n         ty_box(t) | ty_uniq(t) => match get(t).sty {\n             ty_vec(mt, None) => mt.ty,\n+            ty_str(None) => mk_mach_uint(ast::TyU8),\n             _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n         },\n         _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n@@ -1687,7 +1681,7 @@ pub fn type_is_region_ptr(ty: t) -> bool {\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n             // FIXME(nrc, DST) slices weren't regarded as rptrs, so we preserve this\n             // odd behaviour for now. (But ~[] were unique. I have no idea why).\n-            ty_vec(_, None) => false,\n+            ty_vec(_, None) | ty_str(None) => false,\n             _ => true\n         },\n         _ => false\n@@ -1703,7 +1697,7 @@ pub fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_uniq(_) | ty_str(VstoreUniq) => true,\n+        ty_uniq(_) => true,\n         _ => false\n     }\n }\n@@ -1776,8 +1770,7 @@ fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n             }\n             !needs_unwind_cleanup\n           }\n-          ty_uniq(_) |\n-          ty_str(VstoreUniq) => {\n+          ty_uniq(_) => {\n             // Once we're inside a box, the annihilator will find\n             // it and destroy it.\n             if !encountered_box {\n@@ -2090,10 +2083,6 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 TC::None\n             }\n \n-            ty_str(VstoreUniq) => {\n-                TC::OwnsOwned\n-            }\n-\n             ty_closure(ref c) => {\n                 closure_contents(cx, *c)\n             }\n@@ -2103,7 +2092,10 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_uniq(typ) => {\n-                tc_ty(cx, typ, cache).owned_pointer()\n+                match get(typ).sty {\n+                    ty_str(None) => TC::OwnsOwned,\n+                    _ => tc_ty(cx, typ, cache).owned_pointer(),\n+                }\n             }\n \n             ty_trait(~ty::TyTrait { store, bounds, .. }) => {\n@@ -2115,19 +2107,17 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_rptr(r, ref mt) => {\n-                tc_ty(cx, mt.ty, cache).reference(\n-                    borrowed_contents(r, mt.mutbl))\n+                match get(mt.ty).sty {\n+                    ty_str(None) => borrowed_contents(r, ast::MutImmutable),\n+                    _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n+                }\n             }\n \n             ty_vec(mt, _) => {\n                 tc_mt(cx, mt, cache)\n             }\n \n-            ty_str(VstoreSlice(r)) => {\n-                borrowed_contents(r, ast::MutImmutable)\n-            }\n-\n-            ty_str(VstoreFixed(_)) => {\n+            ty_str(_) => {\n                 TC::None\n             }\n \n@@ -2622,15 +2612,15 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     match get(t).sty {\n         ty_box(typ) | ty_uniq(typ) => match get(typ).sty {\n             // Don't deref ~[] etc., might need to generalise this to all DST.\n-            ty_vec(_, None) => None,\n+            ty_vec(_, None) | ty_str(None) => None,\n             _ => Some(mt {\n                 ty: typ,\n                 mutbl: ast::MutImmutable,\n             }),\n         },\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n             // Don't deref &[], might need to generalise this to all DST.\n-            ty_vec(_, None) => None,\n+            ty_vec(_, None) | ty_str(None) => None,\n             _ => Some(mt),\n         },\n         ty_ptr(mt) if explicit => Some(mt),\n@@ -2641,13 +2631,14 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n // Returns the type of t[i]\n pub fn index(t: t) -> Option<mt> {\n     match get(t).sty {\n-        ty_vec(mt, _) => Some(mt),\n+        ty_vec(mt, Some(_)) => Some(mt),\n         ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n         ty_box(t) | ty_uniq(t) => match get(t).sty {\n             ty_vec(mt, None) => Some(mt),\n+            ty_str(None) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n             _ => None,\n         },\n-        ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n+        ty_str(Some(_)) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n         _ => None\n     }\n }\n@@ -2752,7 +2743,6 @@ pub fn ty_region(tcx: &ctxt,\n                  ty: t) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n-        ty_str(VstoreSlice(r)) => r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -2949,33 +2939,29 @@ pub fn adjust_ty(cx: &ctxt,\n         None => unadjusted_ty\n     };\n \n-    fn borrow_vec(cx: &ctxt, span: Span,\n-                  r: Region, m: ast::Mutability,\n+    fn borrow_vec(cx: &ctxt,\n+                  span: Span,\n+                  r: Region,\n+                  m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_uniq(t) | ty_ptr(mt{ty: t, ..}) |\n             ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n                 ty::ty_vec(mt, None) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n-                ref s => {\n+                ty::ty_str(None) => ty::mk_str_slice(cx, r, m),\n+                _ => {\n                     cx.sess.span_bug(\n                         span,\n-                        format!(\"borrow-vec associated with bad sty: {:?}\",\n-                             s));\n+                        format!(\"borrow-vec associated with bad sty: {:?}\", get(ty).sty));\n                 }\n             },\n-            ty_vec(mt, Some(_)) => {\n-                ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m})\n-            }\n-\n-            ty_str(_) => {\n-                ty::mk_str(cx, VstoreSlice(r))\n-            }\n+            ty_vec(mt, Some(_)) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n+            ty_str(Some(_)) => ty::mk_str_slice(cx, r, m),\n \n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    format!(\"borrow-vec associated with bad sty: {:?}\",\n-                         s));\n+                    format!(\"borrow-vec associated with bad sty: {:?}\", s));\n             }\n         }\n     }\n@@ -3310,15 +3296,6 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n      * to present additional details, particularly when\n      * it comes to lifetime-related errors. */\n \n-    fn terr_vstore_kind_to_str(k: terr_vstore_kind) -> ~str {\n-        match k {\n-            terr_vec => \"[]\".to_owned(),\n-            terr_str => \"str\".to_owned(),\n-            terr_fn => \"fn\".to_owned(),\n-            terr_trait => \"trait\".to_owned()\n-        }\n-    }\n-\n     fn tstore_to_closure(s: &TraitStore) -> ~str {\n         match s {\n             &UniqTraitStore => \"proc\".to_owned(),\n@@ -3394,12 +3371,6 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n                   but found bound lifetime parameter {}\",\n                  bound_region_ptr_to_str(cx, br))\n         }\n-        terr_vstores_differ(k, ref values) => {\n-            format!(\"{} storage differs: expected `{}` but found `{}`\",\n-                 terr_vstore_kind_to_str(k),\n-                 (*values).expected.repr(cx),\n-                 (*values).found.repr(cx))\n-        }\n         terr_trait_stores_differ(_, ref values) => {\n             format!(\"trait storage differs: expected `{}` but found `{}`\",\n                  trait_store_to_str(cx, (*values).expected),\n@@ -4168,13 +4139,6 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n             return t_norm;\n         }\n \n-        fn fold_vstore(&mut self, vstore: Vstore) -> Vstore {\n-            match vstore {\n-                VstoreFixed(..) | VstoreUniq => vstore,\n-                VstoreSlice(_) => VstoreSlice(ReStatic)\n-            }\n-        }\n-\n         fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n             ty::ReStatic\n         }\n@@ -4564,9 +4528,13 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                 byte!(6);\n                 hash!(f);\n             }\n-            ty_str(v) => {\n+            ty_str(Some(_)) => {\n                 byte!(7);\n-                hash!(v);\n+                1u8.hash(&mut state);\n+            }\n+            ty_str(None) => {\n+                byte!(7);\n+                0u8.hash(&mut state);\n             }\n             ty_enum(d, _) => {\n                 byte!(8);"}, {"sha": "bfce00a718b8c022832ee8db286ec6a169875d37", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -68,10 +68,6 @@ pub trait TypeFolder {\n         r\n     }\n \n-    fn fold_vstore(&mut self, vstore: ty::Vstore) -> ty::Vstore {\n-        super_fold_vstore(self, vstore)\n-    }\n-\n     fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n         super_fold_trait_store(self, s)\n     }\n@@ -179,8 +175,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             ty::ty_struct(did,\n                           this.fold_substs(substs))\n         }\n-        ty::ty_str(vst) => {\n-            ty::ty_str(this.fold_vstore(vst))\n+        ty::ty_str(sz) => {\n+            ty::ty_str(sz)\n         }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n@@ -191,16 +187,6 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_vstore<T:TypeFolder>(this: &mut T,\n-                                       vstore: ty::Vstore)\n-                                       -> ty::Vstore {\n-    match vstore {\n-        ty::VstoreFixed(i) => ty::VstoreFixed(i),\n-        ty::VstoreUniq => ty::VstoreUniq,\n-        ty::VstoreSlice(r) => ty::VstoreSlice(this.fold_region(r)),\n-    }\n-}\n-\n pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n                                             trait_store: ty::TraitStore)\n                                             -> ty::TraitStore {"}, {"sha": "66e640cbcd6bfc9d57602858236ca7851af8989a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -355,7 +355,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                             tcx.sess.span_err(ast_ty.span,\n                                               \"bare `str` is not a type\");\n                             // return /something/ so they can at least get more errors\n-                            Some(ty::mk_str(tcx, ty::VstoreUniq))\n+                            Some(ty::mk_uniq(tcx, ty::mk_str(tcx, None)))\n                         }\n                     }\n                 }\n@@ -373,19 +373,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n \n     enum PointerTy {\n         Box,\n-        VStore(ty::Vstore)\n-    }\n-    impl PointerTy {\n-        fn expect_vstore(&self, tcx: &ty::ctxt, span: Span, ty: &str) -> ty::Vstore {\n-            match *self {\n-                Box => {\n-                    tcx.sess.span_err(span, format!(\"managed {} are not supported\", ty));\n-                    // everything can be ~, so this is a worth substitute\n-                    ty::VstoreUniq\n-                }\n-                VStore(vst) => vst\n-            }\n-        }\n+        RPtr(ty::Region),\n+        Uniq\n     }\n \n     fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n@@ -423,23 +412,23 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 match tcx.def_map.borrow().find(&id) {\n                     Some(&ast::DefPrimTy(ast::TyStr)) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        let vst = ptr_ty.expect_vstore(tcx, path.span, \"strings\");\n-                        match vst {\n-                            ty::VstoreUniq => {\n-                                return ty::mk_str(tcx, ty::VstoreUniq);\n+                        match ptr_ty {\n+                            Uniq => {\n+                                return ty::mk_uniq(tcx, ty::mk_str(tcx, None));\n                             }\n-                            ty::VstoreSlice(r) => {\n-                                return ty::mk_str(tcx, ty::VstoreSlice(r));\n+                            RPtr(r) => {\n+                                return ty::mk_str_slice(tcx, r, ast::MutImmutable);\n                             }\n-                            _ => {}\n+                            _ => tcx.sess.span_err(path.span,\n+                                                   format!(\"managed strings are not supported\")),\n                         }\n                     }\n                     Some(&ast::DefTrait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n                             this, rscope, trait_def_id, None, path);\n                         let trait_store = match ptr_ty {\n-                            VStore(ty::VstoreUniq) => ty::UniqTraitStore,\n-                            VStore(ty::VstoreSlice(r)) => {\n+                            Uniq => ty::UniqTraitStore,\n+                            RPtr(r) => {\n                                 ty::RegionTraitStore(r, a_seq_ty.mutbl)\n                             }\n                             _ => {\n@@ -491,7 +480,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n             ast::TyUniq(ty) => {\n                 let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, VStore(ty::VstoreUniq),\n+                mk_pointer(this, rscope, &mt, Uniq,\n                            |ty| ty::mk_uniq(tcx, ty))\n             }\n             ast::TyVec(ty) => {\n@@ -509,7 +498,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt, VStore(ty::VstoreSlice(r)),\n+                mk_pointer(this, rscope, mt, RPtr(r),\n                            |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {"}, {"sha": "16389771bb429e0908977201ea52e57bc800a2f8", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -769,6 +769,7 @@ impl<'a> LookupContext<'a> {\n                     self.infcx().next_region_var(infer::Autoref(self.span));\n                 let (extra_derefs, auto) = match ty::get(self_mt.ty).sty {\n                     ty::ty_vec(_, None) => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n+                    ty::ty_str(None) => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n                     _ => (1, ty::AutoPtr(region, self_mt.mutbl)),\n                 };\n                 (ty::mk_rptr(tcx, region, self_mt),\n@@ -836,6 +837,27 @@ impl<'a> LookupContext<'a> {\n             })\n     }\n \n+\n+    fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodCallee> {\n+        let tcx = self.tcx();\n+        debug!(\"auto_slice_str\");\n+\n+        let entry = self.search_for_some_kind_of_autorefd_method(\n+            AutoBorrowVec, autoderefs, [MutImmutable],\n+            |_m,r| ty::mk_str_slice(tcx, r, MutImmutable));\n+\n+        if entry.is_some() {\n+            return entry;\n+        }\n+\n+        self.search_for_some_kind_of_autorefd_method(\n+            AutoBorrowVecRef, autoderefs, [MutImmutable],\n+            |m,r| {\n+                let slice_ty = ty::mk_str_slice(tcx, r, m);\n+                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n+            })\n+    }\n+\n     fn search_for_autosliced_method(&self,\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n@@ -856,25 +878,11 @@ impl<'a> LookupContext<'a> {\n             },\n             ty_uniq(t) => match ty::get(t).sty {\n                 ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n+                ty_str(None) => self.auto_slice_str(autoderefs),\n                 _ => None\n             },\n             ty_vec(mt, Some(_)) => self.auto_slice_vec(mt, autoderefs),\n-\n-            ty_str(VstoreUniq) |\n-            ty_str(VstoreFixed(_)) => {\n-                let entry = self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVec, autoderefs, [MutImmutable],\n-                    |_m,r| ty::mk_str(tcx, VstoreSlice(r)));\n-\n-                if entry.is_some() { return entry; }\n-\n-                self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVecRef, autoderefs, [MutImmutable],\n-                    |m,r| {\n-                        let slice_ty = ty::mk_str(tcx, VstoreSlice(r));\n-                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n-                    })\n-            }\n+            ty_str(Some(_)) => self.auto_slice_str(autoderefs),\n \n             ty_trait(~ty::TyTrait { def_id: trt_did, substs: trt_substs, bounds: b, .. }) => {\n                 // Coerce ~/&Trait instances to &Trait.\n@@ -1310,7 +1318,7 @@ impl<'a> LookupContext<'a> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         match ty::get(mt.ty).sty {\n-                            ty::ty_vec(_, None) => false,\n+                            ty::ty_vec(_, None) | ty::ty_str(None) => false,\n                             _ => mutability_matches(mt.mutbl, m) &&\n                                  rcvr_matches_ty(self.fcx, mt.ty, candidate),\n                         }\n@@ -1332,7 +1340,7 @@ impl<'a> LookupContext<'a> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n                         match ty::get(typ).sty {\n-                            ty::ty_vec(_, None) => false,\n+                            ty::ty_vec(_, None) | ty::ty_str(None) => false,\n                             _ => rcvr_matches_ty(self.fcx, typ, candidate),\n                         }\n                     }"}, {"sha": "b6ea33a9fdf4c28b80b8ff8537c844a15bba4ebd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 47, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -1395,7 +1395,7 @@ pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str(tcx, ty::VstoreSlice(ty::ReStatic)),\n+        ast::LitStr(..) => ty::mk_str_slice(tcx, ty::ReStatic, ast::MutImmutable),\n         ast::LitBinary(..) => {\n             ty::mk_slice(tcx, ty::ReStatic, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n         }\n@@ -2567,15 +2567,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n           ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-            let v = ast_expr_vstore_to_vstore(fcx, ev, vst);\n-            ty::mk_str(tcx, v)\n+            ast_expr_vstore_to_ty(fcx, ev, vst, || ty::mt{ ty: ty::mk_str(tcx, None),\n+                                                           mutbl: ast::MutImmutable })\n           }\n           ast::ExprVec(ref args) => {\n             let mutability = match vst {\n                 ast::ExprVstoreMutSlice => ast::MutMutable,\n                 _ => ast::MutImmutable,\n             };\n-            let v = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mut any_error = false;\n             let mut any_bot = false;\n             let t: ty::t = fcx.infcx().next_ty_var();\n@@ -2594,23 +2593,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             } else if any_bot {\n                 ty::mk_bot()\n             } else {\n-                match v {\n-                    ty::VstoreFixed(sz) => ty::mk_vec(tcx,\n-                                                      ty::mt {ty: t, mutbl: mutability},\n-                                                      Some(sz)),\n-                    ty::VstoreUniq => ty::mk_uniq(tcx,\n-                                                  ty::mk_vec(tcx,\n-                                                             ty::mt {ty: t, mutbl: mutability},\n-                                                             None)), // Sadly, we know the length\n-                                                                     // - Some(args.len()) - but\n-                                                                     // must throw it away or cause\n-                                                                     // confusion further down the\n-                                                                     // pipeline. Hopefully we can\n-                                                                     // remedy this later.\n-                                                                     // See below (x3) too.\n-                    ty::VstoreSlice(r) => ty::mk_slice(tcx, r,\n-                                                       ty::mt {ty: t, mutbl: mutability}),\n-                }\n+                ast_expr_vstore_to_ty(fcx, ev, vst, ||\n+                    ty::mt{ ty: ty::mk_vec(tcx,\n+                                           ty::mt {ty: t, mutbl: mutability},\n+                                           None),\n+                            mutbl: mutability })\n             }\n           }\n           ast::ExprRepeat(element, count_expr) => {\n@@ -2620,7 +2607,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 ast::ExprVstoreMutSlice => ast::MutMutable,\n                 _ => ast::MutImmutable,\n             };\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let t = fcx.infcx().next_ty_var();\n             check_expr_has_type(fcx, element, t);\n             let arg_t = fcx.expr_ty(element);\n@@ -2629,17 +2615,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             } else if ty::type_is_bot(arg_t) {\n                 ty::mk_bot()\n             } else {\n-                match tt {\n-                    ty::VstoreFixed(sz) => ty::mk_vec(tcx,\n-                                                      ty::mt {ty: t, mutbl: mutability},\n-                                                      Some(sz)),\n-                    ty::VstoreUniq => ty::mk_uniq(tcx,\n-                                                  ty::mk_vec(tcx,\n-                                                             ty::mt {ty: t, mutbl: mutability},\n-                                                             None)),\n-                    ty::VstoreSlice(r) => ty::mk_slice(tcx, r,\n-                                                       ty::mt {ty: t, mutbl: mutability}),\n-                }\n+                ast_expr_vstore_to_ty(fcx, ev, vst, ||\n+                    ty::mt{ ty: ty::mk_vec(tcx,\n+                                           ty::mt {ty: t, mutbl: mutability},\n+                                           None),\n+                            mutbl: mutability})\n             }\n           }\n           _ =>\n@@ -4013,33 +3993,29 @@ pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: &FnCtxt,\n-                                 e: &ast::Expr,\n-                                 v: ast::ExprVstore)\n-                                 -> ty::Vstore {\n+pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n+                             e: &ast::Expr,\n+                             v: ast::ExprVstore,\n+                             mk_inner: || -> ty::mt)\n+                             -> ty::t {\n     match v {\n-        ast::ExprVstoreUniq => ty::VstoreUniq,\n+        ast::ExprVstoreUniq => ty::mk_uniq(fcx.ccx.tcx, mk_inner().ty),\n         ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n             match e.node {\n                 ast::ExprLit(..) => {\n                     // string literals and *empty slices* live in static memory\n-                    ty::VstoreSlice(ty::ReStatic)\n+                    ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner())\n                 }\n                 ast::ExprVec(ref elements) if elements.len() == 0 => {\n                     // string literals and *empty slices* live in static memory\n-                    ty::VstoreSlice(ty::ReStatic)\n+                    ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner())\n                 }\n                 ast::ExprRepeat(..) |\n                 ast::ExprVec(..) => {\n                     // vector literals are temporaries on the stack\n                     match fcx.tcx().region_maps.temporary_scope(e.id) {\n-                        Some(scope) => {\n-                            ty::VstoreSlice(ty::ReScope(scope))\n-                        }\n-                        None => {\n-                            // this slice occurs in a static somewhere\n-                            ty::VstoreSlice(ty::ReStatic)\n-                        }\n+                        Some(scope) => ty::mk_rptr(fcx.ccx.tcx, ty::ReScope(scope), mk_inner()),\n+                        None => ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner()),\n                     }\n                 }\n                 _ => {"}, {"sha": "e679718c931aad64e7a6b25c6743e80e5ff19413", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -939,12 +939,8 @@ fn constrain_index(rcx: &mut Rcx,\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n-        ty::ty_str(ty::VstoreSlice(r_ptr)) => {\n-            rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n-                            r_index_expr, r_ptr);\n-        }\n         ty::ty_rptr(r_ptr, mt) => match ty::get(mt.ty).sty {\n-            ty::ty_vec(_, None) => {\n+            ty::ty_vec(_, None) | ty::ty_str(None)=> {\n                 rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n                                 r_index_expr, r_ptr);\n             }"}, {"sha": "aba9c62d83dd076f26f5f13176821893697953d4", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -66,7 +66,6 @@ we may want to adjust precisely when coercions occur.\n \n \n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowObj, AutoDerefRef};\n-use middle::ty::{VstoreSlice, VstoreUniq};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n@@ -109,6 +108,11 @@ impl<'f> Coerce<'f> {\n                         });\n                     }\n                     ty::ty_vec(_, _) => {},\n+                    ty::ty_str(None) => {\n+                        return self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_borrowed_string(a, sty_a, b)\n+                        });\n+                    }\n                     _ => {\n                         return self.unpack_actual_value(a, |sty_a| {\n                             self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n@@ -117,12 +121,6 @@ impl<'f> Coerce<'f> {\n                 };\n             }\n \n-            ty::ty_str(VstoreSlice(..)) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_string(a, sty_a, b)\n-                });\n-            }\n-\n             ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n@@ -264,15 +262,18 @@ impl<'f> Coerce<'f> {\n                b.inf_str(self.get_ref().infcx));\n \n         match *sty_a {\n-            ty::ty_str(VstoreUniq) => {}\n+            ty::ty_uniq(t) => match ty::get(t).sty {\n+                ty::ty_str(None) => {}\n+                _ => return self.subtype(a, b),\n+            },\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n-        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a));\n+        let a_borrowed = ty::mk_str_slice(self.get_ref().infcx.tcx, r_a, ast::MutImmutable);\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,"}, {"sha": "235fb7d496e207f9772787bb589fd07b6b17d608", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -255,30 +255,6 @@ pub trait Combine {\n                   -> cres<ty::Region>;\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n \n-    fn vstores(&self,\n-                vk: ty::terr_vstore_kind,\n-                a: ty::Vstore,\n-                b: ty::Vstore)\n-                -> cres<ty::Vstore> {\n-        debug!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n-\n-        match (a, b) {\n-            (ty::VstoreSlice(a_r), ty::VstoreSlice(b_r)) => {\n-                self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::VstoreSlice(r))\n-                })\n-            }\n-\n-            _ if a == b => {\n-                Ok(a)\n-            }\n-\n-            _ => {\n-                Err(ty::terr_vstores_differ(vk, expected_found(self, a, b)))\n-            }\n-        }\n-    }\n-\n     fn trait_stores(&self,\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n@@ -394,6 +370,27 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n }\n \n pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+\n+    // This is a horible hack - historically, [T] was not treated as a type,\n+    // so, for example, &T and &[U] should not unify. In fact the only thing\n+    // &[U] should unify with is &[T]. We preserve that behaviour with this\n+    // check.\n+    fn check_ptr_to_vec<C:Combine>(this: &C,\n+                                   a: ty::t,\n+                                   b: ty::t,\n+                                   a_inner: ty::t,\n+                                   b_inner: ty::t,\n+                                   result: ty::t) -> cres<ty::t> {\n+        match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n+            (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) |\n+            (&ty::ty_str(None), &ty::ty_str(None)) => Ok(result),\n+            (&ty::ty_vec(_, None), _) | (_, &ty::ty_vec(_, None)) |\n+            (&ty::ty_str(None), _) | (_, &ty::ty_str(None))\n+                => Err(ty::terr_sorts(expected_found(this, a, b))),\n+            _ => Ok(result),\n+        }\n+    }\n+\n     let tcx = this.infcx().tcx;\n     let a_sty = &ty::get(a).sty;\n     let b_sty = &ty::get(b).sty;\n@@ -499,39 +496,18 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n             let typ = if_ok!(this.tys(a_inner, b_inner));\n-\n-            match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n-                (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) => Ok(ty::mk_uniq(tcx, typ)),\n-                (&ty::ty_vec(_, None), _) |\n-                (_, &ty::ty_vec(_, None)) => Err(ty::terr_sorts(expected_found(this, a, b))),\n-                _ => Ok(ty::mk_uniq(tcx, typ)),\n-            }\n+            check_ptr_to_vec(this, a, b, a_inner, b_inner, ty::mk_uniq(tcx, typ))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n             let mt = if_ok!(this.mts(a_mt, b_mt));\n-            match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n-                (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) => Ok(ty::mk_ptr(tcx, mt)),\n-                (&ty::ty_vec(_, None), _) |\n-                (_, &ty::ty_vec(_, None)) => Err(ty::terr_sorts(expected_found(this, a, b))),\n-                _ => Ok(ty::mk_ptr(tcx, mt)),\n-            }\n+            check_ptr_to_vec(this, a, b, a_mt.ty, b_mt.ty, ty::mk_ptr(tcx, mt))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n             let r = if_ok!(this.contraregions(a_r, b_r));\n             let mt = if_ok!(this.mts(a_mt, b_mt));\n-\n-            // This is a horible hack - historically, [T] was not treated as a type,\n-            // so, for example, &T and &[U] should not unify. In fact the only thing\n-            // &[U] should unify with is &[T]. We preserve that behaviour with this\n-            // check. See also ty_uniq, ty_ptr.\n-            match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n-                (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) => Ok(ty::mk_rptr(tcx, r, mt)),\n-                (&ty::ty_vec(_, None), _) |\n-                (_, &ty::ty_vec(_, None)) => Err(ty::terr_sorts(expected_found(this, a, b))),\n-                _ => Ok(ty::mk_rptr(tcx, r, mt)),\n-            }\n+            check_ptr_to_vec(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n       }\n \n       (&ty::ty_vec(ref a_mt, sz_a), &ty::ty_vec(ref b_mt, sz_b)) => {\n@@ -544,9 +520,12 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         })\n       }\n \n-      (&ty::ty_str(vs_a), &ty::ty_str(vs_b)) => {\n-        let vs = if_ok!(this.vstores(ty::terr_str, vs_a, vs_b));\n-        Ok(ty::mk_str(tcx,vs))\n+      (&ty::ty_str(sz_a), &ty::ty_str(sz_b)) => {\n+            if sz_a == sz_b {\n+                Ok(ty::mk_str(tcx,sz_a))\n+            } else {\n+                Err(ty::terr_sorts(expected_found(this, a, b)))\n+            }\n       }\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {"}, {"sha": "a44c70e5df8a4b2243bd3d0bc2c02d2ed799cf01", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -706,7 +706,7 @@ impl<'a> ConstraintContext<'a> {\n         match ty::get(ty).sty {\n             ty::ty_nil | ty::ty_bot | ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n-            ty::ty_float(_) => {\n+            ty::ty_float(_) | ty::ty_str(_) => {\n                 /* leaf type -- noop */\n             }\n \n@@ -716,10 +716,6 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_str(vstore) => {\n-                self.add_constraints_from_vstore(vstore, variance);\n-            }\n-\n             ty::ty_vec(ref mt, _) => {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n@@ -792,20 +788,6 @@ impl<'a> ConstraintContext<'a> {\n         }\n     }\n \n-    /// Adds constraints appropriate for a vector with Vstore `vstore`\n-    /// appearing in a context with ambient variance `variance`\n-    fn add_constraints_from_vstore(&mut self,\n-                                   vstore: ty::Vstore,\n-                                   variance: VarianceTermPtr<'a>) {\n-        match vstore {\n-            ty::VstoreSlice(r) => {\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(r, contra);\n-            }\n-\n-            ty::VstoreFixed(_) | ty::VstoreUniq => {}\n-        }\n-    }\n \n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`"}, {"sha": "7c36885407d11485597b1854dd6bac9949c0fcc0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -395,21 +395,16 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n         let bound_str = bounds.repr(cx);\n         format!(\"{}{}{}{}\", trait_store_to_str(cx, store), ty, bound_sep, bound_str)\n       }\n-      ty_str(vs) => {\n-        match vs {\n-            ty::VstoreFixed(n) => format!(\"str/{}\", n),\n-            ty::VstoreUniq => \"~str\".to_owned(),\n-            ty::VstoreSlice(r) => format!(\"{}str\", region_ptr_to_str(cx, r))\n+      ty_str(sz) => {\n+        match sz {\n+            Some(n) => format!(\"str/{}\", n),\n+            None => \"str\".to_owned(),\n         }\n       }\n       ty_vec(ref mt, sz) => {\n           match sz {\n-              Some(n) => {\n-                  format!(\"[{}, .. {}]\", mt_to_str(cx, mt), n)\n-              }\n-              None => {\n-                  format!(\"[{}]\", ty_to_str(cx, mt.ty))\n-              }\n+              Some(n) => format!(\"[{}, .. {}]\", mt_to_str(cx, mt), n),\n+              None => format!(\"[{}]\", ty_to_str(cx, mt.ty)),\n           }\n       }\n     }\n@@ -854,16 +849,6 @@ impl Repr for ty::TraitStore {\n     }\n }\n \n-impl Repr for ty::Vstore {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        match *self {\n-            ty::VstoreFixed(n) => format!(\"{}\", n),\n-            ty::VstoreUniq => \"~\".to_owned(),\n-            ty::VstoreSlice(r) => region_ptr_to_str(tcx, r)\n-        }\n-    }\n-}\n-\n impl Repr for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)"}, {"sha": "5927ae12f1ca0dffda1134fda2ba7b723b9b5435", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -17,7 +17,7 @@ fn has_uniq(x: ~str) {\n }\n \n fn has_slice(x: &str) {\n-   wants_uniq(x); //~ ERROR str storage differs: expected `~` but found `&`\n+   wants_uniq(x); //~ ERROR mismatched types: expected `~str` but found `&str` (expected ~-ptr but f\n    wants_slice(x);\n }\n "}, {"sha": "273b58be653dde2ae1b676b3ce127656311217c2", "filename": "src/test/compile-fail/ifmt-bad-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs?ref=a3b28cb1f87a649e4bfe4a4b85fe591f9cb6c92f", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     format!(\"{0, select, other{}}\", 2);\n-    //~^ ERROR: expected &str but found integral\n+    //~^ ERROR: mismatched types: expected `&&str` but found `&<generic integer #0>` (expected &-ptr\n }"}]}