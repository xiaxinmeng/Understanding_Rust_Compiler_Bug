{"sha": "e11503f6d2b1766a852183f5591874ec53f6eae5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMTUwM2Y2ZDJiMTc2NmE4NTIxODNmNTU5MTg3NGVjNTNmNmVhZTU=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-06-21T04:16:14Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-06-29T07:56:40Z"}, "message": "librustc: Allow coercions through arrays.", "tree": {"sha": "76f50296b66b9ffbc9a8f7ecf82c0e7ef639e8f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76f50296b66b9ffbc9a8f7ecf82c0e7ef639e8f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e11503f6d2b1766a852183f5591874ec53f6eae5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e11503f6d2b1766a852183f5591874ec53f6eae5", "html_url": "https://github.com/rust-lang/rust/commit/e11503f6d2b1766a852183f5591874ec53f6eae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e11503f6d2b1766a852183f5591874ec53f6eae5/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a3695d54f14491c39da7910082df9ba9c833b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3695d54f14491c39da7910082df9ba9c833b37", "html_url": "https://github.com/rust-lang/rust/commit/6a3695d54f14491c39da7910082df9ba9c833b37"}], "stats": {"total": 159, "additions": 133, "deletions": 26}, "files": [{"sha": "e983830a4c3fdbc62e41d13641395bd16c273862", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e11503f6d2b1766a852183f5591874ec53f6eae5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11503f6d2b1766a852183f5591874ec53f6eae5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e11503f6d2b1766a852183f5591874ec53f6eae5", "patch": "@@ -1533,7 +1533,7 @@ pub fn type_is_self(ty: t) -> bool {\n     }\n }\n \n-fn type_is_slice(ty:t) -> bool {\n+fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n             ty_vec(_, None) | ty_str => true,\n@@ -1543,6 +1543,18 @@ fn type_is_slice(ty:t) -> bool {\n     }\n }\n \n+pub fn type_is_vec(ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_vec(..) => true,\n+        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n+        ty_box(t) | ty_uniq(t) => match get(t).sty {\n+            ty_vec(_, None) => true,\n+            _ => false\n+        },\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n@@ -1560,7 +1572,7 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n \n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n-        ty_vec(mt, Some(_)) => mt.ty,\n+        ty_vec(mt, _) => mt.ty,\n         ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n         ty_box(t) | ty_uniq(t) => match get(t).sty {\n             ty_vec(mt, None) => mt.ty,"}, {"sha": "54cd88a1163d7d9e9b4a342cf80ee49bf4054e38", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e11503f6d2b1766a852183f5591874ec53f6eae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11503f6d2b1766a852183f5591874ec53f6eae5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e11503f6d2b1766a852183f5591874ec53f6eae5", "patch": "@@ -1146,24 +1146,9 @@ fn check_cast(fcx: &FnCtxt,\n            .span_err(span,\n                      \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn is_vec(t: ty::t) -> bool {\n-            match ty::get(t).sty {\n-                ty::ty_vec(..) => true,\n-                ty::ty_ptr(ty::mt{ty: t, ..}) |\n-                ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n-                ty::ty_box(t) |\n-                ty::ty_uniq(t) => {\n-                    match ty::get(t).sty {\n-                        ty::ty_vec(_, None) => true,\n-                        _ => false,\n-                    }\n-                }\n-                _ => false\n-            }\n-        }\n         fn types_compatible(fcx: &FnCtxt, sp: Span,\n                             t1: ty::t, t2: ty::t) -> bool {\n-            if !is_vec(t1) {\n+            if !ty::type_is_vec(t1) {\n                 // If the type being casted from is not a vector, this special\n                 // case does not apply.\n                 return false\n@@ -2779,10 +2764,30 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, enum_type);\n     }\n \n+    type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, ty::t);\n+\n+    fn check_fn_for_vec_elements_expected(fcx: &FnCtxt,\n+                                          expected: Expectation)\n+                                         -> (ExprCheckerWithTy, ty::t) {\n+        let tcx = fcx.ccx.tcx;\n+        let (coerce, t) = match expected {\n+            // If we're given an expected type, we can try to coerce to it\n+            ExpectHasType(t) if ty::type_is_vec(t) => (true, ty::sequence_element_type(tcx, t)),\n+            // Otherwise we just leave the type to be resolved later\n+            _ => (false, fcx.infcx().next_ty_var())\n+        };\n+        if coerce {\n+            (check_expr_coercable_to_type, t)\n+        } else {\n+            (check_expr_has_type, t)\n+        }\n+    }\n+\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n         ast::ExprVstore(ev, vst) => {\n+            let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n             let typ = match ev.node {\n                 ast::ExprVec(ref args) => {\n                     let mutability = match vst {\n@@ -2791,9 +2796,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     };\n                     let mut any_error = false;\n                     let mut any_bot = false;\n-                    let t: ty::t = fcx.infcx().next_ty_var();\n                     for e in args.iter() {\n-                        check_expr_has_type(fcx, &**e, t);\n+                        check(fcx, &**e, t);\n                         let arg_t = fcx.expr_ty(&**e);\n                         if ty::type_is_error(arg_t) {\n                             any_error = true;\n@@ -2821,8 +2825,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         ast::ExprVstoreMutSlice => ast::MutMutable,\n                         _ => ast::MutImmutable,\n                     };\n-                    let t = fcx.infcx().next_ty_var();\n-                    check_expr_has_type(fcx, &**element, t);\n+                    check(fcx, &**element, t);\n                     let arg_t = fcx.expr_ty(&**element);\n                     if ty::type_is_error(arg_t) {\n                         ty::mk_err()\n@@ -3211,9 +3214,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_cast(fcx, &**e, &**t, id, expr.span);\n       }\n       ast::ExprVec(ref args) => {\n-        let t: ty::t = fcx.infcx().next_ty_var();\n+        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n         for e in args.iter() {\n-            check_expr_has_type(fcx, &**e, t);\n+            check(fcx, &**e, t);\n         }\n         let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n                              Some(args.len()));\n@@ -3222,8 +3225,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, &**count_expr);\n-        let t: ty::t = fcx.infcx().next_ty_var();\n-        check_expr_has_type(fcx, &**element, t);\n+        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n+        check(fcx, &**element, t);\n         let element_ty = fcx.expr_ty(&**element);\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);"}, {"sha": "5b52bc34d2b3d53ffc5a4cc59eccc8235be93909", "filename": "src/test/run-pass/issue-11205.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e11503f6d2b1766a852183f5591874ec53f6eae5/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11503f6d2b1766a852183f5591874ec53f6eae5/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=e11503f6d2b1766a852183f5591874ec53f6eae5", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+trait Foo {}\n+impl Foo for int {}\n+fn foo(_: [&Foo, ..2]) {}\n+fn foos(_: &[&Foo]) {}\n+fn foog<T>(_: &[T], _: &[T]) {}\n+\n+fn bar(_: [Box<Foo>, ..2]) {}\n+fn bars(_: &[Box<Foo>]) {}\n+\n+fn main() {\n+    let x: [&Foo, ..2] = [&1i, &2i];\n+    foo(x);\n+    foo([&1i, &2i]);\n+\n+    let r = &1i;\n+    let x: [&Foo, ..2] = [r, ..2];\n+    foo(x);\n+    foo([&1i, ..2]);\n+\n+    let x: &[&Foo] = &[&1i, &2i];\n+    foos(x);\n+    foos(&[&1i, &2i]);\n+\n+    let x: &[&Foo] = &[&1i, &2i];\n+    let r = &1i;\n+    foog(x, &[r]);\n+\n+    let x: [Box<Foo>, ..2] = [box 1i, box 2i];\n+    bar(x);\n+    bar([box 1i, box 2i]);\n+\n+    let x: &[Box<Foo>] = &[box 1i, box 2i];\n+    bars(x);\n+    bars(&[box 1i, box 2i]);\n+\n+    let x: &[Box<Foo>] = &[box 1i, box 2i];\n+    foog(x, &[box 1i]);\n+\n+    struct T<'a> {\n+        t: [&'a Foo, ..2]\n+    }\n+    let _n = T {\n+        t: [&1i, &2i]\n+    };\n+    let r = &1i;\n+    let _n = T {\n+        t: [r, ..2]\n+    };\n+    let x: [&Foo, ..2] = [&1i, &2i];\n+    let _n = T {\n+        t: x\n+    };\n+\n+    struct F<'b> {\n+        t: &'b [&'b Foo]\n+    }\n+    let _n = F {\n+        t: &[&1i, &2i]\n+    };\n+    let r = &1i;\n+    let r: [&Foo, ..2] = [r, ..2];\n+    let _n = F {\n+        t: r\n+    };\n+    let x: [&Foo, ..2] = [&1i, &2i];\n+    let _n = F {\n+        t: x\n+    };\n+\n+    struct M<'a> {\n+        t: &'a [Box<Foo>]\n+    }\n+    let _n = M {\n+        t: &[box 1i, box 2i]\n+    };\n+    let x: [Box<Foo>, ..2] = [box 1i, box 2i];\n+    let _n = M {\n+        t: x\n+    };\n+}"}]}