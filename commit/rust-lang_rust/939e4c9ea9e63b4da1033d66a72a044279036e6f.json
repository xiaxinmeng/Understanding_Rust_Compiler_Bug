{"sha": "939e4c9ea9e63b4da1033d66a72a044279036e6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzOWU0YzllYTllNjNiNGRhMTAzM2Q2NmE3MmEwNDQyNzkwMzZlNmY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-30T08:23:50Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-05-05T10:51:09Z"}, "message": "Guard against overflow in `codemap::span_to_lines`.\n\nMake `span_to_lines` to return a `Result`.\n(This is better than just asserting internally, since it allows caller\nto decide if they can recover from the problem.)\n\nAdded type alias for `FileLinesResult` returned by `span_to_lines`.\n\nUpdate embedded unit test to reflect `span_to_lines` signature change.\n\nIn diagnostic, catch `Err` from `span_to_lines` and print\n`\"(internal compiler error: unprintable span)\"` instead.\n\n----\n\nThere a number of recent issues that report the bug here.  See\ne.g. #24761 and #24954.\n\nThis change *might* fix them. However, that is not its main goal.\nThe main goals are:\n\n 1. Make it possible for callers to recover from an error here, and\n\n 2. Insert a more conservative check, in that we are\n    also checking that the files match up.", "tree": {"sha": "167acffb65c6cf5ce3111cf1234453a744bf03e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167acffb65c6cf5ce3111cf1234453a744bf03e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/939e4c9ea9e63b4da1033d66a72a044279036e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/939e4c9ea9e63b4da1033d66a72a044279036e6f", "html_url": "https://github.com/rust-lang/rust/commit/939e4c9ea9e63b4da1033d66a72a044279036e6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/939e4c9ea9e63b4da1033d66a72a044279036e6f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42cb2de1393b067f1078f0c8b55322620e6058ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/42cb2de1393b067f1078f0c8b55322620e6058ef", "html_url": "https://github.com/rust-lang/rust/commit/42cb2de1393b067f1078f0c8b55322620e6058ef"}], "stats": {"total": 53, "additions": 45, "deletions": 8}, "files": [{"sha": "1aaec73be4f3463f2d24fe653b8b942a4fd3c29a", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/939e4c9ea9e63b4da1033d66a72a044279036e6f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939e4c9ea9e63b4da1033d66a72a044279036e6f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=939e4c9ea9e63b4da1033d66a72a044279036e6f", "patch": "@@ -667,9 +667,22 @@ impl CodeMap {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> FileLines {\n+    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        if sp.lo > sp.hi {\n+            return Err(SpanLinesError::IllFormedSpan(sp));\n+        }\n+\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n+\n+        if lo.file.start_pos != hi.file.start_pos {\n+            return Err(SpanLinesError::DistinctSources(DistinctSources {\n+                begin: (lo.file.name.clone(), lo.file.start_pos),\n+                end: (hi.file.name.clone(), hi.file.start_pos),\n+            }));\n+        }\n+        assert!(hi.line >= lo.line);\n+\n         let mut lines = Vec::with_capacity(hi.line - lo.line + 1);\n \n         // The span starts partway through the first line,\n@@ -693,7 +706,7 @@ impl CodeMap {\n                               start_col: start_col,\n                               end_col: hi.col });\n \n-        FileLines {file: lo.file, lines: lines}\n+        Ok(FileLines {file: lo.file, lines: lines})\n     }\n \n     pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n@@ -918,9 +931,17 @@ impl CodeMap {\n }\n \n // _____________________________________________________________________________\n-// SpanSnippetError, DistinctSources, MalformedCodemapPositions\n+// SpanLinesError, SpanSnippetError, DistinctSources, MalformedCodemapPositions\n //\n \n+pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanLinesError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n@@ -1086,7 +1107,7 @@ mod tests {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n-        let file_lines = cm.span_to_lines(span);\n+        let file_lines = cm.span_to_lines(span).unwrap();\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n@@ -1131,7 +1152,7 @@ mod tests {\n         assert_eq!(&cm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n \n         // check that span_to_lines gives us the complete result with the lines/cols we expected\n-        let lines = cm.span_to_lines(span);\n+        let lines = cm.span_to_lines(span).unwrap();\n         let expected = vec![\n             LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n             LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },"}, {"sha": "aa649b4d99ac5fa291a393435b4da3227202f5a5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/939e4c9ea9e63b4da1033d66a72a044279036e6f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939e4c9ea9e63b4da1033d66a72a044279036e6f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=939e4c9ea9e63b4da1033d66a72a044279036e6f", "patch": "@@ -522,7 +522,7 @@ fn highlight_suggestion(err: &mut EmitterWriter,\n                         suggestion: &str)\n                         -> io::Result<()>\n {\n-    let lines = cm.span_to_lines(sp);\n+    let lines = cm.span_to_lines(sp).unwrap();\n     assert!(!lines.lines.is_empty());\n \n     // To build up the result, we want to take the snippet from the first\n@@ -567,9 +567,17 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines)\n+                   lines: codemap::FileLinesResult)\n                    -> io::Result<()>\n {\n+    let lines = match lines {\n+        Ok(lines) => lines,\n+        Err(_) => {\n+            try!(write!(&mut err.dst, \"(internal compiler error: unprintable span)\\n\"));\n+            return Ok(());\n+        }\n+    };\n+\n     let fm = &*lines.file;\n \n     let line_strings: Option<Vec<&str>> =\n@@ -690,8 +698,16 @@ fn end_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: codemap::FileLines)\n+                          lines: codemap::FileLinesResult)\n                           -> io::Result<()> {\n+    let lines = match lines {\n+        Ok(lines) => lines,\n+        Err(_) => {\n+            try!(write!(&mut w.dst, \"(internal compiler error: unprintable span)\\n\"));\n+            return Ok(());\n+        }\n+    };\n+\n     let fm = &*lines.file;\n \n     let lines = &lines.lines[..];"}]}