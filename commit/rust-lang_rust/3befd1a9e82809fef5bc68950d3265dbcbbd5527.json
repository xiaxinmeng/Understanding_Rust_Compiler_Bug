{"sha": "3befd1a9e82809fef5bc68950d3265dbcbbd5527", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZWZkMWE5ZTgyODA5ZmVmNWJjNjg5NTBkMzI2NWRiY2JiZDU1Mjc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T14:44:10Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T14:44:10Z"}, "message": "Cleanup", "tree": {"sha": "3b2657bd375ad877257f51afa646d58be90e75f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b2657bd375ad877257f51afa646d58be90e75f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3befd1a9e82809fef5bc68950d3265dbcbbd5527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3befd1a9e82809fef5bc68950d3265dbcbbd5527", "html_url": "https://github.com/rust-lang/rust/commit/3befd1a9e82809fef5bc68950d3265dbcbbd5527", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3befd1a9e82809fef5bc68950d3265dbcbbd5527/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5a8089b08478c59e20e219b53345dde5301d517", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a8089b08478c59e20e219b53345dde5301d517", "html_url": "https://github.com/rust-lang/rust/commit/e5a8089b08478c59e20e219b53345dde5301d517"}], "stats": {"total": 162, "additions": 37, "deletions": 125}, "files": [{"sha": "7b8dbe6b75969b34c4a89af0d0ad15f4cc790ca7", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 37, "deletions": 125, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3befd1a9e82809fef5bc68950d3265dbcbbd5527/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3befd1a9e82809fef5bc68950d3265dbcbbd5527/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=3befd1a9e82809fef5bc68950d3265dbcbbd5527", "patch": "@@ -239,19 +239,11 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n         .param_list()\n         .map(|pl| {\n             pl.params()\n-                .map(|p| {\n-                    p.type_ref()\n-                        .map(|t| Ty::new(db, &module, t))\n-                        .unwrap_or(Ok(Ty::Unknown))\n-                })\n+                .map(|p| Ty::new_opt(db, &module, p.type_ref()))\n                 .collect()\n         })\n         .unwrap_or_else(|| Ok(Vec::new()))?;\n-    let output = node\n-        .ret_type()\n-        .and_then(|rt| rt.type_ref())\n-        .map(|t| Ty::new(db, &module, t))\n-        .unwrap_or(Ok(Ty::Unknown))?;\n+    let output = Ty::new_opt(db, &module, node.ret_type().and_then(|rt| rt.type_ref()))?;\n     let sig = FnSig { input, output };\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n@@ -263,11 +255,6 @@ pub fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n     })\n }\n \n-// TODO this should probably be per namespace (i.e. types vs. values), since for\n-// a tuple struct `struct Foo(Bar)`, Foo has function type as a value, but\n-// defines the struct type Foo when used in the type namespace. rustc has a\n-// separate DefId for the constructor, but with the current DefId approach, that\n-// seems complicated.\n pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n     let def = def_id.resolve(db)?;\n     match def {\n@@ -396,85 +383,50 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty = match expr {\n             ast::Expr::IfExpr(e) => {\n                 if let Some(condition) = e.condition() {\n-                    if let Some(e) = condition.expr() {\n-                        // TODO if no pat, this should be bool\n-                        self.infer_expr(e)?;\n-                    }\n+                    // TODO if no pat, this should be bool\n+                    self.infer_expr_opt(condition.expr())?;\n                     // TODO write type for pat\n                 };\n-                let if_ty = if let Some(block) = e.then_branch() {\n-                    self.infer_block(block)?\n-                } else {\n-                    Ty::Unknown\n-                };\n-                let else_ty = if let Some(block) = e.else_branch() {\n-                    self.infer_block(block)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let if_ty = self.infer_block_opt(e.then_branch())?;\n+                let else_ty = self.infer_block_opt(e.else_branch())?;\n                 if let Some(ty) = self.unify(&if_ty, &else_ty) {\n                     ty\n                 } else {\n                     // TODO report diagnostic\n                     Ty::Unknown\n                 }\n             }\n-            ast::Expr::BlockExpr(e) => {\n-                if let Some(block) = e.block() {\n-                    self.infer_block(block)?\n-                } else {\n-                    Ty::Unknown\n-                }\n-            }\n+            ast::Expr::BlockExpr(e) => self.infer_block_opt(e.block())?,\n             ast::Expr::LoopExpr(e) => {\n-                if let Some(block) = e.loop_body() {\n-                    self.infer_block(block)?;\n-                };\n+                self.infer_block_opt(e.loop_body())?;\n                 // TODO never, or the type of the break param\n                 Ty::Unknown\n             }\n             ast::Expr::WhileExpr(e) => {\n                 if let Some(condition) = e.condition() {\n-                    if let Some(e) = condition.expr() {\n-                        // TODO if no pat, this should be bool\n-                        self.infer_expr(e)?;\n-                    }\n+                    // TODO if no pat, this should be bool\n+                    self.infer_expr_opt(condition.expr())?;\n                     // TODO write type for pat\n                 };\n-                if let Some(block) = e.loop_body() {\n-                    // TODO\n-                    self.infer_block(block)?;\n-                };\n+                self.infer_block_opt(e.loop_body())?;\n                 // TODO always unit?\n                 Ty::Unknown\n             }\n             ast::Expr::ForExpr(e) => {\n-                if let Some(expr) = e.iterable() {\n-                    self.infer_expr(expr)?;\n-                }\n+                let _iterable_ty = self.infer_expr_opt(e.iterable());\n                 if let Some(_pat) = e.pat() {\n                     // TODO write type for pat\n                 }\n-                if let Some(block) = e.loop_body() {\n-                    self.infer_block(block)?;\n-                }\n+                self.infer_block_opt(e.loop_body())?;\n                 // TODO always unit?\n                 Ty::Unknown\n             }\n             ast::Expr::LambdaExpr(e) => {\n-                let _body_ty = if let Some(body) = e.body() {\n-                    self.infer_expr(body)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _body_ty = self.infer_expr_opt(e.body())?;\n                 Ty::Unknown\n             }\n             ast::Expr::CallExpr(e) => {\n-                let callee_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let callee_ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n@@ -491,11 +443,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n             ast::Expr::MethodCallExpr(e) => {\n-                let _receiver_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _receiver_ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n@@ -505,20 +453,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Ty::Unknown\n             }\n             ast::Expr::MatchExpr(e) => {\n-                let _ty = if let Some(match_expr) = e.expr() {\n-                    self.infer_expr(match_expr)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(match_arm_list) = e.match_arm_list() {\n                     for arm in match_arm_list.arms() {\n                         // TODO type the bindings in pat\n                         // TODO type the guard\n-                        let _ty = if let Some(e) = arm.expr() {\n-                            self.infer_expr(e)?\n-                        } else {\n-                            Ty::Unknown\n-                        };\n+                        let _ty = self.infer_expr_opt(arm.expr())?;\n                     }\n                     // TODO unify all the match arm types\n                     Ty::Unknown\n@@ -531,19 +471,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n             ast::Expr::ContinueExpr(_e) => Ty::Never,\n             ast::Expr::BreakExpr(_e) => Ty::Never,\n-            ast::Expr::ParenExpr(e) => {\n-                if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                }\n-            }\n+            ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr())?,\n             ast::Expr::Label(_e) => Ty::Unknown,\n             ast::Expr::ReturnExpr(e) => {\n-                if let Some(e) = e.expr() {\n-                    // TODO unify with / expect return type\n-                    self.infer_expr(e)?;\n-                };\n+                self.infer_expr_opt(e.expr())?;\n                 Ty::Never\n             }\n             ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n@@ -554,10 +485,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (ty, _variant_data) = self.resolve_variant(e.path())?;\n                 if let Some(nfl) = e.named_field_list() {\n                     for field in nfl.fields() {\n-                        if let Some(e) = field.expr() {\n-                            // TODO unify with / expect field type\n-                            self.infer_expr(e)?;\n-                        }\n+                        // TODO unify with / expect field type\n+                        self.infer_expr_opt(field.expr())?;\n                     }\n                 }\n                 ty\n@@ -592,40 +521,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n             ast::Expr::TryExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _inner_ty = self.infer_expr_opt(e.expr())?;\n                 Ty::Unknown\n             }\n             ast::Expr::CastExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n-                let cast_ty = e\n-                    .type_ref()\n-                    .map(|t| Ty::new(self.db, &self.module, t))\n-                    .unwrap_or(Ok(Ty::Unknown))?;\n+                let _inner_ty = self.infer_expr_opt(e.expr())?;\n+                let cast_ty = Ty::new_opt(self.db, &self.module, e.type_ref())?;\n                 // TODO do the coercion...\n                 cast_ty\n             }\n             ast::Expr::RefExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _inner_ty = self.infer_expr_opt(e.expr())?;\n                 Ty::Unknown\n             }\n             ast::Expr::PrefixExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _inner_ty = self.infer_expr_opt(e.expr())?;\n                 Ty::Unknown\n             }\n             ast::Expr::RangeExpr(_e) => Ty::Unknown,\n@@ -636,15 +546,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Ok(ty)\n     }\n \n+    fn infer_block_opt(&mut self, node: Option<ast::Block>) -> Cancelable<Ty> {\n+        if let Some(b) = node {\n+            self.infer_block(b)\n+        } else {\n+            Ok(Ty::Unknown)\n+        }\n+    }\n+\n     fn infer_block(&mut self, node: ast::Block) -> Cancelable<Ty> {\n         for stmt in node.statements() {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n-                    let decl_ty = if let Some(type_ref) = stmt.type_ref() {\n-                        Ty::new(self.db, &self.module, type_ref)?\n-                    } else {\n-                        Ty::Unknown\n-                    };\n+                    let decl_ty = Ty::new_opt(self.db, &self.module, stmt.type_ref())?;\n                     let ty = if let Some(expr) = stmt.initializer() {\n                         // TODO pass expectation\n                         let expr_ty = self.infer_expr(expr)?;\n@@ -659,9 +573,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     };\n                 }\n                 ast::Stmt::ExprStmt(expr_stmt) => {\n-                    if let Some(expr) = expr_stmt.expr() {\n-                        self.infer_expr(expr)?;\n-                    }\n+                    self.infer_expr_opt(expr_stmt.expr())?;\n                 }\n             }\n         }"}]}