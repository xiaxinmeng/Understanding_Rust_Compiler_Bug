{"sha": "9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYTJhYWNjZmU3ZGQzNDUyZGQwNjZiYmMzODI5YWY2YmQ3NmFjZTQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-10T22:02:52Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-28T07:43:24Z"}, "message": "translate array drop glue using MIR\n\nThis fixes leakage on panic with arrays & slices. I am using a C-style\nfor-loop instead of a pointer-based loop because that would be ugly-er\nto implement.", "tree": {"sha": "f911577590ac319c17e22dba38b06d4ad31207d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f911577590ac319c17e22dba38b06d4ad31207d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "html_url": "https://github.com/rust-lang/rust/commit/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d2512ec5b03a1155054df881e40e35fc87d6351", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2512ec5b03a1155054df881e40e35fc87d6351", "html_url": "https://github.com/rust-lang/rust/commit/5d2512ec5b03a1155054df881e40e35fc87d6351"}], "stats": {"total": 198, "additions": 152, "deletions": 46}, "files": [{"sha": "c36a77736ab35f2fc944fc2fa1981aa4a3f26097", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "patch": "@@ -584,6 +584,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })\n     }\n+\n+    pub fn const_usize(&self, val: usize) -> ConstInt {\n+        match self.sess.target.uint_type {\n+            ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n+            ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n+            ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),\n+            _ => bug!(),\n+        }\n+    }\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {"}, {"sha": "4569569c820db69f8584f923522fd0b3a99c2510", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 130, "deletions": 5, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "patch": "@@ -11,7 +11,7 @@\n use std::fmt;\n use rustc::hir;\n use rustc::mir::*;\n-use rustc::middle::const_val::ConstInt;\n+use rustc::middle::const_val::{ConstInt, ConstVal};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Kind, Substs};\n@@ -535,6 +535,114 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         })\n     }\n \n+    /// create a loop that drops an array:\n+    ///\n+    /// loop-block:\n+    ///    can_go = index < len\n+    ///    if can_go then drop-block else succ\n+    /// drop-block:\n+    ///    ptr = &mut LV[len]\n+    ///    index = index + 1\n+    ///    drop(ptr)\n+    fn drop_loop(&mut self,\n+                 unwind: Option<BasicBlock>,\n+                 succ: BasicBlock,\n+                 index: &Lvalue<'tcx>,\n+                 length: &Lvalue<'tcx>,\n+                 ety: Ty<'tcx>,\n+                 is_cleanup: bool)\n+                 -> BasicBlock\n+    {\n+        let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n+        let tcx = self.tcx();\n+\n+        let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n+            ty: ety,\n+            mutbl: hir::Mutability::MutMutable\n+        });\n+        let ptr = &Lvalue::Local(self.new_temp(ref_ty));\n+        let can_go = &Lvalue::Local(self.new_temp(tcx.types.bool));\n+\n+        let one = self.constant_usize(1);\n+        let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![\n+                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n+                    ptr.clone(), Rvalue::Ref(\n+                        tcx.types.re_erased, BorrowKind::Mut,\n+                        self.lvalue.clone().index(use_(index))\n+                    ),\n+                )},\n+                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n+                    index.clone(), Rvalue::BinaryOp(BinOp::Add, use_(index), one)\n+                )},\n+            ],\n+            is_cleanup,\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::Resume,\n+            })\n+        });\n+\n+        let loop_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![\n+                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n+                    can_go.clone(), Rvalue::BinaryOp(BinOp::Lt, use_(index), use_(length))\n+                )},\n+            ],\n+            is_cleanup,\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::if_(tcx, use_(can_go), drop_block, succ)\n+            })\n+        });\n+\n+        self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n+            location: ptr.clone().deref(),\n+            target: loop_block,\n+            unwind: unwind\n+        });\n+\n+        loop_block\n+    }\n+\n+    fn open_drop_for_array(&mut self, ety: Ty<'tcx>) -> BasicBlock {\n+        debug!(\"open_drop_for_array({:?})\", ety);\n+        // FIXME: using an index instead of a pointer to avoid\n+        // special-casing ZSTs.\n+        let tcx = self.tcx();\n+        let index = &Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let length = &Lvalue::Local(self.new_temp(tcx.types.usize));\n+\n+        let unwind = self.unwind.map(|unwind| {\n+            self.drop_loop(None, unwind, index, length, ety, true)\n+        });\n+\n+        let is_cleanup = self.is_cleanup;\n+        let succ = self.succ; // FIXME(#6393)\n+        let loop_block = self.drop_loop(unwind, succ, index, length, ety, is_cleanup);\n+\n+        let zero = self.constant_usize(0);\n+        let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![\n+                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n+                    length.clone(), Rvalue::Len(self.lvalue.clone())\n+                )},\n+                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n+                    index.clone(), Rvalue::Use(zero),\n+                )},\n+            ],\n+            is_cleanup,\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::Goto { target: loop_block }\n+            })\n+        });\n+\n+        // FIXME(#34708): handle partially-dropped array/slice elements.\n+        self.drop_flag_test_and_reset_block(\n+            is_cleanup, Some(DropFlagMode::Deep), drop_block, succ)\n+    }\n+\n     /// The slow-path - create an \"open\", elaborated drop for a type\n     /// which is moved-out-of only partially, and patch `bb` to a jump\n     /// to it. This must not be called on ADTs with a destructor,\n@@ -564,10 +672,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty::TyDynamic(..) => {\n                 self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n             }\n-            ty::TyArray(..) | ty::TySlice(..) => {\n-                // FIXME(#34708): handle partially-dropped\n-                // array/slice elements.\n-                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+            ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+                self.open_drop_for_array(ety)\n             }\n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n         }\n@@ -588,6 +694,17 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n \n         let drop_block = self.drop_block(is_cleanup, succ);\n+        self.drop_flag_test_and_reset_block(is_cleanup, drop_mode, drop_block, succ)\n+    }\n+\n+    fn drop_flag_test_and_reset_block(&mut self,\n+                                      is_cleanup: bool,\n+                                      drop_mode: Option<DropFlagMode>,\n+                                      drop_block: BasicBlock,\n+                                      succ: BasicBlock) -> BasicBlock\n+    {\n+        debug!(\"drop_flag_test_and_reset_block({:?},{:?})\", self, drop_mode);\n+\n         if let Some(mode) = drop_mode {\n             let block_start = Location { block: drop_block, statement_index: 0 };\n             self.elaborator.clear_drop_flag(block_start, self.path, mode);\n@@ -691,4 +808,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let mir = self.elaborator.mir();\n         self.elaborator.patch().terminator_loc(mir, bb)\n     }\n+\n+    fn constant_usize(&self, val: usize) -> Operand<'tcx> {\n+        Operand::Constant(box Constant {\n+            span: self.source_info.span,\n+            ty: self.tcx().types.usize,\n+            literal: Literal::Value { value: ConstVal::Integral(self.tcx().const_usize(val)) }\n+        })\n+    }\n }"}, {"sha": "429e7b016102f7e4fd2e67c8471ec563e9ce63a5", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "patch": "@@ -612,17 +612,7 @@ fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 output.push(create_fn_trans_item(instance));\n             }\n         }\n-        ty::InstanceDef::DropGlue(_, Some(ty)) => {\n-            match ty.sty {\n-                ty::TyArray(ety, _) |\n-                ty::TySlice(ety)\n-                    if is_direct_call =>\n-                {\n-                    // drop of arrays/slices is translated in-line.\n-                    visit_drop_use(scx, ety, false, output);\n-                }\n-                _ => {}\n-            };\n+        ty::InstanceDef::DropGlue(_, Some(_)) => {\n             output.push(create_fn_trans_item(instance));\n         }\n         ty::InstanceDef::ClosureOnceShim { .. } |"}, {"sha": "724ff2f21344f35c31b4ad4c7ec7a7600268e3c1", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "patch": "@@ -20,13 +20,12 @@ use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n use common::{self, Funclet};\n-use common::{C_bool, C_str_slice, C_struct, C_u32, C_uint, C_undef};\n+use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use machine::llalign_of_min;\n use meth;\n use monomorphize;\n use type_of;\n-use tvec;\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -222,34 +221,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (drop_fn, need_extra) = match ty.sty {\n                     ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n                                           false),\n-                    ty::TyArray(ety, _) | ty::TySlice(ety) => {\n-                        // FIXME: handle panics\n-                        let drop_fn = monomorphize::resolve_drop_in_place(\n-                            bcx.ccx.shared(), ety);\n-                        let drop_fn = callee::get_fn(bcx.ccx, drop_fn);\n-                        let bcx = tvec::slice_for_each(\n-                            &bcx,\n-                            lvalue.project_index(&bcx, C_uint(bcx.ccx, 0u64)),\n-                            ety,\n-                            lvalue.len(bcx.ccx),\n-                            |bcx, llval, loop_bb| {\n-                                self.set_debug_loc(&bcx, terminator.source_info);\n-                                if let Some(unwind) = unwind {\n-                                    bcx.invoke(\n-                                        drop_fn,\n-                                        &[llval],\n-                                        loop_bb,\n-                                        llblock(self, unwind),\n-                                        cleanup_bundle\n-                                    );\n-                                } else {\n-                                    bcx.call(drop_fn, &[llval], cleanup_bundle);\n-                                    bcx.br(loop_bb);\n-                                }\n-                            });\n-                        funclet_br(self, bcx, target);\n-                        return\n-                    }\n                     _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n                 };\n                 let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];"}, {"sha": "26e5fe987eedd11c7f1141e37a7222d18585297c", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "patch": "@@ -125,6 +125,14 @@ fn union1(a: &Allocator) {\n     }\n }\n \n+fn array_simple(a: &Allocator) {\n+    let _x = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+}\n+\n+fn vec_simple(a: &Allocator) {\n+    let _x = vec![a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+}\n+\n fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n@@ -171,5 +179,8 @@ fn main() {\n     run_test(|a| assignment1(a, false));\n     run_test(|a| assignment1(a, true));\n \n+    run_test(|a| array_simple(a));\n+    run_test(|a| vec_simple(a));\n+\n     run_test_nopanic(|a| union1(a));\n }"}]}