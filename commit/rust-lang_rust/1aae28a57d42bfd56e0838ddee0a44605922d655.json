{"sha": "1aae28a57d42bfd56e0838ddee0a44605922d655", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYWUyOGE1N2Q0MmJmZDU2ZTA4MzhkZGVlMGE0NDYwNTkyMmQ2NTU=", "commit": {"author": {"name": "Jens Nockert", "email": "jens@nockert.se", "date": "2013-07-08T16:05:17Z"}, "committer": {"name": "Jens Nockert", "email": "jens@nockert.se", "date": "2013-07-08T16:05:17Z"}, "message": " Replaces the free-standing functions in f32, &c.\n\nThe free-standing functions in f32, f64, i8, i16, i32, i64, u8, u16,\nu32, u64, float, int, and uint are replaced with generic functions in\nnum instead.\n\nIf you were previously using any of those functions, just replace them\nwith the corresponding function with the same name in num.\n\nNote: If you were using a function that corresponds to an operator, use\nthe operator instead.", "tree": {"sha": "24378e71ef2022a5f6a3021b765b8feba89aa253", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24378e71ef2022a5f6a3021b765b8feba89aa253"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aae28a57d42bfd56e0838ddee0a44605922d655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aae28a57d42bfd56e0838ddee0a44605922d655", "html_url": "https://github.com/rust-lang/rust/commit/1aae28a57d42bfd56e0838ddee0a44605922d655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aae28a57d42bfd56e0838ddee0a44605922d655/comments", "author": {"login": "auroranockert", "id": 49616, "node_id": "MDQ6VXNlcjQ5NjE2", "avatar_url": "https://avatars.githubusercontent.com/u/49616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/auroranockert", "html_url": "https://github.com/auroranockert", "followers_url": "https://api.github.com/users/auroranockert/followers", "following_url": "https://api.github.com/users/auroranockert/following{/other_user}", "gists_url": "https://api.github.com/users/auroranockert/gists{/gist_id}", "starred_url": "https://api.github.com/users/auroranockert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/auroranockert/subscriptions", "organizations_url": "https://api.github.com/users/auroranockert/orgs", "repos_url": "https://api.github.com/users/auroranockert/repos", "events_url": "https://api.github.com/users/auroranockert/events{/privacy}", "received_events_url": "https://api.github.com/users/auroranockert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "auroranockert", "id": 49616, "node_id": "MDQ6VXNlcjQ5NjE2", "avatar_url": "https://avatars.githubusercontent.com/u/49616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/auroranockert", "html_url": "https://github.com/auroranockert", "followers_url": "https://api.github.com/users/auroranockert/followers", "following_url": "https://api.github.com/users/auroranockert/following{/other_user}", "gists_url": "https://api.github.com/users/auroranockert/gists{/gist_id}", "starred_url": "https://api.github.com/users/auroranockert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/auroranockert/subscriptions", "organizations_url": "https://api.github.com/users/auroranockert/orgs", "repos_url": "https://api.github.com/users/auroranockert/repos", "events_url": "https://api.github.com/users/auroranockert/events{/privacy}", "received_events_url": "https://api.github.com/users/auroranockert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44770ae3a8001de38b33e449889c6444808941fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/44770ae3a8001de38b33e449889c6444808941fc", "html_url": "https://github.com/rust-lang/rust/commit/44770ae3a8001de38b33e449889c6444808941fc"}], "stats": {"total": 514, "additions": 161, "deletions": 353}, "files": [{"sha": "f137b573c5549d1677458c3aebfd23c2ac5e1217", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -40,6 +40,7 @@ use list::{MutList, MutCons, MutNil};\n use std::at_vec;\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n+use std::num;\n use std::ptr;\n use std::sys;\n use std::uint;\n@@ -175,7 +176,7 @@ impl Arena {\n     fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n-        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n+        let new_min_chunk_size = num::max(n_bytes, chunk_size);\n         self.chunks = @mut MutCons(copy self.pod_head, self.chunks);\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n@@ -217,7 +218,7 @@ impl Arena {\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n-        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n+        let new_min_chunk_size = num::max(n_bytes, chunk_size);\n         self.chunks = @mut MutCons(copy self.head, self.chunks);\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);"}, {"sha": "dc65ef36b67e689455173184e7622ee3849c2249", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -12,6 +12,7 @@\n \n \n use std::cmp;\n+use std::num;\n use std::ops;\n use std::uint;\n use std::vec;\n@@ -726,7 +727,7 @@ impl Set<uint> for BitvSet {\n         }\n         let nbits = self.capacity();\n         if value >= nbits {\n-            let newsize = uint::max(value, nbits * 2) / uint::bits + 1;\n+            let newsize = num::max(value, nbits * 2) / uint::bits + 1;\n             assert!(newsize > self.bitv.storage.len());\n             self.bitv.storage.grow(newsize, &0);\n         }\n@@ -825,7 +826,7 @@ impl BitvSet {\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn each_common(&self, other: &BitvSet,\n                    f: &fn(uint, uint, uint) -> bool) -> bool {\n-        let min = uint::min(self.bitv.storage.len(),\n+        let min = num::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate().advance(|(i, &w)| {\n             f(i * uint::bits, w, other.bitv.storage[i])\n@@ -843,7 +844,7 @@ impl BitvSet {\n                     f: &fn(bool, uint, uint) -> bool) -> bool {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n-        let min = uint::min(len1, len2);\n+        let min = num::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n         for self.bitv.storage.slice(min, len1).iter().enumerate().advance |(i, &w)| {"}, {"sha": "9ce5e2c7ba20a5e0d2ff4e59d787fcb2e883a653", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -10,6 +10,7 @@\n \n //! A double-ended queue implemented as a circular buffer\n \n+use std::num;\n use std::uint;\n use std::vec;\n use std::iterator::FromIterator;\n@@ -51,7 +52,7 @@ impl<T> Deque<T> {\n     /// Create an empty Deque with space for at least `n` elements.\n     pub fn with_capacity(n: uint) -> Deque<T> {\n         Deque{nelts: 0, lo: 0,\n-              elts: vec::from_fn(uint::max(MINIMUM_CAPACITY, n), |_| None)}\n+              elts: vec::from_fn(num::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Return a reference to the first element in the deque"}, {"sha": "fd80d8e04653b6690ba73687b365056562de6e4a", "filename": "src/libextra/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Ftcp.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -28,7 +28,7 @@ use std::comm::{stream, Port, SharedChan};\n use std::ptr;\n use std::result::{Result};\n use std::result;\n-use std::uint;\n+use std::num;\n use std::vec;\n \n pub mod rustrt {\n@@ -880,7 +880,7 @@ impl io::Reader for TcpSocketBuf {\n           let needed = len - count;\n             if nbuffered > 0 {\n                 unsafe {\n-                    let ncopy = uint::min(nbuffered, needed);\n+                    let ncopy = num::min(nbuffered, needed);\n                     let dst = ptr::mut_offset(\n                         vec::raw::to_mut_ptr(buf), count);\n                     let src = ptr::offset("}, {"sha": "aeffe0d591dc28cf935d235a0c56f7f2f3778385", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -21,6 +21,7 @@ A BigInt is a combination of BigUint and Sign.\n \n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use std::int;\n+use std::num;\n use std::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n use std::str;\n use std::uint;\n@@ -204,7 +205,7 @@ impl Unsigned for BigUint {}\n impl Add<BigUint, BigUint> for BigUint {\n \n     fn add(&self, other: &BigUint) -> BigUint {\n-        let new_len = uint::max(self.data.len(), other.data.len());\n+        let new_len = num::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n         let mut sum = do vec::from_fn(new_len) |i| {\n@@ -224,7 +225,7 @@ impl Add<BigUint, BigUint> for BigUint {\n impl Sub<BigUint, BigUint> for BigUint {\n \n     fn sub(&self, other: &BigUint) -> BigUint {\n-        let new_len = uint::max(self.data.len(), other.data.len());\n+        let new_len = num::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n         let diff = do vec::from_fn(new_len) |i| {\n@@ -260,7 +261,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n         // = a1*b1 * base^2 +\n         //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n         //   a0*b0\n-        let half_len = uint::max(s_len, o_len) / 2;\n+        let half_len = num::max(s_len, o_len) / 2;\n         let (sHi, sLo) = cut_at(self,  half_len);\n         let (oHi, oLo) = cut_at(other, half_len);\n \n@@ -297,7 +298,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n \n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n-            let mid = uint::min(a.data.len(), n);\n+            let mid = num::min(a.data.len(), n);\n             return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n                     BigUint::from_slice(a.data.slice(0, mid)));\n         }\n@@ -482,7 +483,7 @@ impl Integer for BigUint {\n impl IntConvertible for BigUint {\n \n     fn to_int(&self) -> int {\n-        uint::min(self.to_uint(), int::max_value as uint) as int\n+        num::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n \n@@ -580,7 +581,7 @@ impl BigUint {\n         let mut n: BigUint      = Zero::zero();\n         let mut power: BigUint  = One::one();\n         loop {\n-            let start = uint::max(end, unit_len) - unit_len;\n+            let start = num::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(buf.slice(start, end), radix) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // Some(d) => n += BigUint::from_uint(d) * power,\n@@ -1055,9 +1056,9 @@ impl IntConvertible for BigInt {\n \n     fn to_int(&self) -> int {\n         match self.sign {\n-            Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n+            Plus  => num::min(self.to_uint(), int::max_value as uint) as int,\n             Zero  => 0,\n-            Minus => uint::min((-self).to_uint(),\n+            Minus => num::min((-self).to_uint(),\n                                (int::max_value as uint) + 1) as int\n         }\n     }"}, {"sha": "8023fe2c5da236071656ee3676019a1367729ce3", "filename": "src/libextra/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -10,9 +10,9 @@\n \n \n use std::cast;\n+use std::num;\n use std::ptr;\n use std::sys;\n-use std::uint;\n use std::vec;\n use future_spawn = future::spawn;\n \n@@ -44,15 +44,15 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         ~[f()(0u, xs)]\n     }\n     else {\n-        let num_tasks = uint::min(MAX_TASKS, len / MIN_GRANULARITY);\n+        let num_tasks = num::min(MAX_TASKS, len / MIN_GRANULARITY);\n \n         let items_per_task = len / num_tasks;\n \n         let mut futures = ~[];\n         let mut base = 0u;\n         info!(\"spawning tasks\");\n         while base < len {\n-            let end = uint::min(len, base + items_per_task);\n+            let end = num::min(len, base + items_per_task);\n             do xs.as_imm_buf |p, _len| {\n                 let f = f();\n                 let base = base;"}, {"sha": "5446515c1efad006d1272503e4c6deb37b14b3df", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -12,7 +12,6 @@ use sort;\n use std::cmp;\n use std::io;\n use std::num;\n-use std::f64;\n use std::vec;\n \n // NB: this can probably be rewritten in terms of num::Num\n@@ -178,7 +177,7 @@ impl<'self> Stats for &'self [f64] {\n     }\n \n     fn std_dev(self) -> f64 {\n-        f64::sqrt(self.var())\n+        self.var().sqrt()\n     }\n \n     fn std_dev_pct(self) -> f64 {"}, {"sha": "d74656dcc2e4d8eadb5c99edb31b047a08ff00c8", "filename": "src/libextra/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -11,9 +11,9 @@\n #[allow(missing_doc)];\n \n \n-use std::i32;\n use std::int;\n use std::io;\n+use std::num;\n use std::str;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n@@ -249,7 +249,7 @@ impl Tm {\n         } else {\n             let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\");\n             let sign = if self.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-            let mut m = i32::abs(self.tm_gmtoff) / 60_i32;\n+            let mut m = num::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n             s + fmt!(\"%c%02d:%02d\", sign, h as int, m as int)\n@@ -832,7 +832,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           'Z' => copy tm.tm_zone,\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-            let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n+            let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n             fmt!(\"%c%02d%02d\", sign, h as int, m as int)"}, {"sha": "8261862088246168181e8356be70e68cec653a1e", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -13,7 +13,7 @@\n //! `TotalOrd`.\n \n \n-use std::uint;\n+use std::num;\n use std::util::{swap, replace};\n \n // This is implemented as an AA tree, which is a simplified variation of\n@@ -63,7 +63,7 @@ fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n     let mut y = b.iter();\n \n     let (a_len, b_len) = (a.len(), b.len());\n-    for uint::min(a_len, b_len).times {\n+    for num::min(a_len, b_len).times {\n         let (key_a, value_a) = x.next().unwrap();\n         let (key_b, value_b) = y.next().unwrap();\n         if *key_a < *key_b { return true; }"}, {"sha": "62c1f670cf9b524643ae8a9dc5961245de5a9ea8", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -14,6 +14,7 @@ use metadata::cstore;\n use metadata::filesearch;\n \n use std::hashmap::HashSet;\n+use std::num;\n use std::os;\n use std::uint;\n use std::util;\n@@ -141,7 +142,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     assert!(len1 > 0);\n     assert!(len2 > 0);\n \n-    let max_common_path = uint::min(len1, len2) - 1;\n+    let max_common_path = num::min(len1, len2) - 1;\n     let mut start_idx = 0;\n     while start_idx < max_common_path\n         && split1[start_idx] == split2[start_idx] {"}, {"sha": "021c0f9ca369da74b04cf8c0ce823c97eda6289f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -25,11 +25,11 @@ use syntax::{ast, attr};\n \n use std::cast;\n use std::io;\n+use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::ptr;\n use std::str;\n-use std::uint;\n use std::vec;\n use extra::flate;\n \n@@ -211,7 +211,7 @@ fn get_metadata_section(os: os,\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking %u bytes of metadata-version stamp\",\n                        vlen);\n-                let minsz = uint::min(vlen, csz);\n+                let minsz = num::min(vlen, csz);\n                 let mut version_ok = false;\n                 do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n                     version_ok = (buf0 =="}, {"sha": "86b9da1b39c0b642fbb38917940f0a3766582c12", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -18,6 +18,7 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use std::num;\n use std::uint;\n use std::vec;\n use extra::sort;\n@@ -244,7 +245,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 let max_len = do m.rev_iter().fold(0) |max_len, r| {\n                   match r[0].node {\n                     pat_vec(ref before, _, ref after) => {\n-                      uint::max(before.len() + after.len(), max_len)\n+                      num::max(before.len() + after.len(), max_len)\n                     }\n                     _ => max_len\n                   }"}, {"sha": "1492f44d97745ed623c1ae9d5c91d7f59fa520e0", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -14,8 +14,8 @@ use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n \n use middle::trans::type_::Type;\n \n+use std::num;\n use std::option::{Option, None, Some};\n-use std::uint;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n@@ -41,7 +41,7 @@ fn ty_align(ty: Type) -> uint {\n                 1\n             } else {\n                 let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+                str_tys.iter().fold(1, |a, t| num::max(a, ty_align(*t)))\n             }\n         }\n         Array => {"}, {"sha": "a9407092eed45d5c608b3ced270068ad15140788", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -10,7 +10,7 @@\n \n \n use std::libc::c_uint;\n-use std::uint;\n+use std::num;\n use std::vec;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n@@ -43,7 +43,7 @@ fn ty_align(ty: Type) -> uint {\n             1\n           } else {\n             let str_tys = ty.field_types();\n-            str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+            str_tys.iter().fold(1, |a, t| num::max(a, ty_align(*t)))\n           }\n         }\n         Array => {\n@@ -97,7 +97,7 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>)\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n \n-    align = uint::min(uint::max(align, 4), 8);\n+    align = num::min(num::max(align, 4), 8);\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n "}, {"sha": "6a0387d14ea43cc06b788c9be0824727bce0ddb1", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -18,6 +18,7 @@ use middle::trans::cabi::*;\n \n use middle::trans::type_::Type;\n \n+use std::num;\n use std::option;\n use std::option::Option;\n use std::uint;\n@@ -104,7 +105,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 1\n               } else {\n                 let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+                str_tys.iter().fold(1, |a, t| num::max(a, ty_align(*t)))\n               }\n             }\n             Array => {"}, {"sha": "4293a44d929929390ee12d3d44a7476aaeabf6d9", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -34,11 +34,11 @@ use driver::session;\n use middle::lint;\n \n use std::io;\n+use std::num;\n use std::os;\n use std::result;\n use std::str;\n use std::task;\n-use std::uint;\n use std::vec;\n use extra::getopts::{groups, opt_present};\n use extra::getopts;\n@@ -153,7 +153,7 @@ Available lint options:\n \n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0;\n-    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n+    for lint_dict.each_key |k| { max_key = num::max(k.len(), max_key); }\n     fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }"}, {"sha": "4c2464f8b34736d7f217d86abb8fb7cb59238d24", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -20,6 +20,7 @@ middle of a line, and each of the following lines is indented.\n */\n \n \n+use std::num;\n use std::uint;\n use pass::Pass;\n use text_pass;\n@@ -69,7 +70,7 @@ fn unindent(s: &str) -> ~str {\n                     false\n                 }\n             };\n-            uint::min(min_indent, spaces)\n+            num::min(min_indent, spaces)\n         }\n     };\n "}, {"sha": "6c93cd0dc86828c98ffbf84f05d12a5892789486", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -19,6 +19,7 @@ use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n use iterator::{Iterator, IteratorUtil};\n+use num;\n use option::{None, Option, Some};\n use rand::RngUtil;\n use rand;\n@@ -74,7 +75,7 @@ pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n     k0: u64, k1: u64,\n     initial_capacity: uint) -> HashMap<K, V> {\n-    let cap = uint::max(INITIAL_CAPACITY, initial_capacity);\n+    let cap = num::max(INITIAL_CAPACITY, initial_capacity);\n     HashMap {\n         k0: k0, k1: k1,\n         resize_at: resize_at(cap),"}, {"sha": "347fa98885686fd7c0dc15f5d24bd0d8ab621bee", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -53,6 +53,7 @@ use int;\n use libc;\n use libc::{c_int, c_long, c_void, size_t, ssize_t};\n use libc::consts::os::posix88::*;\n+use num;\n use os;\n use cast;\n use path::Path;\n@@ -1054,7 +1055,7 @@ pub struct BytesReader {\n \n impl Reader for BytesReader {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        let count = uint::min(len, self.bytes.len() - *self.pos);\n+        let count = num::min(len, self.bytes.len() - *self.pos);\n \n         let view = self.bytes.slice(*self.pos, self.bytes.len());\n         vec::bytes::copy_memory(bytes, view, count);\n@@ -1660,7 +1661,7 @@ impl Writer for BytesWriter {\n         let v_len = v.len();\n \n         let bytes = &mut *self.bytes;\n-        let count = uint::max(bytes.len(), *self.pos + v_len);\n+        let count = num::max(bytes.len(), *self.pos + v_len);\n         bytes.reserve(count);\n \n         unsafe {"}, {"sha": "faf9b2e2390dc65bcdb80603a6062f55403f120d", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 15, "deletions": 49, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -21,9 +21,7 @@ use to_str;\n \n pub use cmath::c_float_targ_consts::*;\n \n-// An inner module is required to get the #[inline] attribute on the\n-// functions.\n-pub use self::delegated::*;\n+use self::delegated::*;\n \n macro_rules! delegate(\n     (\n@@ -35,6 +33,8 @@ macro_rules! delegate(\n             ) -> $rv:ty = $bound_name:path\n         ),*\n     ) => (\n+        // An inner module is required to get the #[inline] attribute on the\n+        // functions.\n         mod delegated {\n             use cmath::c_float_utils;\n             use libc::{c_float, c_int};\n@@ -116,50 +116,6 @@ pub static infinity: f32 = 1.0_f32/0.0_f32;\n \n pub static neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-#[inline]\n-pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n-\n-#[inline]\n-pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n-\n-#[inline]\n-pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n-\n-#[inline]\n-pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n-\n-#[inline]\n-pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n-\n-#[inline]\n-pub fn lt(x: f32, y: f32) -> bool { return x < y; }\n-\n-#[inline]\n-pub fn le(x: f32, y: f32) -> bool { return x <= y; }\n-\n-#[inline]\n-pub fn eq(x: f32, y: f32) -> bool { return x == y; }\n-\n-#[inline]\n-pub fn ne(x: f32, y: f32) -> bool { return x != y; }\n-\n-#[inline]\n-pub fn ge(x: f32, y: f32) -> bool { return x >= y; }\n-\n-#[inline]\n-pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n-\n-#[inline]\n-pub fn fmax(x: f32, y: f32) -> f32 {\n-    if x >= y || y.is_NaN() { x } else { y }\n-}\n-\n-#[inline]\n-pub fn fmin(x: f32, y: f32) -> f32 {\n-    if x <= y || y.is_NaN() { x } else { y }\n-}\n-\n-\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n@@ -251,13 +207,23 @@ impl Orderable for f32 {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n     #[inline]\n     fn min(&self, other: &f32) -> f32 {\n-        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n+        cond!(\n+            (self.is_NaN())  { *self  }\n+            (other.is_NaN()) { *other }\n+            (*self < *other) { *self  }\n+            _                { *other }\n+        )\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n     #[inline]\n     fn max(&self, other: &f32) -> f32 {\n-        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n+        cond!(\n+            (self.is_NaN())  { *self  }\n+            (other.is_NaN()) { *other }\n+            (*self > *other) { *self  }\n+            _                { *other }\n+        )\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`."}, {"sha": "c7db60e6fd2649e772758ee26666c6eac513cfe1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 15, "deletions": 48, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -23,9 +23,7 @@ use to_str;\n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n \n-// An inner module is required to get the #[inline] attribute on the\n-// functions.\n-pub use self::delegated::*;\n+use self::delegated::*;\n \n macro_rules! delegate(\n     (\n@@ -37,6 +35,8 @@ macro_rules! delegate(\n             ) -> $rv:ty = $bound_name:path\n         ),*\n     ) => (\n+        // An inner module is required to get the #[inline] attribute on the\n+        // functions.\n         mod delegated {\n             use cmath::c_double_utils;\n             use libc::{c_double, c_int};\n@@ -142,49 +142,6 @@ pub static infinity: f64 = 1.0_f64/0.0_f64;\n \n pub static neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-#[inline]\n-pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n-\n-#[inline]\n-pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n-\n-#[inline]\n-pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n-\n-#[inline]\n-pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n-\n-#[inline]\n-pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n-\n-#[inline]\n-pub fn lt(x: f64, y: f64) -> bool { return x < y; }\n-\n-#[inline]\n-pub fn le(x: f64, y: f64) -> bool { return x <= y; }\n-\n-#[inline]\n-pub fn eq(x: f64, y: f64) -> bool { return x == y; }\n-\n-#[inline]\n-pub fn ne(x: f64, y: f64) -> bool { return x != y; }\n-\n-#[inline]\n-pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n-\n-#[inline]\n-pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n-\n-#[inline]\n-pub fn fmax(x: f64, y: f64) -> f64 {\n-    if x >= y || y.is_NaN() { x } else { y }\n-}\n-\n-#[inline]\n-pub fn fmin(x: f64, y: f64) -> f64 {\n-    if x <= y || y.is_NaN() { x } else { y }\n-}\n-\n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n /* Module: consts */\n@@ -273,13 +230,23 @@ impl Orderable for f64 {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n     #[inline]\n     fn min(&self, other: &f64) -> f64 {\n-        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n+        cond!(\n+            (self.is_NaN())  { *self  }\n+            (other.is_NaN()) { *other }\n+            (*self < *other) { *self  }\n+            _                { *other }\n+        )\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n     #[inline]\n     fn max(&self, other: &f64) -> f64 {\n-        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n+        cond!(\n+            (self.is_NaN())  { *self  }\n+            (other.is_NaN()) { *other }\n+            (*self > *other) { *self  }\n+            _                { *other }\n+        )\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`."}, {"sha": "486d35620899a9fd70dc522a55db7c0c4ec3cc6a", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 17, "deletions": 53, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -23,22 +23,12 @@\n #[allow(missing_doc)];\n #[allow(non_uppercase_statics)];\n \n-use f64;\n-use libc::c_int;\n use num::{Zero, One, strconv};\n use num::FPCategory;\n use num;\n use prelude::*;\n use to_str;\n \n-pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n-pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n-pub use f64::{erf, erfc, exp, exp_m1, exp2, abs_sub};\n-pub use f64::{mul_add, fmax, fmin, next_after, frexp, hypot, ldexp};\n-pub use f64::{lgamma, ln, log_radix, ln_1p, log10, log2, ilog_radix};\n-pub use f64::{modf, pow, powi, round, sinh, tanh, tgamma, trunc};\n-pub use f64::{j0, j1, jn, y0, y1, yn};\n-\n pub static NaN: float = 0.0/0.0;\n \n pub static infinity: float = 1.0/0.0;\n@@ -342,31 +332,6 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline]\n-pub fn abs(x: float) -> float {\n-    f64::abs(x as f64) as float\n-}\n-#[inline]\n-pub fn sqrt(x: float) -> float {\n-    f64::sqrt(x as f64) as float\n-}\n-#[inline]\n-pub fn atan(x: float) -> float {\n-    f64::atan(x as f64) as float\n-}\n-#[inline]\n-pub fn sin(x: float) -> float {\n-    f64::sin(x as f64) as float\n-}\n-#[inline]\n-pub fn cos(x: float) -> float {\n-    f64::cos(x as f64) as float\n-}\n-#[inline]\n-pub fn tan(x: float) -> float {\n-    f64::tan(x as f64) as float\n-}\n-\n impl Num for float {}\n \n #[cfg(not(test))]\n@@ -443,19 +408,19 @@ impl One for float {\n impl Round for float {\n     /// Round half-way cases toward `neg_infinity`\n     #[inline]\n-    fn floor(&self) -> float { floor(*self as f64) as float }\n+    fn floor(&self) -> float { (*self as f64).floor() as float }\n \n     /// Round half-way cases toward `infinity`\n     #[inline]\n-    fn ceil(&self) -> float { ceil(*self as f64) as float }\n+    fn ceil(&self) -> float { (*self as f64).ceil() as float }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(&self) -> float { round(*self as f64) as float }\n+    fn round(&self) -> float { (*self as f64).round() as float }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(&self) -> float { trunc(*self as f64) as float }\n+    fn trunc(&self) -> float { (*self as f64).trunc() as float }\n \n     ///\n     /// The fractional part of the number, satisfying:\n@@ -727,31 +692,30 @@ impl Real for float {\n impl RealExt for float {\n     #[inline]\n     fn lgamma(&self) -> (int, float) {\n-        let mut sign = 0;\n-        let result = lgamma(*self as f64, &mut sign);\n-        (sign as int, result as float)\n+        let (sign, value) = (*self as f64).lgamma();\n+        (sign, value as float)\n     }\n \n     #[inline]\n-    fn tgamma(&self) -> float { tgamma(*self as f64) as float }\n+    fn tgamma(&self) -> float { (*self as f64).tgamma() as float }\n \n     #[inline]\n-    fn j0(&self) -> float { j0(*self as f64) as float }\n+    fn j0(&self) -> float { (*self as f64).j0() as float }\n \n     #[inline]\n-    fn j1(&self) -> float { j1(*self as f64) as float }\n+    fn j1(&self) -> float { (*self as f64).j1() as float }\n \n     #[inline]\n-    fn jn(&self, n: int) -> float { jn(n as c_int, *self as f64) as float }\n+    fn jn(&self, n: int) -> float { (*self as f64).jn(n) as float }\n \n     #[inline]\n-    fn y0(&self) -> float { y0(*self as f64) as float }\n+    fn y0(&self) -> float { (*self as f64).y0() as float }\n \n     #[inline]\n-    fn y1(&self) -> float { y1(*self as f64) as float }\n+    fn y1(&self) -> float { (*self as f64).y1() as float }\n \n     #[inline]\n-    fn yn(&self, n: int) -> float { yn(n as c_int, *self as f64) as float }\n+    fn yn(&self, n: int) -> float { (*self as f64).yn(n) as float }\n }\n \n #[cfg(not(test))]\n@@ -792,7 +756,7 @@ impl Neg<float> for float {\n impl Signed for float {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n     #[inline]\n-    fn abs(&self) -> float { abs(*self) }\n+    fn abs(&self) -> float { (*self as f64).abs() as float }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n@@ -812,7 +776,7 @@ impl Signed for float {\n     ///\n     #[inline]\n     fn signum(&self) -> float {\n-        if self.is_NaN() { NaN } else { f64::copysign(1.0, *self as f64) as float }\n+        (*self as f64).signum() as float\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -939,13 +903,13 @@ impl Float for float {\n     ///\n     #[inline]\n     fn mul_add(&self, a: float, b: float) -> float {\n-        mul_add(*self as f64, a as f64, b as f64) as float\n+        (*self as f64).mul_add(a as f64, b as f64) as float\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n     fn next_after(&self, other: float) -> float {\n-        next_after(*self as f64, other as f64) as float\n+        (*self as f64).next_after(other as f64) as float\n     }\n }\n "}, {"sha": "75e0bbcb71b04b6c3502b30ff3f82b73b6f0ff76", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -29,62 +29,6 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = (-1 as $T) << (bits - 1);\n pub static max_value: $T = min_value - 1 as $T;\n \n-/// Calculates the sum of two numbers\n-#[inline]\n-pub fn add(x: $T, y: $T) -> $T { x + y }\n-/// Subtracts the second number from the first\n-#[inline]\n-pub fn sub(x: $T, y: $T) -> $T { x - y }\n-/// Multiplies two numbers together\n-#[inline]\n-pub fn mul(x: $T, y: $T) -> $T { x * y }\n-/// Divides the first argument by the second argument (using integer division)\n-/// Divides the first argument by the second argument (using integer division)\n-#[inline]\n-pub fn div(x: $T, y: $T) -> $T { x / y }\n-\n-///\n-/// Returns the remainder of y / x.\n-///\n-/// # Examples\n-/// ~~~\n-/// assert!(int::rem(5 / 2) == 1);\n-/// ~~~\n-///\n-/// When faced with negative numbers, the result copies the sign of the\n-/// dividend.\n-///\n-/// ~~~\n-/// assert!(int::rem(2 / -3) ==  2);\n-/// ~~~\n-///\n-/// ~~~\n-/// assert!(int::rem(-2 / 3) ==  -2);\n-/// ~~~\n-///\n-///\n-#[inline]\n-pub fn rem(x: $T, y: $T) -> $T { x % y }\n-\n-/// Returns true iff `x < y`\n-#[inline]\n-pub fn lt(x: $T, y: $T) -> bool { x < y }\n-/// Returns true iff `x <= y`\n-#[inline]\n-pub fn le(x: $T, y: $T) -> bool { x <= y }\n-/// Returns true iff `x == y`\n-#[inline]\n-pub fn eq(x: $T, y: $T) -> bool { x == y }\n-/// Returns true iff `x != y`\n-#[inline]\n-pub fn ne(x: $T, y: $T) -> bool { x != y }\n-/// Returns true iff `x >= y`\n-#[inline]\n-pub fn ge(x: $T, y: $T) -> bool { x >= y }\n-/// Returns true iff `x > y`\n-#[inline]\n-pub fn gt(x: $T, y: $T) -> bool { x > y }\n-\n ///\n /// Iterate over the range [`lo`..`hi`)\n ///\n@@ -137,16 +81,6 @@ pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n     range_step(hi, lo, -1 as $T, it)\n }\n \n-/// Computes the bitwise complement\n-#[inline]\n-pub fn compl(i: $T) -> $T {\n-    -1 as $T ^ i\n-}\n-\n-/// Computes the absolute value\n-#[inline]\n-pub fn abs(i: $T) -> $T { i.abs() }\n-\n impl Num for $T {}\n \n #[cfg(not(test))]"}, {"sha": "4468b51c26148dfc440753c25ea2b549b1620bf9", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -46,6 +46,9 @@ pub trait Orderable: Ord {\n     fn clamp(&self, mn: &Self, mx: &Self) -> Self;\n }\n \n+#[inline(always)] pub fn min<T: Orderable>(a: T, b: T) -> T { a.min(&b) }\n+#[inline(always)] pub fn max<T: Orderable>(a: T, b: T) -> T { a.max(&b) }\n+\n pub trait Zero {\n     fn zero() -> Self;      // FIXME (#5527): This should be an associated constant\n     fn is_zero(&self) -> bool;\n@@ -65,12 +68,10 @@ pub trait Signed: Num\n     fn is_negative(&self) -> bool;\n }\n \n-pub trait Unsigned: Num {}\n+#[inline(always)] pub fn abs<T: Signed>(value: T) -> T { value.abs() }\n+#[inline(always)] pub fn signum<T: Signed>(value: T) -> T { value.signum() }\n \n-// This should be moved into the default implementation for Signed::abs\n-pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n-    if v < Zero::zero() { v.neg() } else { v }\n-}\n+pub trait Unsigned: Num {}\n \n pub trait Integer: Num\n                  + Orderable\n@@ -113,6 +114,8 @@ pub trait Algebraic {\n     fn hypot(&self, other: &Self) -> Self;\n }\n \n+#[inline(always)] pub fn sqrt<T: Algebraic>(value: T) -> T { value.sqrt() }\n+\n pub trait Trigonometric {\n     fn sin(&self) -> Self;\n     fn cos(&self) -> Self;\n@@ -124,6 +127,16 @@ pub trait Trigonometric {\n     fn sin_cos(&self) -> (Self, Self);\n }\n \n+#[inline(always)] pub fn sin<T: Trigonometric>(value: T) -> T { value.sin() }\n+#[inline(always)] pub fn cos<T: Trigonometric>(value: T) -> T { value.cos() }\n+#[inline(always)] pub fn tan<T: Trigonometric>(value: T) -> T { value.tan() }\n+\n+#[inline(always)] pub fn asin<T: Trigonometric>(value: T) -> T { value.asin() }\n+#[inline(always)] pub fn acos<T: Trigonometric>(value: T) -> T { value.acos() }\n+#[inline(always)] pub fn atan<T: Trigonometric>(value: T) -> T { value.atan() }\n+\n+#[inline(always)] pub fn atan2<T: Trigonometric>(x: T, y: T) -> T { x.atan2(&y) }\n+\n pub trait Exponential {\n     fn exp(&self) -> Self;\n     fn exp2(&self) -> Self;\n@@ -133,6 +146,14 @@ pub trait Exponential {\n     fn log10(&self) -> Self;\n }\n \n+#[inline(always)] pub fn exp<T: Exponential>(value: T) -> T { value.exp() }\n+#[inline(always)] pub fn exp2<T: Exponential>(value: T) -> T { value.exp2() }\n+\n+#[inline(always)] pub fn ln<T: Exponential>(value: T) -> T { value.ln() }\n+#[inline(always)] pub fn log<T: Exponential>(value: T, base: T) -> T { value.log(&base) }\n+#[inline(always)] pub fn log2<T: Exponential>(value: T) -> T { value.log2() }\n+#[inline(always)] pub fn log10<T: Exponential>(value: T) -> T { value.log10() }\n+\n pub trait Hyperbolic: Exponential {\n     fn sinh(&self) -> Self;\n     fn cosh(&self) -> Self;\n@@ -142,6 +163,14 @@ pub trait Hyperbolic: Exponential {\n     fn atanh(&self) -> Self;\n }\n \n+#[inline(always)] pub fn sinh<T: Hyperbolic>(value: T) -> T { value.sinh() }\n+#[inline(always)] pub fn cosh<T: Hyperbolic>(value: T) -> T { value.cosh() }\n+#[inline(always)] pub fn tanh<T: Hyperbolic>(value: T) -> T { value.tanh() }\n+\n+#[inline(always)] pub fn asinh<T: Hyperbolic>(value: T) -> T { value.asinh() }\n+#[inline(always)] pub fn acosh<T: Hyperbolic>(value: T) -> T { value.acosh() }\n+#[inline(always)] pub fn atanh<T: Hyperbolic>(value: T) -> T { value.atanh() }\n+\n ///\n /// Defines constants and methods common to real numbers\n ///"}, {"sha": "de1b997b14b52355cb243229f7fcb930136e8bf7", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -30,42 +30,6 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = 0 as $T;\n pub static max_value: $T = 0 as $T - 1 as $T;\n \n-/// Calculates the sum of two numbers\n-#[inline]\n-pub fn add(x: $T, y: $T) -> $T { x + y }\n-/// Subtracts the second number from the first\n-#[inline]\n-pub fn sub(x: $T, y: $T) -> $T { x - y }\n-/// Multiplies two numbers together\n-#[inline]\n-pub fn mul(x: $T, y: $T) -> $T { x * y }\n-/// Divides the first argument by the second argument (using integer division)\n-#[inline]\n-pub fn div(x: $T, y: $T) -> $T { x / y }\n-/// Calculates the integer remainder when x is divided by y (equivalent to the\n-/// '%' operator)\n-#[inline]\n-pub fn rem(x: $T, y: $T) -> $T { x % y }\n-\n-/// Returns true iff `x < y`\n-#[inline]\n-pub fn lt(x: $T, y: $T) -> bool { x < y }\n-/// Returns true iff `x <= y`\n-#[inline]\n-pub fn le(x: $T, y: $T) -> bool { x <= y }\n-/// Returns true iff `x == y`\n-#[inline]\n-pub fn eq(x: $T, y: $T) -> bool { x == y }\n-/// Returns true iff `x != y`\n-#[inline]\n-pub fn ne(x: $T, y: $T) -> bool { x != y }\n-/// Returns true iff `x >= y`\n-#[inline]\n-pub fn ge(x: $T, y: $T) -> bool { x >= y }\n-/// Returns true iff `x > y`\n-#[inline]\n-pub fn gt(x: $T, y: $T) -> bool { x > y }\n-\n #[inline]\n /**\n  * Iterate through a range with a given step value.\n@@ -114,12 +78,6 @@ pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n     range_step(hi, lo, -1 as $T_SIGNED, it)\n }\n \n-/// Computes the bitwise complement\n-#[inline]\n-pub fn compl(i: $T) -> $T {\n-    max_value ^ i\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]"}, {"sha": "02c8694bf76e2edf64d32ff5076b992388811024", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -46,6 +46,7 @@ use container::Container;\n use int;\n use iterator::IteratorUtil;\n use local_data;\n+use num;\n use prelude::*;\n use str;\n use sys;\n@@ -463,7 +464,7 @@ impl<R: Rng> RngUtil for R {\n      */\n     fn gen_int_range(&mut self, start: int, end: int) -> int {\n         assert!(start < end);\n-        start + int::abs(self.gen::<int>() % (end - start))\n+        start + num::abs(self.gen::<int>() % (end - start))\n     }\n \n     /**"}, {"sha": "4d983b9495446209e0ab401260628866b16e15fb", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -20,7 +20,7 @@\n // Generating Random Variables\"], but more robust. If one wanted, one\n // could implement VIZIGNOR the ZIGNOR paper for more speed.\n \n-use f64;\n+use num;\n use rand::{Rng,Rand};\n \n mod ziggurat_tables;\n@@ -39,7 +39,7 @@ fn ziggurat<R:Rng>(rng: &mut R,\n         let i: uint = rng.gen::<uint>() & 0xff;\n         let x = u * X[i];\n \n-        let test_x = if center_u {f64::abs(x)} else {x};\n+        let test_x = if center_u {num::abs(x)} else {x};\n \n         // algebraically equivalent to |u| < X[i+1]/X[i] (or u < X[i+1]/X[i])\n         if test_x < X[i + 1] {\n@@ -79,7 +79,7 @@ impl Rand for StandardNormal {\n     fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n         #[inline]\n         fn pdf(x: f64) -> f64 {\n-            f64::exp((-x*x/2.0) as f64) as f64\n+            ((-x*x/2.0) as f64).exp()\n         }\n         #[inline]\n         fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n@@ -89,15 +89,16 @@ impl Rand for StandardNormal {\n             // do-while, so the condition should be true on the first\n             // run, they get overwritten anyway (0 < 1, so these are\n             // good).\n-            let mut x = 1.0;\n-            let mut y = 0.0;\n+            let mut x = 1.0f64;\n+            let mut y = 0.0f64;\n \n             // XXX infinities?\n-            while -2.0*y < x * x {\n-                x = f64::ln(rng.gen()) / ziggurat_tables::ZIG_NORM_R;\n-                y = f64::ln(rng.gen());\n+            while -2.0 * y < x * x {\n+                x = rng.gen::<f64>().ln() / ziggurat_tables::ZIG_NORM_R;\n+                y = rng.gen::<f64>().ln();\n             }\n-            if u < 0.0 {x-ziggurat_tables::ZIG_NORM_R} else {ziggurat_tables::ZIG_NORM_R-x}\n+\n+            if u < 0.0 { x - ziggurat_tables::ZIG_NORM_R } else { ziggurat_tables::ZIG_NORM_R - x }\n         }\n \n         StandardNormal(ziggurat(\n@@ -128,17 +129,17 @@ impl Rand for StandardNormal {\n /// ~~~\n pub struct Exp1(f64);\n \n-// This could be done via `-f64::ln(rng.gen::<f64>())` but that is slower.\n+// This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n impl Rand for Exp1 {\n     #[inline]\n     fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n         #[inline]\n         fn pdf(x: f64) -> f64 {\n-            f64::exp(-x)\n+            (-x).exp()\n         }\n         #[inline]\n         fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n-            ziggurat_tables::ZIG_EXP_R - f64::ln(rng.gen())\n+            ziggurat_tables::ZIG_EXP_R - rng.gen::<f64>().ln()\n         }\n \n         Exp1(ziggurat(rng, false,"}, {"sha": "64ac76756d53be1456a05ca0c4b739534f08be91", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -477,7 +477,7 @@ pub mod rt {\n     use float;\n     use str;\n     use sys;\n-    use int;\n+    use num;\n     use uint;\n     use vec;\n     use option::{Some, None, Option};\n@@ -503,7 +503,7 @@ pub mod rt {\n     pub fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n-        let s : ~str = uint_to_str_prec(int::abs(i) as uint, radix, prec);\n+        let s : ~str = uint_to_str_prec(num::abs(i) as uint, radix, prec);\n \n         let head = if i >= 0 {\n             if have_flag(cv.flags, flag_sign_always) {"}, {"sha": "d4861eacc51bf5c8fdd2685e1546bf7fe3be9af7", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -1919,7 +1919,7 @@ pub mod raw {\n /// Operations on `[u8]`\n pub mod bytes {\n     use libc;\n-    use uint;\n+    use num;\n     use vec::raw;\n     use vec;\n     use ptr;\n@@ -1943,7 +1943,7 @@ pub mod bytes {\n     pub fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = a.len();\n         let b_len = b.len();\n-        let n = uint::min(a_len, b_len) as libc::size_t;\n+        let n = num::min(a_len, b_len) as libc::size_t;\n         let r = unsafe {\n             libc::memcmp(raw::to_ptr(*a) as *libc::c_void,\n                          raw::to_ptr(*b) as *libc::c_void, n) as int"}, {"sha": "78be8e6f180af8f58fb4952f2eda42ee42036d80", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -18,6 +18,7 @@ use visit;\n \n use std::hashmap::HashMap;\n use std::int;\n+use std::num;\n use std::option;\n use std::cast;\n use std::local_data;\n@@ -376,8 +377,8 @@ impl id_range {\n     }\n \n     pub fn add(&mut self, id: node_id) {\n-        self.min = int::min(self.min, id);\n-        self.max = int::max(self.max, id + 1);\n+        self.min = num::min(self.min, id);\n+        self.max = num::max(self.max, id + 1);\n     }\n }\n "}, {"sha": "dbb8da1ebd736815f39922d347a4c4146502585a", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -22,7 +22,7 @@ use extra::time;\n use extra::deque::Deque;\n use extra::par;\n use std::hashmap::HashSet;\n-use std::int::abs;\n+use std::num::abs;\n use std::io;\n use std::os;\n use std::rand::RngUtil;"}, {"sha": "31a300689785f8745452fc50f57a6c73aa54a2ce", "filename": "src/test/run-pass/class-impl-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -58,7 +58,7 @@ class cat : map<int, bool> {\n   fn find(&&k:int) -> Option<bool> { Some(self.get(k)) }\n   fn remove(&&k:int) -> Option<bool> { self.meows -= k; Some(true) }\n   fn each(f: &fn(&&int, &&bool) -> bool) {\n-    let mut n = int::abs(self.meows);\n+    let mut n = num::abs(self.meows);\n     while n > 0 {\n         if !f(n, true) { break; }\n         n -= 1;"}, {"sha": "3a683bc7cb92c37b2cbbfbf9122d389f96517b85", "filename": "src/test/run-pass/core-export-f64-sqrt.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44770ae3a8001de38b33e449889c6444808941fc/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44770ae3a8001de38b33e449889c6444808941fc/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs?ref=44770ae3a8001de38b33e449889c6444808941fc", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Regression test that f64 exports things properly\n-\n-use std::f64;\n-use std::float;\n-\n-pub fn main() {\n-\n-    let digits: uint = 10 as uint;\n-\n-    println(float::to_str_digits(f64::sqrt(42.0f64) as float, digits));\n-}"}, {"sha": "474e0cfe1db2966a0ea80fbf9fb3b369319f4414", "filename": "src/test/run-pass/trait-inheritance-self-in-supertype.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -1,7 +1,6 @@\n // Test for issue #4183: use of Self in supertraits.\n \n-use std::f32;\n-use std::f64;\n+use std::num;\n \n pub static FUZZY_EPSILON: float = 0.1;\n \n@@ -20,7 +19,7 @@ impl FuzzyEq<f32> for f32 {\n     }\n \n     fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n-        f32::abs(*self - *other) < *epsilon\n+        num::abs(*self - *other) < *epsilon\n     }\n }\n \n@@ -34,7 +33,7 @@ impl FuzzyEq<f64> for f64 {\n     }\n \n     fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n-        f64::abs(*self - *other) < *epsilon\n+        num::abs(*self - *other) < *epsilon\n     }\n }\n "}, {"sha": "3bc29ea13e3430ac44ebae45772df08cfc8acdfb", "filename": "src/test/run-pass/utf8_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Frun-pass%2Futf8_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aae28a57d42bfd56e0838ddee0a44605922d655/src%2Ftest%2Frun-pass%2Futf8_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_idents.rs?ref=1aae28a57d42bfd56e0838ddee0a44605922d655", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::float;\n+use std::num;\n \n pub fn main() {\n     let \u03b5 = 0.00001;\n     let \u03a0 = 3.14;\n     let \u0932\u0902\u091a = \u03a0 * \u03a0 + 1.54;\n-    assert!(float::abs((\u0932\u0902\u091a - 1.54) - (\u03a0 * \u03a0)) < \u03b5);\n+    assert!(num::abs((\u0932\u0902\u091a - 1.54) - (\u03a0 * \u03a0)) < \u03b5);\n     assert_eq!(\u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8(), 0);\n }\n "}]}