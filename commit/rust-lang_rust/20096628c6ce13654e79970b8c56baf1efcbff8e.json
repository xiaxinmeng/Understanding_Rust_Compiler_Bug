{"sha": "20096628c6ce13654e79970b8c56baf1efcbff8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMDk2NjI4YzZjZTEzNjU0ZTc5OTcwYjhjNTZiYWYxZWZjYmZmOGU=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-05-02T01:21:20Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-05-20T15:12:49Z"}, "message": "Addressed points raised in review.", "tree": {"sha": "5b93b1709bdd689c9ddea49d852c5a003e2da20c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b93b1709bdd689c9ddea49d852c5a003e2da20c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20096628c6ce13654e79970b8c56baf1efcbff8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20096628c6ce13654e79970b8c56baf1efcbff8e", "html_url": "https://github.com/rust-lang/rust/commit/20096628c6ce13654e79970b8c56baf1efcbff8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20096628c6ce13654e79970b8c56baf1efcbff8e/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd7c253accd46ea8340feb79ecaf18d99f518bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd7c253accd46ea8340feb79ecaf18d99f518bb8", "html_url": "https://github.com/rust-lang/rust/commit/fd7c253accd46ea8340feb79ecaf18d99f518bb8"}], "stats": {"total": 180, "additions": 119, "deletions": 61}, "files": [{"sha": "4e5aa6b915b56bb284232c97fe5f76b02ac78182", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -56,6 +56,7 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     }\n \n     fn contains(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        // See the `insert` method for why we use `anonymize_predicate` here.\n         self.set.contains(&anonymize_predicate(self.tcx, pred))\n     }\n \n@@ -74,13 +75,14 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     }\n \n     fn remove(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        // See the `insert` method for why we use `anonymize_predicate` here.\n         self.set.remove(&anonymize_predicate(self.tcx, pred))\n     }\n }\n \n impl<'a, 'gcx, 'tcx, T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'a, 'gcx, 'tcx> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        for pred in iter.into_iter() {\n+        for pred in iter {\n             self.insert(pred.as_ref());\n         }\n     }\n@@ -289,30 +291,33 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n /// `trait Foo = Bar + Sync;`, and another trait alias\n /// `trait Bar = Read + Write`, then the bounds would expand to\n /// `Read + Write + Sync + Send`.\n+/// Expansion is done via a DFS (depth-first search), and the `visited` field\n+/// is used to avoid cycles.\n pub struct TraitAliasExpander<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n     /// The set of predicates visited from the root directly to the current point in the\n-    /// expansion tree.\n+    /// expansion tree (only containing trait aliases).\n     visited: PredicateSet<'a, 'gcx, 'tcx>,\n }\n \n+/// Stores information about the expansion of a trait via a path of zero or more trait aliases.\n #[derive(Debug, Clone)]\n pub struct TraitAliasExpansionInfo<'tcx> {\n     pub items: SmallVec<[(ty::PolyTraitRef<'tcx>, Span); 4]>,\n }\n \n impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n-    fn new(trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> TraitAliasExpansionInfo<'tcx> {\n-        TraitAliasExpansionInfo {\n+    fn new(trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> Self {\n+        Self {\n             items: smallvec![(trait_ref, span)]\n         }\n     }\n \n-    fn push(&self, trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> TraitAliasExpansionInfo<'tcx> {\n+    fn push(&self, trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> Self {\n         let mut items = self.items.clone();\n         items.push((trait_ref, span));\n \n-        TraitAliasExpansionInfo {\n+        Self {\n             items\n         }\n     }\n@@ -330,6 +335,8 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n     }\n }\n \n+/// Emits diagnostic information relating to the expansion of a trait via trait aliases\n+/// (see [`TraitAliasExpansionInfo`]).\n pub trait TraitAliasExpansionInfoDignosticBuilder {\n     fn label_with_exp_info<'tcx>(&mut self,\n         info: &TraitAliasExpansionInfo<'tcx>,\n@@ -365,24 +372,28 @@ pub fn expand_trait_aliases<'cx, 'gcx, 'tcx>(\n \n impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n     /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n-    /// to the definition and pushes the resulting expansion onto `self.stack`, and returns `false`.\n-    /// Otherwise, immediately returns `true` if `item` is a regular trait and `false` if it is a\n+    /// to the definition, pushes the resulting expansion onto `self.stack`, and returns `false`.\n+    /// Otherwise, immediately returns `true` if `item` is a regular trait, or `false` if it is a\n     /// trait alias.\n-    /// The return value indicates whether `item` should not be yielded to the user.\n+    /// The return value indicates whether `item` should be yielded to the user.\n     fn push(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n         let tcx = self.visited.tcx;\n         let trait_ref = item.trait_ref();\n         let pred = trait_ref.to_predicate();\n \n         debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n \n-        self.visited.remove(&pred);\n-\n+        // Don't recurse unless this bound is a trait alias and isn't currently in the DFS stack of\n+        // already-visited predicates.\n         let is_alias = tcx.is_trait_alias(trait_ref.def_id());\n         if !is_alias || self.visited.contains(&pred) {\n             return !is_alias;\n         }\n \n+        // Remove the current predicate from the stack of already-visited ones, since we're doing\n+        // a DFS.\n+        self.visited.remove(&pred);\n+\n         // Get components of trait alias.\n         let predicates = tcx.super_predicates_of(trait_ref.def_id());\n "}, {"sha": "31aba9ed239c390183dadbc65329e68813525c48", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -996,11 +996,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n         if regular_traits.len() > 1 {\n             let extra_trait = &regular_traits[1];\n-            let mut err = struct_span_err!(tcx.sess, extra_trait.bottom().1, E0225,\n-                \"only auto traits can be used as additional traits in a trait object\");\n-            err.label_with_exp_info(extra_trait, \"additional non-auto trait\");\n-            err.span_label(regular_traits[0].top().1, \"first non-auto trait\");\n-            err.emit();\n+            struct_span_err!(tcx.sess, extra_trait.bottom().1, E0225,\n+                \"only auto traits can be used as additional traits in a trait object\"\n+            )\n+                .label_with_exp_info(extra_trait, \"additional non-auto trait\")\n+                .span_label(regular_traits[0].top().1, \"first non-auto trait\")\n+                .emit();\n         }\n \n         if regular_traits.is_empty() && auto_traits.is_empty() {"}, {"sha": "b50f68e64516f9ee6a9f19e25cef36537dc61a6b", "filename": "src/test/ui/error-codes/E0225.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ferror-codes%2FE0225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ferror-codes%2FE0225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0225.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -3,8 +3,8 @@\n trait Foo = std::io::Read + std::io::Write;\n \n fn main() {\n-    let _: Box<std::io::Read + std::io::Write>;\n+    let _: Box<dyn std::io::Read + std::io::Write>;\n     //~^ ERROR only auto traits can be used as additional traits in a trait object [E0225]\n-    let _: Box<Foo>;\n+    let _: Box<dyn Foo>;\n     //~^ ERROR only auto traits can be used as additional traits in a trait object [E0225]\n }"}, {"sha": "95d14f6d1da3acde665a15126a957bf8c2373df2", "filename": "src/test/ui/maybe-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Fmaybe-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Fmaybe-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaybe-bounds.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -1,6 +1,6 @@\n trait Tr: ?Sized {} //~ ERROR `?Trait` is not permitted in supertraits\n \n-type A1 = Tr + (?Sized);\n-type A2 = for<'a> Tr + (?Sized);\n+type A1 = dyn Tr + (?Sized);\n+type A2 = dyn for<'a> Tr + (?Sized);\n \n fn main() {}"}, {"sha": "3dfcf03ce79da7193881532f9e7df8e48ce96e71", "filename": "src/test/ui/traits/trait-alias/trait-alias-maybe-bound.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-maybe-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-maybe-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-maybe-bound.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -1,27 +1,29 @@\n+// compile-pass\n+\n // Test that `dyn ... + ?Sized + ...` resulting from the expansion of trait aliases is okay.\n \n #![feature(trait_alias)]\n \n+trait Foo {}\n+\n trait S = ?Sized;\n \n // Nest a couple of levels deep:\n trait _0 = S;\n trait _1 = _0;\n \n // Straight list expansion:\n-type _T0 = dyn _1;\n-//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+type _T0 = dyn _1 + Foo;\n \n // In second position:\n-type _T1 = dyn Copy + _1;\n+type _T1 = dyn Foo + _1;\n \n // ... and with an auto trait:\n-type _T2 = dyn Copy + Send + _1;\n+type _T2 = dyn Foo + Send + _1;\n \n // Twice:\n trait _2 = _1 + _1;\n \n-type _T3 = dyn _2;\n-//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+type _T3 = dyn _2 + Foo;\n \n fn main() {}"}, {"sha": "afd8400e2305016693015d94d26a3390fe0dfa57", "filename": "src/test/ui/traits/trait-alias/trait-alias-no-duplicates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-no-duplicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-no-duplicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-no-duplicates.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -6,7 +6,7 @@\n \n use std::marker::Unpin;\n \n-// Some arbitray object-safe trait:\n+// Some arbitrary object-safe trait:\n trait Obj {}\n \n // Nest a few levels deep:"}, {"sha": "4dad8c0f87349346da21abf49acd5e489031e52c", "filename": "src/test/ui/traits/trait-alias/trait-alias-no-extra-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-no-extra-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-no-extra-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-no-extra-traits.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -5,7 +5,7 @@\n \n use std::marker::Unpin;\n \n-// Some arbitray object-safe traits:\n+// Some arbitrary object-safe traits:\n trait ObjA {}\n trait ObjB {}\n "}, {"sha": "f7c410c6362f61b0d3bb6cea3568e4edc2e54fae", "filename": "src/test/ui/traits/trait-alias/trait-alias-object-wf.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-object-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-object-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-object-wf.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-// This test checks that trait objects involving trait aliases are well-formed.\n+// This test hecks that trait objects involving trait aliases are well-formed.\n \n #![feature(trait_alias)]\n \n@@ -14,49 +14,61 @@ trait _1 = _0 + Send + Sync;\n \n use std::marker::Unpin;\n \n-type _T01 = dyn _0;\n-type _T02 = dyn _1;\n-type _T03 = dyn Unpin + _1 + Send + Sync;\n+fn _f0() {\n+    let _: Box<dyn _0>;\n+    let _: Box<dyn _1>;\n+    let _: Box<dyn Unpin + _1 + Send + Sync>;\n+}\n \n // Include object safe traits:\n \n-type _T10 = dyn Obj + _0;\n-type _T11 = dyn Obj + _1;\n-type _T12 = dyn Obj + _1 + _0;\n+fn _f1() {\n+    let _: Box<dyn Obj + _0>;\n+    let _: Box<dyn Obj + _1>;\n+    let _: Box<dyn Obj + _1 + _0>;\n+}\n \n // And when the object safe trait is in a trait alias:\n \n trait _2 = Obj;\n \n-type _T20 = dyn _2 + _0;\n-type _T21 = dyn _2 + _1;\n-type _T22 = dyn _2 + _1 + _0;\n+fn _f2() {\n+    let _: Box<dyn _2 + _0>;\n+    let _: Box<dyn _2 + _1>;\n+    let _: Box<dyn _2 + _1 + _0>;\n+}\n \n // And it should also work when that trait is has auto traits to the right of it.\n \n trait _3 = Obj + Unpin;\n \n-type _T30 = dyn _3 + _0;\n-type _T31 = dyn _3 + _1;\n-type _T32 = dyn _3 + _1 + _0;\n+fn _f3() {\n+    let _: Box<dyn _3 + _0>;\n+    let _: Box<dyn _3 + _1>;\n+    let _: Box<dyn _3 + _1 + _0>;\n+}\n \n // Nest the trait deeply:\n \n trait _4 = _3;\n trait _5 = _4 + Sync + _0 + Send;\n trait _6 = _5 + Send + _1 + Sync;\n \n-type _T60 = dyn _6 + _0;\n-type _T61 = dyn _6 + _1;\n-type _T62 = dyn _6 + _1 + _0;\n+fn _f4() {\n+    let _: Box<dyn _6 + _0>;\n+    let _: Box<dyn _6 + _1>;\n+    let _: Box<dyn _6 + _1 + _0>;\n+}\n \n // Just nest the trait alone:\n \n trait _7 = _2;\n trait _8 = _7;\n trait _9 = _8;\n \n-type _T9 = dyn _9;\n+fn _f5() {\n+    let _: Box<dyn _9>;\n+}\n \n // First bound is auto trait:\n \n@@ -65,7 +77,9 @@ trait _11 = Obj + Send;\n trait _12 = Sync + _11;\n trait _13 = Send + _12;\n \n-type _T70 = dyn _0;\n-type _T71 = dyn _3;\n+fn f6() {\n+    let _: Box<dyn _10>;\n+    let _: Box<dyn _13>;\n+}\n \n fn main() {}"}, {"sha": "d6c611d2a4d91e035be3dbedea7ec18ae57650ca", "filename": "src/test/ui/traits/trait-alias/trait-alias-only-maybe-bound.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -0,0 +1,22 @@\n+// Test that `dyn ?Sized` (i.e., a trait object with only a maybe buond) is not allowed, when just\n+// `?Sized` results from trait alias expansion.\n+\n+#![feature(trait_alias)]\n+\n+trait S = ?Sized;\n+\n+// Nest a couple of levels deep:\n+trait _0 = S;\n+trait _1 = _0;\n+\n+// Straight list expansion:\n+type _T0 = dyn _1;\n+//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+\n+// Twice:\n+trait _2 = _1 + _1;\n+\n+type _T1 = dyn _2;\n+//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+\n+fn main() {}"}, {"sha": "52e90c00c3741372671aefae5b16b2c91b1bee9c", "filename": "src/test/ui/traits/trait-alias/trait-alias-only-maybe-bound.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-only-maybe-bound.stderr?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "previous_filename": "src/test/ui/traits/trait-alias/trait-alias-maybe-bound.stderr"}, {"sha": "405104fe08142eea800fba6c9de78672d95ae6e4", "filename": "src/test/ui/traits/wf-trait-object-maybe-bound.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-maybe-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-maybe-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-maybe-bound.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -1,13 +1,15 @@\n-// The purpose of this test is to demonstrate that `?Sized` is allowed in trait objects\n-// (thought it has no effect).\n+// compile-pass\n \n-type _0 = dyn ?Sized;\n-//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+// Test that `dyn ... + ?Sized + ...` is okay (though `?Sized` has no effect in trait objects).\n \n-type _1 = dyn Clone + ?Sized;\n+trait Foo {}\n \n-type _2 = dyn Clone + ?Sized + ?Sized;\n+type _0 = dyn ?Sized + Foo;\n \n-type _3 = dyn ?Sized + Clone;\n+type _1 = dyn Foo + ?Sized;\n+\n+type _2 = dyn Foo + ?Sized + ?Sized;\n+\n+type _3 = dyn ?Sized + Foo;\n \n fn main() {}"}, {"sha": "678ede58296a49c28bd8b753be0a4dfb0da917dc", "filename": "src/test/ui/traits/wf-trait-object-no-duplicates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-no-duplicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-no-duplicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-no-duplicates.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -1,7 +1,7 @@\n // The purpose of this test is to demonstrate that duplicating object safe traits\n // that are not auto-traits is rejected even though one could reasonably accept this.\n \n-// Some arbitray object-safe trait:\n+// Some arbitrary object-safe trait:\n trait Obj {}\n \n // Demonstrate that recursive expansion of trait aliases doesn't affect stable behavior:"}, {"sha": "c8e6ac38b5a318e602970905e9f2f8cabedc6ca0", "filename": "src/test/ui/traits/wf-trait-object-only-maybe-bound.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -0,0 +1,6 @@\n+// Test that `dyn ?Sized` (i.e., a trait object with only a maybe buond) is not allowed.\n+\n+type _0 = dyn ?Sized;\n+//~^ ERROR at least one non-builtin trait is required for an object type [E0224]\n+\n+fn main() {}"}, {"sha": "ba24b83421181926e2ecf2a1b6f446d9e99c0d2a", "filename": "src/test/ui/traits/wf-trait-object-only-maybe-bound.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-only-maybe-bound.stderr?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "previous_filename": "src/test/ui/traits/wf-trait-object-maybe-bound.stderr"}, {"sha": "4f676cbe33846adadd2933241347bdbacacaf612", "filename": "src/test/ui/traits/wf-trait-object-reverse-order.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-reverse-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20096628c6ce13654e79970b8c56baf1efcbff8e/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-reverse-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fwf-trait-object-reverse-order.rs?ref=20096628c6ce13654e79970b8c56baf1efcbff8e", "patch": "@@ -1,15 +1,15 @@\n // run-pass\n \n-// Ensure that `dyn $($AutoTrait) + ObjSafe` is well-formed.\n+// Ensure that `dyn $($AutoTrait)+ ObjSafe` is well-formed.\n \n use std::marker::Unpin;\n \n-// Some arbitray object-safe trait:\n+// Some arbitrary object-safe trait:\n trait Obj {}\n \n-type _0 = Unpin;\n-type _1 = Send + Obj;\n-type _2 = Send + Unpin + Obj;\n-type _3 = Send + Unpin + Sync + Obj;\n+type _0 = dyn Unpin;\n+type _1 = dyn Send + Obj;\n+type _2 = dyn Send + Unpin + Obj;\n+type _3 = dyn Send + Unpin + Sync + Obj;\n \n fn main() {}"}]}