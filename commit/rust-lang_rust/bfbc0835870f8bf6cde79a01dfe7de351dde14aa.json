{"sha": "bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYmMwODM1ODcwZjhiZjZjZGU3OWEwMWRmZTdkZTM1MWRkZTE0YWE=", "commit": {"author": {"name": "Pierre-Andre Gagnon", "email": "pagagnon@gmail.com", "date": "2021-02-02T23:39:23Z"}, "committer": {"name": "Pierre-Andre Gagnon", "email": "pagagnon@gmail.com", "date": "2021-02-02T23:39:23Z"}, "message": "Fix for issue 6640", "tree": {"sha": "0501523283e0f73a9d18a70a2bb2d9a2f94b7fec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0501523283e0f73a9d18a70a2bb2d9a2f94b7fec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "html_url": "https://github.com/rust-lang/rust/commit/bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/comments", "author": {"login": "pag4k", "id": 32080686, "node_id": "MDQ6VXNlcjMyMDgwNjg2", "avatar_url": "https://avatars.githubusercontent.com/u/32080686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pag4k", "html_url": "https://github.com/pag4k", "followers_url": "https://api.github.com/users/pag4k/followers", "following_url": "https://api.github.com/users/pag4k/following{/other_user}", "gists_url": "https://api.github.com/users/pag4k/gists{/gist_id}", "starred_url": "https://api.github.com/users/pag4k/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pag4k/subscriptions", "organizations_url": "https://api.github.com/users/pag4k/orgs", "repos_url": "https://api.github.com/users/pag4k/repos", "events_url": "https://api.github.com/users/pag4k/events{/privacy}", "received_events_url": "https://api.github.com/users/pag4k/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pag4k", "id": 32080686, "node_id": "MDQ6VXNlcjMyMDgwNjg2", "avatar_url": "https://avatars.githubusercontent.com/u/32080686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pag4k", "html_url": "https://github.com/pag4k", "followers_url": "https://api.github.com/users/pag4k/followers", "following_url": "https://api.github.com/users/pag4k/following{/other_user}", "gists_url": "https://api.github.com/users/pag4k/gists{/gist_id}", "starred_url": "https://api.github.com/users/pag4k/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pag4k/subscriptions", "organizations_url": "https://api.github.com/users/pag4k/orgs", "repos_url": "https://api.github.com/users/pag4k/repos", "events_url": "https://api.github.com/users/pag4k/events{/privacy}", "received_events_url": "https://api.github.com/users/pag4k/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f3f9df3bb1d89ed8cd624c595af90396899360", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f3f9df3bb1d89ed8cd624c595af90396899360", "html_url": "https://github.com/rust-lang/rust/commit/c5f3f9df3bb1d89ed8cd624c595af90396899360"}], "stats": {"total": 229, "additions": 93, "deletions": 136}, "files": [{"sha": "eec76ce8b038d780c36f245729d0424983d8bfe5", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    contains_return, in_macro, is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_then,\n-    visitors::find_all_ret_expressions,\n+    contains_return, in_macro, is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_sugg,\n+    span_lint_and_then, visitors::find_all_ret_expressions,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -64,6 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         span: Span,\n         hir_id: HirId,\n     ) {\n+        // Abort if public function/method or closure.\n         match fn_kind {\n             FnKind::ItemFn(.., visibility, _) | FnKind::Method(.., Some(visibility), _) => {\n                 if visibility.node.is_pub() {\n@@ -74,6 +75,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             _ => (),\n         }\n \n+        // Abort if the method is implementing a trait or of it a trait method.\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n             if matches!(\n                 item.kind,\n@@ -83,22 +85,43 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             }\n         }\n \n-        let (return_type, path) = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::option_type) {\n+        // Check if return type is Option or Result. If neither, abort.\n+        let return_ty = return_ty(cx, hir_id);\n+        let (return_type_label, path) = if is_type_diagnostic_item(cx, return_ty, sym::option_type) {\n             (\"Option\", &paths::OPTION_SOME)\n-        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n+        } else if is_type_diagnostic_item(cx, return_ty, sym::result_type) {\n             (\"Result\", &paths::RESULT_OK)\n         } else {\n             return;\n         };\n \n+        // Take the first inner type of the Option or Result. If can't, abort.\n+        let inner_ty = if_chain! {\n+            // Skip Option or Result and take the first outermost inner type.\n+            if let Some(inner_ty) = return_ty.walk().nth(1);\n+            if let GenericArgKind::Type(inner_ty) = inner_ty.unpack();\n+            then {\n+                inner_ty\n+            } else {\n+                return;\n+            }\n+        };\n+\n+        // Check if all return expression respect the following condition and collect them.\n         let mut suggs = Vec::new();\n         let can_sugg = find_all_ret_expressions(cx, &body.value, |ret_expr| {\n             if_chain! {\n+                // Abort if in macro.\n                 if !in_macro(ret_expr.span);\n+                // Check if a function call.\n                 if let ExprKind::Call(ref func, ref args) = ret_expr.kind;\n+                // Get the Path of the function call.\n                 if let ExprKind::Path(ref qpath) = func.kind;\n+                // Check if OPTION_SOME or RESULT_OK, depending on return type.\n                 if match_qpath(qpath, path);\n+                // Make sure the function call has only one argument.\n                 if args.len() == 1;\n+                // Make sure the function argument does not contain a return expression.\n                 if !contains_return(&args[0]);\n                 then {\n                     suggs.push((ret_expr.span, snippet(cx, args[0].span.source_callsite(), \"..\").to_string()));\n@@ -110,39 +133,42 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         });\n \n         if can_sugg && !suggs.is_empty() {\n-            span_lint_and_then(\n-                cx,\n-                UNNECESSARY_WRAPS,\n-                span,\n-                format!(\n-                    \"this function's return value is unnecessarily wrapped by `{}`\",\n-                    return_type\n-                )\n-                .as_str(),\n-                |diag| {\n-                    let inner_ty = return_ty(cx, hir_id)\n-                        .walk()\n-                        .skip(1) // skip `std::option::Option` or `std::result::Result`\n-                        .take(1) // take the first outermost inner type\n-                        .filter_map(|inner| match inner.unpack() {\n-                            GenericArgKind::Type(inner_ty) => Some(inner_ty.to_string()),\n-                            _ => None,\n-                        });\n-                    inner_ty.for_each(|inner_ty| {\n+            // Issue 6640: If the inner type is Unit, emit lint similar to clippy::unused_unit.\n+            if inner_ty.is_unit() {\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_WRAPS,\n+                    fn_decl.output.span(),\n+                    \"unneeded wrapped unit return type\",\n+                    format!(\"remove the `-> {}<()>`\", return_type_label).as_str(),\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                span_lint_and_then(\n+                    cx,\n+                    UNNECESSARY_WRAPS,\n+                    span,\n+                    format!(\n+                        \"this function's return value is unnecessarily wrapped by `{}`\",\n+                        return_type_label\n+                    )\n+                    .as_str(),\n+                    |diag| {\n                         diag.span_suggestion(\n                             fn_decl.output.span(),\n-                            format!(\"remove `{}` from the return type...\", return_type).as_str(),\n-                            inner_ty,\n+                            format!(\"remove `{}` from the return type...\", return_type_label).as_str(),\n+                            inner_ty.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n-                    });\n-                    diag.multipart_suggestion(\n-                        \"...and change the returning expressions\",\n-                        suggs,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                },\n-            );\n+                        diag.multipart_suggestion(\n+                            \"...and change the returning expressions\",\n+                            suggs,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    },\n+                );\n+            }\n         }\n     }\n }"}, {"sha": "2d6aedc97ef089cc8b3881e640664b28e3531fc2", "filename": "tests/ui/unnecessary_wraps.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/tests%2Fui%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/tests%2Fui%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_wraps.rs?ref=bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "patch": "@@ -116,8 +116,36 @@ fn issue_6384(s: &str) -> Option<&str> {\n     })\n }\n \n+// should be linted\n+fn issue_6640_1(a: bool, b: bool) -> Option<()> {\n+    if a && b {\n+        return Some(());\n+    }\n+    if a {\n+        Some(());\n+        Some(())\n+    } else {\n+        return Some(());\n+    }\n+}\n+\n+// should be linted\n+fn issue_6640_2(a: bool, b: bool) -> Result<(), i32> {\n+    if a && b {\n+        return Ok(());\n+    }\n+    if a {\n+        Ok(());\n+        Ok(())\n+    } else {\n+        return Ok(());\n+    }\n+}\n+\n fn main() {\n     // method calls are not linted\n     func1(true, true);\n     func2(true, true);\n+    issue_6640_1(true, true);\n+    issue_6640_2(true, true);\n }"}, {"sha": "3ca5a8d1702b82931fda38363ec0d55512057de8", "filename": "tests/ui/unnecessary_wraps.stderr", "status": "modified", "additions": 6, "deletions": 103, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/tests%2Fui%2Funnecessary_wraps.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbc0835870f8bf6cde79a01dfe7de351dde14aa/tests%2Fui%2Funnecessary_wraps.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_wraps.stderr?ref=bfbc0835870f8bf6cde79a01dfe7de351dde14aa", "patch": "@@ -1,106 +1,9 @@\n-error: this function's return value is unnecessarily wrapped by `Option`\n-  --> $DIR/unnecessary_wraps.rs:8:1\n-   |\n-LL | / fn func1(a: bool, b: bool) -> Option<i32> {\n-LL | |     if a && b {\n-LL | |         return Some(42);\n-LL | |     }\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n-   |\n-   = note: `-D clippy::unnecessary-wraps` implied by `-D warnings`\n-help: remove `Option` from the return type...\n-   |\n-LL | fn func1(a: bool, b: bool) -> i32 {\n-   |                               ^^^\n-help: ...and change the returning expressions\n-   |\n-LL |         return 42;\n-LL |     }\n-LL |     if a {\n-LL |         Some(-1);\n-LL |         2\n-LL |     } else {\n- ...\n-\n-error: this function's return value is unnecessarily wrapped by `Option`\n-  --> $DIR/unnecessary_wraps.rs:21:1\n-   |\n-LL | / fn func2(a: bool, b: bool) -> Option<i32> {\n-LL | |     if a && b {\n-LL | |         return Some(10);\n-LL | |     }\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n-   |\n-help: remove `Option` from the return type...\n-   |\n-LL | fn func2(a: bool, b: bool) -> i32 {\n-   |                               ^^^\n-help: ...and change the returning expressions\n-   |\n-LL |         return 10;\n-LL |     }\n-LL |     if a {\n-LL |         20\n-LL |     } else {\n-LL |         30\n-   |\n-\n-error: this function's return value is unnecessarily wrapped by `Option`\n-  --> $DIR/unnecessary_wraps.rs:51:1\n-   |\n-LL | / fn func5() -> Option<i32> {\n-LL | |     Some(1)\n-LL | | }\n-   | |_^\n-   |\n-help: remove `Option` from the return type...\n-   |\n-LL | fn func5() -> i32 {\n-   |               ^^^\n-help: ...and change the returning expressions\n-   |\n-LL |     1\n-   |\n-\n-error: this function's return value is unnecessarily wrapped by `Result`\n-  --> $DIR/unnecessary_wraps.rs:61:1\n-   |\n-LL | / fn func7() -> Result<i32, ()> {\n-LL | |     Ok(1)\n-LL | | }\n-   | |_^\n-   |\n-help: remove `Result` from the return type...\n-   |\n-LL | fn func7() -> i32 {\n-   |               ^^^\n-help: ...and change the returning expressions\n-   |\n-LL |     1\n-   |\n-\n-error: this function's return value is unnecessarily wrapped by `Option`\n-  --> $DIR/unnecessary_wraps.rs:93:5\n-   |\n-LL | /     fn func12() -> Option<i32> {\n-LL | |         Some(1)\n-LL | |     }\n-   | |_____^\n-   |\n-help: remove `Option` from the return type...\n-   |\n-LL |     fn func12() -> i32 {\n-   |                    ^^^\n-help: ...and change the returning expressions\n-   |\n-LL |         1\n+error[E0282]: type annotations needed\n+  --> $DIR/unnecessary_wraps.rs:138:9\n    |\n+LL |         Ok(());\n+   |         ^^ cannot infer type for type parameter `E` declared on the enum `Result`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0282`."}]}