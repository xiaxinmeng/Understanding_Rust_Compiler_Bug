{"sha": "7c3ce02a1124b008addb9764173ad441f4741c00", "node_id": "C_kwDOAAsO6NoAKDdjM2NlMDJhMTEyNGIwMDhhZGRiOTc2NDE3M2FkNDQxZjQ3NDFjMDA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-06-09T04:39:13Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-06-14T00:57:44Z"}, "message": "Introduce a minimum CGU size in non-incremental builds.\n\nBecause tiny CGUs make compilation less efficient *and* result in worse\ngenerated code.\n\nWe don't do this when the number of CGUs is explicitly given, because\nthere are times when the requested number is very important, as\ndescribed in some comments within the commit. So the commit also\nintroduces a `CodegenUnits` type that distinguishes between default\nvalues and user-specified values.\n\nThis change has a roughly neutral effect on walltimes across the\nrustc-perf benchmarks; there are some speedups and some slowdowns. But\nit has significant wins for most other metrics on numerous benchmarks,\nincluding instruction counts, cycles, binary size, and max-rss. It also\nreduces parallelism, which is good for reducing jobserver competition\nwhen multiple rustc processes are running at the same time. It's smaller\nbenchmarks that benefit the most; larger benchmarks already have CGUs\nthat are all larger than the minimum size.\n\nHere are some example before/after CGU sizes for opt builds.\n\n- html5ever\n  - CGUs: 16, mean size: 1196.1, sizes: [3908, 2992, 1706, 1652, 1572,\n    1136, 1045, 948, 946, 938, 579, 471, 443, 327, 286, 189]\n  - CGUs: 4, mean size: 4396.0, sizes: [6706, 3908, 3490, 3480]\n\n- libc\n  - CGUs: 12, mean size: 35.3, sizes: [163, 93, 58, 53, 37, 8, 2 (x6)]\n  - CGUs: 1, mean size: 424.0, sizes: [424]\n\n- tt-muncher\n  - CGUs: 5, mean size: 1819.4, sizes: [8508, 350, 198, 34, 7]\n  - CGUs: 1, mean size: 9075.0, sizes: [9075]\n\nNote that CGUs of size 100,000+ aren't unusual in larger programs.", "tree": {"sha": "75a254e36f19194cca031505181d568fb8072c1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75a254e36f19194cca031505181d568fb8072c1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c3ce02a1124b008addb9764173ad441f4741c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3ce02a1124b008addb9764173ad441f4741c00", "html_url": "https://github.com/rust-lang/rust/commit/7c3ce02a1124b008addb9764173ad441f4741c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c3ce02a1124b008addb9764173ad441f4741c00/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "url": "https://api.github.com/repos/rust-lang/rust/commits/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40", "html_url": "https://github.com/rust-lang/rust/commit/95d85899ce7ffca741c180c9f2ef0d29f5ab9e40"}], "stats": {"total": 83, "additions": 65, "deletions": 18}, "files": [{"sha": "fa67a1b3310110d95989e4ea399409160cd6f57e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=7c3ce02a1124b008addb9764173ad441f4741c00", "patch": "@@ -1385,7 +1385,7 @@ fn vcall_visibility_metadata<'ll, 'tcx>(\n     let trait_def_id = trait_ref_self.def_id();\n     let trait_vis = cx.tcx.visibility(trait_def_id);\n \n-    let cgus = cx.sess().codegen_units();\n+    let cgus = cx.sess().codegen_units().as_usize();\n     let single_cgu = cgus == 1;\n \n     let lto = cx.sess().lto();"}, {"sha": "109e9959aeac8ca57fcc9e6e73b2368747106b8a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=7c3ce02a1124b008addb9764173ad441f4741c00", "patch": "@@ -646,10 +646,10 @@ fn produce_final_output_artifacts(\n         // rlib.\n         let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n \n-        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units() > 1;\n+        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units().as_usize() > 1;\n \n         let keep_numbered_objects =\n-            needs_crate_object || (user_wants_objects && sess.codegen_units() > 1);\n+            needs_crate_object || (user_wants_objects && sess.codegen_units().as_usize() > 1);\n \n         for module in compiled_modules.modules.iter() {\n             if let Some(ref path) = module.object {\n@@ -1923,7 +1923,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n-        if sess.codegen_units() == 1 && sess.opts.unstable_opts.time_llvm_passes {\n+        if sess.codegen_units().as_usize() == 1 && sess.opts.unstable_opts.time_llvm_passes {\n             self.backend.print_pass_timings()\n         }\n "}, {"sha": "ebcc3b0399973e409d811923abcf492d8309a6aa", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=7c3ce02a1124b008addb9764173ad441f4741c00", "patch": "@@ -113,6 +113,7 @@ use rustc_middle::query::Providers;\n use rustc_middle::ty::print::{characteristic_def_id_of_type, with_no_trimmed_paths};\n use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n+use rustc_session::CodegenUnits;\n use rustc_span::symbol::Symbol;\n \n use crate::collector::UsageMap;\n@@ -322,7 +323,7 @@ fn merge_codegen_units<'tcx>(\n     cx: &PartitioningCx<'_, 'tcx>,\n     codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n ) {\n-    assert!(cx.tcx.sess.codegen_units() >= 1);\n+    assert!(cx.tcx.sess.codegen_units().as_usize() >= 1);\n \n     // A sorted order here ensures merging is deterministic.\n     assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n@@ -331,11 +332,32 @@ fn merge_codegen_units<'tcx>(\n     let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n         codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n \n-    // Merge the two smallest codegen units until the target size is\n-    // reached.\n-    while codegen_units.len() > cx.tcx.sess.codegen_units() {\n-        // Sort small cgus to the back\n+    // Having multiple CGUs can drastically speed up compilation. But for\n+    // non-incremental builds, tiny CGUs slow down compilation *and* result in\n+    // worse generated code. So we don't allow CGUs smaller than this (unless\n+    // there is just one CGU, of course). Note that CGU sizes of 100,000+ are\n+    // common in larger programs, so this isn't all that large.\n+    const NON_INCR_MIN_CGU_SIZE: usize = 1000;\n+\n+    // Repeatedly merge the two smallest codegen units as long as:\n+    // - we have more CGUs than the upper limit, or\n+    // - (Non-incremental builds only) the user didn't specify a CGU count, and\n+    //   there are multiple CGUs, and some are below the minimum size.\n+    //\n+    // The \"didn't specify a CGU count\" condition is because when an explicit\n+    // count is requested we observe it as closely as possible. For example,\n+    // the `compiler_builtins` crate sets `codegen-units = 10000` and it's\n+    // critical they aren't merged. Also, some tests use explicit small values\n+    // and likewise won't work if small CGUs are merged.\n+    while codegen_units.len() > cx.tcx.sess.codegen_units().as_usize()\n+        || (cx.tcx.sess.opts.incremental.is_none()\n+            && matches!(cx.tcx.sess.codegen_units(), CodegenUnits::Default(_))\n+            && codegen_units.len() > 1\n+            && codegen_units.iter().any(|cgu| cgu.size_estimate() < NON_INCR_MIN_CGU_SIZE))\n+    {\n+        // Sort small cgus to the back.\n         codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+\n         let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n@@ -918,9 +940,13 @@ fn debug_dump<'a, 'tcx: 'a>(\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n                 let size = item.size_estimate(tcx);\n+                let kind = match item.instantiation_mode(tcx) {\n+                    InstantiationMode::GloballyShared { .. } => \"root\",\n+                    InstantiationMode::LocalCopy => \"inlined\",\n+                };\n                 let _ = with_no_trimmed_paths!(writeln!(\n                     s,\n-                    \"  - {item} [{linkage:?}] [{symbol_hash}] (size={size})\"\n+                    \"  - {item} [{linkage:?}] [{symbol_hash}] ({kind}, size: {size})\"\n                 ));\n             }\n "}, {"sha": "5feea83edb6a3d6a3ddf0c84cd3871f78780bdd3", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3ce02a1124b008addb9764173ad441f4741c00/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7c3ce02a1124b008addb9764173ad441f4741c00", "patch": "@@ -234,6 +234,27 @@ pub enum MetadataKind {\n     Compressed,\n }\n \n+#[derive(Clone, Copy)]\n+pub enum CodegenUnits {\n+    /// Specified by the user. In this case we try fairly hard to produce the\n+    /// number of CGUs requested.\n+    User(usize),\n+\n+    /// A default value, i.e. not specified by the user. In this case we take\n+    /// more liberties about CGU formation, e.g. avoid producing very small\n+    /// CGUs.\n+    Default(usize),\n+}\n+\n+impl CodegenUnits {\n+    pub fn as_usize(self) -> usize {\n+        match self {\n+            CodegenUnits::User(n) => n,\n+            CodegenUnits::Default(n) => n,\n+        }\n+    }\n+}\n+\n impl Session {\n     pub fn miri_unleashed_feature(&self, span: Span, feature_gate: Option<Symbol>) {\n         self.miri_unleashed_features.lock().push((span, feature_gate));\n@@ -1104,7 +1125,7 @@ impl Session {\n \n         // If there's only one codegen unit and LTO isn't enabled then there's\n         // no need for ThinLTO so just return false.\n-        if self.codegen_units() == 1 {\n+        if self.codegen_units().as_usize() == 1 {\n             return config::Lto::No;\n         }\n \n@@ -1206,19 +1227,19 @@ impl Session {\n \n     /// Returns the number of codegen units that should be used for this\n     /// compilation\n-    pub fn codegen_units(&self) -> usize {\n+    pub fn codegen_units(&self) -> CodegenUnits {\n         if let Some(n) = self.opts.cli_forced_codegen_units {\n-            return n;\n+            return CodegenUnits::User(n);\n         }\n         if let Some(n) = self.target.default_codegen_units {\n-            return n as usize;\n+            return CodegenUnits::Default(n as usize);\n         }\n \n         // If incremental compilation is turned on, we default to a high number\n         // codegen units in order to reduce the \"collateral damage\" small\n         // changes cause.\n         if self.opts.incremental.is_some() {\n-            return 256;\n+            return CodegenUnits::Default(256);\n         }\n \n         // Why is 16 codegen units the default all the time?\n@@ -1271,7 +1292,7 @@ impl Session {\n         // As a result 16 was chosen here! Mostly because it was a power of 2\n         // and most benchmarks agreed it was roughly a local optimum. Not very\n         // scientific.\n-        16\n+        CodegenUnits::Default(16)\n     }\n \n     pub fn teach(&self, code: &DiagnosticId) -> bool {"}, {"sha": "8de638dde4fbfc9a11e7320c7f898b0155d2a6cd", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c3ce02a1124b008addb9764173ad441f4741c00/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c3ce02a1124b008addb9764173ad441f4741c00/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=7c3ce02a1124b008addb9764173ad441f4741c00", "patch": "@@ -31,8 +31,8 @@ Supported values can also be discovered by running `rustc --print code-models`.\n \n ## codegen-units\n \n-This flag controls how many code generation units the crate is split into. It\n-takes an integer greater than 0.\n+This flag controls the maximum number of code generation units the crate is\n+split into. It takes an integer greater than 0.\n \n When a crate is split into multiple codegen units, LLVM is able to process\n them in parallel. Increasing parallelism may speed up compile times, but may"}]}