{"sha": "2f55354759c8b2140110a361ed43465ce5f4b785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNTUzNTQ3NTljOGIyMTQwMTEwYTM2MWVkNDM0NjVjZTVmNGI3ODU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T04:06:41Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T04:53:38Z"}, "message": "Recover on 'X..' / 'X..=' / 'X...' range patterns.", "tree": {"sha": "dbb8752d9be63797e103eb6bf3fe79a5fff572e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbb8752d9be63797e103eb6bf3fe79a5fff572e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f55354759c8b2140110a361ed43465ce5f4b785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f55354759c8b2140110a361ed43465ce5f4b785", "html_url": "https://github.com/rust-lang/rust/commit/2f55354759c8b2140110a361ed43465ce5f4b785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f55354759c8b2140110a361ed43465ce5f4b785/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "974413fcc5b8b6c32ad1334be05ad746fd82da99", "url": "https://api.github.com/repos/rust-lang/rust/commits/974413fcc5b8b6c32ad1334be05ad746fd82da99", "html_url": "https://github.com/rust-lang/rust/commit/974413fcc5b8b6c32ad1334be05ad746fd82da99"}], "stats": {"total": 64, "additions": 43, "deletions": 21}, "files": [{"sha": "34ed7f50907b16fbf46b52184d02eb57d5f17b8f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2f55354759c8b2140110a361ed43465ce5f4b785/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f55354759c8b2140110a361ed43465ce5f4b785/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2f55354759c8b2140110a361ed43465ce5f4b785", "patch": "@@ -3737,20 +3737,15 @@ impl<'a> Parser<'a> {\n             || self.token.can_begin_literal_or_bool() // e.g. `42`.\n     }\n \n-    // helper function to decide whether to parse as ident binding or to try to do\n-    // something more complex like range patterns\n+    // Helper function to decide whether to parse as ident binding\n+    // or to try to do something more complex like range patterns.\n     fn parse_as_ident(&mut self) -> bool {\n         self.look_ahead(1, |t| match t.kind {\n             token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n-            token::DotDotDot | token::DotDotEq | token::ModSep | token::Not => Some(false),\n-            // ensure slice patterns [a, b.., c] and [a, b, c..] don't go into the\n-            // range pattern branch\n-            token::DotDot => None,\n-            _ => Some(true),\n-        }).unwrap_or_else(|| self.look_ahead(2, |t| match t.kind {\n-            token::Comma | token::CloseDelim(token::Bracket) => true,\n-            _ => false,\n-        }))\n+            token::DotDotDot | token::DotDotEq | token::DotDot |\n+            token::ModSep | token::Not => false,\n+            _ => true,\n+        })\n     }\n \n     /// Parse a parentesized comma separated sequence of patterns until `delim` is reached.\n@@ -3829,6 +3824,33 @@ impl<'a> Parser<'a> {\n         Ok(PatKind::Range(begin, end, respan(lo, re)))\n     }\n \n+    /// Parse the end of a `X..Y`, `X..=Y`, or `X...Y` range pattern  or recover\n+    /// if that end is missing treating it as `X..`, `X..=`, or `X...` respectively.\n+    fn parse_pat_range_end_opt(&mut self, begin: &Expr, form: &str) -> PResult<'a, P<Expr>> {\n+        if self.is_pat_range_end_start() {\n+            // Parsing e.g. `X..=Y`.\n+            self.parse_pat_range_end()\n+        } else {\n+            // Parsing e.g. `X..`.\n+            let range_span = begin.span.to(self.prev_span);\n+\n+            self.diagnostic()\n+                .struct_span_err(\n+                    range_span,\n+                    &format!(\"`X{}` range patterns are not supported\", form),\n+                )\n+                .span_suggestion(\n+                    range_span,\n+                    \"try using the maximum value for the type\",\n+                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n+                    Applicability::HasPlaceholders,\n+                )\n+                .emit();\n+\n+            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n+        }\n+    }\n+\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -3944,10 +3966,10 @@ impl<'a> Parser<'a> {\n                         pat = PatKind::Mac(mac);\n                     }\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                        let end_kind = match self.token.kind {\n-                            token::DotDot => RangeEnd::Excluded,\n-                            token::DotDotDot => RangeEnd::Included(RangeSyntax::DotDotDot),\n-                            token::DotDotEq => RangeEnd::Included(RangeSyntax::DotDotEq),\n+                        let (end_kind, form) = match self.token.kind {\n+                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n                             _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n                                          (checked above)\"),\n                         };\n@@ -3956,7 +3978,7 @@ impl<'a> Parser<'a> {\n                         let span = lo.to(self.prev_span);\n                         let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n-                        let end = self.parse_pat_range_end()?;\n+                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n                         pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n                     }\n                     token::OpenDelim(token::Brace) => {\n@@ -3996,17 +4018,17 @@ impl<'a> Parser<'a> {\n                         let op_span = self.token.span;\n                         if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n                                 self.check(&token::DotDotDot) {\n-                            let end_kind = if self.eat(&token::DotDotDot) {\n-                                RangeEnd::Included(RangeSyntax::DotDotDot)\n+                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n                             } else if self.eat(&token::DotDotEq) {\n-                                RangeEnd::Included(RangeSyntax::DotDotEq)\n+                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n                             } else if self.eat(&token::DotDot) {\n-                                RangeEnd::Excluded\n+                                (RangeEnd::Excluded, \"..\")\n                             } else {\n                                 panic!(\"impossible case: we already matched \\\n                                         on a range-operator token\")\n                             };\n-                            let end = self.parse_pat_range_end()?;\n+                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n                             pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n                         } else {\n                             pat = PatKind::Lit(begin);"}]}