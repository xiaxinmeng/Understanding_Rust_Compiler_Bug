{"sha": "af30e3767e196aa63f813f02910f1d085de89146", "node_id": "C_kwDOAAsO6NoAKGFmMzBlMzc2N2UxOTZhYTYzZjgxM2YwMjkxMGYxZDA4NWRlODkxNDY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-01-20T15:02:31Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-01-27T13:41:32Z"}, "message": "Fix missing const expression items visit", "tree": {"sha": "bb8701e5c28aba207c9f2ef47f50ae8e2cd3f258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb8701e5c28aba207c9f2ef47f50ae8e2cd3f258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af30e3767e196aa63f813f02910f1d085de89146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af30e3767e196aa63f813f02910f1d085de89146", "html_url": "https://github.com/rust-lang/rust/commit/af30e3767e196aa63f813f02910f1d085de89146", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af30e3767e196aa63f813f02910f1d085de89146/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "url": "https://api.github.com/repos/rust-lang/rust/commits/18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "html_url": "https://github.com/rust-lang/rust/commit/18890f05f6cea40fd25bb4bb9aa6f7372b69f641"}], "stats": {"total": 299, "additions": 170, "deletions": 129}, "files": [{"sha": "2fbcda35e4417d106e7ce3926a050fb659321c92", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 170, "deletions": 129, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/af30e3767e196aa63f813f02910f1d085de89146/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af30e3767e196aa63f813f02910f1d085de89146/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=af30e3767e196aa63f813f02910f1d085de89146", "patch": "@@ -5,7 +5,10 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LocalDefIdSet};\n+use rustc_hir::intravisit::{walk_item, Visitor};\n use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -63,29 +66,37 @@ pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: LocalDefId) -> bool\n     false\n }\n \n-// Also, is there some reason that this doesn't use the 'visit'\n-// framework from syntax?.\n-\n pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: LocalDefIdSet,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n     exact_paths: DefIdMap<Vec<Symbol>>,\n+    modules: Vec<Module<'tcx>>,\n+    map: Map<'tcx>,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = LocalDefIdSet::default();\n         stack.insert(CRATE_DEF_ID);\n+        let om = Module::new(\n+            cx.tcx.crate_name(LOCAL_CRATE),\n+            CRATE_DEF_ID,\n+            cx.tcx.hir().root_module().spans.inner_span,\n+        );\n+        let map = cx.tcx.hir();\n+\n         RustdocVisitor {\n             cx,\n             view_item_stack: stack,\n             inlining: false,\n             inside_public_path: true,\n             exact_paths: Default::default(),\n+            modules: vec![om],\n+            map,\n         }\n     }\n \n@@ -94,100 +105,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n-    pub(crate) fn visit(mut self) -> Module<'tcx> {\n-        let mut top_level_module = self.visit_mod_contents(\n-            CRATE_DEF_ID,\n-            self.cx.tcx.hir().root_module(),\n-            self.cx.tcx.crate_name(LOCAL_CRATE),\n-            None,\n-        );\n-\n-        // `#[macro_export] macro_rules!` items are reexported at the top level of the\n-        // crate, regardless of where they're defined. We want to document the\n-        // top level rexport of the macro, not its original definition, since\n-        // the rexport defines the path that a user will actually see. Accordingly,\n-        // we add the rexport as an item here, and then skip over the original\n-        // definition in `visit_item()` below.\n-        //\n-        // We also skip `#[macro_export] macro_rules!` that have already been inserted,\n-        // it can happen if within the same module a `#[macro_export] macro_rules!`\n-        // is declared but also a reexport of itself producing two exports of the same\n-        // macro in the same module.\n-        let mut inserted = FxHashSet::default();\n-        for export in self.cx.tcx.module_reexports(CRATE_DEF_ID).unwrap_or(&[]) {\n-            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n-                if let Some(local_def_id) = def_id.as_local() {\n-                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n-                        if inserted.insert(def_id) {\n-                            let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                            top_level_module.items.push((item, None, None));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.cx.cache.hidden_cfg = self\n-            .cx\n-            .tcx\n-            .hir()\n-            .attrs(CRATE_HIR_ID)\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::doc))\n-            .flat_map(|attr| attr.meta_item_list().into_iter().flatten())\n-            .filter(|attr| attr.has_name(sym::cfg_hide))\n-            .flat_map(|attr| {\n-                attr.meta_item_list()\n-                    .unwrap_or(&[])\n-                    .iter()\n-                    .filter_map(|attr| {\n-                        Cfg::parse(attr.meta_item()?)\n-                            .map_err(|e| self.cx.sess().diagnostic().span_err(e.span, e.msg))\n-                            .ok()\n-                    })\n-                    .collect::<Vec<_>>()\n-            })\n-            .chain(\n-                [Cfg::Cfg(sym::test, None), Cfg::Cfg(sym::doc, None), Cfg::Cfg(sym::doctest, None)]\n-                    .into_iter(),\n-            )\n-            .collect();\n-\n-        self.cx.cache.exact_paths = self.exact_paths;\n-        top_level_module\n-    }\n-\n-    fn visit_mod_contents(\n-        &mut self,\n-        def_id: LocalDefId,\n-        m: &'tcx hir::Mod<'tcx>,\n-        name: Symbol,\n-        parent_id: Option<LocalDefId>,\n-    ) -> Module<'tcx> {\n-        let mut om = Module::new(name, def_id, m.spans.inner_span);\n-        // Keep track of if there were any private modules in the path.\n-        let orig_inside_public_path = self.inside_public_path;\n-        self.inside_public_path &= self.cx.tcx.local_visibility(def_id).is_public();\n-        for &i in m.item_ids {\n-            let item = self.cx.tcx.hir().item(i);\n-            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                continue;\n-            }\n-            self.visit_item(item, None, &mut om, parent_id);\n-        }\n-        for &i in m.item_ids {\n-            let item = self.cx.tcx.hir().item(i);\n-            // To match the way import precedence works, visit glob imports last.\n-            // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n-            // imported items appear last, then they'll be the ones that get discarded.\n-            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item, None, &mut om, parent_id);\n-            }\n-        }\n-        self.inside_public_path = orig_inside_public_path;\n-        om\n-    }\n-\n     /// Tries to resolve the target of a `pub use` statement and inlines the\n     /// target if it is defined locally and would not be documented otherwise,\n     /// or when it is specifically requested with `please_inline`.\n@@ -203,7 +120,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         res: Res,\n         renamed: Option<Symbol>,\n         glob: bool,\n-        om: &mut Module<'tcx>,\n         please_inline: bool,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n@@ -213,33 +129,30 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let tcx = self.cx.tcx;\n-        let Some(res_did) = res.opt_def_id() else {\n+        let Some(ori_res_did) = res.opt_def_id() else {\n             return false;\n         };\n \n         let use_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n-            || tcx.is_doc_hidden(def_id.to_def_id());\n+            || use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n-        if !res_did.is_local() && !is_no_inline {\n-            crate::visit_lib::lib_embargo_visit_item(self.cx, res_did);\n+        if !ori_res_did.is_local() && !is_no_inline {\n+            crate::visit_lib::lib_embargo_visit_item(self.cx, ori_res_did);\n             return false;\n         }\n \n-        let Some(res_did) = res_did.as_local() else {\n+        let Some(res_did) = ori_res_did.as_local() else {\n             return false;\n         };\n \n-        let is_private = !self\n-            .cx\n-            .cache\n-            .effective_visibilities\n-            .is_directly_public(self.cx.tcx, res_did.to_def_id());\n+        let is_private =\n+            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n@@ -256,20 +169,20 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om, Some(def_id));\n+                    self.visit_item_inner(i, None, Some(def_id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om, Some(def_id));\n+                self.visit_item_inner(it, renamed, Some(def_id));\n                 self.inlining = prev;\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_foreign_item(it, renamed, om);\n+                self.visit_foreign_item_inner(it, renamed);\n                 self.inlining = prev;\n                 true\n             }\n@@ -279,18 +192,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    fn visit_item(\n+    fn visit_item_inner(\n         &mut self,\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n-        om: &mut Module<'tcx>,\n         parent_id: Option<LocalDefId>,\n-    ) {\n+    ) -> bool {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n+        let tcx = self.cx.tcx;\n \n         let def_id = item.owner_id.to_def_id();\n-        let is_pub = self.cx.tcx.visibility(def_id).is_public();\n+        let is_pub = tcx.visibility(def_id).is_public();\n \n         if is_pub {\n             self.store_path(item.owner_id.to_def_id());\n@@ -299,8 +212,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         match item.kind {\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for item in items {\n-                    let item = self.cx.tcx.hir().foreign_item(item.id);\n-                    self.visit_foreign_item(item, None, om);\n+                    let item = tcx.hir().foreign_item(item.id);\n+                    self.visit_foreign_item_inner(item, None);\n                 }\n             }\n             // If we're inlining, skip private items or item reexported as \"_\".\n@@ -315,7 +228,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    let attrs = self.cx.tcx.hir().attrs(item.hir_id());\n+                    let attrs =\n+                        tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(item.owner_id.def_id));\n \n                     // If there was a private module in the current path then don't bother inlining\n                     // anything as it will probably be stripped anyway.\n@@ -333,14 +247,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             res,\n                             ident,\n                             is_glob,\n-                            om,\n                             please_inline,\n                         ) {\n                             continue;\n                         }\n                     }\n \n-                    om.items.push((item, renamed, parent_id))\n+                    self.modules.last_mut().unwrap().items.push((item, renamed, parent_id));\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n@@ -357,14 +270,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 let def_id = item.owner_id.to_def_id();\n                 let is_macro_2_0 = !macro_def.macro_rules;\n-                let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n+                let nonexported = !tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    om.items.push((item, renamed, None));\n+                    self.modules.last_mut().unwrap().items.push((item, renamed, None));\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.owner_id.def_id, m, name, parent_id));\n+                self.enter_mod(item.owner_id.def_id, m, name);\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -375,33 +288,161 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed, parent_id)),\n+            | hir::ItemKind::TraitAlias(..) => {\n+                self.modules.last_mut().unwrap().items.push((item, renamed, parent_id))\n+            }\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if name != kw::Underscore {\n-                    om.items.push((item, renamed, parent_id));\n+                    self.modules.last_mut().unwrap().items.push((item, renamed, parent_id));\n                 }\n             }\n             hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {\n-                    om.items.push((item, None, None));\n+                    self.modules.last_mut().unwrap().items.push((item, None, None));\n                 }\n             }\n         }\n+        true\n     }\n \n-    fn visit_foreign_item(\n+    fn visit_foreign_item_inner(\n         &mut self,\n         item: &'tcx hir::ForeignItem<'_>,\n         renamed: Option<Symbol>,\n-        om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n         if !self.inlining || self.cx.tcx.visibility(item.owner_id).is_public() {\n-            om.foreigns.push((item, renamed));\n+            self.modules.last_mut().unwrap().foreigns.push((item, renamed));\n         }\n     }\n+\n+    pub(crate) fn visit(mut self) -> Module<'tcx> {\n+        let root_module = self.cx.tcx.hir().root_module();\n+        self.visit_mod_contents(CRATE_DEF_ID, root_module);\n+\n+        let mut top_level_module = self.modules.pop().unwrap();\n+\n+        // `#[macro_export] macro_rules!` items are reexported at the top level of the\n+        // crate, regardless of where they're defined. We want to document the\n+        // top level rexport of the macro, not its original definition, since\n+        // the rexport defines the path that a user will actually see. Accordingly,\n+        // we add the rexport as an item here, and then skip over the original\n+        // definition in `visit_item()` below.\n+        //\n+        // We also skip `#[macro_export] macro_rules!` that have already been inserted,\n+        // it can happen if within the same module a `#[macro_export] macro_rules!`\n+        // is declared but also a reexport of itself producing two exports of the same\n+        // macro in the same module.\n+        let mut inserted = FxHashSet::default();\n+        for export in self.cx.tcx.module_reexports(CRATE_DEF_ID).unwrap_or(&[]) {\n+            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n+                if let Some(local_def_id) = def_id.as_local() {\n+                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n+                        if inserted.insert(def_id) {\n+                            let item = self.cx.tcx.hir().expect_item(local_def_id);\n+                            top_level_module.items.push((item, None, None));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.cx.cache.hidden_cfg = self\n+            .cx\n+            .tcx\n+            .hir()\n+            .attrs(CRATE_HIR_ID)\n+            .iter()\n+            .filter(|attr| attr.has_name(sym::doc))\n+            .flat_map(|attr| attr.meta_item_list().into_iter().flatten())\n+            .filter(|attr| attr.has_name(sym::cfg_hide))\n+            .flat_map(|attr| {\n+                attr.meta_item_list()\n+                    .unwrap_or(&[])\n+                    .iter()\n+                    .filter_map(|attr| {\n+                        Cfg::parse(attr.meta_item()?)\n+                            .map_err(|e| self.cx.sess().diagnostic().span_err(e.span, e.msg))\n+                            .ok()\n+                    })\n+                    .collect::<Vec<_>>()\n+            })\n+            .chain(\n+                [Cfg::Cfg(sym::test, None), Cfg::Cfg(sym::doc, None), Cfg::Cfg(sym::doctest, None)]\n+                    .into_iter(),\n+            )\n+            .collect();\n+\n+        self.cx.cache.exact_paths = self.exact_paths;\n+        top_level_module\n+    }\n+\n+    /// This method will create a new module and push it onto the \"modules stack\" then call\n+    /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n+    /// add into the list of modules of the current module.\n+    fn enter_mod(&mut self, id: LocalDefId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n+        self.modules.push(Module::new(name, id, m.spans.inner_span));\n+\n+        self.visit_mod_contents(id, m);\n+\n+        let last = self.modules.pop().unwrap();\n+        self.modules.last_mut().unwrap().mods.push(last);\n+    }\n+\n+    /// This method will go through the given module items in two passes:\n+    /// 1. The items which are not glob imports/reexports.\n+    /// 2. The glob imports/reexports.\n+    fn visit_mod_contents(&mut self, def_id: LocalDefId, m: &'tcx hir::Mod<'tcx>) {\n+        debug!(\"Going through module {:?}\", m);\n+        // Keep track of if there were any private modules in the path.\n+        let orig_inside_public_path = self.inside_public_path;\n+        self.inside_public_path &= self.cx.tcx.local_visibility(def_id).is_public();\n+\n+        // Reimplementation of `walk_mod`:\n+        for &i in m.item_ids {\n+            let item = self.cx.tcx.hir().item(i);\n+            if !matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n+                self.visit_item(item);\n+            }\n+        }\n+        for &i in m.item_ids {\n+            let item = self.cx.tcx.hir().item(i);\n+            // To match the way import precedence works, visit glob imports last.\n+            // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n+            // imported items appear last, then they'll be the ones that get discarded.\n+            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n+                self.visit_item(item);\n+            }\n+        }\n+        self.inside_public_path = orig_inside_public_path;\n+    }\n+}\n+\n+// We need to implement this visitor so it'll go everywhere and retrieve items we're interested in\n+// such as impl blocks in const blocks.\n+impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.map\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n+        let parent_id = if self.modules.len() > 1 {\n+            Some(self.modules[self.modules.len() - 2].def_id)\n+        } else {\n+            None\n+        };\n+        if self.visit_item_inner(i, None, parent_id) {\n+            walk_item(self, i);\n+        }\n+    }\n+\n+    fn visit_mod(&mut self, _: &hir::Mod<'tcx>, _: Span, _: hir::HirId) {\n+        // handled in `visit_item_inner`\n+    }\n }"}]}