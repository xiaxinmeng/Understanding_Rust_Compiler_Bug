{"sha": "5018181c79a6fe37913fd931005ad2a63c85be7b", "node_id": "C_kwDOAAsO6NoAKDUwMTgxODFjNzlhNmZlMzc5MTNmZDkzMTAwNWFkMmE2M2M4NWJlN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-01T17:33:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-01T17:33:42Z"}, "message": "Auto merge of #98767 - Dylan-DPC:rollup-j1gq5sr, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #97488 (Suggest blanket impl to the local traits)\n - #98585 (Make `ThinBox<T>` covariant in `T`)\n - #98644 (fix ICE with -Wrust-2021-incompatible-closure-captures)\n - #98739 (fix grammar in useless doc comment lint)\n - #98741 (Many small deriving cleanups)\n - #98756 (Use const instead of function and make it private)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "df5eaa91d921af448f7bcccb3f4c4641090dd6bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df5eaa91d921af448f7bcccb3f4c4641090dd6bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5018181c79a6fe37913fd931005ad2a63c85be7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5018181c79a6fe37913fd931005ad2a63c85be7b", "html_url": "https://github.com/rust-lang/rust/commit/5018181c79a6fe37913fd931005ad2a63c85be7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5018181c79a6fe37913fd931005ad2a63c85be7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9775fe17893cba641a071de7e0a7c8f478c41b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9775fe17893cba641a071de7e0a7c8f478c41b", "html_url": "https://github.com/rust-lang/rust/commit/5b9775fe17893cba641a071de7e0a7c8f478c41b"}, {"sha": "6404620f18da68a07299d6fe02d886141b9d0347", "url": "https://api.github.com/repos/rust-lang/rust/commits/6404620f18da68a07299d6fe02d886141b9d0347", "html_url": "https://github.com/rust-lang/rust/commit/6404620f18da68a07299d6fe02d886141b9d0347"}], "stats": {"total": 876, "additions": 545, "deletions": 331}, "files": [{"sha": "5ef68c6aeaa59956862f803c7094e31a7d0e0430", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -19,7 +19,6 @@ pub fn expand_deriving_copy(\n         path: path_std!(marker::Copy),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: true,\n         methods: Vec::new(),\n         associated_types: Vec::new(),"}, {"sha": "1c507678489fec998af4969df78e2e464acb2a9e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -15,23 +15,22 @@ pub fn expand_deriving_clone(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    // check if we can use a short form\n+    // The simple form is `fn clone(&self) -> Self { *self }`, possibly with\n+    // some additional `AssertParamIsClone` assertions.\n     //\n-    // the short form is `fn clone(&self) -> Self { *self }`\n-    //\n-    // we can use the short form if:\n-    // - the item is Copy (unfortunately, all we can check is whether it's also deriving Copy)\n-    // - there are no generic parameters (after specialization this limitation can be removed)\n-    //      if we used the short form with generics, we'd have to bound the generics with\n-    //      Clone + Copy, and then there'd be no Clone impl at all if the user fills in something\n-    //      that is Clone but not Copy. and until specialization we can't write both impls.\n-    // - the item is a union with Copy fields\n-    //      Unions with generic parameters still can derive Clone because they require Copy\n-    //      for deriving, Clone alone is not enough.\n-    //      Wherever Clone is implemented for fields is irrelevant so we don't assert it.\n+    // We can use the simple form if either of the following are true.\n+    // - The type derives Copy and there are no generic parameters.  (If we\n+    //   used the simple form with generics, we'd have to bound the generics\n+    //   with Clone + Copy, and then there'd be no Clone impl at all if the\n+    //   user fills in something that is Clone but not Copy. After\n+    //   specialization we can remove this no-generics limitation.)\n+    // - The item is a union. (Unions with generic parameters still can derive\n+    //   Clone because they require Copy for deriving, Clone alone is not\n+    //   enough. Whether Clone is implemented for fields is irrelevant so we\n+    //   don't assert it.)\n     let bounds;\n     let substructure;\n-    let is_shallow;\n+    let is_simple;\n     match *item {\n         Annotatable::Item(ref annitem) => match annitem.kind {\n             ItemKind::Struct(_, Generics { ref params, .. })\n@@ -44,30 +43,25 @@ pub fn expand_deriving_clone(\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. }))\n                 {\n                     bounds = vec![];\n-                    is_shallow = true;\n+                    is_simple = true;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone_shallow(\"Clone\", c, s, sub, false)\n+                        cs_clone_simple(\"Clone\", c, s, sub, false)\n                     }));\n                 } else {\n                     bounds = vec![];\n-                    is_shallow = false;\n+                    is_simple = false;\n                     substructure =\n                         combine_substructure(Box::new(|c, s, sub| cs_clone(\"Clone\", c, s, sub)));\n                 }\n             }\n             ItemKind::Union(..) => {\n-                bounds = vec![Literal(path_std!(marker::Copy))];\n-                is_shallow = true;\n+                bounds = vec![Path(path_std!(marker::Copy))];\n+                is_simple = true;\n                 substructure = combine_substructure(Box::new(|c, s, sub| {\n-                    cs_clone_shallow(\"Clone\", c, s, sub, true)\n+                    cs_clone_simple(\"Clone\", c, s, sub, true)\n                 }));\n             }\n-            _ => {\n-                bounds = vec![];\n-                is_shallow = false;\n-                substructure =\n-                    combine_substructure(Box::new(|c, s, sub| cs_clone(\"Clone\", c, s, sub)));\n-            }\n+            _ => cx.span_bug(span, \"`#[derive(Clone)]` on wrong item kind\"),\n         },\n \n         _ => cx.span_bug(span, \"`#[derive(Clone)]` on trait item or impl item\"),\n@@ -81,26 +75,24 @@ pub fn expand_deriving_clone(\n         path: path_std!(clone::Clone),\n         additional_bounds: bounds,\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::clone,\n             generics: Bounds::empty(),\n-            explicit_self: borrowed_explicit_self(),\n+            explicit_self: true,\n             args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            is_unsafe: false,\n             unify_fieldless_variants: false,\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand_ext(cx, mitem, item, push, is_shallow)\n+    trait_def.expand_ext(cx, mitem, item, push, is_simple)\n }\n \n-fn cs_clone_shallow(\n+fn cs_clone_simple(\n     name: &str,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n@@ -143,7 +135,7 @@ fn cs_clone_shallow(\n             }\n             _ => cx.span_bug(\n                 trait_span,\n-                &format!(\"unexpected substructure in shallow `derive({})`\", name),\n+                &format!(\"unexpected substructure in simple `derive({})`\", name),\n             ),\n         }\n     }"}, {"sha": "cb2ad283a1971208cc165a1dd77971f4d5e8e962", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -27,16 +27,14 @@ pub fn expand_deriving_eq(\n         path: path_std!(cmp::Eq),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::assert_receiver_is_total_eq,\n             generics: Bounds::empty(),\n-            explicit_self: borrowed_explicit_self(),\n+            explicit_self: true,\n             args: vec![],\n-            ret_ty: nil_ty(),\n+            ret_ty: Unit,\n             attributes: attrs,\n-            is_unsafe: false,\n             unify_fieldless_variants: true,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 cs_total_eq_assert(a, b, c)"}, {"sha": "c7850cd4b4cf6f4226153a8cfbe7edef31ddbf0f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -23,16 +23,14 @@ pub fn expand_deriving_ord(\n         path: path_std!(cmp::Ord),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::cmp,\n             generics: Bounds::empty(),\n-            explicit_self: borrowed_explicit_self(),\n-            args: vec![(borrowed_self(), sym::other)],\n-            ret_ty: Literal(path_std!(cmp::Ordering)),\n+            explicit_self: true,\n+            args: vec![(self_ref(), sym::other)],\n+            ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n-            is_unsafe: false,\n             unify_fieldless_variants: true,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n@@ -99,8 +97,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         cx.expr_path(equals_path.clone()),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n+        Box::new(|cx, span, tag_tuple| {\n+            if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n             } else {\n                 ordering_collapsed(cx, span, tag_tuple)"}, {"sha": "ca5ca29eb826a6f02c3244049a79d734c28b0ccb", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -48,7 +48,7 @@ pub fn expand_deriving_partial_eq(\n                     None => cx.expr_bool(span, base),\n                 }\n             },\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, !base)),\n+            Box::new(|cx, span, _| cx.expr_bool(span, !base)),\n             cx,\n             span,\n             substr,\n@@ -69,11 +69,10 @@ pub fn expand_deriving_partial_eq(\n             MethodDef {\n                 name: $name,\n                 generics: Bounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), sym::other)],\n-                ret_ty: Literal(path_local!(bool)),\n+                explicit_self: true,\n+                args: vec![(self_ref(), sym::other)],\n+                ret_ty: Path(path_local!(bool)),\n                 attributes: attrs,\n-                is_unsafe: false,\n                 unify_fieldless_variants: true,\n                 combine_substructure: combine_substructure(Box::new(|a, b, c| $f(a, b, c))),\n             }\n@@ -102,7 +101,6 @@ pub fn expand_deriving_partial_eq(\n         path: path_std!(cmp::PartialEq),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods,\n         associated_types: Vec::new(),"}, {"sha": "07db82fee935bb9d48537bf4529162567ac5b07f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -15,25 +15,20 @@ pub fn expand_deriving_partial_ord(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let ordering_ty = Literal(path_std!(cmp::Ordering));\n-    let ret_ty = Literal(Path::new_(\n-        pathvec_std!(option::Option),\n-        None,\n-        vec![Box::new(ordering_ty)],\n-        PathKind::Std,\n-    ));\n+    let ordering_ty = Path(path_std!(cmp::Ordering));\n+    let ret_ty =\n+        Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n     let inline = cx.meta_word(span, sym::inline);\n     let attrs = vec![cx.attribute(inline)];\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n-        explicit_self: borrowed_explicit_self(),\n-        args: vec![(borrowed_self(), sym::other)],\n+        explicit_self: true,\n+        args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n-        is_unsafe: false,\n         unify_fieldless_variants: true,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n@@ -46,7 +41,6 @@ pub fn expand_deriving_partial_ord(\n         path: path_std!(cmp::PartialOrd),\n         additional_bounds: vec![],\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![partial_cmp_def],\n         associated_types: Vec::new(),\n@@ -102,8 +96,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         equals_expr,\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n+        Box::new(|cx, span, tag_tuple| {\n+            if tag_tuple.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             } else {\n                 let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));"}, {"sha": "1411c60c0bfd5e22a13c1bbb7874ce27c49e34bd", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -16,25 +16,22 @@ pub fn expand_deriving_debug(\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     // &mut ::std::fmt::Formatter\n-    let fmtr =\n-        Ptr(Box::new(Literal(path_std!(fmt::Formatter))), Borrowed(None, ast::Mutability::Mut));\n+    let fmtr = Ref(Box::new(Path(path_std!(fmt::Formatter))), ast::Mutability::Mut);\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n         path: path_std!(fmt::Debug),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::fmt,\n             generics: Bounds::empty(),\n-            explicit_self: borrowed_explicit_self(),\n+            explicit_self: true,\n             args: vec![(fmtr, sym::f)],\n-            ret_ty: Literal(path_std!(fmt::Result)),\n+            ret_ty: Path(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n-            is_unsafe: false,\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)\n@@ -64,8 +61,6 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     let (is_struct, args_per_field) = match vdata {\n         ast::VariantData::Unit(..) => {\n             // Special fast path for unit variants.\n-            //let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-            //return cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n             assert!(fields.is_empty());\n             (false, 0)\n         }"}, {"sha": "16154fb4d031b160bc1d6bcd75f9a45cbcd7b7a0", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -23,40 +23,29 @@ pub fn expand_deriving_rustc_decodable(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, sym::Decodable], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Decodable], vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::decode,\n             generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, sym::Decoder], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Decoder], vec![], PathKind::Global)],\n                 )],\n             },\n-            explicit_self: None,\n-            args: vec![(\n-                Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                sym::d,\n-            )],\n-            ret_ty: Literal(Path::new_(\n+            explicit_self: false,\n+            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::d)],\n+            ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n-                None,\n                 vec![\n                     Box::new(Self_),\n-                    Box::new(Literal(Path::new_(\n-                        vec![typaram, sym::Error],\n-                        None,\n-                        vec![],\n-                        PathKind::Local,\n-                    ))),\n+                    Box::new(Path(Path::new_(vec![typaram, sym::Error], vec![], PathKind::Local))),\n                 ],\n                 PathKind::Std,\n             )),\n             attributes: Vec::new(),\n-            is_unsafe: false,\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 decodable_substructure(a, b, c, krate)"}, {"sha": "d41b25343b08e702c081d01c2a77bdf23b3deafc", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -30,16 +30,14 @@ pub fn expand_deriving_default(\n         path: Path::new(vec![kw::Default, sym::Default]),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: kw::Default,\n             generics: Bounds::empty(),\n-            explicit_self: None,\n+            explicit_self: false,\n             args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            is_unsafe: false,\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|cx, trait_span, substr| {\n                 match substr.fields {"}, {"sha": "7dc0584618d664401ca9f9271ebe54efff41a50d", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -108,40 +108,29 @@ pub fn expand_deriving_rustc_encodable(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, sym::Encodable], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Encodable], vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::encode,\n             generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, sym::Encoder], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Encoder], vec![], PathKind::Global)],\n                 )],\n             },\n-            explicit_self: borrowed_explicit_self(),\n-            args: vec![(\n-                Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                sym::s,\n-            )],\n-            ret_ty: Literal(Path::new_(\n+            explicit_self: true,\n+            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::s)],\n+            ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n-                None,\n                 vec![\n-                    Box::new(Tuple(Vec::new())),\n-                    Box::new(Literal(Path::new_(\n-                        vec![typaram, sym::Error],\n-                        None,\n-                        vec![],\n-                        PathKind::Local,\n-                    ))),\n+                    Box::new(Unit),\n+                    Box::new(Path(Path::new_(vec![typaram, sym::Error], vec![], PathKind::Local))),\n                 ],\n                 PathKind::Std,\n             )),\n             attributes: Vec::new(),\n-            is_unsafe: false,\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 encodable_substructure(a, b, c, krate)"}, {"sha": "ff431c8de5d3f01ec141473ff8d482e151102335", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 36, "deletions": 95, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -146,8 +146,6 @@\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     vec![<ident of self>, <ident of __arg_1>],\n-//!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n //!     &[<ident for self index value>, <ident of __arg_1 index value>])\n //! ```\n //!\n@@ -190,7 +188,7 @@ use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use ty::{Bounds, Path, Ptr, PtrTy, Self_, Ty};\n+use ty::{Bounds, Path, Ref, Self_, Ty};\n \n use crate::deriving;\n \n@@ -212,9 +210,6 @@ pub struct TraitDef<'a> {\n     /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n     pub generics: Bounds,\n \n-    /// Is it an `unsafe` trait?\n-    pub is_unsafe: bool,\n-\n     /// Can this trait be derived for unions?\n     pub supports_unions: bool,\n \n@@ -229,10 +224,8 @@ pub struct MethodDef<'a> {\n     /// List of generics, e.g., `R: rand::Rng`\n     pub generics: Bounds,\n \n-    /// Whether there is a self argument (outer Option) i.e., whether\n-    /// this is a static function, and whether it is a pointer (inner\n-    /// Option)\n-    pub explicit_self: Option<Option<PtrTy>>,\n+    /// Is there is a `&self` argument? If not, it is a static function.\n+    pub explicit_self: bool,\n \n     /// Arguments other than the self argument\n     pub args: Vec<(Ty, Symbol)>,\n@@ -242,9 +235,6 @@ pub struct MethodDef<'a> {\n \n     pub attributes: Vec<ast::Attribute>,\n \n-    // Is it an `unsafe fn`?\n-    pub is_unsafe: bool,\n-\n     /// Can we combine fieldless variants for enums into a single match arm?\n     pub unify_fieldless_variants: bool,\n \n@@ -255,14 +245,7 @@ pub struct MethodDef<'a> {\n pub struct Substructure<'a> {\n     /// ident of self\n     pub type_ident: Ident,\n-    /// ident of the method\n-    pub method_ident: Ident,\n-    /// dereferenced access to any [`Self_`] or [`Ptr(Self_, _)`][ptr] arguments\n-    ///\n-    /// [`Self_`]: ty::Ty::Self_\n-    /// [ptr]: ty::Ty::Ptr\n-    pub self_args: &'a [P<Expr>],\n-    /// verbatim access to any other arguments\n+    /// verbatim access to any non-self arguments\n     pub nonself_args: &'a [P<Expr>],\n     pub fields: &'a SubstructureFields<'a>,\n }\n@@ -299,13 +282,10 @@ pub enum SubstructureFields<'a> {\n     /// variant.\n     EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n \n-    /// Non-matching variants of the enum, but with all state hidden from\n-    /// the consequent code. The first component holds `Ident`s for all of\n-    /// the `Self` arguments; the second component is a slice of all of the\n-    /// variants for the enum itself, and the third component is a list of\n-    /// `Ident`s bound to the variant index values for each of the actual\n-    /// input `Self` arguments.\n-    EnumNonMatchingCollapsed(Vec<Ident>, &'a [ast::Variant], &'a [Ident]),\n+    /// Non-matching variants of the enum, but with all state hidden from the\n+    /// consequent code. The field is a list of `Ident`s bound to the variant\n+    /// index values for each of the actual input `Self` arguments.\n+    EnumNonMatchingCollapsed(&'a [Ident]),\n \n     /// A static method where `Self` is a struct.\n     StaticStruct(&'a ast::VariantData, StaticFields),\n@@ -318,13 +298,10 @@ pub enum SubstructureFields<'a> {\n pub type CombineSubstructureFunc<'a> =\n     Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> P<Expr> + 'a>;\n \n-/// Deal with non-matching enum variants. The tuple is a list of\n-/// identifiers (one for each `Self` argument, which could be any of the\n-/// variants since they have been collapsed together) and the identifiers\n-/// holding the variant index value for each of the `Self` arguments. The\n-/// last argument is all the non-`Self` args of the method being derived.\n+/// Deal with non-matching enum variants. The slice is the identifiers holding\n+/// the variant index value for each of the `Self` arguments.\n pub type EnumNonMatchCollapsedFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, (&[Ident], &[Ident]), &[P<Expr>]) -> P<Expr> + 'a>;\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &[Ident]) -> P<Expr> + 'a>;\n \n pub fn combine_substructure(\n     f: CombineSubstructureFunc<'_>,\n@@ -727,14 +704,12 @@ impl<'a> TraitDef<'a> {\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());\n \n-        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(self.span) } else { ast::Unsafe::No };\n-\n         cx.item(\n             self.span,\n             Ident::empty(),\n             a,\n             ast::ItemKind::Impl(Box::new(ast::Impl {\n-                unsafety,\n+                unsafety: ast::Unsafe::No,\n                 polarity: ast::ImplPolarity::Positive,\n                 defaultness: ast::Defaultness::Final,\n                 constness: ast::Const::No,\n@@ -771,7 +746,6 @@ impl<'a> TraitDef<'a> {\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &self_args,\n                         &nonself_args,\n                     )\n                 } else {\n@@ -820,7 +794,6 @@ impl<'a> TraitDef<'a> {\n                         self,\n                         enum_def,\n                         type_ident,\n-                        &self_args,\n                         &nonself_args,\n                     )\n                 } else {\n@@ -848,18 +821,11 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n-        self_args: &[P<Expr>],\n         nonself_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n     ) -> P<Expr> {\n         let span = trait_.span;\n-        let substructure = Substructure {\n-            type_ident,\n-            method_ident: Ident::new(self.name, span),\n-            self_args,\n-            nonself_args,\n-            fields,\n-        };\n+        let substructure = Substructure { type_ident, nonself_args, fields };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n         f(cx, span, &substructure)\n@@ -876,7 +842,7 @@ impl<'a> MethodDef<'a> {\n     }\n \n     fn is_static(&self) -> bool {\n-        self.explicit_self.is_none()\n+        !self.explicit_self\n     }\n \n     fn split_self_nonself_args(\n@@ -889,17 +855,15 @@ impl<'a> MethodDef<'a> {\n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n         let mut arg_tys = Vec::new();\n-        let mut nonstatic = false;\n         let span = trait_.span;\n \n-        let ast_explicit_self = self.explicit_self.as_ref().map(|self_ptr| {\n-            let (self_expr, explicit_self) = ty::get_explicit_self(cx, span, self_ptr);\n-\n+        let ast_explicit_self = if self.explicit_self {\n+            let (self_expr, explicit_self) = ty::get_explicit_self(cx, span);\n             self_args.push(self_expr);\n-            nonstatic = true;\n-\n-            explicit_self\n-        });\n+            Some(explicit_self)\n+        } else {\n+            None\n+        };\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n@@ -911,10 +875,10 @@ impl<'a> MethodDef<'a> {\n             match *ty {\n                 // for static methods, just treat any Self\n                 // arguments as a normal arg\n-                Self_ if nonstatic => {\n+                Self_ if !self.is_static() => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(ref ty, _) if matches!(**ty, Self_) && nonstatic => {\n+                Ref(ref ty, _) if matches!(**ty, Self_) && !self.is_static() => {\n                     self_args.push(cx.expr_deref(span, arg_expr))\n                 }\n                 _ => {\n@@ -955,15 +919,9 @@ impl<'a> MethodDef<'a> {\n         let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n         let body_block = cx.block_expr(body);\n \n-        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(span) } else { ast::Unsafe::No };\n-\n         let trait_lo_sp = span.shrink_to_lo();\n \n-        let sig = ast::FnSig {\n-            header: ast::FnHeader { unsafety, ext: ast::Extern::None, ..ast::FnHeader::default() },\n-            decl: fn_decl,\n-            span,\n-        };\n+        let sig = ast::FnSig { header: ast::FnHeader::default(), decl: fn_decl, span };\n         let defaultness = ast::Defaultness::Final;\n \n         // Create the method.\n@@ -1083,7 +1041,6 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            self_args,\n             nonself_args,\n             &Struct(struct_def, fields),\n         );\n@@ -1104,7 +1061,6 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         struct_def: &VariantData,\n         type_ident: Ident,\n-        self_args: &[P<Expr>],\n         nonself_args: &[P<Expr>],\n     ) -> P<Expr> {\n         let summary = trait_.summarise_struct(cx, struct_def);\n@@ -1113,7 +1069,6 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            self_args,\n             nonself_args,\n             &StaticStruct(struct_def, summary),\n         )\n@@ -1184,11 +1139,6 @@ impl<'a> MethodDef<'a> {\n             )\n             .collect::<Vec<String>>();\n \n-        let self_arg_idents = self_arg_names\n-            .iter()\n-            .map(|name| Ident::from_str_and_span(name, span))\n-            .collect::<Vec<Ident>>();\n-\n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n         // value corresponding to its discriminant.\n@@ -1203,8 +1153,7 @@ impl<'a> MethodDef<'a> {\n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n-        let catch_all_substructure =\n-            EnumNonMatchingCollapsed(self_arg_idents, &variants, &vi_idents);\n+        let catch_all_substructure = EnumNonMatchingCollapsed(&vi_idents);\n \n         let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n \n@@ -1303,7 +1252,6 @@ impl<'a> MethodDef<'a> {\n                     cx,\n                     trait_,\n                     type_ident,\n-                    &self_args[..],\n                     nonself_args,\n                     &substructure,\n                 );\n@@ -1322,7 +1270,6 @@ impl<'a> MethodDef<'a> {\n                     cx,\n                     trait_,\n                     type_ident,\n-                    &self_args[..],\n                     nonself_args,\n                     &substructure,\n                 ))\n@@ -1393,7 +1340,6 @@ impl<'a> MethodDef<'a> {\n                 cx,\n                 trait_,\n                 type_ident,\n-                &self_args[..],\n                 nonself_args,\n                 &catch_all_substructure,\n             );\n@@ -1491,7 +1437,6 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         enum_def: &EnumDef,\n         type_ident: Ident,\n-        self_args: &[P<Expr>],\n         nonself_args: &[P<Expr>],\n     ) -> P<Expr> {\n         let summary = enum_def\n@@ -1507,7 +1452,6 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            self_args,\n             nonself_args,\n             &StaticEnum(enum_def, summary),\n         )\n@@ -1628,7 +1572,7 @@ impl<'a> TraitDef<'a> {\n \n // helpful premade recipes\n \n-pub fn cs_fold_fields<'a, F>(\n+fn cs_fold_fields<'a, F>(\n     use_foldl: bool,\n     mut f: F,\n     base: P<Expr>,\n@@ -1650,21 +1594,19 @@ where\n     }\n }\n \n-pub fn cs_fold_enumnonmatch(\n+fn cs_fold_enumnonmatch(\n     mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substructure: &Substructure<'_>,\n ) -> P<Expr> {\n     match *substructure.fields {\n-        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n-            enum_nonmatch_f(cx, trait_span, (&all_args[..], tuple), substructure.nonself_args)\n-        }\n+        EnumNonMatchingCollapsed(tuple) => enum_nonmatch_f(cx, trait_span, tuple),\n         _ => cx.span_bug(trait_span, \"cs_fold_enumnonmatch expected an EnumNonMatchingCollapsed\"),\n     }\n }\n \n-pub fn cs_fold_static(cx: &mut ExtCtxt<'_>, trait_span: Span) -> P<Expr> {\n+fn cs_fold_static(cx: &mut ExtCtxt<'_>, trait_span: Span) -> P<Expr> {\n     cx.span_bug(trait_span, \"static function in `derive`\")\n }\n \n@@ -1717,22 +1659,21 @@ where\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n-            let (base, all_fields) = match (all_fields.is_empty(), use_foldl) {\n+            let (base, rest) = match (all_fields.is_empty(), use_foldl) {\n                 (false, true) => {\n-                    let field = &all_fields[0];\n-                    let args = (field.span, field.self_.clone(), &field.other[..]);\n-                    (b(cx, Some(args)), &all_fields[1..])\n+                    let (first, rest) = all_fields.split_first().unwrap();\n+                    let args = (first.span, first.self_.clone(), &first.other[..]);\n+                    (b(cx, Some(args)), rest)\n                 }\n                 (false, false) => {\n-                    let idx = all_fields.len() - 1;\n-                    let field = &all_fields[idx];\n-                    let args = (field.span, field.self_.clone(), &field.other[..]);\n-                    (b(cx, Some(args)), &all_fields[..idx])\n+                    let (last, rest) = all_fields.split_last().unwrap();\n+                    let args = (last.span, last.self_.clone(), &last.other[..]);\n+                    (b(cx, Some(args)), rest)\n                 }\n                 (true, _) => (b(cx, None), &all_fields[..]),\n             };\n \n-            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n+            cs_fold_fields(use_foldl, f, base, cx, rest)\n         }\n         EnumNonMatchingCollapsed(..) => {\n             cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)"}, {"sha": "4b20d87629d96fcccd47af72b56a1efa9f3607d2", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 26, "deletions": 94, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -1,7 +1,6 @@\n //! A mini version of ast::Ty, which is easier to use, and features an explicit `Self` type to use\n //! when specifying impls to be derived.\n \n-pub use PtrTy::*;\n pub use Ty::*;\n \n use rustc_ast::ptr::P;\n@@ -11,22 +10,11 @@ use rustc_span::source_map::{respan, DUMMY_SP};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n \n-/// The types of pointers\n-#[derive(Clone)]\n-pub enum PtrTy {\n-    /// &'lifetime mut\n-    Borrowed(Option<Ident>, ast::Mutability),\n-    /// *mut\n-    #[allow(dead_code)]\n-    Raw(ast::Mutability),\n-}\n-\n /// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n-/// for type parameters and a lifetime.\n+/// for type parameters.\n #[derive(Clone)]\n pub struct Path {\n     path: Vec<Symbol>,\n-    lifetime: Option<Ident>,\n     params: Vec<Box<Ty>>,\n     kind: PathKind,\n }\n@@ -40,18 +28,13 @@ pub enum PathKind {\n \n impl Path {\n     pub fn new(path: Vec<Symbol>) -> Path {\n-        Path::new_(path, None, Vec::new(), PathKind::Std)\n+        Path::new_(path, Vec::new(), PathKind::Std)\n     }\n     pub fn new_local(path: Symbol) -> Path {\n-        Path::new_(vec![path], None, Vec::new(), PathKind::Local)\n+        Path::new_(vec![path], Vec::new(), PathKind::Local)\n     }\n-    pub fn new_(\n-        path: Vec<Symbol>,\n-        lifetime: Option<Ident>,\n-        params: Vec<Box<Ty>>,\n-        kind: PathKind,\n-    ) -> Path {\n-        Path { path, lifetime, params, kind }\n+    pub fn new_(path: Vec<Symbol>, params: Vec<Box<Ty>>, kind: PathKind) -> Path {\n+        Path { path, params, kind }\n     }\n \n     pub fn to_ty(\n@@ -71,10 +54,8 @@ impl Path {\n         self_generics: &Generics,\n     ) -> ast::Path {\n         let mut idents = self.path.iter().map(|s| Ident::new(*s, span)).collect();\n-        let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys = self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics));\n-        let params =\n-            lt.into_iter().map(GenericArg::Lifetime).chain(tys.map(GenericArg::Type)).collect();\n+        let params = tys.map(GenericArg::Type).collect();\n \n         match self.kind {\n             PathKind::Global => cx.path_all(span, true, idents, params),\n@@ -92,40 +73,17 @@ impl Path {\n #[derive(Clone)]\n pub enum Ty {\n     Self_,\n-    /// &/Box/ Ty\n-    Ptr(Box<Ty>, PtrTy),\n+    /// A reference.\n+    Ref(Box<Ty>, ast::Mutability),\n     /// `mod::mod::Type<[lifetime], [Params...]>`, including a plain type\n     /// parameter, and things like `i32`\n-    Literal(Path),\n-    /// includes unit\n-    Tuple(Vec<Ty>),\n-}\n-\n-pub fn borrowed_ptrty() -> PtrTy {\n-    Borrowed(None, ast::Mutability::Not)\n-}\n-pub fn borrowed(ty: Box<Ty>) -> Ty {\n-    Ptr(ty, borrowed_ptrty())\n-}\n-\n-pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n-    Some(Some(borrowed_ptrty()))\n-}\n-\n-pub fn borrowed_self() -> Ty {\n-    borrowed(Box::new(Self_))\n+    Path(Path),\n+    /// For () return types.\n+    Unit,\n }\n \n-pub fn nil_ty() -> Ty {\n-    Tuple(Vec::new())\n-}\n-\n-fn mk_lifetime(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Option<ast::Lifetime> {\n-    lt.map(|ident| cx.lifetime(span, ident))\n-}\n-\n-fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Vec<ast::Lifetime> {\n-    mk_lifetime(cx, span, lt).into_iter().collect()\n+pub fn self_ref() -> Ty {\n+    Ref(Box::new(Self_), ast::Mutability::Not)\n }\n \n impl Ty {\n@@ -136,23 +94,15 @@ impl Ty {\n         self_ty: Ident,\n         self_generics: &Generics,\n     ) -> P<ast::Ty> {\n-        match *self {\n-            Ptr(ref ty, ref ptr) => {\n+        match self {\n+            Ref(ty, mutbl) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n-                match *ptr {\n-                    Borrowed(ref lt, mutbl) => {\n-                        let lt = mk_lifetime(cx, span, lt);\n-                        cx.ty_rptr(span, raw_ty, lt, mutbl)\n-                    }\n-                    Raw(mutbl) => cx.ty_ptr(span, raw_ty, mutbl),\n-                }\n+                cx.ty_rptr(span, raw_ty, None, *mutbl)\n             }\n-            Literal(ref p) => p.to_ty(cx, span, self_ty, self_generics),\n+            Path(p) => p.to_ty(cx, span, self_ty, self_generics),\n             Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n-            Tuple(ref fields) => {\n-                let ty = ast::TyKind::Tup(\n-                    fields.iter().map(|f| f.to_ty(cx, span, self_ty, self_generics)).collect(),\n-                );\n+            Unit => {\n+                let ty = ast::TyKind::Tup(vec![]);\n                 cx.ty(span, ty)\n             }\n         }\n@@ -185,9 +135,9 @@ impl Ty {\n \n                 cx.path_all(span, false, vec![self_ty], params)\n             }\n-            Literal(ref p) => p.to_path(cx, span, self_ty, generics),\n-            Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),\n-            Tuple(..) => cx.span_bug(span, \"tuple in a path in generic `derive`\"),\n+            Path(ref p) => p.to_path(cx, span, self_ty, generics),\n+            Ref(..) => cx.span_bug(span, \"ref in a path in generic `derive`\"),\n+            Unit => cx.span_bug(span, \"unit in a path in generic `derive`\"),\n         }\n     }\n }\n@@ -245,28 +195,10 @@ impl Bounds {\n     }\n }\n \n-pub fn get_explicit_self(\n-    cx: &ExtCtxt<'_>,\n-    span: Span,\n-    self_ptr: &Option<PtrTy>,\n-) -> (P<Expr>, ast::ExplicitSelf) {\n+pub fn get_explicit_self(cx: &ExtCtxt<'_>, span: Span) -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n-    match *self_ptr {\n-        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Not))),\n-        Some(ref ptr) => {\n-            let self_ty = respan(\n-                span,\n-                match *ptr {\n-                    Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| cx.lifetime(span, s));\n-                        SelfKind::Region(lt, mutbl)\n-                    }\n-                    Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\"),\n-                },\n-            );\n-            let self_expr = cx.expr_deref(span, self_path);\n-            (self_expr, self_ty)\n-        }\n-    }\n+    let self_ty = respan(span, SelfKind::Region(None, ast::Mutability::Not));\n+    let self_expr = cx.expr_deref(span, self_path);\n+    (self_expr, self_ty)\n }"}, {"sha": "9790449c4b331735a902344bbcb5443ef18e3690", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -15,7 +15,7 @@ pub fn expand_deriving_hash(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let path = Path::new_(pathvec_std!(hash::Hash), None, vec![], PathKind::Std);\n+    let path = Path::new_(pathvec_std!(hash::Hash), vec![], PathKind::Std);\n \n     let typaram = sym::__H;\n \n@@ -26,16 +26,14 @@ pub fn expand_deriving_hash(\n         path,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n-        is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::hash,\n             generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n-            explicit_self: borrowed_explicit_self(),\n-            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), sym::state)],\n-            ret_ty: nil_ty(),\n+            explicit_self: true,\n+            args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n+            ret_ty: Unit,\n             attributes: vec![],\n-            is_unsafe: false,\n             unify_fieldless_variants: true,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 hash_substructure(a, b, c)"}, {"sha": "0dac4f8978e0d190b45773dc3aa069b9c0bb83e8", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -19,11 +19,9 @@ use rustc_target::abi::{self, Abi};\n use std::borrow::Cow;\n use std::convert::TryInto;\n \n-pub fn note_on_undefined_behavior_error() -> &'static str {\n-    \"The rules on what exactly is undefined behavior aren't clear, \\\n+const NOTE_ON_UNDEFINED_BEHAVIOR_ERROR: &str = \"The rules on what exactly is undefined behavior aren't clear, \\\n      so this check might be overzealous. Please open an issue on the rustc \\\n-     repository if you believe it should not be considered undefined behavior.\"\n-}\n+     repository if you believe it should not be considered undefined behavior.\";\n \n // Returns a pointer to where the result lives\n fn eval_body_using_ecx<'mir, 'tcx>(\n@@ -375,7 +373,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     ecx.tcx,\n                     \"it is undefined behavior to use this value\",\n                     |diag| {\n-                        diag.note(note_on_undefined_behavior_error());\n+                        diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n                         diag.note(&format!(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation("}, {"sha": "c0cf8c6b76b786c500ea8d3396aadad50fd5a05e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -1098,12 +1098,12 @@ impl EarlyLintPass for UnusedDocComment {\n     }\n \n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        warn_if_doc(cx, block.span, \"block\", &block.attrs());\n+        warn_if_doc(cx, block.span, \"blocks\", &block.attrs());\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         if let ast::ItemKind::ForeignMod(_) = item.kind {\n-            warn_if_doc(cx, item.span, \"extern block\", &item.attrs);\n+            warn_if_doc(cx, item.span, \"extern blocks\", &item.attrs);\n         }\n     }\n }"}, {"sha": "37958cc0f40324fb0756baaa3f37277cd62dd542", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -38,7 +38,9 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n-use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n+use rustc_trait_selection::traits::error_reporting::{\n+    report_object_safety_error, suggestions::NextTypeParamName,\n+};\n use rustc_trait_selection::traits::wf::object_region_bounds;\n \n use smallvec::SmallVec;\n@@ -2986,6 +2988,50 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Some(r)\n     }\n \n+    /// Make sure that we are in the condition to suggest the blanket implementation.\n+    fn maybe_lint_blanket_trait_impl<T: rustc_errors::EmissionGuarantee>(\n+        &self,\n+        self_ty: &hir::Ty<'_>,\n+        diag: &mut DiagnosticBuilder<'_, T>,\n+    ) {\n+        let tcx = self.tcx();\n+        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id);\n+        if let hir::Node::Item(hir::Item {\n+            kind:\n+                hir::ItemKind::Impl(hir::Impl {\n+                    self_ty: impl_self_ty, of_trait: Some(of_trait_ref), generics, ..\n+                }),\n+            ..\n+        }) = tcx.hir().get_by_def_id(parent_id) && self_ty.hir_id == impl_self_ty.hir_id\n+        {\n+            if !of_trait_ref.trait_def_id().map_or(false, |def_id| def_id.is_local()) {\n+                return;\n+            }\n+            let of_trait_span = of_trait_ref.path.span;\n+            // make sure that we are not calling unwrap to abort during the compilation\n+            let Ok(impl_trait_name) = tcx.sess.source_map().span_to_snippet(self_ty.span) else { return; };\n+            let Ok(of_trait_name) = tcx.sess.source_map().span_to_snippet(of_trait_span) else { return; };\n+            // check if the trait has generics, to make a correct suggestion\n+            let param_name = generics.params.next_type_param_name(None);\n+\n+            let add_generic_sugg = if let Some(span) = generics.span_for_param_suggestion() {\n+                (span, format!(\", {}: {}\", param_name, impl_trait_name))\n+            } else {\n+                (generics.span, format!(\"<{}: {}>\", param_name, impl_trait_name))\n+            };\n+            diag.multipart_suggestion(\n+            format!(\"alternatively use a blanket \\\n+                     implementation to implement `{of_trait_name}` for \\\n+                     all types that also implement `{impl_trait_name}`\"),\n+                vec![\n+                    (self_ty.span, param_name),\n+                    add_generic_sugg,\n+                ],\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+\n     fn maybe_lint_bare_trait(&self, self_ty: &hir::Ty<'_>, in_path: bool) {\n         let tcx = self.tcx();\n         if let hir::TyKind::TraitObject([poly_trait_ref, ..], _, TraitObjectSyntax::None) =\n@@ -3021,23 +3067,27 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if self_ty.span.edition() >= Edition::Edition2021 {\n                 let msg = \"trait objects must include the `dyn` keyword\";\n                 let label = \"add `dyn` keyword before this trait\";\n-                rustc_errors::struct_span_err!(tcx.sess, self_ty.span, E0782, \"{}\", msg)\n-                    .multipart_suggestion_verbose(label, sugg, Applicability::MachineApplicable)\n-                    .emit();\n+                let mut diag =\n+                    rustc_errors::struct_span_err!(tcx.sess, self_ty.span, E0782, \"{}\", msg);\n+                diag.multipart_suggestion_verbose(label, sugg, Applicability::MachineApplicable);\n+                // check if the impl trait that we are considering is a impl of a local trait\n+                self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n+                diag.emit();\n             } else {\n                 let msg = \"trait objects without an explicit `dyn` are deprecated\";\n                 tcx.struct_span_lint_hir(\n                     BARE_TRAIT_OBJECTS,\n                     self_ty.hir_id,\n                     self_ty.span,\n                     |lint| {\n-                        lint.build(msg)\n-                            .multipart_suggestion_verbose(\n-                                \"use `dyn`\",\n-                                sugg,\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                        let mut diag = lint.build(msg);\n+                        diag.multipart_suggestion_verbose(\n+                            \"use `dyn`\",\n+                            sugg,\n+                            Applicability::MachineApplicable,\n+                        );\n+                        self.maybe_lint_blanket_trait_impl::<()>(&self_ty, &mut diag);\n+                        diag.emit();\n                     },\n                 );\n             }"}, {"sha": "87f85a9842f341909b32e35cef3e7306a5b1d9b8", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -1707,12 +1707,14 @@ fn drop_location_span<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> Span {\n         hir::Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(_, _, owner_id) => tcx.hir().span(owner_id.hir_id),\n             _ => {\n-                bug!(\"Drop location span error: need to handle more ItemKind {:?}\", item.kind);\n+                bug!(\"Drop location span error: need to handle more ItemKind '{:?}'\", item.kind);\n             }\n         },\n         hir::Node::Block(block) => tcx.hir().span(block.hir_id),\n+        hir::Node::TraitItem(item) => tcx.hir().span(item.hir_id()),\n+        hir::Node::ImplItem(item) => tcx.hir().span(item.hir_id()),\n         _ => {\n-            bug!(\"Drop location span error: need to handle more Node {:?}\", owner_node);\n+            bug!(\"Drop location span error: need to handle more Node '{:?}'\", owner_node);\n         }\n     };\n     tcx.sess.source_map().end_point(owner_span)"}, {"sha": "649ccfcaa9ed85f2b7cdd2b5e4b0b3429e6c26ad", "filename": "library/alloc/src/boxed/thin.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -31,7 +31,9 @@ use core::ptr::{self, NonNull};\n /// ```\n #[unstable(feature = \"thin_box\", issue = \"92791\")]\n pub struct ThinBox<T: ?Sized> {\n-    ptr: WithHeader<<T as Pointee>::Metadata>,\n+    // This is essentially `WithHeader<<T as Pointee>::Metadata>`,\n+    // but that would be invariant in `T`, and we want covariance.\n+    ptr: WithOpaqueHeader,\n     _marker: PhantomData<T>,\n }\n \n@@ -59,7 +61,7 @@ impl<T> ThinBox<T> {\n     #[cfg(not(no_global_oom_handling))]\n     pub fn new(value: T) -> Self {\n         let meta = ptr::metadata(&value);\n-        let ptr = WithHeader::new(meta, value);\n+        let ptr = WithOpaqueHeader::new(meta, value);\n         ThinBox { ptr, _marker: PhantomData }\n     }\n }\n@@ -83,7 +85,7 @@ impl<Dyn: ?Sized> ThinBox<Dyn> {\n         T: Unsize<Dyn>,\n     {\n         let meta = ptr::metadata(&value as &Dyn);\n-        let ptr = WithHeader::new(meta, value);\n+        let ptr = WithOpaqueHeader::new(meta, value);\n         ThinBox { ptr, _marker: PhantomData }\n     }\n }\n@@ -130,7 +132,7 @@ impl<T: ?Sized> Drop for ThinBox<T> {\n         unsafe {\n             let value = self.deref_mut();\n             let value = value as *mut T;\n-            self.ptr.drop::<T>(value);\n+            self.with_header().drop::<T>(value);\n         }\n     }\n }\n@@ -140,11 +142,16 @@ impl<T: ?Sized> ThinBox<T> {\n     fn meta(&self) -> <T as Pointee>::Metadata {\n         //  Safety:\n         //  -   NonNull and valid.\n-        unsafe { *self.ptr.header() }\n+        unsafe { *self.with_header().header() }\n     }\n \n     fn data(&self) -> *mut u8 {\n-        self.ptr.value()\n+        self.with_header().value()\n+    }\n+\n+    fn with_header(&self) -> &WithHeader<<T as Pointee>::Metadata> {\n+        // SAFETY: both types are transparent to `NonNull<u8>`\n+        unsafe { &*((&self.ptr) as *const WithOpaqueHeader as *const WithHeader<_>) }\n     }\n }\n \n@@ -153,8 +160,22 @@ impl<T: ?Sized> ThinBox<T> {\n ///    metadata (`H`) are ZSTs.\n /// 2. A pointer to a valid `T` that has a header `H` directly before the\n ///    pointed-to location.\n+#[repr(transparent)]\n struct WithHeader<H>(NonNull<u8>, PhantomData<H>);\n \n+/// An opaque representation of `WithHeader<H>` to avoid the\n+/// projection invariance of `<T as Pointee>::Metadata`.\n+#[repr(transparent)]\n+struct WithOpaqueHeader(NonNull<u8>);\n+\n+impl WithOpaqueHeader {\n+    #[cfg(not(no_global_oom_handling))]\n+    fn new<H, T>(header: H, value: T) -> Self {\n+        let ptr = WithHeader::new(header, value);\n+        Self(ptr.0)\n+    }\n+}\n+\n impl<H> WithHeader<H> {\n     #[cfg(not(no_global_oom_handling))]\n     fn new<T>(header: H, value: T) -> WithHeader<H> {"}, {"sha": "368aa564f94367ed564c0c70e421d523aa7cbbdd", "filename": "library/alloc/tests/thin_box.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/library%2Falloc%2Ftests%2Fthin_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/library%2Falloc%2Ftests%2Fthin_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fthin_box.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -26,6 +26,13 @@ fn want_thin() {\n     assert!(is_thin::<i32>());\n }\n \n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn thin_box<'new>(b: ThinBox<[&'static str]>) -> ThinBox<[&'new str]> {\n+        b\n+    }\n+}\n+\n #[track_caller]\n fn verify_aligned<T>(ptr: *const T) {\n     // Use `black_box` to attempt to obscure the fact that we're calling this"}, {"sha": "1a022c30938f29f68e237809e4a7aa1c8e20c4fe", "filename": "src/test/ui/lint/unused/unused-doc-comments-edge-cases.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.stderr?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -71,7 +71,7 @@ LL |\n LL | / extern \"C\" {\n LL | |     fn foo();\n LL | | }\n-   | |_- rustdoc does not generate documentation for extern block\n+   | |_- rustdoc does not generate documentation for extern blocks\n    |\n    = help: use `//` for a plain comment\n "}, {"sha": "b280c8ab6e2b270e61fc77ec2204d56975ce4a32", "filename": "src/test/ui/span/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Wrust-2021-incompatible-closure-captures\n+\n+pub struct A {}\n+\n+impl A {\n+    async fn create(path: impl AsRef<std::path::Path>)  { //~ ERROR  `async fn` is not permitted in Rust 2015\n+    //~^ WARN changes to closure capture in Rust 2021 will affect drop order [rust_2021_incompatible_closure_captures]\n+    ;\n+    crate(move || {} ).await //~ ERROR expected function, found module `crate`\n+    }\n+}\n+\n+trait C{async fn new(val: T) {} //~ ERROR  `async fn` is not permitted in Rust 2015\n+//~^ ERROR functions in traits cannot be declared `async`\n+//~^^ ERROR cannot find type `T` in this scope\n+//~^^^ WARN changes to closure capture in Rust 2021 will affect drop order [rust_2021_incompatible_closure_captures]\n+\n+//~ ERROR  this file contains an unclosed delimiter"}, {"sha": "50de2322907edb3a3e2ca20133d2cd7426112174", "filename": "src/test/ui/span/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.stderr", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-93117.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-93117.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-93117.stderr?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -0,0 +1,93 @@\n+error: this file contains an unclosed delimiter\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:18:53\n+   |\n+LL | trait C{async fn new(val: T) {}\n+   |        - unclosed delimiter\n+...\n+LL |\n+   |                                                     ^\n+\n+error[E0670]: `async fn` is not permitted in Rust 2015\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:6:5\n+   |\n+LL |     async fn create(path: impl AsRef<std::path::Path>)  {\n+   |     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n+   |\n+   = help: pass `--edition 2021` to `rustc`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error[E0670]: `async fn` is not permitted in Rust 2015\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:13:9\n+   |\n+LL | trait C{async fn new(val: T) {}\n+   |         ^^^^^ to use `async fn`, switch to Rust 2018 or later\n+   |\n+   = help: pass `--edition 2021` to `rustc`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error[E0706]: functions in traits cannot be declared `async`\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:13:9\n+   |\n+LL | trait C{async fn new(val: T) {}\n+   |         -----^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         `async` because of this\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error[E0423]: expected function, found module `crate`\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:9:5\n+   |\n+LL |     crate(move || {} ).await\n+   |     ^^^^^ not a function\n+\n+error[E0412]: cannot find type `T` in this scope\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:13:27\n+   |\n+LL | pub struct A {}\n+   | ------------ similarly named struct `A` defined here\n+...\n+LL | trait C{async fn new(val: T) {}\n+   |                           ^ help: a struct with a similar name exists: `A`\n+\n+warning: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:6:57\n+   |\n+LL |       async fn create(path: impl AsRef<std::path::Path>)  {\n+   |  _____________________----_____________________________-__^\n+   | |                     |                                |\n+   | |                     |                                in Rust 2018, `path` is dropped here along with the closure, but in Rust 2021 `path` is not part of the closure\n+   | |                     in Rust 2018, this causes the closure to capture `path`, but in Rust 2021, it has no effect\n+LL | |\n+LL | |     ;\n+LL | |     crate(move || {} ).await\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: requested on the command line with `-W rust-2021-incompatible-closure-captures`\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `path` to be fully captured\n+   |\n+LL |     async fn create(path: impl AsRef<std::path::Path>)  { let _ = &path;\n+   |                                                           ++++++++++++++\n+\n+warning: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-93117.rs:13:30\n+   |\n+LL | trait C{async fn new(val: T) {}\n+   |                      ---   - ^^\n+   |                      |     |\n+   |                      |     in Rust 2018, `val` is dropped here along with the closure, but in Rust 2021 `val` is not part of the closure\n+   |                      in Rust 2018, this causes the closure to capture `val`, but in Rust 2021, it has no effect\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `val` to be fully captured\n+   |\n+LL | trait C{async fn new(val: T) { let _ = &val;}\n+   |                                +++++++++++++\n+\n+error: aborting due to 6 previous errors; 2 warnings emitted\n+\n+Some errors have detailed explanations: E0412, E0423, E0670, E0706.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "a776e5089075c889e024259d832588ae270280c5", "filename": "src/test/ui/span/drop-location-span-error-rust-2021-incompatible-closure-captures-96258.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-96258.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-96258.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-96258.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags -Wrust-2021-incompatible-closure-captures\n+\n+fn main() {}\n+\n+pub(crate) struct Numberer {}\n+\n+impl Numberer {\n+    pub(crate) async fn new(\n+    //~^ ERROR `async fn` is not permitted in Rust 2015\n+        interval: Duration,\n+        //~^ ERROR cannot find type `Duration` in this scope\n+    ) -> Numberer {\n+        Numberer {}\n+    }\n+}"}, {"sha": "37b2f4138603dba0e47f6aab91ef3da0e5b6269c", "filename": "src/test/ui/span/drop-location-span-error-rust-2021-incompatible-closure-captures-96258.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-96258.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-96258.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdrop-location-span-error-rust-2021-incompatible-closure-captures-96258.stderr?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -0,0 +1,24 @@\n+error[E0670]: `async fn` is not permitted in Rust 2015\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-96258.rs:8:16\n+   |\n+LL |     pub(crate) async fn new(\n+   |                ^^^^^ to use `async fn`, switch to Rust 2018 or later\n+   |\n+   = help: pass `--edition 2021` to `rustc`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error[E0412]: cannot find type `Duration` in this scope\n+  --> $DIR/drop-location-span-error-rust-2021-incompatible-closure-captures-96258.rs:10:19\n+   |\n+LL |         interval: Duration,\n+   |                   ^^^^^^^^ not found in this scope\n+   |\n+help: consider importing this struct\n+   |\n+LL | use std::time::Duration;\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0412, E0670.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "7cf536f7966e0c342df53f2671cf10ffd0103523", "filename": "src/test/ui/suggestions/suggest-blanket-impl-local-trait.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-blanket-impl-local-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-blanket-impl-local-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-blanket-impl-local-trait.rs?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -0,0 +1,58 @@\n+// Ensure that the compiler include the blanklet implementation suggestion\n+// when inside a `impl` statment are used two local traits.\n+//\n+// edition:2021\n+use std::fmt;\n+\n+trait LocalTraitOne { }\n+\n+trait LocalTraitTwo { }\n+\n+trait GenericTrait<T> {}\n+\n+impl LocalTraitTwo for LocalTraitOne {}\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+//~| HELP alternatively use a blanket implementation to implement `LocalTraitTwo` for all types that also implement `LocalTraitOne`\n+\n+impl fmt::Display for LocalTraitOne {\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!();\n+    }\n+}\n+\n+impl fmt::Display for LocalTraitTwo + Send {\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!();\n+    }\n+}\n+\n+impl LocalTraitOne for fmt::Display {}\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+//~| HELP alternatively use a blanket implementation to implement `LocalTraitOne` for all types that also implement `fmt::Display`\n+\n+\n+impl LocalTraitOne for fmt::Display + Send {}\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+//~| HELP alternatively use a blanket implementation to implement `LocalTraitOne` for all types that also implement `fmt::Display + Send`\n+\n+\n+impl<E> GenericTrait<E> for LocalTraitOne {}\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+//~| HELP alternatively use a blanket implementation to implement `GenericTrait<E>` for all types that also implement `LocalTraitOne`\n+\n+trait GenericTraitTwo<T> {}\n+\n+impl<T, E> GenericTraitTwo<E> for GenericTrait<T> {}\n+//~^ ERROR trait objects must include the `dyn` keyword\n+//~| HELP add `dyn` keyword before this trait\n+//~| HELP alternatively use a blanket implementation to implement `GenericTraitTwo<E>` for all types that also implement `GenericTrait<T>`\n+\n+fn main() {}"}, {"sha": "d739a8272f1520826951aaeb2e3b12c31853f7d3", "filename": "src/test/ui/suggestions/suggest-blanket-impl-local-trait.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-blanket-impl-local-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-blanket-impl-local-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-blanket-impl-local-trait.stderr?ref=5018181c79a6fe37913fd931005ad2a63c85be7b", "patch": "@@ -0,0 +1,107 @@\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:13:24\n+   |\n+LL | impl LocalTraitTwo for LocalTraitOne {}\n+   |                        ^^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl LocalTraitTwo for LocalTraitOne {}\n+LL + impl LocalTraitTwo for dyn LocalTraitOne {}\n+   |\n+help: alternatively use a blanket implementation to implement `LocalTraitTwo` for all types that also implement `LocalTraitOne`\n+   |\n+LL | impl<T: LocalTraitOne> LocalTraitTwo for T {}\n+   |     ++++++++++++++++++                   ~\n+\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:18:23\n+   |\n+LL | impl fmt::Display for LocalTraitOne {\n+   |                       ^^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl fmt::Display for LocalTraitOne {\n+LL + impl fmt::Display for dyn LocalTraitOne {\n+   |\n+\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:26:23\n+   |\n+LL | impl fmt::Display for LocalTraitTwo + Send {\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl fmt::Display for LocalTraitTwo + Send {\n+LL + impl fmt::Display for dyn LocalTraitTwo + Send {\n+   |\n+\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:34:24\n+   |\n+LL | impl LocalTraitOne for fmt::Display {}\n+   |                        ^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl LocalTraitOne for fmt::Display {}\n+LL + impl LocalTraitOne for dyn fmt::Display {}\n+   |\n+help: alternatively use a blanket implementation to implement `LocalTraitOne` for all types that also implement `fmt::Display`\n+   |\n+LL | impl<T: fmt::Display> LocalTraitOne for T {}\n+   |     +++++++++++++++++                   ~\n+\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:40:24\n+   |\n+LL | impl LocalTraitOne for fmt::Display + Send {}\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl LocalTraitOne for fmt::Display + Send {}\n+LL + impl LocalTraitOne for dyn fmt::Display + Send {}\n+   |\n+help: alternatively use a blanket implementation to implement `LocalTraitOne` for all types that also implement `fmt::Display + Send`\n+   |\n+LL | impl<T: fmt::Display + Send> LocalTraitOne for T {}\n+   |     ++++++++++++++++++++++++                   ~\n+\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:46:29\n+   |\n+LL | impl<E> GenericTrait<E> for LocalTraitOne {}\n+   |                             ^^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl<E> GenericTrait<E> for LocalTraitOne {}\n+LL + impl<E> GenericTrait<E> for dyn LocalTraitOne {}\n+   |\n+help: alternatively use a blanket implementation to implement `GenericTrait<E>` for all types that also implement `LocalTraitOne`\n+   |\n+LL | impl<E, T: LocalTraitOne> GenericTrait<E> for T {}\n+   |       ++++++++++++++++++                      ~\n+\n+error[E0782]: trait objects must include the `dyn` keyword\n+  --> $DIR/suggest-blanket-impl-local-trait.rs:53:35\n+   |\n+LL | impl<T, E> GenericTraitTwo<E> for GenericTrait<T> {}\n+   |                                   ^^^^^^^^^^^^^^^\n+   |\n+help: add `dyn` keyword before this trait\n+   |\n+LL - impl<T, E> GenericTraitTwo<E> for GenericTrait<T> {}\n+LL + impl<T, E> GenericTraitTwo<E> for dyn GenericTrait<T> {}\n+   |\n+help: alternatively use a blanket implementation to implement `GenericTraitTwo<E>` for all types that also implement `GenericTrait<T>`\n+   |\n+LL | impl<T, E, U: GenericTrait<T>> GenericTraitTwo<E> for U {}\n+   |          ++++++++++++++++++++                         ~\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0782`."}, {"sha": "0a357e006c3573ed6279ee359d93dd788baec86a", "filename": "suggest-blanket-impl-local-trait", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5018181c79a6fe37913fd931005ad2a63c85be7b/suggest-blanket-impl-local-trait", "raw_url": "https://github.com/rust-lang/rust/raw/5018181c79a6fe37913fd931005ad2a63c85be7b/suggest-blanket-impl-local-trait", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/suggest-blanket-impl-local-trait?ref=5018181c79a6fe37913fd931005ad2a63c85be7b"}]}