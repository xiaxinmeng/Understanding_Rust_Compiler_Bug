{"sha": "782013564efc06ef02614ba35a4e67dee4fcb8e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MjAxMzU2NGVmYzA2ZWYwMjYxNGJhMzVhNGU2N2RlZTRmY2I4ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-01T13:21:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-01T13:21:34Z"}, "message": "Auto merge of #76919 - fusion-engineering-forks:thread-parker, r=dtolnay\n\nUse futex-based thread::park/unpark on Linux.\n\nThis moves the parking/unparking logic out of `thread/mod.rs` into a module named `thread_parker` in `sys_common`. The current implementation is moved to `sys_common/thread_parker/generic.rs` and the new implementation using futexes is added in `sys_common/thread_parker/futex.rs`.", "tree": {"sha": "2e905ff25153425fe0389ea1db074a72edcd7934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e905ff25153425fe0389ea1db074a72edcd7934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/782013564efc06ef02614ba35a4e67dee4fcb8e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/782013564efc06ef02614ba35a4e67dee4fcb8e7", "html_url": "https://github.com/rust-lang/rust/commit/782013564efc06ef02614ba35a4e67dee4fcb8e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/782013564efc06ef02614ba35a4e67dee4fcb8e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cba260df0f1c67ea3690035cd5611a7465a1560", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cba260df0f1c67ea3690035cd5611a7465a1560", "html_url": "https://github.com/rust-lang/rust/commit/9cba260df0f1c67ea3690035cd5611a7465a1560"}, {"sha": "0b73fd7105db81a994a81b775a43bbdb1be3c76a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b73fd7105db81a994a81b775a43bbdb1be3c76a", "html_url": "https://github.com/rust-lang/rust/commit/0b73fd7105db81a994a81b775a43bbdb1be3c76a"}], "stats": {"total": 388, "additions": 276, "deletions": 112}, "files": [{"sha": "e6f0c48c59b1b354db0ba6aa0b68ffc23e861810", "filename": "library/std/src/sys/unix/futex.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -0,0 +1,37 @@\n+#![cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+\n+use crate::convert::TryInto;\n+use crate::ptr::null;\n+use crate::sync::atomic::AtomicI32;\n+use crate::time::Duration;\n+\n+pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+    let timespec = timeout.and_then(|d| {\n+        Some(libc::timespec {\n+            // Sleep forever if the timeout is longer than fits in a timespec.\n+            tv_sec: d.as_secs().try_into().ok()?,\n+            // This conversion never truncates, as subsec_nanos is always <1e9.\n+            tv_nsec: d.subsec_nanos() as _,\n+        })\n+    });\n+    unsafe {\n+        libc::syscall(\n+            libc::SYS_futex,\n+            futex as *const AtomicI32,\n+            libc::FUTEX_WAIT | libc::FUTEX_PRIVATE_FLAG,\n+            expected,\n+            timespec.as_ref().map_or(null(), |d| d as *const libc::timespec),\n+        );\n+    }\n+}\n+\n+pub fn futex_wake(futex: &AtomicI32) {\n+    unsafe {\n+        libc::syscall(\n+            libc::SYS_futex,\n+            futex as *const AtomicI32,\n+            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n+            1,\n+        );\n+    }\n+}"}, {"sha": "776f4f18ecfa285ae8799d089b5d50e6463fffce", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -49,6 +49,7 @@ pub mod env;\n pub mod ext;\n pub mod fd;\n pub mod fs;\n+pub mod futex;\n pub mod io;\n #[cfg(target_os = \"l4re\")]\n mod l4re;"}, {"sha": "234b257aa926e834666398a9a27796e05b12a871", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -66,6 +66,7 @@ pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod util;\n pub mod wtf8;\n "}, {"sha": "a5d4927dcc5cac841b370c4f8c072f096975d433", "filename": "library/std/src/sys_common/thread_parker/futex.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -0,0 +1,93 @@\n+use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::Ordering::{Acquire, Release};\n+use crate::sys::futex::{futex_wait, futex_wake};\n+use crate::time::Duration;\n+\n+const PARKED: i32 = -1;\n+const EMPTY: i32 = 0;\n+const NOTIFIED: i32 = 1;\n+\n+pub struct Parker {\n+    state: AtomicI32,\n+}\n+\n+// Notes about memory ordering:\n+//\n+// Memory ordering is only relevant for the relative ordering of operations\n+// between different variables. Even Ordering::Relaxed guarantees a\n+// monotonic/consistent order when looking at just a single atomic variable.\n+//\n+// So, since this parker is just a single atomic variable, we only need to look\n+// at the ordering guarantees we need to provide to the 'outside world'.\n+//\n+// The only memory ordering guarantee that parking and unparking provide, is\n+// that things which happened before unpark() are visible on the thread\n+// returning from park() afterwards. Otherwise, it was effectively unparked\n+// before unpark() was called while still consuming the 'token'.\n+//\n+// In other words, unpark() needs to synchronize with the part of park() that\n+// consumes the token and returns.\n+//\n+// This is done with a release-acquire synchronization, by using\n+// Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n+// Ordering::Acquire when checking for this state in park().\n+impl Parker {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Parker { state: AtomicI32::new(EMPTY) }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park(&self) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+        loop {\n+            // Wait for something to happen, assuming it's still set to PARKED.\n+            futex_wait(&self.state, PARKED, None);\n+            // Change NOTIFIED=>EMPTY and return in that case.\n+            if self.state.compare_and_swap(NOTIFIED, EMPTY, Acquire) == NOTIFIED {\n+                return;\n+            } else {\n+                // Spurious wake up. We loop to try again.\n+            }\n+        }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+        // Wait for something to happen, assuming it's still set to PARKED.\n+        futex_wait(&self.state, PARKED, Some(timeout));\n+        // This is not just a store, because we need to establish a\n+        // release-acquire ordering with unpark().\n+        if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n+            // Woke up because of unpark().\n+        } else {\n+            // Timeout or spurious wake up.\n+            // We return either way, because we can't easily tell if it was the\n+            // timeout or not.\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unpark(&self) {\n+        // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n+        // wake the thread in the first case.\n+        //\n+        // Note that even NOTIFIED=>NOTIFIED results in a write. This is on\n+        // purpose, to make sure every unpark() has a release-acquire ordering\n+        // with park().\n+        if self.state.swap(NOTIFIED, Release) == PARKED {\n+            futex_wake(&self.state);\n+        }\n+    }\n+}"}, {"sha": "14cfa958e5e534ce7ef371ab194f570a81c6156f", "filename": "library/std/src/sys_common/thread_parker/generic.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -0,0 +1,119 @@\n+//! Parker implementaiton based on a Mutex and Condvar.\n+\n+use crate::sync::atomic::AtomicUsize;\n+use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sync::{Condvar, Mutex};\n+use crate::time::Duration;\n+\n+const EMPTY: usize = 0;\n+const PARKED: usize = 1;\n+const NOTIFIED: usize = 2;\n+\n+pub struct Parker {\n+    state: AtomicUsize,\n+    lock: Mutex<()>,\n+    cvar: Condvar,\n+}\n+\n+impl Parker {\n+    pub fn new() -> Self {\n+        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n+    }\n+\n+    // This implementaiton doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park(&self) {\n+        // If we were previously notified then we consume this notification and\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        // Otherwise we need to coordinate going to sleep\n+        let mut m = self.lock.lock().unwrap();\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read here, even though we know it will be `NOTIFIED`.\n+                // This is because `unpark` may have been called again since we read\n+                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+                // acquire operation that synchronizes with that `unpark` to observe\n+                // any writes it made before the call to unpark. To do that we must\n+                // read from the write it made to `state`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => panic!(\"inconsistent park state\"),\n+        }\n+        loop {\n+            m = self.cvar.wait(m).unwrap();\n+            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n+                Ok(_) => return, // got a notification\n+                Err(_) => {}     // spurious wakeup, go back to sleep\n+            }\n+        }\n+    }\n+\n+    // This implementaiton doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park_timeout(&self, dur: Duration) {\n+        // Like `park` above we have a fast path for an already-notified thread, and\n+        // afterwards we start coordinating for a sleep.\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+        let m = self.lock.lock().unwrap();\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read again here, see `park`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => panic!(\"inconsistent park_timeout state\"),\n+        }\n+\n+        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n+        // from a notification we just want to unconditionally set the state back to\n+        // empty, either consuming a notification or un-flagging ourselves as\n+        // parked.\n+        let (_m, _result) = self.cvar.wait_timeout(m, dur).unwrap();\n+        match self.state.swap(EMPTY, SeqCst) {\n+            NOTIFIED => {} // got a notification, hurray!\n+            PARKED => {}   // no notification, alas\n+            n => panic!(\"inconsistent park_timeout state: {}\", n),\n+        }\n+    }\n+\n+    pub fn unpark(&self) {\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n+        match self.state.swap(NOTIFIED, SeqCst) {\n+            EMPTY => return,    // no one was waiting\n+            NOTIFIED => return, // already unparked\n+            PARKED => {}        // gotta go wake someone up\n+            _ => panic!(\"inconsistent state in unpark\"),\n+        }\n+\n+        // There is a period between when the parked thread sets `state` to\n+        // `PARKED` (or last checked `state` in the case of a spurious wake\n+        // up) and when it actually waits on `cvar`. If we were to notify\n+        // during this period it would be ignored and then when the parked\n+        // thread went to sleep it would never wake up. Fortunately, it has\n+        // `lock` locked at this stage so we can acquire `lock` to wait until\n+        // it is ready to receive the notification.\n+        //\n+        // Releasing `lock` before the call to `notify_one` means that when the\n+        // parked thread wakes it doesn't get woken only to have to wait for us\n+        // to release `lock`.\n+        drop(self.lock.lock().unwrap());\n+        self.cvar.notify_one()\n+    }\n+}"}, {"sha": "23c17c8e2cf26108e6049121c1d4ae61bbc192fa", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -0,0 +1,9 @@\n+cfg_if::cfg_if! {\n+    if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n+        mod futex;\n+        pub use futex::Parker;\n+    } else {\n+        mod generic;\n+        pub use generic::Parker;\n+    }\n+}"}, {"sha": "fb2fbb5bf2dbd16aff878af05f7c2ee4704bc119", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 16, "deletions": 112, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782013564efc06ef02614ba35a4e67dee4fcb8e7/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=782013564efc06ef02614ba35a4e67dee4fcb8e7", "patch": "@@ -159,13 +159,12 @@ use crate::num::NonZeroU64;\n use crate::panic;\n use crate::panicking;\n use crate::str;\n-use crate::sync::atomic::AtomicUsize;\n-use crate::sync::atomic::Ordering::SeqCst;\n-use crate::sync::{Arc, Condvar, Mutex};\n+use crate::sync::Arc;\n use crate::sys::thread as imp;\n use crate::sys_common::mutex;\n use crate::sys_common::thread;\n use crate::sys_common::thread_info;\n+use crate::sys_common::thread_parker::Parker;\n use crate::sys_common::{AsInner, IntoInner};\n use crate::time::Duration;\n \n@@ -667,6 +666,8 @@ pub fn current() -> Thread {\n ///\n /// [`channel`]: crate::sync::mpsc\n /// [`join`]: JoinHandle::join\n+/// [`Condvar`]: crate::sync::Condvar\n+/// [`Mutex`]: crate::sync::Mutex\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn yield_now() {\n     imp::Thread::yield_now()\n@@ -712,6 +713,8 @@ pub fn yield_now() {\n ///     panic!()\n /// }\n /// ```\n+///\n+/// [Mutex]: crate::sync::Mutex\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn panicking() -> bool {\n@@ -779,11 +782,6 @@ pub fn sleep(dur: Duration) {\n     imp::Thread::sleep(dur)\n }\n \n-// constants for park/unpark\n-const EMPTY: usize = 0;\n-const PARKED: usize = 1;\n-const NOTIFIED: usize = 2;\n-\n /// Blocks unless or until the current thread's token is made available.\n ///\n /// A call to `park` does not guarantee that the thread will remain parked\n@@ -870,45 +868,11 @@ const NOTIFIED: usize = 2;\n ///\n /// [`unpark`]: Thread::unpark\n /// [`thread::park_timeout`]: park_timeout\n-//\n-// The implementation currently uses the trivial strategy of a Mutex+Condvar\n-// with wakeup flag, which does not actually allow spurious wakeups. In the\n-// future, this will be implemented in a more efficient way, perhaps along the lines of\n-//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n-// or futuxes, and in either case may allow spurious wakeups.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn park() {\n-    let thread = current();\n-\n-    // If we were previously notified then we consume this notification and\n-    // return quickly.\n-    if thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-        return;\n-    }\n-\n-    // Otherwise we need to coordinate going to sleep\n-    let mut m = thread.inner.lock.lock().unwrap();\n-    match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-        Ok(_) => {}\n-        Err(NOTIFIED) => {\n-            // We must read here, even though we know it will be `NOTIFIED`.\n-            // This is because `unpark` may have been called again since we read\n-            // `NOTIFIED` in the `compare_exchange` above. We must perform an\n-            // acquire operation that synchronizes with that `unpark` to observe\n-            // any writes it made before the call to unpark. To do that we must\n-            // read from the write it made to `state`.\n-            let old = thread.inner.state.swap(EMPTY, SeqCst);\n-            assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-            return;\n-        } // should consume this notification, so prohibit spurious wakeups in next park.\n-        Err(_) => panic!(\"inconsistent park state\"),\n-    }\n-    loop {\n-        m = thread.inner.cvar.wait(m).unwrap();\n-        match thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n-            Ok(_) => return, // got a notification\n-            Err(_) => {}     // spurious wakeup, go back to sleep\n-        }\n+    // SAFETY: park_timeout is called on the parker owned by this thread.\n+    unsafe {\n+        current().inner.parker.park();\n     }\n }\n \n@@ -970,35 +934,9 @@ pub fn park_timeout_ms(ms: u32) {\n /// ```\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n-    let thread = current();\n-\n-    // Like `park` above we have a fast path for an already-notified thread, and\n-    // afterwards we start coordinating for a sleep.\n-    // return quickly.\n-    if thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-        return;\n-    }\n-    let m = thread.inner.lock.lock().unwrap();\n-    match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-        Ok(_) => {}\n-        Err(NOTIFIED) => {\n-            // We must read again here, see `park`.\n-            let old = thread.inner.state.swap(EMPTY, SeqCst);\n-            assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-            return;\n-        } // should consume this notification, so prohibit spurious wakeups in next park.\n-        Err(_) => panic!(\"inconsistent park_timeout state\"),\n-    }\n-\n-    // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n-    // from a notification we just want to unconditionally set the state back to\n-    // empty, either consuming a notification or un-flagging ourselves as\n-    // parked.\n-    let (_m, _result) = thread.inner.cvar.wait_timeout(m, dur).unwrap();\n-    match thread.inner.state.swap(EMPTY, SeqCst) {\n-        NOTIFIED => {} // got a notification, hurray!\n-        PARKED => {}   // no notification, alas\n-        n => panic!(\"inconsistent park_timeout state: {}\", n),\n+    // SAFETY: park_timeout is called on the parker owned by this thread.\n+    unsafe {\n+        current().inner.parker.park_timeout(dur);\n     }\n }\n \n@@ -1077,11 +1015,7 @@ impl ThreadId {\n struct Inner {\n     name: Option<CString>, // Guaranteed to be UTF-8\n     id: ThreadId,\n-\n-    // state for thread park/unpark\n-    state: AtomicUsize,\n-    lock: Mutex<()>,\n-    cvar: Condvar,\n+    parker: Parker,\n }\n \n #[derive(Clone)]\n@@ -1115,13 +1049,7 @@ impl Thread {\n         let cname =\n             name.map(|n| CString::new(n).expect(\"thread name may not contain interior null bytes\"));\n         Thread {\n-            inner: Arc::new(Inner {\n-                name: cname,\n-                id: ThreadId::new(),\n-                state: AtomicUsize::new(EMPTY),\n-                lock: Mutex::new(()),\n-                cvar: Condvar::new(),\n-            }),\n+            inner: Arc::new(Inner { name: cname, id: ThreadId::new(), parker: Parker::new() }),\n         }\n     }\n \n@@ -1156,33 +1084,9 @@ impl Thread {\n     /// parked_thread.join().unwrap();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn unpark(&self) {\n-        // To ensure the unparked thread will observe any writes we made\n-        // before this call, we must perform a release operation that `park`\n-        // can synchronize with. To do that we must write `NOTIFIED` even if\n-        // `state` is already `NOTIFIED`. That is why this must be a swap\n-        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n-        // on failure.\n-        match self.inner.state.swap(NOTIFIED, SeqCst) {\n-            EMPTY => return,    // no one was waiting\n-            NOTIFIED => return, // already unparked\n-            PARKED => {}        // gotta go wake someone up\n-            _ => panic!(\"inconsistent state in unpark\"),\n-        }\n-\n-        // There is a period between when the parked thread sets `state` to\n-        // `PARKED` (or last checked `state` in the case of a spurious wake\n-        // up) and when it actually waits on `cvar`. If we were to notify\n-        // during this period it would be ignored and then when the parked\n-        // thread went to sleep it would never wake up. Fortunately, it has\n-        // `lock` locked at this stage so we can acquire `lock` to wait until\n-        // it is ready to receive the notification.\n-        //\n-        // Releasing `lock` before the call to `notify_one` means that when the\n-        // parked thread wakes it doesn't get woken only to have to wait for us\n-        // to release `lock`.\n-        drop(self.inner.lock.lock().unwrap());\n-        self.inner.cvar.notify_one()\n+        self.inner.parker.unpark();\n     }\n \n     /// Gets the thread's unique identifier."}]}