{"sha": "cf7aa572798d1a1ab67e39e693062c2b52536463", "node_id": "C_kwDOAAsO6NoAKGNmN2FhNTcyNzk4ZDFhMWFiNjdlMzllNjkzMDYyYzJiNTI1MzY0NjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-07T16:57:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-07T16:57:16Z"}, "message": "Rollup merge of #107746 - Nathan-Fenner:nathanf/clean-up-adjust_fulfillment_errors, r=compiler-errors\n\nSplit fn_ctxt/adjust_fulfillment_errors from fn_ctxt/checks\n\nThis is a follow-up from #106477, addressing a small number of the `FIXME`s that were added, by moving some functions into the new(er) `adjust_fulfillment_errors` module.\n\nMore cleanup is possible for this file (and I'll hopefully get around to doing some of that soon) but the very first thing is to just move these functions out.\n\nThere should be no \"real\" changes in this PR, besides minor adjustments to imports and the functions being transferred.", "tree": {"sha": "ecaaae952390c61929a21c3a9a878fa68c008f73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecaaae952390c61929a21c3a9a878fa68c008f73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf7aa572798d1a1ab67e39e693062c2b52536463", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj4oLsCRBK7hj4Ov3rIwAAiZ8IAJ2B6urK2NcXDOzNXka8NM3p\n2FODonSnJqgFCa9ubWRhJFV2w96tTHiVhrhFPN57OakkGSIsBW1uUYKEKBHkz/nk\nFa0UXDHEWK3hLZlBYIfvbxcfWSZaPo0O0a986VRE4K0nWE+yUGcCMEDNP9gMPDut\nVFWZtt1DTgZ/kt+wKTL0jAQyfyHLn0IFWJ7Z6ORZxKoG8SwSpRvIpFo2+WqlT93T\npynsdVgIxhfD3uLMzTIPhSTomMOD3rzDzmW8abT0uYhZR9yrMd4x0oDc/yMX2/a7\nIWvNz+B5CMzOdBxsIiVSZpH98Emd5eDeWjB7RtHezo4di041pxhGuoXj5LfQmIU=\n=AJ5p\n-----END PGP SIGNATURE-----\n", "payload": "tree ecaaae952390c61929a21c3a9a878fa68c008f73\nparent 8709e9be5adfe50fa765f73aec8fb5725ec20862\nparent 4c053668d6b170232fadb37082f7c590ce84aa4f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675789036 +0100\ncommitter GitHub <noreply@github.com> 1675789036 +0100\n\nRollup merge of #107746 - Nathan-Fenner:nathanf/clean-up-adjust_fulfillment_errors, r=compiler-errors\n\nSplit fn_ctxt/adjust_fulfillment_errors from fn_ctxt/checks\n\nThis is a follow-up from #106477, addressing a small number of the `FIXME`s that were added, by moving some functions into the new(er) `adjust_fulfillment_errors` module.\n\nMore cleanup is possible for this file (and I'll hopefully get around to doing some of that soon) but the very first thing is to just move these functions out.\n\nThere should be no \"real\" changes in this PR, besides minor adjustments to imports and the functions being transferred.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7aa572798d1a1ab67e39e693062c2b52536463", "html_url": "https://github.com/rust-lang/rust/commit/cf7aa572798d1a1ab67e39e693062c2b52536463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf7aa572798d1a1ab67e39e693062c2b52536463/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8709e9be5adfe50fa765f73aec8fb5725ec20862", "url": "https://api.github.com/repos/rust-lang/rust/commits/8709e9be5adfe50fa765f73aec8fb5725ec20862", "html_url": "https://github.com/rust-lang/rust/commit/8709e9be5adfe50fa765f73aec8fb5725ec20862"}, {"sha": "4c053668d6b170232fadb37082f7c590ce84aa4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c053668d6b170232fadb37082f7c590ce84aa4f", "html_url": "https://github.com/rust-lang/rust/commit/4c053668d6b170232fadb37082f7c590ce84aa4f"}], "stats": {"total": 744, "additions": 374, "deletions": 370}, "files": [{"sha": "db1acb599271696008ec0143c1f68a587ddf173f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 373, "deletions": 1, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/cf7aa572798d1a1ab67e39e693062c2b52536463/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7aa572798d1a1ab67e39e693062c2b52536463/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=cf7aa572798d1a1ab67e39e693062c2b52536463", "patch": "@@ -1,10 +1,382 @@\n use crate::FnCtxt;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::traits::ObligationCauseCode;\n+use rustc_middle::ty::{self, DefIdTree, Ty, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_span::{self, Span};\n use rustc_trait_selection::traits;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn adjust_fulfillment_error_for_expr_obligation(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+    ) -> bool {\n+        let (traits::ExprItemObligation(def_id, hir_id, idx) | traits::ExprBindingObligation(def_id, _, hir_id, idx))\n+            = *error.obligation.cause.code().peel_derives() else { return false; };\n+        let hir = self.tcx.hir();\n+        let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n+\n+        let Some(unsubstituted_pred) =\n+            self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n+            else { return false; };\n+\n+        let generics = self.tcx.generics_of(def_id);\n+        let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n+            _ => ty::List::empty(),\n+        };\n+\n+        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n+            predicate_substs.types().find_map(|ty| {\n+                ty.walk().find_map(|arg| {\n+                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                        && let ty::Param(param_ty) = ty.kind()\n+                        && matches(param_ty)\n+                    {\n+                        Some(arg)\n+                    } else {\n+                        None\n+                    }\n+                })\n+            })\n+        };\n+\n+        // Prefer generics that are local to the fn item, since these are likely\n+        // to be the cause of the unsatisfied predicate.\n+        let mut param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n+        });\n+        // Fall back to generic that isn't local to the fn item. This will come\n+        // from a trait or impl, for example.\n+        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n+                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n+        });\n+        // Finally, the `Self` parameter is possibly the reason that the predicate\n+        // is unsatisfied. This is less likely to be true for methods, because\n+        // method probe means that we already kinda check that the predicates due\n+        // to the `Self` type are true.\n+        let mut self_param_to_point_at =\n+            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n+\n+        // Finally, for ambiguity-related errors, we actually want to look\n+        // for a parameter that is the source of the inference type left\n+        // over in this predicate.\n+        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n+            fallback_param_to_point_at = None;\n+            self_param_to_point_at = None;\n+            param_to_point_at =\n+                self.find_ambiguous_parameter_in(def_id, error.root_obligation.predicate);\n+        }\n+\n+        if self.closure_span_overlaps_error(error, expr.span) {\n+            return false;\n+        }\n+\n+        match &expr.kind {\n+            hir::ExprKind::Path(qpath) => {\n+                if let hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Call(callee, args),\n+                    hir_id: call_hir_id,\n+                    span: call_span,\n+                    ..\n+                }) = hir.get_parent(expr.hir_id)\n+                    && callee.hir_id == expr.hir_id\n+                {\n+                    if self.closure_span_overlaps_error(error, *call_span) {\n+                        return false;\n+                    }\n+\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                        .into_iter()\n+                        .flatten()\n+                    {\n+                        if self.blame_specific_arg_if_possible(\n+                                error,\n+                                def_id,\n+                                param,\n+                                *call_hir_id,\n+                                callee.span,\n+                                None,\n+                                args,\n+                            )\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                // Notably, we only point to params that are local to the\n+                // item we're checking, since those are the ones we are able\n+                // to look in the final `hir::PathSegment` for. Everything else\n+                // would require a deeper search into the `qpath` than I think\n+                // is worthwhile.\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n+                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    .into_iter()\n+                    .flatten()\n+                {\n+                    if self.blame_specific_arg_if_possible(\n+                        error,\n+                        def_id,\n+                        param,\n+                        hir_id,\n+                        segment.ident.span,\n+                        Some(receiver),\n+                        args,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::ExprKind::Struct(qpath, fields, ..) => {\n+                if let Res::Def(\n+                    hir::def::DefKind::Struct | hir::def::DefKind::Variant,\n+                    variant_def_id,\n+                ) = self.typeck_results.borrow().qpath_res(qpath, hir_id)\n+                {\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    {\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n+                                def_id,\n+                                param,\n+                                variant_def_id,\n+                                fields,\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+\n+    fn point_at_path_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param: ty::GenericArg<'tcx>,\n+        qpath: &hir::QPath<'tcx>,\n+    ) -> bool {\n+        match qpath {\n+            hir::QPath::Resolved(_, path) => {\n+                if let Some(segment) = path.segments.last()\n+                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::QPath::TypeRelative(_, segment) => {\n+                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+\n+    fn point_at_generic_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        segment: &hir::PathSegment<'tcx>,\n+    ) -> bool {\n+        let own_substs = self\n+            .tcx\n+            .generics_of(def_id)\n+            .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n+        let Some((index, _)) = own_substs\n+            .iter()\n+            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n+            .enumerate()\n+            .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n+        let Some(arg) = segment\n+            .args()\n+            .args\n+            .iter()\n+            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n+            .nth(index) else { return false; };\n+        error.obligation.cause.span = arg\n+            .span()\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(arg.span());\n+        true\n+    }\n+\n+    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n+        &self,\n+        item_def_id: DefId,\n+        t: T,\n+    ) -> Option<ty::GenericArg<'tcx>> {\n+        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n+        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n+            type BreakTy = ty::GenericArg<'tcx>;\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n+                if let Some(origin) = self.0.type_var_origin(ty)\n+                    && let rustc_infer::infer::type_variable::TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n+                        origin.kind\n+                    && let generics = self.0.tcx.generics_of(self.1)\n+                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n+                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n+                        .get(index as usize)\n+                {\n+                    ControlFlow::Break(*subst)\n+                } else {\n+                    ty.super_visit_with(self)\n+                }\n+            }\n+        }\n+        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n+    }\n+\n+    fn closure_span_overlaps_error(\n+        &self,\n+        error: &traits::FulfillmentError<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        if let traits::FulfillmentErrorCode::CodeSelectionError(\n+            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n+        ) = error.code\n+            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n+            && span.overlaps(self.tcx.def_span(*def_id))\n+        {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_field_if_possible(\n+        &self,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        variant_def_id: DefId,\n+        expr_fields: &[hir::ExprField<'tcx>],\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n+        let def = self.tcx.adt_def(def_id);\n+\n+        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n+        let fields_referencing_param: Vec<_> = def\n+            .variant_with_id(variant_def_id)\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                let field_ty = field.ty(self.tcx, identity_substs);\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+            })\n+            .collect();\n+\n+        if let [field] = fields_referencing_param.as_slice() {\n+            for expr_field in expr_fields {\n+                // Look for the ExprField that matches the field, using the\n+                // same rules that check_expr_struct uses for macro hygiene.\n+                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n+                {\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        call_hir_id: hir::HirId,\n+        callee_span: Span,\n+        receiver: Option<&'tcx hir::Expr<'tcx>>,\n+        args: &'tcx [hir::Expr<'tcx>],\n+    ) -> bool {\n+        let ty = self.tcx.type_of(def_id);\n+        if !ty.is_fn() {\n+            return false;\n+        }\n+        let sig = ty.fn_sig(self.tcx).skip_binder();\n+        let args_referencing_param: Vec<_> = sig\n+            .inputs()\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .collect();\n+        // If there's one field that references the given generic, great!\n+        if let [(idx, _)] = args_referencing_param.as_slice()\n+            && let Some(arg) = receiver\n+                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n+            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n+            error.obligation.cause.map_code(|parent_code| {\n+                ObligationCauseCode::FunctionArgumentObligation {\n+                    arg_hir_id: arg.hir_id,\n+                    call_hir_id,\n+                    parent_code,\n+                }\n+            });\n+            return true;\n+        } else if args_referencing_param.len() > 0 {\n+            // If more than one argument applies, then point to the callee span at least...\n+            // We have chance to fix this up further in `point_at_generics_if_possible`\n+            error.obligation.cause.span = callee_span;\n+        }\n+\n+        false\n+    }\n+\n     /**\n      * Recursively searches for the most-specific blamable expression.\n      * For example, if you have a chain of constraints like:"}, {"sha": "2a1265600de8b32738e227b6670768c98af19401", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 369, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/cf7aa572798d1a1ab67e39e693062c2b52536463/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7aa572798d1a1ab67e39e693062c2b52536463/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=cf7aa572798d1a1ab67e39e693062c2b52536463", "patch": "@@ -26,7 +26,7 @@ use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, sym, Span};\n@@ -36,8 +36,6 @@ use std::iter;\n use std::mem;\n use std::slice;\n \n-use std::ops::ControlFlow;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1758,372 +1756,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_fulfillment_error_for_expr_obligation(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-    ) -> bool {\n-        let (traits::ExprItemObligation(def_id, hir_id, idx) | traits::ExprBindingObligation(def_id, _, hir_id, idx))\n-            = *error.obligation.cause.code().peel_derives() else { return false; };\n-        let hir = self.tcx.hir();\n-        let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n-\n-        let Some(unsubstituted_pred) =\n-            self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n-            else { return false; };\n-\n-        let generics = self.tcx.generics_of(def_id);\n-        let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n-            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n-            _ => ty::List::empty(),\n-        };\n-\n-        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n-            predicate_substs.types().find_map(|ty| {\n-                ty.walk().find_map(|arg| {\n-                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Param(param_ty) = ty.kind()\n-                        && matches(param_ty)\n-                    {\n-                        Some(arg)\n-                    } else {\n-                        None\n-                    }\n-                })\n-            })\n-        };\n-\n-        // Prefer generics that are local to the fn item, since these are likely\n-        // to be the cause of the unsatisfied predicate.\n-        let mut param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n-        });\n-        // Fall back to generic that isn't local to the fn item. This will come\n-        // from a trait or impl, for example.\n-        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n-                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n-        });\n-        // Finally, the `Self` parameter is possibly the reason that the predicate\n-        // is unsatisfied. This is less likely to be true for methods, because\n-        // method probe means that we already kinda check that the predicates due\n-        // to the `Self` type are true.\n-        let mut self_param_to_point_at =\n-            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n-\n-        // Finally, for ambiguity-related errors, we actually want to look\n-        // for a parameter that is the source of the inference type left\n-        // over in this predicate.\n-        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n-            fallback_param_to_point_at = None;\n-            self_param_to_point_at = None;\n-            param_to_point_at =\n-                self.find_ambiguous_parameter_in(def_id, error.root_obligation.predicate);\n-        }\n-\n-        if self.closure_span_overlaps_error(error, expr.span) {\n-            return false;\n-        }\n-\n-        match &expr.kind {\n-            hir::ExprKind::Path(qpath) => {\n-                if let hir::Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::Call(callee, args),\n-                    hir_id: call_hir_id,\n-                    span: call_span,\n-                    ..\n-                }) = hir.get_parent(expr.hir_id)\n-                    && callee.hir_id == expr.hir_id\n-                {\n-                    if self.closure_span_overlaps_error(error, *call_span) {\n-                        return false;\n-                    }\n-\n-                    for param in\n-                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                        .into_iter()\n-                        .flatten()\n-                    {\n-                        if self.blame_specific_arg_if_possible(\n-                                error,\n-                                def_id,\n-                                param,\n-                                *call_hir_id,\n-                                callee.span,\n-                                None,\n-                                args,\n-                            )\n-                        {\n-                            return true;\n-                        }\n-                    }\n-                }\n-                // Notably, we only point to params that are local to the\n-                // item we're checking, since those are the ones we are able\n-                // to look in the final `hir::PathSegment` for. Everything else\n-                // would require a deeper search into the `qpath` than I think\n-                // is worthwhile.\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n-                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                    .into_iter()\n-                    .flatten()\n-                {\n-                    if self.blame_specific_arg_if_possible(\n-                        error,\n-                        def_id,\n-                        param,\n-                        hir_id,\n-                        segment.ident.span,\n-                        Some(receiver),\n-                        args,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::ExprKind::Struct(qpath, fields, ..) => {\n-                if let Res::Def(DefKind::Struct | DefKind::Variant, variant_def_id) =\n-                    self.typeck_results.borrow().qpath_res(qpath, hir_id)\n-                {\n-                    for param in\n-                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                    {\n-                        if let Some(param) = param {\n-                            let refined_expr = self.point_at_field_if_possible(\n-                                def_id,\n-                                param,\n-                                variant_def_id,\n-                                fields,\n-                            );\n-\n-                            match refined_expr {\n-                                None => {}\n-                                Some((refined_expr, _)) => {\n-                                    error.obligation.cause.span = refined_expr\n-                                        .span\n-                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                                        .unwrap_or(refined_expr.span);\n-                                    return true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n-    fn closure_span_overlaps_error(\n-        &self,\n-        error: &traits::FulfillmentError<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        if let traits::FulfillmentErrorCode::CodeSelectionError(\n-            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n-        ) = error.code\n-            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n-            && span.overlaps(self.tcx.def_span(*def_id))\n-        {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n-    /// looking for the most-specific-possible span to blame.\n-    ///\n-    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n-    /// expression mentioned.\n-    ///\n-    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n-    /// the provided function call expression, and mark it as responsible for the fullfillment\n-    /// error.\n-    fn blame_specific_arg_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        call_hir_id: hir::HirId,\n-        callee_span: Span,\n-        receiver: Option<&'tcx hir::Expr<'tcx>>,\n-        args: &'tcx [hir::Expr<'tcx>],\n-    ) -> bool {\n-        let ty = self.tcx.type_of(def_id);\n-        if !ty.is_fn() {\n-            return false;\n-        }\n-        let sig = ty.fn_sig(self.tcx).skip_binder();\n-        let args_referencing_param: Vec<_> = sig\n-            .inputs()\n-            .iter()\n-            .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n-            .collect();\n-        // If there's one field that references the given generic, great!\n-        if let [(idx, _)] = args_referencing_param.as_slice()\n-            && let Some(arg) = receiver\n-                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n-\n-            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n-\n-            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n-                // This is more specific than pointing at the entire argument.\n-                self.blame_specific_expr_if_possible(error, arg_expr)\n-            }\n-\n-            error.obligation.cause.map_code(|parent_code| {\n-                ObligationCauseCode::FunctionArgumentObligation {\n-                    arg_hir_id: arg.hir_id,\n-                    call_hir_id,\n-                    parent_code,\n-                }\n-            });\n-            return true;\n-        } else if args_referencing_param.len() > 0 {\n-            // If more than one argument applies, then point to the callee span at least...\n-            // We have chance to fix this up further in `point_at_generics_if_possible`\n-            error.obligation.cause.span = callee_span;\n-        }\n-\n-        false\n-    }\n-\n-    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n-    pub fn point_at_field_if_possible(\n-        &self,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        variant_def_id: DefId,\n-        expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n-        let def = self.tcx.adt_def(def_id);\n-\n-        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n-        let fields_referencing_param: Vec<_> = def\n-            .variant_with_id(variant_def_id)\n-            .fields\n-            .iter()\n-            .filter(|field| {\n-                let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n-            })\n-            .collect();\n-\n-        if let [field] = fields_referencing_param.as_slice() {\n-            for expr_field in expr_fields {\n-                // Look for the ExprField that matches the field, using the\n-                // same rules that check_expr_struct uses for macro hygiene.\n-                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n-                {\n-                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn point_at_path_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param: ty::GenericArg<'tcx>,\n-        qpath: &QPath<'tcx>,\n-    ) -> bool {\n-        match qpath {\n-            hir::QPath::Resolved(_, path) => {\n-                if let Some(segment) = path.segments.last()\n-                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::QPath::TypeRelative(_, segment) => {\n-                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n-    fn point_at_generic_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        segment: &hir::PathSegment<'tcx>,\n-    ) -> bool {\n-        let own_substs = self\n-            .tcx\n-            .generics_of(def_id)\n-            .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n-        let Some((index, _)) = own_substs\n-            .iter()\n-            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n-            .enumerate()\n-            .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n-        let Some(arg) = segment\n-            .args()\n-            .args\n-            .iter()\n-            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n-            .nth(index) else { return false; };\n-        error.obligation.cause.span = arg\n-            .span()\n-            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-            .unwrap_or(arg.span());\n-        true\n-    }\n-\n-    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n-        &self,\n-        item_def_id: DefId,\n-        t: T,\n-    ) -> Option<ty::GenericArg<'tcx>> {\n-        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n-        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n-            type BreakTy = ty::GenericArg<'tcx>;\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-                if let Some(origin) = self.0.type_var_origin(ty)\n-                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n-                        origin.kind\n-                    && let generics = self.0.tcx.generics_of(self.1)\n-                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n-                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n-                        .get(index as usize)\n-                {\n-                    ControlFlow::Break(*subst)\n-                } else {\n-                    ty.super_visit_with(self)\n-                }\n-            }\n-        }\n-        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n-    }\n-\n     fn label_fn_like(\n         &self,\n         err: &mut Diagnostic,"}]}