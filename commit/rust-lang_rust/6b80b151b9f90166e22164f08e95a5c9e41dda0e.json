{"sha": "6b80b151b9f90166e22164f08e95a5c9e41dda0e", "node_id": "C_kwDOAAsO6NoAKDZiODBiMTUxYjlmOTAxNjZlMjIxNjRmMDhlOTVhNWM5ZTQxZGRhMGU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-03T15:10:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-03T15:10:52Z"}, "message": "Rollup merge of #97471 - estebank:prohibit-generics, r=cjgillot\n\nProvide more context when denying invalid type params", "tree": {"sha": "b2f3b63add7a51a252a9c2402d43a1c2e7b6548d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2f3b63add7a51a252a9c2402d43a1c2e7b6548d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b80b151b9f90166e22164f08e95a5c9e41dda0e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJimiR9CRBK7hj4Ov3rIwAAuSAIAJMfp8wFpe/N7nVyAePT/up/\nuMdG9xKNVkuf85zRxiB4O8yGUl7FwgpUrlG2NCUFF7sma19yx/QBq7MHOZ9y4+9W\nxGO1Vt9Sz7Oaex9l/sxtKLmcL6RIlOMUtZWdOoOScWTKBabG3xpmQsH/BlGWyETp\nXXtJPZLzOXijA8dCwxQvhfSDaAEi6bt7TJDFUYVWOjvOo6Qy7zhg+lnJeS2pRDGe\nTxwpFii/cxz4fgbHs8uJVyJprQPngQPyBH9LERfWAuZQi8YnqhLvxploHLXltUBe\n3HVG90Tbieyx8A7jkCWKlEKE7cWaUF06pRokZP39zRh0rrrCudEGFhBm8HI8EFw=\n=6e+G\n-----END PGP SIGNATURE-----\n", "payload": "tree b2f3b63add7a51a252a9c2402d43a1c2e7b6548d\nparent 53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69\nparent cd8cfbfb098f8e1da086ee7d164af03e3fdde189\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1654269052 +0200\ncommitter GitHub <noreply@github.com> 1654269052 +0200\n\nRollup merge of #97471 - estebank:prohibit-generics, r=cjgillot\n\nProvide more context when denying invalid type params\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b80b151b9f90166e22164f08e95a5c9e41dda0e", "html_url": "https://github.com/rust-lang/rust/commit/6b80b151b9f90166e22164f08e95a5c9e41dda0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b80b151b9f90166e22164f08e95a5c9e41dda0e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "html_url": "https://github.com/rust-lang/rust/commit/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69"}, {"sha": "cd8cfbfb098f8e1da086ee7d164af03e3fdde189", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd8cfbfb098f8e1da086ee7d164af03e3fdde189", "html_url": "https://github.com/rust-lang/rust/commit/cd8cfbfb098f8e1da086ee7d164af03e3fdde189"}], "stats": {"total": 1313, "additions": 998, "deletions": 315}, "files": [{"sha": "bcff2ae51290932fb4df6995be917329f25e6bd7", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 287, "deletions": 77, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -16,7 +16,7 @@ use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError,\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, Const, DefIdTree, EarlyBinder, Ty, TyCtxt, TypeFold\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n@@ -653,7 +653,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             span, item_def_id, item_segment\n         );\n         if tcx.generics_of(item_def_id).params.is_empty() {\n-            self.prohibit_generics(slice::from_ref(item_segment));\n+            self.prohibit_generics(slice::from_ref(item_segment).iter(), |_| {});\n \n             parent_substs\n         } else {\n@@ -681,7 +681,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n \n         self.ast_path_to_mono_trait_ref(\n             trait_ref.path.span,\n@@ -784,7 +784,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let args = trait_segment.args();\n         let infer_args = trait_segment.infer_args;\n \n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, false);\n \n         self.instantiate_poly_trait_ref_inner(\n@@ -1776,12 +1776,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         hir_ref_id: hir::HirId,\n         span: Span,\n         qself_ty: Ty<'tcx>,\n-        qself_res: Res,\n+        qself: &hir::Ty<'_>,\n         assoc_segment: &hir::PathSegment<'_>,\n         permit_variants: bool,\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorGuaranteed> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n+        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+            path.res\n+        } else {\n+            Res::Err\n+        };\n \n         debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n \n@@ -1796,7 +1801,87 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span, None);\n-                        self.prohibit_generics(slice::from_ref(assoc_segment));\n+                        self.prohibit_generics(slice::from_ref(assoc_segment).iter(), |err| {\n+                            err.note(\"enum variants can't have type parameters\");\n+                            let type_name = tcx.item_name(adt_def.did());\n+                            let msg = format!(\n+                                \"you might have meant to specity type parameters on enum \\\n+                                 `{type_name}`\"\n+                            );\n+                            let Some(args) = assoc_segment.args else { return; };\n+                            // Get the span of the generics args *including* the leading `::`.\n+                            let args_span = assoc_segment.ident.span.shrink_to_hi().to(args.span_ext);\n+                            if tcx.generics_of(adt_def.did()).count() == 0 {\n+                                // FIXME(estebank): we could also verify that the arguments being\n+                                // work for the `enum`, instead of just looking if it takes *any*.\n+                                err.span_suggestion_verbose(\n+                                    args_span,\n+                                    &format!(\"{type_name} doesn't have generic parameters\"),\n+                                    String::new(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return;\n+                            }\n+                            let Ok(snippet) = tcx.sess.source_map().span_to_snippet(args_span) else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n+                                hir::QPath::Resolved(_, ref path)\n+                            ) = qself.kind {\n+                                // If the path segment already has type params, we want to overwrite\n+                                // them.\n+                                match &path.segments[..] {\n+                                    // `segment` is the previous to last element on the path,\n+                                    // which would normally be the `enum` itself, while the last\n+                                    // `_` `PathSegment` corresponds to the variant.\n+                                    [.., hir::PathSegment {\n+                                        ident,\n+                                        args,\n+                                        res: Some(Res::Def(DefKind::Enum, _)),\n+                                        ..\n+                                    }, _] => (\n+                                        // We need to include the `::` in `Type::Variant::<Args>`\n+                                        // to point the span to `::<Args>`, not just `<Args>`.\n+                                        ident.span.shrink_to_hi().to(args.map_or(\n+                                            ident.span.shrink_to_hi(),\n+                                            |a| a.span_ext)),\n+                                        false,\n+                                    ),\n+                                    [segment] => (\n+                                        // We need to include the `::` in `Type::Variant::<Args>`\n+                                        // to point the span to `::<Args>`, not just `<Args>`.\n+                                        segment.ident.span.shrink_to_hi().to(segment.args.map_or(\n+                                            segment.ident.span.shrink_to_hi(),\n+                                            |a| a.span_ext)),\n+                                        kw::SelfUpper == segment.ident.name,\n+                                    ),\n+                                    _ => {\n+                                        err.note(&msg);\n+                                        return;\n+                                    }\n+                                }\n+                            } else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let suggestion = vec![\n+                                if is_self {\n+                                    // Account for people writing `Self::Variant::<Args>`, where\n+                                    // `Self` is the enum, and suggest replacing `Self` with the\n+                                    // appropriate type: `Type::<Args>::Variant`.\n+                                    (qself.span, format!(\"{type_name}{snippet}\"))\n+                                } else {\n+                                    (qself_sugg_span, snippet)\n+                                },\n+                                (args_span, String::new()),\n+                            ];\n+                            err.multipart_suggestion_verbose(\n+                                &msg,\n+                                suggestion,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        });\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n                         variant_resolution = Some(variant_def.def_id);\n@@ -2017,69 +2102,112 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment<'a>>>(\n+    pub fn prohibit_generics<'a>(\n         &self,\n-        segments: T,\n+        segments: impl Iterator<Item = &'a hir::PathSegment<'a>> + Clone,\n+        extend: impl Fn(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n     ) -> bool {\n-        let mut has_err = false;\n-        for segment in segments {\n-            let (mut err_for_lt, mut err_for_ty, mut err_for_ct) = (false, false, false);\n-            for arg in segment.args().args {\n-                let (span, kind) = match arg {\n-                    hir::GenericArg::Lifetime(lt) => {\n-                        if err_for_lt {\n-                            continue;\n-                        }\n-                        err_for_lt = true;\n-                        has_err = true;\n-                        (lt.span, \"lifetime\")\n-                    }\n-                    hir::GenericArg::Type(ty) => {\n-                        if err_for_ty {\n-                            continue;\n-                        }\n-                        err_for_ty = true;\n-                        has_err = true;\n-                        (ty.span, \"type\")\n-                    }\n-                    hir::GenericArg::Const(ct) => {\n-                        if err_for_ct {\n-                            continue;\n-                        }\n-                        err_for_ct = true;\n-                        has_err = true;\n-                        (ct.span, \"const\")\n-                    }\n-                    hir::GenericArg::Infer(inf) => {\n-                        if err_for_ty {\n-                            continue;\n-                        }\n-                        has_err = true;\n-                        err_for_ty = true;\n-                        (inf.span, \"generic\")\n+        let args = segments.clone().flat_map(|segment| segment.args().args);\n+        let types_and_spans: Vec<_> = segments\n+            .clone()\n+            .flat_map(|segment| {\n+                segment.res.and_then(|res| {\n+                    if segment.args().args.is_empty() {\n+                        None\n+                    } else {\n+                        Some((\n+                            match res {\n+                                Res::PrimTy(ty) => format!(\"{} `{}`\", res.descr(), ty.name()),\n+                                Res::Def(_, def_id)\n+                                if let Some(name) = self.tcx().opt_item_name(def_id) => {\n+                                    format!(\"{} `{name}`\", res.descr())\n+                                }\n+                                Res::Err => \"this type\".to_string(),\n+                                _ => res.descr().to_string(),\n+                            },\n+                            segment.ident.span,\n+                        ))\n                     }\n-                };\n-                let mut err = struct_span_err!(\n-                    self.tcx().sess,\n-                    span,\n-                    E0109,\n-                    \"{} arguments are not allowed for this type\",\n-                    kind,\n-                );\n-                err.span_label(span, format!(\"{} argument not allowed\", kind));\n-                err.emit();\n-                if err_for_lt && err_for_ty && err_for_ct {\n-                    break;\n-                }\n+                })\n+            })\n+            .collect();\n+        let this_type = match &types_and_spans[..] {\n+            [.., _, (last, _)] => format!(\n+                \"{} and {last}\",\n+                types_and_spans[..types_and_spans.len() - 1]\n+                    .iter()\n+                    .map(|(x, _)| x.as_str())\n+                    .intersperse(&\", \")\n+                    .collect::<String>()\n+            ),\n+            [(only, _)] => only.to_string(),\n+            [] => \"this type\".to_string(),\n+        };\n+\n+        let (lt, ty, ct, inf) =\n+            args.clone().fold((false, false, false, false), |(lt, ty, ct, inf), arg| match arg {\n+                hir::GenericArg::Lifetime(_) => (true, ty, ct, inf),\n+                hir::GenericArg::Type(_) => (lt, true, ct, inf),\n+                hir::GenericArg::Const(_) => (lt, ty, true, inf),\n+                hir::GenericArg::Infer(_) => (lt, ty, ct, true),\n+            });\n+        let mut emitted = false;\n+        if lt || ty || ct || inf {\n+            let arg_spans: Vec<Span> = args.map(|arg| arg.span()).collect();\n+\n+            let mut kinds = Vec::with_capacity(4);\n+            if lt {\n+                kinds.push(\"lifetime\");\n+            }\n+            if ty {\n+                kinds.push(\"type\");\n+            }\n+            if ct {\n+                kinds.push(\"const\");\n             }\n+            if inf {\n+                kinds.push(\"generic\");\n+            }\n+            let (kind, s) = match kinds[..] {\n+                [.., _, last] => (\n+                    format!(\n+                        \"{} and {last}\",\n+                        kinds[..kinds.len() - 1]\n+                            .iter()\n+                            .map(|&x| x)\n+                            .intersperse(\", \")\n+                            .collect::<String>()\n+                    ),\n+                    \"s\",\n+                ),\n+                [only] => (format!(\"{only}\"), \"\"),\n+                [] => unreachable!(),\n+            };\n+            let last_span = *arg_spans.last().unwrap();\n+            let span: MultiSpan = arg_spans.into();\n+            let mut err = struct_span_err!(\n+                self.tcx().sess,\n+                span,\n+                E0109,\n+                \"{kind} arguments are not allowed on {this_type}\",\n+            );\n+            err.span_label(last_span, format!(\"{kind} argument{s} not allowed\"));\n+            for (_, span) in types_and_spans {\n+                err.span_label(span, \"not allowed on this\");\n+            }\n+            extend(&mut err);\n+            err.emit();\n+            emitted = true;\n+        }\n \n+        for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let [binding, ..] = segment.args().bindings {\n-                has_err = true;\n                 Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n+                return true;\n             }\n         }\n-        has_err\n+        emitted\n     }\n \n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n@@ -2229,7 +2357,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n-                self.prohibit_generics(item_segment.1);\n+                self.prohibit_generics(item_segment.1.iter(), |err| {\n+                    err.note(\"`impl Trait` types can't have type parameters\");\n+                });\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n                 self.normalize_ty(span, tcx.mk_opaque(did, substs))\n             }\n@@ -2242,7 +2372,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 did,\n             ) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1.iter(), |_| {});\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Res::Def(kind @ DefKind::Variant, def_id) if permit_variants => {\n@@ -2254,18 +2384,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n-                self.prohibit_generics(path.segments.iter().enumerate().filter_map(\n-                    |(index, seg)| {\n+                self.prohibit_generics(\n+                    path.segments.iter().enumerate().filter_map(|(index, seg)| {\n                         if !generic_segs.contains(&index) { Some(seg) } else { None }\n+                    }),\n+                    |err| {\n+                        err.note(\"enum variants can't have type parameters\");\n                     },\n-                ));\n+                );\n \n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n             Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    if let Some(span) = tcx.def_ident_span(def_id) {\n+                        let name = tcx.item_name(def_id);\n+                        err.span_note(span, &format!(\"type parameter `{name}` defined here\"));\n+                    }\n+                });\n \n                 let def_id = def_id.expect_local();\n                 let item_def_id = tcx.hir().ty_param_owner(def_id);\n@@ -2276,15 +2414,81 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::SelfTy { trait_: Some(_), alias_to: None } => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments[..] {\n+                        err.span_suggestion_verbose(\n+                            ident.span.shrink_to_hi().to(args.span_ext),\n+                            \"the `Self` type doesn't accept type parameters\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                });\n                 tcx.types.self_param\n             }\n             Res::SelfTy { trait_: _, alias_to: Some((def_id, forbid_generic)) } => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n                 // Try to evaluate any array length constants.\n                 let ty = tcx.at(span).type_of(def_id);\n+                let span_of_impl = tcx.span_of_impl(def_id);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    let def_id = match *ty.kind() {\n+                        ty::Adt(self_def, _) => self_def.did(),\n+                        _ => return,\n+                    };\n+\n+                    let type_name = tcx.item_name(def_id);\n+                    let span_of_ty = tcx.def_ident_span(def_id);\n+                    let generics = tcx.generics_of(def_id).count();\n+\n+                    let msg = format!(\"`Self` is of type `{ty}`\");\n+                    if let (Ok(i_sp), Some(t_sp)) = (span_of_impl, span_of_ty) {\n+                        let i_sp = tcx.sess.source_map().guess_head_span(i_sp);\n+                        let mut span: MultiSpan = vec![t_sp].into();\n+                        span.push_span_label(\n+                            i_sp,\n+                            &format!(\"`Self` is on type `{type_name}` in this `impl`\"),\n+                        );\n+                        let mut postfix = \"\";\n+                        if generics == 0 {\n+                            postfix = \", which doesn't have generic parameters\";\n+                        }\n+                        span.push_span_label(\n+                            t_sp,\n+                            &format!(\"`Self` corresponds to this type{postfix}\"),\n+                        );\n+                        err.span_note(span, &msg);\n+                    } else {\n+                        err.note(&msg);\n+                    }\n+                    for segment in path.segments {\n+                        if let Some(args) = segment.args && segment.ident.name == kw::SelfUpper {\n+                            if generics == 0 {\n+                                // FIXME(estebank): we could also verify that the arguments being\n+                                // work for the `enum`, instead of just looking if it takes *any*.\n+                                err.span_suggestion_verbose(\n+                                    segment.ident.span.shrink_to_hi().to(args.span_ext),\n+                                    \"the `Self` type doesn't accept type parameters\",\n+                                    String::new(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return;\n+                            } else {\n+                                err.span_suggestion_verbose(\n+                                    segment.ident.span,\n+                                    format!(\n+                                        \"the `Self` type doesn't accept type parameters, use the \\\n+                                        concrete type's name `{type_name}` instead if you want to \\\n+                                        specify its type parameters\"\n+                                    ),\n+                                    type_name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                    }\n+                });\n                 // HACK(min_const_generics): Forbid generic `Self` types\n                 // here as we can't easily do that during nameres.\n                 //\n@@ -2324,7 +2528,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n-                self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n+                self.prohibit_generics(path.segments[..path.segments.len() - 2].iter(), |_| {});\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n@@ -2335,7 +2539,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    let name = prim_ty.name_str();\n+                    for segment in path.segments {\n+                        if let Some(args) = segment.args {\n+                            err.span_suggestion_verbose(\n+                                segment.ident.span.shrink_to_hi().to(args.span_ext),\n+                                &format!(\"primitive type `{name}` doesn't have generic parameters\"),\n+                                String::new(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                });\n                 match prim_ty {\n                     hir::PrimTy::Bool => tcx.types.bool,\n                     hir::PrimTy::Char => tcx.types.char,\n@@ -2426,13 +2642,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n-\n-                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n-                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, res, segment, false)\n+                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }"}, {"sha": "c28c041e78dff9c9709211b3f784363cfd417f2f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1228,6 +1228,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     None\n                 }\n             }),\n+            |_| {},\n         );\n \n         if let Res::Local(hid) = res {"}, {"sha": "83afbfa54b1dda8dbe272df87ffb2045d8901990", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1564,13 +1564,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n                 let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty, res, segment, true,\n+                    self, hir_id, path_span, ty, qself, segment, true,\n                 );\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));"}, {"sha": "6f0e4d55aeb0432f33146021b8a866cc3267cf6e", "filename": "src/test/ui/derives/issue-97343.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fderives%2Fissue-97343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fderives%2Fissue-97343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-97343.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Debug;\n \n #[derive(Debug)]\n-pub struct Irrelevant<Irrelevant> { //~ ERROR type arguments are not allowed for this type\n+pub struct Irrelevant<Irrelevant> { //~ ERROR type arguments are not allowed on type parameter\n     irrelevant: Irrelevant,\n }\n "}, {"sha": "ac797a8f50152e0c4a8cab24419255d44c28504b", "filename": "src/test/ui/derives/issue-97343.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fderives%2Fissue-97343.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fderives%2Fissue-97343.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-97343.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,11 +1,19 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on type parameter `Irrelevant`\n   --> $DIR/issue-97343.rs:4:23\n    |\n LL | #[derive(Debug)]\n-   |          ----- in this derive macro expansion\n+   |          -----\n+   |          |\n+   |          not allowed on this\n+   |          in this derive macro expansion\n LL | pub struct Irrelevant<Irrelevant> {\n    |                       ^^^^^^^^^^ type argument not allowed\n    |\n+note: type parameter `Irrelevant` defined here\n+  --> $DIR/issue-97343.rs:4:23\n+   |\n+LL | pub struct Irrelevant<Irrelevant> {\n+   |                       ^^^^^^^^^^\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "e0e437e18ae8c6a4b9c93c9ce4a48501fbcd416a", "filename": "src/test/ui/error-codes/E0109.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,16 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/E0109.rs:1:14\n    |\n LL | type X = u32<i32>;\n-   |              ^^^ type argument not allowed\n+   |          --- ^^^ type argument not allowed\n+   |          |\n+   |          not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n+   |\n+LL - type X = u32<i32>;\n+LL + type X = u32;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "15e1b959193fae7cdd99407326d20d13af060134", "filename": "src/test/ui/error-codes/E0110.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,16 @@\n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/E0110.rs:1:14\n    |\n LL | type X = u32<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+   |          --- ^^^^^^^ lifetime argument not allowed\n+   |          |\n+   |          not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n+   |\n+LL - type X = u32<'static>;\n+LL + type X = u32;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "bb8a58d3d2ecc63c36340bff5de941e6379f08ca", "filename": "src/test/ui/issues/issue-22706.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,3 +1,3 @@\n fn is_copy<T: ::std::marker<i32>::Copy>() {}\n-//~^ ERROR type arguments are not allowed for this type [E0109]\n+//~^ ERROR type arguments are not allowed on module `marker` [E0109]\n fn main() {}"}, {"sha": "66911f081d76cd74f2e2ec78f717e7b4dbcb7a62", "filename": "src/test/ui/issues/issue-22706.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on module `marker`\n   --> $DIR/issue-22706.rs:1:29\n    |\n LL | fn is_copy<T: ::std::marker<i32>::Copy>() {}\n-   |                             ^^^ type argument not allowed\n+   |                      ------ ^^^ type argument not allowed\n+   |                      |\n+   |                      not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "8846912a8ff79bb11d6daeda27101d845d4f61cd", "filename": "src/test/ui/issues/issue-57924.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -3,7 +3,7 @@ pub struct Gcm<E>(E);\n impl<E> Gcm<E> {\n     pub fn crash(e: E) -> Self {\n         Self::<E>(e)\n-        //~^ ERROR type arguments are not allowed for this type\n+        //~^ ERROR type arguments are not allowed on self constructor\n     }\n }\n "}, {"sha": "211b0dde48c2e24046245cfe994138bd1257970b", "filename": "src/test/ui/issues/issue-57924.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self constructor\n   --> $DIR/issue-57924.rs:5:16\n    |\n LL |         Self::<E>(e)\n-   |                ^ type argument not allowed\n+   |         ----   ^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "29db3fdb47104815247640c37fcb33494f3325b1", "filename": "src/test/ui/issues/issue-60989.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -10,9 +10,9 @@ impl From<A> for B {\n fn main() {\n     let c1 = ();\n     c1::<()>;\n-    //~^ ERROR type arguments are not allowed for this type\n+    //~^ ERROR type arguments are not allowed on local variable\n \n     let c1 = A {};\n     c1::<dyn Into<B>>;\n-    //~^ ERROR type arguments are not allowed for this type\n+    //~^ ERROR type arguments are not allowed on local variable\n }"}, {"sha": "9076f4f9385ba178073a6f532423ec9c7cd31876", "filename": "src/test/ui/issues/issue-60989.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,14 +1,18 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on local variable\n   --> $DIR/issue-60989.rs:12:10\n    |\n LL |     c1::<()>;\n-   |          ^^ type argument not allowed\n+   |     --   ^^ type argument not allowed\n+   |     |\n+   |     not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on local variable\n   --> $DIR/issue-60989.rs:16:10\n    |\n LL |     c1::<dyn Into<B>>;\n-   |          ^^^^^^^^^^^ type argument not allowed\n+   |     --   ^^^^^^^^^^^ type argument not allowed\n+   |     |\n+   |     not allowed on this\n \n error: aborting due to 2 previous errors\n "}, {"sha": "959024c46f4ffe601e9e52c22b822f65abe15dbc", "filename": "src/test/ui/mod-subitem-as-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -5,5 +5,5 @@ mod Mod {\n fn main() {\n     Mod::FakeVariant::<i32>(0);\n     Mod::<i32>::FakeVariant(0);\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on module `Mod` [E0109]\n }"}, {"sha": "15da1d155a337fc17a2a26a3fa81ba91f350dfae", "filename": "src/test/ui/mod-subitem-as-enum-variant.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on module `Mod`\n   --> $DIR/mod-subitem-as-enum-variant.rs:7:11\n    |\n LL |     Mod::<i32>::FakeVariant(0);\n-   |           ^^^ type argument not allowed\n+   |     ---   ^^^ type argument not allowed\n+   |     |\n+   |     not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "f88572f8419c03a1590888658bc41458bb5d6100", "filename": "src/test/ui/structs/struct-path-associated-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -13,7 +13,7 @@ fn f<T: Tr>() {\n     //~^ ERROR expected struct, variant or union type, found associated type\n     let z = T::A::<u8> {};\n     //~^ ERROR expected struct, variant or union type, found associated type\n-    //~| ERROR type arguments are not allowed for this type\n+    //~| ERROR type arguments are not allowed on this type\n     match S {\n         T::A {} => {}\n         //~^ ERROR expected struct, variant or union type, found associated type\n@@ -22,7 +22,7 @@ fn f<T: Tr>() {\n \n fn g<T: Tr<A = S>>() {\n     let s = T::A {}; // OK\n-    let z = T::A::<u8> {}; //~ ERROR type arguments are not allowed for this type\n+    let z = T::A::<u8> {}; //~ ERROR type arguments are not allowed on this type\n     match S {\n         T::A {} => {} // OK\n     }"}, {"sha": "7424ceecbe3b63195ab9f00da7dcae7606ad8ac7", "filename": "src/test/ui/structs/struct-path-associated-type.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -4,11 +4,13 @@ error[E0071]: expected struct, variant or union type, found associated type\n LL |     let s = T::A {};\n    |             ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/struct-path-associated-type.rs:14:20\n    |\n LL |     let z = T::A::<u8> {};\n-   |                    ^^ type argument not allowed\n+   |                -   ^^ type argument not allowed\n+   |                |\n+   |                not allowed on this\n \n error[E0071]: expected struct, variant or union type, found associated type\n   --> $DIR/struct-path-associated-type.rs:14:13\n@@ -22,11 +24,13 @@ error[E0071]: expected struct, variant or union type, found associated type\n LL |         T::A {} => {}\n    |         ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/struct-path-associated-type.rs:25:20\n    |\n LL |     let z = T::A::<u8> {};\n-   |                    ^^ type argument not allowed\n+   |                -   ^^ type argument not allowed\n+   |                |\n+   |                not allowed on this\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:32:13"}, {"sha": "6e529c7ed2b70c417fc56fafb4a54f9e01fe1613", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -6,7 +6,7 @@ trait Tr {\n         //~^ ERROR expected struct, variant or union type, found type parameter\n         let z = Self::<u8> {};\n         //~^ ERROR expected struct, variant or union type, found type parameter\n-        //~| ERROR type arguments are not allowed for this type\n+        //~| ERROR type arguments are not allowed on self type\n         match s {\n             Self { .. } => {}\n             //~^ ERROR expected struct, variant or union type, found type parameter\n@@ -17,7 +17,7 @@ trait Tr {\n impl Tr for S {\n     fn f() {\n         let s = Self {}; // OK\n-        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed for this type\n+        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on self type\n         match s {\n             Self { .. } => {} // OK\n         }\n@@ -27,7 +27,7 @@ impl Tr for S {\n impl S {\n     fn g() {\n         let s = Self {}; // OK\n-        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed for this type\n+        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on self type\n         match s {\n             Self { .. } => {} // OK\n         }"}, {"sha": "cccdd7b0f023ff938575e152b3e88af51fdd60ec", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -4,11 +4,19 @@ error[E0071]: expected struct, variant or union type, found type parameter `Self\n LL |         let s = Self {};\n    |                 ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/struct-path-self.rs:7:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type argument not allowed\n+   |                 ----   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error[E0071]: expected struct, variant or union type, found type parameter `Self`\n   --> $DIR/struct-path-self.rs:7:17\n@@ -22,17 +30,49 @@ error[E0071]: expected struct, variant or union type, found type parameter `Self\n LL |             Self { .. } => {}\n    |             ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/struct-path-self.rs:20:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type argument not allowed\n+   |                 ----   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+note: `Self` is of type `S`\n+  --> $DIR/struct-path-self.rs:1:8\n+   |\n+LL | struct S;\n+   |        ^ `Self` corresponds to this type, which doesn't have generic parameters\n+...\n+LL | impl Tr for S {\n+   | ------------- `Self` is on type `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/struct-path-self.rs:30:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type argument not allowed\n+   |                 ----   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+note: `Self` is of type `S`\n+  --> $DIR/struct-path-self.rs:1:8\n+   |\n+LL | struct S;\n+   |        ^ `Self` corresponds to this type, which doesn't have generic parameters\n+...\n+LL | impl S {\n+   | ------ `Self` is on type `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error: aborting due to 6 previous errors\n "}, {"sha": "e6f45036f8514fcd8b59e16fcd4674bbdf5577b8", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-generic-args.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -13,93 +13,93 @@ impl<T> Enum<T> {\n         Self::TSVariant(());\n         //~^ ERROR mismatched types [E0308]\n         Self::TSVariant::<()>(());\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on this type [E0109]\n         Self::<()>::TSVariant(());\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n         //~| ERROR mismatched types [E0308]\n         Self::<()>::TSVariant::<()>(());\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n-        //~| ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n+        //~| ERROR type arguments are not allowed on this type [E0109]\n     }\n \n     fn s_variant() {\n         Self::SVariant { v: () };\n         //~^ ERROR mismatched types [E0308]\n         Self::SVariant::<()> { v: () };\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on this type [E0109]\n         //~| ERROR mismatched types [E0308]\n         Self::<()>::SVariant { v: () };\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n         //~| ERROR mismatched types [E0308]\n         Self::<()>::SVariant::<()> { v: () };\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n-        //~| ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n+        //~| ERROR type arguments are not allowed on this type [E0109]\n         //~| ERROR mismatched types [E0308]\n     }\n \n     fn u_variant() {\n         Self::UVariant::<()>;\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on this type [E0109]\n         Self::<()>::UVariant;\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n         Self::<()>::UVariant::<()>;\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n-        //~| ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n+        //~| ERROR type arguments are not allowed on this type [E0109]\n     }\n }\n \n fn main() {\n     // Tuple struct variant\n \n     Enum::<()>::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     Alias::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     Alias::<()>::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     AliasFixed::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     AliasFixed::<()>::TSVariant(());\n     //~^ ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n     AliasFixed::<()>::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     //~| ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n \n     // Struct variant\n \n     Enum::<()>::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     Alias::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     Alias::<()>::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     AliasFixed::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     AliasFixed::<()>::SVariant { v: () };\n     //~^ ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n     AliasFixed::<()>::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     //~| ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n \n     // Unit variant\n \n     Enum::<()>::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     Alias::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     Alias::<()>::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     AliasFixed::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     AliasFixed::<()>::UVariant;\n     //~^ ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n     AliasFixed::<()>::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     //~| ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n }"}, {"sha": "3e60ab108a82fc8fda4488d83150a4b6f1c286fb", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-generic-args.stderr", "status": "modified", "additions": 230, "deletions": 54, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -17,17 +17,34 @@ note: tuple variant defined here\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |                ^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:15:27\n    |\n LL |         Self::TSVariant::<()>(());\n-   |                           ^^ type argument not allowed\n+   |               ---------   ^^ type argument not allowed\n+   |               |\n+   |               not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:17:16\n    |\n LL |         Self::<()>::TSVariant(());\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::TSVariant(());\n+   |         ~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:17:31\n@@ -48,17 +65,34 @@ note: tuple variant defined here\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |                ^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:20:16\n    |\n LL |         Self::<()>::TSVariant::<()>(());\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::TSVariant::<()>(());\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:20:33\n    |\n LL |         Self::<()>::TSVariant::<()>(());\n-   |                                 ^^ type argument not allowed\n+   |                     ---------   ^^ type argument not allowed\n+   |                     |\n+   |                     not allowed on this\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:26:29\n@@ -72,11 +106,20 @@ LL |         Self::SVariant { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:28:26\n    |\n LL |         Self::SVariant::<()> { v: () };\n-   |                          ^^ type argument not allowed\n+   |               --------   ^^ type argument not allowed\n+   |               |\n+   |               not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -         Self::SVariant::<()> { v: () };\n+LL +         Enum::<()>::SVariant { v: () };\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:28:35\n@@ -90,11 +133,26 @@ LL |         Self::SVariant::<()> { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:31:16\n    |\n LL |         Self::<()>::SVariant { v: () };\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::SVariant { v: () };\n+   |         ~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:31:35\n@@ -108,17 +166,41 @@ LL |         Self::<()>::SVariant { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:34:16\n    |\n LL |         Self::<()>::SVariant::<()> { v: () };\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::SVariant::<()> { v: () };\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:34:32\n    |\n LL |         Self::<()>::SVariant::<()> { v: () };\n-   |                                ^^ type argument not allowed\n+   |                     --------   ^^ type argument not allowed\n+   |                     |\n+   |                     not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -         Self::<()>::SVariant::<()> { v: () };\n+LL +         Enum::<()>::SVariant { v: () };\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:34:41\n@@ -132,53 +214,95 @@ LL |         Self::<()>::SVariant::<()> { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:41:26\n    |\n LL |         Self::UVariant::<()>;\n-   |                          ^^ type argument not allowed\n+   |               --------   ^^ type argument not allowed\n+   |               |\n+   |               not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:43:16\n    |\n LL |         Self::<()>::UVariant;\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::UVariant;\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:45:16\n    |\n LL |         Self::<()>::UVariant::<()>;\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::UVariant::<()>;\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:45:32\n    |\n LL |         Self::<()>::UVariant::<()>;\n-   |                                ^^ type argument not allowed\n+   |                     --------   ^^ type argument not allowed\n+   |                     |\n+   |                     not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:54:29\n    |\n LL |     Enum::<()>::TSVariant::<()>(());\n-   |                             ^^ type argument not allowed\n+   |                 ---------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:57:24\n    |\n LL |     Alias::TSVariant::<()>(());\n-   |                        ^^ type argument not allowed\n+   |            ---------   ^^ type argument not allowed\n+   |            |\n+   |            not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:59:30\n    |\n LL |     Alias::<()>::TSVariant::<()>(());\n-   |                              ^^ type argument not allowed\n+   |                  ---------   ^^ type argument not allowed\n+   |                  |\n+   |                  not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:62:29\n    |\n LL |     AliasFixed::TSVariant::<()>(());\n-   |                             ^^ type argument not allowed\n+   |                 ---------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:64:5\n@@ -208,35 +332,68 @@ note: type alias defined here, with 0 generic parameters\n LL | type AliasFixed = Enum<()>;\n    |      ^^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:66:35\n    |\n LL |     AliasFixed::<()>::TSVariant::<()>(());\n-   |                                   ^^ type argument not allowed\n+   |                       ---------   ^^ type argument not allowed\n+   |                       |\n+   |                       not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:72:28\n    |\n LL |     Enum::<()>::SVariant::<()> { v: () };\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:75:23\n    |\n LL |     Alias::SVariant::<()> { v: () };\n-   |                       ^^ type argument not allowed\n+   |            --------   ^^ type argument not allowed\n+   |            |\n+   |            not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     Alias::SVariant::<()> { v: () };\n+LL +     Alias::<()>::SVariant { v: () };\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:77:29\n    |\n LL |     Alias::<()>::SVariant::<()> { v: () };\n-   |                             ^^ type argument not allowed\n+   |                  --------   ^^ type argument not allowed\n+   |                  |\n+   |                  not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     Alias::<()>::SVariant::<()> { v: () };\n+LL +     Alias::<()>::SVariant { v: () };\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:80:28\n    |\n LL |     AliasFixed::SVariant::<()> { v: () };\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     AliasFixed::SVariant::<()> { v: () };\n+LL +     AliasFixed::<()>::SVariant { v: () };\n+   | \n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:82:5\n@@ -266,35 +423,52 @@ note: type alias defined here, with 0 generic parameters\n LL | type AliasFixed = Enum<()>;\n    |      ^^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:84:34\n    |\n LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n-   |                                  ^^ type argument not allowed\n+   |                       --------   ^^ type argument not allowed\n+   |                       |\n+   |                       not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     AliasFixed::<()>::SVariant::<()> { v: () };\n+LL +     AliasFixed::<()>::SVariant { v: () };\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:90:28\n    |\n LL |     Enum::<()>::UVariant::<()>;\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:93:23\n    |\n LL |     Alias::UVariant::<()>;\n-   |                       ^^ type argument not allowed\n+   |            --------   ^^ type argument not allowed\n+   |            |\n+   |            not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:95:29\n    |\n LL |     Alias::<()>::UVariant::<()>;\n-   |                             ^^ type argument not allowed\n+   |                  --------   ^^ type argument not allowed\n+   |                  |\n+   |                  not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:98:28\n    |\n LL |     AliasFixed::UVariant::<()>;\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:100:5\n@@ -324,11 +498,13 @@ note: type alias defined here, with 0 generic parameters\n LL | type AliasFixed = Enum<()>;\n    |      ^^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:102:34\n    |\n LL |     AliasFixed::<()>::UVariant::<()>;\n-   |                                  ^^ type argument not allowed\n+   |                       --------   ^^ type argument not allowed\n+   |                       |\n+   |                       not allowed on this\n \n error: aborting due to 39 previous errors\n "}, {"sha": "872ece0c0f99e4d1dedd99601c33b995ca7b1848", "filename": "src/test/ui/type-alias-enum-variants/no-type-application-on-aliased-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let _ = Option::<u8>::None; // OK\n     let _ = Option::None::<u8>; // OK (Lint in future!)\n     let _ = Alias::<u8>::None; // OK\n-    let _ = Alias::None::<u8>; //~ ERROR type arguments are not allowed for this type\n+    let _ = Alias::None::<u8>; //~ ERROR type arguments are not allowed on this type\n }"}, {"sha": "474548a14a9a6e9e89731a82f10c79f6f7a97055", "filename": "src/test/ui/type-alias-enum-variants/no-type-application-on-aliased-enum-variant.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/no-type-application-on-aliased-enum-variant.rs:13:27\n    |\n LL |     let _ = Alias::None::<u8>;\n-   |                           ^^ type argument not allowed\n+   |                    ----   ^^ type argument not allowed\n+   |                    |\n+   |                    not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "01ed9ea9e231ff2d73e4996b1cc45b5b2a2b6ec0", "filename": "src/test/ui/type/issue-91268.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype%2Fissue-91268.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype%2Fissue-91268.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-91268.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,7 +1,7 @@\n // error-pattern: this file contains an unclosed delimiter\n // error-pattern: cannot find type `\u0163` in this scope\n // error-pattern: parenthesized type parameters may only be used with a `Fn` trait\n-// error-pattern: type arguments are not allowed for this type\n+// error-pattern: type arguments are not allowed on this type\n // error-pattern: mismatched types\n // ignore-tidy-trailing-newlines\n // `\u0163` must be the last character in this file, it cannot be followed by a newline"}, {"sha": "199fd6a23f75550af2c8c6615523b92cc47ef8c6", "filename": "src/test/ui/type/issue-91268.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -30,11 +30,19 @@ error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n LL |     0: u8(\u0163\n    |        ^^^^ only `Fn` traits may use parentheses\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/issue-91268.rs:9:11\n    |\n LL |     0: u8(\u0163\n-   |           ^ type argument not allowed\n+   |        -- ^ type argument not allowed\n+   |        |\n+   |        not allowed on this\n+   |\n+help: primitive type `u8` doesn't have generic parameters\n+   |\n+LL -     0: u8(\u0163\n+LL +     0: u8\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/issue-91268.rs:9:5"}, {"sha": "1c5fd7508676a640bf0952ed3ac5fd9309437195", "filename": "src/test/ui/typeck/prim-with-args.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+fn main() {\n+\n+let _x: isize; //~ ERROR type arguments are not allowed on this type\n+let _x: i8; //~ ERROR type arguments are not allowed on this type\n+let _x: i16; //~ ERROR type arguments are not allowed on this type\n+let _x: i32; //~ ERROR type arguments are not allowed on this type\n+let _x: i64; //~ ERROR type arguments are not allowed on this type\n+let _x: usize; //~ ERROR type arguments are not allowed on this type\n+let _x: u8; //~ ERROR type arguments are not allowed on this type\n+let _x: u16; //~ ERROR type arguments are not allowed on this type\n+let _x: u32; //~ ERROR type arguments are not allowed on this type\n+let _x: u64; //~ ERROR type arguments are not allowed on this type\n+let _x: char; //~ ERROR type arguments are not allowed on this type\n+\n+let _x: isize; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i8; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i16; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i32; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i64; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: usize; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u8; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u16; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u32; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u64; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: char; //~ ERROR lifetime arguments are not allowed on this type\n+\n+}"}, {"sha": "b05d6c1cb4e4a4e190ac03fd6116fd3dc4df4815", "filename": "src/test/ui/typeck/prim-with-args.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,27 +1,28 @@\n+// run-rustfix\n fn main() {\n \n-let x: isize<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i8<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i16<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i32<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i64<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: usize<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u8<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u16<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u32<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u64<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: char<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: isize<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i8<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i16<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i32<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i64<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: usize<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u8<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u16<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u32<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u64<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: char<isize>; //~ ERROR type arguments are not allowed on this type\n \n-let x: isize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: usize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: char<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: isize<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i8<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i16<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i32<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i64<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: usize<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u8<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u16<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u32<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u64<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: char<'static>; //~ ERROR lifetime arguments are not allowed on this type\n \n }"}, {"sha": "7e7bc580b3b9535b9edb0e8743e8958e218da76a", "filename": "src/test/ui/typeck/prim-with-args.stderr", "status": "modified", "additions": 259, "deletions": 83, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,134 +1,310 @@\n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:3:14\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:4:15\n    |\n-LL | let x: isize<isize>;\n-   |              ^^^^^ type argument not allowed\n-\n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:4:11\n+LL | let _x: isize<isize>;\n+   |         ----- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `isize` doesn't have generic parameters\n    |\n-LL | let x: i8<isize>;\n-   |           ^^^^^ type argument not allowed\n+LL - let _x: isize<isize>;\n+LL + let _x: isize;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:5:12\n    |\n-LL | let x: i16<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: i8<isize>;\n+   |         -- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i8` doesn't have generic parameters\n+   |\n+LL - let _x: i8<isize>;\n+LL + let _x: i8;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:6:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:6:13\n+   |\n+LL | let _x: i16<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i16` doesn't have generic parameters\n    |\n-LL | let x: i32<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL - let _x: i16<isize>;\n+LL + let _x: i16;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:7:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:7:13\n    |\n-LL | let x: i64<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: i32<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i32` doesn't have generic parameters\n+   |\n+LL - let _x: i32<isize>;\n+LL + let _x: i32;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:8:14\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:8:13\n+   |\n+LL | let _x: i64<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: usize<isize>;\n-   |              ^^^^^ type argument not allowed\n+help: primitive type `i64` doesn't have generic parameters\n+   |\n+LL - let _x: i64<isize>;\n+LL + let _x: i64;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:9:11\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:9:15\n+   |\n+LL | let _x: usize<isize>;\n+   |         ----- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `usize` doesn't have generic parameters\n    |\n-LL | let x: u8<isize>;\n-   |           ^^^^^ type argument not allowed\n+LL - let _x: usize<isize>;\n+LL + let _x: usize;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:10:12\n    |\n-LL | let x: u16<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: u8<isize>;\n+   |         -- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u8` doesn't have generic parameters\n+   |\n+LL - let _x: u8<isize>;\n+LL + let _x: u8;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:11:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:11:13\n+   |\n+LL | let _x: u16<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: u32<isize>;\n-   |            ^^^^^ type argument not allowed\n+help: primitive type `u16` doesn't have generic parameters\n+   |\n+LL - let _x: u16<isize>;\n+LL + let _x: u16;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:12:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:12:13\n+   |\n+LL | let _x: u32<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n    |\n-LL | let x: u64<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL - let _x: u32<isize>;\n+LL + let _x: u32;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:13:13\n    |\n-LL | let x: char<isize>;\n-   |             ^^^^^ type argument not allowed\n+LL | let _x: u64<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u64` doesn't have generic parameters\n+   |\n+LL - let _x: u64<isize>;\n+LL + let _x: u64;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:15:14\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:14:14\n+   |\n+LL | let _x: char<isize>;\n+   |         ---- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: isize<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+help: primitive type `char` doesn't have generic parameters\n+   |\n+LL - let _x: char<isize>;\n+LL + let _x: char;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:16:11\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:16:15\n+   |\n+LL | let _x: isize<'static>;\n+   |         ----- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: i8<'static>;\n-   |           ^^^^^^^ lifetime argument not allowed\n+help: primitive type `isize` doesn't have generic parameters\n+   |\n+LL - let _x: isize<'static>;\n+LL + let _x: isize;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:17:12\n    |\n-LL | let x: i16<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i8<'static>;\n+   |         -- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i8` doesn't have generic parameters\n+   |\n+LL - let _x: i8<'static>;\n+LL + let _x: i8;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:18:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:18:13\n    |\n-LL | let x: i32<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i16<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i16` doesn't have generic parameters\n+   |\n+LL - let _x: i16<'static>;\n+LL + let _x: i16;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:19:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:19:13\n+   |\n+LL | let _x: i32<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: i64<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+help: primitive type `i32` doesn't have generic parameters\n+   |\n+LL - let _x: i32<'static>;\n+LL + let _x: i32;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:20:14\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:20:13\n+   |\n+LL | let _x: i64<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i64` doesn't have generic parameters\n    |\n-LL | let x: usize<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+LL - let _x: i64<'static>;\n+LL + let _x: i64;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:21:11\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:21:15\n    |\n-LL | let x: u8<'static>;\n-   |           ^^^^^^^ lifetime argument not allowed\n+LL | let _x: usize<'static>;\n+   |         ----- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `usize` doesn't have generic parameters\n+   |\n+LL - let _x: usize<'static>;\n+LL + let _x: usize;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:22:12\n    |\n-LL | let x: u16<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u8<'static>;\n+   |         -- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u8` doesn't have generic parameters\n+   |\n+LL - let _x: u8<'static>;\n+LL + let _x: u8;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:23:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:23:13\n+   |\n+LL | let _x: u16<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u16` doesn't have generic parameters\n    |\n-LL | let x: u32<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL - let _x: u16<'static>;\n+LL + let _x: u16;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:24:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:24:13\n    |\n-LL | let x: u64<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u32<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n+   |\n+LL - let _x: u32<'static>;\n+LL + let _x: u32;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:25:13\n    |\n-LL | let x: char<'static>;\n-   |             ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u64<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u64` doesn't have generic parameters\n+   |\n+LL - let _x: u64<'static>;\n+LL + let _x: u64;\n+   | \n+\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:26:14\n+   |\n+LL | let _x: char<'static>;\n+   |         ---- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `char` doesn't have generic parameters\n+   |\n+LL - let _x: char<'static>;\n+LL + let _x: char;\n+   | \n \n error: aborting due to 22 previous errors\n "}, {"sha": "6d17ba9b5b26199c599edc7686bfc3c150b36d80", "filename": "src/test/ui/usize-generic-argument-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fusize-generic-argument-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fusize-generic-argument-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fusize-generic-argument-parent.rs?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,5 +1,5 @@\n fn foo() {\n-    let x: usize<foo>; //~ ERROR const arguments are not allowed for this type\n+    let x: usize<foo>; //~ ERROR const arguments are not allowed on this type\n }\n \n fn main() {}"}, {"sha": "c657f0faa0b98a64ba2a0252ad8e9d6cf579759a", "filename": "src/test/ui/usize-generic-argument-parent.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b80b151b9f90166e22164f08e95a5c9e41dda0e/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr?ref=6b80b151b9f90166e22164f08e95a5c9e41dda0e", "patch": "@@ -1,8 +1,16 @@\n-error[E0109]: const arguments are not allowed for this type\n+error[E0109]: const arguments are not allowed on this type\n   --> $DIR/usize-generic-argument-parent.rs:2:18\n    |\n LL |     let x: usize<foo>;\n-   |                  ^^^ const argument not allowed\n+   |            ----- ^^^ const argument not allowed\n+   |            |\n+   |            not allowed on this\n+   |\n+help: primitive type `usize` doesn't have generic parameters\n+   |\n+LL -     let x: usize<foo>;\n+LL +     let x: usize;\n+   | \n \n error: aborting due to previous error\n "}]}