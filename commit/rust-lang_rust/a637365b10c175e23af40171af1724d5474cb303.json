{"sha": "a637365b10c175e23af40171af1724d5474cb303", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MzczNjViMTBjMTc1ZTIzYWY0MDE3MWFmMTcyNGQ1NDc0Y2IzMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-26T22:19:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-26T22:19:44Z"}, "message": "Auto merge of #21606 - arielb1:clean-cast, r=huonw\n\nThis also makes the cast error messages somewhat more uniform.", "tree": {"sha": "f8ef4e5bf5a4e4bf40f3fc432d9b9a02d7051203", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8ef4e5bf5a4e4bf40f3fc432d9b9a02d7051203"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a637365b10c175e23af40171af1724d5474cb303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a637365b10c175e23af40171af1724d5474cb303", "html_url": "https://github.com/rust-lang/rust/commit/a637365b10c175e23af40171af1724d5474cb303", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a637365b10c175e23af40171af1724d5474cb303/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec3a833d5082a77e74a30c2d3d353ba7f5df644", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec3a833d5082a77e74a30c2d3d353ba7f5df644", "html_url": "https://github.com/rust-lang/rust/commit/8ec3a833d5082a77e74a30c2d3d353ba7f5df644"}, {"sha": "e7245252ccb5de3d8002a2cc3ecb25595ea23e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7245252ccb5de3d8002a2cc3ecb25595ea23e90", "html_url": "https://github.com/rust-lang/rust/commit/e7245252ccb5de3d8002a2cc3ecb25595ea23e90"}], "stats": {"total": 210, "additions": 119, "deletions": 91}, "files": [{"sha": "86cf030c8288a51a4749df7720988788476c22b8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -3126,7 +3126,6 @@ pub fn type_is_scalar(ty: Ty) -> bool {\n       ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n       ty_bare_fn(..) | ty_ptr(_) => true,\n-      ty_tup(ref tys) if tys.is_empty() => true,\n       _ => false\n     }\n }"}, {"sha": "8de1ffd37e01b34f51b4a504d2f4cdb9b09d0ad0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 100, "deletions": 86, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -990,86 +990,65 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_cast(fcx: &FnCtxt,\n-              cast_expr: &ast::Expr,\n-              e: &ast::Expr,\n-              t: &ast::Ty) {\n-    let id = cast_expr.id;\n-    let span = cast_expr.span;\n-\n-    // Find the type of `e`. Supply hints based on the type we are casting to,\n-    // if appropriate.\n-    let t_1 = fcx.to_ty(t);\n-    let t_1 = structurally_resolved_type(fcx, span, t_1);\n-\n-    check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n-\n-    let t_e = fcx.expr_ty(e);\n-\n-    debug!(\"t_1={}\", fcx.infcx().ty_to_string(t_1));\n-    debug!(\"t_e={}\", fcx.infcx().ty_to_string(t_e));\n-\n-    if ty::type_is_error(t_e) {\n-        fcx.write_error(id);\n-        return\n-    }\n-\n-    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n-        let tstr = fcx.infcx().ty_to_string(t_1);\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-        }, t_e, None);\n-        match t_e.sty {\n-            ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n-                let mtstr = match mt {\n-                    ast::MutMutable => \"mut \",\n-                    ast::MutImmutable => \"\"\n-                };\n-                if ty::type_is_trait(t_1) {\n-                    span_help!(fcx.tcx().sess, t.span, \"did you mean `&{}{}`?\", mtstr, tstr);\n-                } else {\n-                    span_help!(fcx.tcx().sess, span,\n-                               \"consider using an implicit coercion to `&{}{}` instead\",\n-                               mtstr, tstr);\n-                }\n-            }\n-            ty::ty_uniq(..) => {\n-                span_help!(fcx.tcx().sess, t.span, \"did you mean `Box<{}>`?\", tstr);\n-            }\n-            _ => {\n-                span_help!(fcx.tcx().sess, e.span,\n-                           \"consider using a box or reference as appropriate\");\n+fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         span: Span,\n+                                         t_span: Span,\n+                                         e_span: Span,\n+                                         t_1: Ty<'tcx>,\n+                                         t_e: Ty<'tcx>,\n+                                         id: ast::NodeId) {\n+    let tstr = fcx.infcx().ty_to_string(t_1);\n+    fcx.type_error_message(span, |actual| {\n+        format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n+    }, t_e, None);\n+    match t_e.sty {\n+        ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n+            let mtstr = match mt {\n+                ast::MutMutable => \"mut \",\n+                ast::MutImmutable => \"\"\n+            };\n+            if ty::type_is_trait(t_1) {\n+                span_help!(fcx.tcx().sess, t_span, \"did you mean `&{}{}`?\", mtstr, tstr);\n+            } else {\n+                span_help!(fcx.tcx().sess, span,\n+                           \"consider using an implicit coercion to `&{}{}` instead\",\n+                           mtstr, tstr);\n             }\n         }\n-        fcx.write_error(id);\n-        return\n-    }\n-\n-    if ty::type_is_trait(t_1) {\n-        // This will be looked up later on.\n-        vtable::check_object_cast(fcx, cast_expr, e, t_1);\n-        fcx.write_ty(id, t_1);\n-        return\n+        ty::ty_uniq(..) => {\n+            span_help!(fcx.tcx().sess, t_span, \"did you mean `Box<{}>`?\", tstr);\n+        }\n+        _ => {\n+            span_help!(fcx.tcx().sess, e_span,\n+                       \"consider using a box or reference as appropriate\");\n+        }\n     }\n+    fcx.write_error(id);\n+}\n \n-    let t_1 = structurally_resolved_type(fcx, span, t_1);\n-    let t_e = structurally_resolved_type(fcx, span, t_e);\n \n-    if ty::type_is_nil(t_e) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cast from nil: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n-    } else if ty::type_is_nil(t_1) {\n+fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              t_1: Ty<'tcx>,\n+                              t_e: Ty<'tcx>,\n+                              e: &ast::Expr) {\n+    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          t_1: Ty<'tcx>,\n+                                          t_e: Ty<'tcx>) {\n         fcx.type_error_message(span, |actual| {\n-            format!(\"cast to nil: `{}` as `{}`\",\n+            format!(\"illegal cast; cast through an \\\n+                    integer first: `{}` as `{}`\",\n                     actual,\n                     fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     }\n \n     let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n+    let t_e_is_scalar = ty::type_is_scalar(t_e);\n+    let t_e_is_integral = ty::type_is_integral(t_e);\n+    let t_e_is_float = ty::type_is_floating_point(t_e);\n+    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n \n     let t_1_is_scalar = ty::type_is_scalar(t_1);\n     let t_1_is_char = ty::type_is_char(t_1);\n@@ -1078,18 +1057,9 @@ fn check_cast(fcx: &FnCtxt,\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+\n     if t_e_is_bare_fn_item && t_1_is_bare_fn {\n         demand::coerce(fcx, e.span, t_1, &*e);\n-    } else if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n-        if t_1_is_float || ty::type_is_unsafe_ptr(t_1) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"illegal cast; cast through an \\\n-                         integer first: `{}` as `{}`\",\n-                        actual,\n-                        fcx.infcx().ty_to_string(t_1))\n-            }, t_e, None);\n-        }\n-        // casts from C-like enums are allowed\n     } else if t_1_is_char {\n         let t_e = fcx.infcx().shallow_resolve(t_e);\n         if t_e.sty != ty::ty_uint(ast::TyU8) {\n@@ -1101,6 +1071,16 @@ fn check_cast(fcx: &FnCtxt,\n     } else if t_1.sty == ty::ty_bool {\n         span_err!(fcx.tcx().sess, span, E0054,\n             \"cannot cast as `bool`, compare with zero instead\");\n+    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) && !(\n+        t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n+        // Casts to float must go through an integer or boolean\n+        cast_through_integer_err(fcx, span, t_1, t_e)\n+    } else if t_e_is_c_enum && t_1_is_trivial {\n+        if ty::type_is_unsafe_ptr(t_1) {\n+            // ... and likewise with C enum -> *T\n+            cast_through_integer_err(fcx, span, t_1, t_e)\n+        }\n+        // casts from C-like enums are allowed\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n         fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                                       t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n@@ -1142,7 +1122,7 @@ fn check_cast(fcx: &FnCtxt,\n                 demand::coerce(fcx, e.span, t_1, &*e);\n             }\n         }\n-    } else if !(ty::type_is_scalar(t_e) && t_1_is_trivial) {\n+    } else if !(t_e_is_scalar && t_1_is_trivial) {\n         /*\n         If more type combinations should be supported than are\n         supported here, then file an enhancement issue and\n@@ -1153,15 +1133,49 @@ fn check_cast(fcx: &FnCtxt,\n                     actual,\n                     fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n-    } else if ty::type_is_unsafe_ptr(t_e) && t_1_is_float {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cannot cast from pointer to float directly: `{}` as `{}`; cast through an \\\n-                     integer first\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n     }\n+}\n+\n+fn check_cast(fcx: &FnCtxt,\n+              cast_expr: &ast::Expr,\n+              e: &ast::Expr,\n+              t: &ast::Ty) {\n+    let id = cast_expr.id;\n+    let span = cast_expr.span;\n+\n+    // Find the type of `e`. Supply hints based on the type we are casting to,\n+    // if appropriate.\n+    let t_1 = fcx.to_ty(t);\n+    let t_1 = structurally_resolved_type(fcx, span, t_1);\n+\n+    check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n+\n+    let t_e = fcx.expr_ty(e);\n+\n+    debug!(\"t_1={}\", fcx.infcx().ty_to_string(t_1));\n+    debug!(\"t_e={}\", fcx.infcx().ty_to_string(t_e));\n+\n+    if ty::type_is_error(t_e) {\n+        fcx.write_error(id);\n+        return\n+    }\n+\n+    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n+        report_cast_to_unsized_type(fcx, span, t.span, e.span, t_1, t_e, id);\n+        return\n+    }\n+\n+    if ty::type_is_trait(t_1) {\n+        // This will be looked up later on.\n+        vtable::check_object_cast(fcx, cast_expr, e, t_1);\n+        fcx.write_ty(id, t_1);\n+        return\n+    }\n+\n+    let t_1 = structurally_resolved_type(fcx, span, t_1);\n+    let t_e = structurally_resolved_type(fcx, span, t_e);\n \n+    check_cast_inner(fcx, span, t_1, t_e, e);\n     fcx.write_ty(id, t_1);\n }\n "}, {"sha": "4c6dcaccc9aed5347cb85f94cd456c982f56e724", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cast from nil: `()` as `u32`\n+// error-pattern: non-scalar cast: `()` as `u32`\n fn main() { let u = (assert!(true) as u32); }"}, {"sha": "e5fd5bb33eb908978d6f77f82b7354fabc6fdc17", "filename": "src/test/compile-fail/cast-to-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cast to nil: `u32` as `()`\n+// error-pattern: non-scalar cast: `u32` as `()`\n fn main() { let u = 0u32 as (); }"}, {"sha": "25060b94dcf37bec0354f1fd1c6e4bbaa714d7d4", "filename": "src/test/compile-fail/issue-10991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let nil = ();\n-    let _t = nil as usize; //~ ERROR: cast from nil: `()` as `usize`\n+    let _t = nil as usize; //~ ERROR: non-scalar cast: `()` as `usize`\n }"}, {"sha": "a2cac55033c1f30b023b4f39dc1b9d19c66fd11c", "filename": "src/test/compile-fail/issue-21554.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Inches(i32);\n+\n+fn main() {\n+    Inches as f32; //~ ERROR illegal cast; cast through an integer first\n+}"}, {"sha": "285a5dbee053dc8aa7ab8120627cfeedce248f82", "filename": "src/test/compile-fail/typeck-cast-pointer-to-float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a637365b10c175e23af40171af1724d5474cb303/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs?ref=a637365b10c175e23af40171af1724d5474cb303", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     let x : i16 = 22;\n     ((&x) as *const i16) as f32;\n-    //~^ ERROR: cannot cast from pointer to float directly: `*const i16` as `f32`\n+    //~^ ERROR illegal cast; cast through an integer first: `*const i16` as `f32`\n }"}]}