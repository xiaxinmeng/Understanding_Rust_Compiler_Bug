{"sha": "cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNjQ3ZjNlOGUzMjE4MGNkZTBmMGU3YTI1OTlhNWRjNWIzNTM0NWE=", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2021-01-18T14:22:17Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2021-02-13T03:01:04Z"}, "message": "Fix possible soundness issue in `ensure_subset_of`", "tree": {"sha": "8a5eae31d65eb661db31c1e4f6e1c547a30b8af3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a5eae31d65eb661db31c1e4f6e1c547a30b8af3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "html_url": "https://github.com/rust-lang/rust/commit/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d29793614cc810fb8febf7f1a2e0202f3919bb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d29793614cc810fb8febf7f1a2e0202f3919bb6", "html_url": "https://github.com/rust-lang/rust/commit/9d29793614cc810fb8febf7f1a2e0202f3919bb6"}], "stats": {"total": 222, "additions": 112, "deletions": 110}, "files": [{"sha": "319ca666fc6228c82f38aaf0a6a8e5bb7e11bad8", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -1063,7 +1063,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = range.ensure_subset_of(..self.len());\n+        let Range { start, end } = Range::ensure_subset_of(range, ..self.len());\n         let tail = self.wrap_add(self.tail, start);\n         let head = self.wrap_add(self.tail, end);\n         (tail, head)"}, {"sha": "ade2e3fed2c2d3b946f35ae8820003e7f8f9d145", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -115,7 +115,7 @@\n #![feature(or_patterns)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n-#![feature(range_bounds_ensure_subset_of)]\n+#![feature(range_ensure_subset_of)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![cfg_attr(bootstrap, feature(min_const_generics))]"}, {"sha": "ef2f264ec7ea835a7a8fbda60101e4a7962ee22a", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -1510,7 +1510,7 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let Range { start, end } = range.ensure_subset_of(..self.len());\n+        let Range { start, end } = Range::ensure_subset_of(range, ..self.len());\n         assert!(self.is_char_boundary(start));\n         assert!(self.is_char_boundary(end));\n "}, {"sha": "1a7b846bd85143e96562c36e75000c5f9c4944ee", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -1650,7 +1650,7 @@ impl<T, A: Allocator> Vec<T, A> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let Range { start, end } = range.ensure_subset_of(..len);\n+        let Range { start, end } = Range::ensure_subset_of(range, ..len);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked"}, {"sha": "b30ff9450ff028f2344289a34a4a1318e7236591", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 97, "deletions": 95, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -151,6 +151,103 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     }\n }\n \n+impl Range<usize> {\n+    /// Performs bounds-checking of a range.\n+    ///\n+    /// This method is similar to [`Index::index`] for slices, but it returns a\n+    /// `Range` equivalent to `range`. You can use this method to turn any range\n+    /// into `start` and `end` values.\n+    ///\n+    /// `bounds` is the range of the slice to use for bounds-checking. It should\n+    /// be a [`RangeTo`] range that ends at the length of the slice.\n+    ///\n+    /// The returned `Range` is safe to pass to [`slice::get_unchecked`] and\n+    /// [`slice::get_unchecked_mut`] for slices with the given range.\n+    ///\n+    /// [`slice::get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n+    /// [`slice::get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `range` would be out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_ensure_subset_of)]\n+    ///\n+    /// use std::ops::Range;\n+    ///\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(1..2, Range::ensure_subset_of(1..2, ..v.len()));\n+    /// assert_eq!(0..2, Range::ensure_subset_of(..2, ..v.len()));\n+    /// assert_eq!(1..3, Range::ensure_subset_of(1.., ..v.len()));\n+    /// ```\n+    ///\n+    /// Panics when [`Index::index`] would panic:\n+    ///\n+    /// ```should_panic\n+    /// #![feature(range_ensure_subset_of)]\n+    ///\n+    /// use std::ops::Range;\n+    ///\n+    /// Range::ensure_subset_of(2..1, ..3);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(range_ensure_subset_of)]\n+    ///\n+    /// use std::ops::Range;\n+    ///\n+    /// Range::ensure_subset_of(1..4, ..3);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(range_ensure_subset_of)]\n+    ///\n+    /// use std::ops::Range;\n+    ///\n+    /// Range::ensure_subset_of(1..=usize::MAX, ..3);\n+    /// ```\n+    ///\n+    /// [`Index::index`]: crate::ops::Index::index\n+    #[track_caller]\n+    #[unstable(feature = \"range_ensure_subset_of\", issue = \"76393\")]\n+    pub fn ensure_subset_of<R>(range: R, bounds: RangeTo<usize>) -> Self\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let len = bounds.end;\n+\n+        let start: Bound<&usize> = range.start_bound();\n+        let start = match start {\n+            Bound::Included(&start) => start,\n+            Bound::Excluded(start) => {\n+                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end: Bound<&usize> = range.end_bound();\n+        let end = match end {\n+            Bound::Included(end) => {\n+                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+            }\n+            Bound::Excluded(&end) => end,\n+            Bound::Unbounded => len,\n+        };\n+\n+        if start > end {\n+            slice_index_order_fail(start, end);\n+        }\n+        if end > len {\n+            slice_end_index_len_fail(end, len);\n+        }\n+\n+        Self { start, end }\n+    }\n+}\n+\n /// A range only bounded inclusively below (`start..`).\n ///\n /// The `RangeFrom` `start..` contains all values with `x >= start`.\n@@ -764,101 +861,6 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n     fn end_bound(&self) -> Bound<&T>;\n \n-    /// Performs bounds-checking of this range.\n-    ///\n-    /// This method is similar to [`Index::index`] for slices, but it returns a\n-    /// [`Range`] equivalent to this range. You can use this method to turn any\n-    /// range into `start` and `end` values.\n-    ///\n-    /// The given range is the range of the slice to use for bounds-checking. It\n-    /// should be a [`RangeTo`] range that ends at the length of the slice.\n-    ///\n-    /// The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and\n-    /// [`slice::get_unchecked_mut`] for slices with the given range.\n-    ///\n-    /// [`slice::get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n-    /// [`slice::get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the range would be out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_bounds_ensure_subset_of)]\n-    ///\n-    /// use std::ops::RangeBounds;\n-    ///\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(1..2, (1..2).ensure_subset_of(..v.len()));\n-    /// assert_eq!(0..2, (..2).ensure_subset_of(..v.len()));\n-    /// assert_eq!(1..3, (1..).ensure_subset_of(..v.len()));\n-    /// ```\n-    ///\n-    /// Panics when [`Index::index`] would panic:\n-    ///\n-    /// ```should_panic\n-    /// #![feature(range_bounds_ensure_subset_of)]\n-    ///\n-    /// use std::ops::RangeBounds;\n-    ///\n-    /// (2..1).ensure_subset_of(..3);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(range_bounds_ensure_subset_of)]\n-    ///\n-    /// use std::ops::RangeBounds;\n-    ///\n-    /// (1..4).ensure_subset_of(..3);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(range_bounds_ensure_subset_of)]\n-    ///\n-    /// use std::ops::RangeBounds;\n-    ///\n-    /// (1..=usize::MAX).ensure_subset_of(..3);\n-    /// ```\n-    ///\n-    /// [`Index::index`]: crate::ops::Index::index\n-    #[track_caller]\n-    #[unstable(feature = \"range_bounds_ensure_subset_of\", issue = \"76393\")]\n-    fn ensure_subset_of(self, range: RangeTo<usize>) -> Range<usize>\n-    where\n-        Self: RangeBounds<usize>,\n-    {\n-        let len = range.end;\n-\n-        let start: Bound<&usize> = self.start_bound();\n-        let start = match start {\n-            Bound::Included(&start) => start,\n-            Bound::Excluded(start) => {\n-                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n-            }\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let end: Bound<&usize> = self.end_bound();\n-        let end = match end {\n-            Bound::Included(end) => {\n-                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n-            }\n-            Bound::Excluded(&end) => end,\n-            Bound::Unbounded => len,\n-        };\n-\n-        if start > end {\n-            slice_index_order_fail(start, end);\n-        }\n-        if end > len {\n-            slice_end_index_len_fail(end, len);\n-        }\n-\n-        Range { start, end }\n-    }\n-\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples"}, {"sha": "e78b6476511014a83a7cc905148294ac8cd197fc", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -3052,7 +3052,7 @@ impl<T> [T] {\n     where\n         T: Copy,\n     {\n-        let Range { start: src_start, end: src_end } = src.ensure_subset_of(..self.len());\n+        let Range { start: src_start, end: src_end } = Range::ensure_subset_of(src, ..self.len());\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         // SAFETY: the conditions for `ptr::copy` have all been checked above,"}, {"sha": "ea3f01ff5f9d192ec1f7473614d66ae4185143ea", "filename": "src/doc/unstable-book/src/library-features/range-bounds-ensure-subset-of.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d29793614cc810fb8febf7f1a2e0202f3919bb6/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-bounds-ensure-subset-of.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d29793614cc810fb8febf7f1a2e0202f3919bb6/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-bounds-ensure-subset-of.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-bounds-ensure-subset-of.md?ref=9d29793614cc810fb8febf7f1a2e0202f3919bb6", "patch": "@@ -1,10 +0,0 @@\n-# `range_bounds_ensure_subset_of`\n-\n-The tracking issue for this feature is: [#76393]\n-\n-------------------------\n-\n-This adds [`RangeBounds::ensure_subset_of`].\n-\n-[#76393]: https://github.com/rust-lang/rust/issues/76393\n-[`RangeBounds::ensure_subset_of`]: https://doc.rust-lang.org/nightly/std/ops/trait.RangeBounds.html#method.ensure_subset_of"}, {"sha": "8b5a21a34cfbb8d447213e7edf35a6b81338b01d", "filename": "src/doc/unstable-book/src/library-features/range-ensure-subset-of.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-ensure-subset-of.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb647f3e8e32180cde0f0e7a2599a5dc5b35345a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-ensure-subset-of.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frange-ensure-subset-of.md?ref=cb647f3e8e32180cde0f0e7a2599a5dc5b35345a", "patch": "@@ -0,0 +1,10 @@\n+# `range_ensure_subset_of`\n+\n+The tracking issue for this feature is: [#76393]\n+\n+------------------------\n+\n+This adds [`Range::ensure_subset_of`].\n+\n+[#76393]: https://github.com/rust-lang/rust/issues/76393\n+[`Range::ensure_subset_of`]: https://doc.rust-lang.org/std/ops/struct.Range.html#method.ensure_subset_of"}]}