{"sha": "5ceaf345ed8d70b444907b09e61c1b347dad436c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZWFmMzQ1ZWQ4ZDcwYjQ0NDkwN2IwOWU2MWMxYjM0N2RhZDQzNmM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-12T22:42:12Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-12T22:42:51Z"}, "message": "Add stats option and lazily emit glue.", "tree": {"sha": "c26e0ed6779c0c4789e44f5e4cf75e43eaae4a13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c26e0ed6779c0c4789e44f5e4cf75e43eaae4a13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ceaf345ed8d70b444907b09e61c1b347dad436c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ceaf345ed8d70b444907b09e61c1b347dad436c", "html_url": "https://github.com/rust-lang/rust/commit/5ceaf345ed8d70b444907b09e61c1b347dad436c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ceaf345ed8d70b444907b09e61c1b347dad436c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "295c037aac7b48a3d00593b21f00d7ff07127985", "url": "https://api.github.com/repos/rust-lang/rust/commits/295c037aac7b48a3d00593b21f00d7ff07127985", "html_url": "https://github.com/rust-lang/rust/commit/295c037aac7b48a3d00593b21f00d7ff07127985"}], "stats": {"total": 355, "additions": 269, "deletions": 86}, "files": [{"sha": "dcb12e9b4361511bef6281016c26bf8a7adadc5d", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ceaf345ed8d70b444907b09e61c1b347dad436c/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ceaf345ed8d70b444907b09e61c1b347dad436c/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=5ceaf345ed8d70b444907b09e61c1b347dad436c", "patch": "@@ -158,6 +158,7 @@ options:\n     -S                 compile only; do not assemble or link\n     -c                 compile and assemble, but do not link\n     --save-temps       write intermediate files in addition to normal output\n+    --stats            gather and report various compilation statistics\n     --time-passes      time the individual phases of the compiler\n     --time-llvm-passes time the individual phases of the LLVM backend\n     --sysroot <path>   override the system root (default: rustc's directory)\n@@ -212,6 +213,7 @@ fn main(vec[str] args) {\n                     optflag(\"O\"), optflag(\"shared\"), optmulti(\"L\"),\n                     optflag(\"S\"), optflag(\"c\"), optopt(\"o\"), optflag(\"g\"),\n                     optflag(\"save-temps\"), optopt(\"sysroot\"),\n+                    optflag(\"stats\"),\n                     optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n                     optflag(\"no-typestate\"), optflag(\"noverify\"));\n     auto binary = _vec::shift[str](args);\n@@ -256,6 +258,7 @@ fn main(vec[str] args) {\n     // FIXME: Maybe we should support -O0, -O1, -Os, etc\n     auto optimize = opt_present(match, \"O\");\n     auto debuginfo = opt_present(match, \"g\");\n+    auto stats = opt_present(match, \"stats\");\n     auto time_passes = opt_present(match, \"time-passes\");\n     auto time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n     auto run_typestate = !opt_present(match, \"no-typestate\");\n@@ -274,6 +277,7 @@ fn main(vec[str] args) {\n              verify = verify,\n              run_typestate = run_typestate,\n              save_temps = save_temps,\n+             stats = stats,\n              time_passes = time_passes,\n              time_llvm_passes = time_llvm_passes,\n              output_type = output_type,"}, {"sha": "12129a93858434959b559864b544b27a2eb9c784", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ceaf345ed8d70b444907b09e61c1b347dad436c/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ceaf345ed8d70b444907b09e61c1b347dad436c/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=5ceaf345ed8d70b444907b09e61c1b347dad436c", "patch": "@@ -31,6 +31,7 @@ type options = rec(bool shared,\n                    bool verify,\n                    bool run_typestate,\n                    bool save_temps,\n+                   bool stats,\n                    bool time_passes,\n                    bool time_llvm_passes,\n                    back::Link::output_type output_type,"}, {"sha": "09156cab4a158b18d3db110536e2ab385c42214b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 264, "deletions": 86, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/5ceaf345ed8d70b444907b09e61c1b347dad436c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ceaf345ed8d70b444907b09e61c1b347dad436c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5ceaf345ed8d70b444907b09e61c1b347dad436c", "patch": "@@ -63,10 +63,14 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef no_op_type_glue,\n                     ValueRef vec_append_glue);\n \n-type tydesc_info = rec(ValueRef tydesc,\n-                       ValueRef take_glue,\n-                       ValueRef drop_glue,\n-                       ValueRef cmp_glue);\n+type tydesc_info = rec(ty::t ty,\n+                       ValueRef tydesc,\n+                       ValueRef size,\n+                       ValueRef align,\n+                       mutable option::t[ValueRef] take_glue,\n+                       mutable option::t[ValueRef] drop_glue,\n+                       mutable option::t[ValueRef] cmp_glue,\n+                       vec[uint] ty_params);\n \n /*\n  * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n@@ -87,6 +91,12 @@ type tydesc_info = rec(ValueRef tydesc,\n  *\n  */\n \n+type stats = rec(mutable uint n_static_tydescs,\n+                 mutable uint n_derived_tydescs,\n+                 mutable uint n_glues_created,\n+                 mutable uint n_null_glues,\n+                 mutable uint n_real_glues);\n+\n state type crate_ctxt = rec(session::session sess,\n                             ModuleRef llmod,\n                             target_data td,\n@@ -117,6 +127,7 @@ state type crate_ctxt = rec(session::session sess,\n                             hashmap[ty::t, metadata::ty_abbrev] type_abbrevs,\n                             hashmap[ty::t, str] type_short_names,\n                             ty::ctxt tcx,\n+                            stats stats,\n                             @upcall::upcalls upcalls);\n \n type local_ctxt = rec(vec[str] path,\n@@ -1576,7 +1587,8 @@ fn trans_malloc_boxed(&@block_ctxt cx, ty::t t) -> result {\n // tydesc if necessary.\n fn field_of_tydesc(&@block_ctxt cx, &ty::t t, bool escapes, int field)\n         -> result {\n-    auto tydesc = get_tydesc(cx, t, escapes);\n+    auto ti = none[@tydesc_info];\n+    auto tydesc = get_tydesc(cx, t, escapes, ti);\n     ret res(tydesc.bcx,\n             tydesc.bcx.build.GEP(tydesc.val, vec(C_int(0), C_int(field))));\n }\n@@ -1658,7 +1670,8 @@ fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n     ret llmyroottydesc;\n }\n \n-fn mk_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes) -> result {\n+fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n+                      &mutable option::t[@tydesc_info] static_ti) -> result {\n     alt (cx.fcx.derived_tydescs.find(t)) {\n         case (some[derived_tydesc_info](?info)) {\n             // If the tydesc escapes in this context, the cached derived\n@@ -1668,6 +1681,8 @@ fn mk_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes) -> result {\n         case (none[derived_tydesc_info]) { /* fall through */ }\n     }\n \n+    cx.fcx.lcx.ccx.stats.n_derived_tydescs += 1u;\n+\n     auto bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n \n     let uint n_params = ty::count_ty_params(bcx.fcx.lcx.ccx.tcx, t);\n@@ -1676,7 +1691,10 @@ fn mk_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes) -> result {\n     assert (n_params == _vec::len[uint](tys._0));\n     assert (n_params == _vec::len[ValueRef](tys._1));\n \n-    auto root = get_static_tydesc(bcx, t, tys._0).tydesc;\n+    auto root_ti = get_static_tydesc(bcx, t, tys._0);\n+    static_ti = some[@tydesc_info](root_ti);\n+    lazily_emit_all_tydesc_glue(cx, static_ti);\n+    auto root = root_ti.tydesc;\n \n     auto sz = size_of(bcx, t);\n     bcx = sz.bcx;\n@@ -1737,7 +1755,8 @@ fn mk_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes) -> result {\n     ret res(cx, v);\n }\n \n-fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes) -> result {\n+fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n+              &mutable option::t[@tydesc_info] static_ti) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty::type_param(cx.fcx.lcx.ccx.tcx, t)) {\n         case (some[uint](?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n@@ -1747,13 +1766,14 @@ fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes) -> result {\n     // Does it contain a type param? If so, generate a derived tydesc.\n \n     if (ty::type_contains_params(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret mk_derived_tydesc(cx, t, escapes);\n+        ret get_derived_tydesc(cx, t, escapes, static_ti);\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     let vec[uint] tps = vec();\n-    auto st = get_static_tydesc(cx, t, tps).tydesc;\n-    ret res(cx, st);\n+    auto info = get_static_tydesc(cx, t, tps);\n+    static_ti = some[@tydesc_info](info);\n+    ret res(cx, info.tydesc);\n }\n \n fn get_static_tydesc(&@block_ctxt cx,\n@@ -1763,34 +1783,18 @@ fn get_static_tydesc(&@block_ctxt cx,\n             ret info;\n         }\n         case (none[@tydesc_info]) {\n-\n-            // FIXME: Use of a simplified tydesc (w/o names) removes a lot of\n-            // generated glue, but the compile time goes way down due to\n-            // greatly increasing the miss rate on the type_of cache elsewhere\n-            // in this file. Experiment with other approaches to this.\n-\n-            /*\n-            fn simplifier(ty::t typ) -> ty::t {\n-                ret @rec(cname=none[str] with *typ);\n-            }\n-            auto f = simplifier;\n-            auto t_simplified = ty::fold_ty(cx.fcx.lcx.ccx.tcx, f, t);\n-            auto info = declare_tydesc(cx.fcx.lcx, t_simplified);\n-            cx.fcx.lcx.ccx.tydescs.insert(t_simplified, info);\n-            */\n-\n-            auto info = declare_tydesc(cx.fcx.lcx, t);\n+            cx.fcx.lcx.ccx.stats.n_static_tydescs += 1u;\n+            auto info = declare_tydesc(cx.fcx.lcx, t, ty_params);\n             cx.fcx.lcx.ccx.tydescs.insert(t, info);\n-            define_tydesc(cx.fcx.lcx, t, ty_params);\n             ret info;\n         }\n     }\n }\n \n-// Generates the declaration for (but doesn't fill in) a type descriptor. This\n-// needs to be separate from make_tydesc() below, because sometimes type glue\n-// functions needs to refer to their own type descriptors.\n-fn declare_tydesc(&@local_ctxt cx, &ty::t t) -> @tydesc_info {\n+// Generates the declaration for (but doesn't emit) a type descriptor.\n+fn declare_tydesc(&@local_ctxt cx, &ty::t t,\n+                  vec[uint] ty_params) -> @tydesc_info {\n+    log \"+++ declare_tydesc \" + ty::ty_to_str(cx.ccx.tcx, t);\n     auto take_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n                                           \"take\");\n     auto drop_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n@@ -1812,8 +1816,6 @@ fn declare_tydesc(&@local_ctxt cx, &ty::t t) -> @tydesc_info {\n         llalign = C_int(0);\n     }\n \n-    auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n-\n     auto name;\n     if (cx.ccx.sess.get_opts().debuginfo) {\n         name = mangle_name_by_type_only(cx.ccx, t, \"tydesc\");\n@@ -1823,31 +1825,18 @@ fn declare_tydesc(&@local_ctxt cx, &ty::t t) -> @tydesc_info {\n     }\n \n     auto gvar = llvm::LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n-                                   _str::buf(name));\n-    auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n-                               llsize,\n-                               llalign,\n-                               take_glue,             // take_glue\n-                               drop_glue,             // drop_glue\n-                               C_null(glue_fn_ty),    // free_glue\n-                               C_null(glue_fn_ty),    // sever_glue\n-                               C_null(glue_fn_ty),    // mark_glue\n-                               C_null(glue_fn_ty),    // obj_drop_glue\n-                               C_null(glue_fn_ty),    // is_stateful\n-                               cmp_glue));            // cmp_glue\n-\n-    llvm::LLVMSetInitializer(gvar, tydesc);\n-    llvm::LLVMSetGlobalConstant(gvar, True);\n-    llvm::LLVMSetLinkage(gvar, lib::llvm::LLVMInternalLinkage\n-                        as llvm::Linkage);\n-\n-    auto info = @rec(\n-        tydesc=gvar,\n-        take_glue=take_glue,\n-        drop_glue=drop_glue,\n-        cmp_glue=cmp_glue\n-    );\n-\n+                                    _str::buf(name));\n+\n+    auto info = @rec(ty = t,\n+                     tydesc = gvar,\n+                     size = llsize,\n+                     align = llalign,\n+                     mutable take_glue = none[ValueRef],\n+                     mutable drop_glue = none[ValueRef],\n+                     mutable cmp_glue = none[ValueRef],\n+                     ty_params = ty_params);\n+\n+    log \"--- declare_tydesc \" + ty::ty_to_str(cx.ccx.tcx, t);\n     ret info;\n }\n \n@@ -1856,18 +1845,6 @@ tag make_generic_glue_helper_fn {\n     mgghf_cmp;\n }\n \n-// declare_tydesc() above must have been called first.\n-fn define_tydesc(&@local_ctxt cx, &ty::t t, &vec[uint] ty_params) {\n-    auto info = cx.ccx.tydescs.get(t);\n-    auto gvar = info.tydesc;\n-\n-    auto tg = make_take_glue;\n-    make_generic_glue(cx, t, info.take_glue, mgghf_single(tg), ty_params);\n-    auto dg = make_drop_glue;\n-    make_generic_glue(cx, t, info.drop_glue, mgghf_single(dg), ty_params);\n-    make_generic_glue(cx, t, info.cmp_glue, mgghf_cmp, ty_params);\n-}\n-\n fn declare_generic_glue(&@local_ctxt cx,\n                         &ty::t t,\n                         TypeRef llfnty,\n@@ -1890,6 +1867,8 @@ fn make_generic_glue(&@local_ctxt cx,\n                      &vec[uint] ty_params) -> ValueRef {\n     auto fcx = new_fn_ctxt(cx, llfn);\n \n+    cx.ccx.stats.n_glues_created += 1u;\n+\n     // Any nontrivial glue is with values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be\n@@ -1945,6 +1924,70 @@ fn make_generic_glue(&@local_ctxt cx,\n     ret llfn;\n }\n \n+fn emit_tydescs(&@crate_ctxt ccx) {\n+    for each (@tup(ty::t, @tydesc_info) pair in ccx.tydescs.items()) {\n+\n+        auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n+        auto cmp_fn_ty = T_ptr(T_cmp_glue_fn(ccx.tn));\n+\n+        auto ti = pair._1;\n+\n+        auto take_glue = alt (ti.take_glue) {\n+            case (none[ValueRef]) {\n+                ccx.stats.n_null_glues += 1u;\n+                C_null(glue_fn_ty)\n+            }\n+            case (some[ValueRef](?v)) {\n+                ccx.stats.n_real_glues += 1u;\n+                v\n+            }\n+        };\n+\n+        auto drop_glue = alt (ti.drop_glue) {\n+            case (none[ValueRef]) {\n+                ccx.stats.n_null_glues += 1u;\n+                C_null(glue_fn_ty)\n+            }\n+            case (some[ValueRef](?v)) {\n+                ccx.stats.n_real_glues += 1u;\n+                v\n+            }\n+        };\n+\n+\n+        auto cmp_glue = alt (ti.cmp_glue) {\n+            case (none[ValueRef]) {\n+                ccx.stats.n_null_glues += 1u;\n+                C_null(cmp_fn_ty)\n+            }\n+            case (some[ValueRef](?v)) {\n+                ccx.stats.n_real_glues += 1u;\n+                v\n+            }\n+        };\n+\n+\n+        auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n+                                   ti.size,\n+                                   ti.align,\n+                                   take_glue,             // take_glue\n+                                   drop_glue,             // drop_glue\n+                                   C_null(glue_fn_ty),    // free_glue\n+                                   C_null(glue_fn_ty),    // sever_glue\n+                                   C_null(glue_fn_ty),    // mark_glue\n+                                   C_null(glue_fn_ty),    // obj_drop_glue\n+                                   C_null(glue_fn_ty),    // is_stateful\n+                                   cmp_glue));            // cmp_glue\n+\n+        auto gvar = ti.tydesc;\n+        llvm::LLVMSetInitializer(gvar, tydesc);\n+        llvm::LLVMSetGlobalConstant(gvar, True);\n+        llvm::LLVMSetLinkage(gvar, lib::llvm::LLVMInternalLinkage\n+                             as llvm::Linkage);\n+    }\n+}\n+\n+\n fn make_take_glue(&@block_ctxt cx, ValueRef v, &ty::t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     auto bcx;\n@@ -2068,8 +2111,9 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n                 auto cx_ = maybe_call_dtor(cx, o);\n \n                 // Call through the obj's own fields-drop glue first.\n+                auto ti = none[@tydesc_info];\n                 call_tydesc_glue_full(cx_, body, tydesc,\n-                                      abi::tydesc_field_drop_glue);\n+                                      abi::tydesc_field_drop_glue, ti);\n \n                 // Then free the body.\n                 // FIXME: switch gc/non-gc on layer of the type.\n@@ -2106,8 +2150,9 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n                                  vec(C_int(0),\n                                      C_int(abi::closure_elt_tydesc)));\n \n+                auto ti = none[@tydesc_info];\n                 call_tydesc_glue_full(cx, bindings, cx.build.Load(tydescptr),\n-                                      abi::tydesc_field_drop_glue);\n+                                      abi::tydesc_field_drop_glue, ti);\n \n \n                 // Then free the body.\n@@ -2210,7 +2255,10 @@ fn make_cmp_glue(&@block_ctxt cx,\n     } else if (ty::type_is_box(cx.fcx.lcx.ccx.tcx, t)) {\n         lhs = cx.build.GEP(lhs, vec(C_int(0), C_int(abi::box_rc_field_body)));\n         rhs = cx.build.GEP(rhs, vec(C_int(0), C_int(abi::box_rc_field_body)));\n-        auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n+        auto t_inner = alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+            case (ty::ty_box(?ti)) { ti.ty }\n+        };\n+        auto rslt = call_cmp_glue(cx, lhs, rhs, t_inner, llop);\n \n         rslt.bcx.build.Store(rslt.val, cx.fcx.llretptr);\n         rslt.bcx.build.RetVoid();\n@@ -2838,8 +2886,97 @@ fn iter_sequence(@block_ctxt cx,\n     fail;\n }\n \n+fn lazily_emit_all_tydesc_glue(&@block_ctxt cx,\n+                               &option::t[@tydesc_info] static_ti) {\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, static_ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, static_ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, static_ti);\n+}\n+\n+fn lazily_emit_all_generic_info_tydesc_glues(&@block_ctxt cx,\n+                                             &generic_info gi) {\n+    for (option::t[@tydesc_info] ti in gi. static_tis) {\n+        lazily_emit_all_tydesc_glue(cx, ti);\n+    }\n+}\n+\n+fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n+                           &option::t[@tydesc_info] static_ti) {\n+    alt (static_ti) {\n+        case (none[@tydesc_info]) { }\n+        case (some[@tydesc_info](?ti)) {\n+\n+            if(field == abi::tydesc_field_take_glue) {\n+                alt (ti.take_glue) {\n+                    case (some[ValueRef](_)) {}\n+                    case (none[ValueRef]) {\n+                        log #fmt(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+\n+                        auto lcx = cx.fcx.lcx;\n+                        auto glue_fn =\n+                            declare_generic_glue(lcx, ti.ty,\n+                                                 T_glue_fn(lcx.ccx.tn),\n+                                                 \"take\");\n+                        ti.take_glue = some[ValueRef](glue_fn);\n+                        auto tg = make_take_glue;\n+                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                                          mgghf_single(tg), ti.ty_params);\n+\n+                        log #fmt(\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                    }\n+                }\n+            } else if (field == abi::tydesc_field_drop_glue)  {\n+                alt (ti.drop_glue) {\n+                    case (some[ValueRef](_)) { }\n+                    case (none[ValueRef]) {\n+                        log #fmt(\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                        auto lcx = cx.fcx.lcx;\n+                        auto glue_fn =\n+                            declare_generic_glue(lcx, ti.ty,\n+                                                 T_glue_fn(lcx.ccx.tn),\n+                                                 \"drop\");\n+                        ti.drop_glue = some[ValueRef](glue_fn);\n+                        auto dg = make_drop_glue;\n+                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                                          mgghf_single(dg), ti.ty_params);\n+                        log #fmt(\"--- lazily_emit_tydesc_glue DROP %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                    }\n+                }\n+\n+            } else if (field == abi::tydesc_field_cmp_glue) {\n+                alt (ti.cmp_glue) {\n+                    case (some[ValueRef](_)) { }\n+                    case (none[ValueRef]) {\n+                        log #fmt(\"+++ lazily_emit_tydesc_glue CMP %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                        auto lcx = cx.fcx.lcx;\n+                        auto glue_fn =\n+                            declare_generic_glue(lcx, ti.ty,\n+                                                 T_cmp_glue_fn(lcx.ccx.tn),\n+                                                 \"cmp\");\n+                        ti.cmp_glue = some[ValueRef](glue_fn);\n+                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                                          mgghf_cmp, ti.ty_params);\n+                        log #fmt(\"--- lazily_emit_tydesc_glue CMP %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n fn call_tydesc_glue_full(&@block_ctxt cx, ValueRef v,\n-                         ValueRef tydesc, int field) {\n+                         ValueRef tydesc, int field,\n+                         &option::t[@tydesc_info] static_ti) {\n+\n+    lazily_emit_tydesc_glue(cx, field, static_ti);\n+\n     auto llrawptr = cx.build.BitCast(v, T_ptr(T_i8()));\n     auto lltydescs = cx.build.GEP(tydesc,\n                                   vec(C_int(0),\n@@ -2857,10 +2994,13 @@ fn call_tydesc_glue_full(&@block_ctxt cx, ValueRef v,\n \n fn call_tydesc_glue(&@block_ctxt cx, ValueRef v,\n                     &ty::t t, bool escapes, int field) -> result {\n-    auto td = get_tydesc(cx, t, escapes);\n+\n+    let option::t[@tydesc_info] ti = none[@tydesc_info];\n+    auto td = get_tydesc(cx, t, escapes, ti);\n+\n     call_tydesc_glue_full(td.bcx,\n                           spill_if_immediate(td.bcx, v, t),\n-                          td.val, field);\n+                          td.val, field, ti);\n     ret res(td.bcx, C_nil());\n }\n \n@@ -2900,7 +3040,11 @@ fn call_cmp_glue(&@block_ctxt cx,\n     auto llrawlhsptr = cx.build.BitCast(lllhs, T_ptr(T_i8()));\n     auto llrawrhsptr = cx.build.BitCast(llrhs, T_ptr(T_i8()));\n \n-    auto r = get_tydesc(cx, t, false);\n+    auto ti = none[@tydesc_info];\n+    auto r = get_tydesc(cx, t, false, ti);\n+\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, ti);\n+\n     auto lltydescs =\n         r.bcx.build.GEP(r.val, vec(C_int(0),\n                                    C_int(abi::tydesc_field_first_param)));\n@@ -3268,11 +3412,14 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t,\n     }\n \n     auto bcx = cx;\n-\n-    auto llvec_tydesc = get_tydesc(bcx, t, false);\n+    auto ti = none[@tydesc_info];\n+    auto llvec_tydesc = get_tydesc(bcx, t, false, ti);\n     bcx = llvec_tydesc.bcx;\n \n-    auto llelt_tydesc = get_tydesc(bcx, elt_ty, false);\n+    ti = none[@tydesc_info];\n+    auto llelt_tydesc = get_tydesc(bcx, elt_ty, false, ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, ti);\n     bcx = llelt_tydesc.bcx;\n \n     auto dst = bcx.build.PointerCast(lhs, T_ptr(T_opaque_vec_ptr()));\n@@ -4105,6 +4252,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n }\n \n type generic_info = rec(ty::t item_type,\n+                        vec[option::t[@tydesc_info]] static_tis,\n                         vec[ValueRef] tydescs);\n \n type lval_result = rec(result res,\n@@ -4169,13 +4317,17 @@ fn lval_generic_fn(&@block_ctxt cx,\n     if (_vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = vec();\n+        let vec[option::t[@tydesc_info]] tis = vec();\n         for (ty::t t in tys) {\n             // TODO: Doesn't always escape.\n-            auto td = get_tydesc(bcx, t, true);\n+            auto ti = none[@tydesc_info];\n+            auto td = get_tydesc(bcx, t, true, ti);\n+            tis += vec(ti);\n             bcx = td.bcx;\n             _vec::push[ValueRef](tydescs, td.val);\n         }\n         auto gen = rec( item_type = tpt._1,\n+                        static_tis = tis,\n                         tydescs = tydescs );\n         lv = rec(res = res(bcx, lv.res.val),\n                  generic = some[generic_info](gen)\n@@ -4664,6 +4816,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 lltydescs = vec();\n             }\n             case (some[generic_info](?ginfo)) {\n+                lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n                 outgoing_fty = ginfo.item_type;\n                 lltydescs = ginfo.tydescs;\n             }\n@@ -4731,7 +4884,9 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 bcx.build.GEP(closure,\n                               vec(C_int(0),\n                                   C_int(abi::closure_elt_tydesc)));\n-            auto bindings_tydesc = get_tydesc(bcx, bindings_ty, true);\n+            auto ti = none[@tydesc_info];\n+            auto bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n+            lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n             bcx = bindings_tydesc.bcx;\n             bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n@@ -4772,9 +4927,11 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n             // If necessary, copy tydescs describing type parameters into the\n             // appropriate slot in the closure.\n+\n             alt (f_res.generic) {\n                 case (none[generic_info]) { /* nothing to do */ }\n                 case (some[generic_info](?ginfo)) {\n+                    lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n                     auto ty_params_slot =\n                         bcx.build.GEP(closure,\n                                       vec(C_int(0),\n@@ -4920,6 +5077,7 @@ fn trans_args(&@block_ctxt cx,\n \n     alt (gen) {\n         case (some[generic_info](?g)) {\n+            lazily_emit_all_generic_info_tydesc_glues(cx, g);\n             lltydescs = g.tydescs;\n             args = ty::ty_fn_args(cx.fcx.lcx.ccx.tcx, g.item_type);\n             retty = ty::ty_fn_ret(cx.fcx.lcx.ccx.tcx, g.item_type);\n@@ -6554,7 +6712,10 @@ fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n                          vec(0, abi::obj_body_elt_tydesc));\n         bcx = body_tydesc.bcx;\n \n-        auto body_td = get_tydesc(bcx, body_ty, true);\n+        auto ti = none[@tydesc_info];\n+        auto body_td = get_tydesc(bcx, body_ty, true, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+\n         auto dtor = C_null(T_ptr(T_glue_fn(ccx.tn)));\n         alt (ob.dtor) {\n             case (some[@ast::method](?d)) {\n@@ -7603,9 +7764,10 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n         fn take_one(ValueRef elt_tydesc,\n                     &@block_ctxt cx,\n                     ValueRef dst, ValueRef src) -> result {\n+            auto ti = none[@tydesc_info];\n             call_tydesc_glue_full(cx, src,\n                                   elt_tydesc,\n-                                  abi::tydesc_field_take_glue);\n+                                  abi::tydesc_field_take_glue, ti);\n             ret res(cx, src);\n         }\n \n@@ -7811,6 +7973,11 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                     type_abbrevs = abbrevs,\n                     type_short_names = short_names,\n                     tcx = tcx,\n+                    stats = rec(mutable n_static_tydescs = 0u,\n+                                mutable n_derived_tydescs = 0u,\n+                                mutable n_glues_created = 0u,\n+                                mutable n_null_glues = 0u,\n+                                mutable n_real_glues = 0u),\n                     upcalls = upcall::declare_upcalls(tn, llmod));\n     auto cx = new_local_ctxt(ccx);\n \n@@ -7826,9 +7993,20 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n         trans_main_fn(cx, crate_ptr, crate_map);\n     }\n \n+    emit_tydescs(ccx);\n+\n     // Translate the metadata:\n     middle::metadata::write_metadata(cx.ccx, crate);\n \n+    if (ccx.sess.get_opts().stats) {\n+        log_err \"--- trans stats ---\";\n+        log_err #fmt(\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs);\n+        log_err #fmt(\"n_derived_tydescs: %u\", ccx.stats.n_derived_tydescs);\n+        log_err #fmt(\"n_glues_created: %u\", ccx.stats.n_glues_created);\n+        log_err #fmt(\"n_null_glues: %u\", ccx.stats.n_null_glues);\n+        log_err #fmt(\"n_real_glues: %u\", ccx.stats.n_real_glues);\n+    }\n+\n     ret llmod;\n }\n "}]}