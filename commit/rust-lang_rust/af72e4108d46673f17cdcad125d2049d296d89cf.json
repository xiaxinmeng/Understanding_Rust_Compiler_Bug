{"sha": "af72e4108d46673f17cdcad125d2049d296d89cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNzJlNDEwOGQ0NjY3M2YxN2NkY2FkMTI1ZDIwNDlkMjk2ZDg5Y2Y=", "commit": {"author": {"name": "David Creswick", "email": "dcrewi@gyrae.net", "date": "2013-09-12T01:49:46Z"}, "committer": {"name": "David Creswick", "email": "dcrewi@gyrae.net", "date": "2013-09-18T01:48:04Z"}, "message": "Generate random big integers within a range\n\nThanks to @huonw for feedback", "tree": {"sha": "5d8df0134e98e02d1c67eab06d88b1bab3935d4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d8df0134e98e02d1c67eab06d88b1bab3935d4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af72e4108d46673f17cdcad125d2049d296d89cf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af72e4108d46673f17cdcad125d2049d296d89cf", "html_url": "https://github.com/rust-lang/rust/commit/af72e4108d46673f17cdcad125d2049d296d89cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af72e4108d46673f17cdcad125d2049d296d89cf/comments", "author": {"login": "dcrewi", "id": 1852207, "node_id": "MDQ6VXNlcjE4NTIyMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1852207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcrewi", "html_url": "https://github.com/dcrewi", "followers_url": "https://api.github.com/users/dcrewi/followers", "following_url": "https://api.github.com/users/dcrewi/following{/other_user}", "gists_url": "https://api.github.com/users/dcrewi/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcrewi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcrewi/subscriptions", "organizations_url": "https://api.github.com/users/dcrewi/orgs", "repos_url": "https://api.github.com/users/dcrewi/repos", "events_url": "https://api.github.com/users/dcrewi/events{/privacy}", "received_events_url": "https://api.github.com/users/dcrewi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dcrewi", "id": 1852207, "node_id": "MDQ6VXNlcjE4NTIyMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1852207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcrewi", "html_url": "https://github.com/dcrewi", "followers_url": "https://api.github.com/users/dcrewi/followers", "following_url": "https://api.github.com/users/dcrewi/following{/other_user}", "gists_url": "https://api.github.com/users/dcrewi/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcrewi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcrewi/subscriptions", "organizations_url": "https://api.github.com/users/dcrewi/orgs", "repos_url": "https://api.github.com/users/dcrewi/repos", "events_url": "https://api.github.com/users/dcrewi/events{/privacy}", "received_events_url": "https://api.github.com/users/dcrewi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ab8a3f529e8b6735e0c8a998dc78667cabe40e", "html_url": "https://github.com/rust-lang/rust/commit/91ab8a3f529e8b6735e0c8a998dc78667cabe40e"}], "stats": {"total": 142, "additions": 140, "deletions": 2}, "files": [{"sha": "3228268c76870c3e68be6a2962fb7ddcb620891a", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 140, "deletions": 2, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/af72e4108d46673f17cdcad125d2049d296d89cf/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af72e4108d46673f17cdcad125d2049d296d89cf/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=af72e4108d46673f17cdcad125d2049d296d89cf", "patch": "@@ -697,6 +697,13 @@ impl BigUint {\n         }\n         return BigUint::new(shifted);\n     }\n+\n+    /// Determines the fewest bits necessary to express the BigUint.\n+    pub fn bits(&self) -> uint {\n+        if self.is_zero() { return 0; }\n+        let zeros = self.data.last().leading_zeros();\n+        return self.data.len()*BigDigit::bits - (zeros as uint);\n+    }\n }\n \n #[cfg(target_word_size = \"64\")]\n@@ -1115,10 +1122,23 @@ trait RandBigInt {\n \n     /// Generate a random BigInt of the given bit size.\n     fn gen_bigint(&mut self, bit_size: uint) -> BigInt;\n+\n+    /// Generate a random BigUint less than the given bound. Fails\n+    /// when the bound is zero.\n+    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;\n+\n+    /// Generate a random BigUint within the given range. The lower\n+    /// bound is inclusive; the upper bound is exclusive. Fails when\n+    /// the upper bound is not greater than the lower bound.\n+    fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;\n+\n+    /// Generate a random BigInt within the given range. The lower\n+    /// bound is inclusive; the upper bound is exclusive. Fails when\n+    /// the upper bound is not greater than the lower bound.\n+    fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;\n }\n \n impl<R: Rng> RandBigInt for R {\n-    /// Generate a random BigUint of the given bit size.\n     fn gen_biguint(&mut self, bit_size: uint) -> BigUint {\n         let (digits, rem) = bit_size.div_rem(&BigDigit::bits);\n         let mut data = vec::with_capacity(digits+1);\n@@ -1132,7 +1152,6 @@ impl<R: Rng> RandBigInt for R {\n         return BigUint::new(data);\n     }\n \n-    /// Generate a random BigInt of the given bit size.\n     fn gen_bigint(&mut self, bit_size: uint) -> BigInt {\n         // Generate a random BigUint...\n         let biguint = self.gen_biguint(bit_size);\n@@ -1154,6 +1173,32 @@ impl<R: Rng> RandBigInt for R {\n         };\n         return BigInt::from_biguint(sign, biguint);\n     }\n+\n+    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {\n+        assert!(!bound.is_zero());\n+        let bits = bound.bits();\n+        loop {\n+            let n = self.gen_biguint(bits);\n+            if n < *bound { return n; }\n+        }\n+    }\n+\n+    fn gen_biguint_range(&mut self,\n+                         lbound: &BigUint,\n+                         ubound: &BigUint)\n+                         -> BigUint {\n+        assert!(*lbound < *ubound);\n+        return *lbound + self.gen_biguint_below(&(*ubound - *lbound));\n+    }\n+\n+    fn gen_bigint_range(&mut self,\n+                        lbound: &BigInt,\n+                        ubound: &BigInt)\n+                        -> BigInt {\n+        assert!(*lbound < *ubound);\n+        let delta = (*ubound - *lbound).to_biguint();\n+        return *lbound + self.gen_biguint_below(&delta).to_bigint();\n+    }\n }\n \n impl BigInt {\n@@ -1780,12 +1825,63 @@ mod biguint_tests {\n         check(30, \"265252859812191058636308480000000\");\n     }\n \n+    #[test]\n+    fn test_bits() {\n+        assert_eq!(BigUint::new(~[0,0,0,0]).bits(), 0);\n+        assert_eq!(BigUint::from_uint(0).bits(), 0);\n+        assert_eq!(BigUint::from_uint(1).bits(), 1);\n+        assert_eq!(BigUint::from_uint(3).bits(), 2);\n+        let n: BigUint = FromStrRadix::from_str_radix(\"4000000000\", 16).unwrap();\n+        assert_eq!(n.bits(), 39);\n+        let one: BigUint = One::one();\n+        assert_eq!((one << 426).bits(), 427);\n+    }\n+\n     #[test]\n     fn test_rand() {\n         let mut rng = task_rng();\n         let _n: BigUint = rng.gen_biguint(137);\n         assert!(rng.gen_biguint(0).is_zero());\n     }\n+\n+    #[test]\n+    fn test_rand_range() {\n+        let mut rng = task_rng();\n+\n+        do 10.times {\n+            assert_eq!(rng.gen_bigint_range(&BigInt::from_uint(236),\n+                                            &BigInt::from_uint(237)),\n+                       BigInt::from_uint(236));\n+        }\n+\n+        let l = BigUint::from_uint(403469000 + 2352);\n+        let u = BigUint::from_uint(403469000 + 3513);\n+        do 1000.times {\n+            let n: BigUint = rng.gen_biguint_below(&u);\n+            assert!(n < u);\n+\n+            let n: BigUint = rng.gen_biguint_range(&l, &u);\n+            assert!(n >= l);\n+            assert!(n < u);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_zero_rand_range() {\n+        task_rng().gen_biguint_range(&BigUint::from_uint(54),\n+                                     &BigUint::from_uint(54));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_negative_rand_range() {\n+        let mut rng = task_rng();\n+        let l = BigUint::from_uint(2352);\n+        let u = BigUint::from_uint(3513);\n+        // Switching u and l should fail:\n+        let _n: BigUint = rng.gen_biguint_range(&u, &l);\n+    }\n }\n \n #[cfg(test)]\n@@ -2237,6 +2333,48 @@ mod bigint_tests {\n         let _n: BigInt = rng.gen_bigint(137);\n         assert!(rng.gen_bigint(0).is_zero());\n     }\n+\n+    #[test]\n+    fn test_rand_range() {\n+        let mut rng = task_rng();\n+\n+        do 10.times {\n+            assert_eq!(rng.gen_bigint_range(&BigInt::from_uint(236),\n+                                            &BigInt::from_uint(237)),\n+                       BigInt::from_uint(236));\n+        }\n+\n+        fn check(l: BigInt, u: BigInt) {\n+            let mut rng = task_rng();\n+            do 1000.times {\n+                let n: BigInt = rng.gen_bigint_range(&l, &u);\n+                assert!(n >= l);\n+                assert!(n < u);\n+            }\n+        }\n+        let l = BigInt::from_uint(403469000 + 2352);\n+        let u = BigInt::from_uint(403469000 + 3513);\n+        check( l.clone(),  u.clone());\n+        check(-l.clone(),  u.clone());\n+        check(-u.clone(), -l.clone());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_zero_rand_range() {\n+        task_rng().gen_bigint_range(&IntConvertible::from_int(54),\n+                                    &IntConvertible::from_int(54));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_negative_rand_range() {\n+        let mut rng = task_rng();\n+        let l = BigInt::from_uint(2352);\n+        let u = BigInt::from_uint(3513);\n+        // Switching u and l should fail:\n+        let _n: BigInt = rng.gen_bigint_range(&u, &l);\n+    }\n }\n \n #[cfg(test)]"}]}