{"sha": "39ce393a9e5a71aa410923b22e67968a91c00582", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Y2UzOTNhOWU1YTcxYWE0MTA5MjNiMjJlNjc5NjhhOTFjMDA1ODI=", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-03-29T05:55:43Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-04-20T16:54:58Z"}, "message": "Automatically categorize the changelog entries", "tree": {"sha": "95cf80d1b805e4af2ec936b4f561ea0ff0d65fb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95cf80d1b805e4af2ec936b4f561ea0ff0d65fb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ce393a9e5a71aa410923b22e67968a91c00582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ce393a9e5a71aa410923b22e67968a91c00582", "html_url": "https://github.com/rust-lang/rust/commit/39ce393a9e5a71aa410923b22e67968a91c00582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ce393a9e5a71aa410923b22e67968a91c00582/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad131049c4cd1302af1a5616ff83d0e1f0cadea2", "html_url": "https://github.com/rust-lang/rust/commit/ad131049c4cd1302af1a5616ff83d0e1f0cadea2"}], "stats": {"total": 216, "additions": 173, "deletions": 43}, "files": [{"sha": "699a48e630812fe7f96231131028ba39ab8fc178", "filename": "docs/dev/README.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39ce393a9e5a71aa410923b22e67968a91c00582/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/39ce393a9e5a71aa410923b22e67968a91c00582/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=39ce393a9e5a71aa410923b22e67968a91c00582", "patch": "@@ -208,20 +208,26 @@ Release process is handled by `release`, `dist` and `promote` xtasks, `release`\n \n Additionally, it assumes that remote for `rust-analyzer` is called `upstream` (I use `origin` to point to my fork).\n \n+`release` calls the GitHub API calls to scrape pull request comments and categorize them in the changelog.\n+This step uses the `curl` and `jq` applications, which need to be available in `PATH`.\n+Finally, you need to obtain a GitHub personal access token and set the `GITHUB_TOKEN` environment variable.\n+\n Release steps:\n \n-1. Inside rust-analyzer, run `cargo xtask release`. This will:\n+1. Set the `GITHUB_TOKEN` environment variable.\n+2. Inside rust-analyzer, run `cargo xtask release`. This will:\n    * checkout the `release` branch\n    * reset it to `upstream/nightly`\n    * push it to `upstream`. This triggers GitHub Actions which:\n      * runs `cargo xtask dist` to package binaries and VS Code extension\n      * makes a GitHub release\n      * pushes VS Code extension to the marketplace\n-   * create new changelog in `rust-analyzer.github.io`\n-2. While the release is in progress, fill in the changelog\n-3. Commit & push the changelog\n-4. Tweet\n-5. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's submodule.\n+   * call the GitHub API for PR details\n+   * create a new changelog in `rust-analyzer.github.io`\n+3. While the release is in progress, fill in the changelog\n+4. Commit & push the changelog\n+5. Tweet\n+6. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's submodule.\n    Self-approve the PR.\n \n If the GitHub Actions release fails because of a transient problem like a timeout, you can re-run the job from the Actions console."}, {"sha": "22bb504674fb69988c7a6709485af1ba48d74127", "filename": "xtask/src/release.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/39ce393a9e5a71aa410923b22e67968a91c00582/xtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce393a9e5a71aa410923b22e67968a91c00582/xtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Frelease.rs?ref=39ce393a9e5a71aa410923b22e67968a91c00582", "patch": "@@ -1,4 +1,4 @@\n-use std::fmt::Write;\n+mod changelog;\n \n use xshell::{cmd, cp, pushd, read_dir, write_file};\n \n@@ -38,42 +38,7 @@ impl flags::Release {\n         let tags = cmd!(\"git tag --list\").read()?;\n         let prev_tag = tags.lines().filter(|line| is_release_tag(line)).last().unwrap();\n \n-        let git_log = cmd!(\"git log {prev_tag}..HEAD --merges --reverse\").read()?;\n-        let mut git_log_summary = String::new();\n-        for line in git_log.lines() {\n-            let line = line.trim_start();\n-            if let Some(p) = line.find(':') {\n-                if let Ok(pr) = line[..p].parse::<u32>() {\n-                    writeln!(git_log_summary, \"* pr:{}[]{}\", pr, &line[p + 1..]).unwrap();\n-                }\n-            }\n-        }\n-\n-        let contents = format!(\n-            \"\\\n-= Changelog #{}\n-:sectanchors:\n-:page-layout: post\n-\n-Commit: commit:{}[] +\n-Release: release:{}[]\n-\n-== Sponsors\n-\n-**Become a sponsor:** On https://opencollective.com/rust-analyzer/[OpenCollective] or\n-https://github.com/sponsors/rust-analyzer[GitHub Sponsors].\n-\n-== New Features\n-\n-{}\n-\n-== Fixes\n-\n-== Internal Improvements\n-\",\n-            changelog_n, commit, today, git_log_summary\n-        );\n-\n+        let contents = changelog::get_changelog(changelog_n, &commit, prev_tag, &today)?;\n         let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n         write_file(&path, &contents)?;\n "}, {"sha": "ffcae2cf726c5c7a274e996950a36e3fe07ba414", "filename": "xtask/src/release/changelog.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/39ce393a9e5a71aa410923b22e67968a91c00582/xtask%2Fsrc%2Frelease%2Fchangelog.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce393a9e5a71aa410923b22e67968a91c00582/xtask%2Fsrc%2Frelease%2Fchangelog.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Frelease%2Fchangelog.rs?ref=39ce393a9e5a71aa410923b22e67968a91c00582", "patch": "@@ -0,0 +1,159 @@\n+use std::fmt::Write;\n+use std::{env, iter};\n+\n+use anyhow::{bail, Result};\n+use xshell::cmd;\n+\n+pub(crate) fn get_changelog(\n+    changelog_n: usize,\n+    commit: &str,\n+    prev_tag: &str,\n+    today: &str,\n+) -> Result<String> {\n+    let git_log = cmd!(\"git log {prev_tag}..HEAD --merges --reverse\").read()?;\n+    let mut features = String::new();\n+    let mut fixes = String::new();\n+    let mut internal = String::new();\n+    let mut others = String::new();\n+    for line in git_log.lines() {\n+        let line = line.trim_start();\n+        if let Some(p) = line.find(':') {\n+            let pr = &line[..p];\n+            if let Ok(pr_num) = pr.parse::<u32>() {\n+                let accept = \"Accept: application/vnd.github.v3+json\";\n+                let token = match env::var(\"GITHUB_TOKEN\") {\n+                    Ok(token) => token,\n+                    Err(_) => bail!(\"Please obtain a personal access token from https://github.com/settings/tokens and set the `GITHUB_TOKEN` environment variable.\"),\n+                };\n+                let authorization = format!(\"Authorization: token {}\", token);\n+                let pr_url = \"https://api.github.com/repos/rust-analyzer/rust-analyzer/issues\";\n+\n+                // we don't use an HTTPS client or JSON parser to keep the build times low\n+                let pr_json =\n+                    cmd!(\"curl -s -H {accept} -H {authorization} {pr_url}/{pr}\").read()?;\n+                let pr_title = cmd!(\"jq .title\").stdin(&pr_json).read()?;\n+                let pr_title = unescape(&pr_title[1..pr_title.len() - 1]);\n+                let pr_comment = cmd!(\"jq .body\").stdin(pr_json).read()?;\n+\n+                let comments_json =\n+                    cmd!(\"curl -s -H {accept} -H {authorization} {pr_url}/{pr}/comments\").read()?;\n+                let pr_comments = cmd!(\"jq .[].body\").stdin(comments_json).read()?;\n+\n+                let l = iter::once(pr_comment.as_str())\n+                    .chain(pr_comments.lines())\n+                    .rev()\n+                    .find_map(|it| {\n+                        let it = unescape(&it[1..it.len() - 1]);\n+                        it.lines().find_map(parse_changelog_line)\n+                    })\n+                    .into_iter()\n+                    .next()\n+                    .unwrap_or_else(|| parse_title_line(&pr_title));\n+                let s = match l.kind {\n+                    PrKind::Feature => &mut features,\n+                    PrKind::Fix => &mut fixes,\n+                    PrKind::Internal => &mut internal,\n+                    PrKind::Other => &mut others,\n+                    PrKind::Skip => continue,\n+                };\n+                writeln!(s, \"* pr:{}[] {}\", pr_num, l.message.as_deref().unwrap_or(&pr_title))\n+                    .unwrap();\n+            }\n+        }\n+    }\n+\n+    let contents = format!(\n+        \"\\\n+= Changelog #{}\n+:sectanchors:\n+:page-layout: post\n+\n+Commit: commit:{}[] +\n+Release: release:{}[]\n+\n+== Sponsors\n+\n+**Become a sponsor:** On https://opencollective.com/rust-analyzer/[OpenCollective] or\n+https://github.com/sponsors/rust-analyzer[GitHub Sponsors].\n+\n+== New Features\n+\n+{}\n+\n+== Fixes\n+\n+{}\n+\n+== Internal Improvements\n+\n+{}\n+\n+== Others\n+\n+{}\n+\",\n+        changelog_n, commit, today, features, fixes, internal, others\n+    );\n+    Ok(contents)\n+}\n+\n+#[derive(Clone, Copy)]\n+enum PrKind {\n+    Feature,\n+    Fix,\n+    Internal,\n+    Other,\n+    Skip,\n+}\n+\n+struct PrInfo {\n+    message: Option<String>,\n+    kind: PrKind,\n+}\n+\n+fn unescape(s: &str) -> String {\n+    s.replace(r#\"\\\"\"#, \"\").replace(r#\"\\n\"#, \"\\n\").replace(r#\"\\r\"#, \"\")\n+}\n+\n+fn parse_changelog_line(s: &str) -> Option<PrInfo> {\n+    let parts = s.splitn(3, ' ').collect::<Vec<_>>();\n+    if parts.len() < 2 || parts[0] != \"changelog\" {\n+        return None;\n+    }\n+    let message = parts.get(2).map(|it| it.to_string());\n+    let kind = match parts[1].trim_end_matches(':') {\n+        \"feature\" => PrKind::Feature,\n+        \"fix\" => PrKind::Fix,\n+        \"internal\" => PrKind::Internal,\n+        \"skip\" => PrKind::Skip,\n+        _ => {\n+            let kind = PrKind::Other;\n+            let message = format!(\"{} {}\", parts[1], message.unwrap_or_default());\n+            return Some(PrInfo { kind, message: Some(message) });\n+        }\n+    };\n+    let res = PrInfo { kind, message };\n+    Some(res)\n+}\n+\n+fn parse_title_line(s: &str) -> PrInfo {\n+    let lower = s.to_ascii_lowercase();\n+    const PREFIXES: [(&str, PrKind); 5] = [\n+        (\"feat: \", PrKind::Feature),\n+        (\"feature: \", PrKind::Feature),\n+        (\"fix: \", PrKind::Fix),\n+        (\"internal: \", PrKind::Internal),\n+        (\"minor: \", PrKind::Skip),\n+    ];\n+\n+    for &(prefix, kind) in &PREFIXES {\n+        if lower.starts_with(prefix) {\n+            let message = match &kind {\n+                PrKind::Skip => None,\n+                _ => Some(s[prefix.len()..].to_string()),\n+            };\n+            return PrInfo { kind, message };\n+        }\n+    }\n+    PrInfo { kind: PrKind::Other, message: Some(s.to_string()) }\n+}"}]}