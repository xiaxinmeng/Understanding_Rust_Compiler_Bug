{"sha": "af24045ff0e17764524a9eaf243479a3260c2d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMjQwNDVmZjBlMTc3NjQ1MjRhOWVhZjI0MzQ3OWEzMjYwYzJkOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-19T01:46:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-19T01:46:33Z"}, "message": "auto merge of #13607 : brson/rust/to_owned, r=brson\n\nContinues https://github.com/mozilla/rust/pull/13548", "tree": {"sha": "bc160d119b2d963afa53e9bbb59aacee6bdc4ecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc160d119b2d963afa53e9bbb59aacee6bdc4ecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af24045ff0e17764524a9eaf243479a3260c2d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af24045ff0e17764524a9eaf243479a3260c2d8b", "html_url": "https://github.com/rust-lang/rust/commit/af24045ff0e17764524a9eaf243479a3260c2d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af24045ff0e17764524a9eaf243479a3260c2d8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b7cfd3c724bbad9dd8a0115bb2619f307b73f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b7cfd3c724bbad9dd8a0115bb2619f307b73f8c", "html_url": "https://github.com/rust-lang/rust/commit/9b7cfd3c724bbad9dd8a0115bb2619f307b73f8c"}, {"sha": "919889a1d688a6bbe2edac8705f048f06b1b455c", "url": "https://api.github.com/repos/rust-lang/rust/commits/919889a1d688a6bbe2edac8705f048f06b1b455c", "html_url": "https://github.com/rust-lang/rust/commit/919889a1d688a6bbe2edac8705f048f06b1b455c"}], "stats": {"total": 5727, "additions": 2910, "deletions": 2817}, "files": [{"sha": "cae6c2b656d6542323eeec7fa74d22f9f4434e2b", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -93,7 +93,7 @@ pub fn parse_config(args: Vec<~str> ) -> config {\n     assert!(!args.is_empty());\n     let argv0 = (*args.get(0)).clone();\n     let args_ = args.tail();\n-    if *args.get(1) == ~\"-h\" || *args.get(1) == ~\"--help\" {\n+    if *args.get(1) == \"-h\".to_owned() || *args.get(1) == \"--help\".to_owned() {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(message, groups.as_slice()));\n         println!(\"\");\n@@ -181,7 +181,7 @@ pub fn log_config(config: &config) {\n     logv(c, format!(\"adb_test_dir: {}\", config.adb_test_dir));\n     logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n     match config.test_shard {\n-        None => logv(c, ~\"test_shard: (all)\"),\n+        None => logv(c, \"test_shard: (all)\".to_owned()),\n         Some((a,b)) => logv(c, format!(\"test_shard: {}.{}\", a, b))\n     }\n     logv(c, format!(\"verbose: {}\", config.verbose));\n@@ -199,7 +199,7 @@ pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n }\n \n pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n-    match maybestr { None => ~\"(none)\", Some(s) => { s } }\n+    match maybestr { None => \"(none)\".to_owned(), Some(s) => { s } }\n }\n \n pub fn str_mode(s: ~str) -> mode {\n@@ -216,17 +216,17 @@ pub fn str_mode(s: ~str) -> mode {\n \n pub fn mode_str(mode: mode) -> ~str {\n     match mode {\n-      mode_compile_fail => ~\"compile-fail\",\n-      mode_run_fail => ~\"run-fail\",\n-      mode_run_pass => ~\"run-pass\",\n-      mode_pretty => ~\"pretty\",\n-      mode_debug_info => ~\"debug-info\",\n-      mode_codegen => ~\"codegen\",\n+      mode_compile_fail => \"compile-fail\".to_owned(),\n+      mode_run_fail => \"run-fail\".to_owned(),\n+      mode_run_pass => \"run-pass\".to_owned(),\n+      mode_pretty => \"pretty\".to_owned(),\n+      mode_debug_info => \"debug-info\".to_owned(),\n+      mode_codegen => \"codegen\".to_owned(),\n     }\n }\n \n pub fn run_tests(config: &config) {\n-    if config.target == ~\"arm-linux-androideabi\" {\n+    if config.target == \"arm-linux-androideabi\".to_owned() {\n         match config.mode{\n             mode_debug_info => {\n                 println!(\"arm-linux-androideabi debug-info \\\n@@ -296,10 +296,10 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n-          mode_pretty => vec!(~\".rs\"),\n-          _ => vec!(~\".rc\", ~\".rs\")\n+          mode_pretty => vec!(\".rs\".to_owned()),\n+          _ => vec!(\".rc\".to_owned(), \".rs\".to_owned())\n         };\n-    let invalid_prefixes = vec!(~\".\", ~\"#\", ~\"~\");\n+    let invalid_prefixes = vec!(\".\".to_owned(), \"#\".to_owned(), \"~\".to_owned());\n     let name = testfile.filename_str().unwrap();\n \n     let mut valid = false;"}, {"sha": "9300cee432ff44a177e2e3c8b7a649294979ab95", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -31,7 +31,7 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n \n fn parse_expected(line_num: uint, line: ~str) -> Vec<ExpectedError> {\n     let line = line.trim();\n-    let error_tag = ~\"//~\";\n+    let error_tag = \"//~\".to_owned();\n     let mut idx;\n     match line.find_str(error_tag) {\n       None => return Vec::new(),"}, {"sha": "1e9ce5789d17446f70c58dacbaeb97cb08668d19", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -112,10 +112,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n \n pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     fn ignore_target(config: &config) -> ~str {\n-        ~\"ignore-\" + util::get_os(config.target)\n+        \"ignore-\".to_owned() + util::get_os(config.target)\n     }\n     fn ignore_stage(config: &config) -> ~str {\n-        ~\"ignore-\" + config.stage_id.split('-').next().unwrap()\n+        \"ignore-\".to_owned() + config.stage_id.split('-').next().unwrap()\n     }\n \n     let val = iter_header(testfile, |ln| {\n@@ -149,23 +149,23 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n }\n \n fn parse_error_pattern(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, ~\"error-pattern\")\n+    parse_name_value_directive(line, \"error-pattern\".to_owned())\n }\n \n fn parse_aux_build(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, ~\"aux-build\")\n+    parse_name_value_directive(line, \"aux-build\".to_owned())\n }\n \n fn parse_compile_flags(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, ~\"compile-flags\")\n+    parse_name_value_directive(line, \"compile-flags\".to_owned())\n }\n \n fn parse_debugger_cmd(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, ~\"debugger\")\n+    parse_name_value_directive(line, \"debugger\".to_owned())\n }\n \n fn parse_check_line(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, ~\"check\")\n+    parse_name_value_directive(line, \"check\".to_owned())\n }\n \n fn parse_force_host(line: &str) -> bool {\n@@ -181,12 +181,12 @@ fn parse_no_prefer_dynamic(line: &str) -> bool {\n }\n \n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n-    parse_name_value_directive(line, ~\"exec-env\").map(|nv| {\n+    parse_name_value_directive(line, \"exec-env\".to_owned()).map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<~str> = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n \n         match strs.len() {\n-          1u => (strs.pop().unwrap(), ~\"\"),\n+          1u => (strs.pop().unwrap(), \"\".to_owned()),\n           2u => {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n@@ -197,7 +197,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n }\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n-    match parse_name_value_directive(line, ~\"pp-exact\") {\n+    match parse_name_value_directive(line, \"pp-exact\".to_owned()) {\n       Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {"}, {"sha": "7d3aa33aae8533e3f1e8f011a85569bbb63b2430", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -29,7 +29,7 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n         (k, new_v)\n     }).collect();\n     if prog.ends_with(\"rustc.exe\") {\n-        new_env.push((~\"RUST_THREADS\", ~\"1\"));\n+        new_env.push((\"RUST_THREADS\".to_owned(), \"1\".to_owned()));\n     }\n     return new_env;\n }\n@@ -49,7 +49,7 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(~str,~str)> {\n     };\n     let prev = match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n         Some(i) => env.remove(i).unwrap().val1(),\n-        None => ~\"\",\n+        None => \"\".to_owned(),\n     };\n     env.push((var.to_owned(), if prev.is_empty() {\n         lib_path + \":\" + aux_path"}, {"sha": "086e6c06f7090f64cfd5b1900d73176514fcdf69", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 85, "deletions": 82, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -75,15 +75,15 @@ fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_ProcRes(~\"compile-fail test compiled successfully!\", &proc_res);\n+        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_owned(), &proc_res);\n     }\n \n     check_correct_failure_status(&proc_res);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n-            fatal(~\"both error pattern and expected errors specified\");\n+            fatal(\"both error pattern and expected errors specified\".to_owned());\n         }\n         check_expected_errors(expected_errors, testfile, &proc_res);\n     } else {\n@@ -96,7 +96,7 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n         let proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(~\"compilation failed!\", &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -107,7 +107,7 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n     if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n-        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &proc_res);\n+        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_owned(), &proc_res);\n     }\n \n     check_correct_failure_status(&proc_res);\n@@ -129,25 +129,25 @@ fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n         let mut proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(~\"compilation failed!\", &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n         }\n \n         proc_res = exec_compiled_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(~\"test run failed!\", &proc_res);\n+            fatal_ProcRes(\"test run failed!\".to_owned(), &proc_res);\n         }\n     } else {\n         let proc_res = jit_test(config, props, testfile);\n \n-        if !proc_res.status.success() { fatal_ProcRes(~\"jit failed!\", &proc_res); }\n+        if !proc_res.status.success() { fatal_ProcRes(\"jit failed!\".to_owned(), &proc_res); }\n     }\n }\n \n fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n-        logv(config, ~\"testing for exact pretty-printing\");\n-    } else { logv(config, ~\"testing for converging pretty-printing\"); }\n+        logv(config, \"testing for exact pretty-printing\".to_owned());\n+    } else { logv(config, \"testing for converging pretty-printing\".to_owned()); }\n \n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n@@ -185,7 +185,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n-        let cr = ~\"\\r\";\n+        let cr = \"\\r\".to_owned();\n         actual = actual.replace(cr, \"\");\n         expected = expected.replace(cr, \"\");\n     }\n@@ -196,7 +196,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let proc_res = typecheck_source(config, props, testfile, actual);\n \n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"pretty-printed source does not typecheck\", &proc_res);\n+        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_owned(), &proc_res);\n     }\n \n     return;\n@@ -207,15 +207,15 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     }\n \n     fn make_pp_args(config: &config, _testfile: &Path) -> ProcArgs {\n-        let args = vec!(~\"-\", ~\"--pretty\", ~\"normal\",\n-                     ~\"--target=\" + config.target);\n+        let args = vec!(\"-\".to_owned(), \"--pretty\".to_owned(), \"normal\".to_owned(),\n+                     \"--target=\".to_owned() + config.target);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n     }\n \n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n-            error(~\"pretty-printed source does not match expected source\");\n+            error(\"pretty-printed source does not match expected source\".to_owned());\n             println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n@@ -245,11 +245,11 @@ actual:\\n\\\n             config.target.as_slice()\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(~\"-\",\n-                         ~\"--no-trans\", ~\"--crate-type=lib\",\n-                         ~\"--target=\" + target,\n-                         ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n-                         ~\"-L\",\n+        let mut args = vec!(\"-\".to_owned(),\n+                         \"--no-trans\".to_owned(), \"--crate-type=lib\".to_owned(),\n+                         \"--target=\".to_owned() + target,\n+                         \"-L\".to_owned(), config.build_base.as_str().unwrap().to_owned(),\n+                         \"-L\".to_owned(),\n                          aux_dir.as_str().unwrap().to_owned());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n@@ -272,7 +272,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut proc_res = compile_test(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"compilation failed!\", &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -284,33 +284,34 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             cmds = cmds.replace(\"run\",\"continue\");\n \n             // write debugger script\n-            let script_str = [~\"set charset UTF-8\",\n+            let script_str = [\"set charset UTF-8\".to_owned(),\n                               format!(\"file {}\",exe_file.as_str().unwrap().to_owned()),\n-                              ~\"target remote :5039\",\n+                              \"target remote :5039\".to_owned(),\n                               cmds,\n-                              ~\"quit\"].connect(\"\\n\");\n+                              \"quit\".to_owned()].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n \n             procsrv::run(\"\", config.adb_path,\n-                         [~\"push\", exe_file.as_str().unwrap().to_owned(),\n+                         [\"push\".to_owned(), exe_file.as_str().unwrap().to_owned(),\n                           config.adb_test_dir.clone()],\n-                         vec!((~\"\",~\"\")), Some(~\"\"))\n+                         vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             procsrv::run(\"\", config.adb_path,\n-                         [~\"forward\", ~\"tcp:5039\", ~\"tcp:5039\"],\n-                         vec!((~\"\",~\"\")), Some(~\"\"))\n+                         [\"forward\".to_owned(), \"tcp:5039\".to_owned(), \"tcp:5039\".to_owned()],\n+                         vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n                                   config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n                                   str::from_utf8(exe_file.filename().unwrap()).unwrap());\n \n             let mut process = procsrv::run_background(\"\", config.adb_path,\n-                                                      [~\"shell\",adb_arg.clone()],\n-                                                      vec!((~\"\",~\"\")), Some(~\"\"))\n+                                                      [\"shell\".to_owned(),adb_arg.clone()],\n+                                                      vec!((\"\".to_owned(),\"\".to_owned())),\n+                                                      Some(\"\".to_owned()))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n@@ -337,20 +338,20 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             }\n \n             if tool_path.is_empty() {\n-                fatal(~\"cannot found android cross path\");\n+                fatal(\"cannot found android cross path\".to_owned());\n             }\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = vec!(~\"-quiet\", ~\"-batch\", ~\"-nx\",\n+            let debugger_opts = vec!(\"-quiet\".to_owned(), \"-batch\".to_owned(), \"-nx\".to_owned(),\n                                   \"-command=\" + debugger_script.as_str().unwrap().to_owned());\n \n             let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n             let procsrv::Result{ out, err, status }=\n                 procsrv::run(\"\",\n                              gdb_path.as_slice(),\n                              debugger_opts.as_slice(),\n-                             vec!((~\"\",~\"\")),\n+                             vec!((\"\".to_owned(),\"\".to_owned())),\n                              None)\n                 .expect(format!(\"failed to exec `{}`\", gdb_path));\n             let cmdline = {\n@@ -370,22 +371,22 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n         _=> {\n             // write debugger script\n-            let script_str = [~\"set charset UTF-8\",\n+            let script_str = [\"set charset UTF-8\".to_owned(),\n                 cmds,\n-                ~\"quit\\n\"].connect(\"\\n\");\n+                \"quit\\n\".to_owned()].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n             // run debugger script with gdb\n             #[cfg(windows)]\n-            fn debugger() -> ~str { ~\"gdb.exe\" }\n+            fn debugger() -> ~str { \"gdb.exe\".to_owned() }\n             #[cfg(unix)]\n-            fn debugger() -> ~str { ~\"gdb\" }\n+            fn debugger() -> ~str { \"gdb\".to_owned() }\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = vec!(~\"-quiet\", ~\"-batch\", ~\"-nx\",\n+            let debugger_opts = vec!(\"-quiet\".to_owned(), \"-batch\".to_owned(), \"-nx\".to_owned(),\n                 \"-command=\" + debugger_script.as_str().unwrap().to_owned(),\n                 exe_file.as_str().unwrap().to_owned());\n             proc_args = ProcArgs {prog: debugger(), args: debugger_opts};\n@@ -394,7 +395,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     }\n \n     if !proc_res.status.success() {\n-        fatal(~\"gdb failed to execute\");\n+        fatal(\"gdb failed to execute\".to_owned());\n     }\n     let num_check_lines = check_lines.len();\n     if num_check_lines > 0 {\n@@ -448,7 +449,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         }\n \n         // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n-        let options_to_remove = [~\"-O\", ~\"-g\", ~\"--debuginfo\"];\n+        let options_to_remove = [\"-O\".to_owned(), \"-g\".to_owned(), \"--debuginfo\".to_owned()];\n         let new_options = split_maybe_args(options).move_iter()\n                                                    .filter(|x| !options_to_remove.contains(x))\n                                                    .collect::<Vec<~str>>()\n@@ -461,11 +462,12 @@ fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(~\"no error pattern specified in \" + testfile.display().as_maybe_owned().as_slice());\n+        fatal(\"no error pattern specified in \".to_owned() +\n+              testfile.display().as_maybe_owned().as_slice());\n     }\n \n     if proc_res.status.success() {\n-        fatal(~\"process did not return an error status\");\n+        fatal(\"process did not return an error status\".to_owned());\n     }\n \n     let mut next_err_idx = 0u;\n@@ -499,7 +501,7 @@ fn check_error_patterns(props: &TestProps,\n         for pattern in missing_patterns.iter() {\n             error(format!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_ProcRes(~\"multiple error patterns not found\", proc_res);\n+        fatal_ProcRes(\"multiple error patterns not found\".to_owned(), proc_res);\n     }\n }\n \n@@ -512,7 +514,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {\n-        fatal(~\"process did not return an error status\");\n+        fatal(\"process did not return an error status\".to_owned());\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n@@ -672,14 +674,14 @@ fn compile_test(config: &config, props: &TestProps,\n }\n \n fn jit_test(config: &config, props: &TestProps, testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, [~\"--jit\"])\n+    compile_test_(config, props, testfile, [\"--jit\".to_owned()])\n }\n \n fn compile_test_(config: &config, props: &TestProps,\n                  testfile: &Path, extra_args: &[~str]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(~\"-L\", aux_dir.as_str().unwrap().to_owned());\n+    let link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(extra_args),\n@@ -720,15 +722,15 @@ fn compose_and_run_compiler(\n \n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let extra_link_args = vec!(~\"-L\", aux_dir.as_str().unwrap().to_owned());\n+    let extra_link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n \n     for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = load_props(&abs_ab);\n         let crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n-            vec!(~\"--crate-type=dylib\")\n+            vec!(\"--crate-type=dylib\".to_owned())\n         };\n         let aux_args =\n             make_compile_args(config,\n@@ -794,16 +796,16 @@ fn make_compile_args(config: &config,\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut args = vec!(testfile.as_str().unwrap().to_owned(),\n-                     ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n-                     ~\"--target=\" + target);\n+                     \"-L\".to_owned(), config.build_base.as_str().unwrap().to_owned(),\n+                     \"--target=\".to_owned() + target);\n     args.push_all(extras.as_slice());\n     if !props.no_prefer_dynamic {\n-        args.push(~\"-C\");\n-        args.push(~\"prefer-dynamic\");\n+        args.push(\"-C\".to_owned());\n+        args.push(\"prefer-dynamic\".to_owned());\n     }\n     let path = match xform_file {\n-        ThisFile(path) => { args.push(~\"-o\"); path }\n-        ThisDirectory(path) => { args.push(~\"--out-dir\"); path }\n+        ThisFile(path) => { args.push(\"-o\".to_owned()); path }\n+        ThisDirectory(path) => { args.push(\"--out-dir\".to_owned()); path }\n     };\n     args.push(path.as_str().unwrap().to_owned());\n     if props.force_host {\n@@ -974,8 +976,8 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     // copy to target\n     let copy_result = procsrv::run(\"\", config.adb_path,\n-        [~\"push\", args.prog.clone(), config.adb_test_dir.clone()],\n-        vec!((~\"\",~\"\")), Some(~\"\"))\n+        [\"push\".to_owned(), args.prog.clone(), config.adb_test_dir.clone()],\n+        vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n@@ -989,7 +991,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     let mut runargs = Vec::new();\n \n     // run test via adb_run_wrapper\n-    runargs.push(~\"shell\");\n+    runargs.push(\"shell\".to_owned());\n     for (key, val) in env.move_iter() {\n         runargs.push(format!(\"{}={}\", key, val));\n     }\n@@ -1003,18 +1005,18 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     procsrv::run(\"\",\n                  config.adb_path,\n                  runargs.as_slice(),\n-                 vec!((~\"\",~\"\")), Some(~\"\"))\n+                 vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = Vec::new();\n-    runargs.push(~\"shell\");\n-    runargs.push(~\"cat\");\n+    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"cat\".to_owned());\n     runargs.push(format!(\"{}/{}.exitcode\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs.as_slice(), vec!((~\"\",~\"\")),\n-                     Some(~\"\"))\n+        procsrv::run(\"\", config.adb_path, runargs.as_slice(), vec!((\"\".to_owned(),\"\".to_owned())),\n+                     Some(\"\".to_owned()))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     let mut exitcode : int = 0;\n@@ -1028,28 +1030,28 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     // get stdout of result\n     runargs = Vec::new();\n-    runargs.push(~\"shell\");\n-    runargs.push(~\"cat\");\n+    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"cat\".to_owned());\n     runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      config.adb_path,\n                      runargs.as_slice(),\n-                     vec!((~\"\",~\"\")), Some(~\"\"))\n+                     vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = Vec::new();\n-    runargs.push(~\"shell\");\n-    runargs.push(~\"cat\");\n+    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"cat\".to_owned());\n     runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      config.adb_path,\n                      runargs.as_slice(),\n-                     vec!((~\"\",~\"\")), Some(~\"\"))\n+                     vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config, testfile, stdout_out, stderr_out);\n@@ -1070,8 +1072,8 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\", config.adb_path,\n-                [~\"push\", file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n-                vec!((~\"\",~\"\")), Some(~\"\"))\n+                [\"push\".to_owned(), file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n+                vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             if config.verbose {\n@@ -1102,8 +1104,9 @@ fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(~\"-L\", aux_dir.as_str().unwrap().to_owned());\n-    let llvm_args = vec!(~\"--emit=obj\", ~\"--crate-type=lib\", ~\"-C\", ~\"save-temps\");\n+    let link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+    let llvm_args = vec!(\"--emit=obj\".to_owned(), \"--crate-type=lib\".to_owned(),\n+                         \"-C\".to_owned(), \"save-temps\".to_owned());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(llvm_args.as_slice()),\n@@ -1119,9 +1122,9 @@ fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n-        args: vec!(~\"-c\",\n-                ~\"-emit-llvm\",\n-                ~\"-o\", bitcodefile.as_str().unwrap().to_owned(),\n+        args: vec!(\"-c\".to_owned(),\n+                \"-emit-llvm\".to_owned(),\n+                \"-o\".to_owned(), bitcodefile.as_str().unwrap().to_owned(),\n                 testcc.as_str().unwrap().to_owned() )\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n@@ -1172,42 +1175,42 @@ fn run_codegen_test(config: &config, props: &TestProps,\n                     testfile: &Path, mm: &mut MetricMap) {\n \n     if config.llvm_bin_path.is_none() {\n-        fatal(~\"missing --llvm-bin-path\");\n+        fatal(\"missing --llvm-bin-path\".to_owned());\n     }\n \n     if config.clang_path.is_none() {\n-        fatal(~\"missing --clang-path\");\n+        fatal(\"missing --clang-path\".to_owned());\n     }\n \n     let mut proc_res = compile_test_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"compilation failed!\", &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"extracting 'test' function failed\", &proc_res);\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_owned(), &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"disassembling extract failed\", &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_owned(), &proc_res);\n     }\n \n \n     let mut proc_res = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"compilation failed!\", &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"extracting 'test' function failed\", &proc_res);\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_owned(), &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(~\"disassembling extract failed\", &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_owned(), &proc_res);\n     }\n \n     let base = output_base_name(config, testfile);"}, {"sha": "e0afd57adf04bf91efab8a2b5fa869424f3c20e7", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -46,10 +46,10 @@ pub fn make_new_path(path: &str) -> ~str {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn lib_path_env_var() -> ~str { ~\"PATH\" }\n+pub fn lib_path_env_var() -> ~str { \"PATH\".to_owned() }\n \n #[cfg(target_os = \"win32\")]\n-pub fn path_div() -> ~str { ~\";\" }\n+pub fn path_div() -> ~str { \";\".to_owned() }\n \n pub fn logv(config: &config, s: ~str) {\n     debug!(\"{}\", s);"}, {"sha": "6cfe9918d85109c71b774e5c0ed35d328dcdff79", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -194,13 +194,13 @@ fn open(Door(name): Door<Closed>) -> Door<Open> {\n     Door::<Open>(name)\n }\n \n-let _ = close(Door::<Open>(~\"front\"));\n+let _ = close(Door::<Open>(\"front\".to_owned()));\n ~~~\n \n Attempting to close a closed door is prevented statically:\n \n ~~~ {.ignore}\n-let _ = close(Door::<Closed>(~\"front\")); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n+let _ = close(Door::<Closed>(\"front\".to_owned())); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n ~~~\n \n # FFI (Foreign Function Interface)"}, {"sha": "ed5384830d9d6f3ab73b60fed89679adde3f9f59", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -529,13 +529,13 @@ spawn(proc() {\n });\n \n from_child.send(22);\n-assert!(from_child.recv() == ~\"22\");\n+assert!(from_child.recv() == \"22\".to_owned());\n \n from_child.send(23);\n from_child.send(0);\n \n-assert!(from_child.recv() == ~\"23\");\n-assert!(from_child.recv() == ~\"0\");\n+assert!(from_child.recv() == \"23\".to_owned());\n+assert!(from_child.recv() == \"0\".to_owned());\n \n # }\n ~~~~"}, {"sha": "17941a152094fadf8165adb420c358a1eac5112c", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1241,8 +1241,8 @@ enum Animal {\n     Cat { name: ~str, weight: f64 }\n }\n \n-let mut a: Animal = Dog(~\"Cocoa\", 37.2);\n-a = Cat{ name: ~\"Spotty\", weight: 2.7 };\n+let mut a: Animal = Dog(\"Cocoa\".to_owned(), 37.2);\n+a = Cat{ name: \"Spotty\".to_owned(), weight: 2.7 };\n ~~~~\n \n In this example, `Cat` is a _struct-like enum variant_,\n@@ -3510,7 +3510,7 @@ allocated on the heap (unlike closures). An example of creating and calling a\n procedure:\n \n ```rust\n-let string = ~\"Hello\";\n+let string = \"Hello\".to_owned();\n \n // Creates a new procedure, passing it to the `spawn` function.\n spawn(proc() {"}, {"sha": "09574c803778e35f082c62e6e7b76e9c3bc67d58", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -2166,7 +2166,7 @@ impl Printable for ~str {\n }\n \n # 1.print();\n-# (~\"foo\").print();\n+# (\"foo\".to_owned()).print();\n ~~~~\n \n Methods defined in an impl for a trait may be called just like\n@@ -2216,7 +2216,7 @@ impl Printable for bool {}\n impl Printable for f32 {}\n \n # 1.print();\n-# (~\"foo\").print();\n+# (\"foo\".to_owned()).print();\n # true.print();\n # 3.14159.print();\n ~~~~"}, {"sha": "ec14820fc5db97dea7fb9442ac9edab02382d040", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -549,7 +549,7 @@ mod tests {\n         let arena = TypedArena::new();\n         for _ in range(0, 100000) {\n             arena.alloc(Noncopy {\n-                string: ~\"hello world\",\n+                string: \"hello world\".to_owned(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             });\n         }\n@@ -560,7 +560,7 @@ mod tests {\n         let arena = TypedArena::new();\n         b.iter(|| {\n             arena.alloc(Noncopy {\n-                string: ~\"hello world\",\n+                string: \"hello world\".to_owned(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })\n@@ -570,7 +570,7 @@ mod tests {\n     pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n             ~Noncopy {\n-                string: ~\"hello world\",\n+                string: \"hello world\".to_owned(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             }\n         })\n@@ -581,7 +581,7 @@ mod tests {\n         let arena = Arena::new();\n         b.iter(|| {\n             arena.alloc(|| Noncopy {\n-                string: ~\"hello world\",\n+                string: \"hello world\".to_owned(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })"}, {"sha": "6326f83b497808b2f50d910adc37fcf52b7b9516", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -955,10 +955,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n-        assert_eq!(zerolen.to_str(), ~\"\");\n+        assert_eq!(zerolen.to_str(), \"\".to_owned());\n \n         let eightbits = Bitv::new(8u, false);\n-        assert_eq!(eightbits.to_str(), ~\"00000000\");\n+        assert_eq!(eightbits.to_str(), \"00000000\".to_owned());\n     }\n \n     #[test]\n@@ -981,7 +981,7 @@ mod tests {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert_eq!(b.to_str(), ~\"10\");\n+        assert_eq!(b.to_str(), \"10\".to_owned());\n     }\n \n     #[test]\n@@ -1291,7 +1291,7 @@ mod tests {\n     #[test]\n     fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n-        let str = ~\"10110110\" + \"00000000\" + \"11111111\";\n+        let str = \"10110110\".to_owned() + \"00000000\" + \"11111111\";\n         assert_eq!(bitv.to_str(), str);\n     }\n \n@@ -1310,7 +1310,7 @@ mod tests {\n     #[test]\n     fn test_from_bools() {\n         assert!(from_bools([true, false, true, true]).to_str() ==\n-            ~\"1011\");\n+            \"1011\".to_owned());\n     }\n \n     #[test]"}, {"sha": "a258cf8b175ed77e215f2378953ac2d2def27a8e", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -776,81 +776,81 @@ mod test_btree {\n     //Tests the functionality of the insert methods (which are unfinished).\n     #[test]\n     fn insert_test_one() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n-        let is_insert = b.insert(2, ~\"xyz\");\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let is_insert = b.insert(2, \"xyz\".to_owned());\n         //println!(\"{}\", is_insert.clone().to_str());\n         assert!(is_insert.root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_two() {\n-        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n-        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n-        let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n+        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_owned());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3));\n         let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(4, ~\"ddd\").to_str());\n-        assert!(b.insert(4, ~\"ddd\").root.is_leaf());\n+        //println!(\"{}\", b.clone().insert(4, \"ddd\".to_owned()).to_str());\n+        assert!(b.insert(4, \"ddd\".to_owned()).root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n-        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n-        let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n-        let leaf_elt_4 = LeafElt::new(4, ~\"ddd\");\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n+        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_owned());\n+        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_owned());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n-        //println!(\"{}\", b.clone().insert(5, ~\"eee\").to_str());\n-        assert!(!b.insert(5, ~\"eee\").root.is_leaf());\n+        //println!(\"{}\", b.clone().insert(5, \"eee\".to_owned()).to_str());\n+        assert!(!b.insert(5, \"eee\".to_owned()).root.is_leaf());\n     }\n \n     #[test]\n     fn insert_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n-        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n-        let leaf_elt_3 = LeafElt::new(3, ~\"ccc\");\n-        let leaf_elt_4 = LeafElt::new(4, ~\"ddd\");\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n+        let leaf_elt_3 = LeafElt::new(3, \"ccc\".to_owned());\n+        let leaf_elt_4 = LeafElt::new(4, \"ddd\".to_owned());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let mut b = BTree::new_with_node_len(n, 3, 2);\n-        b = b.clone().insert(5, ~\"eee\");\n-        b = b.clone().insert(6, ~\"fff\");\n-        b = b.clone().insert(7, ~\"ggg\");\n-        b = b.clone().insert(8, ~\"hhh\");\n-        b = b.clone().insert(0, ~\"omg\");\n+        b = b.clone().insert(5, \"eee\".to_owned());\n+        b = b.clone().insert(6, \"fff\".to_owned());\n+        b = b.clone().insert(7, \"ggg\".to_owned());\n+        b = b.clone().insert(8, \"hhh\".to_owned());\n+        b = b.clone().insert(0, \"omg\".to_owned());\n         //println!(\"{}\", b.clone().to_str());\n         assert!(!b.root.is_leaf());\n     }\n \n     #[test]\n     fn bsearch_test_one() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n         assert_eq!(Some(1), b.root.bsearch_node(2));\n     }\n \n     #[test]\n     fn bsearch_test_two() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n         assert_eq!(Some(0), b.root.bsearch_node(0));\n     }\n \n     #[test]\n     fn bsearch_test_three() {\n-        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n-        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n-        let leaf_elt_3 = LeafElt::new(4, ~\"ccc\");\n-        let leaf_elt_4 = LeafElt::new(5, ~\"ddd\");\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n+        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_owned());\n+        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_owned());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(2), b.root.bsearch_node(3));\n     }\n \n     #[test]\n     fn bsearch_test_four() {\n-        let leaf_elt_1 = LeafElt::new(1, ~\"aaa\");\n-        let leaf_elt_2 = LeafElt::new(2, ~\"bbb\");\n-        let leaf_elt_3 = LeafElt::new(4, ~\"ccc\");\n-        let leaf_elt_4 = LeafElt::new(5, ~\"ddd\");\n+        let leaf_elt_1 = LeafElt::new(1, \"aaa\".to_owned());\n+        let leaf_elt_2 = LeafElt::new(2, \"bbb\".to_owned());\n+        let leaf_elt_3 = LeafElt::new(4, \"ccc\".to_owned());\n+        let leaf_elt_4 = LeafElt::new(5, \"ddd\".to_owned());\n         let n = Node::new_leaf(vec!(leaf_elt_1, leaf_elt_2, leaf_elt_3, leaf_elt_4));\n         let b = BTree::new_with_node_len(n, 3, 2);\n         assert_eq!(Some(4), b.root.bsearch_node(800));\n@@ -859,48 +859,48 @@ mod test_btree {\n     //Tests the functionality of the get method.\n     #[test]\n     fn get_test() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n         let val = b.get(1);\n-        assert_eq!(val, Some(~\"abc\"));\n+        assert_eq!(val, Some(\"abc\".to_owned()));\n     }\n \n     //Tests the BTree's clone() method.\n     #[test]\n     fn btree_clone_test() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n         let b2 = b.clone();\n         assert!(b.root == b2.root)\n     }\n \n     //Tests the BTree's cmp() method when one node is \"less than\" another.\n     #[test]\n     fn btree_cmp_test_less() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n-        let b2 = BTree::new(2, ~\"bcd\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b2 = BTree::new(2, \"bcd\".to_owned(), 2);\n         assert!(&b.cmp(&b2) == &Less)\n     }\n \n     //Tests the BTree's cmp() method when two nodes are equal.\n     #[test]\n     fn btree_cmp_test_eq() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n-        let b2 = BTree::new(1, ~\"bcd\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b2 = BTree::new(1, \"bcd\".to_owned(), 2);\n         assert!(&b.cmp(&b2) == &Equal)\n     }\n \n     //Tests the BTree's cmp() method when one node is \"greater than\" another.\n     #[test]\n     fn btree_cmp_test_greater() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n-        let b2 = BTree::new(2, ~\"bcd\", 2);\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        let b2 = BTree::new(2, \"bcd\".to_owned(), 2);\n         assert!(&b2.cmp(&b) == &Greater)\n     }\n \n     //Tests the BTree's to_str() method.\n     #[test]\n     fn btree_tostr_test() {\n-        let b = BTree::new(1, ~\"abc\", 2);\n-        assert_eq!(b.to_str(), ~\"Key: 1, value: abc;\")\n+        let b = BTree::new(1, \"abc\".to_owned(), 2);\n+        assert_eq!(b.to_str(), \"Key: 1, value: abc;\".to_owned())\n     }\n \n }"}, {"sha": "30875804823673fb544e4505667a458f8ab5c828", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1962,9 +1962,9 @@ mod test_map {\n         let mut m = HashMap::new();\n \n         let (foo, bar, baz) = (1,2,3);\n-        m.insert(~\"foo\", foo);\n-        m.insert(~\"bar\", bar);\n-        m.insert(~\"baz\", baz);\n+        m.insert(\"foo\".to_owned(), foo);\n+        m.insert(\"bar\".to_owned(), bar);\n+        m.insert(\"baz\".to_owned(), baz);\n \n \n         assert_eq!(m.find_equiv(&(\"foo\")), Some(&foo));\n@@ -2223,8 +2223,8 @@ mod test_set {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == ~\"{1, 2}\" || set_str == ~\"{2, 1}\");\n-        assert_eq!(format!(\"{}\", empty), ~\"{}\");\n+        assert!(set_str == \"{1, 2}\".to_owned() || set_str == \"{2, 1}\".to_owned());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_owned());\n     }\n }\n "}, {"sha": "fc95ba6d95a64ffe4ebbdefc48b152de6c0f0e94", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -295,22 +295,22 @@ mod tests {\n     #[test]\n     fn test_put_update() {\n         let mut cache: LruCache<~str, Vec<u8>> = LruCache::new(1);\n-        cache.put(~\"1\", vec![10, 10]);\n-        cache.put(~\"1\", vec![10, 19]);\n-        assert_opt_eq(cache.get(&~\"1\"), vec![10, 19]);\n+        cache.put(\"1\".to_owned(), vec![10, 10]);\n+        cache.put(\"1\".to_owned(), vec![10, 19]);\n+        assert_opt_eq(cache.get(&\"1\".to_owned()), vec![10, 19]);\n         assert_eq!(cache.len(), 1);\n     }\n \n     #[test]\n     fn test_expire_lru() {\n         let mut cache: LruCache<~str, ~str> = LruCache::new(2);\n-        cache.put(~\"foo1\", ~\"bar1\");\n-        cache.put(~\"foo2\", ~\"bar2\");\n-        cache.put(~\"foo3\", ~\"bar3\");\n-        assert!(cache.get(&~\"foo1\").is_none());\n-        cache.put(~\"foo2\", ~\"bar2update\");\n-        cache.put(~\"foo4\", ~\"bar4\");\n-        assert!(cache.get(&~\"foo3\").is_none());\n+        cache.put(\"foo1\".to_owned(), \"bar1\".to_owned());\n+        cache.put(\"foo2\".to_owned(), \"bar2\".to_owned());\n+        cache.put(\"foo3\".to_owned(), \"bar3\".to_owned());\n+        assert!(cache.get(&\"foo1\".to_owned()).is_none());\n+        cache.put(\"foo2\".to_owned(), \"bar2update\".to_owned());\n+        cache.put(\"foo4\".to_owned(), \"bar4\".to_owned());\n+        assert!(cache.get(&\"foo3\".to_owned()).is_none());\n     }\n \n     #[test]\n@@ -343,15 +343,15 @@ mod tests {\n         cache.put(1, 10);\n         cache.put(2, 20);\n         cache.put(3, 30);\n-        assert_eq!(cache.to_str(), ~\"{3: 30, 2: 20, 1: 10}\");\n+        assert_eq!(cache.to_str(), \"{3: 30, 2: 20, 1: 10}\".to_owned());\n         cache.put(2, 22);\n-        assert_eq!(cache.to_str(), ~\"{2: 22, 3: 30, 1: 10}\");\n+        assert_eq!(cache.to_str(), \"{2: 22, 3: 30, 1: 10}\".to_owned());\n         cache.put(6, 60);\n-        assert_eq!(cache.to_str(), ~\"{6: 60, 2: 22, 3: 30}\");\n+        assert_eq!(cache.to_str(), \"{6: 60, 2: 22, 3: 30}\".to_owned());\n         cache.get(&3);\n-        assert_eq!(cache.to_str(), ~\"{3: 30, 6: 60, 2: 22}\");\n+        assert_eq!(cache.to_str(), \"{3: 30, 6: 60, 2: 22}\".to_owned());\n         cache.change_capacity(2);\n-        assert_eq!(cache.to_str(), ~\"{3: 30, 6: 60}\");\n+        assert_eq!(cache.to_str(), \"{3: 30, 6: 60}\".to_owned());\n     }\n \n     #[test]\n@@ -362,6 +362,6 @@ mod tests {\n         cache.clear();\n         assert!(cache.get(&1).is_none());\n         assert!(cache.get(&2).is_none());\n-        assert_eq!(cache.to_str(), ~\"{}\");\n+        assert_eq!(cache.to_str(), \"{}\".to_owned());\n     }\n }"}, {"sha": "8887eb9e804a6ec5cad481d4338cbeabf0f691bb", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 102, "deletions": 95, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -419,7 +419,7 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     OptGroup {\n         short_name: short_name.to_owned(),\n         long_name: long_name.to_owned(),\n-        hint: ~\"\",\n+        hint: \"\".to_owned(),\n         desc: desc.to_owned(),\n         hasarg: No,\n         occur: Optional\n@@ -434,7 +434,7 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     OptGroup {\n         short_name: short_name.to_owned(),\n         long_name: long_name.to_owned(),\n-        hint: ~\"\",\n+        hint: \"\".to_owned(),\n         desc: desc.to_owned(),\n         hasarg: No,\n         occur: Multi\n@@ -532,7 +532,7 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n         let curlen = cur.len();\n         if !is_arg(cur) {\n             free.push(cur);\n-        } else if cur == ~\"--\" {\n+        } else if cur == \"--\".to_owned() {\n             let mut j = i + 1;\n             while j < l { free.push(args[j].clone()); j += 1; }\n             break;\n@@ -893,11 +893,11 @@ fn test_split_within() {\n     }\n     t(\"\", 0, []);\n     t(\"\", 15, []);\n-    t(\"hello\", 15, [~\"hello\"]);\n+    t(\"hello\", 15, [\"hello\".to_owned()]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n-        [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n+        [\"Mary had a\".to_owned(), \"little lamb\".to_owned(), \"Little lamb\".to_owned()]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n-        [~\"Mary had a little lamb\\nLittle lamb\"]);\n+        [\"Mary had a little lamb\\nLittle lamb\".to_owned()]);\n }\n \n #[cfg(test)]\n@@ -920,33 +920,33 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = vec!(~\"--test=20\");\n+        let long_args = vec!(\"--test=20\".to_owned());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n             assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n           }\n           _ => { fail!(\"test_reqopt failed (long arg)\"); }\n         }\n-        let short_args = vec!(~\"-t\", ~\"20\");\n+        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n           }\n           _ => { fail!(\"test_reqopt failed (short arg)\"); }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = vec!(~\"blah\");\n+        let args = vec!(\"blah\".to_owned());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -957,14 +957,14 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = vec!(~\"--test\");\n+        let long_args = vec!(\"--test\".to_owned());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-t\");\n+        let short_args = vec!(\"-t\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -973,7 +973,7 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = vec!(~\"--test=20\", ~\"-t\", ~\"30\");\n+        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -985,33 +985,33 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = vec!(~\"--test=20\");\n+        let long_args = vec!(\"--test=20\".to_owned());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-t\", ~\"20\");\n+        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = vec!(~\"blah\");\n+        let args = vec!(\"blah\".to_owned());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1025,14 +1025,14 @@ mod tests {\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = vec!(~\"--test\");\n+        let long_args = vec!(\"--test\".to_owned());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-t\");\n+        let short_args = vec!(\"-t\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1041,7 +1041,7 @@ mod tests {\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = vec!(~\"--test=20\", ~\"-t\", ~\"30\");\n+        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1053,7 +1053,7 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = vec!(~\"--test\");\n+        let long_args = vec!(\"--test\".to_owned());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1063,7 +1063,7 @@ mod tests {\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-t\");\n+        let short_args = vec!(\"-t\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -1075,7 +1075,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = vec!(~\"blah\");\n+        let args = vec!(\"blah\".to_owned());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1089,7 +1089,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = vec!(~\"--test=20\");\n+        let args = vec!(\"--test=20\".to_owned());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1103,7 +1103,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = vec!(~\"--test\", ~\"-t\");\n+        let args = vec!(\"--test\".to_owned(), \"-t\".to_owned());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1114,14 +1114,14 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = vec!(~\"-t\", ~\"20\");\n+        let args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(*m.free.get(0) == ~\"20\");\n+            assert!(*m.free.get(0) == \"20\".to_owned());\n           }\n           _ => fail!()\n         }\n@@ -1130,7 +1130,7 @@ mod tests {\n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = vec!(~\"-v\");\n+        let args = vec!(\"-v\".to_owned());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1143,7 +1143,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = vec!(~\"-v\", ~\"-v\");\n+        let args = vec!(\"-v\".to_owned(), \"-v\".to_owned());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1156,7 +1156,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = vec!(~\"-vv\");\n+        let args = vec!(\"-vv\".to_owned());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1169,7 +1169,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = vec!(~\"--verbose\");\n+        let args = vec!(\"--verbose\".to_owned());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1182,7 +1182,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = vec!(~\"--verbose\", ~\"--verbose\");\n+        let args = vec!(\"--verbose\".to_owned(), \"--verbose\".to_owned());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1195,7 +1195,8 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = vec!(~\"--verbose\", ~\"-v\", ~\"-vv\", ~\"verbose\");\n+        let args = vec!(\"--verbose\".to_owned(), \"-v\".to_owned(),\n+                        \"-vv\".to_owned(), \"verbose\".to_owned());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1210,33 +1211,33 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = vec!(~\"--test=20\");\n+        let long_args = vec!(\"--test=20\".to_owned());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-t\", ~\"20\");\n+        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = vec!(~\"blah\");\n+        let args = vec!(\"blah\".to_owned());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1250,14 +1251,14 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = vec!(~\"--test\");\n+        let long_args = vec!(\"--test\".to_owned());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-t\");\n+        let short_args = vec!(\"-t\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1266,33 +1267,33 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = vec!(~\"--test=20\", ~\"-t\", ~\"30\");\n+        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n+              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n               assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n+              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n               let pair = m.opt_strs(\"test\");\n-              assert!(*pair.get(0) == ~\"20\");\n-              assert!(*pair.get(1) == ~\"30\");\n+              assert!(*pair.get(0) == \"20\".to_owned());\n+              assert!(*pair.get(1) == \"30\".to_owned());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = vec!(~\"--untest\");\n+        let long_args = vec!(\"--untest\".to_owned());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n-        let short_args = vec!(~\"-u\");\n+        let short_args = vec!(\"-u\".to_owned());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n@@ -1302,9 +1303,10 @@ mod tests {\n     #[test]\n     fn test_combined() {\n         let args =\n-            vec!(~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n-              ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n-              ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\");\n+            vec!(\"prog\".to_owned(), \"free1\".to_owned(), \"-s\".to_owned(), \"20\".to_owned(),\n+            \"free2\".to_owned(), \"--flag\".to_owned(), \"--long=30\".to_owned(), \"-f\".to_owned(),\n+            \"-m\".to_owned(), \"40\".to_owned(), \"-m\".to_owned(), \"50\".to_owned(), \"-n\".to_owned(),\n+            \"-A B\".to_owned(), \"-n\".to_owned(), \"-60 70\".to_owned());\n         let opts =\n             vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n               optflag(\"\", \"flag\", \"a flag\"),\n@@ -1316,19 +1318,19 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(*m.free.get(0) == ~\"prog\");\n-            assert!(*m.free.get(1) == ~\"free1\");\n-            assert_eq!(m.opt_str(\"s\").unwrap(), ~\"20\");\n-            assert!(*m.free.get(2) == ~\"free2\");\n+            assert!(*m.free.get(0) == \"prog\".to_owned());\n+            assert!(*m.free.get(1) == \"free1\".to_owned());\n+            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_owned());\n+            assert!(*m.free.get(2) == \"free2\".to_owned());\n             assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), ~\"30\");\n+            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_owned());\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(*pair.get(0) == ~\"40\");\n-            assert!(*pair.get(1) == ~\"50\");\n+            assert!(*pair.get(0) == \"40\".to_owned());\n+            assert!(*pair.get(1) == \"50\".to_owned());\n             let pair = m.opt_strs(\"n\");\n-            assert!(*pair.get(0) == ~\"-A B\");\n-            assert!(*pair.get(1) == ~\"-60 70\");\n+            assert!(*pair.get(0) == \"-A B\".to_owned());\n+            assert!(*pair.get(1) == \"-60 70\".to_owned());\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()\n@@ -1341,63 +1343,68 @@ mod tests {\n                      optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n                      optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n \n-        let args_single = vec!(~\"-e\", ~\"foo\");\n+        let args_single = vec!(\"-e\".to_owned(), \"foo\".to_owned());\n         let matches_single = &match getopts(args_single.as_slice(),\n                                             opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_single.opts_present([~\"e\"]));\n-        assert!(matches_single.opts_present([~\"encrypt\", ~\"e\"]));\n-        assert!(matches_single.opts_present([~\"e\", ~\"encrypt\"]));\n-        assert!(!matches_single.opts_present([~\"encrypt\"]));\n-        assert!(!matches_single.opts_present([~\"thing\"]));\n+        assert!(matches_single.opts_present([\"e\".to_owned()]));\n+        assert!(matches_single.opts_present([\"encrypt\".to_owned(), \"e\".to_owned()]));\n+        assert!(matches_single.opts_present([\"e\".to_owned(), \"encrypt\".to_owned()]));\n+        assert!(!matches_single.opts_present([\"encrypt\".to_owned()]));\n+        assert!(!matches_single.opts_present([\"thing\".to_owned()]));\n         assert!(!matches_single.opts_present([]));\n \n-        assert_eq!(matches_single.opts_str([~\"e\"]).unwrap(), ~\"foo\");\n-        assert_eq!(matches_single.opts_str([~\"e\", ~\"encrypt\"]).unwrap(), ~\"foo\");\n-        assert_eq!(matches_single.opts_str([~\"encrypt\", ~\"e\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_single.opts_str([\"e\".to_owned()]).unwrap(), \"foo\".to_owned());\n+        assert_eq!(matches_single.opts_str([\"e\".to_owned(), \"encrypt\".to_owned()]).unwrap(),\n+                   \"foo\".to_owned());\n+        assert_eq!(matches_single.opts_str([\"encrypt\".to_owned(), \"e\".to_owned()]).unwrap(),\n+                   \"foo\".to_owned());\n \n-        let args_both = vec!(~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\");\n+        let args_both = vec!(\"-e\".to_owned(), \"foo\".to_owned(), \"--encrypt\".to_owned(),\n+                             \"foo\".to_owned());\n         let matches_both = &match getopts(args_both.as_slice(),\n                                           opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_both.opts_present([~\"e\"]));\n-        assert!(matches_both.opts_present([~\"encrypt\"]));\n-        assert!(matches_both.opts_present([~\"encrypt\", ~\"e\"]));\n-        assert!(matches_both.opts_present([~\"e\", ~\"encrypt\"]));\n-        assert!(!matches_both.opts_present([~\"f\"]));\n-        assert!(!matches_both.opts_present([~\"thing\"]));\n+        assert!(matches_both.opts_present([\"e\".to_owned()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_owned()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_owned(), \"e\".to_owned()]));\n+        assert!(matches_both.opts_present([\"e\".to_owned(), \"encrypt\".to_owned()]));\n+        assert!(!matches_both.opts_present([\"f\".to_owned()]));\n+        assert!(!matches_both.opts_present([\"thing\".to_owned()]));\n         assert!(!matches_both.opts_present([]));\n \n-        assert_eq!(matches_both.opts_str([~\"e\"]).unwrap(), ~\"foo\");\n-        assert_eq!(matches_both.opts_str([~\"encrypt\"]).unwrap(), ~\"foo\");\n-        assert_eq!(matches_both.opts_str([~\"e\", ~\"encrypt\"]).unwrap(), ~\"foo\");\n-        assert_eq!(matches_both.opts_str([~\"encrypt\", ~\"e\"]).unwrap(), ~\"foo\");\n+        assert_eq!(matches_both.opts_str([\"e\".to_owned()]).unwrap(), \"foo\".to_owned());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_owned()]).unwrap(), \"foo\".to_owned());\n+        assert_eq!(matches_both.opts_str([\"e\".to_owned(), \"encrypt\".to_owned()]).unwrap(),\n+                   \"foo\".to_owned());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_owned(), \"e\".to_owned()]).unwrap(),\n+                   \"foo\".to_owned());\n     }\n \n     #[test]\n     fn test_nospace() {\n-        let args = vec!(~\"-Lfoo\", ~\"-M.\");\n+        let args = vec!(\"-Lfoo\".to_owned(), \"-M.\".to_owned());\n         let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n                      optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n         let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches.opts_present([~\"L\"]));\n-        assert_eq!(matches.opts_str([~\"L\"]).unwrap(), ~\"foo\");\n-        assert!(matches.opts_present([~\"M\"]));\n-        assert_eq!(matches.opts_str([~\"M\"]).unwrap(), ~\".\");\n+        assert!(matches.opts_present([\"L\".to_owned()]));\n+        assert_eq!(matches.opts_str([\"L\".to_owned()]).unwrap(), \"foo\".to_owned());\n+        assert!(matches.opts_present([\"M\".to_owned()]));\n+        assert_eq!(matches.opts_str([\"M\".to_owned()]).unwrap(), \".\".to_owned());\n \n     }\n \n     #[test]\n     fn test_long_to_short() {\n         let mut short = Opt {\n-            name: Long(~\"banana\"),\n+            name: Long(\"banana\".to_owned()),\n             hasarg: Yes,\n             occur: Req,\n             aliases: Vec::new(),\n@@ -1416,7 +1423,7 @@ mod tests {\n         let opts = vec!(\n             optflagmulti(\"a\", \"apple\", \"Desc\"));\n \n-        let args = vec!(~\"-a\", ~\"--apple\", ~\"-a\");\n+        let args = vec!(\"-a\".to_owned(), \"--apple\".to_owned(), \"-a\".to_owned());\n \n         let matches = getopts(args.as_slice(), opts.as_slice()).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n@@ -1515,7 +1522,7 @@ Options:\n             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n             optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n-        let expected = ~\"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\";\n+        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_owned();\n         let generated_usage = short_usage(\"fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);"}, {"sha": "05dd1bad569f566257539c11f5fb7ae9e9a27318", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -767,7 +767,7 @@ mod test {\n     #[test]\n     fn test_pattern_escape() {\n         let s = \"_[_]_?_*_!_\";\n-        assert_eq!(Pattern::escape(s), ~\"_[[]_[]]_[?]_[*]_!_\");\n+        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_owned());\n         assert!(Pattern::new(Pattern::escape(s)).matches(s));\n     }\n "}, {"sha": "4897924c55b175f991d609670d9db4e6fb8d85c6", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -74,26 +74,26 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, ~str)> {\n     let mut chars = s.chars().peekable();\n     let mut i = 0;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    if chars.next() != Some('0') { return Some((i, ~\"Expected '0'\")); } i+=1;\n-    if chars.next() != Some('x') { return Some((i, ~\"Expected 'x'\")); } i+=1;\n+    if chars.next() != Some('0') { return Some((i, \"Expected '0'\".to_owned())); } i+=1;\n+    if chars.next() != Some('x') { return Some((i, \"Expected 'x'\".to_owned())); } i+=1;\n     let mut d_len = 0;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n-    if chars.next() != Some('.') { return Some((i, ~\"Expected '.'\")); } i+=1;\n+    if chars.next() != Some('.') { return Some((i, \"Expected '.'\".to_owned())); } i+=1;\n     let mut f_len = 0;\n     for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n     if d_len == 0 && f_len == 0 {\n-        return Some((i, ~\"Expected digits before or after decimal point\"));\n+        return Some((i, \"Expected digits before or after decimal point\".to_owned()));\n     }\n-    if chars.next() != Some('p') { return Some((i, ~\"Expected 'p'\")); } i+=1;\n+    if chars.next() != Some('p') { return Some((i, \"Expected 'p'\".to_owned())); } i+=1;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n     let mut e_len = 0;\n     for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n     if e_len == 0 {\n-        return Some((i, ~\"Expected exponent digits\"));\n+        return Some((i, \"Expected exponent digits\".to_owned()));\n     }\n     match chars.next() {\n         None => None,\n-        Some(_) => Some((i, ~\"Expected end of string\"))\n+        Some(_) => Some((i, \"Expected end of string\".to_owned()))\n     }\n }\n "}, {"sha": "4329f68b9aaeede834e4ae3b61ddd9e52d7542a3", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -79,13 +79,13 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 3);\n-        assert_eq!(dirs[0].name, Some(~\"crate1::mod1\"));\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_owned()));\n         assert_eq!(dirs[0].level, 1);\n \n-        assert_eq!(dirs[1].name, Some(~\"crate1::mod2\"));\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_owned()));\n         assert_eq!(dirs[1].level, ::MAX_LOG_LEVEL);\n \n-        assert_eq!(dirs[2].name, Some(~\"crate2\"));\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[2].level, 4);\n     }\n \n@@ -95,7 +95,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(~\"crate2\"));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, 4);\n     }\n \n@@ -105,7 +105,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(~\"crate2\"));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, 4);\n     }\n \n@@ -115,7 +115,7 @@ mod tests {\n         let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(~\"crate2\"));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, ::WARN);\n     }\n \n@@ -127,7 +127,7 @@ mod tests {\n         assert_eq!(dirs.len(), 2);\n         assert_eq!(dirs[0].name, None);\n         assert_eq!(dirs[0].level, 2);\n-        assert_eq!(dirs[1].name, Some(~\"crate2\"));\n+        assert_eq!(dirs[1].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[1].level, 4);\n     }\n }"}, {"sha": "87c82e1dd7d424d829ac77e6fae6ef2b2625235a", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -305,8 +305,8 @@ mod tests {\n \n     #[test]\n     fn match_full_path() {\n-        let dirs = [LogDirective { name: Some(~\"crate2\"), level: 3 },\n-                    LogDirective { name: Some(~\"crate1::mod1\"), level: 2 }];\n+        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n+                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(!enabled(3, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2\", dirs.iter()));\n@@ -315,39 +315,39 @@ mod tests {\n \n     #[test]\n     fn no_match() {\n-        let dirs = [LogDirective { name: Some(~\"crate2\"), level: 3 },\n-                    LogDirective { name: Some(~\"crate1::mod1\"), level: 2 }];\n+        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n+                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n         assert!(!enabled(2, \"crate3\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning() {\n-        let dirs = [LogDirective { name: Some(~\"crate2\"), level: 3 },\n-                    LogDirective { name: Some(~\"crate1::mod1\"), level: 2 }];\n+        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n+                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n         assert!(enabled(3, \"crate2::mod1\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning_longest_match() {\n-        let dirs = [LogDirective { name: Some(~\"crate2\"), level: 3 },\n-                    LogDirective { name: Some(~\"crate2::mod\"), level: 4 },\n-                    LogDirective { name: Some(~\"crate1::mod1\"), level: 2 }];\n+        let dirs = [LogDirective { name: Some(\"crate2\".to_owned()), level: 3 },\n+                    LogDirective { name: Some(\"crate2::mod\".to_owned()), level: 4 },\n+                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n         assert!(enabled(4, \"crate2::mod1\", dirs.iter()));\n         assert!(!enabled(4, \"crate2\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_default() {\n         let dirs = [LogDirective { name: None, level: 3 },\n-                    LogDirective { name: Some(~\"crate1::mod1\"), level: 2 }];\n+                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 2 }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }\n \n     #[test]\n     fn zero_level() {\n         let dirs = [LogDirective { name: None, level: 3 },\n-                    LogDirective { name: Some(~\"crate1::mod1\"), level: 0 }];\n+                    LogDirective { name: Some(\"crate1::mod1\".to_owned()), level: 0 }];\n         assert!(!enabled(1, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }"}, {"sha": "a29a5b631c660f5e1ad9a8d093ff86f3a51a8b21", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -854,20 +854,20 @@ mod tests {\n     fn test_make_command_line() {\n         use super::make_command_line;\n         assert_eq!(\n-            make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n-            ~\"prog aaa bbb ccc\"\n+            make_command_line(\"prog\", [\"aaa\".to_owned(), \"bbb\".to_owned(), \"ccc\".to_owned()]),\n+            \"prog aaa bbb ccc\".to_owned()\n         );\n         assert_eq!(\n-            make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+            make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\".to_owned()]),\n+            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_owned()\n         );\n         assert_eq!(\n-            make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+            make_command_line(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\".to_owned()]),\n+            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_owned()\n         );\n         assert_eq!(\n-            make_command_line(\"echo\", [~\"a b c\"]),\n-            ~\"echo \\\"a b c\\\"\"\n+            make_command_line(\"echo\", [\"a b c\".to_owned()]),\n+            \"echo \\\"a b c\\\"\".to_owned()\n         );\n     }\n }"}, {"sha": "46ee996608e4894741e843a03a8b25a0c4d92688", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -665,7 +665,7 @@ impl ToStrRadix for BigUint {\n         }\n \n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n-            if v.is_empty() { return ~\"0\" }\n+            if v.is_empty() { return \"0\".to_owned() }\n             let mut s = StrBuf::with_capacity(v.len() * l);\n             for n in v.rev_iter() {\n                 let ss = (*n as uint).to_str_radix(radix);\n@@ -1268,8 +1268,8 @@ impl ToStrRadix for BigInt {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n-            Zero  => ~\"0\",\n-            Minus => ~\"-\" + self.data.to_str_radix(radix)\n+            Zero  => \"0\".to_owned(),\n+            Minus => \"-\".to_owned() + self.data.to_str_radix(radix)\n         }\n     }\n }\n@@ -1974,55 +1974,55 @@ mod biguint_tests {\n     fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, ~str)>)> {\n         let bits = BigDigit::bits;\n         vec!(( Zero::zero(), vec!(\n-            (2, ~\"0\"), (3, ~\"0\")\n+            (2, \"0\".to_owned()), (3, \"0\".to_owned())\n         )), ( BigUint::from_slice([ 0xff ]), vec!(\n-            (2,  ~\"11111111\"),\n-            (3,  ~\"100110\"),\n-            (4,  ~\"3333\"),\n-            (5,  ~\"2010\"),\n-            (6,  ~\"1103\"),\n-            (7,  ~\"513\"),\n-            (8,  ~\"377\"),\n-            (9,  ~\"313\"),\n-            (10, ~\"255\"),\n-            (11, ~\"212\"),\n-            (12, ~\"193\"),\n-            (13, ~\"168\"),\n-            (14, ~\"143\"),\n-            (15, ~\"120\"),\n-            (16, ~\"ff\")\n+            (2,  \"11111111\".to_owned()),\n+            (3,  \"100110\".to_owned()),\n+            (4,  \"3333\".to_owned()),\n+            (5,  \"2010\".to_owned()),\n+            (6,  \"1103\".to_owned()),\n+            (7,  \"513\".to_owned()),\n+            (8,  \"377\".to_owned()),\n+            (9,  \"313\".to_owned()),\n+            (10, \"255\".to_owned()),\n+            (11, \"212\".to_owned()),\n+            (12, \"193\".to_owned()),\n+            (13, \"168\".to_owned()),\n+            (14, \"143\".to_owned()),\n+            (15, \"120\".to_owned()),\n+            (16, \"ff\".to_owned())\n         )), ( BigUint::from_slice([ 0xfff ]), vec!(\n-            (2,  ~\"111111111111\"),\n-            (4,  ~\"333333\"),\n-            (16, ~\"fff\")\n+            (2,  \"111111111111\".to_owned()),\n+            (4,  \"333333\".to_owned()),\n+            (16, \"fff\".to_owned())\n         )), ( BigUint::from_slice([ 1, 2 ]), vec!(\n             (2,\n-             ~\"10\" +\n+             \"10\".to_owned() +\n              \"0\".repeat(bits - 1) + \"1\"),\n             (4,\n-             ~\"2\" +\n+             \"2\".to_owned() +\n              \"0\".repeat(bits / 2 - 1) + \"1\"),\n             (10, match bits {\n-                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail!()\n+                32 => \"8589934593\".to_owned(), 16 => \"131073\".to_owned(), _ => fail!()\n             }),\n             (16,\n-             ~\"2\" +\n+             \"2\".to_owned() +\n              \"0\".repeat(bits / 4 - 1) + \"1\")\n         )), ( BigUint::from_slice([ 1, 2, 3 ]), vec!(\n             (2,\n-             ~\"11\" +\n+             \"11\".to_owned() +\n              \"0\".repeat(bits - 2) + \"10\" +\n              \"0\".repeat(bits - 1) + \"1\"),\n             (4,\n-             ~\"3\" +\n+             \"3\".to_owned() +\n              \"0\".repeat(bits / 2 - 1) + \"2\" +\n              \"0\".repeat(bits / 2 - 1) + \"1\"),\n             (10, match bits {\n-                32 => ~\"55340232229718589441\",\n-                16 => ~\"12885032961\",\n+                32 => \"55340232229718589441\".to_owned(),\n+                16 => \"12885032961\".to_owned(),\n                 _ => fail!()\n             }),\n-            (16, ~\"3\" +\n+            (16, \"3\".to_owned() +\n              \"0\".repeat(bits / 4 - 1) + \"2\" +\n              \"0\".repeat(bits / 4 - 1) + \"1\")\n         )) )"}, {"sha": "e1e0102bbdc239fbf8a5f703496765197cdc60f2", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -351,12 +351,12 @@ mod test {\n         fn test(c : Complex64, s: ~str) {\n             assert_eq!(c.to_str(), s);\n         }\n-        test(_0_0i, ~\"0+0i\");\n-        test(_1_0i, ~\"1+0i\");\n-        test(_0_1i, ~\"0+1i\");\n-        test(_1_1i, ~\"1+1i\");\n-        test(_neg1_1i, ~\"-1+1i\");\n-        test(-_neg1_1i, ~\"1-1i\");\n-        test(_05_05i, ~\"0.5+0.5i\");\n+        test(_0_0i, \"0+0i\".to_owned());\n+        test(_1_0i, \"1+0i\".to_owned());\n+        test(_0_1i, \"0+1i\".to_owned());\n+        test(_1_1i, \"1+1i\".to_owned());\n+        test(_neg1_1i, \"-1+1i\".to_owned());\n+        test(-_neg1_1i, \"1-1i\".to_owned());\n+        test(_05_05i, \"0.5+0.5i\".to_owned());\n     }\n }"}, {"sha": "edaeffccc9e6ef6b4f41a801ef9ec53fc5e23781", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -564,12 +564,12 @@ mod test {\n             assert_eq!(FromStr::from_str(s), Some(r));\n             assert_eq!(r.to_str(), s);\n         }\n-        test(_1, ~\"1/1\");\n-        test(_0, ~\"0/1\");\n-        test(_1_2, ~\"1/2\");\n-        test(_3_2, ~\"3/2\");\n-        test(_2, ~\"2/1\");\n-        test(_neg1_2, ~\"-1/2\");\n+        test(_1, \"1/1\".to_owned());\n+        test(_0, \"0/1\".to_owned());\n+        test(_1_2, \"1/2\".to_owned());\n+        test(_3_2, \"3/2\".to_owned());\n+        test(_2, \"2/1\".to_owned());\n+        test(_neg1_2, \"-1/2\".to_owned());\n     }\n     #[test]\n     fn test_from_str_fail() {\n@@ -593,23 +593,23 @@ mod test {\n         fn test3(r: Rational, s: ~str) { test(r, s, 3) }\n         fn test16(r: Rational, s: ~str) { test(r, s, 16) }\n \n-        test3(_1, ~\"1/1\");\n-        test3(_0, ~\"0/1\");\n-        test3(_1_2, ~\"1/2\");\n-        test3(_3_2, ~\"10/2\");\n-        test3(_2, ~\"2/1\");\n-        test3(_neg1_2, ~\"-1/2\");\n-        test3(_neg1_2 / _2, ~\"-1/11\");\n-\n-        test16(_1, ~\"1/1\");\n-        test16(_0, ~\"0/1\");\n-        test16(_1_2, ~\"1/2\");\n-        test16(_3_2, ~\"3/2\");\n-        test16(_2, ~\"2/1\");\n-        test16(_neg1_2, ~\"-1/2\");\n-        test16(_neg1_2 / _2, ~\"-1/4\");\n-        test16(Ratio::new(13,15), ~\"d/f\");\n-        test16(_1_2*_1_2*_1_2*_1_2, ~\"1/10\");\n+        test3(_1, \"1/1\".to_owned());\n+        test3(_0, \"0/1\".to_owned());\n+        test3(_1_2, \"1/2\".to_owned());\n+        test3(_3_2, \"10/2\".to_owned());\n+        test3(_2, \"2/1\".to_owned());\n+        test3(_neg1_2, \"-1/2\".to_owned());\n+        test3(_neg1_2 / _2, \"-1/11\".to_owned());\n+\n+        test16(_1, \"1/1\".to_owned());\n+        test16(_0, \"0/1\".to_owned());\n+        test16(_1_2, \"1/2\".to_owned());\n+        test16(_3_2, \"3/2\".to_owned());\n+        test16(_2, \"2/1\".to_owned());\n+        test16(_neg1_2, \"-1/2\".to_owned());\n+        test16(_neg1_2 / _2, \"-1/4\".to_owned());\n+        test16(Ratio::new(13,15), \"d/f\".to_owned());\n+        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_owned());\n     }\n \n     #[test]"}, {"sha": "798b5eadef4b79e1c3810776a21ef5ec50681c8e", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,50 +15,50 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     let cc_args = if target_triple.contains(\"thumb\") {\n-        vec!(~\"-mthumb\")\n+        vec!(\"-mthumb\".to_owned())\n     } else {\n-        vec!(~\"-marm\")\n+        vec!(\"-marm\".to_owned())\n     };\n     return target_strs::t {\n-        module_asm: ~\"\",\n+        module_asm: \"\".to_owned(),\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            ~\"e-p:32:32:32\" +\n+            \"e-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsWin32 => {\n-            ~\"e-p:32:32:32\" +\n+            \"e-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsLinux => {\n-            ~\"e-p:32:32:32\" +\n+            \"e-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsAndroid => {\n-            ~\"e-p:32:32:32\" +\n+            \"e-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsFreebsd => {\n-            ~\"e-p:32:32:32\" +\n+            \"e-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +"}, {"sha": "9211827e6a691ae0f5b46b9a0425bbf304d6ab46", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -79,7 +79,7 @@ pub fn WriteOutputFile(\n             let result = llvm::LLVMRustWriteOutputFile(\n                     target, pm, m, output, file_type);\n             if !result {\n-                llvm_err(sess, ~\"could not write output\");\n+                llvm_err(sess, \"could not write output\".to_owned());\n             }\n         })\n     }\n@@ -341,8 +341,8 @@ pub mod write {\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let args = [\n-            ~\"-c\",\n-            ~\"-o\", object.as_str().unwrap().to_owned(),\n+            \"-c\".to_owned(),\n+            \"-o\".to_owned(), object.as_str().unwrap().to_owned(),\n             assembly.as_str().unwrap().to_owned()];\n \n         debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n@@ -622,7 +622,7 @@ pub fn sanitize(s: &str) -> ~str {\n     if result.len() > 0u &&\n         result[0] != '_' as u8 &&\n         ! char::is_XID_start(result[0] as char) {\n-        return ~\"_\" + result;\n+        return \"_\".to_owned() + result;\n     }\n \n     return result;\n@@ -738,7 +738,7 @@ pub fn get_cc_prog(sess: &Session) -> ~str {\n     // instead of hard-coded gcc.\n     // For win32, there is no cc command, so we add a condition to make it use gcc.\n     match sess.targ_cfg.os {\n-        abi::OsWin32 => return ~\"gcc\",\n+        abi::OsWin32 => return \"gcc\".to_owned(),\n         _ => {},\n     }\n \n@@ -1089,13 +1089,13 @@ fn link_args(sess: &Session,\n     // The location of crates will be determined as needed.\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let lib_path = sess.filesearch().get_target_lib_path();\n-    let stage: ~str = ~\"-L\" + lib_path.as_str().unwrap();\n+    let stage: ~str = \"-L\".to_owned() + lib_path.as_str().unwrap();\n \n     let mut args = vec!(stage);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push_all([\n-        ~\"-o\", out_filename.as_str().unwrap().to_owned(),\n+        \"-o\".to_owned(), out_filename.as_str().unwrap().to_owned(),\n         obj_filename.as_str().unwrap().to_owned()]);\n \n     // Stack growth requires statically linking a __morestack function. Note\n@@ -1113,7 +1113,7 @@ fn link_args(sess: &Session,\n     // line, but inserting this farther to the left makes the\n     // \"rust_stack_exhausted\" symbol an outstanding undefined symbol, which\n     // flags libstd as a required library (or whatever provides the symbol).\n-    args.push(~\"-lmorestack\");\n+    args.push(\"-lmorestack\".to_owned());\n \n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n@@ -1131,30 +1131,30 @@ fn link_args(sess: &Session,\n     //\n     // FIXME(#11937) we should invoke the system linker directly\n     if sess.targ_cfg.os != abi::OsWin32 {\n-        args.push(~\"-nodefaultlibs\");\n+        args.push(\"-nodefaultlibs\".to_owned());\n     }\n \n     if sess.targ_cfg.os == abi::OsLinux {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n         // follow this flag. Thus, use it before specifying libraries to link to.\n-        args.push(~\"-Wl,--as-needed\");\n+        args.push(\"-Wl,--as-needed\".to_owned());\n \n         // GNU-style linkers support optimization with -O. --gc-sections\n         // removes metadata and potentially other useful things, so don't\n         // include it. GNU ld doesn't need a numeric argument, but other linkers\n         // do.\n         if sess.opts.optimize == session::Default ||\n            sess.opts.optimize == session::Aggressive {\n-            args.push(~\"-Wl,-O1\");\n+            args.push(\"-Wl,-O1\".to_owned());\n         }\n     }\n \n     if sess.targ_cfg.os == abi::OsWin32 {\n         // Make sure that we link to the dynamic libgcc, otherwise cross-module\n         // DWARF stack unwinding will not work.\n         // This behavior may be overridden by --link-args \"-static-libgcc\"\n-        args.push(~\"-shared-libgcc\");\n+        args.push(\"-shared-libgcc\".to_owned());\n \n         // And here, we see obscure linker flags #45. On windows, it has been\n         // found to be necessary to have this flag to compile liblibc.\n@@ -1181,13 +1181,13 @@ fn link_args(sess: &Session,\n         //\n         // [1] - https://sourceware.org/bugzilla/show_bug.cgi?id=13130\n         // [2] - https://code.google.com/p/go/issues/detail?id=2139\n-        args.push(~\"-Wl,--enable-long-section-names\");\n+        args.push(\"-Wl,--enable-long-section-names\".to_owned());\n     }\n \n     if sess.targ_cfg.os == abi::OsAndroid {\n         // Many of the symbols defined in compiler-rt are also defined in libgcc.\n         // Android linker doesn't like that by default.\n-        args.push(~\"-Wl,--allow-multiple-definition\");\n+        args.push(\"-Wl,--allow-multiple-definition\".to_owned());\n     }\n \n     // Take careful note of the ordering of the arguments we pass to the linker\n@@ -1232,22 +1232,22 @@ fn link_args(sess: &Session,\n     if dylib {\n         // On mac we need to tell the linker to let this library be rpathed\n         if sess.targ_cfg.os == abi::OsMacos {\n-            args.push(~\"-dynamiclib\");\n-            args.push(~\"-Wl,-dylib\");\n+            args.push(\"-dynamiclib\".to_owned());\n+            args.push(\"-Wl,-dylib\".to_owned());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             if !sess.opts.cg.no_rpath {\n-                args.push(~\"-Wl,-install_name,@rpath/\" +\n+                args.push(\"-Wl,-install_name,@rpath/\".to_owned() +\n                           out_filename.filename_str().unwrap());\n             }\n         } else {\n-            args.push(~\"-shared\")\n+            args.push(\"-shared\".to_owned())\n         }\n     }\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n-        args.push_all([~\"-L/usr/local/lib\",\n-                       ~\"-L/usr/local/lib/gcc46\",\n-                       ~\"-L/usr/local/lib/gcc44\"]);\n+        args.push_all([\"-L/usr/local/lib\".to_owned(),\n+                       \"-L/usr/local/lib/gcc46\".to_owned(),\n+                       \"-L/usr/local/lib/gcc44\".to_owned()]);\n     }\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to\n@@ -1264,7 +1264,7 @@ fn link_args(sess: &Session,\n     //\n     // This is the end of the command line, so this library is used to resolve\n     // *all* undefined symbols in all other libraries, and this is intentional.\n-    args.push(~\"-lcompiler-rt\");\n+    args.push(\"-lcompiler-rt\".to_owned());\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n@@ -1317,7 +1317,7 @@ fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n                 args.push(\"-l\" + *l);\n             }\n             cstore::NativeFramework => {\n-                args.push(~\"-framework\");\n+                args.push(\"-framework\".to_owned());\n                 args.push(l.to_owned());\n             }\n         }\n@@ -1525,7 +1525,7 @@ fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n             match kind {\n                 cstore::NativeUnknown => args.push(\"-l\" + *lib),\n                 cstore::NativeFramework => {\n-                    args.push(~\"-framework\");\n+                    args.push(\"-framework\".to_owned());\n                     args.push(lib.to_owned());\n                 }\n                 cstore::NativeStatic => {"}, {"sha": "e318ffe5c9a219c21b8e74c4cd8203222746d1f3", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,45 +15,45 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: ~\"\",\n+        module_asm: \"\".to_owned(),\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            ~\"E-p:32:32:32\" +\n+            \"E-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsWin32 => {\n-            ~\"E-p:32:32:32\" +\n+            \"E-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsLinux => {\n-            ~\"E-p:32:32:32\" +\n+            \"E-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsAndroid => {\n-            ~\"E-p:32:32:32\" +\n+            \"E-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n           abi::OsFreebsd => {\n-            ~\"E-p:32:32:32\" +\n+            \"E-p:32:32:32\".to_owned() +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +"}, {"sha": "d7d86e077de5be702acf9b9ec612309c2c6f67bd", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -33,9 +33,9 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let mut flags = Vec::new();\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n-        flags.push_all([~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n-                        ~\"-Wl,-rpath,/usr/local/lib/gcc44\",\n-                        ~\"-Wl,-z,origin\"]);\n+        flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_owned(),\n+                        \"-Wl,-rpath,/usr/local/lib/gcc44\".to_owned(),\n+                        \"-Wl,-z,origin\".to_owned()]);\n     }\n \n     debug!(\"preparing the RPATH!\");\n@@ -163,8 +163,8 @@ mod test {\n \n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags([~\"path1\", ~\"path2\"]);\n-        assert_eq!(flags, vec!(~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"));\n+        let flags = rpaths_to_flags([\"path1\".to_owned(), \"path2\".to_owned()]);\n+        assert_eq!(flags, vec!(\"-Wl,-rpath,path1\".to_owned(), \"-Wl,-rpath,path2\".to_owned()));\n     }\n \n     #[test]\n@@ -190,17 +190,18 @@ mod test {\n \n     #[test]\n     fn test_minimize1() {\n-        let res = minimize_rpaths([~\"rpath1\", ~\"rpath2\", ~\"rpath1\"]);\n-        assert!(res.as_slice() == [~\"rpath1\", ~\"rpath2\"]);\n+        let res = minimize_rpaths([\"rpath1\".to_owned(), \"rpath2\".to_owned(), \"rpath1\".to_owned()]);\n+        assert!(res.as_slice() == [\"rpath1\".to_owned(), \"rpath2\".to_owned()]);\n     }\n \n     #[test]\n     fn test_minimize2() {\n-        let res = minimize_rpaths([~\"1a\", ~\"2\",  ~\"2\",\n-                                   ~\"1a\", ~\"4a\", ~\"1a\",\n-                                   ~\"2\",  ~\"3\",  ~\"4a\",\n-                                   ~\"3\"]);\n-        assert!(res.as_slice() == [~\"1a\", ~\"2\", ~\"4a\", ~\"3\"]);\n+        let res = minimize_rpaths([\"1a\".to_owned(), \"2\".to_owned(),  \"2\".to_owned(),\n+                                   \"1a\".to_owned(), \"4a\".to_owned(), \"1a\".to_owned(),\n+                                   \"2\".to_owned(),  \"3\".to_owned(),  \"4a\".to_owned(),\n+                                   \"3\".to_owned()]);\n+        assert!(res.as_slice() == [\"1a\".to_owned(), \"2\".to_owned(), \"4a\".to_owned(),\n+                                   \"3\".to_owned()]);\n     }\n \n     #[test]"}, {"sha": "08ea29c2012ecc0586a78bd381d6548a4f27d0a0", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,36 +16,36 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: ~\"\",\n+        module_asm: \"\".to_owned(),\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            ~\"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" +\n+            \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\".to_owned() +\n                 \"-i32:32:32-i64:32:64\" +\n                 \"-f32:32:32-f64:32:64-v64:64:64\" +\n                 \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\"\n           }\n \n           abi::OsWin32 => {\n-            ~\"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\"\n+            \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_owned()\n           }\n \n           abi::OsLinux => {\n-            ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_owned()\n           }\n           abi::OsAndroid => {\n-            ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_owned()\n           }\n \n           abi::OsFreebsd => {\n-            ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_owned()\n           }\n         },\n \n         target_triple: target_triple,\n \n-        cc_args: vec!(~\"-m32\"),\n+        cc_args: vec!(\"-m32\".to_owned()),\n     };\n }"}, {"sha": "68de14a5248546567bf29c8d8fd3b560f167e202", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,44 +16,44 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: ~\"\",\n+        module_asm: \"\".to_owned(),\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64\"\n           }\n \n           abi::OsWin32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n-            ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n           abi::OsLinux => {\n-            ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n           abi::OsAndroid => {\n-            ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n           abi::OsFreebsd => {\n-            ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n         },\n \n         target_triple: target_triple,\n \n-        cc_args: vec!(~\"-m64\"),\n+        cc_args: vec!(\"-m64\".to_owned()),\n     };\n }"}, {"sha": "7da9d6f82bcfa160d72a6d7012635d4be878b787", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -161,7 +161,7 @@ impl Input {\n     fn filestem(&self) -> ~str {\n         match *self {\n             FileInput(ref ifile) => ifile.filestem_str().unwrap().to_str(),\n-            StrInput(_) => ~\"rust_out\",\n+            StrInput(_) => \"rust_out\".to_owned(),\n         }\n     }\n }\n@@ -615,7 +615,7 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n             }\n             pprust::NodeBlock(blk) => {\n                 try!(pp::space(&mut s.s));\n-                s.synth_comment(~\"block \" + blk.id.to_str())\n+                s.synth_comment(\"block \".to_owned() + blk.id.to_str())\n             }\n             pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n@@ -624,7 +624,7 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n             }\n             pprust::NodePat(pat) => {\n                 try!(pp::space(&mut s.s));\n-                s.synth_comment(~\"pat \" + pat.id.to_str())\n+                s.synth_comment(\"pat \".to_owned() + pat.id.to_str())\n             }\n         }\n     }\n@@ -1242,7 +1242,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([~\"--test\"], optgroups().as_slice()) {\n+            &match getopts([\"--test\".to_owned()], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n@@ -1257,7 +1257,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([~\"--test\", ~\"--cfg=test\"],\n+            &match getopts([\"--test\".to_owned(), \"--cfg=test\".to_owned()],\n                            optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {"}, {"sha": "e23423bcd0b71fa1d7c1d182c7d2936895fd07b4", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -434,9 +434,9 @@ cgoptions!(\n         \"system linker to link outputs with\"),\n     link_args: Vec<~str> = (Vec::new(), parse_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n-    target_cpu: ~str = (~\"generic\", parse_string,\n+    target_cpu: ~str = (\"generic\".to_owned(), parse_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n-    target_feature: ~str = (~\"\", parse_string,\n+    target_feature: ~str = (\"\".to_owned(), parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n     passes: Vec<~str> = (Vec::new(), parse_list,\n         \"a list of extra LLVM passes to run (space separated)\"),\n@@ -460,7 +460,7 @@ cgoptions!(\n         \"prefer dynamic linking to static linking\"),\n     no_integrated_as: bool = (false, parse_bool,\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    relocation_model: ~str = (~\"pic\", parse_string,\n+    relocation_model: ~str = (\"pic\".to_owned(), parse_string,\n          \"choose the relocation model to use (llc -relocation-model for details)\"),\n )\n \n@@ -524,12 +524,12 @@ pub fn collect_crate_types(session: &Session,\n                         session.add_lint(lint::UnknownCrateType,\n                                          ast::CRATE_NODE_ID,\n                                          a.span,\n-                                         ~\"invalid `crate_type` value\");\n+                                         \"invalid `crate_type` value\".to_owned());\n                         None\n                     }\n                     _ => {\n                         session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n-                                        a.span, ~\"`crate_type` requires a value\");\n+                                        a.span, \"`crate_type` requires a value\".to_owned());\n                         None\n                     }\n                 }"}, {"sha": "3ab39dd121f082aca119f359f69293b8863e4b42", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -339,7 +339,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                             sess.add_lint(lint::UnknownFeatures,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n-                                          ~\"unknown feature\");\n+                                          \"unknown feature\".to_owned());\n                         }\n                     }\n                 }"}, {"sha": "72b63ebc80d543d22a6be965908ef21024dd6f76", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -171,7 +171,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            name: ~\"test\",\n+            name: \"test\".to_owned(),\n             format: MacroAttribute,\n             span: None\n         }"}, {"sha": "0c9aa60b4a1563de94cf6dc16d766a8cdfb807b2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -243,24 +243,24 @@ pub fn run_compiler(args: &[~str]) {\n \n     let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n                                     matches.opt_strs(\"warn\").as_slice());\n-    if lint_flags.iter().any(|x| x == &~\"help\") {\n+    if lint_flags.iter().any(|x| x == &\"help\".to_owned()) {\n         describe_warnings();\n         return;\n     }\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.iter().any(|x| x == &~\"help\") {\n+    if r.iter().any(|x| x == &\"help\".to_owned()) {\n         describe_debug_flags();\n         return;\n     }\n \n     let cg_flags = matches.opt_strs(\"C\");\n-    if cg_flags.iter().any(|x| x == &~\"help\") {\n+    if cg_flags.iter().any(|x| x == &\"help\".to_owned()) {\n         describe_codegen_flags();\n         return;\n     }\n \n-    if cg_flags.contains(&~\"passes=list\") {\n+    if cg_flags.contains(&\"passes=list\".to_owned()) {\n         unsafe { lib::llvm::llvm::LLVMRustPrintPasses(); }\n         return;\n     }\n@@ -406,9 +406,9 @@ pub fn monitor(f: proc():Send) {\n                 }\n \n                 let xs = [\n-                    ~\"the compiler hit an unexpected failure path. this is a bug.\",\n+                    \"the compiler hit an unexpected failure path. this is a bug.\".to_owned(),\n                     \"we would appreciate a bug report: \" + BUG_REPORT_URL,\n-                    ~\"run with `RUST_BACKTRACE=1` for a backtrace\",\n+                    \"run with `RUST_BACKTRACE=1` for a backtrace\".to_owned(),\n                 ];\n                 for note in xs.iter() {\n                     emitter.emit(None, *note, diagnostic::Note)"}, {"sha": "9b3dce6147b1a045ecb09ae78ac90f6e41a56605", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -241,21 +241,21 @@ fn find_libdir(sysroot: &Path) -> ~str {\n     }\n \n     #[cfg(target_word_size = \"64\")]\n-    fn primary_libdir_name() -> ~str { ~\"lib64\" }\n+    fn primary_libdir_name() -> ~str { \"lib64\".to_owned() }\n \n     #[cfg(target_word_size = \"32\")]\n-    fn primary_libdir_name() -> ~str { ~\"lib32\" }\n+    fn primary_libdir_name() -> ~str { \"lib32\".to_owned() }\n \n-    fn secondary_libdir_name() -> ~str { ~\"lib\" }\n+    fn secondary_libdir_name() -> ~str { \"lib\".to_owned() }\n }\n \n #[cfg(windows)]\n fn find_libdir(_sysroot: &Path) -> ~str {\n-    ~\"bin\"\n+    \"bin\".to_owned()\n }\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n pub fn rustlibdir() -> ~str {\n-    ~\"rustlib\"\n+    \"rustlib\".to_owned()\n }"}, {"sha": "5e0425141ac82e64f5e806f1df7150aaefe26d71", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -240,7 +240,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             if restr.loan_path != loan2.loan_path { continue; }\n \n             let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n-                ~\"it\"\n+                \"it\".to_owned()\n             } else {\n                 format!(\"`{}`\",\n                         self.bccx.loan_path_to_str(old_loan.loan_path))"}, {"sha": "67f3b8fe90654638880a89e6b63eec29a6abe224", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -112,7 +112,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprCast(_, _) => {\n             let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n-                v.tcx.sess.span_err(e.span, ~\"can not cast to `\" +\n+                v.tcx.sess.span_err(e.span, \"can not cast to `\".to_owned() +\n                                               ppaux::ty_to_str(v.tcx, ety) +\n                                              \"` in a constant expression\");\n             }"}, {"sha": "e08ffa89cfba17f6123d812c68f8737b4e0b96c4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -172,8 +172,8 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match *ctor {\n-                        val(const_bool(true)) => Some(~\"true\"),\n-                        val(const_bool(false)) => Some(~\"false\"),\n+                        val(const_bool(true)) => Some(\"true\".to_owned()),\n+                        val(const_bool(false)) => Some(\"false\".to_owned()),\n                         _ => None\n                     }\n                 }\n@@ -201,9 +201,9 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n             }\n         }\n     };\n-    let msg = ~\"non-exhaustive patterns\" + match ext {\n+    let msg = \"non-exhaustive patterns\".to_owned() + match ext {\n         Some(ref s) => format!(\": {} not covered\",  *s),\n-        None => ~\"\"\n+        None => \"\".to_owned()\n     };\n     cx.tcx.sess.span_err(sp, msg);\n }"}, {"sha": "763c1abdc7394ec169a6538b2b4dd022035a76f0", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -132,7 +132,7 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n                     ty::ty_enum(did, _) => {\n                         if ty::has_dtor(self.tcx, did) {\n                             self.report_error(e.span,\n-                                     Some(~\"static items are not allowed to have destructors\"));\n+                             Some(\"static items are not allowed to have destructors\".to_owned()));\n                             return;\n                         }\n                     }"}, {"sha": "d39f0721b427ff6717f84316a128d8f7ddbf89a8", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -321,8 +321,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => Err(~\"negate on string\"),\n-          Ok(const_bool(_)) => Err(~\"negate on boolean\"),\n+          Ok(const_str(_)) => Err(\"negate on string\".to_owned()),\n+          Ok(const_bool(_)) => Err(\"negate on boolean\".to_owned()),\n           ref err => ((*err).clone())\n         }\n       }\n@@ -331,7 +331,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          _ => Err(~\"not on float or string\")\n+          _ => Err(\"not on float or string\".to_owned())\n         }\n       }\n       ExprBinary(op, a, b) => {\n@@ -350,17 +350,17 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiNe => fromb(a != b),\n               BiGe => fromb(a >= b),\n               BiGt => fromb(a > b),\n-              _ => Err(~\"can't do this op on floats\")\n+              _ => Err(\"can't do this op on floats\".to_owned())\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n             match op {\n               BiAdd => Ok(const_int(a + b)),\n               BiSub => Ok(const_int(a - b)),\n               BiMul => Ok(const_int(a * b)),\n-              BiDiv if b == 0 => Err(~\"attempted to divide by zero\"),\n+              BiDiv if b == 0 => Err(\"attempted to divide by zero\".to_owned()),\n               BiDiv => Ok(const_int(a / b)),\n-              BiRem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n+              BiRem if b == 0 => Err(\"attempted remainder with a divisor of zero\".to_owned()),\n               BiRem => Ok(const_int(a % b)),\n               BiAnd | BiBitAnd => Ok(const_int(a & b)),\n               BiOr | BiBitOr => Ok(const_int(a | b)),\n@@ -380,9 +380,9 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiAdd => Ok(const_uint(a + b)),\n               BiSub => Ok(const_uint(a - b)),\n               BiMul => Ok(const_uint(a * b)),\n-              BiDiv if b == 0 => Err(~\"attempted to divide by zero\"),\n+              BiDiv if b == 0 => Err(\"attempted to divide by zero\".to_owned()),\n               BiDiv => Ok(const_uint(a / b)),\n-              BiRem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n+              BiRem if b == 0 => Err(\"attempted remainder with a divisor of zero\".to_owned()),\n               BiRem => Ok(const_uint(a % b)),\n               BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n               BiOr | BiBitOr => Ok(const_uint(a | b)),\n@@ -402,14 +402,14 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n             match op {\n               BiShl => Ok(const_int(a << b)),\n               BiShr => Ok(const_int(a >> b)),\n-              _ => Err(~\"can't do this op on an int and uint\")\n+              _ => Err(\"can't do this op on an int and uint\".to_owned())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n               BiShl => Ok(const_uint(a << b)),\n               BiShr => Ok(const_uint(a >> b)),\n-              _ => Err(~\"can't do this op on a uint and int\")\n+              _ => Err(\"can't do this op on a uint and int\".to_owned())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n@@ -421,10 +421,10 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiBitOr => a | b,\n               BiEq => a == b,\n               BiNe => a != b,\n-              _ => return Err(~\"can't do this op on bools\")\n+              _ => return Err(\"can't do this op on bools\".to_owned())\n              }))\n           }\n-          _ => Err(~\"bad operands for binary\")\n+          _ => Err(\"bad operands for binary\".to_owned())\n         }\n       }\n       ExprCast(base, target_ty) => {\n@@ -448,41 +448,41 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             const_uint(u) => Ok(const_float(u as f64)),\n                             const_int(i) => Ok(const_float(i as f64)),\n                             const_float(f) => Ok(const_float(f)),\n-                            _ => Err(~\"can't cast float to str\"),\n+                            _ => Err(\"can't cast float to str\".to_owned()),\n                         }\n                     }\n                     ty::ty_uint(_) => {\n                         match val {\n                             const_uint(u) => Ok(const_uint(u)),\n                             const_int(i) => Ok(const_uint(i as u64)),\n                             const_float(f) => Ok(const_uint(f as u64)),\n-                            _ => Err(~\"can't cast str to uint\"),\n+                            _ => Err(\"can't cast str to uint\".to_owned()),\n                         }\n                     }\n                     ty::ty_int(_) | ty::ty_bool => {\n                         match val {\n                             const_uint(u) => Ok(const_int(u as i64)),\n                             const_int(i) => Ok(const_int(i)),\n                             const_float(f) => Ok(const_int(f as i64)),\n-                            _ => Err(~\"can't cast str to int\"),\n+                            _ => Err(\"can't cast str to int\".to_owned()),\n                         }\n                     }\n-                    _ => Err(~\"can't cast this type\")\n+                    _ => Err(\"can't cast this type\".to_owned())\n                 }\n             }\n         }\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n               Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n-              None => Err(~\"non-constant path in constant expr\")\n+              None => Err(\"non-constant path in constant expr\".to_owned())\n           }\n       }\n       ExprLit(lit) => Ok(lit_to_const(lit)),\n       // If we have a vstore, just keep going; it has to be a string\n       ExprVstore(e, _) => eval_const_expr_partial(tcx, e),\n       ExprParen(e)     => eval_const_expr_partial(tcx, e),\n-      _ => Err(~\"unsupported constant expr\")\n+      _ => Err(\"unsupported constant expr\".to_owned())\n     }\n }\n "}, {"sha": "2b79917f9d51567c8c30ed63945cd62d6dca331b", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -103,14 +103,14 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n                 format!(\" gen: {}\", bits_to_str(gens))\n             } else {\n-                ~\"\"\n+                \"\".to_owned()\n             };\n \n             let kills = self.kills.slice(start, end);\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n                 format!(\" kill: {}\", bits_to_str(kills))\n             } else {\n-                ~\"\"\n+                \"\".to_owned()\n             };\n \n             try!(ps.synth_comment(format!(\"id {}: {}{}{}\", id, entry_str,"}, {"sha": "c943744147d5bc3eeec7ed04ad0688c5fbaf70f6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -157,7 +157,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> ~str {\n         FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n         ExprNode(s)    => format!(\"Expr node [{}]\", cm.span_to_str(s)),\n         VarDefNode(s)  => format!(\"Var def node [{}]\", cm.span_to_str(s)),\n-        ExitNode       => ~\"Exit node\"\n+        ExitNode       => \"Exit node\".to_owned()\n     }\n }\n \n@@ -328,7 +328,7 @@ impl<'a> IrMaps<'a> {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n                 token::get_ident(nm).get().to_str()\n             },\n-            &ImplicitRet => ~\"<implicit-ret>\"\n+            &ImplicitRet => \"<implicit-ret>\".to_owned()\n         }\n     }\n "}, {"sha": "fc9d5a60eec63c7f1a37f5c11a6fd2fb9254ae29", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1089,19 +1089,19 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n     pub fn cmt_to_str(&self, cmt: cmt) -> ~str {\n         match cmt.cat {\n           cat_static_item => {\n-              ~\"static item\"\n+              \"static item\".to_owned()\n           }\n           cat_copied_upvar(_) => {\n-              ~\"captured outer variable in a proc\"\n+              \"captured outer variable in a proc\".to_owned()\n           }\n           cat_rvalue(..) => {\n-              ~\"non-lvalue\"\n+              \"non-lvalue\".to_owned()\n           }\n           cat_local(_) => {\n-              ~\"local variable\"\n+              \"local variable\".to_owned()\n           }\n           cat_arg(..) => {\n-              ~\"argument\"\n+              \"argument\".to_owned()\n           }\n           cat_deref(base, _, pk) => {\n               match base.cat {\n@@ -1114,22 +1114,22 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n               }\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n-              ~\"field\"\n+              \"field\".to_owned()\n           }\n           cat_interior(_, InteriorField(PositionalField(_))) => {\n-              ~\"anonymous field\"\n+              \"anonymous field\".to_owned()\n           }\n           cat_interior(_, InteriorElement(VecElement)) => {\n-              ~\"vec content\"\n+              \"vec content\".to_owned()\n           }\n           cat_interior(_, InteriorElement(StrElement)) => {\n-              ~\"str content\"\n+              \"str content\".to_owned()\n           }\n           cat_interior(_, InteriorElement(OtherElement)) => {\n-              ~\"indexed content\"\n+              \"indexed content\".to_owned()\n           }\n           cat_upvar(..) => {\n-              ~\"captured outer variable\"\n+              \"captured outer variable\".to_owned()\n           }\n           cat_discr(cmt, _) => {\n             self.cmt_to_str(cmt)\n@@ -1300,7 +1300,7 @@ impl Repr for InteriorKind {\n                 token::get_name(fld).get().to_str()\n             }\n             InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n-            InteriorElement(_) => ~\"[]\",\n+            InteriorElement(_) => \"[]\".to_owned(),\n         }\n     }\n }"}, {"sha": "b2e1a992f54792b6f472e744d878ffdf3090feba", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1340,7 +1340,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                 if self.path_is_private_type(path_id) {\n                     self.tcx.sess.add_lint(lint::VisiblePrivateTypes,\n                                            path_id, p.span,\n-                                           ~\"private type in exported type signature\");\n+                                           \"private type in exported type signature\".to_owned());\n                 }\n             }\n             _ => {}"}, {"sha": "70483aac7062d0336590875e87a2c5db48ee8177", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -2126,7 +2126,7 @@ impl<'a> Resolver<'a> {\n             SingleImport(_, source) => {\n                 token::get_ident(source).get().to_str()\n             }\n-            GlobImport => ~\"*\"\n+            GlobImport => \"*\".to_owned()\n         }\n     }\n \n@@ -4617,7 +4617,7 @@ impl<'a> Resolver<'a> {\n                     self.session.add_lint(UnnecessaryQualification,\n                                           id,\n                                           path.span,\n-                                          ~\"unnecessary qualification\");\n+                                          \"unnecessary qualification\".to_owned());\n                 }\n                 _ => ()\n             }\n@@ -5300,7 +5300,8 @@ impl<'a> Resolver<'a> {\n                         ViewPathGlob(_, id) => {\n                             if !self.used_imports.contains(&(id, TypeNS)) &&\n                                !self.used_imports.contains(&(id, ValueNS)) {\n-                                self.session.add_lint(UnusedImports, id, p.span, ~\"unused import\");\n+                                self.session.add_lint(UnusedImports, id, p.span,\n+                                                      \"unused import\".to_owned());\n                             }\n                         },\n                     }\n@@ -5321,7 +5322,7 @@ impl<'a> Resolver<'a> {\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(UnusedImports, id, span, ~\"unused import\");\n+            self.session.add_lint(UnusedImports, id, span, \"unused import\".to_owned());\n         }\n \n         let (v_priv, t_priv) = match self.last_private.find(&id) {\n@@ -5386,7 +5387,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         if idents.len() == 0 {\n-            return ~\"???\";\n+            return \"???\".to_owned();\n         }\n         return self.idents_to_str(idents.move_iter()\n                                         .rev()\n@@ -5409,18 +5410,18 @@ impl<'a> Resolver<'a> {\n         for (&name, import_resolution) in import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n-                None => { value_repr = ~\"\"; }\n+                None => { value_repr = \"\".to_owned(); }\n                 Some(_) => {\n-                    value_repr = ~\" value:?\";\n+                    value_repr = \" value:?\".to_owned();\n                     // FIXME #4954\n                 }\n             }\n \n             let type_repr;\n             match import_resolution.target_for_namespace(TypeNS) {\n-                None => { type_repr = ~\"\"; }\n+                None => { type_repr = \"\".to_owned(); }\n                 Some(_) => {\n-                    type_repr = ~\" type:?\";\n+                    type_repr = \" type:?\".to_owned();\n                     // FIXME #4954\n                 }\n             }"}, {"sha": "0fbaf74561583b1c45c00c59ac13bccc9082c1f4", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -93,7 +93,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                     let root_msg = match self.root_ty {\n                         Some(root) => format!(\" in the substitution of `{}`\",\n                                               root.repr(self.tcx)),\n-                        None => ~\"\"\n+                        None => \"\".to_owned()\n                     };\n                     let m = format!(\"can't use type parameters from outer \\\n                                     function{}; try using a local type \\\n@@ -112,7 +112,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                         let root_msg = match self.root_ty {\n                             Some(root) => format!(\" in the substitution of `{}`\",\n                                                   root.repr(self.tcx)),\n-                            None => ~\"\"\n+                            None => \"\".to_owned()\n                         };\n                         let m = format!(\"missing `Self` type param{}\", root_msg);\n                         match self.span {"}, {"sha": "d6636854713a88b2bc34a831208ed9db5249d0aa", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -137,11 +137,11 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"mips\")]\n fn getClobbers() -> ~str {\n-    ~\"\"\n+    \"\".to_owned()\n }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]\n fn getClobbers() -> ~str {\n-    ~\"~{dirflag},~{fpsr},~{flags}\"\n+    \"~{dirflag},~{fpsr},~{flags}\".to_owned()\n }"}, {"sha": "95ba619e401039d1773fecee102bc40e23d788cb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -468,7 +468,7 @@ pub fn set_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n     if ccx.all_llvm_symbols.borrow().contains(&sym) {\n-        ccx.sess().bug(~\"duplicate LLVM symbol: \" + sym);\n+        ccx.sess().bug(\"duplicate LLVM symbol: \".to_owned() + sym);\n     }\n     ccx.all_llvm_symbols.borrow_mut().insert(sym);\n }\n@@ -696,7 +696,7 @@ pub fn iter_structural_ty<'r,\n \n                   for variant in (*variants).iter() {\n                       let variant_cx =\n-                          fcx.new_temp_block(~\"enum-iter-variant-\" +\n+                          fcx.new_temp_block(\"enum-iter-variant-\".to_owned() +\n                                              variant.disr_val.to_str());\n                       match adt::trans_case(cx, repr, variant.disr_val) {\n                           _match::single_result(r) => {\n@@ -795,7 +795,7 @@ pub fn fail_if_zero<'a>(\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n-        cx.sess().bug(~\"fail-if-zero on unexpected type: \" +\n+        cx.sess().bug(\"fail-if-zero on unexpected type: \".to_owned() +\n                       ty_to_str(cx.tcx(), rhs_t));\n       }\n     };\n@@ -1108,7 +1108,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n     for p in param_substs.iter() { p.validate(); }\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n-           if id == -1 { ~\"\" } else { ccx.tcx.map.path_to_str(id) },\n+           if id == -1 { \"\".to_owned() } else { ccx.tcx.map.path_to_str(id) },\n            id, param_substs.repr(ccx.tcx()));\n \n     let substd_output_type = match param_substs {\n@@ -2188,10 +2188,12 @@ pub fn trans_crate(krate: ast::Crate,\n     // symbol. This symbol is required for use by the libmorestack library that\n     // we link in, so we must ensure that this symbol is not internalized (if\n     // defined in the crate).\n-    reachable.push(~\"main\");\n-    reachable.push(~\"rust_stack_exhausted\");\n-    reachable.push(~\"rust_eh_personality\"); // referenced from .eh_frame section on some platforms\n-    reachable.push(~\"rust_eh_personality_catch\"); // referenced from rt/rust_try.ll\n+    reachable.push(\"main\".to_owned());\n+    reachable.push(\"rust_stack_exhausted\".to_owned());\n+\n+    // referenced from .eh_frame section on some platforms\n+    reachable.push(\"rust_eh_personality\".to_owned());\n+    reachable.push(\"rust_eh_personality_catch\".to_owned()); // referenced from rt/rust_try.ll\n \n     let metadata_module = ccx.metadata_llmod;\n "}, {"sha": "c90d457e83a2851f520d6314aedcb68d84d3a5af", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -117,9 +117,9 @@ pub struct EnvValue {\n impl EnvAction {\n     pub fn to_str(&self) -> ~str {\n         match *self {\n-            EnvCopy => ~\"EnvCopy\",\n-            EnvMove => ~\"EnvMove\",\n-            EnvRef => ~\"EnvRef\"\n+            EnvCopy => \"EnvCopy\".to_owned(),\n+            EnvMove => \"EnvMove\".to_owned(),\n+            EnvRef => \"EnvRef\".to_owned()\n         }\n     }\n }"}, {"sha": "e44370afa2d71e59d9923499267717988160ec59", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1149,27 +1149,27 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n     debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n-        ty::ty_nil => (~\"()\", DW_ATE_unsigned),\n-        ty::ty_bot => (~\"!\", DW_ATE_unsigned),\n-        ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n-        ty::ty_char => (~\"char\", DW_ATE_unsigned_char),\n+        ty::ty_nil => (\"()\".to_owned(), DW_ATE_unsigned),\n+        ty::ty_bot => (\"!\".to_owned(), DW_ATE_unsigned),\n+        ty::ty_bool => (\"bool\".to_owned(), DW_ATE_boolean),\n+        ty::ty_char => (\"char\".to_owned(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n-            ast::TyI => (~\"int\", DW_ATE_signed),\n-            ast::TyI8 => (~\"i8\", DW_ATE_signed),\n-            ast::TyI16 => (~\"i16\", DW_ATE_signed),\n-            ast::TyI32 => (~\"i32\", DW_ATE_signed),\n-            ast::TyI64 => (~\"i64\", DW_ATE_signed)\n+            ast::TyI => (\"int\".to_owned(), DW_ATE_signed),\n+            ast::TyI8 => (\"i8\".to_owned(), DW_ATE_signed),\n+            ast::TyI16 => (\"i16\".to_owned(), DW_ATE_signed),\n+            ast::TyI32 => (\"i32\".to_owned(), DW_ATE_signed),\n+            ast::TyI64 => (\"i64\".to_owned(), DW_ATE_signed)\n         },\n         ty::ty_uint(uint_ty) => match uint_ty {\n-            ast::TyU => (~\"uint\", DW_ATE_unsigned),\n-            ast::TyU8 => (~\"u8\", DW_ATE_unsigned),\n-            ast::TyU16 => (~\"u16\", DW_ATE_unsigned),\n-            ast::TyU32 => (~\"u32\", DW_ATE_unsigned),\n-            ast::TyU64 => (~\"u64\", DW_ATE_unsigned)\n+            ast::TyU => (\"uint\".to_owned(), DW_ATE_unsigned),\n+            ast::TyU8 => (\"u8\".to_owned(), DW_ATE_unsigned),\n+            ast::TyU16 => (\"u16\".to_owned(), DW_ATE_unsigned),\n+            ast::TyU32 => (\"u32\".to_owned(), DW_ATE_unsigned),\n+            ast::TyU64 => (\"u64\".to_owned(), DW_ATE_unsigned)\n         },\n         ty::ty_float(float_ty) => match float_ty {\n-            ast::TyF32 => (~\"f32\", DW_ATE_float),\n-            ast::TyF64 => (~\"f64\", DW_ATE_float)\n+            ast::TyF32 => (\"f32\".to_owned(), DW_ATE_float),\n+            ast::TyF64 => (\"f64\".to_owned(), DW_ATE_float)\n         },\n         _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n@@ -1247,7 +1247,7 @@ impl StructMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.fields.iter().map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n-                ~\"\"\n+                \"\".to_owned()\n             } else {\n                 token::get_ident(field.ident).get().to_str()\n             };\n@@ -1350,7 +1350,7 @@ impl TupleMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.component_types.iter().map(|&component_type| {\n             MemberDescription {\n-                name: ~\"\",\n+                name: \"\".to_owned(),\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n@@ -1428,7 +1428,7 @@ impl GeneralMemberDescriptionFactory {\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n                 MemberDescription {\n-                    name: ~\"\",\n+                    name: \"\".to_owned(),\n                     llvm_type: variant_llvm_type,\n                     type_metadata: variant_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n@@ -1497,12 +1497,12 @@ fn describe_enum_variant(cx: &CrateContext,\n         Some(ref names) => {\n             names.iter().map(|ident| token::get_ident(*ident).get().to_str()).collect()\n         }\n-        None => variant_info.args.iter().map(|_| ~\"\").collect()\n+        None => variant_info.args.iter().map(|_| \"\".to_owned()).collect()\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n     if discriminant_type_metadata.is_some() {\n-        arg_names.insert(0, ~\"\");\n+        arg_names.insert(0, \"\".to_owned());\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n@@ -1853,7 +1853,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                     -> DICompositeType {\n     let box_type_name = match content_type_name {\n         Some(content_type_name) => format!(\"Boxed<{}>\", content_type_name),\n-        None                    => ~\"BoxedType\"\n+        None                    => \"BoxedType\".to_owned()\n     };\n \n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n@@ -1868,31 +1868,31 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: ~\"refcnt\",\n+            name: \"refcnt\".to_owned(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"drop_glue\",\n+            name: \"drop_glue\".to_owned(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"prev\",\n+            name: \"prev\".to_owned(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"next\",\n+            name: \"next\".to_owned(),\n             llvm_type: *member_llvm_types.get(3),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"val\",\n+            name: \"val\".to_owned(),\n             llvm_type: *member_llvm_types.get(4),\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -1979,19 +1979,19 @@ fn vec_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: ~\"fill\",\n+            name: \"fill\".to_owned(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"alloc\",\n+            name: \"alloc\".to_owned(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"elements\",\n+            name: \"elements\".to_owned(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: array_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -2036,13 +2036,13 @@ fn vec_slice_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: ~\"data_ptr\",\n+            name: \"data_ptr\".to_owned(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"length\",\n+            name: \"length\".to_owned(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,"}, {"sha": "50eda155b52f1736c949d2ab94b09a5ea26b2f3a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -90,7 +90,7 @@ impl Dest {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         match *self {\n             SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n-            Ignore => ~\"Ignore\"\n+            Ignore => \"Ignore\".to_owned()\n         }\n     }\n }"}, {"sha": "966e05ff1eaf04a84aa34b4cd49a3b4f76d5d383", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -433,7 +433,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                         name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n-    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, ~\"glue_\" + name);\n+    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"glue_\".to_owned() + name);\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);"}, {"sha": "de1ee72c9df1bec6728e0213feb356926b9ccc0f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -87,7 +87,7 @@ impl<'a> Reflector<'a> {\n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n         let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n-        let mth_idx = ty::method_idx(token::str_to_ident(~\"visit_\" + ty_name),\n+        let mth_idx = ty::method_idx(token::str_to_ident(\"visit_\".to_owned() + ty_name),\n                                      self.visitor_methods.as_slice()).expect(\n                 format!(\"couldn't find visit method for {}\", ty_name));\n         let mth_ty =\n@@ -128,10 +128,10 @@ impl<'a> Reflector<'a> {\n         match vstore {\n             ty::VstoreFixed(n) => {\n                 let extra = (vec!(self.c_uint(n))).append(self.c_size_and_align(t).as_slice());\n-                (~\"fixed\", extra)\n+                (\"fixed\".to_owned(), extra)\n             }\n-            ty::VstoreSlice(..) => (~\"slice\", Vec::new()),\n-            ty::VstoreUniq => (~\"uniq\", Vec::new()),\n+            ty::VstoreSlice(..) => (\"slice\".to_owned(), Vec::new()),\n+            ty::VstoreUniq => (\"uniq\".to_owned(), Vec::new()),\n         }\n     }\n \n@@ -166,7 +166,7 @@ impl<'a> Reflector<'a> {\n           // Should rename to str_*/vec_*.\n           ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              self.visit(~\"estr_\" + name, extra.as_slice())\n+              self.visit(\"estr_\".to_owned() + name, extra.as_slice())\n           }\n           ty::ty_vec(ty, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n@@ -177,7 +177,7 @@ impl<'a> Reflector<'a> {\n                       _ => ast::MutImmutable\n                   }\n               }).as_slice());\n-              self.visit(~\"evec_\" + name, extra.as_slice())\n+              self.visit(\"evec_\".to_owned() + name, extra.as_slice())\n           }\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {"}, {"sha": "a590c5b38f4c2452f01255f95d74c02b1d57d756", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -226,15 +226,15 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                              content_expr: &ast::Expr)\n                              -> DatumBlock<'a, Expr> {\n     /*!\n-     * ~[...] and ~\"...\" allocate boxes in the exchange heap and write\n+     * ~[...] and \"...\".to_owned() allocate boxes in the exchange heap and write\n      * the array elements into them.\n      */\n \n     debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_str(vstore_expr));\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    // Handle ~\"\".\n+    // Handle \"\".to_owned().\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {"}, {"sha": "d6f1866f5dc0386e77c78d1c3303e4ac4984e076", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -3251,22 +3251,22 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> ~str {\n         }\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n-        ty_box(_) => ~\"@-ptr\",\n-        ty_uniq(_) => ~\"~-ptr\",\n-        ty_vec(_, _) => ~\"vector\",\n-        ty_ptr(_) => ~\"*-ptr\",\n-        ty_rptr(_, _) => ~\"&-ptr\",\n-        ty_bare_fn(_) => ~\"extern fn\",\n-        ty_closure(_) => ~\"fn\",\n+        ty_box(_) => \"@-ptr\".to_owned(),\n+        ty_uniq(_) => \"~-ptr\".to_owned(),\n+        ty_vec(_, _) => \"vector\".to_owned(),\n+        ty_ptr(_) => \"*-ptr\".to_owned(),\n+        ty_rptr(_, _) => \"&-ptr\".to_owned(),\n+        ty_bare_fn(_) => \"extern fn\".to_owned(),\n+        ty_closure(_) => \"fn\".to_owned(),\n         ty_trait(ref inner) => format!(\"trait {}\", item_path_str(cx, inner.def_id)),\n         ty_struct(id, _) => format!(\"struct {}\", item_path_str(cx, id)),\n-        ty_tup(_) => ~\"tuple\",\n-        ty_infer(TyVar(_)) => ~\"inferred type\",\n-        ty_infer(IntVar(_)) => ~\"integral variable\",\n-        ty_infer(FloatVar(_)) => ~\"floating-point variable\",\n-        ty_param(_) => ~\"type parameter\",\n-        ty_self(_) => ~\"self\",\n-        ty_err => ~\"type error\"\n+        ty_tup(_) => \"tuple\".to_owned(),\n+        ty_infer(TyVar(_)) => \"inferred type\".to_owned(),\n+        ty_infer(IntVar(_)) => \"integral variable\".to_owned(),\n+        ty_infer(FloatVar(_)) => \"floating-point variable\".to_owned(),\n+        ty_param(_) => \"type parameter\".to_owned(),\n+        ty_self(_) => \"self\".to_owned(),\n+        ty_err => \"type error\".to_owned()\n     }\n }\n \n@@ -3282,15 +3282,15 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n \n     fn terr_vstore_kind_to_str(k: terr_vstore_kind) -> ~str {\n         match k {\n-            terr_vec => ~\"[]\",\n-            terr_str => ~\"str\",\n-            terr_fn => ~\"fn\",\n-            terr_trait => ~\"trait\"\n+            terr_vec => \"[]\".to_owned(),\n+            terr_str => \"str\".to_owned(),\n+            terr_fn => \"fn\".to_owned(),\n+            terr_trait => \"trait\".to_owned()\n         }\n     }\n \n     match *err {\n-        terr_mismatch => ~\"types differ\",\n+        terr_mismatch => \"types differ\".to_owned(),\n         terr_fn_style_mismatch(values) => {\n             format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n@@ -3308,11 +3308,11 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n-        terr_mutability => ~\"values differ in mutability\",\n-        terr_box_mutability => ~\"boxed values differ in mutability\",\n-        terr_vec_mutability => ~\"vectors differ in mutability\",\n-        terr_ptr_mutability => ~\"pointers differ in mutability\",\n-        terr_ref_mutability => ~\"references differ in mutability\",\n+        terr_mutability => \"values differ in mutability\".to_owned(),\n+        terr_box_mutability => \"boxed values differ in mutability\".to_owned(),\n+        terr_vec_mutability => \"vectors differ in mutability\".to_owned(),\n+        terr_ptr_mutability => \"pointers differ in mutability\".to_owned(),\n+        terr_ref_mutability => \"references differ in mutability\".to_owned(),\n         terr_ty_param_size(values) => {\n             format!(\"expected a type with {} type params \\\n                   but found one with {} type params\",\n@@ -3329,15 +3329,15 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n                  values.expected, values.found)\n         }\n         terr_record_mutability => {\n-            ~\"record elements differ in mutability\"\n+            \"record elements differ in mutability\".to_owned()\n         }\n         terr_record_fields(values) => {\n             format!(\"expected a record with field `{}` but found one with field \\\n                   `{}`\",\n                  token::get_ident(values.expected),\n                  token::get_ident(values.found))\n         }\n-        terr_arg_count => ~\"incorrect number of function parameters\",\n+        terr_arg_count => \"incorrect number of function parameters\".to_owned(),\n         terr_regions_does_not_outlive(..) => {\n             format!(\"lifetime mismatch\")\n         }"}, {"sha": "825c71c3a693a4732b1c4fa7351f9321f0865c08", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -166,10 +166,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                                                       expected.map_or(~\"\", |e| {\n+                                                       expected.map_or(\"\".to_owned(), |e| {\n                         format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n-                             Some(expected), ~\"a structure pattern\",\n+                             Some(expected), \"a structure pattern\".to_owned(),\n                              None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n@@ -217,10 +217,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_or(~\"\", |e| {\n+                                               expected.map_or(\"\".to_owned(), |e| {\n                     format!(\"mismatched types: expected `{}` but found {}\",\n                          e, actual)})},\n-                    Some(expected), ~\"an enum or structure pattern\",\n+                    Some(expected), \"an enum or structure pattern\".to_owned(),\n                     None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n@@ -446,7 +446,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         debug!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n-            || ~\"mismatched types in range\")\n+            || \"mismatched types in range\".to_owned())\n         {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) && !ty::type_is_char(b_ty) {\n@@ -540,10 +540,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n-                            expected.map_or(~\"\", |e| {\n+                            expected.map_or(\"\".to_owned(), |e| {\n                                     format!(\"mismatched types: expected `{}` but found {}\",\n                                          e, actual)})},\n-                                         Some(expected), ~\"a structure pattern\",\n+                                         Some(expected), \"a structure pattern\".to_owned(),\n                                          None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n@@ -597,9 +597,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                 };\n                 // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n-                expected.map_or(~\"\", |e| {\n-                    format!(\"mismatched types: expected `{}` but found {}\",\n-                                     e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n+                        expected.map_or(\"\".to_owned(), |e| {\n+                            format!(\"mismatched types: expected `{}` but found {}\",\n+                                             e, actual)})},\n+                    Some(expected), \"tuple\".to_owned(), Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n         }\n@@ -650,11 +651,11 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n               fcx.infcx().type_error_message_str_with_expected(\n                   pat.span,\n                   |expected, actual| {\n-                      expected.map_or(~\"\", |e| {\n+                      expected.map_or(\"\".to_owned(), |e| {\n                           format!(\"mismatched types: expected `{}` but found {}\",\n                                e, actual)})},\n                   Some(expected),\n-                  ~\"a vector pattern\",\n+                  \"a vector pattern\".to_owned(),\n                   None);\n               fcx.write_error(pat.id);\n               return;\n@@ -706,7 +707,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_or(~\"\", |e| {\n+                    expected.map_or(\"\".to_owned(), |e| {\n                         format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                 Some(expected),"}, {"sha": "d971b2c31c229b6834705a5b4264e25d76125fa4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -2339,7 +2339,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let name = class_field.name;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n-                        missing_fields.push(~\"`\" + token::get_name(name).get() + \"`\");\n+                        missing_fields.push(\"`\".to_owned() + token::get_name(name).get() + \"`\");\n                     }\n                 }\n \n@@ -3128,7 +3128,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n-               _ => ~\"empty\"\n+               _ => \"empty\".to_owned()\n            });\n \n     unifier();\n@@ -3277,7 +3277,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                   _ => false\n                 } {\n                 fcx.ccx.tcx.sess.add_lint(UnreachableCode, s_id, s.span,\n-                                          ~\"unreachable statement\");\n+                                          \"unreachable statement\".to_owned());\n                 warned = true;\n             }\n             if ty::type_is_bot(s_ty) {\n@@ -3299,7 +3299,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n           Some(e) => {\n             if any_bot && !warned {\n                 fcx.ccx.tcx.sess.add_lint(UnreachableCode, e.id, e.span,\n-                                          ~\"unreachable expression\");\n+                                          \"unreachable expression\".to_owned());\n             }\n             check_expr_with_opt_hint(fcx, e, expected);\n               let ety = fcx.expr_ty(e);\n@@ -3779,7 +3779,7 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n         _ => {\n             fcx.type_error_message(sp, |_actual| {\n-                ~\"the type of this value must be known in this context\"\n+                \"the type of this value must be known in this context\".to_owned()\n             }, tp, None);\n             demand::suptype(fcx, sp, ty::mk_err(), tp);\n             tp"}, {"sha": "6ba727f9d4d17028678eb3fa5a3948d73aad7478", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1209,12 +1209,12 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n-            infer::MiscVariable(_) => ~\"\",\n-            infer::PatternRegion(_) => ~\" for pattern\",\n-            infer::AddrOfRegion(_) => ~\" for borrow expression\",\n-            infer::AddrOfSlice(_) => ~\" for slice expression\",\n-            infer::Autoref(_) => ~\" for autoref\",\n-            infer::Coercion(_) => ~\" for automatic coercion\",\n+            infer::MiscVariable(_) => \"\".to_owned(),\n+            infer::PatternRegion(_) => \" for pattern\".to_owned(),\n+            infer::AddrOfRegion(_) => \" for borrow expression\".to_owned(),\n+            infer::AddrOfSlice(_) => \" for slice expression\".to_owned(),\n+            infer::Autoref(_) => \" for autoref\".to_owned(),\n+            infer::Coercion(_) => \" for automatic coercion\".to_owned(),\n             infer::LateBoundRegion(_, br) => {\n                 format!(\" for {}in function call\",\n                         bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))"}, {"sha": "9f87993279cfbb1710e1a382a3f36038e10f6502", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -36,7 +36,7 @@ impl<'f> Glb<'f> {\n \n impl<'f> Combine for Glb<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> ~str { ~\"glb\" }\n+    fn tag(&self) -> ~str { \"glb\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }\n "}, {"sha": "d42205f0035695e97fbea644db5d2b69e6e32eae", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -35,7 +35,7 @@ impl<'f> Lub<'f> {\n \n impl<'f> Combine for Lub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> ~str { ~\"lub\" }\n+    fn tag(&self) -> ~str { \"lub\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }\n "}, {"sha": "b2143b7d7988c920047250a0a5e68546d6b79733", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -248,10 +248,10 @@ pub enum fixup_err {\n \n pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n     match f {\n-      unresolved_int_ty(_) => ~\"unconstrained integral type\",\n-      unresolved_ty(_) => ~\"unconstrained type\",\n-      cyclic_ty(_) => ~\"cyclic type of infinite size\",\n-      unresolved_region(_) => ~\"unconstrained region\",\n+      unresolved_int_ty(_) => \"unconstrained integral type\".to_owned(),\n+      unresolved_ty(_) => \"unconstrained type\".to_owned(),\n+      cyclic_ty(_) => \"cyclic type of infinite size\".to_owned(),\n+      unresolved_region(_) => \"unconstrained region\".to_owned(),\n       region_var_bound_by_region_var(r1, r2) => {\n         format!(\"region var {:?} bound by another region var {:?}; this is \\\n               a bug in rustc\", r1, r2)\n@@ -728,7 +728,7 @@ impl<'a> InferCtxt<'a> {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = err.map_or(~\"\", |t_err| {\n+        let error_str = err.map_or(\"\".to_owned(), |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n         });\n         let resolved_expected = expected_ty.map(|e_ty| {"}, {"sha": "6d02094669cb99d6a619a045d5e5f5f739128bd4", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -35,7 +35,7 @@ impl<'f> Sub<'f> {\n \n impl<'f> Combine for Sub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> ~str { ~\"sub\" }\n+    fn tag(&self) -> ~str { \"sub\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }\n "}, {"sha": "a8ff7d4ee7f6ec0362034d0b3b276d0f4580c242", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -46,11 +46,11 @@ static EMPTY_SOURCE_STR: &str = \"/* Hello, world! */\";\n \n fn setup_env(test_name: &str, source_string: &str) -> Env {\n     let messages = @DVec();\n-    let matches = getopts(vec!(~\"-Z\", ~\"verbose\"), optgroups()).get();\n+    let matches = getopts(vec!(\"-Z\".to_owned(), \"verbose\".to_owned()), optgroups()).get();\n     let diag = diagnostic::collect(messages);\n-    let sessopts = build_session_options(~\"rustc\", &matches, diag);\n+    let sessopts = build_session_options(\"rustc\".to_owned(), &matches, diag);\n     let sess = build_session(sessopts, None, diag);\n-    let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n+    let cfg = build_configuration(sess, \"whatever\".to_owned(), str_input(\"\".to_owned()));\n     let dm = HashMap();\n     let amap = HashMap();\n     let freevars = HashMap();"}, {"sha": "fd3c9faa33e6f84894b50bd3d1ed517391864834", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -53,7 +53,7 @@ impl<V:InferStr> InferStr for Bound<V> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Some(ref v) => v.inf_str(cx),\n-          None => ~\"none\"\n+          None => \"none\".to_owned()\n         }\n     }\n }"}, {"sha": "c899ba45d616fb3b573e4617d84571e0dcab335c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -118,9 +118,9 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n         }\n       }\n \n-      ReStatic => { (~\"the static lifetime\", None) }\n+      ReStatic => { (\"the static lifetime\".to_owned(), None) }\n \n-      ReEmpty => { (~\"the empty lifetime\", None) }\n+      ReEmpty => { (\"the empty lifetime\".to_owned(), None) }\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n@@ -192,8 +192,8 @@ pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> ~s\n \n pub fn mutability_to_str(m: ast::Mutability) -> ~str {\n     match m {\n-        ast::MutMutable => ~\"mut \",\n-        ast::MutImmutable => ~\"\",\n+        ast::MutMutable => \"mut \".to_owned(),\n+        ast::MutImmutable => \"\".to_owned(),\n     }\n }\n \n@@ -203,7 +203,7 @@ pub fn mt_to_str(cx: &ctxt, m: &mt) -> ~str {\n \n pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n-        ty::UniqTraitStore => ~\"~\",\n+        ty::UniqTraitStore => \"~\".to_owned(),\n         ty::RegionTraitStore(r, m) => {\n             format!(\"{}{}\", region_ptr_to_str(cx, r), mutability_to_str(m))\n         }\n@@ -337,22 +337,22 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n \n     // pretty print the structural type representation:\n     return match ty::get(typ).sty {\n-      ty_nil => ~\"()\",\n-      ty_bot => ~\"!\",\n-      ty_bool => ~\"bool\",\n-      ty_char => ~\"char\",\n+      ty_nil => \"()\".to_owned(),\n+      ty_bot => \"!\".to_owned(),\n+      ty_bool => \"bool\".to_owned(),\n+      ty_char => \"char\".to_owned(),\n       ty_int(t) => ast_util::int_ty_to_str(t, None),\n       ty_uint(t) => ast_util::uint_ty_to_str(t, None),\n       ty_float(t) => ast_util::float_ty_to_str(t),\n-      ty_box(typ) => ~\"@\" + ty_to_str(cx, typ),\n-      ty_uniq(typ) => ~\"~\" + ty_to_str(cx, typ),\n-      ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n+      ty_box(typ) => \"@\".to_owned() + ty_to_str(cx, typ),\n+      ty_uniq(typ) => \"~\".to_owned() + ty_to_str(cx, typ),\n+      ty_ptr(ref tm) => \"*\".to_owned() + mt_to_str(cx, tm),\n       ty_rptr(r, ref tm) => {\n         region_ptr_to_str(cx, r) + mt_to_str(cx, tm)\n       }\n       ty_tup(ref elems) => {\n         let strs: Vec<~str> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n-        ~\"(\" + strs.connect(\",\") + \")\"\n+        \"(\".to_owned() + strs.connect(\",\") + \")\"\n       }\n       ty_closure(ref f) => {\n           closure_to_str(cx, *f)\n@@ -361,7 +361,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n           bare_fn_to_str(cx, f.fn_style, f.abi, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n-      ty_err => ~\"[type error]\",\n+      ty_err => \"[type error]\".to_owned(),\n       ty_param(param_ty {idx: id, def_id: did}) => {\n           let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n               Some(def) => token::get_ident(def.ident).get().to_str(),\n@@ -375,7 +375,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             format!(\"{}:{:?}\", ident, did)\n           }\n       }\n-      ty_self(..) => ~\"Self\",\n+      ty_self(..) => \"Self\".to_owned(),\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let base = ty::item_path_str(cx, did);\n         parameterized(cx,\n@@ -408,7 +408,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n       ty_str(vs) => {\n         match vs {\n             ty::VstoreFixed(n) => format!(\"str/{}\", n),\n-            ty::VstoreUniq => ~\"~str\",\n+            ty::VstoreUniq => \"~str\".to_owned(),\n             ty::VstoreSlice(r, ()) => format!(\"{}str\", region_ptr_to_str(cx, r))\n         }\n       }\n@@ -477,7 +477,7 @@ pub fn ty_to_short_str(cx: &ctxt, typ: t) -> ~str {\n impl<T:Repr> Repr for Option<T> {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n-            &None => ~\"None\",\n+            &None => \"None\".to_owned(),\n             &Some(ref t) => t.repr(tcx),\n         }\n     }\n@@ -494,7 +494,7 @@ impl<T:Repr,U:Repr> Repr for Result<T,U> {\n \n impl Repr for () {\n     fn repr(&self, _tcx: &ctxt) -> ~str {\n-        ~\"()\"\n+        \"()\".to_owned()\n     }\n }\n \n@@ -568,7 +568,7 @@ impl Repr for ty::substs {\n impl Repr for ty::RegionSubsts {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n-            ty::ErasedRegions => ~\"erased\",\n+            ty::ErasedRegions => \"erased\".to_owned(),\n             ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n         }\n     }\n@@ -579,11 +579,11 @@ impl Repr for ty::ParamBounds {\n         let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n-                ty::BoundStatic => ~\"'static\",\n-                ty::BoundSend => ~\"Send\",\n-                ty::BoundSized => ~\"Sized\",\n-                ty::BoundCopy => ~\"Pod\",\n-                ty::BoundShare => ~\"Share\",\n+                ty::BoundStatic => \"'static\".to_owned(),\n+                ty::BoundSend => \"Send\".to_owned(),\n+                ty::BoundSized => \"Sized\".to_owned(),\n+                ty::BoundCopy => \"Pod\".to_owned(),\n+                ty::BoundShare => \"Share\".to_owned(),\n             });\n         }\n         for t in self.trait_bounds.iter() {\n@@ -852,7 +852,7 @@ impl Repr for ty::Vstore {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::VstoreFixed(n) => format!(\"{}\", n),\n-            ty::VstoreUniq => ~\"~\",\n+            ty::VstoreUniq => \"~\".to_owned(),\n             ty::VstoreSlice(r, m) => {\n                 format!(\"{}{}\", region_ptr_to_str(tcx, r), mutability_to_str(m))\n             }\n@@ -864,7 +864,7 @@ impl Repr for ty::Vstore<()> {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::VstoreFixed(n) => format!(\"{}\", n),\n-            ty::VstoreUniq => ~\"~\",\n+            ty::VstoreUniq => \"~\".to_owned(),\n             ty::VstoreSlice(r, ()) => region_ptr_to_str(tcx, r)\n         }\n     }\n@@ -879,11 +879,11 @@ impl Repr for ty::BuiltinBound {\n impl UserString for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> ~str {\n         match *self {\n-            ty::BoundStatic => ~\"'static\",\n-            ty::BoundSend => ~\"Send\",\n-            ty::BoundSized => ~\"Sized\",\n-            ty::BoundCopy => ~\"Pod\",\n-            ty::BoundShare => ~\"Share\",\n+            ty::BoundStatic => \"'static\".to_owned(),\n+            ty::BoundSend => \"Send\".to_owned(),\n+            ty::BoundSized => \"Sized\".to_owned(),\n+            ty::BoundCopy => \"Pod\".to_owned(),\n+            ty::BoundShare => \"Share\".to_owned(),\n         }\n     }\n }\n@@ -909,7 +909,7 @@ impl<A:UserString> UserString for @A {\n \n impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: &ctxt) -> ~str {\n-        if self.is_empty() { ~\"<no-bounds>\" } else {\n+        if self.is_empty() { \"<no-bounds>\".to_owned() } else {\n             let mut result = Vec::new();\n             for bb in self.iter() {\n                 result.push(bb.user_string(tcx));"}, {"sha": "8de7cabde0ed71f0e4b0f77c19c1b54201d5ca98", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -576,16 +576,19 @@ mod tests {\n         // Examples from wikipedia\n         let wikipedia_tests = vec!(\n             Test {\n-                input: ~\"\",\n-                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n+                input: \"\".to_owned(),\n+                output_str: \"e3b0c44298fc1c149afb\\\n+            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_owned()\n             },\n             Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n+                input: \"The quick brown fox jumps over the lazy dog\".to_owned(),\n+                output_str: \"d7a8fbb307d7809469ca\\\n+            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_owned()\n             },\n             Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n+                input: \"The quick brown fox jumps over the lazy dog.\".to_owned(),\n+                output_str: \"ef537f25c895bfa78252\\\n+            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_owned()\n             });\n \n         let tests = wikipedia_tests;"}, {"sha": "fcd6629096c9940f22fd5c2891cacc87176f0b33", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -202,7 +202,7 @@ impl Clean<Item> for doctree::Module {\n         let name = if self.name.is_some() {\n             self.name.unwrap().clean()\n         } else {\n-            ~\"\"\n+            \"\".to_owned()\n         };\n         let mut foreigns = Vec::new();\n         for subforeigns in self.foreigns.clean().move_iter() {\n@@ -1170,7 +1170,7 @@ impl Clean<Item> for ast::ForeignItem {\n                 ForeignStaticItem(Static {\n                     type_: ty.clean(),\n                     mutability: if mutbl {Mutable} else {Immutable},\n-                    expr: ~\"\",\n+                    expr: \"\".to_owned(),\n                 })\n             }\n         };\n@@ -1197,7 +1197,7 @@ impl ToSource for syntax::codemap::Span {\n         let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n-            None    => ~\"\"\n+            None    => \"\".to_owned()\n         };\n         debug!(\"got snippet {}\", sn);\n         sn\n@@ -1208,14 +1208,14 @@ fn lit_to_str(lit: &ast::Lit) -> ~str {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_owned(),\n         ast::LitBinary(ref data) => format!(\"{:?}\", data.as_slice()),\n-        ast::LitChar(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n+        ast::LitChar(c) => \"'\".to_owned() + std::char::from_u32(c).unwrap().to_str() + \"'\",\n         ast::LitInt(i, _t) => i.to_str(),\n         ast::LitUint(u, _t) => u.to_str(),\n         ast::LitIntUnsuffixed(i) => i.to_str(),\n         ast::LitFloat(ref f, _t) => f.get().to_str(),\n         ast::LitFloatUnsuffixed(ref f) => f.get().to_str(),\n         ast::LitBool(b) => b.to_str(),\n-        ast::LitNil => ~\"\",\n+        ast::LitNil => \"\".to_owned(),\n     }\n }\n \n@@ -1224,19 +1224,19 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n     debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n     match p.node {\n-        PatWild => ~\"_\",\n-        PatWildMulti => ~\"..\",\n+        PatWild => \"_\".to_owned(),\n+        PatWildMulti => \"..\".to_owned(),\n         PatIdent(_, ref p, _) => path_to_str(p),\n         PatEnum(ref p, _) => path_to_str(p),\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n-        PatTup(..) => ~\"(tuple arg NYI)\",\n+        PatTup(..) => \"(tuple arg NYI)\".to_owned(),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");\n-            ~\"()\"\n+            \"()\".to_owned()\n         },\n         PatRange(..) => fail!(\"tried to get argument name from PatRange, \\\n                               which is not allowed in function arguments\"),"}, {"sha": "2819a70de92f47b72e1099d884d9b296743ce296", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -214,7 +214,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n             let cache = cache.unwrap();\n             let abs_root = root(&**cache, loc.as_slice());\n             let rel_root = match path.segments.get(0).name.as_slice() {\n-                \"self\" => Some(~\"./\"),\n+                \"self\" => Some(\"./\".to_owned()),\n                 _ => None,\n             };\n \n@@ -343,7 +343,7 @@ impl fmt::Show for clean::Type {\n                                {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n-                           ~\"\"\n+                           \"\".to_owned()\n                        } else {\n                            format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n@@ -379,13 +379,13 @@ impl fmt::Show for clean::Type {\n                                {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n-                           ~\"\"\n+                           \"\".to_owned()\n                        } else {\n                            format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n                        bounds = if decl.bounds.len() == 0 {\n-                           ~\"\"\n+                           \"\".to_owned()\n                        } else {\n                            let mut m = decl.bounds.iter().map(|s| s.to_str());\n                            \": \" + m.collect::<~[~str]>().connect(\" + \")\n@@ -397,8 +397,8 @@ impl fmt::Show for clean::Type {\n                 write!(f.buf, \"{}{}fn{}{}\",\n                        FnStyleSpace(decl.fn_style),\n                        match decl.abi {\n-                           ref x if \"\" == *x => ~\"\",\n-                           ref x if \"\\\"Rust\\\"\" == *x => ~\"\",\n+                           ref x if \"\" == *x => \"\".to_owned(),\n+                           ref x if \"\\\"Rust\\\"\" == *x => \"\".to_owned(),\n                            ref s => \" \" + *s + \" \",\n                        },\n                        decl.generics,\n@@ -432,7 +432,7 @@ impl fmt::Show for clean::Type {\n                        }, **t)\n             }\n             clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-                let lt = match *l { Some(ref l) => format!(\"{} \", *l), _ => ~\"\" };\n+                let lt = match *l { Some(ref l) => format!(\"{} \", *l), _ => \"\".to_owned() };\n                 write!(f.buf, \"&amp;{}{}{}\",\n                        lt,\n                        match mutability {"}, {"sha": "18b6298a3a03a54290d26f3406346fa2e327942a", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -27,7 +27,7 @@ use t = syntax::parse::token;\n /// Highlights some source code, returning the HTML output.\n pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n     let sess = parse::new_parse_sess();\n-    let fm = parse::string_to_filemap(&sess, src.to_owned(), ~\"<stdin>\");\n+    let fm = parse::string_to_filemap(&sess, src.to_owned(), \"<stdin>\".to_owned());\n \n     let mut out = io::MemWriter::new();\n     doit(&sess,"}, {"sha": "fa285185a61840f156a306b581f711bead9af929", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -173,7 +173,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Extract the text provided\n         let s = if text.is_null() {\n-            ~\"\"\n+            \"\".to_owned()\n         } else {\n             unsafe {\n                 str::raw::from_buf_len((*text).data, (*text).size as uint)"}, {"sha": "4ccba7a1f44270989031449b4481ca385317d085", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -214,8 +214,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         root_path: StrBuf::new(),\n         sidebar: HashMap::new(),\n         layout: layout::Layout {\n-            logo: ~\"\",\n-            favicon: ~\"\",\n+            logo: \"\".to_owned(),\n+            favicon: \"\".to_owned(),\n             krate: krate.name.clone(),\n         },\n         include_sources: true,\n@@ -309,7 +309,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         let mut w = MemWriter::new();\n         try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n \n-        let mut lastpath = ~\"\";\n+        let mut lastpath = \"\".to_owned();\n         for (i, item) in cache.search_index.iter().enumerate() {\n             // Omit the path if it is same to that of the prior item.\n             let path;"}, {"sha": "b741bf6966fb483927ba2b488524e77a9ca521c4", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -200,7 +200,7 @@ mod test {\n         // there's been no macro mistake.\n         macro_rules! push {\n             ($level: expr, $name: expr) => {\n-                assert_eq!(builder.push($level, $name.to_owned(), ~\"\"), $name);\n+                assert_eq!(builder.push($level, $name.to_owned(), \"\".to_owned()), $name);\n             }\n         }\n         push!(2, \"0.1\");\n@@ -240,7 +240,7 @@ mod test {\n                                 level: $level,\n                                 name: $name.to_owned(),\n                                 sec_number: $name.to_owned(),\n-                                id: ~\"\",\n+                                id: \"\".to_owned(),\n                                 children: toc!($($sub),*)\n                             }\n                             ),*"}, {"sha": "4fa4287f6f8119e820dc6d3554240162c269003a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -186,7 +186,7 @@ pub fn main_args(args: &[~str]) -> int {\n         (false, false) => {}\n     }\n \n-    if matches.opt_strs(\"passes\").as_slice() == &[~\"list\"] {\n+    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_owned()] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -309,7 +309,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     }\n \n     // Load all plugins/passes into a PluginManager\n-    let path = matches.opt_str(\"plugin-path\").unwrap_or(~\"/tmp/rustdoc/plugins\");\n+    let path = matches.opt_str(\"plugin-path\").unwrap_or(\"/tmp/rustdoc/plugins\".to_owned());\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n@@ -343,29 +343,29 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n-            match obj.pop(&~\"schema\") {\n+            match obj.pop(&\"schema\".to_owned()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n                         return Err(format!(\"sorry, but I only understand \\\n                                             version {}\", SCHEMA_VERSION))\n                     }\n                 }\n-                Some(..) => return Err(~\"malformed json\"),\n-                None => return Err(~\"expected a schema version\"),\n+                Some(..) => return Err(\"malformed json\".to_owned()),\n+                None => return Err(\"expected a schema version\".to_owned()),\n             }\n-            let krate = match obj.pop(&~\"crate\") {\n+            let krate = match obj.pop(&\"crate\".to_owned()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()\n                 }\n-                None => return Err(~\"malformed json\"),\n+                None => return Err(\"malformed json\".to_owned()),\n             };\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n             let plugin_output = Vec::new();\n             Ok((krate, plugin_output))\n         }\n-        Ok(..) => Err(~\"malformed json input: expected an object at the top\"),\n+        Ok(..) => Err(\"malformed json input: expected an object at the top\".to_owned()),\n     }\n }\n \n@@ -379,7 +379,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"plugins\": { output of plugins ... }\n     // }\n     let mut json = ~collections::TreeMap::new();\n-    json.insert(~\"schema\", json::String(SCHEMA_VERSION.to_owned()));\n+    json.insert(\"schema\".to_owned(), json::String(SCHEMA_VERSION.to_owned()));\n     let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n@@ -397,8 +397,8 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n         Err(e) => fail!(\"Rust generated JSON is invalid: {:?}\", e)\n     };\n \n-    json.insert(~\"crate\", crate_json);\n-    json.insert(~\"plugins\", json::Object(plugins_json));\n+    json.insert(\"crate\".to_owned(), crate_json);\n+    json.insert(\"plugins\".to_owned(), json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n     try!(json::Object(json).to_writer(&mut file));"}, {"sha": "142e13fd24e06cca25cd213a77770510f63c42a4", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -166,7 +166,7 @@ pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n \n     let mut collector = Collector::new(input.to_owned(), libs, true, true);\n     find_testable_code(input_str, &mut collector);\n-    test_args.unshift(~\"rustdoctest\");\n+    test_args.unshift(\"rustdoctest\".to_owned());\n     testing::test_main(test_args.as_slice(), collector.tests);\n     0\n }"}, {"sha": "ed71dc27d9d30e8c07453917019927e60fe8217c", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -219,7 +219,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n             for attr in i.attrs.iter() {\n                 match attr {\n                     &clean::NameValue(ref x, ref s) if \"doc\" == *x => avec.push(\n-                        clean::NameValue(~\"doc\", unindent(*s))),\n+                        clean::NameValue(\"doc\".to_owned(), unindent(*s))),\n                     x => avec.push(x.clone())\n                 }\n             }\n@@ -252,7 +252,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                 _ => true\n             }).map(|x| x.clone()).collect();\n             if docstr.len() > 0 {\n-                a.push(clean::NameValue(~\"doc\", docstr.into_owned()));\n+                a.push(clean::NameValue(\"doc\".to_owned(), docstr.into_owned()));\n             }\n             i.attrs = a;\n             self.fold_item_recur(i)\n@@ -329,25 +329,25 @@ mod unindent_tests {\n \n     #[test]\n     fn should_unindent() {\n-        let s = ~\"    line1\\n    line2\";\n+        let s = \"    line1\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, ~\"line1\\nline2\");\n+        assert_eq!(r, \"line1\\nline2\".to_owned());\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n-        let s = ~\"    line1\\n\\n    line2\";\n+        let s = \"    line1\\n\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, ~\"line1\\n\\nline2\");\n+        assert_eq!(r, \"line1\\n\\nline2\".to_owned());\n     }\n \n     #[test]\n     fn should_leave_multiple_indent_levels() {\n         // Line 2 is indented another level beyond the\n         // base indentation and should be preserved\n-        let s = ~\"    line1\\n\\n        line2\";\n+        let s = \"    line1\\n\\n        line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, ~\"line1\\n\\n    line2\");\n+        assert_eq!(r, \"line1\\n\\n    line2\".to_owned());\n     }\n \n     #[test]\n@@ -357,15 +357,15 @@ mod unindent_tests {\n         //\n         // #[doc = \"Start way over here\n         //          and continue here\"]\n-        let s = ~\"line1\\n    line2\";\n+        let s = \"line1\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, ~\"line1\\nline2\");\n+        assert_eq!(r, \"line1\\nline2\".to_owned());\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = ~\"line1\\n\\n    line2\";\n+        let s = \"line1\\n\\n    line2\".to_owned();\n         let r = unindent(s);\n-        assert_eq!(r, ~\"line1\\n\\n    line2\");\n+        assert_eq!(r, \"line1\\n\\n    line2\".to_owned());\n     }\n }"}, {"sha": "b05fdc826ff106fb7b3b2f25eed49b0350a0119f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -85,7 +85,7 @@ pub fn run(input: &str, cfgs: Vec<~str>,\n                                        false);\n     collector.fold_crate(krate);\n \n-    test_args.unshift(~\"rustdoctest\");\n+    test_args.unshift(\"rustdoctest\".to_owned());\n \n     testing::test_main(test_args.as_slice(),\n                        collector.tests.move_iter().collect());"}, {"sha": "f30c04b405b3f9ece9d23faa8e12e053dae434d2", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -388,7 +388,7 @@ impl fmt::Show for UvError {\n #[test]\n fn error_smoke_test() {\n     let err: UvError = UvError(uvll::EOF);\n-    assert_eq!(err.to_str(), ~\"EOF: end of file\");\n+    assert_eq!(err.to_str(), \"EOF: end of file\".to_owned());\n }\n \n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {"}, {"sha": "73454aaf13f7d56ada018ad97c06cb9b02d0443c", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -743,15 +743,15 @@ mod test {\n     fn connect_close_ip4() {\n         match TcpWatcher::connect(local_loop(), next_test_ip4()) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n+            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_owned()),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n         match TcpWatcher::connect(local_loop(), next_test_ip6()) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n+            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_owned()),\n         }\n     }\n "}, {"sha": "6ee684ff9bdc082bf142d167b2534d761bfa72a0", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -275,7 +275,7 @@ mod tests {\n     fn bind_err() {\n         match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), ~\"EACCES\"),\n+            Err(e) => assert_eq!(e.name(), \"EACCES\".to_owned()),\n         }\n     }\n "}, {"sha": "2f5c6309265c425f49a7c13b7fa7f3815a520b09", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -308,52 +308,52 @@ fn test_parse() {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(~\"alpha1\")),\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n         build: vec!(),\n     }));\n     assert!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(~\"alpha1\")),\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n         build: vec!()\n     }));\n     assert!(parse(\"1.2.3+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: vec!(),\n-        build: vec!(AlphaNumeric(~\"build5\"))\n+        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n     }));\n     assert!(parse(\"  1.2.3+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: vec!(),\n-        build: vec!(AlphaNumeric(~\"build5\"))\n+        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n     }));\n     assert!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(~\"alpha1\")),\n-        build: vec!(AlphaNumeric(~\"build5\"))\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n+        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n     }));\n     assert!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(AlphaNumeric(~\"alpha1\")),\n-        build: vec!(AlphaNumeric(~\"build5\"))\n+        pre: vec!(AlphaNumeric(\"alpha1\".to_owned())),\n+        build: vec!(AlphaNumeric(\"build5\".to_owned()))\n     }));\n     assert!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        pre: vec!(Numeric(1),AlphaNumeric(~\"alpha1\"),Numeric(9)),\n-        build: vec!(AlphaNumeric(~\"build5\"),\n+        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_owned()),Numeric(9)),\n+        build: vec!(AlphaNumeric(\"build5\".to_owned()),\n                  Numeric(7),\n-                 AlphaNumeric(~\"3aedf\"))\n+                 AlphaNumeric(\"3aedf\".to_owned()))\n     }));\n \n }\n@@ -377,18 +377,18 @@ fn test_ne() {\n \n #[test]\n fn test_show() {\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3\").unwrap()), ~\"1.2.3\");\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()), ~\"1.2.3-alpha1\");\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3+build.42\").unwrap()), ~\"1.2.3+build.42\");\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()), ~\"1.2.3-alpha1+42\");\n+    assert_eq!(format!(\"{}\", parse(\"1.2.3\").unwrap()), \"1.2.3\".to_owned());\n+    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()), \"1.2.3-alpha1\".to_owned());\n+    assert_eq!(format!(\"{}\", parse(\"1.2.3+build.42\").unwrap()), \"1.2.3+build.42\".to_owned());\n+    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()), \"1.2.3-alpha1+42\".to_owned());\n }\n \n #[test]\n fn test_to_str() {\n-    assert_eq!(parse(\"1.2.3\").unwrap().to_str(), ~\"1.2.3\");\n-    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_str(), ~\"1.2.3-alpha1\");\n-    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_str(), ~\"1.2.3+build.42\");\n-    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_str(), ~\"1.2.3-alpha1+42\");\n+    assert_eq!(parse(\"1.2.3\").unwrap().to_str(), \"1.2.3\".to_owned());\n+    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_str(), \"1.2.3-alpha1\".to_owned());\n+    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_str(), \"1.2.3+build.42\".to_owned());\n+    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_str(), \"1.2.3-alpha1+42\".to_owned());\n }\n \n #[test]"}, {"sha": "426894aeff7dd8eb914d28128edb291f2b5193d3", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -269,13 +269,13 @@ mod tests {\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".as_bytes().to_base64(STANDARD), ~\"\");\n-        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), ~\"Zg==\");\n-        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), ~\"Zm8=\");\n-        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), ~\"Zm9v\");\n-        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), ~\"Zm9vYg==\");\n-        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmFy\");\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_owned());\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_owned());\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_owned());\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_owned());\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_owned());\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_owned());\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_owned());\n     }\n \n     #[test]\n@@ -284,19 +284,19 @@ mod tests {\n                 .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n-                   ~\"Zm9v\\r\\nYmFy\");\n+                   \"Zm9v\\r\\nYmFy\".to_owned());\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n-        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_owned());\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_owned());\n     }\n \n     #[test]\n     fn test_to_base64_url_safe() {\n-        assert_eq!([251, 255].to_base64(URL_SAFE), ~\"-_8\");\n-        assert_eq!([251, 255].to_base64(STANDARD), ~\"+/8=\");\n+        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_owned());\n+        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_owned());\n     }\n \n     #[test]"}, {"sha": "cbed0656e4de285a8e141f11bdf43731060314e8", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -145,7 +145,7 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), ~\"666f6f626172\");\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_owned());\n     }\n \n     #[test]"}, {"sha": "93a5e2ec4c8b15a1a9be4050a924906c48c51c1b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 196, "deletions": 193, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -68,7 +68,7 @@ use serialize::{json, Encodable};\n  }\n \n fn main() {\n-    let to_encode_object = TestStruct{data_str:~\"example of string to encode\"};\n+    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_owned()};\n     let mut m = io::MemWriter::new();\n     {\n         let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n@@ -85,7 +85,7 @@ into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`\n \n ```rust\n use serialize::json;\n-let to_encode_object = ~\"example of string to encode\";\n+let to_encode_object = \"example of string to encode\".to_owned();\n let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n ```\n \n@@ -114,14 +114,14 @@ pub struct MyStruct  {\n impl ToJson for MyStruct {\n     fn to_json( &self ) -> json::Json {\n         let mut d = ~TreeMap::new();\n-        d.insert(~\"attr1\", self.attr1.to_json());\n-        d.insert(~\"attr2\", self.attr2.to_json());\n+        d.insert(\"attr1\".to_owned(), self.attr1.to_json());\n+        d.insert(\"attr2\".to_owned(), self.attr2.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:~\"test\"};\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_owned()};\n     let tjson: json::Json = test2.to_json();\n     let json_str: ~str = tjson.to_str();\n }\n@@ -141,7 +141,7 @@ pub struct MyStruct  {\n \n fn main() {\n     let json_str_to_decode: ~str =\n-            ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n+            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_owned();\n     let json_object = json::from_str(json_str_to_decode);\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n@@ -173,7 +173,7 @@ use serialize::{json, Encodable, Decodable};\n // It calls the generated `Encodable` impl.\n fn main() {\n     let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:~[2,3,4,5]};\n     let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n@@ -207,17 +207,18 @@ pub struct TestStruct1  {\n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n         let mut d = ~TreeMap::new();\n-        d.insert(~\"data_int\", self.data_int.to_json());\n-        d.insert(~\"data_str\", self.data_str.to_json());\n-        d.insert(~\"data_vector\", self.data_vector.to_json());\n+        d.insert(\"data_int\".to_owned(), self.data_int.to_json());\n+        d.insert(\"data_str\".to_owned(), self.data_str.to_json());\n+        d.insert(\"data_vector\".to_owned(), self.data_vector.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n     // Serialization using our impl of to_json\n \n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_owned(),\n+                                          data_vector:~[2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n     let json_str: ~str = tjson.to_str();\n \n@@ -931,7 +932,7 @@ impl<T: Iterator<char>> Parser<T> {\n             if self.eof() {\n                 Ok(value)\n             } else {\n-                self.error(~\"trailing characters\")\n+                self.error(\"trailing characters\".to_owned())\n             }\n           }\n           Err(e) => Err(e)\n@@ -968,7 +969,7 @@ impl<T : Iterator<char>> Parser<T> {\n     fn parse_value(&mut self) -> DecodeResult<Json> {\n         self.parse_whitespace();\n \n-        if self.eof() { return self.error(~\"EOF while parsing value\"); }\n+        if self.eof() { return self.error(\"EOF while parsing value\".to_owned()); }\n \n         match self.ch_or_null() {\n             'n' => self.parse_ident(\"ull\", Null),\n@@ -983,7 +984,7 @@ impl<T : Iterator<char>> Parser<T> {\n             },\n             '[' => self.parse_list(),\n             '{' => self.parse_object(),\n-            _ => self.error(~\"invalid syntax\"),\n+            _ => self.error(\"invalid syntax\".to_owned()),\n         }\n     }\n \n@@ -999,7 +1000,7 @@ impl<T : Iterator<char>> Parser<T> {\n             self.bump();\n             Ok(value)\n         } else {\n-            self.error(~\"invalid syntax\")\n+            self.error(\"invalid syntax\".to_owned())\n         }\n     }\n \n@@ -1042,7 +1043,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n                 // There can be only one leading '0'.\n                 match self.ch_or_null() {\n-                    '0' .. '9' => return self.error(~\"invalid number\"),\n+                    '0' .. '9' => return self.error(\"invalid number\".to_owned()),\n                     _ => ()\n                 }\n             },\n@@ -1059,7 +1060,7 @@ impl<T : Iterator<char>> Parser<T> {\n                     }\n                 }\n             }\n-            _ => return self.error(~\"invalid number\"),\n+            _ => return self.error(\"invalid number\".to_owned()),\n         }\n         Ok(res)\n     }\n@@ -1070,7 +1071,7 @@ impl<T : Iterator<char>> Parser<T> {\n         // Make sure a digit follows the decimal place.\n         match self.ch_or_null() {\n             '0' .. '9' => (),\n-             _ => return self.error(~\"invalid number\")\n+             _ => return self.error(\"invalid number\".to_owned())\n         }\n \n         let mut res = res;\n@@ -1106,7 +1107,7 @@ impl<T : Iterator<char>> Parser<T> {\n         // Make sure a digit follows the exponent place.\n         match self.ch_or_null() {\n             '0' .. '9' => (),\n-            _ => return self.error(~\"invalid number\")\n+            _ => return self.error(\"invalid number\".to_owned())\n         }\n         while !self.eof() {\n             match self.ch_or_null() {\n@@ -1144,7 +1145,7 @@ impl<T : Iterator<char>> Parser<T> {\n                 'e' | 'E' => n * 16_u16 + 14_u16,\n                 'f' | 'F' => n * 16_u16 + 15_u16,\n                 _ => return self.error(\n-                    ~\"invalid \\\\u escape (unrecognized hex)\")\n+                    \"invalid \\\\u escape (unrecognized hex)\".to_owned())\n             };\n \n             i += 1u;\n@@ -1153,7 +1154,7 @@ impl<T : Iterator<char>> Parser<T> {\n         // Error out if we didn't parse 4 digits.\n         if i != 4u {\n             return self.error(\n-                ~\"invalid \\\\u escape (not four digits)\");\n+                \"invalid \\\\u escape (not four digits)\".to_owned());\n         }\n \n         Ok(n)\n@@ -1166,7 +1167,7 @@ impl<T : Iterator<char>> Parser<T> {\n         loop {\n             self.bump();\n             if self.eof() {\n-                return self.error(~\"EOF while parsing string\");\n+                return self.error(\"EOF while parsing string\".to_owned());\n             }\n \n             if escape {\n@@ -1181,7 +1182,7 @@ impl<T : Iterator<char>> Parser<T> {\n                     't' => res.push_char('\\t'),\n                     'u' => match try!(self.decode_hex_escape()) {\n                         0xDC00 .. 0xDFFF => return self.error(\n-                                ~\"lone trailing surrogate in hex escape\"),\n+                                \"lone trailing surrogate in hex escape\".to_owned()),\n \n                         // Non-BMP characters are encoded as a sequence of\n                         // two hex escapes, representing UTF-16 surrogates.\n@@ -1191,14 +1192,14 @@ impl<T : Iterator<char>> Parser<T> {\n                             match (c1, c2) {\n                                 (Some('\\\\'), Some('u')) => (),\n                                 _ => return self.error(\n-                                    ~\"unexpected end of non-BMP hex escape\"),\n+                                    \"unexpected end of non-BMP hex escape\".to_owned()),\n                             }\n \n                             let buf = [n1, try!(self.decode_hex_escape())];\n                             match str::utf16_items(buf.as_slice()).next() {\n                                 Some(ScalarValue(c)) => res.push_char(c),\n                                 _ => return self.error(\n-                                    ~\"lone leading surrogate in hex escape\"),\n+                                    \"lone leading surrogate in hex escape\".to_owned()),\n                             }\n                         }\n \n@@ -1208,7 +1209,7 @@ impl<T : Iterator<char>> Parser<T> {\n                                 format!(\"invalid Unicode codepoint {:u}\", n)),\n                         },\n                     },\n-                    _ => return self.error(~\"invalid escape\"),\n+                    _ => return self.error(\"invalid escape\".to_owned()),\n                 }\n                 escape = false;\n             } else if self.ch_is('\\\\') {\n@@ -1245,7 +1246,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n             self.parse_whitespace();\n             if self.eof() {\n-                return self.error(~\"EOF while parsing list\");\n+                return self.error(\"EOF while parsing list\".to_owned());\n             }\n \n             if self.ch_is(',') {\n@@ -1254,7 +1255,7 @@ impl<T : Iterator<char>> Parser<T> {\n                 self.bump();\n                 return Ok(List(values.move_iter().collect()));\n             } else {\n-                return self.error(~\"expected `,` or `]`\")\n+                return self.error(\"expected `,` or `]`\".to_owned())\n             }\n         };\n     }\n@@ -1274,7 +1275,7 @@ impl<T : Iterator<char>> Parser<T> {\n             self.parse_whitespace();\n \n             if !self.ch_is('\"') {\n-                return self.error(~\"key must be a string\");\n+                return self.error(\"key must be a string\".to_owned());\n             }\n \n             let key = match self.parse_str() {\n@@ -1286,7 +1287,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n             if !self.ch_is(':') {\n                 if self.eof() { break; }\n-                return self.error(~\"expected `:`\");\n+                return self.error(\"expected `:`\".to_owned());\n             }\n             self.bump();\n \n@@ -1301,12 +1302,12 @@ impl<T : Iterator<char>> Parser<T> {\n                 '}' => { self.bump(); return Ok(Object(values)); },\n                 _ => {\n                     if self.eof() { break; }\n-                    return self.error(~\"expected `,` or `}`\");\n+                    return self.error(\"expected `,` or `}`\".to_owned());\n                 }\n             }\n         }\n \n-        return self.error(~\"EOF while parsing object\");\n+        return self.error(\"EOF while parsing object\".to_owned());\n     }\n }\n \n@@ -1318,7 +1319,7 @@ pub fn from_reader(rdr: &mut io::Reader) -> DecodeResult<Json> {\n     };\n     let s = match str::from_utf8(contents.as_slice()) {\n         Some(s) => s.to_owned(),\n-        None => return Err(ParseError(~\"contents not utf-8\", 0, 0))\n+        None => return Err(ParseError(\"contents not utf-8\".to_owned(), 0, 0))\n     };\n     let mut parser = Parser::new(s.chars());\n     parser.parse()\n@@ -1354,7 +1355,7 @@ macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n             Null => Ok(()),\n-            other => Err(ExpectedError(~\"Null\", format!(\"{}\", other)))\n+            other => Err(ExpectedError(\"Null\".to_owned(), format!(\"{}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n@@ -1399,7 +1400,7 @@ impl ::Decoder<Error> for Decoder {\n                 // is going to have a string here, as per JSON spec..\n                 Ok(FromStr::from_str(s).unwrap())\n             },\n-            value => Err(ExpectedError(~\"Number\", format!(\"{}\", value)))\n+            value => Err(ExpectedError(\"Number\".to_owned(), format!(\"{}\", value)))\n         }\n     }\n \n@@ -1415,7 +1416,7 @@ impl ::Decoder<Error> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(~\"single character string\", format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_owned(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<~str> {\n@@ -1438,23 +1439,23 @@ impl ::Decoder<Error> for Decoder {\n         let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n-                let n = match o.pop(&~\"variant\") {\n+                let n = match o.pop(&\"variant\".to_owned()) {\n                     Some(String(s)) => s,\n-                    Some(val) => return Err(ExpectedError(~\"String\", format!(\"{}\", val))),\n-                    None => return Err(MissingFieldError(~\"variant\"))\n+                    Some(val) => return Err(ExpectedError(\"String\".to_owned(), format!(\"{}\", val))),\n+                    None => return Err(MissingFieldError(\"variant\".to_owned()))\n                 };\n-                match o.pop(&~\"fields\") {\n+                match o.pop(&\"fields\".to_owned()) {\n                     Some(List(l)) => {\n                         for field in l.move_rev_iter() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    Some(val) => return Err(ExpectedError(~\"List\", format!(\"{}\", val))),\n-                    None => return Err(MissingFieldError(~\"fields\"))\n+                    Some(val) => return Err(ExpectedError(\"List\".to_owned(), format!(\"{}\", val))),\n+                    None => return Err(MissingFieldError(\"fields\".to_owned()))\n                 }\n                 n\n             }\n-            json => return Err(ExpectedError(~\"String or Object\", format!(\"{}\", json)))\n+            json => return Err(ExpectedError(\"String or Object\".to_owned(), format!(\"{}\", json)))\n         };\n         let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n@@ -1820,115 +1821,115 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_str(), ~\"null\");\n-        assert_eq!(Null.to_pretty_str(), ~\"null\");\n+        assert_eq!(Null.to_str(), \"null\".to_owned());\n+        assert_eq!(Null.to_pretty_str(), \"null\".to_owned());\n     }\n \n \n     #[test]\n     fn test_write_number() {\n-        assert_eq!(Number(3.0).to_str(), ~\"3\");\n-        assert_eq!(Number(3.0).to_pretty_str(), ~\"3\");\n+        assert_eq!(Number(3.0).to_str(), \"3\".to_owned());\n+        assert_eq!(Number(3.0).to_pretty_str(), \"3\".to_owned());\n \n-        assert_eq!(Number(3.1).to_str(), ~\"3.1\");\n-        assert_eq!(Number(3.1).to_pretty_str(), ~\"3.1\");\n+        assert_eq!(Number(3.1).to_str(), \"3.1\".to_owned());\n+        assert_eq!(Number(3.1).to_pretty_str(), \"3.1\".to_owned());\n \n-        assert_eq!(Number(-1.5).to_str(), ~\"-1.5\");\n-        assert_eq!(Number(-1.5).to_pretty_str(), ~\"-1.5\");\n+        assert_eq!(Number(-1.5).to_str(), \"-1.5\".to_owned());\n+        assert_eq!(Number(-1.5).to_pretty_str(), \"-1.5\".to_owned());\n \n-        assert_eq!(Number(0.5).to_str(), ~\"0.5\");\n-        assert_eq!(Number(0.5).to_pretty_str(), ~\"0.5\");\n+        assert_eq!(Number(0.5).to_str(), \"0.5\".to_owned());\n+        assert_eq!(Number(0.5).to_pretty_str(), \"0.5\".to_owned());\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(~\"\").to_str(), ~\"\\\"\\\"\");\n-        assert_eq!(String(~\"\").to_pretty_str(), ~\"\\\"\\\"\");\n+        assert_eq!(String(\"\".to_owned()).to_str(), \"\\\"\\\"\".to_owned());\n+        assert_eq!(String(\"\".to_owned()).to_pretty_str(), \"\\\"\\\"\".to_owned());\n \n-        assert_eq!(String(~\"foo\").to_str(), ~\"\\\"foo\\\"\");\n-        assert_eq!(String(~\"foo\").to_pretty_str(), ~\"\\\"foo\\\"\");\n+        assert_eq!(String(\"foo\".to_owned()).to_str(), \"\\\"foo\\\"\".to_owned());\n+        assert_eq!(String(\"foo\".to_owned()).to_pretty_str(), \"\\\"foo\\\"\".to_owned());\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_str(), ~\"true\");\n-        assert_eq!(Boolean(true).to_pretty_str(), ~\"true\");\n+        assert_eq!(Boolean(true).to_str(), \"true\".to_owned());\n+        assert_eq!(Boolean(true).to_pretty_str(), \"true\".to_owned());\n \n-        assert_eq!(Boolean(false).to_str(), ~\"false\");\n-        assert_eq!(Boolean(false).to_pretty_str(), ~\"false\");\n+        assert_eq!(Boolean(false).to_str(), \"false\".to_owned());\n+        assert_eq!(Boolean(false).to_pretty_str(), \"false\".to_owned());\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(~[]).to_str(), ~\"[]\");\n-        assert_eq!(List(~[]).to_pretty_str(), ~\"[]\");\n+        assert_eq!(List(~[]).to_str(), \"[]\".to_owned());\n+        assert_eq!(List(~[]).to_pretty_str(), \"[]\".to_owned());\n \n-        assert_eq!(List(~[Boolean(true)]).to_str(), ~\"[true]\");\n+        assert_eq!(List(~[Boolean(true)]).to_str(), \"[true]\".to_owned());\n         assert_eq!(\n             List(~[Boolean(true)]).to_pretty_str(),\n-            ~\"\\\n+            \"\\\n             [\\n  \\\n                 true\\n\\\n-            ]\"\n+            ]\".to_owned()\n         );\n \n         let long_test_list = List(~[\n             Boolean(false),\n             Null,\n-            List(~[String(~\"foo\\nbar\"), Number(3.5)])]);\n+            List(~[String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n \n         assert_eq!(long_test_list.to_str(),\n-            ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n+            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_owned());\n         assert_eq!(\n             long_test_list.to_pretty_str(),\n-            ~\"\\\n+            \"\\\n             [\\n  \\\n                 false,\\n  \\\n                 null,\\n  \\\n                 [\\n    \\\n                     \\\"foo\\\\nbar\\\",\\n    \\\n                     3.5\\n  \\\n                 ]\\n\\\n-            ]\"\n+            ]\".to_owned()\n         );\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object([]).to_str(), ~\"{}\");\n-        assert_eq!(mk_object([]).to_pretty_str(), ~\"{}\");\n+        assert_eq!(mk_object([]).to_str(), \"{}\".to_owned());\n+        assert_eq!(mk_object([]).to_pretty_str(), \"{}\".to_owned());\n \n         assert_eq!(\n-            mk_object([(~\"a\", Boolean(true))]).to_str(),\n-            ~\"{\\\"a\\\":true}\"\n+            mk_object([(\"a\".to_owned(), Boolean(true))]).to_str(),\n+            \"{\\\"a\\\":true}\".to_owned()\n         );\n         assert_eq!(\n-            mk_object([(~\"a\", Boolean(true))]).to_pretty_str(),\n-            ~\"\\\n+            mk_object([(\"a\".to_owned(), Boolean(true))]).to_pretty_str(),\n+            \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n-            }\"\n+            }\".to_owned()\n         );\n \n         let complex_obj = mk_object([\n-                (~\"b\", List(~[\n-                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n-                    mk_object([(~\"d\", String(~\"\"))])\n+                (\"b\".to_owned(), List(~[\n+                    mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n+                    mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n                 ]))\n             ]);\n \n         assert_eq!(\n             complex_obj.to_str(),\n-            ~\"{\\\n+            \"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n                     {\\\"d\\\":\\\"\\\"}\\\n                 ]\\\n-            }\"\n+            }\".to_owned()\n         );\n         assert_eq!(\n             complex_obj.to_pretty_str(),\n-            ~\"\\\n+            \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n                     {\\n      \\\n@@ -1938,14 +1939,14 @@ mod tests {\n                         \\\"d\\\": \\\"\\\"\\n    \\\n                     }\\n  \\\n                 ]\\n\\\n-            }\"\n+            }\".to_owned()\n         );\n \n         let a = mk_object([\n-            (~\"a\", Boolean(true)),\n-            (~\"b\", List(~[\n-                mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n-                mk_object([(~\"d\", String(~\"\"))])\n+            (\"a\".to_owned(), Boolean(true)),\n+            (\"b\".to_owned(), List(~[\n+                mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n+                mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n             ]))\n         ]);\n \n@@ -1972,53 +1973,53 @@ mod tests {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            ~\"\\\"Dog\\\"\"\n+            \"\\\"Dog\\\"\".to_owned()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            ~\"\\\"Dog\\\"\"\n+            \"\\\"Dog\\\"\".to_owned()\n         );\n \n-        let animal = Frog(~\"Henry\", 349);\n+        let animal = Frog(\"Henry\".to_owned(), 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n+            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_owned()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            ~\"\\\n+            \"\\\n             [\\n  \\\n                 \\\"Frog\\\",\\n  \\\n                 \\\"Henry\\\",\\n  \\\n                 349\\n\\\n-            ]\"\n+            ]\".to_owned()\n         );\n     }\n \n     #[test]\n     fn test_write_some() {\n-        let value = Some(~\"jodhpurs\");\n+        let value = Some(\"jodhpurs\".to_owned());\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_owned());\n \n-        let value = Some(~\"jodhpurs\");\n+        let value = Some(\"jodhpurs\".to_owned());\n         let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_owned());\n     }\n \n     #[test]\n@@ -2028,47 +2029,47 @@ mod tests {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, ~\"null\");\n+        assert_eq!(s, \"null\".to_owned());\n \n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, ~\"null\");\n+        assert_eq!(s, \"null\".to_owned());\n     }\n \n     #[test]\n     fn test_trailing_characters() {\n         assert_eq!(from_str(\"nulla\"),\n-            Err(ParseError(~\"trailing characters\", 1u, 5u)));\n+            Err(ParseError(\"trailing characters\".to_owned(), 1u, 5u)));\n         assert_eq!(from_str(\"truea\"),\n-            Err(ParseError(~\"trailing characters\", 1u, 5u)));\n+            Err(ParseError(\"trailing characters\".to_owned(), 1u, 5u)));\n         assert_eq!(from_str(\"falsea\"),\n-            Err(ParseError(~\"trailing characters\", 1u, 6u)));\n+            Err(ParseError(\"trailing characters\".to_owned(), 1u, 6u)));\n         assert_eq!(from_str(\"1a\"),\n-            Err(ParseError(~\"trailing characters\", 1u, 2u)));\n+            Err(ParseError(\"trailing characters\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"[]a\"),\n-            Err(ParseError(~\"trailing characters\", 1u, 3u)));\n+            Err(ParseError(\"trailing characters\".to_owned(), 1u, 3u)));\n         assert_eq!(from_str(\"{}a\"),\n-            Err(ParseError(~\"trailing characters\", 1u, 3u)));\n+            Err(ParseError(\"trailing characters\".to_owned(), 1u, 3u)));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert_eq!(from_str(\"n\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 2u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"nul\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 4u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 4u)));\n \n         assert_eq!(from_str(\"t\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 2u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"truz\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 4u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 4u)));\n \n         assert_eq!(from_str(\"f\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 2u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"faz\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 3u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 3u)));\n \n         assert_eq!(from_str(\"null\"), Ok(Null));\n         assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n@@ -2096,20 +2097,20 @@ mod tests {\n     #[test]\n     fn test_read_number() {\n         assert_eq!(from_str(\"+\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 1u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 1u)));\n         assert_eq!(from_str(\".\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 1u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 1u)));\n \n         assert_eq!(from_str(\"-\"),\n-            Err(ParseError(~\"invalid number\", 1u, 2u)));\n+            Err(ParseError(\"invalid number\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"00\"),\n-            Err(ParseError(~\"invalid number\", 1u, 2u)));\n+            Err(ParseError(\"invalid number\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"1.\"),\n-            Err(ParseError(~\"invalid number\", 1u, 3u)));\n+            Err(ParseError(\"invalid number\".to_owned(), 1u, 3u)));\n         assert_eq!(from_str(\"1e\"),\n-            Err(ParseError(~\"invalid number\", 1u, 3u)));\n+            Err(ParseError(\"invalid number\".to_owned(), 1u, 3u)));\n         assert_eq!(from_str(\"1e+\"),\n-            Err(ParseError(~\"invalid number\", 1u, 4u)));\n+            Err(ParseError(\"invalid number\".to_owned(), 1u, 4u)));\n \n         assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n         assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n@@ -2155,24 +2156,24 @@ mod tests {\n     #[test]\n     fn test_read_str() {\n         assert_eq!(from_str(\"\\\"\"),\n-            Err(ParseError(~\"EOF while parsing string\", 1u, 2u)));\n+            Err(ParseError(\"EOF while parsing string\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"\\\"lol\"),\n-            Err(ParseError(~\"EOF while parsing string\", 1u, 5u)));\n-\n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n+            Err(ParseError(\"EOF while parsing string\".to_owned(), 1u, 5u)));\n+\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_owned())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_owned())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_owned())));\n \n         // Non-BMP escapes.  The exact error messages and positions are kind of\n         // arbitrary.\n-        assert_eq!(from_str(\"\\\"\\\\ud83d\\\\udca9\\\"\"), Ok(String(~\"\\U0001F4A9\")));\n+        assert_eq!(from_str(\"\\\"\\\\ud83d\\\\udca9\\\"\"), Ok(String(\"\\U0001F4A9\".to_owned())));\n         assert!(from_str(\"\\\"\\\\ud83d\\\"\").is_err());\n         assert!(from_str(\"\\\"\\\\udca9\\\"\").is_err());\n         assert!(from_str(\"\\\"\\\\ud83d\\\\ud83d\\\"\").is_err());\n@@ -2185,53 +2186,53 @@ mod tests {\n     fn test_decode_str() {\n         let mut decoder = Decoder::new(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\");\n+        assert_eq!(v, \"\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"foo\");\n+        assert_eq!(v, \"foo\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\\"\");\n+        assert_eq!(v, \"\\\"\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\x08\");\n+        assert_eq!(v, \"\\x08\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\n\");\n+        assert_eq!(v, \"\\n\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\r\");\n+        assert_eq!(v, \"\\r\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\t\");\n+        assert_eq!(v, \"\\t\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\u12ab\");\n+        assert_eq!(v, \"\\u12ab\".to_owned());\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~\"\\uAB12\");\n+        assert_eq!(v, \"\\uAB12\".to_owned());\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert_eq!(from_str(\"[\"),\n-            Err(ParseError(~\"EOF while parsing value\", 1u, 2u)));\n+            Err(ParseError(\"EOF while parsing value\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"[1\"),\n-            Err(ParseError(~\"EOF while parsing list\", 1u, 3u)));\n+            Err(ParseError(\"EOF while parsing list\".to_owned(), 1u, 3u)));\n         assert_eq!(from_str(\"[1,\"),\n-            Err(ParseError(~\"EOF while parsing value\", 1u, 4u)));\n+            Err(ParseError(\"EOF while parsing value\".to_owned(), 1u, 4u)));\n         assert_eq!(from_str(\"[1,]\"),\n-            Err(ParseError(~\"invalid syntax\", 1u, 4u)));\n+            Err(ParseError(\"invalid syntax\".to_owned(), 1u, 4u)));\n         assert_eq!(from_str(\"[6 7]\"),\n-            Err(ParseError(~\"expected `,` or `]`\", 1u, 4u)));\n+            Err(ParseError(\"expected `,` or `]`\".to_owned(), 1u, 4u)));\n \n         assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n         assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n@@ -2276,50 +2277,50 @@ mod tests {\n     #[test]\n     fn test_read_object() {\n         assert_eq!(from_str(\"{\"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 2u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"{ \"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 3u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 3u)));\n         assert_eq!(from_str(\"{1\"),\n-            Err(ParseError(~\"key must be a string\", 1u, 2u)));\n+            Err(ParseError(\"key must be a string\".to_owned(), 1u, 2u)));\n         assert_eq!(from_str(\"{ \\\"a\\\"\"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 6u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 6u)));\n         assert_eq!(from_str(\"{\\\"a\\\"\"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 5u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 5u)));\n         assert_eq!(from_str(\"{\\\"a\\\" \"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 6u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 6u)));\n \n         assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n-            Err(ParseError(~\"expected `:`\", 1u, 6u)));\n+            Err(ParseError(\"expected `:`\".to_owned(), 1u, 6u)));\n         assert_eq!(from_str(\"{\\\"a\\\":\"),\n-            Err(ParseError(~\"EOF while parsing value\", 1u, 6u)));\n+            Err(ParseError(\"EOF while parsing value\".to_owned(), 1u, 6u)));\n         assert_eq!(from_str(\"{\\\"a\\\":1\"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 7u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 7u)));\n         assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n-            Err(ParseError(~\"expected `,` or `}`\", 1u, 8u)));\n+            Err(ParseError(\"expected `,` or `}`\".to_owned(), 1u, 8u)));\n         assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n-            Err(ParseError(~\"EOF while parsing object\", 1u, 8u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 1u, 8u)));\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(~\"a\", Number(3.0))]));\n+                  mk_object([(\"a\".to_owned(), Number(3.0))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object([\n-                      (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]));\n+                      (\"a\".to_owned(), Null),\n+                      (\"b\".to_owned(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object([\n-                      (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]));\n+                      (\"a\".to_owned(), Null),\n+                      (\"b\".to_owned(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (~\"a\", Number(1.0)),\n-                      (~\"b\", List(~[Boolean(true)]))\n+                      (\"a\".to_owned(), Number(1.0)),\n+                      (\"b\".to_owned(), List(~[Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n-                      ~\"{\" +\n+                      \"{\".to_owned() +\n                           \"\\\"a\\\": 1.0, \" +\n                           \"\\\"b\\\": [\" +\n                               \"true,\" +\n@@ -2328,31 +2329,31 @@ mod tests {\n                           \"]\" +\n                       \"}\").unwrap(),\n                   mk_object([\n-                      (~\"a\", Number(1.0)),\n-                      (~\"b\", List(~[\n+                      (\"a\".to_owned(), Number(1.0)),\n+                      (\"b\".to_owned(), List(~[\n                           Boolean(true),\n-                          String(~\"foo\\nbar\"),\n+                          String(\"foo\\nbar\".to_owned()),\n                           mk_object([\n-                              (~\"c\", mk_object([(~\"d\", Null)]))\n+                              (\"c\".to_owned(), mk_object([(\"d\".to_owned(), Null)]))\n                           ])\n                       ]))\n                   ]));\n     }\n \n     #[test]\n     fn test_decode_struct() {\n-        let s = ~\"{\n+        let s = \"{\n             \\\"inner\\\": [\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n-        }\";\n+        }\".to_owned();\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(\n             v,\n             Outer {\n                 inner: ~[\n-                    Inner { a: (), b: 2, c: ~[~\"abc\", ~\"xyz\"] }\n+                    Inner { a: (), b: 2, c: ~[\"abc\".to_owned(), \"xyz\".to_owned()] }\n                 ]\n             }\n         );\n@@ -2366,7 +2367,7 @@ mod tests {\n \n         let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Some(~\"jodhpurs\"));\n+        assert_eq!(value, Some(\"jodhpurs\".to_owned()));\n     }\n \n     #[test]\n@@ -2378,23 +2379,24 @@ mod tests {\n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Frog(~\"Henry\", 349));\n+        assert_eq!(value, Frog(\"Henry\".to_owned(), 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n-        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n+        let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n+                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\".to_owned();\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder).unwrap();\n \n-        assert_eq!(map.pop(&~\"a\"), Some(Dog));\n-        assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));\n+        assert_eq!(map.pop(&\"a\".to_owned()), Some(Dog));\n+        assert_eq!(map.pop(&\"b\".to_owned()), Some(Frog(\"Henry\".to_owned(), 349)));\n     }\n \n     #[test]\n     fn test_multiline_errors() {\n         assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(ParseError(~\"EOF while parsing object\", 3u, 8u)));\n+            Err(ParseError(\"EOF while parsing object\".to_owned(), 3u, 8u)));\n     }\n \n     #[deriving(Decodable)]\n@@ -2427,50 +2429,51 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(~\"Object\", ~\"[]\"));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_owned(), \"[]\".to_owned()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(~\"Number\", ~\"true\"));\n+                                  ExpectedError(\"Number\".to_owned(), \"true\".to_owned()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(~\"Boolean\", ~\"[]\"));\n+                                  ExpectedError(\"Boolean\".to_owned(), \"[]\".to_owned()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(~\"String\", ~\"{}\"));\n+                                  ExpectedError(\"String\".to_owned(), \"{}\".to_owned()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(~\"List\", ~\"null\"));\n+                                  ExpectedError(\"List\".to_owned(), \"null\".to_owned()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(~\"w\"));\n+                                  MissingFieldError(\"w\".to_owned()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(~\"variant\"));\n+                                MissingFieldError(\"variant\".to_owned()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(~\"String\", ~\"1\"));\n+                                ExpectedError(\"String\".to_owned(), \"1\".to_owned()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(~\"fields\"));\n+                                MissingFieldError(\"fields\".to_owned()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(~\"List\", ~\"null\"));\n+                                ExpectedError(\"List\".to_owned(), \"null\".to_owned()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(~\"C\"));\n+                                UnknownVariantError(\"C\".to_owned()));\n     }\n \n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&~\"dog\");\n+        let found_str = json_value.find(&\"dog\".to_owned());\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == &\"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&~\"dog\", &~\"cat\", &~\"mouse\"]);\n+        let found_str = json_value.find_path(&[&\"dog\".to_owned(),\n+                                             &\"cat\".to_owned(), &\"mouse\".to_owned()]);\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == &\"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&~\"mouse\").and_then(|j| j.as_string());\n+        let found_str = json_value.search(&\"mouse\".to_owned()).and_then(|j| j.as_string());\n         assert!(found_str.is_some());\n         assert!(found_str.unwrap() == &\"cheese\");\n     }"}, {"sha": "5a6ecdb1f21a7b8bc6de16b5708566d6c403ef5f", "filename": "src/libstd/any.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -164,6 +164,7 @@ impl<'a> fmt::Show for &'a Any {\n mod tests {\n     use prelude::*;\n     use super::*;\n+    use str::StrSlice;\n \n     #[deriving(Eq, Show)]\n     struct Test;\n@@ -290,13 +291,13 @@ mod tests {\n     fn test_show() {\n         let a = ~8u as ~Any;\n         let b = ~Test as ~Any;\n-        assert_eq!(format!(\"{}\", a), ~\"~Any\");\n-        assert_eq!(format!(\"{}\", b), ~\"~Any\");\n+        assert_eq!(format!(\"{}\", a), \"~Any\".to_owned());\n+        assert_eq!(format!(\"{}\", b), \"~Any\".to_owned());\n \n         let a = &8u as &Any;\n         let b = &Test as &Any;\n-        assert_eq!(format!(\"{}\", a), ~\"&Any\");\n-        assert_eq!(format!(\"{}\", b), ~\"&Any\");\n+        assert_eq!(format!(\"{}\", a), \"&Any\".to_owned());\n+        assert_eq!(format!(\"{}\", b), \"&Any\".to_owned());\n     }\n }\n "}, {"sha": "6ffe0cfe57d56f3f409103e06a6b97c556d06e87", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -487,6 +487,7 @@ mod tests {\n     use str::from_char;\n     use char::from_u32;\n     use vec::Vec;\n+    use str::StrSlice;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n@@ -536,14 +537,14 @@ mod tests {\n         // FIXME: #5475 borrowchk error, owned vectors do not live long enough\n         // if chained-from directly\n         let v = ~[40u8, 32u8, 59u8]; assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n-        let v = ~\"( ;\";              assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+        let v = \"( ;\".to_owned();              assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n \n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), ~\"abcdef&?#\");\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), ~\"ABCDEF&?#\");\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_owned());\n \n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), ~\"\");\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), ~\"ymca\");\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), ~\"ABCDEFXYZ:.;\");\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_owned());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_owned());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_owned());\n \n         assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n \n@@ -555,18 +556,19 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_lower()).into_str(), ~\"abcdef&?#\");\n-        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_upper()).into_str(), ~\"ABCDEF&?#\");\n-\n-        assert_eq!(Vec::from_slice(\"\".to_ascii().to_lower()).into_str(), ~\"\");\n-        assert_eq!(Vec::from_slice(\"YMCA\".to_ascii().to_lower()).into_str(), ~\"ymca\");\n+        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_lower()).into_str(),\n+                   \"abcdef&?#\".to_owned());\n+        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_upper()).into_str(),\n+                   \"ABCDEF&?#\".to_owned());\n+        assert_eq!(Vec::from_slice(\"\".to_ascii().to_lower()).into_str(), \"\".to_owned());\n+        assert_eq!(Vec::from_slice(\"YMCA\".to_ascii().to_lower()).into_str(), \"ymca\".to_owned());\n         assert_eq!(Vec::from_slice(\"abcDEFxyz:.;\".to_ascii().to_upper()).into_str(),\n-                   ~\"ABCDEFXYZ:.;\");\n+                   \"ABCDEFXYZ:.;\".to_owned());\n     }\n \n     #[test]\n     fn test_owned_ascii_vec() {\n-        assert_eq!((~\"( ;\").into_ascii(), v2ascii!(~[40, 32, 59]));\n+        assert_eq!((\"( ;\".to_owned()).into_ascii(), v2ascii!(~[40, 32, 59]));\n         assert_eq!((~[40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n     }\n \n@@ -578,8 +580,8 @@ mod tests {\n \n     #[test]\n     fn test_ascii_into_str() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), ~\"( ;\");\n-        assert_eq!(vec2ascii!(40, 32, 59).into_str(), ~\"( ;\");\n+        assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), \"( ;\".to_owned());\n+        assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_owned());\n     }\n \n     #[test]\n@@ -626,14 +628,14 @@ mod tests {\n         assert_eq!((~[40u8, 32u8, 59u8]).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n         assert_eq!((~[127u8, 128u8, 255u8]).into_ascii_opt(), None);\n \n-        assert_eq!((~\"( ;\").into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n-        assert_eq!((~\"zo\u00e4\u534e\").into_ascii_opt(), None);\n+        assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n+        assert_eq!((\"zo\u00e4\u534e\".to_owned()).into_ascii_opt(), None);\n     }\n \n     #[test]\n     fn test_to_ascii_upper() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), ~\"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), ~\"H\u0131\u212a\u00df\");\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\".to_owned());\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\".to_owned());\n \n         let mut i = 0;\n         while i <= 500 {\n@@ -647,9 +649,9 @@ mod tests {\n \n     #[test]\n     fn test_to_ascii_lower() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), ~\"url()url()url()\u00dcrl\");\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\".to_owned());\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), ~\"h\u0130\u212a\u00df\");\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\".to_owned());\n \n         let mut i = 0;\n         while i <= 500 {\n@@ -663,8 +665,9 @@ mod tests {\n \n     #[test]\n     fn test_into_ascii_upper() {\n-        assert_eq!((~\"url()URL()uRl()\u00fcrl\").into_ascii_upper(), ~\"URL()URL()URL()\u00fcRL\");\n-        assert_eq!((~\"h\u0131\u212a\u00df\").into_ascii_upper(), ~\"H\u0131\u212a\u00df\");\n+        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_owned()).into_ascii_upper(),\n+                   \"URL()URL()URL()\u00fcRL\".to_owned());\n+        assert_eq!((\"h\u0131\u212a\u00df\".to_owned()).into_ascii_upper(), \"H\u0131\u212a\u00df\".to_owned());\n \n         let mut i = 0;\n         while i <= 500 {\n@@ -678,9 +681,10 @@ mod tests {\n \n     #[test]\n     fn test_into_ascii_lower() {\n-        assert_eq!((~\"url()URL()uRl()\u00dcrl\").into_ascii_lower(), ~\"url()url()url()\u00dcrl\");\n+        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_owned()).into_ascii_lower(),\n+                   \"url()url()url()\u00dcrl\".to_owned());\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((~\"H\u0130\u212a\u00df\").into_ascii_lower(), ~\"h\u0130\u212a\u00df\");\n+        assert_eq!((\"H\u0130\u212a\u00df\".to_owned()).into_ascii_lower(), \"h\u0130\u212a\u00df\".to_owned());\n \n         let mut i = 0;\n         while i <= 500 {\n@@ -716,12 +720,12 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let s = Ascii{ chr: 't' as u8 }.to_str();\n-        assert_eq!(s, ~\"t\");\n+        assert_eq!(s, \"t\".to_owned());\n     }\n \n     #[test]\n     fn test_show() {\n         let c = Ascii { chr: 't' as u8 };\n-        assert_eq!(format!(\"{}\", c), ~\"t\");\n+        assert_eq!(format!(\"{}\", c), \"t\".to_owned());\n     }\n }"}, {"sha": "5a07c860b5ddab1248ef5c7795c3ccb4f1c8e1bf", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -199,6 +199,7 @@ impl Default for bool {\n mod tests {\n     use prelude::*;\n     use super::to_bit;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_to_bit() {\n@@ -268,8 +269,8 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!(false.to_str(), ~\"false\");\n-        assert_eq!(true.to_str(), ~\"true\");\n+        assert_eq!(false.to_str(), \"false\".to_owned());\n+        assert_eq!(true.to_str(), \"true\".to_owned());\n     }\n \n     #[test]"}, {"sha": "310bc861cd3f255999e28c62e7573257f8918f18", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -428,6 +428,7 @@ mod tests {\n     use super::*;\n     use libc;\n     use ptr;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_str_multistring_parsing() {\n@@ -638,7 +639,7 @@ mod tests {\n     #[test]\n     fn test_clone_noleak() {\n         fn foo(f: |c: &CString|) {\n-            let s = ~\"test\";\n+            let s = \"test\".to_owned();\n             let c = s.to_c_str();\n             // give the closure a non-owned CString\n             let mut c_ = c.with_ref(|c| unsafe { CString::new(c, false) } );"}, {"sha": "0fb6f30e8a1fa7a3e0b3b487074dbe76f78211c1", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -108,6 +108,7 @@ pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n mod tests {\n     use cast::{bump_box_refcount, transmute};\n     use raw;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_transmute_copy() {\n@@ -117,13 +118,13 @@ mod tests {\n     #[test]\n     fn test_bump_managed_refcount() {\n         unsafe {\n-            let managed = @~\"box box box\";      // refcount 1\n+            let managed = @\"box box box\".to_owned();      // refcount 1\n             bump_box_refcount(managed);     // refcount 2\n             let ptr: *int = transmute(managed); // refcount 2\n             let _box1: @~str = ::cast::transmute_copy(&ptr);\n             let _box2: @~str = ::cast::transmute_copy(&ptr);\n-            assert!(*_box1 == ~\"box box box\");\n-            assert!(*_box2 == ~\"box box box\");\n+            assert!(*_box1 == \"box box box\".to_owned());\n+            assert!(*_box2 == \"box box box\".to_owned());\n             // Will destroy _box1 and _box2. Without the bump, this would\n             // use-after-free. With too many bumps, it would leak.\n         }\n@@ -142,7 +143,7 @@ mod tests {\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n-            assert_eq!(~[76u8], transmute(~\"L\"));\n+            assert_eq!(~[76u8], transmute(\"L\".to_owned()));\n         }\n     }\n }"}, {"sha": "228db221cfc61177b2d9d8f71d4cdc285960ea7e", "filename": "src/libstd/char.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -779,19 +779,19 @@ fn test_escape_default() {\n         escape_default(c, |c| { result.push_char(c); });\n         return result.into_owned();\n     }\n-    assert_eq!(string('\\n'), ~\"\\\\n\");\n-    assert_eq!(string('\\r'), ~\"\\\\r\");\n-    assert_eq!(string('\\''), ~\"\\\\'\");\n-    assert_eq!(string('\"'), ~\"\\\\\\\"\");\n-    assert_eq!(string(' '), ~\" \");\n-    assert_eq!(string('a'), ~\"a\");\n-    assert_eq!(string('~'), ~\"~\");\n-    assert_eq!(string('\\x00'), ~\"\\\\x00\");\n-    assert_eq!(string('\\x1f'), ~\"\\\\x1f\");\n-    assert_eq!(string('\\x7f'), ~\"\\\\x7f\");\n-    assert_eq!(string('\\xff'), ~\"\\\\xff\");\n-    assert_eq!(string('\\u011b'), ~\"\\\\u011b\");\n-    assert_eq!(string('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n+    assert_eq!(string('\\n'), \"\\\\n\".to_owned());\n+    assert_eq!(string('\\r'), \"\\\\r\".to_owned());\n+    assert_eq!(string('\\''), \"\\\\'\".to_owned());\n+    assert_eq!(string('\"'), \"\\\\\\\"\".to_owned());\n+    assert_eq!(string(' '), \" \".to_owned());\n+    assert_eq!(string('a'), \"a\".to_owned());\n+    assert_eq!(string('~'), \"~\".to_owned());\n+    assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n+    assert_eq!(string('\\x1f'), \"\\\\x1f\".to_owned());\n+    assert_eq!(string('\\x7f'), \"\\\\x7f\".to_owned());\n+    assert_eq!(string('\\xff'), \"\\\\xff\".to_owned());\n+    assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n+    assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n }\n \n #[test]\n@@ -801,19 +801,19 @@ fn test_escape_unicode() {\n         escape_unicode(c, |c| { result.push_char(c); });\n         return result.into_owned();\n     }\n-    assert_eq!(string('\\x00'), ~\"\\\\x00\");\n-    assert_eq!(string('\\n'), ~\"\\\\x0a\");\n-    assert_eq!(string(' '), ~\"\\\\x20\");\n-    assert_eq!(string('a'), ~\"\\\\x61\");\n-    assert_eq!(string('\\u011b'), ~\"\\\\u011b\");\n-    assert_eq!(string('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n+    assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n+    assert_eq!(string('\\n'), \"\\\\x0a\".to_owned());\n+    assert_eq!(string(' '), \"\\\\x20\".to_owned());\n+    assert_eq!(string('a'), \"\\\\x61\".to_owned());\n+    assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n+    assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n }\n \n #[test]\n fn test_to_str() {\n     use to_str::ToStr;\n     let s = 't'.to_str();\n-    assert_eq!(s, ~\"t\");\n+    assert_eq!(s, \"t\".to_owned());\n }\n \n #[test]"}, {"sha": "8e4d8707cca7b788a34c112dc9bc97d89a5267e7", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -34,12 +34,12 @@ arguments directly while performing minimal allocations.\n Some examples of the `format!` extension are:\n \n ```rust\n-format!(\"Hello\");                 // => ~\"Hello\"\n-format!(\"Hello, {:s}!\", \"world\"); // => ~\"Hello, world!\"\n-format!(\"The number is {:d}\", 1); // => ~\"The number is 1\"\n-format!(\"{:?}\", ~[3, 4]);         // => ~\"~[3, 4]\"\n-format!(\"{value}\", value=4);      // => ~\"4\"\n-format!(\"{} {}\", 1, 2);           // => ~\"1 2\"\n+format!(\"Hello\");                 // => \"Hello\".to_owned()\n+format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_owned()\n+format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_owned()\n+format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_owned()\n+format!(\"{value}\", value=4);      // => \"4\".to_owned()\n+format!(\"{} {}\", 1, 2);           // => \"1 2\".to_owned()\n ```\n \n From these, you can see that the first argument is a format string. It is\n@@ -62,7 +62,7 @@ iterator over the argument. Each time a \"next argument\" specifier is seen, the\n iterator advances. This leads to behavior like this:\n \n ```rust\n-format!(\"{1} {} {0} {}\", 1, 2); // => ~\"2 1 1 2\"\n+format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_owned()\n ```\n \n The internal iterator over the argument has not been advanced by the time the\n@@ -89,9 +89,9 @@ identifier '=' expression\n For example, the following `format!` expressions all use named argument:\n \n ```rust\n-format!(\"{argument}\", argument = \"test\");       // => ~\"test\"\n-format!(\"{name} {}\", 1, name = 2);              // => ~\"2 1\"\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => ~\"a 3 ()\"\n+format!(\"{argument}\", argument = \"test\");       // => \"test\".to_owned()\n+format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_owned()\n+format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_owned()\n ```\n \n It is illegal to put positional parameters (those without names) after arguments\n@@ -330,7 +330,7 @@ to reference the string value of the argument which was selected upon. As an\n example:\n \n ```rust\n-format!(\"{0, select, other{#}}\", \"hello\"); // => ~\"hello\"\n+format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_owned()\n ```\n \n This example is the equivalent of `{0:s}` essentially.\n@@ -771,7 +771,7 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n /// use std::fmt;\n ///\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, ~\"Hello, world!\");\n+/// assert_eq!(s, \"Hello, world!\".to_owned());\n /// ```\n pub fn format(args: &Arguments) -> ~str {\n     unsafe { format_unsafe(args.fmt, args.args) }"}, {"sha": "1abfca50b54077a19eb11ae8cdacf9202f29ca7d", "filename": "src/libstd/fmt/num.rs", "status": "modified", "additions": 116, "deletions": 115, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -138,7 +138,7 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// ~~~\n /// use std::fmt::radix;\n-/// assert_eq!(format!(\"{}\", radix(55, 36)), ~\"1j\");\n+/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_owned());\n /// ~~~\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n@@ -192,6 +192,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n+    use str::StrSlice;\n \n     #[test]\n     fn test_radix_base() {\n@@ -243,143 +244,143 @@ mod tests {\n         // Formatting integers should select the right implementation based off\n         // the type of the argument. Also, hex/octal/binary should be defined\n         // for integers, but they shouldn't emit the negative sign.\n-        assert_eq!(format!(\"{}\", 1i), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1i8), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1i16), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1i32), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1i64), ~\"1\");\n-        assert_eq!(format!(\"{:d}\", -1i), ~\"-1\");\n-        assert_eq!(format!(\"{:d}\", -1i8), ~\"-1\");\n-        assert_eq!(format!(\"{:d}\", -1i16), ~\"-1\");\n-        assert_eq!(format!(\"{:d}\", -1i32), ~\"-1\");\n-        assert_eq!(format!(\"{:d}\", -1i64), ~\"-1\");\n-        assert_eq!(format!(\"{:t}\", 1i), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1i8), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1i16), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1i32), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1i64), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1i), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1i8), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1i16), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1i32), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1i64), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1i), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1i8), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1i16), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1i32), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1i64), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1i), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1i8), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1i16), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1i32), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1i64), ~\"1\");\n-\n-        assert_eq!(format!(\"{}\", 1u), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1u8), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1u16), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1u32), ~\"1\");\n-        assert_eq!(format!(\"{}\", 1u64), ~\"1\");\n-        assert_eq!(format!(\"{:u}\", 1u), ~\"1\");\n-        assert_eq!(format!(\"{:u}\", 1u8), ~\"1\");\n-        assert_eq!(format!(\"{:u}\", 1u16), ~\"1\");\n-        assert_eq!(format!(\"{:u}\", 1u32), ~\"1\");\n-        assert_eq!(format!(\"{:u}\", 1u64), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1u), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1u8), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1u16), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1u32), ~\"1\");\n-        assert_eq!(format!(\"{:t}\", 1u64), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1u), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1u8), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1u16), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1u32), ~\"1\");\n-        assert_eq!(format!(\"{:x}\", 1u64), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1u), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1u8), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1u16), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1u32), ~\"1\");\n-        assert_eq!(format!(\"{:X}\", 1u64), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1u), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1u8), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1u16), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1u32), ~\"1\");\n-        assert_eq!(format!(\"{:o}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1i8), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1i16), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1i32), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1i64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:d}\", -1i), \"-1\".to_owned());\n+        assert_eq!(format!(\"{:d}\", -1i8), \"-1\".to_owned());\n+        assert_eq!(format!(\"{:d}\", -1i16), \"-1\".to_owned());\n+        assert_eq!(format!(\"{:d}\", -1i32), \"-1\".to_owned());\n+        assert_eq!(format!(\"{:d}\", -1i64), \"-1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1i), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1i8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1i16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1i32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1i64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1i), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1i8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1i16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1i32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1i64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1i), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1i8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1i16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1i32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1i64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1i), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1i8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1i16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1i32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1i64), \"1\".to_owned());\n+\n+        assert_eq!(format!(\"{}\", 1u), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1u8), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1u16), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1u32), \"1\".to_owned());\n+        assert_eq!(format!(\"{}\", 1u64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:u}\", 1u), \"1\".to_owned());\n+        assert_eq!(format!(\"{:u}\", 1u8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:u}\", 1u16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:u}\", 1u32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:u}\", 1u64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1u), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1u8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1u16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1u32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 1u64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1u), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1u8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1u16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1u32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 1u64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1u), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1u8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1u16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1u32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 1u64), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1u), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1u8), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1u16), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1u32), \"1\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 1u64), \"1\".to_owned());\n \n         // Test a larger number\n-        assert_eq!(format!(\"{:t}\", 55), ~\"110111\");\n-        assert_eq!(format!(\"{:o}\", 55), ~\"67\");\n-        assert_eq!(format!(\"{:d}\", 55), ~\"55\");\n-        assert_eq!(format!(\"{:x}\", 55), ~\"37\");\n-        assert_eq!(format!(\"{:X}\", 55), ~\"37\");\n+        assert_eq!(format!(\"{:t}\", 55), \"110111\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 55), \"67\".to_owned());\n+        assert_eq!(format!(\"{:d}\", 55), \"55\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 55), \"37\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 55), \"37\".to_owned());\n     }\n \n     #[test]\n     fn test_format_int_zero() {\n-        assert_eq!(format!(\"{}\", 0i), ~\"0\");\n-        assert_eq!(format!(\"{:d}\", 0i), ~\"0\");\n-        assert_eq!(format!(\"{:t}\", 0i), ~\"0\");\n-        assert_eq!(format!(\"{:o}\", 0i), ~\"0\");\n-        assert_eq!(format!(\"{:x}\", 0i), ~\"0\");\n-        assert_eq!(format!(\"{:X}\", 0i), ~\"0\");\n-\n-        assert_eq!(format!(\"{}\", 0u), ~\"0\");\n-        assert_eq!(format!(\"{:u}\", 0u), ~\"0\");\n-        assert_eq!(format!(\"{:t}\", 0u), ~\"0\");\n-        assert_eq!(format!(\"{:o}\", 0u), ~\"0\");\n-        assert_eq!(format!(\"{:x}\", 0u), ~\"0\");\n-        assert_eq!(format!(\"{:X}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{}\", 0i), \"0\".to_owned());\n+        assert_eq!(format!(\"{:d}\", 0i), \"0\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 0i), \"0\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 0i), \"0\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 0i), \"0\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 0i), \"0\".to_owned());\n+\n+        assert_eq!(format!(\"{}\", 0u), \"0\".to_owned());\n+        assert_eq!(format!(\"{:u}\", 0u), \"0\".to_owned());\n+        assert_eq!(format!(\"{:t}\", 0u), \"0\".to_owned());\n+        assert_eq!(format!(\"{:o}\", 0u), \"0\".to_owned());\n+        assert_eq!(format!(\"{:x}\", 0u), \"0\".to_owned());\n+        assert_eq!(format!(\"{:X}\", 0u), \"0\".to_owned());\n     }\n \n     #[test]\n     fn test_format_int_flags() {\n-        assert_eq!(format!(\"{:3d}\", 1), ~\"  1\");\n-        assert_eq!(format!(\"{:>3d}\", 1), ~\"  1\");\n-        assert_eq!(format!(\"{:>+3d}\", 1), ~\" +1\");\n-        assert_eq!(format!(\"{:<3d}\", 1), ~\"1  \");\n-        assert_eq!(format!(\"{:#d}\", 1), ~\"1\");\n-        assert_eq!(format!(\"{:#x}\", 10), ~\"0xa\");\n-        assert_eq!(format!(\"{:#X}\", 10), ~\"0xA\");\n-        assert_eq!(format!(\"{:#5x}\", 10), ~\"  0xa\");\n-        assert_eq!(format!(\"{:#o}\", 10), ~\"0o12\");\n-        assert_eq!(format!(\"{:08x}\", 10), ~\"0000000a\");\n-        assert_eq!(format!(\"{:8x}\", 10), ~\"       a\");\n-        assert_eq!(format!(\"{:<8x}\", 10), ~\"a       \");\n-        assert_eq!(format!(\"{:>8x}\", 10), ~\"       a\");\n-        assert_eq!(format!(\"{:#08x}\", 10), ~\"0x00000a\");\n-        assert_eq!(format!(\"{:08d}\", -10), ~\"-0000010\");\n-        assert_eq!(format!(\"{:x}\", -1u8), ~\"ff\");\n-        assert_eq!(format!(\"{:X}\", -1u8), ~\"FF\");\n-        assert_eq!(format!(\"{:t}\", -1u8), ~\"11111111\");\n-        assert_eq!(format!(\"{:o}\", -1u8), ~\"377\");\n-        assert_eq!(format!(\"{:#x}\", -1u8), ~\"0xff\");\n-        assert_eq!(format!(\"{:#X}\", -1u8), ~\"0xFF\");\n-        assert_eq!(format!(\"{:#t}\", -1u8), ~\"0b11111111\");\n-        assert_eq!(format!(\"{:#o}\", -1u8), ~\"0o377\");\n+        assert_eq!(format!(\"{:3d}\", 1), \"  1\".to_owned());\n+        assert_eq!(format!(\"{:>3d}\", 1), \"  1\".to_owned());\n+        assert_eq!(format!(\"{:>+3d}\", 1), \" +1\".to_owned());\n+        assert_eq!(format!(\"{:<3d}\", 1), \"1  \".to_owned());\n+        assert_eq!(format!(\"{:#d}\", 1), \"1\".to_owned());\n+        assert_eq!(format!(\"{:#x}\", 10), \"0xa\".to_owned());\n+        assert_eq!(format!(\"{:#X}\", 10), \"0xA\".to_owned());\n+        assert_eq!(format!(\"{:#5x}\", 10), \"  0xa\".to_owned());\n+        assert_eq!(format!(\"{:#o}\", 10), \"0o12\".to_owned());\n+        assert_eq!(format!(\"{:08x}\", 10), \"0000000a\".to_owned());\n+        assert_eq!(format!(\"{:8x}\", 10), \"       a\".to_owned());\n+        assert_eq!(format!(\"{:<8x}\", 10), \"a       \".to_owned());\n+        assert_eq!(format!(\"{:>8x}\", 10), \"       a\".to_owned());\n+        assert_eq!(format!(\"{:#08x}\", 10), \"0x00000a\".to_owned());\n+        assert_eq!(format!(\"{:08d}\", -10), \"-0000010\".to_owned());\n+        assert_eq!(format!(\"{:x}\", -1u8), \"ff\".to_owned());\n+        assert_eq!(format!(\"{:X}\", -1u8), \"FF\".to_owned());\n+        assert_eq!(format!(\"{:t}\", -1u8), \"11111111\".to_owned());\n+        assert_eq!(format!(\"{:o}\", -1u8), \"377\".to_owned());\n+        assert_eq!(format!(\"{:#x}\", -1u8), \"0xff\".to_owned());\n+        assert_eq!(format!(\"{:#X}\", -1u8), \"0xFF\".to_owned());\n+        assert_eq!(format!(\"{:#t}\", -1u8), \"0b11111111\".to_owned());\n+        assert_eq!(format!(\"{:#o}\", -1u8), \"0o377\".to_owned());\n     }\n \n     #[test]\n     fn test_format_int_sign_padding() {\n-        assert_eq!(format!(\"{:+5d}\", 1), ~\"   +1\");\n-        assert_eq!(format!(\"{:+5d}\", -1), ~\"   -1\");\n-        assert_eq!(format!(\"{:05d}\", 1), ~\"00001\");\n-        assert_eq!(format!(\"{:05d}\", -1), ~\"-0001\");\n-        assert_eq!(format!(\"{:+05d}\", 1), ~\"+0001\");\n-        assert_eq!(format!(\"{:+05d}\", -1), ~\"-0001\");\n+        assert_eq!(format!(\"{:+5d}\", 1), \"   +1\".to_owned());\n+        assert_eq!(format!(\"{:+5d}\", -1), \"   -1\".to_owned());\n+        assert_eq!(format!(\"{:05d}\", 1), \"00001\".to_owned());\n+        assert_eq!(format!(\"{:05d}\", -1), \"-0001\".to_owned());\n+        assert_eq!(format!(\"{:+05d}\", 1), \"+0001\".to_owned());\n+        assert_eq!(format!(\"{:+05d}\", -1), \"-0001\".to_owned());\n     }\n \n     #[test]\n     fn test_format_int_twos_complement() {\n         use {i8, i16, i32, i64};\n-        assert_eq!(format!(\"{}\", i8::MIN), ~\"-128\");\n-        assert_eq!(format!(\"{}\", i16::MIN), ~\"-32768\");\n-        assert_eq!(format!(\"{}\", i32::MIN), ~\"-2147483648\");\n-        assert_eq!(format!(\"{}\", i64::MIN), ~\"-9223372036854775808\");\n+        assert_eq!(format!(\"{}\", i8::MIN), \"-128\".to_owned());\n+        assert_eq!(format!(\"{}\", i16::MIN), \"-32768\".to_owned());\n+        assert_eq!(format!(\"{}\", i32::MIN), \"-2147483648\".to_owned());\n+        assert_eq!(format!(\"{}\", i64::MIN), \"-9223372036854775808\".to_owned());\n     }\n \n     #[test]\n     fn test_format_radix() {\n-        assert_eq!(format!(\"{:04}\", radix(3, 2)), ~\"0011\");\n-        assert_eq!(format!(\"{}\", radix(55, 36)), ~\"1j\");\n+        assert_eq!(format!(\"{:04}\", radix(3, 2)), \"0011\".to_owned());\n+        assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_owned());\n     }\n \n     #[test]"}, {"sha": "ffb41e9781b865bd60fc6827cc766953fd3c3628", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -27,8 +27,8 @@\n  *     phone: u64,\n  * }\n  *\n- * let person1 = Person { id: 5, name: ~\"Janet\", phone: 555_666_7777 };\n- * let person2 = Person { id: 5, name: ~\"Bob\", phone: 555_666_7777 };\n+ * let person1 = Person { id: 5, name: \"Janet\".to_owned(), phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: \"Bob\".to_owned(), phone: 555_666_7777 };\n  *\n  * assert!(hash::hash(&person1) != hash::hash(&person2));\n  * ```\n@@ -54,8 +54,8 @@\n  *     }\n  * }\n  *\n- * let person1 = Person { id: 5, name: ~\"Janet\", phone: 555_666_7777 };\n- * let person2 = Person { id: 5, name: ~\"Bob\", phone: 555_666_7777 };\n+ * let person1 = Person { id: 5, name: \"Janet\".to_owned(), phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: \"Bob\".to_owned(), phone: 555_666_7777 };\n  *\n  * assert!(hash::hash(&person1) == hash::hash(&person2));\n  * ```"}, {"sha": "794c4ee62ff78cebd4fde9b1255ebad3b633ea1d", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -361,6 +361,10 @@ mod tests {\n     extern crate test;\n     use prelude::*;\n     use num::ToStrRadix;\n+    use option::{Some, None};\n+    use str::{Str,StrSlice};\n+    use strbuf::StrBuf;\n+    use slice::{Vector, ImmutableVector, OwnedVector};\n     use self::test::Bencher;\n \n     use super::super::Hash;\n@@ -640,7 +644,7 @@ officia deserunt mollit anim id est laborum.\";\n         let compound = Compound {\n             x: 1,\n             y: 2,\n-            z: ~\"foobarbaz\",\n+            z: \"foobarbaz\".to_owned(),\n         };\n         b.iter(|| {\n             assert_eq!(hash(&compound), 15783192367317361799);"}, {"sha": "298e9df6d684b7184429b1b0f006774f88333094", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -372,6 +372,7 @@ mod test {\n     use super::*;\n     use super::super::mem::{MemReader, MemWriter, BufReader};\n     use self::test::Bencher;\n+    use str::StrSlice;\n \n     /// A type, free to create, primarily intended for benchmarking creation of\n     /// wrappers that, just for construction, don't need a Reader/Writer that\n@@ -535,9 +536,9 @@ mod test {\n     fn test_read_line() {\n         let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Ok(~\"a\\n\"));\n-        assert_eq!(reader.read_line(), Ok(~\"b\\n\"));\n-        assert_eq!(reader.read_line(), Ok(~\"c\"));\n+        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_owned()));\n+        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_owned()));\n+        assert_eq!(reader.read_line(), Ok(\"c\".to_owned()));\n         assert!(reader.read_line().is_err());\n     }\n \n@@ -546,9 +547,9 @@ mod test {\n         let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(Ok(~\"a\\n\")));\n-        assert_eq!(it.next(), Some(Ok(~\"b\\n\")));\n-        assert_eq!(it.next(), Some(Ok(~\"c\")));\n+        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_owned())));\n+        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_owned())));\n+        assert_eq!(it.next(), Some(Ok(\"c\".to_owned())));\n         assert_eq!(it.next(), None);\n     }\n "}, {"sha": "bb45e519e5e710d971b3eb9ff783817e0fa87c91", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,6 +16,7 @@ use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n use super::{Reader, Writer, IoResult};\n+use str::StrSlice;\n use slice::{bytes, CloneableVector, MutableVector, ImmutableVector};\n \n /// Allows reading from a rx."}, {"sha": "6bc32d0ed7b56c0a2c4c547835a52ef4e600fe7e", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -711,6 +711,7 @@ mod test {\n     use path::Path;\n     use io;\n     use ops::Drop;\n+    use str::StrSlice;\n \n     macro_rules! check( ($e:expr) => (\n         match $e {"}, {"sha": "2f64592ec7a31a70d89bd0b1c53987e068491f68", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -339,6 +339,7 @@ mod test {\n     use super::*;\n     use io::*;\n     use io;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_mem_writer() {\n@@ -496,7 +497,7 @@ mod test {\n         writer.write_line(\"testing\").unwrap();\n         writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), ~\"testingtesting\\ntesting\");\n+        assert_eq!(r.read_to_str().unwrap(), \"testingtesting\\ntesting\".to_owned());\n     }\n \n     #[test]\n@@ -506,7 +507,7 @@ mod test {\n         writer.write_char('\\n').unwrap();\n         writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), ~\"a\\n\u1ec7\");\n+        assert_eq!(r.read_to_str().unwrap(), \"a\\n\u1ec7\".to_owned());\n     }\n \n     #[test]"}, {"sha": "d8267e472bd0acedb012624662c621d3d0ce4b88", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1188,7 +1188,7 @@ pub trait Buffer: Reader {\n     /// use std::io;\n     ///\n     /// let mut reader = io::stdin();\n-    /// let input = reader.read_line().ok().unwrap_or(~\"nothing\");\n+    /// let input = reader.read_line().ok().unwrap_or(\"nothing\".to_owned());\n     /// ```\n     ///\n     /// # Error"}, {"sha": "f61b282767f7161f8e835ecb82ab7218e9625ad9", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -445,7 +445,8 @@ mod test {\n     #[test]\n     fn ipv6_addr_to_str() {\n         let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_str() == ~\"::ffff:192.0.2.128\" || a1.to_str() == ~\"::FFFF:192.0.2.128\");\n-        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), ~\"8:9:a:b:c:d:e:f\");\n+        assert!(a1.to_str() == \"::ffff:192.0.2.128\".to_owned() ||\n+                a1.to_str() == \"::FFFF:192.0.2.128\".to_owned());\n+        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), \"8:9:a:b:c:d:e:f\".to_owned());\n     }\n }"}, {"sha": "b507f61bb45d0fdb569121d46ae325a5cdda65d7", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -43,7 +43,7 @@ use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n /// ```should_fail\n /// use std::io::Process;\n ///\n-/// let mut child = match Process::new(\"/bin/cat\", [~\"file.txt\"]) {\n+/// let mut child = match Process::new(\"/bin/cat\", [\"file.txt\".to_owned()]) {\n ///     Ok(child) => child,\n ///     Err(e) => fail!(\"failed to execute child: {}\", e),\n /// };\n@@ -81,7 +81,7 @@ pub struct Process {\n ///\n /// let config = ProcessConfig {\n ///     program: \"/bin/sh\",\n-///     args: &[~\"-c\", ~\"true\"],\n+///     args: &[\"-c\".to_owned(), \"true\".to_owned()],\n ///     .. ProcessConfig::new()\n /// };\n /// ```\n@@ -211,7 +211,7 @@ impl<'a> ProcessConfig<'a> {\n     ///\n     /// let config = ProcessConfig {\n     ///     program: \"/bin/sh\",\n-    ///     args: &[~\"-c\", ~\"echo hello\"],\n+    ///     args: &[\"-c\".to_owned(), \"echo hello\".to_owned()],\n     ///     .. ProcessConfig::new()\n     /// };\n     ///\n@@ -248,7 +248,7 @@ impl Process {\n     /// ```\n     /// use std::io::Process;\n     ///\n-    /// let mut process = match Process::new(\"sh\", &[~\"c\", ~\"echo hello\"]) {\n+    /// let mut process = match Process::new(\"sh\", &[\"c\".to_owned(), \"echo hello\".to_owned()]) {\n     ///     Ok(p) => p,\n     ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n     /// };\n@@ -272,7 +272,7 @@ impl Process {\n     /// use std::io::Process;\n     /// use std::str;\n     ///\n-    /// let output = match Process::output(\"cat\", [~\"foo.txt\"]) {\n+    /// let output = match Process::output(\"cat\", [\"foo.txt\".to_owned()]) {\n     ///     Ok(output) => output,\n     ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n     /// };\n@@ -427,6 +427,7 @@ impl Drop for Process {\n mod tests {\n     use io::process::{ProcessConfig, Process};\n     use prelude::*;\n+    use str::StrSlice;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n \n@@ -471,7 +472,7 @@ mod tests {\n     iotest!(fn signal_reported_right() {\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"kill -1 $$\"],\n+            args: &[\"-c\".to_owned(), \"kill -1 $$\".to_owned()],\n             .. ProcessConfig::new()\n         };\n         let p = Process::configure(args);\n@@ -501,31 +502,31 @@ mod tests {\n     iotest!(fn stdout_works() {\n         let args = ProcessConfig {\n             program: \"echo\",\n-            args: &[~\"foobar\"],\n+            args: &[\"foobar\".to_owned()],\n             stdout: CreatePipe(false, true),\n             .. ProcessConfig::new()\n         };\n-        assert_eq!(run_output(args), ~\"foobar\\n\");\n+        assert_eq!(run_output(args), \"foobar\\n\".to_owned());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn set_cwd_works() {\n         let cwd = Path::new(\"/\");\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"pwd\"],\n+            args: &[\"-c\".to_owned(), \"pwd\".to_owned()],\n             cwd: Some(&cwd),\n             stdout: CreatePipe(false, true),\n             .. ProcessConfig::new()\n         };\n-        assert_eq!(run_output(args), ~\"/\\n\");\n+        assert_eq!(run_output(args), \"/\\n\".to_owned());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn stdin_works() {\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"read line; echo $line\"],\n+            args: &[\"-c\".to_owned(), \"read line; echo $line\".to_owned()],\n             stdin: CreatePipe(true, false),\n             stdout: CreatePipe(false, true),\n             .. ProcessConfig::new()\n@@ -535,7 +536,7 @@ mod tests {\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n         assert!(p.wait().success());\n-        assert_eq!(out, ~\"foobar\\n\");\n+        assert_eq!(out, \"foobar\\n\".to_owned());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -564,7 +565,7 @@ mod tests {\n         use libc;\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"true\"],\n+            args: &[\"-c\".to_owned(), \"true\".to_owned()],\n             uid: Some(unsafe { libc::getuid() as uint }),\n             gid: Some(unsafe { libc::getgid() as uint }),\n             .. ProcessConfig::new()\n@@ -609,11 +610,11 @@ mod tests {\n     iotest!(fn test_process_output_output() {\n \n         let ProcessOutput {status, output, error}\n-             = Process::output(\"echo\", [~\"hello\"]).unwrap();\n+             = Process::output(\"echo\", [\"hello\".to_owned()]).unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -623,7 +624,7 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_process_output_error() {\n         let ProcessOutput {status, output, error}\n-             = Process::output(\"mkdir\", [~\".\"]).unwrap();\n+             = Process::output(\"mkdir\", [\".\".to_owned()]).unwrap();\n \n         assert!(status.matches_exit_status(1));\n         assert_eq!(output, Vec::new());\n@@ -646,12 +647,12 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_wait_with_output_once() {\n \n-        let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n+        let mut prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -660,13 +661,13 @@ mod tests {\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_wait_with_output_twice() {\n-        let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n+        let mut prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n \n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -694,7 +695,7 @@ mod tests {\n     pub fn run_pwd(dir: Option<&Path>) -> Process {\n         Process::configure(ProcessConfig {\n             program: \"/system/bin/sh\",\n-            args: &[~\"-c\",~\"pwd\"],\n+            args: &[\"-c\".to_owned(),\"pwd\".to_owned()],\n             cwd: dir.map(|a| &*a),\n             .. ProcessConfig::new()\n         }).unwrap()\n@@ -704,7 +705,7 @@ mod tests {\n     pub fn run_pwd(dir: Option<&Path>) -> Process {\n         Process::configure(ProcessConfig {\n             program: \"cmd\",\n-            args: &[~\"/c\", ~\"cd\"],\n+            args: &[\"/c\".to_owned(), \"cd\".to_owned()],\n             cwd: dir.map(|a| &*a),\n             .. ProcessConfig::new()\n         }).unwrap()\n@@ -754,7 +755,7 @@ mod tests {\n     pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n         Process::configure(ProcessConfig {\n             program: \"/system/bin/sh\",\n-            args: &[~\"-c\",~\"set\"],\n+            args: &[\"-c\".to_owned(),\"set\".to_owned()],\n             env: env.as_ref().map(|e| e.as_slice()),\n             .. ProcessConfig::new()\n         }).unwrap()\n@@ -764,7 +765,7 @@ mod tests {\n     pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n         Process::configure(ProcessConfig {\n             program: \"cmd\",\n-            args: &[~\"/c\", ~\"set\"],\n+            args: &[\"/c\".to_owned(), \"set\".to_owned()],\n             env: env.as_ref().map(|e| e.as_slice()),\n             .. ProcessConfig::new()\n         }).unwrap()\n@@ -795,15 +796,15 @@ mod tests {\n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n-            if *k != ~\"RANDOM\" {\n+            if *k != \"RANDOM\".to_owned() {\n                 assert!(output.contains(format!(\"{}={}\", *k, *v)) ||\n                         output.contains(format!(\"{}=\\'{}\\'\", *k, *v)));\n             }\n         }\n     })\n \n     iotest!(fn test_add_to_env() {\n-        let new_env = ~[(~\"RUN_TEST_NEW_ENV\", ~\"123\")];\n+        let new_env = ~[(\"RUN_TEST_NEW_ENV\".to_owned(), \"123\".to_owned())];\n \n         let mut prog = run_env(Some(new_env));\n         let result = prog.wait_with_output();\n@@ -815,14 +816,14 @@ mod tests {\n \n     #[cfg(unix)]\n     pub fn sleeper() -> Process {\n-        Process::new(\"sleep\", [~\"1000\"]).unwrap()\n+        Process::new(\"sleep\", [\"1000\".to_owned()]).unwrap()\n     }\n     #[cfg(windows)]\n     pub fn sleeper() -> Process {\n         // There's a `timeout` command on windows, but it doesn't like having\n         // its output piped, so instead just ping ourselves a few times with\n         // gaps inbetweeen so we're sure this process is alive for awhile\n-        Process::new(\"ping\", [~\"127.0.0.1\", ~\"-n\", ~\"1000\"]).unwrap()\n+        Process::new(\"ping\", [\"127.0.0.1\".to_owned(), \"-n\".to_owned(), \"1000\".to_owned()]).unwrap()\n     }\n \n     iotest!(fn test_kill() {"}, {"sha": "96439439e7aefb9ca3ac2015d47ca3c34181a2fe", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -411,7 +411,7 @@ mod tests {\n             set_stdout(~w);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_str().unwrap(), ~\"hello!\\n\");\n+        assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_owned());\n     })\n \n     iotest!(fn capture_stderr() {"}, {"sha": "a6199aa43ab4de16423492126796b0c0c6ff91ef", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -354,38 +354,39 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use task;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_tls_multitask() {\n         static my_key: Key<~str> = &Key;\n-        set(my_key, ~\"parent data\");\n+        set(my_key, \"parent data\".to_owned());\n         task::spawn(proc() {\n             // TLS shouldn't carry over.\n             assert!(get(my_key, |k| k.map(|k| (*k).clone())).is_none());\n-            set(my_key, ~\"child data\");\n+            set(my_key, \"child data\".to_owned());\n             assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() ==\n-                    ~\"child data\");\n+                    \"child data\".to_owned());\n             // should be cleaned up for us\n         });\n         // Must work multiple times\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n+        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"parent data\".to_owned());\n+        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"parent data\".to_owned());\n+        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"parent data\".to_owned());\n     }\n \n     #[test]\n     fn test_tls_overwrite() {\n         static my_key: Key<~str> = &Key;\n-        set(my_key, ~\"first data\");\n-        set(my_key, ~\"next data\"); // Shouldn't leak.\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"next data\");\n+        set(my_key, \"first data\".to_owned());\n+        set(my_key, \"next data\".to_owned()); // Shouldn't leak.\n+        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"next data\".to_owned());\n     }\n \n     #[test]\n     fn test_tls_pop() {\n         static my_key: Key<~str> = &Key;\n-        set(my_key, ~\"weasel\");\n-        assert!(pop(my_key).unwrap() == ~\"weasel\");\n+        set(my_key, \"weasel\".to_owned());\n+        assert!(pop(my_key).unwrap() == \"weasel\".to_owned());\n         // Pop must remove the data from the map.\n         assert!(pop(my_key).is_none());\n     }\n@@ -396,17 +397,17 @@ mod tests {\n         modify(my_key, |data| {\n             match data {\n                 Some(ref val) => fail!(\"unwelcome value: {}\", *val),\n-                None           => Some(~\"first data\")\n+                None           => Some(\"first data\".to_owned())\n             }\n         });\n         modify(my_key, |data| {\n             match data.as_ref().map(|s| s.as_slice()) {\n-                Some(\"first data\") => Some(~\"next data\"),\n+                Some(\"first data\") => Some(\"next data\".to_owned()),\n                 Some(ref val)       => fail!(\"wrong value: {}\", *val),\n                 None                 => fail!(\"missing value\")\n             }\n         });\n-        assert!(pop(my_key).unwrap() == ~\"next data\");\n+        assert!(pop(my_key).unwrap() == \"next data\".to_owned());\n     }\n \n     #[test]\n@@ -419,7 +420,7 @@ mod tests {\n         // a stack smaller than 1 MB.\n         static my_key: Key<~str> = &Key;\n         task::spawn(proc() {\n-            set(my_key, ~\"hax\");\n+            set(my_key, \"hax\".to_owned());\n         });\n     }\n \n@@ -429,7 +430,7 @@ mod tests {\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            set(str_key, ~\"string data\");\n+            set(str_key, \"string data\".to_owned());\n             set(box_key, @());\n             set(int_key, 42);\n         });\n@@ -442,8 +443,8 @@ mod tests {\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            set(str_key, ~\"string data\");\n-            set(str_key, ~\"string data 2\");\n+            set(str_key, \"string data\".to_owned());\n+            set(str_key, \"string data 2\".to_owned());\n             set(box_key, @());\n             set(box_key, @());\n             set(int_key, 42);\n@@ -460,11 +461,11 @@ mod tests {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        set(str_key, ~\"parent data\");\n+        set(str_key, \"parent data\".to_owned());\n         set(box_key, @());\n         task::spawn(proc() {\n             // spawn_linked\n-            set(str_key, ~\"string data\");\n+            set(str_key, \"string data\".to_owned());\n             set(box_key, @());\n             set(int_key, 42);\n             fail!();"}, {"sha": "d562aa73d7844731efb8f77f0fe7f8e0e3568227", "filename": "src/libstd/mem.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -262,6 +262,7 @@ pub fn drop<T>(_x: T) { }\n mod tests {\n     use mem::*;\n     use option::{Some,None};\n+    use str::StrSlice;\n \n     #[test]\n     fn size_of_basic() {\n@@ -352,7 +353,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut x = Some(~\"test\");\n+        let mut x = Some(\"test\".to_owned());\n         let y = replace(&mut x, None);\n         assert!(x.is_none());\n         assert!(y.is_some());"}, {"sha": "a6b0ccf3a87251ffa12390bd3abab94f6fd27b08", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -298,6 +298,7 @@ mod tests {\n     use num::Bitwise;\n     use num::CheckedDiv;\n     use num::ToStrRadix;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_overflows() {\n@@ -419,39 +420,39 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!((0 as $T).to_str_radix(10u), ~\"0\");\n-        assert_eq!((1 as $T).to_str_radix(10u), ~\"1\");\n-        assert_eq!((-1 as $T).to_str_radix(10u), ~\"-1\");\n-        assert_eq!((127 as $T).to_str_radix(16u), ~\"7f\");\n-        assert_eq!((100 as $T).to_str_radix(10u), ~\"100\");\n+        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_owned());\n+        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_owned());\n+        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_owned());\n+        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_owned());\n+        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_owned());\n \n     }\n \n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_str(), ~\"127\");\n+        assert_eq!(i8_val.to_str(), \"127\".to_owned());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_str(), ~\"-128\");\n+        assert_eq!(i8_val.to_str(), \"-128\".to_owned());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_str(), ~\"32767\");\n+        assert_eq!(i16_val.to_str(), \"32767\".to_owned());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_str(), ~\"-32768\");\n+        assert_eq!(i16_val.to_str(), \"-32768\".to_owned());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_str(), ~\"2147483647\");\n+        assert_eq!(i32_val.to_str(), \"2147483647\".to_owned());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_str(), ~\"-2147483648\");\n+        assert_eq!(i32_val.to_str(), \"-2147483648\".to_owned());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_str(), ~\"9223372036854775807\");\n+        assert_eq!(i64_val.to_str(), \"9223372036854775807\".to_owned());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_str(), ~\"-9223372036854775808\");\n+        assert_eq!(i64_val.to_str(), \"-9223372036854775808\".to_owned());\n     }\n \n     #[test]"}, {"sha": "9b9aee672a0f51a6ea6bb829fc35782d89ed78bb", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -234,6 +234,7 @@ mod tests {\n     use num::CheckedDiv;\n     use num::Bitwise;\n     use num::ToStrRadix;\n+    use str::StrSlice;\n     use u16;\n \n     #[test]\n@@ -274,13 +275,13 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str() {\n-        assert_eq!((0 as $T).to_str_radix(10u), ~\"0\");\n-        assert_eq!((1 as $T).to_str_radix(10u), ~\"1\");\n-        assert_eq!((2 as $T).to_str_radix(10u), ~\"2\");\n-        assert_eq!((11 as $T).to_str_radix(10u), ~\"11\");\n-        assert_eq!((11 as $T).to_str_radix(16u), ~\"b\");\n-        assert_eq!((255 as $T).to_str_radix(16u), ~\"ff\");\n-        assert_eq!((0xff as $T).to_str_radix(10u), ~\"255\");\n+        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_owned());\n+        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_owned());\n+        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_owned());\n+        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_owned());\n+        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_owned());\n+        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_owned());\n+        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_owned());\n     }\n \n     #[test]\n@@ -313,28 +314,28 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8_val.to_str(), ~\"255\");\n+        assert_eq!(u8_val.to_str(), \"255\".to_owned());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8_val.to_str(), ~\"0\");\n+        assert_eq!(u8_val.to_str(), \"0\".to_owned());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16_val.to_str(), ~\"65535\");\n+        assert_eq!(u16_val.to_str(), \"65535\".to_owned());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16_val.to_str(), ~\"0\");\n+        assert_eq!(u16_val.to_str(), \"0\".to_owned());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32_val.to_str(), ~\"4294967295\");\n+        assert_eq!(u32_val.to_str(), \"4294967295\".to_owned());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32_val.to_str(), ~\"0\");\n+        assert_eq!(u32_val.to_str(), \"0\".to_owned());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64_val.to_str(), ~\"18446744073709551615\");\n+        assert_eq!(u64_val.to_str(), \"18446744073709551615\".to_owned());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64_val.to_str(), ~\"0\");\n+        assert_eq!(u64_val.to_str(), \"0\".to_owned());\n     }\n \n     #[test]"}, {"sha": "557e2043381326cc0233e713a0186f68005c5218", "filename": "src/libstd/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -194,7 +194,7 @@ impl<T> Option<T> {\n     /// to the value inside the original.\n     ///\n     /// ```\n-    /// let num_as_str: Option<~str> = Some(~\"10\");\n+    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n     /// // First, cast `Option<~str>` to `Option<&~str>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n     /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n@@ -294,7 +294,7 @@ impl<T> Option<T> {\n     /// Convert an `Option<~str>` into an `Option<uint>`, consuming the original:\n     ///\n     /// ```\n-    /// let num_as_str: Option<~str> = Some(~\"10\");\n+    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n     /// // `Option::map` takes self *by value*, consuming `num_as_str`\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n@@ -630,7 +630,7 @@ mod tests {\n \n     #[test]\n     fn test_get_str() {\n-        let x = ~\"test\";\n+        let x = \"test\".to_owned();\n         let addr_x = x.as_ptr();\n         let opt = Some(x);\n         let y = opt.unwrap();\n@@ -751,7 +751,7 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         assert_eq!(Some(1).unwrap(), 1);\n-        assert_eq!(Some(~\"hello\").unwrap(), ~\"hello\");\n+        assert_eq!(Some(\"hello\".to_owned()).unwrap(), \"hello\".to_owned());\n     }\n \n     #[test]"}, {"sha": "97e01efa3a94366715de870c2b9c63024cc999ef", "filename": "src/libstd/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1525,7 +1525,7 @@ mod tests {\n \n     fn make_rand_name() -> ~str {\n         let mut rng = rand::task_rng();\n-        let n = ~\"TEST\" + rng.gen_ascii_str(10u);\n+        let n = \"TEST\".to_owned() + rng.gen_ascii_str(10u);\n         assert!(getenv(n).is_none());\n         n\n     }\n@@ -1534,7 +1534,7 @@ mod tests {\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n, \"VALUE\");\n-        assert_eq!(getenv(n), option::Some(~\"VALUE\"));\n+        assert_eq!(getenv(n), option::Some(\"VALUE\".to_owned()));\n     }\n \n     #[test]\n@@ -1551,17 +1551,17 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, \"1\");\n         setenv(n, \"2\");\n-        assert_eq!(getenv(n), option::Some(~\"2\"));\n+        assert_eq!(getenv(n), option::Some(\"2\".to_owned()));\n         setenv(n, \"\");\n-        assert_eq!(getenv(n), option::Some(~\"\"));\n+        assert_eq!(getenv(n), option::Some(\"\".to_owned()));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n     // the buffer the variable is copied into is the right size\n     #[test]\n     #[ignore]\n     fn test_getenv_big() {\n-        let mut s = ~\"\";\n+        let mut s = \"\".to_owned();\n         let mut i = 0;\n         while i < 100 {\n             s = s + \"aaaaaaaaaa\";\n@@ -1627,10 +1627,10 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, \"VALUE\");\n-        assert!(!e.contains(&(n.clone(), ~\"VALUE\")));\n+        assert!(!e.contains(&(n.clone(), \"VALUE\".to_owned())));\n \n         e = env();\n-        assert!(e.contains(&(n, ~\"VALUE\")));\n+        assert!(e.contains(&(n, \"VALUE\".to_owned())));\n     }\n \n     #[test]"}, {"sha": "4affea37e35b26fa5c0b7514aca87cf0dc15242f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -459,6 +459,7 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use str;\n+    use str::StrSlice;\n \n     macro_rules! t(\n         (s: $path:expr, $exp:expr) => (\n@@ -766,7 +767,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\".to_owned(), \"e\".to_owned()], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n         t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n@@ -871,7 +872,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\".to_owned(), \"e\".to_owned()], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n     }"}, {"sha": "74ca8dc57859aeccff243bda94d09fc975a181ec", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1314,9 +1314,9 @@ mod tests {\n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n-        assert_eq!(path.display().to_str(), ~\"foo\");\n+        assert_eq!(path.display().to_str(), \"foo\".to_owned());\n         let path = Path::new(b!(\"\\\\\"));\n-        assert_eq!(path.filename_display().to_str(), ~\"\");\n+        assert_eq!(path.filename_display().to_str(), \"\".to_owned());\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_maybe_owned();\n@@ -1577,7 +1577,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\".to_owned(), \"e\".to_owned()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n@@ -1718,7 +1718,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\".to_owned(), \"e\".to_owned()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n            b!(\"a\\\\b\\\\c\\\\d\\\\e\"));"}, {"sha": "668edbcc42f9b13b22c64760d7b41a538c5e1687", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -636,7 +636,8 @@ fn test_repr() {\n     exact_test(&false, \"false\");\n     exact_test(&1.234, \"1.234f64\");\n     exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n-    exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n+    // FIXME What do I do about this one?\n+    exact_test(&(\"he\\u10f3llo\".to_owned()), \"~\\\"he\\\\u10f3llo\\\"\");\n \n     exact_test(&(@10), \"@10\");\n     exact_test(&(~10), \"~10\");\n@@ -658,13 +659,13 @@ fn test_repr() {\n                \"@repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(~P{a:10, b:1.234}),\n                \"~repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(10u8, ~\"hello\"),\n+    exact_test(&(10u8, \"hello\".to_owned()),\n                \"(10u8, ~\\\"hello\\\")\");\n-    exact_test(&(10u16, ~\"hello\"),\n+    exact_test(&(10u16, \"hello\".to_owned()),\n                \"(10u16, ~\\\"hello\\\")\");\n-    exact_test(&(10u32, ~\"hello\"),\n+    exact_test(&(10u32, \"hello\".to_owned()),\n                \"(10u32, ~\\\"hello\\\")\");\n-    exact_test(&(10u64, ~\"hello\"),\n+    exact_test(&(10u64, \"hello\".to_owned()),\n                \"(10u64, ~\\\"hello\\\")\");\n \n     exact_test(&(&[1, 2]), \"&[1, 2]\");"}, {"sha": "0f993598747f0c96bebadc01aaa783fa7f09a552", "filename": "src/libstd/result.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -623,37 +623,41 @@ pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n mod tests {\n     use super::*;\n     use prelude::*;\n+    use str::StrSlice;\n \n     use iter::range;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n-    pub fn op2() -> Result<int, ~str> { Err(~\"sadface\") }\n+    pub fn op2() -> Result<int, ~str> { Err(\"sadface\".to_owned()) }\n \n     #[test]\n     pub fn test_and() {\n         assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n-        assert_eq!(op1().and(Err::<(), ~str>(~\"bad\")).unwrap_err(), ~\"bad\");\n+        assert_eq!(op1().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n \n-        assert_eq!(op2().and(Ok(667)).unwrap_err(), ~\"sadface\");\n-        assert_eq!(op2().and(Err::<(), ~str>(~\"bad\")).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\".to_owned());\n+        assert_eq!(op2().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"sadface\".to_owned());\n     }\n \n     #[test]\n     pub fn test_and_then() {\n         assert_eq!(op1().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap(), 667);\n-        assert_eq!(op1().and_then(|_| Err::<int, ~str>(~\"bad\")).unwrap_err(), ~\"bad\");\n+        assert_eq!(op1().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n+                   \"bad\".to_owned());\n \n-        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(), ~\"sadface\");\n-        assert_eq!(op2().and_then(|_| Err::<int, ~str>(~\"bad\")).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(),\n+                   \"sadface\".to_owned());\n+        assert_eq!(op2().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n+                   \"sadface\".to_owned());\n     }\n \n     #[test]\n     pub fn test_or() {\n         assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n-        assert_eq!(op1().or(Err(~\"bad\")).unwrap(), 666);\n+        assert_eq!(op1().or(Err(\"bad\".to_owned())).unwrap(), 666);\n \n         assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n-        assert_eq!(op2().or(Err(~\"bad\")).unwrap_err(), ~\"bad\");\n+        assert_eq!(op2().or(Err(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n     }\n \n     #[test]\n@@ -662,19 +666,20 @@ mod tests {\n         assert_eq!(op1().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap(), 666);\n \n         assert_eq!(op2().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 667);\n-        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(), ~\"sadface!\");\n+        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(),\n+                   \"sadface!\".to_owned());\n     }\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map(|x| x + \"b\"), Ok(~\"ab\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map(|x| x + \"b\"), Err(~\"a\"));\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Ok(\"ab\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Err(\"a\".to_owned()));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err(|x| x + \"b\"), Ok(~\"a\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map_err(|x| x + \"b\"), Err(~\"ab\"));\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Ok(\"a\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Err(\"ab\".to_owned()));\n     }\n \n     #[test]\n@@ -720,25 +725,25 @@ mod tests {\n     #[test]\n     pub fn test_to_str() {\n         let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(~\"Err\");\n+        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n \n-        assert_eq!(ok.to_str(), ~\"Ok(100)\");\n-        assert_eq!(err.to_str(), ~\"Err(Err)\");\n+        assert_eq!(ok.to_str(), \"Ok(100)\".to_owned());\n+        assert_eq!(err.to_str(), \"Err(Err)\".to_owned());\n     }\n \n     #[test]\n     pub fn test_fmt_default() {\n         let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(~\"Err\");\n+        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n \n-        assert_eq!(format!(\"{}\", ok), ~\"Ok(100)\");\n-        assert_eq!(format!(\"{}\", err), ~\"Err(Err)\");\n+        assert_eq!(format!(\"{}\", ok), \"Ok(100)\".to_owned());\n+        assert_eq!(format!(\"{}\", err), \"Err(Err)\".to_owned());\n     }\n \n     #[test]\n     pub fn test_unwrap_or() {\n         let ok: Result<int, ~str> = Ok(100);\n-        let ok_err: Result<int, ~str> = Err(~\"Err\");\n+        let ok_err: Result<int, ~str> = Err(\"Err\".to_owned());\n \n         assert_eq!(ok.unwrap_or(50), 100);\n         assert_eq!(ok_err.unwrap_or(50), 50);\n@@ -747,15 +752,15 @@ mod tests {\n     #[test]\n     pub fn test_unwrap_or_else() {\n         fn handler(msg: ~str) -> int {\n-            if msg == ~\"I got this.\" {\n+            if msg == \"I got this.\".to_owned() {\n                 50\n             } else {\n                 fail!(\"BadBad\")\n             }\n         }\n \n         let ok: Result<int, ~str> = Ok(100);\n-        let ok_err: Result<int, ~str> = Err(~\"I got this.\");\n+        let ok_err: Result<int, ~str> = Err(\"I got this.\".to_owned());\n \n         assert_eq!(ok.unwrap_or_handle(handler), 100);\n         assert_eq!(ok_err.unwrap_or_handle(handler), 50);\n@@ -765,14 +770,14 @@ mod tests {\n     #[should_fail]\n     pub fn test_unwrap_or_else_failure() {\n         fn handler(msg: ~str) -> int {\n-            if msg == ~\"I got this.\" {\n+            if msg == \"I got this.\".to_owned() {\n                 50\n             } else {\n                 fail!(\"BadBad\")\n             }\n         }\n \n-        let bad_err: Result<int, ~str> = Err(~\"Unrecoverable mess.\");\n+        let bad_err: Result<int, ~str> = Err(\"Unrecoverable mess.\".to_owned());\n         let _ : int = bad_err.unwrap_or_handle(handler);\n     }\n }"}, {"sha": "8b9b8a7498b2db766daffc76a19824ebffb16926", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -67,6 +67,7 @@ mod imp {\n     use clone::Clone;\n     use option::{Option, Some, None};\n     use iter::Iterator;\n+    use str::StrSlice;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n     #[cfg(not(test))] use ptr::RawPtr;"}, {"sha": "f75b5315207ccceed4786ea57d7118e518386526", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -413,11 +413,11 @@ mod test {\n     fn tls() {\n         use local_data;\n         local_data_key!(key: @~str)\n-        local_data::set(key, @~\"data\");\n-        assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n+        local_data::set(key, @\"data\".to_owned());\n+        assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == \"data\".to_owned());\n         local_data_key!(key2: @~str)\n-        local_data::set(key2, @~\"data\");\n-        assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n+        local_data::set(key2, @\"data\".to_owned());\n+        assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == \"data\".to_owned());\n     }\n \n     #[test]"}, {"sha": "6c55195e627286286da86cc4d07d20bae27c8ee7", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1142,7 +1142,7 @@ pub trait OwnedVector<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let v = ~[~\"a\", ~\"b\"];\n+    /// let v = ~[\"a\".to_owned(), \"b\".to_owned()];\n     /// for s in v.move_iter() {\n     ///   // s has type ~str, not &~str\n     ///   println!(\"{}\", s);\n@@ -1602,15 +1602,15 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = ~[~\"foo\", ~\"bar\", ~\"baz\"];\n+    /// let mut v = ~[\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned()];\n     ///\n     /// unsafe {\n-    ///     // `~\"baz\"` is deallocated.\n-    ///     v.unsafe_set(2, ~\"qux\");\n+    ///     // `\"baz\".to_owned()` is deallocated.\n+    ///     v.unsafe_set(2, \"qux\".to_owned());\n     ///\n     ///     // Out of bounds: could cause a crash, or overwriting\n     ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, ~\"oops\");\n+    ///     // v.unsafe_set(10, \"oops\".to_owned());\n     /// }\n     /// ```\n     unsafe fn unsafe_set(self, index: uint, val: T);\n@@ -1622,10 +1622,10 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [~\"foo\", ~\"bar\"];\n+    /// let mut v = [\"foo\".to_owned(), \"bar\".to_owned()];\n     ///\n-    /// // memory leak! `~\"bar\"` is not deallocated.\n-    /// unsafe { v.init_elem(1, ~\"baz\"); }\n+    /// // memory leak! `\"bar\".to_owned()` is not deallocated.\n+    /// unsafe { v.init_elem(1, \"baz\".to_owned()); }\n     /// ```\n     unsafe fn init_elem(self, i: uint, val: T);\n \n@@ -2763,7 +2763,7 @@ mod tests {\n             assert_eq!(it.next(), None);\n         }\n         {\n-            let v = [~\"Hello\"];\n+            let v = [\"Hello\".to_owned()];\n             let mut it = v.permutations();\n             assert_eq!(it.next(), None);\n         }\n@@ -3404,10 +3404,10 @@ mod tests {\n             })\n         )\n         let empty: ~[int] = ~[];\n-        test_show_vec!(empty, ~\"[]\");\n-        test_show_vec!(~[1], ~\"[1]\");\n-        test_show_vec!(~[1, 2, 3], ~\"[1, 2, 3]\");\n-        test_show_vec!(~[~[], ~[1u], ~[1u, 1u]], ~\"[[], [1], [1, 1]]\");\n+        test_show_vec!(empty, \"[]\".to_owned());\n+        test_show_vec!(~[1], \"[1]\".to_owned());\n+        test_show_vec!(~[1, 2, 3], \"[1, 2, 3]\".to_owned());\n+        test_show_vec!(~[~[], ~[1u], ~[1u, 1u]], \"[[], [1], [1, 1]]\".to_owned());\n     }\n \n     #[test]\n@@ -3507,11 +3507,11 @@ mod tests {\n \n         let xs = vec![Foo, Foo, Foo];\n         assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n-                   ~\"~[slice::tests::Foo, slice::tests::Foo]\");\n+                   \"~[slice::tests::Foo, slice::tests::Foo]\".to_owned());\n \n         let xs: [Foo, ..3] = [Foo, Foo, Foo];\n         assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n-                   ~\"~[slice::tests::Foo, slice::tests::Foo]\");\n+                   \"~[slice::tests::Foo, slice::tests::Foo]\".to_owned());\n         cnt = 0;\n         for f in xs.iter() {\n             assert!(*f == Foo);"}, {"sha": "3c03bddb293ed8bc4fb7cc48a454ecc330a93b15", "filename": "src/libstd/str.rs", "status": "modified", "additions": 134, "deletions": 130, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -33,7 +33,7 @@ As an example, here's a few different kinds of strings.\n \n ```rust\n fn main() {\n-    let owned_string = ~\"I am an owned string\";\n+    let owned_string = \"I am an owned string\".to_owned();\n     let borrowed_string1 = \"This string is borrowed with the 'static lifetime\";\n     let borrowed_string2: &str = owned_string;   // owned strings can be borrowed\n }\n@@ -163,7 +163,7 @@ pub trait StrVector {\n \n impl<'a, S: Str> StrVector for &'a [S] {\n     fn concat(&self) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n+        if self.is_empty() { return \"\".to_owned(); }\n \n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n@@ -178,7 +178,7 @@ impl<'a, S: Str> StrVector for &'a [S] {\n     }\n \n     fn connect(&self, sep: &str) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n+        if self.is_empty() { return \"\".to_owned(); }\n \n         // concat is faster\n         if sep.is_empty() { return self.concat(); }\n@@ -974,7 +974,7 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n /// // \ud834\udd1emusic\n /// let mut v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n ///              0x0073, 0x0069, 0x0063];\n-/// assert_eq!(str::from_utf16(v), Some(~\"\ud834\udd1emusic\"));\n+/// assert_eq!(str::from_utf16(v), Some(\"\ud834\udd1emusic\".to_owned()));\n ///\n /// // \ud834\udd1emu<invalid>ic\n /// v[4] = 0xD800;\n@@ -1004,7 +1004,7 @@ pub fn from_utf16(v: &[u16]) -> Option<~str> {\n ///          0xD834];\n ///\n /// assert_eq!(str::from_utf16_lossy(v),\n-///            ~\"\ud834\udd1emus\\uFFFDic\\uFFFD\");\n+///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_owned());\n /// ```\n pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n@@ -1451,7 +1451,7 @@ pub mod raw {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n-            assert_eq!(c, ~\"AAA\");\n+            assert_eq!(c, \"AAA\".to_owned());\n         }\n     }\n }\n@@ -2776,7 +2776,7 @@ impl<'a> Default for &'a str {\n }\n \n impl Default for ~str {\n-    fn default() -> ~str { ~\"\" }\n+    fn default() -> ~str { \"\".to_owned() }\n }\n \n #[cfg(test)]\n@@ -2789,9 +2789,9 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        assert!((eq(&~\"\", &~\"\")));\n-        assert!((eq(&~\"foo\", &~\"foo\")));\n-        assert!((!eq(&~\"foo\", &~\"bar\")));\n+        assert!((eq(&\"\".to_owned(), &\"\".to_owned())));\n+        assert!((eq(&\"foo\".to_owned(), &\"foo\".to_owned())));\n+        assert!((!eq(&\"foo\".to_owned(), &\"bar\".to_owned())));\n     }\n \n     #[test]\n@@ -2851,17 +2851,17 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let empty = ~\"\";\n+        let empty = \"\".to_owned();\n         let s: ~str = empty.chars().collect();\n         assert_eq!(empty, s);\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_owned();\n         let s: ~str = data.chars().collect();\n         assert_eq!(data, s);\n     }\n \n     #[test]\n     fn test_into_bytes() {\n-        let data = ~\"asdf\";\n+        let data = \"asdf\".to_owned();\n         let buf = data.into_bytes();\n         assert_eq!(bytes!(\"asdf\"), buf.as_slice());\n     }\n@@ -2877,7 +2877,7 @@ mod tests {\n         assert_eq!(data.slice(2u, 6u).find_str(\"ab\"), Some(3u - 2u));\n         assert!(data.slice(2u, 4u).find_str(\"ab\").is_none());\n \n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let mut data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         data = data + data;\n         assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n         assert_eq!(data.slice(0u, 43u).find_str(\"\"), Some(0u));\n@@ -2914,22 +2914,24 @@ mod tests {\n         fn t(v: &[~str], s: &str) {\n             assert_eq!(v.concat(), s.to_str());\n         }\n-        t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], \"youknowI'mnogood\");\n+        t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n+          \"no\".to_owned(), \"good\".to_owned()], \"youknowI'mnogood\");\n         let v: &[~str] = [];\n         t(v, \"\");\n-        t([~\"hi\"], \"hi\");\n+        t([\"hi\".to_owned()], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep), s.to_str());\n         }\n-        t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n+        t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n+           \"no\".to_owned(), \"good\".to_owned()],\n           \" \", \"you know I'm no good\");\n         let v: &[~str] = [];\n         t(v, \" \", \"\");\n-        t([~\"hi\"], \" \", \"hi\");\n+        t([\"hi\".to_owned()], \" \", \"hi\");\n     }\n \n     #[test]\n@@ -2956,11 +2958,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert_eq!(\"x\".repeat(4), ~\"xxxx\");\n-        assert_eq!(\"hi\".repeat(4), ~\"hihihihi\");\n-        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n-        assert_eq!(\"\".repeat(4), ~\"\");\n-        assert_eq!(\"hi\".repeat(0), ~\"\");\n+        assert_eq!(\"x\".repeat(4), \"xxxx\".to_owned());\n+        assert_eq!(\"hi\".repeat(4), \"hihihihi\".to_owned());\n+        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), \"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\".to_owned());\n+        assert_eq!(\"\".repeat(4), \"\".to_owned());\n+        assert_eq!(\"hi\".repeat(0), \"\".to_owned());\n     }\n \n     #[test]\n@@ -3022,51 +3024,51 @@ mod tests {\n     #[test]\n     fn test_replace() {\n         let a = \"a\";\n-        assert_eq!(\"\".replace(a, \"b\"), ~\"\");\n-        assert_eq!(\"a\".replace(a, \"b\"), ~\"b\");\n-        assert_eq!(\"ab\".replace(a, \"b\"), ~\"bb\");\n+        assert_eq!(\"\".replace(a, \"b\"), \"\".to_owned());\n+        assert_eq!(\"a\".replace(a, \"b\"), \"b\".to_owned());\n+        assert_eq!(\"ab\".replace(a, \"b\"), \"bb\".to_owned());\n         let test = \"test\";\n         assert!(\" test test \".replace(test, \"toast\") ==\n-            ~\" toast toast \");\n-        assert_eq!(\" test test \".replace(test, \"\"), ~\"   \");\n+            \" toast toast \".to_owned());\n+        assert_eq!(\" test test \".replace(test, \"\"), \"   \".to_owned());\n     }\n \n     #[test]\n     fn test_replace_2a() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n \n-        let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n-        let a2 = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let a = \"\u0e1b\u0e23\u0e30\u0e40\".to_owned();\n+        let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n         assert_eq!(data.replace(a, repl), a2);\n     }\n \n     #[test]\n     fn test_replace_2b() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n \n-        let b = ~\"\u0e30\u0e40\";\n-        let b2 = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let b = \"\u0e30\u0e40\".to_owned();\n+        let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n         assert_eq!(data.replace(b, repl), b2);\n     }\n \n     #[test]\n     fn test_replace_2c() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n \n-        let c = ~\"\u4e2d\u534e\";\n-        let c2 = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let c = \"\u4e2d\u534e\".to_owned();\n+        let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n         assert_eq!(data.replace(c, repl), c2);\n     }\n \n     #[test]\n     fn test_replace_2d() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n \n-        let d = ~\"\u0e44\u0e17\u534e\";\n+        let d = \"\u0e44\u0e17\u534e\".to_owned();\n         assert_eq!(data.replace(d, repl), data);\n     }\n \n@@ -3331,7 +3333,7 @@ mod tests {\n             let a = ~[65, 65, 65, 65, 65, 65, 65, 0];\n             let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n-            assert_eq!(c, ~\"AAAAAAA\");\n+            assert_eq!(c, \"AAAAAAA\".to_owned());\n         }\n     }\n \n@@ -3353,7 +3355,7 @@ mod tests {\n     fn test_as_bytes_fail() {\n         // Don't double free. (I'm not sure if this exercises the\n         // original problem code path anymore.)\n-        let s = ~\"\";\n+        let s = \"\".to_owned();\n         let _bytes = s.as_bytes();\n         fail!();\n     }\n@@ -3395,7 +3397,7 @@ mod tests {\n \n     #[test]\n     fn vec_str_conversions() {\n-        let s1: ~str = ~\"All mimsy were the borogoves\";\n+        let s1: ~str = \"All mimsy were the borogoves\".to_owned();\n \n         let v: ~[u8] = s1.as_bytes().to_owned();\n         let s2: ~str = from_utf8(v).unwrap().to_owned();\n@@ -3423,7 +3425,7 @@ mod tests {\n         assert!(!\"abcde\".contains(\"def\"));\n         assert!(!\"\".contains(\"a\"));\n \n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         assert!(data.contains(\"\u0e1b\u0e23\u0e30\u0e40\"));\n         assert!(data.contains(\"\u0e30\u0e40\"));\n         assert!(data.contains(\"\u4e2d\u534e\"));\n@@ -3441,21 +3443,21 @@ mod tests {\n     #[test]\n     fn test_utf16() {\n         let pairs =\n-            [(~\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\",\n+            [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_owned(),\n               ~[0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                 0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                 0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                 0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n-             (~\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\",\n+             (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_owned(),\n               ~[0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                 0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                 0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                 0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                 0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                 0x000a_u16]),\n \n-             (~\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\",\n+             (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_owned(),\n               ~[0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                 0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                 0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n@@ -3464,7 +3466,7 @@ mod tests {\n                 0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n                 0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n-             (~\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\",\n+             (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_owned(),\n               ~[0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                 0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                 0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n@@ -3477,7 +3479,7 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n-             (~\"\\U00020000\",\n+             (\"\\U00020000\".to_owned(),\n               ~[0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n@@ -3512,15 +3514,15 @@ mod tests {\n     fn test_utf16_lossy() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(from_utf16_lossy([0xD800]), ~\"\\uFFFD\");\n+        assert_eq!(from_utf16_lossy([0xD800]), \"\\uFFFD\".to_owned());\n         // lead + lead\n-        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), ~\"\\uFFFD\\uFFFD\");\n+        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), \"\\uFFFD\\uFFFD\".to_owned());\n \n         // isolated trail\n-        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), ~\"a\\uFFFD\");\n+        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), \"a\\uFFFD\".to_owned());\n \n         // general\n-        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]), ~\"\\uFFFD\ud801\udc8b\\uFFFD\");\n+        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]), \"\\uFFFD\ud801\udc8b\\uFFFD\".to_owned());\n     }\n \n     #[test]\n@@ -3543,7 +3545,7 @@ mod tests {\n \n     #[test]\n     fn test_char_at() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for ch in v.iter() {\n@@ -3554,7 +3556,7 @@ mod tests {\n \n     #[test]\n     fn test_char_at_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n         for ch in v.rev_iter() {\n@@ -3565,27 +3567,27 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(\"abc\".escape_unicode(), ~\"\\\\x61\\\\x62\\\\x63\");\n-        assert_eq!(\"a c\".escape_unicode(), ~\"\\\\x61\\\\x20\\\\x63\");\n-        assert_eq!(\"\\r\\n\\t\".escape_unicode(), ~\"\\\\x0d\\\\x0a\\\\x09\");\n-        assert_eq!(\"'\\\"\\\\\".escape_unicode(), ~\"\\\\x27\\\\x22\\\\x5c\");\n-        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n-        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), ~\"\\\\u0100\\\\uffff\");\n-        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(), ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert_eq!(\"ab\\ufb00\".escape_unicode(), ~\"\\\\x61\\\\x62\\\\ufb00\");\n-        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), ~\"\\\\U0001d4ea\\\\x0d\");\n+        assert_eq!(\"abc\".escape_unicode(), \"\\\\x61\\\\x62\\\\x63\".to_owned());\n+        assert_eq!(\"a c\".escape_unicode(), \"\\\\x61\\\\x20\\\\x63\".to_owned());\n+        assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\x0d\\\\x0a\\\\x09\".to_owned());\n+        assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\x27\\\\x22\\\\x5c\".to_owned());\n+        assert_eq!(\"\\x00\\x01\\xfe\\xff\".escape_unicode(), \"\\\\x00\\\\x01\\\\xfe\\\\xff\".to_owned());\n+        assert_eq!(\"\\u0100\\uffff\".escape_unicode(), \"\\\\u0100\\\\uffff\".to_owned());\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_unicode(), \"\\\\U00010000\\\\U0010ffff\".to_owned());\n+        assert_eq!(\"ab\\ufb00\".escape_unicode(), \"\\\\x61\\\\x62\\\\ufb00\".to_owned());\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_unicode(), \"\\\\U0001d4ea\\\\x0d\".to_owned());\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert_eq!(\"abc\".escape_default(), ~\"abc\");\n-        assert_eq!(\"a c\".escape_default(), ~\"a c\");\n-        assert_eq!(\"\\r\\n\\t\".escape_default(), ~\"\\\\r\\\\n\\\\t\");\n-        assert_eq!(\"'\\\"\\\\\".escape_default(), ~\"\\\\'\\\\\\\"\\\\\\\\\");\n-        assert_eq!(\"\\u0100\\uffff\".escape_default(), ~\"\\\\u0100\\\\uffff\");\n-        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(), ~\"\\\\U00010000\\\\U0010ffff\");\n-        assert_eq!(\"ab\\ufb00\".escape_default(), ~\"ab\\\\ufb00\");\n-        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), ~\"\\\\U0001d4ea\\\\r\");\n+        assert_eq!(\"abc\".escape_default(), \"abc\".to_owned());\n+        assert_eq!(\"a c\".escape_default(), \"a c\".to_owned());\n+        assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\".to_owned());\n+        assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\".to_owned());\n+        assert_eq!(\"\\u0100\\uffff\".escape_default(), \"\\\\u0100\\\\uffff\".to_owned());\n+        assert_eq!(\"\\U00010000\\U0010ffff\".escape_default(), \"\\\\U00010000\\\\U0010ffff\".to_owned());\n+        assert_eq!(\"ab\\ufb00\".escape_default(), \"ab\\\\ufb00\".to_owned());\n+        assert_eq!(\"\\U0001d4ea\\r\".escape_default(), \"\\\\U0001d4ea\\\\r\".to_owned());\n     }\n \n     #[test]\n@@ -3599,7 +3601,7 @@ mod tests {\n \n     #[test]\n     fn test_char_range_at() {\n-        let data = ~\"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n+        let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\".to_owned();\n         assert_eq!('b', data.char_range_at(0).ch);\n         assert_eq!('\u00a2', data.char_range_at(1).ch);\n         assert_eq!('\u20ac', data.char_range_at(3).ch);\n@@ -3629,15 +3631,15 @@ mod tests {\n         );\n \n         t!(\"foo\",  \"bar\", \"foobar\");\n-        t!(\"foo\", ~\"bar\", \"foobar\");\n+        t!(\"foo\", \"bar\".to_owned(), \"foobar\");\n         t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"\u534eVi\u1ec7t Nam\".to_owned(), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n     #[test]\n     fn test_iterator() {\n         use iter::*;\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n@@ -3653,7 +3655,7 @@ mod tests {\n     #[test]\n     fn test_rev_iterator() {\n         use iter::*;\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = ~['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n@@ -3676,7 +3678,7 @@ mod tests {\n \n     #[test]\n     fn test_bytesator() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n@@ -3692,7 +3694,7 @@ mod tests {\n \n     #[test]\n     fn test_bytes_revator() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n@@ -3849,30 +3851,30 @@ mod tests {\n \n     #[test]\n     fn test_nfd_chars() {\n-        assert_eq!(\"abc\".nfd_chars().collect::<~str>(), ~\"abc\");\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<~str>(), ~\"d\\u0307\\u01c4\");\n-        assert_eq!(\"\\u2026\".nfd_chars().collect::<~str>(), ~\"\\u2026\");\n-        assert_eq!(\"\\u2126\".nfd_chars().collect::<~str>(), ~\"\\u03a9\");\n-        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"a\\u0301\".nfd_chars().collect::<~str>(), ~\"a\\u0301\");\n-        assert_eq!(\"\\u0301a\".nfd_chars().collect::<~str>(), ~\"\\u0301a\");\n-        assert_eq!(\"\\ud4db\".nfd_chars().collect::<~str>(), ~\"\\u1111\\u1171\\u11b6\");\n-        assert_eq!(\"\\uac1c\".nfd_chars().collect::<~str>(), ~\"\\u1100\\u1162\");\n+        assert_eq!(\"abc\".nfd_chars().collect::<~str>(), \"abc\".to_owned());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<~str>(), \"d\\u0307\\u01c4\".to_owned());\n+        assert_eq!(\"\\u2026\".nfd_chars().collect::<~str>(), \"\\u2026\".to_owned());\n+        assert_eq!(\"\\u2126\".nfd_chars().collect::<~str>(), \"\\u03a9\".to_owned());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n+        assert_eq!(\"a\\u0301\".nfd_chars().collect::<~str>(), \"a\\u0301\".to_owned());\n+        assert_eq!(\"\\u0301a\".nfd_chars().collect::<~str>(), \"\\u0301a\".to_owned());\n+        assert_eq!(\"\\ud4db\".nfd_chars().collect::<~str>(), \"\\u1111\\u1171\\u11b6\".to_owned());\n+        assert_eq!(\"\\uac1c\".nfd_chars().collect::<~str>(), \"\\u1100\\u1162\".to_owned());\n     }\n \n     #[test]\n     fn test_nfkd_chars() {\n-        assert_eq!(\"abc\".nfkd_chars().collect::<~str>(), ~\"abc\");\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<~str>(), ~\"d\\u0307DZ\\u030c\");\n-        assert_eq!(\"\\u2026\".nfkd_chars().collect::<~str>(), ~\"...\");\n-        assert_eq!(\"\\u2126\".nfkd_chars().collect::<~str>(), ~\"\\u03a9\");\n-        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<~str>(), ~\"a\\u0301\");\n-        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<~str>(), ~\"\\u0301a\");\n-        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<~str>(), ~\"\\u1111\\u1171\\u11b6\");\n-        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<~str>(), ~\"\\u1100\\u1162\");\n+        assert_eq!(\"abc\".nfkd_chars().collect::<~str>(), \"abc\".to_owned());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<~str>(), \"d\\u0307DZ\\u030c\".to_owned());\n+        assert_eq!(\"\\u2026\".nfkd_chars().collect::<~str>(), \"...\".to_owned());\n+        assert_eq!(\"\\u2126\".nfkd_chars().collect::<~str>(), \"\\u03a9\".to_owned());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<~str>(), \"d\\u0323\\u0307\".to_owned());\n+        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<~str>(), \"a\\u0301\".to_owned());\n+        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<~str>(), \"\\u0301a\".to_owned());\n+        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<~str>(), \"\\u1111\\u1171\\u11b6\".to_owned());\n+        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<~str>(), \"\\u1100\\u1162\".to_owned());\n     }\n \n     #[test]\n@@ -3926,9 +3928,9 @@ mod tests {\n             v.iter().map(|x| x.len()).sum()\n         }\n \n-        let s = ~\"01234\";\n+        let s = \"01234\".to_owned();\n         assert_eq!(5, sum_len([\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len([~\"01\", ~\"2\", ~\"34\", ~\"\"]));\n+        assert_eq!(5, sum_len([\"01\".to_owned(), \"2\".to_owned(), \"34\".to_owned(), \"\".to_owned()]));\n         assert_eq!(5, sum_len([s.as_slice()]));\n     }\n \n@@ -3947,10 +3949,10 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8_owned() {\n         let xs = bytes!(\"hello\").to_owned();\n-        assert_eq!(from_utf8_owned(xs), Some(~\"hello\"));\n+        assert_eq!(from_utf8_owned(xs), Some(\"hello\".to_owned()));\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\").to_owned();\n-        assert_eq!(from_utf8_owned(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(from_utf8_owned(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned()));\n \n         let xs = bytes!(\"hello\", 0xff).to_owned();\n         assert_eq!(from_utf8_owned(xs), None);\n@@ -3965,51 +3967,53 @@ mod tests {\n         assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"Hello\\uFFFD There\\uFFFD Goodbye\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD There\\uFFFD Goodbye\".to_owned()));\n \n         let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\".to_owned()));\n \n         let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\".to_owned()));\n \n         let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\".to_owned()));\n \n         let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\".to_owned()));\n \n         let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n+                                               foo\\U00010000bar\".to_owned()));\n \n         // surrogates\n         let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n+                                               \\uFFFD\\uFFFD\\uFFFDbar\".to_owned()));\n     }\n \n     #[test]\n     fn test_from_str() {\n       let owned: Option<~str> = from_str(&\"string\");\n-      assert_eq!(owned, Some(~\"string\"));\n+      assert_eq!(owned, Some(\"string\".to_owned()));\n     }\n \n     #[test]\n     fn test_maybe_owned_traits() {\n         let s = Slice(\"abcde\");\n         assert_eq!(s.len(), 5);\n         assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(s.to_str(), ~\"abcde\");\n-        assert_eq!(format!(\"{}\", s), ~\"abcde\");\n-        assert!(s.lt(&Owned(~\"bcdef\")));\n+        assert_eq!(s.to_str(), \"abcde\".to_owned());\n+        assert_eq!(format!(\"{}\", s), \"abcde\".to_owned());\n+        assert!(s.lt(&Owned(\"bcdef\".to_owned())));\n         assert_eq!(Slice(\"\"), Default::default());\n \n-        let o = Owned(~\"abcde\");\n+        let o = Owned(\"abcde\".to_owned());\n         assert_eq!(o.len(), 5);\n         assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(o.to_str(), ~\"abcde\");\n-        assert_eq!(format!(\"{}\", o), ~\"abcde\");\n+        assert_eq!(o.to_str(), \"abcde\".to_owned());\n+        assert_eq!(format!(\"{}\", o), \"abcde\".to_owned());\n         assert!(o.lt(&Slice(\"bcdef\")));\n-        assert_eq!(Owned(~\"\"), Default::default());\n+        assert_eq!(Owned(\"\".to_owned()), Default::default());\n \n         assert!(s.cmp(&o) == Equal);\n         assert!(s.equiv(&o));\n@@ -4024,31 +4028,31 @@ mod tests {\n         assert!(s.is_slice());\n         assert!(!s.is_owned());\n \n-        let o = Owned(~\"abcde\");\n+        let o = Owned(\"abcde\".to_owned());\n         assert!(!o.is_slice());\n         assert!(o.is_owned());\n     }\n \n     #[test]\n     fn test_maybe_owned_clone() {\n-        assert_eq!(Owned(~\"abcde\"), Slice(\"abcde\").clone());\n-        assert_eq!(Owned(~\"abcde\"), Owned(~\"abcde\").clone());\n+        assert_eq!(Owned(\"abcde\".to_owned()), Slice(\"abcde\").clone());\n+        assert_eq!(Owned(\"abcde\".to_owned()), Owned(\"abcde\".to_owned()).clone());\n         assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").clone());\n-        assert_eq!(Slice(\"abcde\"), Owned(~\"abcde\").clone());\n+        assert_eq!(Slice(\"abcde\"), Owned(\"abcde\".to_owned()).clone());\n     }\n \n     #[test]\n     fn test_maybe_owned_into_owned() {\n-        assert_eq!(Slice(\"abcde\").into_owned(), ~\"abcde\");\n-        assert_eq!(Owned(~\"abcde\").into_owned(), ~\"abcde\");\n+        assert_eq!(Slice(\"abcde\").into_owned(), \"abcde\".to_owned());\n+        assert_eq!(Owned(\"abcde\".to_owned()).into_owned(), \"abcde\".to_owned());\n     }\n \n     #[test]\n     fn test_into_maybe_owned() {\n         assert_eq!(\"abcde\".into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!((~\"abcde\").into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!(\"abcde\".into_maybe_owned(), Owned(~\"abcde\"));\n-        assert_eq!((~\"abcde\").into_maybe_owned(), Owned(~\"abcde\"));\n+        assert_eq!((\"abcde\".to_owned()).into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!(\"abcde\".into_maybe_owned(), Owned(\"abcde\".to_owned()));\n+        assert_eq!((\"abcde\".to_owned()).into_maybe_owned(), Owned(\"abcde\".to_owned()));\n     }\n }\n "}, {"sha": "7ac7700d8d348876da178802aabdd3dc225db52d", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -181,12 +181,12 @@ mod tests {\n     #[test]\n     fn arclike_newN() {\n         // Tests that the many-refcounts-at-once constructors don't leak.\n-        let _ = UnsafeArc::new2(~~\"hello\");\n-        let x = UnsafeArc::newN(~~\"hello\", 0);\n+        let _ = UnsafeArc::new2(\"hello\".to_owned().to_owned());\n+        let x = UnsafeArc::newN(\"hello\".to_owned().to_owned(), 0);\n         assert_eq!(x.len(), 0)\n-        let x = UnsafeArc::newN(~~\"hello\", 1);\n+        let x = UnsafeArc::newN(\"hello\".to_owned().to_owned(), 1);\n         assert_eq!(x.len(), 1)\n-        let x = UnsafeArc::newN(~~\"hello\", 10);\n+        let x = UnsafeArc::newN(\"hello\".to_owned().to_owned(), 10);\n         assert_eq!(x.len(), 10)\n     }\n }"}, {"sha": "610df320fa52464c2eead07b7a091c5d636b75a7", "filename": "src/libstd/task.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -48,6 +48,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use result;\n+#[cfg(test)] use str::StrSlice;\n \n /// Indicates the manner in which a task exited.\n ///\n@@ -297,7 +298,7 @@ fn test_unnamed_task() {\n \n #[test]\n fn test_owned_named_task() {\n-    task().named(~\"ada lovelace\").spawn(proc() {\n+    task().named(\"ada lovelace\".to_owned()).spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n@@ -369,7 +370,7 @@ fn test_back_to_the_future_result() {\n #[test]\n fn test_try_success() {\n     match try(proc() {\n-        ~\"Success!\"\n+        \"Success!\".to_owned()\n     }).as_ref().map(|s| s.as_slice()) {\n         result::Ok(\"Success!\") => (),\n         _ => fail!()\n@@ -499,12 +500,12 @@ fn test_try_fail_message_static_str() {\n #[test]\n fn test_try_fail_message_owned_str() {\n     match try(proc() {\n-        fail!(~\"owned string\");\n+        fail!(\"owned string\".to_owned());\n     }) {\n         Err(e) => {\n             type T = ~str;\n             assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), ~\"owned string\");\n+            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_owned());\n         }\n         Ok(()) => fail!()\n     }"}, {"sha": "d29b0b3b07cbbdbf4bc8764074a6b026789eed76", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -35,26 +35,27 @@ impl<T: fmt::Show> ToStr for T {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_str(), ~\"1\");\n-        assert_eq!((-1i).to_str(), ~\"-1\");\n-        assert_eq!(200u.to_str(), ~\"200\");\n-        assert_eq!(2u8.to_str(), ~\"2\");\n-        assert_eq!(true.to_str(), ~\"true\");\n-        assert_eq!(false.to_str(), ~\"false\");\n-        assert_eq!(().to_str(), ~\"()\");\n-        assert_eq!((~\"hi\").to_str(), ~\"hi\");\n+        assert_eq!(1i.to_str(), \"1\".to_owned());\n+        assert_eq!((-1i).to_str(), \"-1\".to_owned());\n+        assert_eq!(200u.to_str(), \"200\".to_owned());\n+        assert_eq!(2u8.to_str(), \"2\".to_owned());\n+        assert_eq!(true.to_str(), \"true\".to_owned());\n+        assert_eq!(false.to_str(), \"false\".to_owned());\n+        assert_eq!(().to_str(), \"()\".to_owned());\n+        assert_eq!((\"hi\".to_owned()).to_str(), \"hi\".to_owned());\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = ~[];\n-        assert_eq!(x.to_str(), ~\"[]\");\n-        assert_eq!((~[1]).to_str(), ~\"[1]\");\n-        assert_eq!((~[1, 2, 3]).to_str(), ~\"[1, 2, 3]\");\n+        assert_eq!(x.to_str(), \"[]\".to_owned());\n+        assert_eq!((~[1]).to_str(), \"[1]\".to_owned());\n+        assert_eq!((~[1, 2, 3]).to_str(), \"[1, 2, 3]\".to_owned());\n         assert!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n-               ~\"[[], [1], [1, 1]]\");\n+               \"[[], [1], [1, 1]]\".to_owned());\n     }\n }"}, {"sha": "cf63ea43fdb3c7cb4720d688b3f48a7edacaac0e", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -266,10 +266,11 @@ mod tests {\n     use super::*;\n     use clone::Clone;\n     use cmp::*;\n+    use str::StrSlice;\n \n     #[test]\n     fn test_clone() {\n-        let a = (1, ~\"2\");\n+        let a = (1, \"2\".to_owned());\n         let b = a.clone();\n         assert_eq!(a, b);\n     }\n@@ -342,8 +343,8 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        assert_eq!(format!(\"{}\", (1,)), ~\"(1,)\");\n-        assert_eq!(format!(\"{}\", (1, true)), ~\"(1, true)\");\n-        assert_eq!(format!(\"{}\", (1, ~\"hi\", true)), ~\"(1, hi, true)\");\n+        assert_eq!(format!(\"{}\", (1,)), \"(1,)\".to_owned());\n+        assert_eq!(format!(\"{}\", (1, true)), \"(1, true)\".to_owned());\n+        assert_eq!(format!(\"{}\", (1, \"hi\".to_owned(), true)), \"(1, hi, true)\".to_owned());\n     }\n }"}, {"sha": "585bed83101dd75b0288b8002a08ed57a1da9b9d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -626,7 +626,7 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v = vec!(~\"a\", ~\"b\");\n+    /// let v = vec!(\"a\".to_owned(), \"b\".to_owned());\n     /// for s in v.move_iter() {\n     ///     // s has type ~str, not &~str\n     ///     println!(\"{}\", s);\n@@ -830,13 +830,13 @@ impl<T> Vec<T> {\n     ///\n     /// # Example\n     /// ```rust\n-    /// let mut v = vec!(~\"foo\", ~\"bar\", ~\"baz\", ~\"qux\");\n+    /// let mut v = vec!(\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned(), \"qux\".to_owned());\n     ///\n-    /// assert_eq!(v.swap_remove(1), Some(~\"bar\"));\n-    /// assert_eq!(v, vec!(~\"foo\", ~\"qux\", ~\"baz\"));\n+    /// assert_eq!(v.swap_remove(1), Some(\"bar\".to_owned()));\n+    /// assert_eq!(v, vec!(\"foo\".to_owned(), \"qux\".to_owned(), \"baz\".to_owned()));\n     ///\n-    /// assert_eq!(v.swap_remove(0), Some(~\"foo\"));\n-    /// assert_eq!(v, vec!(~\"baz\", ~\"qux\"));\n+    /// assert_eq!(v.swap_remove(0), Some(\"foo\".to_owned()));\n+    /// assert_eq!(v, vec!(\"baz\".to_owned(), \"qux\".to_owned()));\n     ///\n     /// assert_eq!(v.swap_remove(2), None);\n     /// ```"}, {"sha": "6cc98cd69cafc927cd194b18e52a6e1a7ee5b96f", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -60,10 +60,10 @@ mod test {\n     pub fn DuplexStream1() {\n         let (left, right) = duplex();\n \n-        left.send(~\"abc\");\n+        left.send(\"abc\".to_owned());\n         right.send(123);\n \n         assert!(left.recv() == 123);\n-        assert!(right.recv() == ~\"abc\");\n+        assert!(right.recv() == \"abc\".to_owned());\n     }\n }"}, {"sha": "2836f9cb4be82d0246f64ec1f539eb55360a1a03", "filename": "src/libsync/future.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -143,34 +143,34 @@ mod test {\n \n     #[test]\n     fn test_from_value() {\n-        let mut f = Future::from_value(~\"snail\");\n-        assert_eq!(f.get(), ~\"snail\");\n+        let mut f = Future::from_value(\"snail\".to_owned());\n+        assert_eq!(f.get(), \"snail\".to_owned());\n     }\n \n     #[test]\n     fn test_from_receiver() {\n         let (tx, rx) = channel();\n-        tx.send(~\"whale\");\n+        tx.send(\"whale\".to_owned());\n         let mut f = Future::from_receiver(rx);\n-        assert_eq!(f.get(), ~\"whale\");\n+        assert_eq!(f.get(), \"whale\".to_owned());\n     }\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = Future::from_fn(proc() ~\"brail\");\n-        assert_eq!(f.get(), ~\"brail\");\n+        let mut f = Future::from_fn(proc() \"brail\".to_owned());\n+        assert_eq!(f.get(), \"brail\".to_owned());\n     }\n \n     #[test]\n     fn test_interface_get() {\n-        let mut f = Future::from_value(~\"fail\");\n-        assert_eq!(f.get(), ~\"fail\");\n+        let mut f = Future::from_value(\"fail\".to_owned());\n+        assert_eq!(f.get(), \"fail\".to_owned());\n     }\n \n     #[test]\n     fn test_interface_unwrap() {\n-        let f = Future::from_value(~\"fail\");\n-        assert_eq!(f.unwrap(), ~\"fail\");\n+        let f = Future::from_value(\"fail\".to_owned());\n+        assert_eq!(f.unwrap(), \"fail\".to_owned());\n     }\n \n     #[test]\n@@ -181,8 +181,8 @@ mod test {\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = Future::spawn(proc() ~\"bale\");\n-        assert_eq!(f.get(), ~\"bale\");\n+        let mut f = Future::spawn(proc() \"bale\".to_owned());\n+        assert_eq!(f.get(), \"bale\".to_owned());\n     }\n \n     #[test]"}, {"sha": "437f865b449e2fb01e62016cc5e20aa0b5cf960b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -187,7 +187,7 @@ pub fn uint_ty_max(t: UintTy) -> u64 {\n }\n \n pub fn float_ty_to_str(t: FloatTy) -> ~str {\n-    match t { TyF32 => ~\"f32\", TyF64 => ~\"f64\" }\n+    match t { TyF32 => \"f32\".to_owned(), TyF64 => \"f64\".to_owned() }\n }\n \n pub fn is_call_expr(e: @Expr) -> bool {"}, {"sha": "760310e81d3e9d76ce7c8d2c10606295aec74ccb", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -354,7 +354,7 @@ impl CodeMap {\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {\n         if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n-            return ~\"no-location\";\n+            return \"no-location\".to_owned();\n         }\n \n         let lo = self.lookup_char_pos_adj(sp.lo);\n@@ -515,19 +515,19 @@ mod test {\n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(\"blork.rs\".to_owned(),\"first line.\\nsecond line\".to_owned());\n         fm.next_line(BytePos(0));\n-        assert_eq!(&fm.get_line(0),&~\"first line.\");\n+        assert_eq!(&fm.get_line(0),&\"first line.\".to_owned());\n         // TESTING BROKEN BEHAVIOR:\n         fm.next_line(BytePos(10));\n-        assert_eq!(&fm.get_line(1),&~\".\");\n+        assert_eq!(&fm.get_line(1),&\".\".to_owned());\n     }\n \n     #[test]\n     #[should_fail]\n     fn t2 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(\"blork.rs\".to_owned(),\"first line.\\nsecond line\".to_owned());\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n         fm.next_line(BytePos(10));\n@@ -536,9 +536,9 @@ mod test {\n \n     fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new();\n-        let fm1 = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n-        let fm2 = cm.new_filemap(~\"empty.rs\",~\"\");\n-        let fm3 = cm.new_filemap(~\"blork2.rs\",~\"first line.\\nsecond line\");\n+        let fm1 = cm.new_filemap(\"blork.rs\".to_owned(),\"first line.\\nsecond line\".to_owned());\n+        let fm2 = cm.new_filemap(\"empty.rs\".to_owned(),\"\".to_owned());\n+        let fm3 = cm.new_filemap(\"blork2.rs\".to_owned(),\"first line.\\nsecond line\".to_owned());\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(12));\n@@ -555,11 +555,11 @@ mod test {\n         let cm = init_code_map();\n \n         let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n-        assert_eq!(fmabp1.fm.name, ~\"blork.rs\");\n+        assert_eq!(fmabp1.fm.name, \"blork.rs\".to_owned());\n         assert_eq!(fmabp1.pos, BytePos(22));\n \n         let fmabp2 = cm.lookup_byte_offset(BytePos(24));\n-        assert_eq!(fmabp2.fm.name, ~\"blork2.rs\");\n+        assert_eq!(fmabp2.fm.name, \"blork2.rs\".to_owned());\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n \n@@ -581,21 +581,21 @@ mod test {\n         let cm = init_code_map();\n \n         let loc1 = cm.lookup_char_pos(BytePos(22));\n-        assert_eq!(loc1.file.name, ~\"blork.rs\");\n+        assert_eq!(loc1.file.name, \"blork.rs\".to_owned());\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n         let loc2 = cm.lookup_char_pos(BytePos(24));\n-        assert_eq!(loc2.file.name, ~\"blork2.rs\");\n+        assert_eq!(loc2.file.name, \"blork2.rs\".to_owned());\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n     }\n \n     fn init_code_map_mbc() -> CodeMap {\n         let cm = CodeMap::new();\n         // \u20ac is a three byte utf8 char.\n-        let fm1 = cm.new_filemap(~\"blork.rs\",~\"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\");\n-        let fm2 = cm.new_filemap(~\"blork2.rs\",~\"first line\u20ac\u20ac.\\n\u20ac second line\");\n+        let fm1 = cm.new_filemap(\"blork.rs\".to_owned(),\"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_owned());\n+        let fm2 = cm.new_filemap(\"blork2.rs\".to_owned(),\"first line\u20ac\u20ac.\\n\u20ac second line\".to_owned());\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(22));\n@@ -639,7 +639,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n         let file_lines = cm.span_to_lines(span);\n \n-        assert_eq!(file_lines.file.name, ~\"blork.rs\");\n+        assert_eq!(file_lines.file.name, \"blork.rs\".to_owned());\n         assert_eq!(file_lines.lines.len(), 1);\n         assert_eq!(*file_lines.lines.get(0), 1u);\n     }\n@@ -651,7 +651,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n         let snippet = cm.span_to_snippet(span);\n \n-        assert_eq!(snippet, Some(~\"second line\"));\n+        assert_eq!(snippet, Some(\"second line\".to_owned()));\n     }\n \n     #[test]\n@@ -661,6 +661,6 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n         let sstr =  cm.span_to_str(span);\n \n-        assert_eq!(sstr, ~\"blork.rs:2:1: 2:12\");\n+        assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_owned());\n     }\n }"}, {"sha": "61c6af62768be12c96c2da82256ffa02cda2063f", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -123,17 +123,17 @@ impl CrateId {\n #[test]\n fn bare_name() {\n     let crateid: CrateId = from_str(\"foo\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"foo\");\n+    assert_eq!(crateid.name, \"foo\".to_owned());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, ~\"foo\");\n+    assert_eq!(crateid.path, \"foo\".to_owned());\n }\n \n #[test]\n fn bare_name_single_char() {\n     let crateid: CrateId = from_str(\"f\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"f\");\n+    assert_eq!(crateid.name, \"f\".to_owned());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, ~\"f\");\n+    assert_eq!(crateid.path, \"f\".to_owned());\n }\n \n #[test]\n@@ -145,17 +145,17 @@ fn empty_crateid() {\n #[test]\n fn simple_path() {\n     let crateid: CrateId = from_str(\"example.com/foo/bar\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"bar\");\n+    assert_eq!(crateid.name, \"bar\".to_owned());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, ~\"example.com/foo/bar\");\n+    assert_eq!(crateid.path, \"example.com/foo/bar\".to_owned());\n }\n \n #[test]\n fn simple_version() {\n     let crateid: CrateId = from_str(\"foo#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"foo\");\n-    assert_eq!(crateid.version, Some(~\"1.0\"));\n-    assert_eq!(crateid.path, ~\"foo\");\n+    assert_eq!(crateid.name, \"foo\".to_owned());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_owned()));\n+    assert_eq!(crateid.path, \"foo\".to_owned());\n }\n \n #[test]\n@@ -173,39 +173,39 @@ fn path_ends_with_slash() {\n #[test]\n fn path_and_version() {\n     let crateid: CrateId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"bar\");\n-    assert_eq!(crateid.version, Some(~\"1.0\"));\n-    assert_eq!(crateid.path, ~\"example.com/foo/bar\");\n+    assert_eq!(crateid.name, \"bar\".to_owned());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_owned()));\n+    assert_eq!(crateid.path, \"example.com/foo/bar\".to_owned());\n }\n \n #[test]\n fn single_chars() {\n     let crateid: CrateId = from_str(\"a/b#1\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"b\");\n-    assert_eq!(crateid.version, Some(~\"1\"));\n-    assert_eq!(crateid.path, ~\"a/b\");\n+    assert_eq!(crateid.name, \"b\".to_owned());\n+    assert_eq!(crateid.version, Some(\"1\".to_owned()));\n+    assert_eq!(crateid.path, \"a/b\".to_owned());\n }\n \n #[test]\n fn missing_version() {\n     let crateid: CrateId = from_str(\"foo#\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"foo\");\n+    assert_eq!(crateid.name, \"foo\".to_owned());\n     assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, ~\"foo\");\n+    assert_eq!(crateid.path, \"foo\".to_owned());\n }\n \n #[test]\n fn path_and_name() {\n     let crateid: CrateId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"bar\");\n-    assert_eq!(crateid.version, Some(~\"1.0\"));\n-    assert_eq!(crateid.path, ~\"foo/rust-bar\");\n+    assert_eq!(crateid.name, \"bar\".to_owned());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_owned()));\n+    assert_eq!(crateid.path, \"foo/rust-bar\".to_owned());\n }\n \n #[test]\n fn empty_name() {\n     let crateid: CrateId = from_str(\"foo/bar#:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, ~\"bar\");\n-    assert_eq!(crateid.version, Some(~\"1.0\"));\n-    assert_eq!(crateid.path, ~\"foo/bar\");\n+    assert_eq!(crateid.name, \"bar\".to_owned());\n+    assert_eq!(crateid.version, Some(\"1.0\".to_owned()));\n+    assert_eq!(crateid.path, \"foo/bar\".to_owned());\n }"}, {"sha": "4d487689c6797b219a0666f1409549a382bfb93b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -99,7 +99,7 @@ impl SpanHandler {\n         fail!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, ~\"unimplemented \" + msg);\n+        self.span_bug(sp, \"unimplemented \".to_owned() + msg);\n     }\n     pub fn handler<'a>(&'a self) -> &'a Handler {\n         &self.handler\n@@ -136,7 +136,7 @@ impl Handler {\n         let s;\n         match self.err_count.get() {\n           0u => return,\n-          1u => s = ~\"aborting due to previous error\",\n+          1u => s = \"aborting due to previous error\".to_owned(),\n           _  => {\n             s = format!(\"aborting due to {} previous errors\",\n                      self.err_count.get());\n@@ -155,7 +155,7 @@ impl Handler {\n         fail!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(~\"unimplemented \" + msg);\n+        self.bug(\"unimplemented \".to_owned() + msg);\n     }\n     pub fn emit(&self,\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n@@ -452,7 +452,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                          sp: Span)\n                          -> io::IoResult<()> {\n     for ei in sp.expn_info.iter() {\n-        let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));\n+        let ss = ei.callee.span.as_ref().map_or(\"\".to_owned(), |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")"}, {"sha": "9b362f8d9425cbea6eca20ae722d1084e601b44d", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -56,7 +56,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();\n-    let mut cons = ~\"\";\n+    let mut cons = \"\".to_owned();\n     let mut volatile = false;\n     let mut alignstack = false;\n     let mut dialect = ast::AsmAtt;"}, {"sha": "1c3edce96fb1dcd7427ab62e24761c5371f7931b", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -36,7 +36,7 @@ impl<D:Decoder> Decodable for node_id {\n     fn decode(d: &D) -> Node {\n         d.read_struct(\"Node\", 1, || {\n             Node {\n-                id: d.read_field(~\"x\", 0, || decode(d))\n+                id: d.read_field(\"x\".to_owned(), 0, || decode(d))\n             }\n         })\n     }\n@@ -73,8 +73,8 @@ would yield functions like:\n         fn decode(d: &D) -> spanned<T> {\n             d.read_rec(|| {\n                 {\n-                    node: d.read_field(~\"node\", 0, || decode(d)),\n-                    span: d.read_field(~\"span\", 1, || decode(d)),\n+                    node: d.read_field(\"node\".to_owned(), 0, || decode(d)),\n+                    span: d.read_field(\"span\".to_owned(), 1, || decode(d)),\n                 }\n             })\n         }"}, {"sha": "1d4aa08f9e3bd7f6b7f3fa80ad66e80e704b2381", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -864,7 +864,7 @@ impl<'a> MethodDef<'a> {\n \n         } else {  // there are still matches to create\n             let current_match_str = if match_count == 0 {\n-                ~\"__self\"\n+                \"__self\".to_owned()\n             } else {\n                 format!(\"__arg_{}\", match_count)\n             };"}, {"sha": "734d07ccb8f9bc2df946ba0ee5ea292da15650b9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1019,11 +1019,11 @@ mod test {\n     // make sure that macros can leave scope\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n-        let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n-                    fn inty() -> int { z!() }\";\n+        let src = \"fn bogus() {macro_rules! z (() => (3+4))}\\\n+                   fn inty() -> int { z!() }\".to_owned();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n+            \"<test>\".to_owned(),\n             src,\n             Vec::new(), &sess);\n         // should fail:\n@@ -1039,11 +1039,11 @@ mod test {\n     // make sure that macros can leave scope for modules\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n-        let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n-                    fn inty() -> int { z!() }\";\n+        let src = \"mod foo {macro_rules! z (() => (3+4))}\\\n+                   fn inty() -> int { z!() }\".to_owned();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n+            \"<test>\".to_owned(),\n             src,\n             Vec::new(), &sess);\n         // should fail:\n@@ -1058,11 +1058,11 @@ mod test {\n \n     // macro_escape modules shouldn't cause macros to leave scope\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n-                    fn inty() -> int { z!() }\";\n+        let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+                   fn inty() -> int { z!() }\".to_owned();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n+            \"<test>\".to_owned(),\n             src,\n             Vec::new(), &sess);\n         // should fail:\n@@ -1130,7 +1130,7 @@ mod test {\n     //}\n \n     #[test] fn macro_tokens_should_match(){\n-        expand_crate_str(~\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\");\n+        expand_crate_str(\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\".to_owned());\n     }\n \n     // renaming tests expand a crate and then check that the bindings match\n@@ -1260,10 +1260,10 @@ mod test {\n     }\n \n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = ~\"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n+        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_str()))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n foo_module!()\n-\";\n+\".to_owned();\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n         let mut name_finder = new_name_finder(Vec::new());\n@@ -1309,7 +1309,7 @@ foo_module!()\n \n     #[test]\n     fn pat_idents(){\n-        let pat = string_to_pat(~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n+        let pat = string_to_pat(\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_owned());\n         let mut pat_idents = new_name_finder(Vec::new());\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(pat_idents.ident_accumulator,"}, {"sha": "7d86b9880779c139917c6e38b3f02018e3c1c6eb", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -393,11 +393,11 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_INT(i, ity) => {\n             let s_ity = match ity {\n-                ast::TyI => ~\"TyI\",\n-                ast::TyI8 => ~\"TyI8\",\n-                ast::TyI16 => ~\"TyI16\",\n-                ast::TyI32 => ~\"TyI32\",\n-                ast::TyI64 => ~\"TyI64\"\n+                ast::TyI => \"TyI\".to_owned(),\n+                ast::TyI8 => \"TyI8\".to_owned(),\n+                ast::TyI16 => \"TyI16\".to_owned(),\n+                ast::TyI32 => \"TyI32\".to_owned(),\n+                ast::TyI64 => \"TyI64\".to_owned()\n             };\n             let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n \n@@ -410,11 +410,11 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_UINT(u, uty) => {\n             let s_uty = match uty {\n-                ast::TyU => ~\"TyU\",\n-                ast::TyU8 => ~\"TyU8\",\n-                ast::TyU16 => ~\"TyU16\",\n-                ast::TyU32 => ~\"TyU32\",\n-                ast::TyU64 => ~\"TyU64\"\n+                ast::TyU => \"TyU\".to_owned(),\n+                ast::TyU8 => \"TyU8\".to_owned(),\n+                ast::TyU16 => \"TyU16\".to_owned(),\n+                ast::TyU32 => \"TyU32\".to_owned(),\n+                ast::TyU64 => \"TyU64\".to_owned()\n             };\n             let e_uty = cx.expr_ident(sp, id_ext(s_uty));\n \n@@ -435,8 +435,8 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_FLOAT(fident, fty) => {\n             let s_fty = match fty {\n-                ast::TyF32 => ~\"TyF32\",\n-                ast::TyF64 => ~\"TyF64\"\n+                ast::TyF32 => \"TyF32\".to_owned(),\n+                ast::TyF64 => \"TyF64\".to_owned()\n             };\n             let e_fty = cx.expr_ident(sp, id_ext(s_fty));\n \n@@ -649,10 +649,10 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   cx_expr: @ast::Expr,\n                   expr: @ast::Expr) -> @ast::Expr {\n     let uses = vec!( cx.view_use_glob(sp, ast::Inherited,\n-                                   ids_ext(vec!(~\"syntax\",\n-                                             ~\"ext\",\n-                                             ~\"quote\",\n-                                             ~\"rt\"))) );\n+                                   ids_ext(vec!(\"syntax\".to_owned(),\n+                                             \"ext\".to_owned(),\n+                                             \"quote\".to_owned(),\n+                                             \"rt\".to_owned()))) );\n \n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr);\n "}, {"sha": "8143f2aceeb610a6903b3c0305f3eb932079078f", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -366,9 +366,9 @@ pub fn parse(sess: &ParseSess,\n                 }\n                 return Success(nameize(sess, ms, v.as_slice()));\n             } else if eof_eis.len() > 1u {\n-                return Error(sp, ~\"ambiguity: multiple successful parses\");\n+                return Error(sp, \"ambiguity: multiple successful parses\".to_owned());\n             } else {\n-                return Failure(sp, ~\"unexpected end of macro invocation\");\n+                return Failure(sp, \"unexpected end of macro invocation\".to_owned());\n             }\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n@@ -436,7 +436,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         token::IDENT(sn,b) => { p.bump(); token::NtIdent(~sn,b) }\n         _ => {\n             let token_str = token::to_str(&p.token);\n-            p.fatal(~\"expected ident, found \" + token_str)\n+            p.fatal(\"expected ident, found \".to_owned() + token_str)\n         }\n       },\n       \"path\" => {\n@@ -450,6 +450,6 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         res\n       }\n       \"matchers\" => token::NtMatchers(p.parse_matchers()),\n-      _ => p.fatal(~\"unsupported builtin nonterminal parser: \" + name)\n+      _ => p.fatal(\"unsupported builtin nonterminal parser: \".to_owned() + name)\n     }\n }"}, {"sha": "78ea37587f010c10929497929c46ead322b60ae7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -132,7 +132,7 @@ fn generic_extension(cx: &ExtCtxt,\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_fail_spot = DUMMY_SP;\n-    let mut best_fail_msg = ~\"internal error: ran no matchers\";\n+    let mut best_fail_msg = \"internal error: ran no matchers\".to_owned();\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match **lhs {"}, {"sha": "fc4f427d8d738e7bb72b0e0dd7f64904dcdefa1b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -947,24 +947,24 @@ mod test {\n     #[test] fn ident_transformation () {\n         let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(\n-            ~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+            \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_owned());\n         let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n-                     ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n+                     \"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_owned());\n     }\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n         let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(\n-            ~\"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n-              (g $(d $d $e)+))} \");\n+            \"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n+             (g $(d $d $e)+))} \".to_owned());\n         let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n-                     ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n+                     \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\".to_owned());\n     }\n }"}, {"sha": "a96905f859738093184e7c52e9846d9c720656ad", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -238,7 +238,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<~str> ,\n         Some(col) => {\n             if col < len {\n                 s.slice(col, len).to_owned()\n-            } else {  ~\"\" }\n+            } else {  \"\".to_owned() }\n         }\n         None => s,\n     };\n@@ -279,7 +279,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n-                rdr.fatal(~\"unterminated block comment\");\n+                rdr.fatal(\"unterminated block comment\".to_owned());\n             }\n             if rdr.curr_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines,\n@@ -405,41 +405,41 @@ mod test {\n     #[test] fn test_block_doc_comment_1() {\n         let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, ~\" Test \\n*  Test\\n   Test\");\n+        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\".to_owned());\n     }\n \n     #[test] fn test_block_doc_comment_2() {\n         let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, ~\" Test\\n  Test\");\n+        assert_eq!(stripped, \" Test\\n  Test\".to_owned());\n     }\n \n     #[test] fn test_block_doc_comment_3() {\n         let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, ~\" let a: *int;\\n *a = 5;\");\n+        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\".to_owned());\n     }\n \n     #[test] fn test_block_doc_comment_4() {\n         let comment = \"/*******************\\n test\\n *********************/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, ~\" test\");\n+        assert_eq!(stripped, \" test\".to_owned());\n     }\n \n     #[test] fn test_line_doc_comment() {\n         let stripped = strip_doc_comment_decoration(\"/// test\");\n-        assert_eq!(stripped, ~\" test\");\n+        assert_eq!(stripped, \" test\".to_owned());\n         let stripped = strip_doc_comment_decoration(\"///! test\");\n-        assert_eq!(stripped, ~\" test\");\n+        assert_eq!(stripped, \" test\".to_owned());\n         let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, ~\" test\");\n+        assert_eq!(stripped, \" test\".to_owned());\n         let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, ~\" test\");\n+        assert_eq!(stripped, \" test\".to_owned());\n         let stripped = strip_doc_comment_decoration(\"///test\");\n-        assert_eq!(stripped, ~\"test\");\n+        assert_eq!(stripped, \"test\".to_owned());\n         let stripped = strip_doc_comment_decoration(\"///!test\");\n-        assert_eq!(stripped, ~\"test\");\n+        assert_eq!(stripped, \"test\".to_owned());\n         let stripped = strip_doc_comment_decoration(\"//test\");\n-        assert_eq!(stripped, ~\"test\");\n+        assert_eq!(stripped, \"test\".to_owned());\n     }\n }"}, {"sha": "ff087d95e50fb649cdb033e9b480895d277dc179", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -400,9 +400,9 @@ fn consume_block_comment(rdr: &mut StringReader) -> Option<TokenAndSpan> {\n     while level > 0 {\n         if is_eof(rdr) {\n             let msg = if is_doc_comment {\n-                ~\"unterminated block doc-comment\"\n+                \"unterminated block doc-comment\".to_owned()\n             } else {\n-                ~\"unterminated block comment\"\n+                \"unterminated block comment\".to_owned()\n             };\n             fatal_span(rdr, start_bpos, rdr.last_pos, msg);\n         } else if rdr.curr_is('/') && nextch_is(rdr, '*') {\n@@ -456,7 +456,7 @@ fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<~str> {\n             return Some(rslt.into_owned());\n         } else {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       ~\"scan_exponent: bad fp literal\");\n+                       \"scan_exponent: bad fp literal\".to_owned());\n         }\n     } else { return None::<~str>; }\n }\n@@ -480,11 +480,11 @@ fn check_float_base(rdr: &mut StringReader, start_bpos: BytePos, last_bpos: Byte\n                     base: uint) {\n     match base {\n       16u => fatal_span(rdr, start_bpos, last_bpos,\n-                      ~\"hexadecimal float literal is not supported\"),\n+                      \"hexadecimal float literal is not supported\".to_owned()),\n       8u => fatal_span(rdr, start_bpos, last_bpos,\n-                     ~\"octal float literal is not supported\"),\n+                     \"octal float literal is not supported\".to_owned()),\n       2u => fatal_span(rdr, start_bpos, last_bpos,\n-                     ~\"binary float literal is not supported\"),\n+                     \"binary float literal is not supported\".to_owned()),\n       _ => ()\n     }\n }\n@@ -544,13 +544,13 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n         }\n         if num_str.len() == 0u {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       ~\"no valid digits found for number\");\n+                       \"no valid digits found for number\".to_owned());\n         }\n         let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                  base as uint) {\n             Some(p) => p,\n             None => fatal_span(rdr, start_bpos, rdr.last_pos,\n-                               ~\"int literal is too large\")\n+                               \"int literal is too large\".to_owned())\n         };\n \n         match tp {\n@@ -595,7 +595,7 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n             back-end.  */\n         } else {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       ~\"expected `f32` or `f64` suffix\");\n+                       \"expected `f32` or `f64` suffix\".to_owned());\n         }\n     }\n     if is_float {\n@@ -605,13 +605,13 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n     } else {\n         if num_str.len() == 0u {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       ~\"no valid digits found for number\");\n+                       \"no valid digits found for number\".to_owned());\n         }\n         let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                  base as uint) {\n             Some(p) => p,\n             None => fatal_span(rdr, start_bpos, rdr.last_pos,\n-                               ~\"int literal is too large\")\n+                               \"int literal is too large\".to_owned())\n         };\n \n         debug!(\"lexing {} as an unsuffixed integer literal\",\n@@ -628,7 +628,7 @@ fn scan_numeric_escape(rdr: &mut StringReader, n_hex_digits: uint) -> char {\n         let n = rdr.curr;\n         if !is_hex_digit(n) {\n             fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n-                            ~\"illegal character in numeric character escape\",\n+                            \"illegal character in numeric character escape\".to_owned(),\n                             n.unwrap());\n         }\n         bump(rdr);\n@@ -638,13 +638,13 @@ fn scan_numeric_escape(rdr: &mut StringReader, n_hex_digits: uint) -> char {\n     }\n     if i != 0 && is_eof(rdr) {\n         fatal_span(rdr, start_bpos, rdr.last_pos,\n-                   ~\"unterminated numeric character escape\");\n+                   \"unterminated numeric character escape\".to_owned());\n     }\n \n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n         None => fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           ~\"illegal numeric character escape\")\n+                           \"illegal numeric character escape\".to_owned())\n     }\n }\n \n@@ -813,11 +813,12 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n \n             if token::is_keyword(token::keywords::Self, tok) {\n                 fatal_span(rdr, start, rdr.last_pos,\n-                           ~\"invalid lifetime name: 'self is no longer a special lifetime\");\n+                           \"invalid lifetime name: 'self \\\n+                            is no longer a special lifetime\".to_owned());\n             } else if token::is_any_keyword(tok) &&\n                 !token::is_keyword(token::keywords::Static, tok) {\n                 fatal_span(rdr, start, rdr.last_pos,\n-                           ~\"invalid lifetime name\");\n+                           \"invalid lifetime name\".to_owned());\n             } else {\n                 return token::LIFETIME(ident);\n             }\n@@ -846,15 +847,15 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                             'U' => scan_numeric_escape(rdr, 8u),\n                             c2 => {\n                                 fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n-                                                ~\"unknown character escape\", c2)\n+                                                \"unknown character escape\".to_owned(), c2)\n                             }\n                         }\n                     }\n                 }\n             }\n             '\\t' | '\\n' | '\\r' | '\\'' => {\n                 fatal_span_char(rdr, start, rdr.last_pos,\n-                                ~\"character constant must be escaped\", c2);\n+                                \"character constant must be escaped\".to_owned(), c2);\n             }\n             _ => {}\n         }\n@@ -865,7 +866,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                                // ascii single quote.\n                                start - BytePos(1),\n                                rdr.last_pos,\n-                               ~\"unterminated character constant\");\n+                               \"unterminated character constant\".to_owned());\n         }\n         bump(rdr); // advance curr past token\n         return token::LIT_CHAR(c2 as u32);\n@@ -877,7 +878,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n         while !rdr.curr_is('\"') {\n             if is_eof(rdr) {\n                 fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           ~\"unterminated double quote string\");\n+                           \"unterminated double quote string\".to_owned());\n             }\n \n             let ch = rdr.curr.unwrap();\n@@ -886,7 +887,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n               '\\\\' => {\n                 if is_eof(rdr) {\n                     fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           ~\"unterminated double quote string\");\n+                           \"unterminated double quote string\".to_owned());\n                 }\n \n                 let escaped = rdr.curr.unwrap();\n@@ -912,7 +913,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                   }\n                   c2 => {\n                     fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n-                                    ~\"unknown string escape\", c2);\n+                                    \"unknown string escape\".to_owned(), c2);\n                   }\n                 }\n               }\n@@ -933,11 +934,11 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n \n         if is_eof(rdr) {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       ~\"unterminated raw string\");\n+                       \"unterminated raw string\".to_owned());\n         } else if !rdr.curr_is('\"') {\n             fatal_span_char(rdr, start_bpos, rdr.last_pos,\n-                            ~\"only `#` is allowed in raw string delimitation; \\\n-                              found illegal character\",\n+                            \"only `#` is allowed in raw string delimitation; \\\n+                             found illegal character\".to_owned(),\n                             rdr.curr.unwrap());\n         }\n         bump(rdr);\n@@ -946,7 +947,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n         'outer: loop {\n             if is_eof(rdr) {\n                 fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           ~\"unterminated raw string\");\n+                           \"unterminated raw string\".to_owned());\n             }\n             if rdr.curr_is('\"') {\n                 content_end_bpos = rdr.last_pos;\n@@ -994,7 +995,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n           fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n-                          ~\"unknown start of token\", c);\n+                          \"unknown start of token\".to_owned(), c);\n       }\n     }\n }\n@@ -1022,15 +1023,15 @@ mod test {\n     // open a string reader for the given string\n     fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n                  teststr: ~str) -> StringReader<'a> {\n-        let fm = span_handler.cm.new_filemap(~\"zebra.rs\", teststr);\n+        let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_owned(), teststr);\n         new_string_reader(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n         let span_handler = mk_sh();\n         let mut string_reader = setup(&span_handler,\n-            ~\"/* my source file */ \\\n-              fn main() { println!(\\\"zebra\\\"); }\\n\");\n+            \"/* my source file */ \\\n+             fn main() { println!(\\\"zebra\\\"); }\\n\".to_owned());\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n@@ -1063,54 +1064,54 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        check_tokenization(setup(&mk_sh(), ~\"a b\"),\n+        check_tokenization(setup(&mk_sh(), \"a b\".to_owned()),\n                            vec!(mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_2 () {\n-        check_tokenization(setup(&mk_sh(), ~\"a::b\"),\n+        check_tokenization(setup(&mk_sh(), \"a::b\".to_owned()),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_3 () {\n-        check_tokenization(setup(&mk_sh(), ~\"a ::b\"),\n+        check_tokenization(setup(&mk_sh(), \"a ::b\".to_owned()),\n                            vec!(mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_4 () {\n-        check_tokenization(setup(&mk_sh(), ~\"a:: b\"),\n+        check_tokenization(setup(&mk_sh(), \"a:: b\".to_owned()),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {\n-        assert_eq!(setup(&mk_sh(), ~\"'a'\").next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"'a'\".to_owned()).next_token().tok,\n                    token::LIT_CHAR('a' as u32));\n     }\n \n     #[test] fn character_space() {\n-        assert_eq!(setup(&mk_sh(), ~\"' '\").next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"' '\".to_owned()).next_token().tok,\n                    token::LIT_CHAR(' ' as u32));\n     }\n \n     #[test] fn character_escaped() {\n-        assert_eq!(setup(&mk_sh(), ~\"'\\\\n'\").next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_owned()).next_token().tok,\n                    token::LIT_CHAR('\\n' as u32));\n     }\n \n     #[test] fn lifetime_name() {\n-        assert_eq!(setup(&mk_sh(), ~\"'abc\").next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"'abc\".to_owned()).next_token().tok,\n                    token::LIFETIME(token::str_to_ident(\"abc\")));\n     }\n \n     #[test] fn raw_string() {\n-        assert_eq!(setup(&mk_sh(), ~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\").next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_owned()).next_token().tok,\n                    token::LIT_STR_RAW(token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n     }\n \n@@ -1121,7 +1122,7 @@ mod test {\n     }\n \n     #[test] fn nested_block_comments() {\n-        assert_eq!(setup(&mk_sh(), ~\"/* /* */ */'a'\").next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"/* /* */ */'a'\".to_owned()).next_token().tok,\n                    token::LIT_CHAR('a' as u32));\n     }\n "}, {"sha": "4586980d89394951a9a976825aa353579c1b6bfe", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -302,7 +302,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_1() {\n-        assert!(string_to_expr(~\"a\") ==\n+        assert!(string_to_expr(\"a\".to_owned()) ==\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -321,7 +321,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_2 () {\n-        assert!(string_to_expr(~\"::a::b\") ==\n+        assert!(string_to_expr(\"::a::b\".to_owned()) ==\n                    @ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -346,12 +346,12 @@ mod test {\n \n     #[should_fail]\n     #[test] fn bad_path_expr_1() {\n-        string_to_expr(~\"::abc::def::return\");\n+        string_to_expr(\"::abc::def::return\".to_owned());\n     }\n \n     // check the token-tree-ization of macros\n     #[test] fn string_to_tts_macro () {\n-        let tts = string_to_tts(~\"macro_rules! zip (($a)=>($a))\");\n+        let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_owned());\n         let tts: &[ast::TokenTree] = tts.as_slice();\n         match tts {\n             [ast::TTTok(_,_),\n@@ -404,9 +404,9 @@ mod test {\n     }\n \n     #[test] fn string_to_tts_1 () {\n-        let tts = string_to_tts(~\"fn a (b : int) { b; }\");\n+        let tts = string_to_tts(\"fn a (b : int) { b; }\".to_owned());\n         assert_eq!(to_json_str(&tts),\n-        ~\"[\\\n+        \"[\\\n     {\\\n         \\\"variant\\\":\\\"TTTok\\\",\\\n         \\\"fields\\\":[\\\n@@ -528,12 +528,12 @@ mod test {\n             ]\\\n         ]\\\n     }\\\n-]\"\n+]\".to_owned()\n         );\n     }\n \n     #[test] fn ret_expr() {\n-        assert!(string_to_expr(~\"return d\") ==\n+        assert!(string_to_expr(\"return d\".to_owned()) ==\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(@ast::Expr{\n@@ -556,7 +556,7 @@ mod test {\n     }\n \n     #[test] fn parse_stmt_1 () {\n-        assert!(string_to_stmt(~\"b;\") ==\n+        assert!(string_to_stmt(\"b;\".to_owned()) ==\n                    @Spanned{\n                        node: ast::StmtExpr(@ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n@@ -583,7 +583,7 @@ mod test {\n \n     #[test] fn parse_ident_pat () {\n         let sess = new_parse_sess();\n-        let mut parser = string_to_parser(&sess, ~\"b\");\n+        let mut parser = string_to_parser(&sess, \"b\".to_owned());\n         assert!(parser.parse_pat() ==\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n@@ -607,7 +607,7 @@ mod test {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\"\n-        assert!(string_to_item(~\"fn a (b : int) { b; }\") ==\n+        assert!(string_to_item(\"fn a (b : int) { b; }\".to_owned()) ==\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n@@ -699,12 +699,12 @@ mod test {\n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n-        string_to_expr(~\"3 + 4\");\n-        string_to_expr(~\"a::z.froob(b,@(987+3))\");\n+        string_to_expr(\"3 + 4\".to_owned());\n+        string_to_expr(\"a::z.froob(b,@(987+3))\".to_owned());\n     }\n \n     #[test] fn attrs_fix_bug () {\n-        string_to_item(~\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+        string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n@@ -715,7 +715,7 @@ mod test {\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-}\");\n+}\".to_owned());\n     }\n \n }"}, {"sha": "58634be1995662242977d1ba2c9c0d9198998a78", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -384,7 +384,7 @@ impl<'a> Parser<'a> {\n         fn tokens_to_str(tokens: &[token::Token]) -> ~str {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n-            let b = i.next().map_or(~\"\", |t| Parser::token_to_str(t));\n+            let b = i.next().map_or(\"\".to_owned(), |t| Parser::token_to_str(t));\n             i.fold(b, |b,a| b + \"`, `\" + Parser::token_to_str(a))\n         }\n         if edible.contains(&self.token) {"}, {"sha": "77743cdb9dfcb2d63b85b1988f0022fd0b5363c8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -141,56 +141,56 @@ impl fmt::Show for Nonterminal {\n \n pub fn binop_to_str(o: BinOp) -> ~str {\n     match o {\n-      PLUS => ~\"+\",\n-      MINUS => ~\"-\",\n-      STAR => ~\"*\",\n-      SLASH => ~\"/\",\n-      PERCENT => ~\"%\",\n-      CARET => ~\"^\",\n-      AND => ~\"&\",\n-      OR => ~\"|\",\n-      SHL => ~\"<<\",\n-      SHR => ~\">>\"\n+      PLUS => \"+\".to_owned(),\n+      MINUS => \"-\".to_owned(),\n+      STAR => \"*\".to_owned(),\n+      SLASH => \"/\".to_owned(),\n+      PERCENT => \"%\".to_owned(),\n+      CARET => \"^\".to_owned(),\n+      AND => \"&\".to_owned(),\n+      OR => \"|\".to_owned(),\n+      SHL => \"<<\".to_owned(),\n+      SHR => \">>\".to_owned()\n     }\n }\n \n pub fn to_str(t: &Token) -> ~str {\n     match *t {\n-      EQ => ~\"=\",\n-      LT => ~\"<\",\n-      LE => ~\"<=\",\n-      EQEQ => ~\"==\",\n-      NE => ~\"!=\",\n-      GE => ~\">=\",\n-      GT => ~\">\",\n-      NOT => ~\"!\",\n-      TILDE => ~\"~\",\n-      OROR => ~\"||\",\n-      ANDAND => ~\"&&\",\n+      EQ => \"=\".to_owned(),\n+      LT => \"<\".to_owned(),\n+      LE => \"<=\".to_owned(),\n+      EQEQ => \"==\".to_owned(),\n+      NE => \"!=\".to_owned(),\n+      GE => \">=\".to_owned(),\n+      GT => \">\".to_owned(),\n+      NOT => \"!\".to_owned(),\n+      TILDE => \"~\".to_owned(),\n+      OROR => \"||\".to_owned(),\n+      ANDAND => \"&&\".to_owned(),\n       BINOP(op) => binop_to_str(op),\n       BINOPEQ(op) => binop_to_str(op) + \"=\",\n \n       /* Structural symbols */\n-      AT => ~\"@\",\n-      DOT => ~\".\",\n-      DOTDOT => ~\"..\",\n-      DOTDOTDOT => ~\"...\",\n-      COMMA => ~\",\",\n-      SEMI => ~\";\",\n-      COLON => ~\":\",\n-      MOD_SEP => ~\"::\",\n-      RARROW => ~\"->\",\n-      LARROW => ~\"<-\",\n-      DARROW => ~\"<->\",\n-      FAT_ARROW => ~\"=>\",\n-      LPAREN => ~\"(\",\n-      RPAREN => ~\")\",\n-      LBRACKET => ~\"[\",\n-      RBRACKET => ~\"]\",\n-      LBRACE => ~\"{\",\n-      RBRACE => ~\"}\",\n-      POUND => ~\"#\",\n-      DOLLAR => ~\"$\",\n+      AT => \"@\".to_owned(),\n+      DOT => \".\".to_owned(),\n+      DOTDOT => \"..\".to_owned(),\n+      DOTDOTDOT => \"...\".to_owned(),\n+      COMMA => \",\".to_owned(),\n+      SEMI => \";\".to_owned(),\n+      COLON => \":\".to_owned(),\n+      MOD_SEP => \"::\".to_owned(),\n+      RARROW => \"->\".to_owned(),\n+      LARROW => \"<-\".to_owned(),\n+      DARROW => \"<->\".to_owned(),\n+      FAT_ARROW => \"=>\".to_owned(),\n+      LPAREN => \"(\".to_owned(),\n+      RPAREN => \")\".to_owned(),\n+      LBRACKET => \"[\".to_owned(),\n+      RBRACKET => \"]\".to_owned(),\n+      LBRACE => \"{\".to_owned(),\n+      RBRACE => \"}\".to_owned(),\n+      POUND => \"#\".to_owned(),\n+      DOLLAR => \"$\".to_owned(),\n \n       /* Literals */\n       LIT_CHAR(c) => {\n@@ -232,29 +232,29 @@ pub fn to_str(t: &Token) -> ~str {\n       LIFETIME(s) => {\n           format!(\"'{}\", get_ident(s))\n       }\n-      UNDERSCORE => ~\"_\",\n+      UNDERSCORE => \"_\".to_owned(),\n \n       /* Other */\n       DOC_COMMENT(s) => get_ident(s).get().to_str(),\n-      EOF => ~\"<eof>\",\n+      EOF => \"<eof>\".to_owned(),\n       INTERPOLATED(ref nt) => {\n         match nt {\n             &NtExpr(e) => ::print::pprust::expr_to_str(e),\n             &NtMeta(e) => ::print::pprust::meta_item_to_str(e),\n             _ => {\n-                ~\"an interpolated \" +\n+                \"an interpolated \".to_owned() +\n                     match *nt {\n-                        NtItem(..) => ~\"item\",\n-                        NtBlock(..) => ~\"block\",\n-                        NtStmt(..) => ~\"statement\",\n-                        NtPat(..) => ~\"pattern\",\n+                        NtItem(..) => \"item\".to_owned(),\n+                        NtBlock(..) => \"block\".to_owned(),\n+                        NtStmt(..) => \"statement\".to_owned(),\n+                        NtPat(..) => \"pattern\".to_owned(),\n                         NtMeta(..) => fail!(\"should have been handled\"),\n                         NtExpr(..) => fail!(\"should have been handled above\"),\n-                        NtTy(..) => ~\"type\",\n-                        NtIdent(..) => ~\"identifier\",\n-                        NtPath(..) => ~\"path\",\n-                        NtTT(..) => ~\"tt\",\n-                        NtMatchers(..) => ~\"matcher sequence\"\n+                        NtTy(..) => \"type\".to_owned(),\n+                        NtIdent(..) => \"identifier\".to_owned(),\n+                        NtPath(..) => \"path\".to_owned(),\n+                        NtTT(..) => \"tt\".to_owned(),\n+                        NtMatchers(..) => \"matcher sequence\".to_owned()\n                     }\n             }\n         }"}, {"sha": "21215748fb43848839201ddaa6ea87dba5bd45e0", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -112,10 +112,10 @@ impl Token {\n pub fn tok_str(t: Token) -> ~str {\n     match t {\n         String(s, len) => return format!(\"STR({},{})\", s, len),\n-        Break(_) => return ~\"BREAK\",\n-        Begin(_) => return ~\"BEGIN\",\n-        End => return ~\"END\",\n-        Eof => return ~\"EOF\"\n+        Break(_) => return \"BREAK\".to_owned(),\n+        Begin(_) => return \"BEGIN\".to_owned(),\n+        End => return \"END\".to_owned(),\n+        Eof => return \"EOF\".to_owned()\n     }\n }\n "}, {"sha": "7041a6585a0cd64bd6665386cde7004362b92f02", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -2409,7 +2409,7 @@ mod test {\n         let generics = ast_util::empty_generics();\n         assert_eq!(&fun_to_str(&decl, ast::NormalFn, abba_ident,\n                                None, &generics),\n-                   &~\"fn abba()\");\n+                   &\"fn abba()\".to_owned());\n     }\n \n     #[test]\n@@ -2427,6 +2427,6 @@ mod test {\n         });\n \n         let varstr = variant_to_str(&var);\n-        assert_eq!(&varstr,&~\"pub principal_skinner\");\n+        assert_eq!(&varstr,&\"pub principal_skinner\".to_owned());\n     }\n }"}, {"sha": "cdf7455b1bc756c1628ffab2111dc9d810c8727b", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,12 +18,12 @@ use parse::token;\n // map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: ~str) -> Vec<ast::TokenTree> {\n     let ps = new_parse_sess();\n-    filemap_to_tts(&ps, string_to_filemap(&ps, source_str,~\"bogofile\"))\n+    filemap_to_tts(&ps, string_to_filemap(&ps, source_str,\"bogofile\".to_owned()))\n }\n \n // map string to parser (via tts)\n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: ~str) -> Parser<'a> {\n-    new_parser_from_source_str(ps, Vec::new(), ~\"bogofile\", source_str)\n+    new_parser_from_source_str(ps, Vec::new(), \"bogofile\".to_owned(), source_str)\n }\n \n fn with_error_checking_parse<T>(s: ~str, f: |&mut Parser| -> T) -> T {"}, {"sha": "9e3be403065aedb0cb53e69012994769a16b93ff", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -129,7 +129,7 @@ impl<T: Writer> Terminal<T> {\n     pub fn new(out: T) -> Result<Terminal<T>, ~str> {\n         let term = match os::getenv(\"TERM\") {\n             Some(t) => t,\n-            None => return Err(~\"TERM environment variable undefined\")\n+            None => return Err(\"TERM environment variable undefined\".to_owned())\n         };\n \n         let mut file = match open(term) {\n@@ -251,7 +251,7 @@ impl<T: Writer> Terminal<T> {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = cap.map_or(Err(~\"can't find terminfo capability `sgr0`\"), |op| {\n+        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()), |op| {\n             expand(op.as_slice(), [], &mut Variables::new())\n         });\n         if s.is_ok() {"}, {"sha": "993b69be881ef4ed567dc8a94340a57eca43e2fa", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -124,9 +124,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n-                            _       => return Err(~\"a non-char was used with %c\")\n+                            _       => return Err(\"a non-char was used with %c\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n@@ -135,112 +135,112 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             String(s) => stack.push(Number(s.len() as int)),\n-                            _         => return Err(~\"a non-str was used with %l\")\n+                            _         => return Err(\"a non-str was used with %l\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '+' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                            _ => return Err(~\"non-numbers on stack with +\")\n+                            _ => return Err(\"non-numbers on stack with +\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '-' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                            _ => return Err(~\"non-numbers on stack with -\")\n+                            _ => return Err(\"non-numbers on stack with -\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '*' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                            _ => return Err(~\"non-numbers on stack with *\")\n+                            _ => return Err(\"non-numbers on stack with *\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '/' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                            _ => return Err(~\"non-numbers on stack with /\")\n+                            _ => return Err(\"non-numbers on stack with /\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'm' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                            _ => return Err(~\"non-numbers on stack with %\")\n+                            _ => return Err(\"non-numbers on stack with %\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '&' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                            _ => return Err(~\"non-numbers on stack with &\")\n+                            _ => return Err(\"non-numbers on stack with &\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '|' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                            _ => return Err(~\"non-numbers on stack with |\")\n+                            _ => return Err(\"non-numbers on stack with |\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '^' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                            _ => return Err(~\"non-numbers on stack with ^\")\n+                            _ => return Err(\"non-numbers on stack with ^\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '=' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(~\"non-numbers on stack with =\")\n+                            _ => return Err(\"non-numbers on stack with =\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '>' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(~\"non-numbers on stack with >\")\n+                            _ => return Err(\"non-numbers on stack with >\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '<' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(~\"non-numbers on stack with <\")\n+                            _ => return Err(\"non-numbers on stack with <\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'A' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(~\"non-numbers on stack with logical and\")\n+                            _ => return Err(\"non-numbers on stack with logical and\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'O' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(~\"non-numbers on stack with logical or\")\n+                            _ => return Err(\"non-numbers on stack with logical or\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '!' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n-                            _ => return Err(~\"non-number on stack with logical not\")\n+                            _ => return Err(\"non-number on stack with logical not\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '~' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n-                            _         => return Err(~\"non-number on stack with %~\")\n+                            _         => return Err(\"non-number on stack with %~\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'i' => match (mparams[0].clone(), mparams[1].clone()) {\n                         (Number(x), Number(y)) => {\n                             mparams[0] = Number(x+1);\n                             mparams[1] = Number(y+1);\n                         },\n-                        (_, _) => return Err(~\"first two params not numbers with %i\")\n+                        (_, _) => return Err(\"first two params not numbers with %i\".to_owned())\n                     },\n \n                     // printf-style support for %doxXs\n@@ -249,7 +249,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice())\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     ':'|'#'|' '|'.'|'0'..'9' => {\n                         let mut flags = Flags::new();\n                         let mut fstate = FormatStateFlags;\n@@ -273,9 +273,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         match stack.pop().unwrap() {\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n-                            _         => return Err(~\"non-number on stack with conditional\")\n+                            _         => return Err(\"non-number on stack \\\n+                                                    with conditional\".to_owned())\n                         }\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n@@ -286,22 +287,22 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 // params are 1-indexed\n                 stack.push(mparams[match char::to_digit(cur, 10) {\n                     Some(d) => d - 1,\n-                    None => return Err(~\"bad param number\")\n+                    None => return Err(\"bad param number\".to_owned())\n                 }].clone());\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n                         vars.sta[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(~\"stack is empty\") }\n+                    } else { return Err(\"stack is empty\".to_owned()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n                         vars.dyn[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(~\"stack is empty\") }\n+                    } else { return Err(\"stack is empty\".to_owned()) }\n                 } else {\n-                    return Err(~\"bad variable name in %P\");\n+                    return Err(\"bad variable name in %P\".to_owned());\n                 }\n             },\n             GetVar => {\n@@ -312,7 +313,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     let idx = (cur as u8) - ('a' as u8);\n                     stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n-                    return Err(~\"bad variable name in %g\");\n+                    return Err(\"bad variable name in %g\".to_owned());\n                 }\n             },\n             CharConstant => {\n@@ -321,7 +322,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             CharClose => {\n                 if cur != '\\'' {\n-                    return Err(~\"malformed character constant\");\n+                    return Err(\"malformed character constant\".to_owned());\n                 }\n             },\n             IntConstant(i) => {\n@@ -334,7 +335,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = IntConstant(i*10 + (cur as int - '0' as int));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(~\"bad int constant\")\n+                    _ => return Err(\"bad int constant\".to_owned())\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n@@ -345,7 +346,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice());\n                         old_state = state; // will cause state to go to Nothing\n-                    } else { return Err(~\"stack is empty\") },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;\n                     }\n@@ -368,17 +369,19 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (FormatStateWidth,'0'..'9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as uint - '0' as uint);\n-                        if flags.width < old { return Err(~\"format width overflow\") }\n+                        if flags.width < old { return Err(\"format width overflow\".to_owned()) }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n                     (FormatStatePrecision,'0'..'9') => {\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as uint - '0' as uint);\n-                        if flags.precision < old { return Err(~\"format precision overflow\") }\n+                        if flags.precision < old {\n+                            return Err(\"format precision overflow\".to_owned())\n+                        }\n                     }\n-                    _ => return Err(~\"invalid format specifier\")\n+                    _ => return Err(\"invalid format specifier\".to_owned())\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -485,7 +488,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n                 (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n-                (FormatString, _)    => return Err(~\"non-number on stack with %s\"),\n+                (FormatString, _)    => return Err(\"non-number on stack with %s\".to_owned()),\n             };\n             let mut s: Vec<u8> = s.move_iter().collect();\n             if flags.precision > s.len() {\n@@ -596,7 +599,11 @@ mod test {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n-            let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n+            let p = if *cap == \"%s\" || *cap == \"%l\" {\n+                String(\"foo\".to_owned())\n+            } else {\n+                Number(97)\n+            };\n             let res = expand(bytes!(\"%p1\").iter().map(|x| *x).collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                              [p],\n@@ -671,9 +678,10 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n-                          [String(~\"foo\"), String(~\"foo\"), String(~\"f\"), String(~\"foo\")], vars),\n+                          [String(\"foo\".to_owned()), String(\"foo\".to_owned()),\n+                           String(\"f\".to_owned()), String(\"foo\".to_owned())], vars),\n                    Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(~\"foo\")], vars),\n+        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_owned())], vars),\n                    Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n \n         assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),"}, {"sha": "e27f4652305ad0642c73cc5aa8f51dc091108198", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -195,21 +195,21 @@ pub fn parse(file: &mut io::Reader,\n     assert!(names_bytes          > 0);\n \n     if (bools_bytes as uint) > boolnames.len() {\n-        return Err(~\"incompatible file: more booleans than expected\");\n+        return Err(\"incompatible file: more booleans than expected\".to_owned());\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n-        return Err(~\"incompatible file: more numbers than expected\");\n+        return Err(\"incompatible file: more numbers than expected\".to_owned());\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n-        return Err(~\"incompatible file: more string offsets than expected\");\n+        return Err(\"incompatible file: more string offsets than expected\".to_owned());\n     }\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n     let names_str = match str::from_utf8(bytes.as_slice()) {\n-        Some(s) => s.to_owned(), None => return Err(~\"input not utf-8\"),\n+        Some(s) => s.to_owned(), None => return Err(\"input not utf-8\".to_owned()),\n     };\n \n     let term_names: Vec<~str> = names_str.split('|').map(|s| s.to_owned()).collect();\n@@ -221,7 +221,7 @@ pub fn parse(file: &mut io::Reader,\n         for i in range(0, bools_bytes) {\n             let b = try!(file.read_byte());\n             if b < 0 {\n-                return Err(~\"error: expected more bools but hit EOF\");\n+                return Err(\"error: expected more bools but hit EOF\".to_owned());\n             } else if b == 1 {\n                 bools_map.insert(bnames[i as uint].to_owned(), true);\n             }\n@@ -253,7 +253,7 @@ pub fn parse(file: &mut io::Reader,\n         let string_table = try!(file.read_exact(string_table_bytes as uint));\n \n         if string_table.len() != string_table_bytes as uint {\n-            return Err(~\"error: hit EOF before end of string table\");\n+            return Err(\"error: hit EOF before end of string table\".to_owned());\n         }\n \n         for (i, v) in string_offsets.iter().enumerate() {\n@@ -287,7 +287,7 @@ pub fn parse(file: &mut io::Reader,\n                                           offset as uint + len)))\n                 },\n                 None => {\n-                    return Err(~\"invalid file: missing NUL in string_table\");\n+                    return Err(\"invalid file: missing NUL in string_table\".to_owned());\n                 }\n             };\n         }\n@@ -300,12 +300,12 @@ pub fn parse(file: &mut io::Reader,\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> ~TermInfo {\n     let mut strings = HashMap::new();\n-    strings.insert(~\"sgr0\", Vec::from_slice(bytes!(\"\\x1b[0m\")));\n-    strings.insert(~\"bold\", Vec::from_slice(bytes!(\"\\x1b[1m\")));\n-    strings.insert(~\"setaf\", Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n-    strings.insert(~\"setab\", Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n+    strings.insert(\"sgr0\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n+    strings.insert(\"bold\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n+    strings.insert(\"setaf\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n+    strings.insert(\"setab\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n     ~TermInfo {\n-        names: vec!(~\"cygwin\"), // msys is a fork of an older cygwin version\n+        names: vec!(\"cygwin\".to_owned()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n         strings: strings"}, {"sha": "12540f525812f337228a9db72afa1e466f383a6a", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -99,10 +99,10 @@ fn test_get_dbpath_for_term() {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n         p.as_str().unwrap().to_owned()\n     };\n-    assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_owned());\n     assert!(get_dbpath_for_term(\"\") == None);\n     setenv(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_owned());\n     unsetenv(\"TERMINFO_DIRS\");\n }\n "}, {"sha": "758b7532acc20bafa0558dcdddf0ff7c561ab2f4", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -536,9 +536,9 @@ impl<T: Writer> ConsoleTestState<T> {\n             None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n-                        TrOk => ~\"ok\",\n-                        TrFailed => ~\"failed\",\n-                        TrIgnored => ~\"ignored\",\n+                        TrOk => \"ok\".to_owned(),\n+                        TrFailed => \"failed\".to_owned(),\n+                        TrIgnored => \"ignored\".to_owned(),\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.to_str());\n@@ -893,7 +893,7 @@ pub fn filter_tests(\n     } else {\n         let filter_str = match opts.filter {\n           Some(ref f) => (*f).clone(),\n-          None => ~\"\"\n+          None => \"\".to_owned()\n         };\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n@@ -1019,8 +1019,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = ~TreeMap::new();\n-        map.insert(~\"value\", json::Number(self.value));\n-        map.insert(~\"noise\", json::Number(self.noise));\n+        map.insert(\"value\".to_owned(), json::Number(self.value));\n+        map.insert(\"noise\".to_owned(), json::Number(self.noise));\n         json::Object(map)\n     }\n }\n@@ -1378,7 +1378,7 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = vec!(~\"progname\", ~\"filter\");\n+        let args = vec!(\"progname\".to_owned(), \"filter\".to_owned());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n@@ -1388,7 +1388,7 @@ mod tests {\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec!(~\"progname\", ~\"filter\", ~\"--ignored\");\n+        let args = vec!(\"progname\".to_owned(), \"filter\".to_owned(), \"--ignored\".to_owned());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in parse_ignored_flag\")\n@@ -1433,7 +1433,7 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered.get(0).desc.name.to_str(), ~\"1\");\n+        assert_eq!(filtered.get(0).desc.name.to_str(), \"1\".to_owned());\n         assert!(filtered.get(0).desc.ignore == false);\n     }\n \n@@ -1452,12 +1452,12 @@ mod tests {\n         };\n \n         let names =\n-            vec!(~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\",\n-             ~\"test::do_not_run_ignored_tests\",\n-             ~\"test::ignored_tests_result_in_ignored\",\n-             ~\"test::first_free_arg_should_be_a_filter\",\n-             ~\"test::parse_ignored_flag\", ~\"test::filter_for_ignored_option\",\n-             ~\"test::sort_tests\");\n+            vec!(\"sha1::test\".to_owned(), \"int::test_to_str\".to_owned(), \"int::test_pow\".to_owned(),\n+             \"test::do_not_run_ignored_tests\".to_owned(),\n+             \"test::ignored_tests_result_in_ignored\".to_owned(),\n+             \"test::first_free_arg_should_be_a_filter\".to_owned(),\n+             \"test::parse_ignored_flag\".to_owned(), \"test::filter_for_ignored_option\".to_owned(),\n+             \"test::sort_tests\".to_owned());\n         let tests =\n         {\n             fn testfn() { }\n@@ -1478,13 +1478,13 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         let expected =\n-            vec!(~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n-              ~\"test::do_not_run_ignored_tests\",\n-              ~\"test::filter_for_ignored_option\",\n-              ~\"test::first_free_arg_should_be_a_filter\",\n-              ~\"test::ignored_tests_result_in_ignored\",\n-              ~\"test::parse_ignored_flag\",\n-              ~\"test::sort_tests\");\n+            vec!(\"int::test_pow\".to_owned(), \"int::test_to_str\".to_owned(), \"sha1::test\".to_owned(),\n+              \"test::do_not_run_ignored_tests\".to_owned(),\n+              \"test::filter_for_ignored_option\".to_owned(),\n+              \"test::first_free_arg_should_be_a_filter\".to_owned(),\n+              \"test::ignored_tests_result_in_ignored\".to_owned(),\n+              \"test::parse_ignored_flag\".to_owned(),\n+              \"test::sort_tests\".to_owned());\n \n         for (a, b) in expected.iter().zip(filtered.iter()) {\n             assert!(*a == b.desc.name.to_str());\n@@ -1515,28 +1515,32 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&~\"in-both-noise\").unwrap()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&~\"in-first-noise\").unwrap()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&~\"in-second-noise\").unwrap()), MetricAdded);\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-noise\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"in-first-noise\".to_owned()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.find(&\"in-second-noise\".to_owned()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_owned()).unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_owned()).unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_owned()).unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_owned()).unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&~\"in-both-noise\").unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-first-noise\").unwrap()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&~\"in-second-noise\").unwrap()), MetricAdded);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-but-regressed\").unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-and-improved\").unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-but-regressed\").unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-and-improved\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-both-noise\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-first-noise\".to_owned()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.find(&\"in-second-noise\".to_owned()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_owned()).unwrap()),\n+                   LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_owned()).unwrap()),\n+                   LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_owned()).unwrap()),\n+                   LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_owned()).unwrap()),\n+                   LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n \n@@ -1560,29 +1564,29 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&~\"runtime\").unwrap()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&~\"throughput\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"runtime\".to_owned()).unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.find(&\"throughput\".to_owned()).unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&~\"runtime\").unwrap()), Metric::new(1000.0, 2.0));\n-        assert_eq!(*(m3.find(&~\"throughput\").unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m3.find(&\"runtime\".to_owned()).unwrap()), Metric::new(1000.0, 2.0));\n+        assert_eq!(*(m3.find(&\"throughput\".to_owned()).unwrap()), Metric::new(50.0, 2.0));\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&~\"runtime\").unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"throughput\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"runtime\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"throughput\".to_owned()).unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&~\"runtime\").unwrap()), Metric::new(1100.0, 2.0));\n-        assert_eq!(*(m4.find(&~\"throughput\").unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m4.find(&\"runtime\".to_owned()).unwrap()), Metric::new(1100.0, 2.0));\n+        assert_eq!(*(m4.find(&\"throughput\".to_owned()).unwrap()), Metric::new(50.0, 2.0));\n     }\n }"}, {"sha": "754f636618e75d42d70ab8d4b16b7dde1fc074eb", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -1019,9 +1019,9 @@ mod tests {\n             assert_eq!(out, expected);\n         }\n \n-        t(&Summary::new([-2.0, -1.0]), ~\"-2 |[------******#*****---]| -1\");\n-        t(&Summary::new([0.0, 2.0]), ~\"0 |[-------*****#*******---]| 2\");\n-        t(&Summary::new([-2.0, 0.0]), ~\"-2 |[------******#******---]| 0\");\n+        t(&Summary::new([-2.0, -1.0]), \"-2 |[------******#*****---]| -1\".to_owned());\n+        t(&Summary::new([0.0, 2.0]), \"0 |[-------*****#*******---]| 2\".to_owned());\n+        t(&Summary::new([-2.0, 0.0]), \"-2 |[------******#******---]| 0\".to_owned());\n \n     }\n     #[test]"}, {"sha": "3a7b8a4d85cade8279f9e3fbc031ea45825d55ac", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 212, "deletions": 212, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -477,62 +477,62 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n       -> Result<uint, ~str> {\n         match ch {\n           'A' => match match_strs(s, pos, [\n-              (~\"Sunday\", 0_i32),\n-              (~\"Monday\", 1_i32),\n-              (~\"Tuesday\", 2_i32),\n-              (~\"Wednesday\", 3_i32),\n-              (~\"Thursday\", 4_i32),\n-              (~\"Friday\", 5_i32),\n-              (~\"Saturday\", 6_i32)\n+              (\"Sunday\".to_owned(), 0_i32),\n+              (\"Monday\".to_owned(), 1_i32),\n+              (\"Tuesday\".to_owned(), 2_i32),\n+              (\"Wednesday\".to_owned(), 3_i32),\n+              (\"Thursday\".to_owned(), 4_i32),\n+              (\"Friday\".to_owned(), 5_i32),\n+              (\"Saturday\".to_owned(), 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(~\"Invalid day\")\n+            None => Err(\"Invalid day\".to_owned())\n           },\n           'a' => match match_strs(s, pos, [\n-              (~\"Sun\", 0_i32),\n-              (~\"Mon\", 1_i32),\n-              (~\"Tue\", 2_i32),\n-              (~\"Wed\", 3_i32),\n-              (~\"Thu\", 4_i32),\n-              (~\"Fri\", 5_i32),\n-              (~\"Sat\", 6_i32)\n+              (\"Sun\".to_owned(), 0_i32),\n+              (\"Mon\".to_owned(), 1_i32),\n+              (\"Tue\".to_owned(), 2_i32),\n+              (\"Wed\".to_owned(), 3_i32),\n+              (\"Thu\".to_owned(), 4_i32),\n+              (\"Fri\".to_owned(), 5_i32),\n+              (\"Sat\".to_owned(), 6_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(~\"Invalid day\")\n+            None => Err(\"Invalid day\".to_owned())\n           },\n           'B' => match match_strs(s, pos, [\n-              (~\"January\", 0_i32),\n-              (~\"February\", 1_i32),\n-              (~\"March\", 2_i32),\n-              (~\"April\", 3_i32),\n-              (~\"May\", 4_i32),\n-              (~\"June\", 5_i32),\n-              (~\"July\", 6_i32),\n-              (~\"August\", 7_i32),\n-              (~\"September\", 8_i32),\n-              (~\"October\", 9_i32),\n-              (~\"November\", 10_i32),\n-              (~\"December\", 11_i32)\n+              (\"January\".to_owned(), 0_i32),\n+              (\"February\".to_owned(), 1_i32),\n+              (\"March\".to_owned(), 2_i32),\n+              (\"April\".to_owned(), 3_i32),\n+              (\"May\".to_owned(), 4_i32),\n+              (\"June\".to_owned(), 5_i32),\n+              (\"July\".to_owned(), 6_i32),\n+              (\"August\".to_owned(), 7_i32),\n+              (\"September\".to_owned(), 8_i32),\n+              (\"October\".to_owned(), 9_i32),\n+              (\"November\".to_owned(), 10_i32),\n+              (\"December\".to_owned(), 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(~\"Invalid month\")\n+            None => Err(\"Invalid month\".to_owned())\n           },\n           'b' | 'h' => match match_strs(s, pos, [\n-              (~\"Jan\", 0_i32),\n-              (~\"Feb\", 1_i32),\n-              (~\"Mar\", 2_i32),\n-              (~\"Apr\", 3_i32),\n-              (~\"May\", 4_i32),\n-              (~\"Jun\", 5_i32),\n-              (~\"Jul\", 6_i32),\n-              (~\"Aug\", 7_i32),\n-              (~\"Sep\", 8_i32),\n-              (~\"Oct\", 9_i32),\n-              (~\"Nov\", 10_i32),\n-              (~\"Dec\", 11_i32)\n+              (\"Jan\".to_owned(), 0_i32),\n+              (\"Feb\".to_owned(), 1_i32),\n+              (\"Mar\".to_owned(), 2_i32),\n+              (\"Apr\".to_owned(), 3_i32),\n+              (\"May\".to_owned(), 4_i32),\n+              (\"Jun\".to_owned(), 5_i32),\n+              (\"Jul\".to_owned(), 6_i32),\n+              (\"Aug\".to_owned(), 7_i32),\n+              (\"Sep\".to_owned(), 8_i32),\n+              (\"Oct\".to_owned(), 9_i32),\n+              (\"Nov\".to_owned(), 10_i32),\n+              (\"Dec\".to_owned(), 11_i32)\n           ]) {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(~\"Invalid month\")\n+            None => Err(\"Invalid month\".to_owned())\n           },\n           'C' => match match_digits_in_range(s, pos, 2u, false, 0_i32,\n                                              99_i32) {\n@@ -541,7 +541,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n                   Ok(pos)\n               }\n-            None => Err(~\"Invalid year\")\n+            None => Err(\"Invalid year\".to_owned())\n           },\n           'c' => {\n             parse_type(s, pos, 'a', &mut *tm)\n@@ -564,12 +564,12 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(~\"Invalid day of the month\")\n+            None => Err(\"Invalid day of the month\".to_owned())\n           },\n           'e' => match match_digits_in_range(s, pos, 2u, true, 1_i32,\n                                              31_i32) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(~\"Invalid day of the month\")\n+            None => Err(\"Invalid day of the month\".to_owned())\n           },\n           'f' => {\n             let (val, pos) = match_fractional_seconds(s, pos);\n@@ -586,7 +586,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           'H' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(~\"Invalid hour\")\n+              None => Err(\"Invalid hour\".to_owned())\n             }\n           }\n           'I' => {\n@@ -596,7 +596,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(~\"Invalid hour\")\n+              None => Err(\"Invalid hour\".to_owned())\n             }\n           }\n           'j' => {\n@@ -606,13 +606,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_yday = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(~\"Invalid day of year\")\n+              None => Err(\"Invalid day of year\".to_owned())\n             }\n           }\n           'k' => {\n             match match_digits_in_range(s, pos, 2u, true, 0_i32, 23_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(~\"Invalid hour\")\n+              None => Err(\"Invalid hour\".to_owned())\n             }\n           }\n           'l' => {\n@@ -622,13 +622,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   Ok(pos)\n               }\n-              None => Err(~\"Invalid hour\")\n+              None => Err(\"Invalid hour\".to_owned())\n             }\n           }\n           'M' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 59_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_min = v; Ok(pos) }\n-              None => Err(~\"Invalid minute\")\n+              None => Err(\"Invalid minute\".to_owned())\n             }\n           }\n           'm' => {\n@@ -638,21 +638,21 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_mon = v - 1_i32;\n                 Ok(pos)\n               }\n-              None => Err(~\"Invalid month\")\n+              None => Err(\"Invalid month\".to_owned())\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n-                                  [(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n+                                  [(\"am\".to_owned(), 0_i32), (\"pm\".to_owned(), 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(~\"Invalid hour\")\n+            None => Err(\"Invalid hour\".to_owned())\n           },\n           'p' => match match_strs(s, pos,\n-                                  [(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n+                                  [(\"AM\".to_owned(), 0_i32), (\"PM\".to_owned(), 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(~\"Invalid hour\")\n+            None => Err(\"Invalid hour\".to_owned())\n           },\n           'R' => {\n             parse_type(s, pos, 'H', &mut *tm)\n@@ -675,7 +675,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_sec = v;\n                 Ok(pos)\n               }\n-              None => Err(~\"Invalid second\")\n+              None => Err(\"Invalid second\".to_owned())\n             }\n           }\n           //'s' {}\n@@ -694,7 +694,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_wday = if v == 7 { 0 } else { v };\n                 Ok(pos)\n               }\n-              None => Err(~\"Invalid day of week\")\n+              None => Err(\"Invalid day of week\".to_owned())\n             }\n           }\n           'v' => {\n@@ -708,7 +708,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           'w' => {\n             match match_digits_in_range(s, pos, 1u, false, 0_i32, 6_i32) {\n               Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-              None => Err(~\"Invalid day of week\")\n+              None => Err(\"Invalid day of week\".to_owned())\n             }\n           }\n           'Y' => {\n@@ -718,7 +718,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_year = v - 1900_i32;\n                 Ok(pos)\n               }\n-              None => Err(~\"Invalid year\")\n+              None => Err(\"Invalid year\".to_owned())\n             }\n           }\n           'y' => {\n@@ -728,13 +728,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm.tm_year = v;\n                 Ok(pos)\n               }\n-              None => Err(~\"Invalid year\")\n+              None => Err(\"Invalid year\".to_owned())\n             }\n           }\n           'Z' => {\n             if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n-                tm.tm_zone = ~\"UTC\";\n+                tm.tm_zone = \"UTC\".to_owned();\n                 Ok(pos + 3u)\n             } else {\n                 // It's odd, but to maintain compatibility with c's\n@@ -759,15 +759,15 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n                         tm.tm_gmtoff = 0_i32;\n-                        tm.tm_zone = ~\"UTC\";\n+                        tm.tm_zone = \"UTC\".to_owned();\n                     }\n \n                     Ok(pos)\n                   }\n-                  None => Err(~\"Invalid zone offset\")\n+                  None => Err(\"Invalid zone offset\".to_owned())\n                 }\n             } else {\n-                Err(~\"Invalid zone offset\")\n+                Err(\"Invalid zone offset\".to_owned())\n             }\n           }\n           '%' => parse_char(s, pos, '%'),\n@@ -789,12 +789,12 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n-        tm_zone: ~\"\",\n+        tm_zone: \"\".to_owned(),\n         tm_nsec: 0_i32,\n     };\n     let mut pos = 0u;\n     let len = s.len();\n-    let mut result = Err(~\"Invalid time\");\n+    let mut result = Err(\"Invalid time\".to_owned());\n \n     while pos < len {\n         let range = s.char_range_at(pos);\n@@ -893,61 +893,61 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n             'G' => format!(\"{}\", year),\n             'g' => format!(\"{:02d}\", (year % 100 + 100) % 100),\n             'V' => format!(\"{:02d}\", days / 7 + 1),\n-            _ => ~\"\"\n+            _ => \"\".to_owned()\n         }\n     }\n \n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n       let die = || format!(\"strftime: can't understand this format {} \", ch);\n         match ch {\n           'A' => match tm.tm_wday as int {\n-            0 => ~\"Sunday\",\n-            1 => ~\"Monday\",\n-            2 => ~\"Tuesday\",\n-            3 => ~\"Wednesday\",\n-            4 => ~\"Thursday\",\n-            5 => ~\"Friday\",\n-            6 => ~\"Saturday\",\n+            0 => \"Sunday\".to_owned(),\n+            1 => \"Monday\".to_owned(),\n+            2 => \"Tuesday\".to_owned(),\n+            3 => \"Wednesday\".to_owned(),\n+            4 => \"Thursday\".to_owned(),\n+            5 => \"Friday\".to_owned(),\n+            6 => \"Saturday\".to_owned(),\n             _ => die()\n           },\n          'a' => match tm.tm_wday as int {\n-            0 => ~\"Sun\",\n-            1 => ~\"Mon\",\n-            2 => ~\"Tue\",\n-            3 => ~\"Wed\",\n-            4 => ~\"Thu\",\n-            5 => ~\"Fri\",\n-            6 => ~\"Sat\",\n+            0 => \"Sun\".to_owned(),\n+            1 => \"Mon\".to_owned(),\n+            2 => \"Tue\".to_owned(),\n+            3 => \"Wed\".to_owned(),\n+            4 => \"Thu\".to_owned(),\n+            5 => \"Fri\".to_owned(),\n+            6 => \"Sat\".to_owned(),\n             _ => die()\n           },\n           'B' => match tm.tm_mon as int {\n-            0 => ~\"January\",\n-            1 => ~\"February\",\n-            2 => ~\"March\",\n-            3 => ~\"April\",\n-            4 => ~\"May\",\n-            5 => ~\"June\",\n-            6 => ~\"July\",\n-            7 => ~\"August\",\n-            8 => ~\"September\",\n-            9 => ~\"October\",\n-            10 => ~\"November\",\n-            11 => ~\"December\",\n+            0 => \"January\".to_owned(),\n+            1 => \"February\".to_owned(),\n+            2 => \"March\".to_owned(),\n+            3 => \"April\".to_owned(),\n+            4 => \"May\".to_owned(),\n+            5 => \"June\".to_owned(),\n+            6 => \"July\".to_owned(),\n+            7 => \"August\".to_owned(),\n+            8 => \"September\".to_owned(),\n+            9 => \"October\".to_owned(),\n+            10 => \"November\".to_owned(),\n+            11 => \"December\".to_owned(),\n             _ => die()\n           },\n           'b' | 'h' => match tm.tm_mon as int {\n-            0 => ~\"Jan\",\n-            1 => ~\"Feb\",\n-            2 => ~\"Mar\",\n-            3 => ~\"Apr\",\n-            4 => ~\"May\",\n-            5 => ~\"Jun\",\n-            6 => ~\"Jul\",\n-            7 => ~\"Aug\",\n-            8 => ~\"Sep\",\n-            9 => ~\"Oct\",\n-            10 => ~\"Nov\",\n-            11 => ~\"Dec\",\n+            0 => \"Jan\".to_owned(),\n+            1 => \"Feb\".to_owned(),\n+            2 => \"Mar\".to_owned(),\n+            3 => \"Apr\".to_owned(),\n+            4 => \"May\".to_owned(),\n+            5 => \"Jun\".to_owned(),\n+            6 => \"Jul\".to_owned(),\n+            7 => \"Aug\".to_owned(),\n+            8 => \"Sep\".to_owned(),\n+            9 => \"Oct\".to_owned(),\n+            10 => \"Nov\".to_owned(),\n+            11 => \"Dec\".to_owned(),\n             _  => die()\n           },\n           'C' => format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n@@ -993,9 +993,9 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n           }\n           'M' => format!(\"{:02d}\", tm.tm_min),\n           'm' => format!(\"{:02d}\", tm.tm_mon + 1),\n-          'n' => ~\"\\n\",\n-          'P' => if (tm.tm_hour as int) < 12 { ~\"am\" } else { ~\"pm\" },\n-          'p' => if (tm.tm_hour as int) < 12 { ~\"AM\" } else { ~\"PM\" },\n+          'n' => \"\\n\".to_owned(),\n+          'P' => if (tm.tm_hour as int) < 12 { \"am\".to_owned() } else { \"pm\".to_owned() },\n+          'p' => if (tm.tm_hour as int) < 12 { \"AM\".to_owned() } else { \"PM\".to_owned() },\n           'R' => {\n             format!(\"{}:{}\",\n                 parse_type('H', tm),\n@@ -1016,7 +1016,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n                 parse_type('M', tm),\n                 parse_type('S', tm))\n           }\n-          't' => ~\"\\t\",\n+          't' => \"\\t\".to_owned(),\n           'U' => format!(\"{:02d}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n           'u' => {\n             let i = tm.tm_wday as int;\n@@ -1043,7 +1043,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n             format!(\"{}{:02d}{:02d}\", sign, h, m)\n           }\n           '+' => tm.rfc3339(),\n-          '%' => ~\"%\",\n+          '%' => \"%\".to_owned(),\n           _   => die()\n         }\n     }\n@@ -1158,7 +1158,7 @@ mod tests {\n         assert_eq!(utc.tm_yday, 43_i32);\n         assert_eq!(utc.tm_isdst, 0_i32);\n         assert_eq!(utc.tm_gmtoff, 0_i32);\n-        assert_eq!(utc.tm_zone, ~\"UTC\");\n+        assert_eq!(utc.tm_zone, \"UTC\".to_owned());\n         assert_eq!(utc.tm_nsec, 54321_i32);\n     }\n \n@@ -1184,7 +1184,7 @@ mod tests {\n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = &local.tm_zone;\n-        assert!(*zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\");\n+        assert!(*zone == \"PST\".to_owned() || *zone == \"Pacific Standard Time\".to_owned());\n \n         assert_eq!(local.tm_nsec, 54321_i32);\n     }\n@@ -1228,16 +1228,16 @@ mod tests {\n             assert!(tm.tm_wday == 0_i32);\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n-            assert!(tm.tm_zone == ~\"\");\n+            assert!(tm.tm_zone == \"\".to_owned());\n             assert!(tm.tm_nsec == 0_i32);\n           }\n           Err(_) => ()\n         }\n \n         let format = \"%a %b %e %T.%f %Y\";\n-        assert_eq!(strptime(\"\", format), Err(~\"Invalid time\"));\n+        assert_eq!(strptime(\"\", format), Err(\"Invalid time\".to_owned()));\n         assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n-            == Err(~\"Invalid time\"));\n+            == Err(\"Invalid time\".to_owned()));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n           Err(e) => fail!(e),\n@@ -1252,7 +1252,7 @@ mod tests {\n             assert!(tm.tm_yday == 0_i32);\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n-            assert!(tm.tm_zone == ~\"\");\n+            assert!(tm.tm_zone == \"\".to_owned());\n             assert!(tm.tm_nsec == 12340000_i32);\n           }\n         }\n@@ -1265,62 +1265,62 @@ mod tests {\n         }\n \n         let days = [\n-            ~\"Sunday\",\n-            ~\"Monday\",\n-            ~\"Tuesday\",\n-            ~\"Wednesday\",\n-            ~\"Thursday\",\n-            ~\"Friday\",\n-            ~\"Saturday\"\n+            \"Sunday\".to_owned(),\n+            \"Monday\".to_owned(),\n+            \"Tuesday\".to_owned(),\n+            \"Wednesday\".to_owned(),\n+            \"Thursday\".to_owned(),\n+            \"Friday\".to_owned(),\n+            \"Saturday\".to_owned()\n         ];\n         for day in days.iter() {\n             assert!(test(*day, \"%A\"));\n         }\n \n         let days = [\n-            ~\"Sun\",\n-            ~\"Mon\",\n-            ~\"Tue\",\n-            ~\"Wed\",\n-            ~\"Thu\",\n-            ~\"Fri\",\n-            ~\"Sat\"\n+            \"Sun\".to_owned(),\n+            \"Mon\".to_owned(),\n+            \"Tue\".to_owned(),\n+            \"Wed\".to_owned(),\n+            \"Thu\".to_owned(),\n+            \"Fri\".to_owned(),\n+            \"Sat\".to_owned()\n         ];\n         for day in days.iter() {\n             assert!(test(*day, \"%a\"));\n         }\n \n         let months = [\n-            ~\"January\",\n-            ~\"February\",\n-            ~\"March\",\n-            ~\"April\",\n-            ~\"May\",\n-            ~\"June\",\n-            ~\"July\",\n-            ~\"August\",\n-            ~\"September\",\n-            ~\"October\",\n-            ~\"November\",\n-            ~\"December\"\n+            \"January\".to_owned(),\n+            \"February\".to_owned(),\n+            \"March\".to_owned(),\n+            \"April\".to_owned(),\n+            \"May\".to_owned(),\n+            \"June\".to_owned(),\n+            \"July\".to_owned(),\n+            \"August\".to_owned(),\n+            \"September\".to_owned(),\n+            \"October\".to_owned(),\n+            \"November\".to_owned(),\n+            \"December\".to_owned()\n         ];\n         for day in months.iter() {\n             assert!(test(*day, \"%B\"));\n         }\n \n         let months = [\n-            ~\"Jan\",\n-            ~\"Feb\",\n-            ~\"Mar\",\n-            ~\"Apr\",\n-            ~\"May\",\n-            ~\"Jun\",\n-            ~\"Jul\",\n-            ~\"Aug\",\n-            ~\"Sep\",\n-            ~\"Oct\",\n-            ~\"Nov\",\n-            ~\"Dec\"\n+            \"Jan\".to_owned(),\n+            \"Feb\".to_owned(),\n+            \"Mar\".to_owned(),\n+            \"Apr\".to_owned(),\n+            \"May\".to_owned(),\n+            \"Jun\".to_owned(),\n+            \"Jul\".to_owned(),\n+            \"Aug\".to_owned(),\n+            \"Sep\".to_owned(),\n+            \"Oct\".to_owned(),\n+            \"Nov\".to_owned(),\n+            \"Dec\".to_owned()\n         ];\n         for day in months.iter() {\n             assert!(test(*day, \"%b\"));\n@@ -1365,17 +1365,17 @@ mod tests {\n         assert!(test(\"2009\", \"%Y\"));\n         assert!(test(\"09\", \"%y\"));\n         assert!(strptime(\"UTC\", \"%Z\").unwrap().tm_zone ==\n-            ~\"UTC\");\n+            \"UTC\".to_owned());\n         assert!(strptime(\"PST\", \"%Z\").unwrap().tm_zone ==\n-            ~\"\");\n+            \"\".to_owned());\n         assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff ==\n             0);\n         assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff ==\n             0);\n         assert!(test(\"%\", \"%%\"));\n \n         // Test for #7256\n-        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(~\"Invalid year\"))\n+        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(\"Invalid year\".to_owned()))\n     }\n \n     fn test_ctime() {\n@@ -1387,8 +1387,8 @@ mod tests {\n \n         debug!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n-        assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n-        assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_owned());\n+        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_owned());\n     }\n \n     fn test_strftime() {\n@@ -1398,70 +1398,70 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(\"\"), ~\"\");\n-        assert_eq!(local.strftime(\"%A\"), ~\"Friday\");\n-        assert_eq!(local.strftime(\"%a\"), ~\"Fri\");\n-        assert_eq!(local.strftime(\"%B\"), ~\"February\");\n-        assert_eq!(local.strftime(\"%b\"), ~\"Feb\");\n-        assert_eq!(local.strftime(\"%C\"), ~\"20\");\n-        assert_eq!(local.strftime(\"%c\"), ~\"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.strftime(\"%D\"), ~\"02/13/09\");\n-        assert_eq!(local.strftime(\"%d\"), ~\"13\");\n-        assert_eq!(local.strftime(\"%e\"), ~\"13\");\n-        assert_eq!(local.strftime(\"%f\"), ~\"000054321\");\n-        assert_eq!(local.strftime(\"%F\"), ~\"2009-02-13\");\n-        assert_eq!(local.strftime(\"%G\"), ~\"2009\");\n-        assert_eq!(local.strftime(\"%g\"), ~\"09\");\n-        assert_eq!(local.strftime(\"%H\"), ~\"15\");\n-        assert_eq!(local.strftime(\"%I\"), ~\"03\");\n-        assert_eq!(local.strftime(\"%j\"), ~\"044\");\n-        assert_eq!(local.strftime(\"%k\"), ~\"15\");\n-        assert_eq!(local.strftime(\"%l\"), ~\" 3\");\n-        assert_eq!(local.strftime(\"%M\"), ~\"31\");\n-        assert_eq!(local.strftime(\"%m\"), ~\"02\");\n-        assert_eq!(local.strftime(\"%n\"), ~\"\\n\");\n-        assert_eq!(local.strftime(\"%P\"), ~\"pm\");\n-        assert_eq!(local.strftime(\"%p\"), ~\"PM\");\n-        assert_eq!(local.strftime(\"%R\"), ~\"15:31\");\n-        assert_eq!(local.strftime(\"%r\"), ~\"03:31:30 PM\");\n-        assert_eq!(local.strftime(\"%S\"), ~\"30\");\n-        assert_eq!(local.strftime(\"%s\"), ~\"1234567890\");\n-        assert_eq!(local.strftime(\"%T\"), ~\"15:31:30\");\n-        assert_eq!(local.strftime(\"%t\"), ~\"\\t\");\n-        assert_eq!(local.strftime(\"%U\"), ~\"06\");\n-        assert_eq!(local.strftime(\"%u\"), ~\"5\");\n-        assert_eq!(local.strftime(\"%V\"), ~\"07\");\n-        assert_eq!(local.strftime(\"%v\"), ~\"13-Feb-2009\");\n-        assert_eq!(local.strftime(\"%W\"), ~\"06\");\n-        assert_eq!(local.strftime(\"%w\"), ~\"5\");\n-        assert_eq!(local.strftime(\"%X\"), ~\"15:31:30\"); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\"), ~\"02/13/09\"); // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%Y\"), ~\"2009\");\n-        assert_eq!(local.strftime(\"%y\"), ~\"09\");\n-        assert_eq!(local.strftime(\"%+\"), ~\"2009-02-13T15:31:30-08:00\");\n+        assert_eq!(local.strftime(\"\"), \"\".to_owned());\n+        assert_eq!(local.strftime(\"%A\"), \"Friday\".to_owned());\n+        assert_eq!(local.strftime(\"%a\"), \"Fri\".to_owned());\n+        assert_eq!(local.strftime(\"%B\"), \"February\".to_owned());\n+        assert_eq!(local.strftime(\"%b\"), \"Feb\".to_owned());\n+        assert_eq!(local.strftime(\"%C\"), \"20\".to_owned());\n+        assert_eq!(local.strftime(\"%c\"), \"Fri Feb 13 15:31:30 2009\".to_owned());\n+        assert_eq!(local.strftime(\"%D\"), \"02/13/09\".to_owned());\n+        assert_eq!(local.strftime(\"%d\"), \"13\".to_owned());\n+        assert_eq!(local.strftime(\"%e\"), \"13\".to_owned());\n+        assert_eq!(local.strftime(\"%f\"), \"000054321\".to_owned());\n+        assert_eq!(local.strftime(\"%F\"), \"2009-02-13\".to_owned());\n+        assert_eq!(local.strftime(\"%G\"), \"2009\".to_owned());\n+        assert_eq!(local.strftime(\"%g\"), \"09\".to_owned());\n+        assert_eq!(local.strftime(\"%H\"), \"15\".to_owned());\n+        assert_eq!(local.strftime(\"%I\"), \"03\".to_owned());\n+        assert_eq!(local.strftime(\"%j\"), \"044\".to_owned());\n+        assert_eq!(local.strftime(\"%k\"), \"15\".to_owned());\n+        assert_eq!(local.strftime(\"%l\"), \" 3\".to_owned());\n+        assert_eq!(local.strftime(\"%M\"), \"31\".to_owned());\n+        assert_eq!(local.strftime(\"%m\"), \"02\".to_owned());\n+        assert_eq!(local.strftime(\"%n\"), \"\\n\".to_owned());\n+        assert_eq!(local.strftime(\"%P\"), \"pm\".to_owned());\n+        assert_eq!(local.strftime(\"%p\"), \"PM\".to_owned());\n+        assert_eq!(local.strftime(\"%R\"), \"15:31\".to_owned());\n+        assert_eq!(local.strftime(\"%r\"), \"03:31:30 PM\".to_owned());\n+        assert_eq!(local.strftime(\"%S\"), \"30\".to_owned());\n+        assert_eq!(local.strftime(\"%s\"), \"1234567890\".to_owned());\n+        assert_eq!(local.strftime(\"%T\"), \"15:31:30\".to_owned());\n+        assert_eq!(local.strftime(\"%t\"), \"\\t\".to_owned());\n+        assert_eq!(local.strftime(\"%U\"), \"06\".to_owned());\n+        assert_eq!(local.strftime(\"%u\"), \"5\".to_owned());\n+        assert_eq!(local.strftime(\"%V\"), \"07\".to_owned());\n+        assert_eq!(local.strftime(\"%v\"), \"13-Feb-2009\".to_owned());\n+        assert_eq!(local.strftime(\"%W\"), \"06\".to_owned());\n+        assert_eq!(local.strftime(\"%w\"), \"5\".to_owned());\n+        assert_eq!(local.strftime(\"%X\"), \"15:31:30\".to_owned()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%x\"), \"02/13/09\".to_owned()); // FIXME (#2350): support locale\n+        assert_eq!(local.strftime(\"%Y\"), \"2009\".to_owned());\n+        assert_eq!(local.strftime(\"%y\"), \"09\".to_owned());\n+        assert_eq!(local.strftime(\"%+\"), \"2009-02-13T15:31:30-08:00\".to_owned());\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(\"%Z\");\n-        assert!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n+        assert!(zone == \"PST\".to_owned() || zone == \"Pacific Standard Time\".to_owned());\n \n-        assert_eq!(local.strftime(\"%z\"), ~\"-0800\");\n-        assert_eq!(local.strftime(\"%%\"), ~\"%\");\n+        assert_eq!(local.strftime(\"%z\"), \"-0800\".to_owned());\n+        assert_eq!(local.strftime(\"%%\"), \"%\".to_owned());\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n-        let prefix = ~\"Fri, 13 Feb 2009 15:31:30 \";\n+        let prefix = \"Fri, 13 Feb 2009 15:31:30 \".to_owned();\n         assert!(rfc822 == prefix + \"PST\" || rfc822 == prefix + \"Pacific Standard Time\");\n \n-        assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.rfc822z(), ~\"Fri, 13 Feb 2009 15:31:30 -0800\");\n-        assert_eq!(local.rfc3339(), ~\"2009-02-13T15:31:30-08:00\");\n+        assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_owned());\n+        assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_owned());\n+        assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_owned());\n \n-        assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n-        assert_eq!(utc.rfc822(), ~\"Fri, 13 Feb 2009 23:31:30 GMT\");\n-        assert_eq!(utc.rfc822z(), ~\"Fri, 13 Feb 2009 23:31:30 -0000\");\n-        assert_eq!(utc.rfc3339(), ~\"2009-02-13T23:31:30Z\");\n+        assert_eq!(utc.ctime(), \"Fri Feb 13 23:31:30 2009\".to_owned());\n+        assert_eq!(utc.rfc822(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_owned());\n+        assert_eq!(utc.rfc822z(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_owned());\n+        assert_eq!(utc.rfc3339(), \"2009-02-13T23:31:30Z\".to_owned());\n     }\n \n     fn test_timespec_eq_ord() {"}, {"sha": "f875a1a0619752488816a62a38b96998945cf308", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 215, "deletions": 213, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -39,13 +39,13 @@ use std::uint;\n /// ```rust\n /// use url::{Url, UserInfo};\n ///\n-/// let url = Url { scheme: ~\"https\",\n-///                 user: Some(UserInfo { user: ~\"username\", pass: None }),\n-///                 host: ~\"example.com\",\n-///                 port: Some(~\"8080\"),\n-///                 path: ~\"/foo/bar\",\n-///                 query: vec!((~\"baz\", ~\"qux\")),\n-///                 fragment: Some(~\"quz\") };\n+/// let url = Url { scheme: \"https\".to_owned(),\n+///                 user: Some(UserInfo { user: \"username\".to_owned(), pass: None }),\n+///                 host: \"example.com\".to_owned(),\n+///                 port: Some(\"8080\".to_owned()),\n+///                 path: \"/foo/bar\".to_owned(),\n+///                 query: vec!((\"baz\".to_owned(), \"qux\".to_owned())),\n+///                 fragment: Some(\"quz\".to_owned()) };\n /// // https://username@example.com:8080/foo/bar?baz=qux#quz\n /// ```\n #[deriving(Clone, Eq, TotalEq)]\n@@ -60,7 +60,7 @@ pub struct Url {\n     pub port: Option<~str>,\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: ~str,\n-    /// The query component of a URL.  `vec!((~\"baz\", ~\"qux\"))` represents the\n+    /// The query component of a URL.  `vec!((\"baz\".to_owned(), \"qux\".to_owned()))` represents the\n     /// fragment `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n@@ -71,7 +71,7 @@ pub struct Url {\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: ~str,\n-    /// The query component of a URL.  `vec!((~\"baz\", ~\"qux\"))` represents the\n+    /// The query component of a URL.  `vec!((\"baz\".to_owned(), \"qux\".to_owned()))` represents the\n     /// fragment `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n@@ -413,7 +413,7 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (s.slice(0, index).to_owned(), ~\"\");\n+        return (s.slice(0, index).to_owned(), \"\".to_owned());\n     } else {\n         return (s.slice(0, index).to_owned(),\n              s.slice(index + mat, s.len()).to_owned());\n@@ -446,7 +446,9 @@ fn query_from_str(rawquery: &str) -> Query {\n  * # Example\n  *\n  * ```rust\n- * let query = vec!((~\"title\", ~\"The Village\"), (~\"north\", ~\"52.91\"), (~\"west\", ~\"4.10\"));\n+ * let query = vec!((\"title\".to_owned(), \"The Village\".to_owned()),\n+                    (\"north\".to_owned(), \"52.91\".to_owned()),\n+                    (\"west\".to_owned(), \"4.10\".to_owned()));\n  * println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n  * ```\n  */\n@@ -476,7 +478,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n  *\n  * let scheme = match get_scheme(\"https://example.com/\") {\n  *     Ok((sch, _)) => sch,\n- *     Err(_) => ~\"(None)\",\n+ *     Err(_) => \"(None)\".to_owned(),\n  * };\n  * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n  * ```\n@@ -487,24 +489,24 @@ pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n           'A' .. 'Z' | 'a' .. 'z' => continue,\n           '0' .. '9' | '+' | '-' | '.' => {\n             if i == 0 {\n-                return Err(~\"url: Scheme must begin with a letter.\");\n+                return Err(\"url: Scheme must begin with a letter.\".to_owned());\n             }\n             continue;\n           }\n           ':' => {\n             if i == 0 {\n-                return Err(~\"url: Scheme cannot be empty.\");\n+                return Err(\"url: Scheme cannot be empty.\".to_owned());\n             } else {\n                 return Ok((rawurl.slice(0,i).to_owned(),\n                                 rawurl.slice(i+1,rawurl.len()).to_owned()));\n             }\n           }\n           _ => {\n-            return Err(~\"url: Invalid character in scheme.\");\n+            return Err(\"url: Invalid character in scheme.\".to_owned());\n           }\n         }\n     };\n-    return Err(~\"url: Scheme must be terminated with a colon.\");\n+    return Err(\"url: Scheme must be terminated with a colon.\".to_owned());\n }\n \n #[deriving(Clone, Eq)]\n@@ -519,7 +521,7 @@ fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n     if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n-        return Ok((None, ~\"\", None, rawurl.to_str()));\n+        return Ok((None, \"\".to_owned(), None, rawurl.to_str()));\n     }\n \n     enum State {\n@@ -536,7 +538,7 @@ fn get_authority(rawurl: &str) ->\n     let mut input = Digit; // most restricted, start here.\n \n     let mut userinfo = None;\n-    let mut host = ~\"\";\n+    let mut host = \"\".to_owned();\n     let mut port = None;\n \n     let mut colon_count = 0;\n@@ -563,7 +565,7 @@ fn get_authority(rawurl: &str) ->\n             // separators, don't change anything\n           }\n           _ => {\n-            return Err(~\"Illegal character in authority\");\n+            return Err(\"Illegal character in authority\".to_owned());\n           }\n         }\n \n@@ -580,7 +582,7 @@ fn get_authority(rawurl: &str) ->\n                 // multiple colons means ipv6 address.\n                 if input == Unreserved {\n                     return Err(\n-                        ~\"Illegal characters in IPv6 address.\");\n+                        \"Illegal characters in IPv6 address.\".to_owned());\n                 }\n                 st = Ip6Host;\n               }\n@@ -597,7 +599,7 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Port => {\n                 if input == Unreserved {\n-                    return Err(~\"Illegal characters in authority.\");\n+                    return Err(\"Illegal characters in authority.\".to_owned());\n                 }\n                 st = Ip6Host;\n               }\n@@ -609,7 +611,7 @@ fn get_authority(rawurl: &str) ->\n                 }\n               }\n               _ => {\n-                return Err(~\"Invalid ':' in authority.\");\n+                return Err(\"Invalid ':' in authority.\".to_owned());\n               }\n             }\n             input = Digit; // reset input class\n@@ -631,7 +633,7 @@ fn get_authority(rawurl: &str) ->\n                 st = InHost;\n               }\n               _ => {\n-                return Err(~\"Invalid '@' in authority.\");\n+                return Err(\"Invalid '@' in authority.\".to_owned());\n               }\n             }\n             begin = i+1;\n@@ -652,7 +654,7 @@ fn get_authority(rawurl: &str) ->\n       }\n       PassHostPort | Ip6Port => {\n         if input != Digit {\n-            return Err(~\"Non-digit characters in port.\");\n+            return Err(\"Non-digit characters in port.\".to_owned());\n         }\n         host = rawurl.slice(begin, pos).to_owned();\n         port = Some(rawurl.slice(pos+1, end).to_owned());\n@@ -662,7 +664,7 @@ fn get_authority(rawurl: &str) ->\n       }\n       InPort => {\n         if input != Digit {\n-            return Err(~\"Non-digit characters in port.\");\n+            return Err(\"Non-digit characters in port.\".to_owned());\n         }\n         port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n@@ -689,14 +691,14 @@ fn get_path(rawurl: &str, authority: bool) ->\n             end = i;\n             break;\n           }\n-          _ => return Err(~\"Invalid character in path.\")\n+          _ => return Err(\"Invalid character in path.\".to_owned())\n         }\n     }\n \n     if authority {\n         if end != 0 && !rawurl.starts_with(\"/\") {\n-            return Err(~\"Non-empty path must begin with\\\n-                               '/' in presence of authority.\");\n+            return Err(\"Non-empty path must begin with\\\n+                              '/' in presence of authority.\".to_owned());\n         }\n     }\n \n@@ -748,7 +750,7 @@ pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n     };\n \n     // path\n-    let has_authority = if host == ~\"\" { false } else { true };\n+    let has_authority = if host == \"\".to_owned() { false } else { true };\n     let (path, rest) = match get_path(rest, has_authority) {\n         Ok(val) => val,\n         Err(e) => return Err(e),\n@@ -875,53 +877,53 @@ impl<S: Writer> Hash<S> for Path {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, ~\"hello\");\n-    assert_eq!(v, ~\" sweet world\");\n+    assert_eq!(u, \"hello\".to_owned());\n+    assert_eq!(v, \" sweet world\".to_owned());\n \n     let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, ~\"hello sweet world\");\n-    assert_eq!(v, ~\"\");\n+    assert_eq!(u, \"hello sweet world\".to_owned());\n+    assert_eq!(v, \"\".to_owned());\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert_eq!(u, Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n-    assert_eq!(h, ~\"rust-lang.org\");\n+    assert_eq!(u, Some(UserInfo::new(\"user\".to_owned(), Some(\"pass\".to_owned()))));\n+    assert_eq!(h, \"rust-lang.org\".to_owned());\n     assert!(p.is_none());\n-    assert_eq!(r, ~\"/something\");\n+    assert_eq!(r, \"/something\".to_owned());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, ~\"rust-lang.org\");\n-    assert_eq!(p, Some(~\"8000\"));\n-    assert_eq!(r, ~\"?something\");\n+    assert_eq!(h, \"rust-lang.org\".to_owned());\n+    assert_eq!(p, Some(\"8000\".to_owned()));\n+    assert_eq!(r, \"?something\".to_owned());\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, ~\"rust-lang.org\");\n+    assert_eq!(h, \"rust-lang.org\".to_owned());\n     assert!(p.is_none());\n-    assert_eq!(r, ~\"#blah\");\n+    assert_eq!(r, \"#blah\".to_owned());\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert_eq!(p, Some(~\"8000\"));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n+    assert_eq!(p, Some(\"8000\".to_owned()));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert_eq!(u, Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n-    assert_eq!(h, ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert_eq!(p, Some(~\"8000\"));\n+    assert_eq!(u, Some(UserInfo::new(\"us\".to_owned(), Some(\"p\".to_owned()))));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_owned());\n+    assert_eq!(p, Some(\"8000\".to_owned()));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -933,22 +935,22 @@ fn test_get_authority() {\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, ~\"\");\n+    assert_eq!(h, \"\".to_owned());\n     let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, ~\"\");\n+    assert_eq!(h, \"\".to_owned());\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert_eq!(p, ~\"/something+ orother\");\n-    assert_eq!(r, ~\"\");\n+    assert_eq!(p, \"/something+ orother\".to_owned());\n+    assert_eq!(r, \"\".to_owned());\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert_eq!(p, ~\"test@email.com\");\n-    assert_eq!(r, ~\"#fragment\");\n+    assert_eq!(p, \"test@email.com\".to_owned());\n+    assert_eq!(r, \"#fragment\".to_owned());\n     let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n-    assert_eq!(p, ~\"/gen/:addr=\");\n-    assert_eq!(r, ~\"?q=v\");\n+    assert_eq!(p, \"/gen/:addr=\".to_owned());\n+    assert_eq!(r, \"?q=v\".to_owned());\n \n     //failure cases\n     assert!(get_path(\"something?q\", true).is_err());\n@@ -964,87 +966,87 @@ mod tests {\n \n     #[test]\n     fn test_url_parse() {\n-        let url = ~\"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n+        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\".to_owned();\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert_eq!(&u.scheme, &~\"http\");\n-        assert_eq!(&u.user, &Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n-        assert_eq!(&u.host, &~\"rust-lang.org\");\n-        assert_eq!(&u.port, &Some(~\"8080\"));\n-        assert_eq!(&u.path, &~\"/doc/~u\");\n-        assert_eq!(&u.query, &vec!((~\"s\", ~\"v\")));\n-        assert_eq!(&u.fragment, &Some(~\"something\"));\n+        assert_eq!(&u.scheme, &\"http\".to_owned());\n+        assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_owned(), Some(\"pass\".to_owned()))));\n+        assert_eq!(&u.host, &\"rust-lang.org\".to_owned());\n+        assert_eq!(&u.port, &Some(\"8080\".to_owned()));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_owned());\n+        assert_eq!(&u.query, &vec!((\"s\".to_owned(), \"v\".to_owned())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_owned()));\n     }\n \n     #[test]\n     fn test_path_parse() {\n-        let path = ~\"/doc/~u?s=v#something\";\n+        let path = \"/doc/~u?s=v#something\".to_owned();\n \n         let up = path_from_str(path);\n         let u = up.unwrap();\n-        assert_eq!(&u.path, &~\"/doc/~u\");\n-        assert_eq!(&u.query, &vec!((~\"s\", ~\"v\")));\n-        assert_eq!(&u.fragment, &Some(~\"something\"));\n+        assert_eq!(&u.path, &\"/doc/~u\".to_owned());\n+        assert_eq!(&u.query, &vec!((\"s\".to_owned(), \"v\".to_owned())));\n+        assert_eq!(&u.fragment, &Some(\"something\".to_owned()));\n     }\n \n     #[test]\n     fn test_url_parse_host_slash() {\n-        let urlstr = ~\"http://0.42.42.42/\";\n+        let urlstr = \"http://0.42.42.42/\".to_owned();\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.host == ~\"0.42.42.42\");\n-        assert!(url.path == ~\"/\");\n+        assert!(url.host == \"0.42.42.42\".to_owned());\n+        assert!(url.path == \"/\".to_owned());\n     }\n \n     #[test]\n     fn test_path_parse_host_slash() {\n-        let pathstr = ~\"/\";\n+        let pathstr = \"/\".to_owned();\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == ~\"/\");\n+        assert!(path.path == \"/\".to_owned());\n     }\n \n     #[test]\n     fn test_url_host_with_port() {\n-        let urlstr = ~\"scheme://host:1234\";\n+        let urlstr = \"scheme://host:1234\".to_owned();\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &~\"scheme\");\n-        assert_eq!(&url.host, &~\"host\");\n-        assert_eq!(&url.port, &Some(~\"1234\"));\n-        assert_eq!(&url.path, &~\"\"); // is empty path really correct? Other tests think so\n-        let urlstr = ~\"scheme://host:1234/\";\n+        assert_eq!(&url.scheme, &\"scheme\".to_owned());\n+        assert_eq!(&url.host, &\"host\".to_owned());\n+        assert_eq!(&url.port, &Some(\"1234\".to_owned()));\n+        assert_eq!(&url.path, &\"\".to_owned()); // is empty path really correct? Other tests think so\n+        let urlstr = \"scheme://host:1234/\".to_owned();\n         let url = from_str(urlstr).unwrap();\n-        assert_eq!(&url.scheme, &~\"scheme\");\n-        assert_eq!(&url.host, &~\"host\");\n-        assert_eq!(&url.port, &Some(~\"1234\"));\n-        assert_eq!(&url.path, &~\"/\");\n+        assert_eq!(&url.scheme, &\"scheme\".to_owned());\n+        assert_eq!(&url.host, &\"host\".to_owned());\n+        assert_eq!(&url.port, &Some(\"1234\".to_owned()));\n+        assert_eq!(&url.path, &\"/\".to_owned());\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n-        let urlstr = ~\"http://dotcom.com/file_name.html\";\n+        let urlstr = \"http://dotcom.com/file_name.html\".to_owned();\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == ~\"/file_name.html\");\n+        assert!(url.path == \"/file_name.html\".to_owned());\n     }\n \n     #[test]\n     fn test_path_with_underscores() {\n-        let pathstr = ~\"/file_name.html\";\n+        let pathstr = \"/file_name.html\".to_owned();\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == ~\"/file_name.html\");\n+        assert!(path.path == \"/file_name.html\".to_owned());\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n-        let urlstr = ~\"http://dotcom.com/file-name.html\";\n+        let urlstr = \"http://dotcom.com/file-name.html\".to_owned();\n         let url = from_str(urlstr).unwrap();\n-        assert!(url.path == ~\"/file-name.html\");\n+        assert!(url.path == \"/file-name.html\".to_owned());\n     }\n \n     #[test]\n     fn test_path_with_dashes() {\n-        let pathstr = ~\"/file-name.html\";\n+        let pathstr = \"/file-name.html\".to_owned();\n         let path = path_from_str(pathstr).unwrap();\n-        assert!(path.path == ~\"/file-name.html\");\n+        assert!(path.path == \"/file-name.html\".to_owned());\n     }\n \n     #[test]\n@@ -1060,217 +1062,217 @@ mod tests {\n \n     #[test]\n     fn test_full_url_parse_and_format() {\n-        let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n+        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n-        let url = ~\"http://rust-lang.org/doc?s=v#something\";\n+        let url = \"http://rust-lang.org/doc?s=v#something\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n-        let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n+        let url = \"http://user:pass@rust-lang.org/doc#something\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n-        let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n-        let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n+        let url = \"http://user:pass@rust-lang.org/doc?#something\".to_owned();\n+        let should_be = \"http://user:pass@rust-lang.org/doc#something\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), should_be);\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n-        let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n+        let url = \"http://user:pass@rust-lang.org/doc?q=v\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n-        let url = ~\"http://rust-lang.org/doc\";\n+        let url = \"http://rust-lang.org/doc\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_url_with_port_parse_and_format() {\n-        let url = ~\"http://rust-lang.org:80/doc\";\n+        let url = \"http://rust-lang.org:80/doc\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n-        let url = ~\"http://rust-lang.org\";\n+        let url = \"http://rust-lang.org\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n-        let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n+        let url = \"http://user:pass@rust-lang.org?q=v#something\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n-        let url = ~\"http://rust-lang.org#something\";\n+        let url = \"http://rust-lang.org#something\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_url_component_encoding() {\n-        let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n+        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\".to_owned();\n         let u = from_str(url).unwrap();\n-        assert!(u.path == ~\"/doc uments\");\n-        assert!(u.query == vec!((~\"ba%d \", ~\"#&+\")));\n+        assert!(u.path == \"/doc uments\".to_owned());\n+        assert!(u.query == vec!((\"ba%d \".to_owned(), \"#&+\".to_owned())));\n     }\n \n     #[test]\n     fn test_path_component_encoding() {\n-        let path = ~\"/doc%20uments?ba%25d%20=%23%26%2B\";\n+        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\".to_owned();\n         let p = path_from_str(path).unwrap();\n-        assert!(p.path == ~\"/doc uments\");\n-        assert!(p.query == vec!((~\"ba%d \", ~\"#&+\")));\n+        assert!(p.path == \"/doc uments\".to_owned());\n+        assert!(p.query == vec!((\"ba%d \".to_owned(), \"#&+\".to_owned())));\n     }\n \n     #[test]\n     fn test_url_without_authority() {\n-        let url = ~\"mailto:test@email.com\";\n+        let url = \"mailto:test@email.com\".to_owned();\n         assert_eq!(from_str(url).unwrap().to_str(), url);\n     }\n \n     #[test]\n     fn test_encode() {\n-        assert_eq!(encode(\"\"), ~\"\");\n-        assert_eq!(encode(\"http://example.com\"), ~\"http://example.com\");\n-        assert_eq!(encode(\"foo bar% baz\"), ~\"foo%20bar%25%20baz\");\n-        assert_eq!(encode(\" \"), ~\"%20\");\n-        assert_eq!(encode(\"!\"), ~\"!\");\n-        assert_eq!(encode(\"\\\"\"), ~\"\\\"\");\n-        assert_eq!(encode(\"#\"), ~\"#\");\n-        assert_eq!(encode(\"$\"), ~\"$\");\n-        assert_eq!(encode(\"%\"), ~\"%25\");\n-        assert_eq!(encode(\"&\"), ~\"&\");\n-        assert_eq!(encode(\"'\"), ~\"%27\");\n-        assert_eq!(encode(\"(\"), ~\"(\");\n-        assert_eq!(encode(\")\"), ~\")\");\n-        assert_eq!(encode(\"*\"), ~\"*\");\n-        assert_eq!(encode(\"+\"), ~\"+\");\n-        assert_eq!(encode(\",\"), ~\",\");\n-        assert_eq!(encode(\"/\"), ~\"/\");\n-        assert_eq!(encode(\":\"), ~\":\");\n-        assert_eq!(encode(\";\"), ~\";\");\n-        assert_eq!(encode(\"=\"), ~\"=\");\n-        assert_eq!(encode(\"?\"), ~\"?\");\n-        assert_eq!(encode(\"@\"), ~\"@\");\n-        assert_eq!(encode(\"[\"), ~\"[\");\n-        assert_eq!(encode(\"]\"), ~\"]\");\n+        assert_eq!(encode(\"\"), \"\".to_owned());\n+        assert_eq!(encode(\"http://example.com\"), \"http://example.com\".to_owned());\n+        assert_eq!(encode(\"foo bar% baz\"), \"foo%20bar%25%20baz\".to_owned());\n+        assert_eq!(encode(\" \"), \"%20\".to_owned());\n+        assert_eq!(encode(\"!\"), \"!\".to_owned());\n+        assert_eq!(encode(\"\\\"\"), \"\\\"\".to_owned());\n+        assert_eq!(encode(\"#\"), \"#\".to_owned());\n+        assert_eq!(encode(\"$\"), \"$\".to_owned());\n+        assert_eq!(encode(\"%\"), \"%25\".to_owned());\n+        assert_eq!(encode(\"&\"), \"&\".to_owned());\n+        assert_eq!(encode(\"'\"), \"%27\".to_owned());\n+        assert_eq!(encode(\"(\"), \"(\".to_owned());\n+        assert_eq!(encode(\")\"), \")\".to_owned());\n+        assert_eq!(encode(\"*\"), \"*\".to_owned());\n+        assert_eq!(encode(\"+\"), \"+\".to_owned());\n+        assert_eq!(encode(\",\"), \",\".to_owned());\n+        assert_eq!(encode(\"/\"), \"/\".to_owned());\n+        assert_eq!(encode(\":\"), \":\".to_owned());\n+        assert_eq!(encode(\";\"), \";\".to_owned());\n+        assert_eq!(encode(\"=\"), \"=\".to_owned());\n+        assert_eq!(encode(\"?\"), \"?\".to_owned());\n+        assert_eq!(encode(\"@\"), \"@\".to_owned());\n+        assert_eq!(encode(\"[\"), \"[\".to_owned());\n+        assert_eq!(encode(\"]\"), \"]\".to_owned());\n     }\n \n     #[test]\n     fn test_encode_component() {\n-        assert_eq!(encode_component(\"\"), ~\"\");\n+        assert_eq!(encode_component(\"\"), \"\".to_owned());\n         assert!(encode_component(\"http://example.com\") ==\n-            ~\"http%3A%2F%2Fexample.com\");\n+            \"http%3A%2F%2Fexample.com\".to_owned());\n         assert!(encode_component(\"foo bar% baz\") ==\n-            ~\"foo%20bar%25%20baz\");\n-        assert_eq!(encode_component(\" \"), ~\"%20\");\n-        assert_eq!(encode_component(\"!\"), ~\"%21\");\n-        assert_eq!(encode_component(\"#\"), ~\"%23\");\n-        assert_eq!(encode_component(\"$\"), ~\"%24\");\n-        assert_eq!(encode_component(\"%\"), ~\"%25\");\n-        assert_eq!(encode_component(\"&\"), ~\"%26\");\n-        assert_eq!(encode_component(\"'\"), ~\"%27\");\n-        assert_eq!(encode_component(\"(\"), ~\"%28\");\n-        assert_eq!(encode_component(\")\"), ~\"%29\");\n-        assert_eq!(encode_component(\"*\"), ~\"%2A\");\n-        assert_eq!(encode_component(\"+\"), ~\"%2B\");\n-        assert_eq!(encode_component(\",\"), ~\"%2C\");\n-        assert_eq!(encode_component(\"/\"), ~\"%2F\");\n-        assert_eq!(encode_component(\":\"), ~\"%3A\");\n-        assert_eq!(encode_component(\";\"), ~\"%3B\");\n-        assert_eq!(encode_component(\"=\"), ~\"%3D\");\n-        assert_eq!(encode_component(\"?\"), ~\"%3F\");\n-        assert_eq!(encode_component(\"@\"), ~\"%40\");\n-        assert_eq!(encode_component(\"[\"), ~\"%5B\");\n-        assert_eq!(encode_component(\"]\"), ~\"%5D\");\n+            \"foo%20bar%25%20baz\".to_owned());\n+        assert_eq!(encode_component(\" \"), \"%20\".to_owned());\n+        assert_eq!(encode_component(\"!\"), \"%21\".to_owned());\n+        assert_eq!(encode_component(\"#\"), \"%23\".to_owned());\n+        assert_eq!(encode_component(\"$\"), \"%24\".to_owned());\n+        assert_eq!(encode_component(\"%\"), \"%25\".to_owned());\n+        assert_eq!(encode_component(\"&\"), \"%26\".to_owned());\n+        assert_eq!(encode_component(\"'\"), \"%27\".to_owned());\n+        assert_eq!(encode_component(\"(\"), \"%28\".to_owned());\n+        assert_eq!(encode_component(\")\"), \"%29\".to_owned());\n+        assert_eq!(encode_component(\"*\"), \"%2A\".to_owned());\n+        assert_eq!(encode_component(\"+\"), \"%2B\".to_owned());\n+        assert_eq!(encode_component(\",\"), \"%2C\".to_owned());\n+        assert_eq!(encode_component(\"/\"), \"%2F\".to_owned());\n+        assert_eq!(encode_component(\":\"), \"%3A\".to_owned());\n+        assert_eq!(encode_component(\";\"), \"%3B\".to_owned());\n+        assert_eq!(encode_component(\"=\"), \"%3D\".to_owned());\n+        assert_eq!(encode_component(\"?\"), \"%3F\".to_owned());\n+        assert_eq!(encode_component(\"@\"), \"%40\".to_owned());\n+        assert_eq!(encode_component(\"[\"), \"%5B\".to_owned());\n+        assert_eq!(encode_component(\"]\"), \"%5D\".to_owned());\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert_eq!(decode(\"\"), ~\"\");\n-        assert_eq!(decode(\"abc/def 123\"), ~\"abc/def 123\");\n-        assert_eq!(decode(\"abc%2Fdef%20123\"), ~\"abc%2Fdef 123\");\n-        assert_eq!(decode(\"%20\"), ~\" \");\n-        assert_eq!(decode(\"%21\"), ~\"%21\");\n-        assert_eq!(decode(\"%22\"), ~\"%22\");\n-        assert_eq!(decode(\"%23\"), ~\"%23\");\n-        assert_eq!(decode(\"%24\"), ~\"%24\");\n-        assert_eq!(decode(\"%25\"), ~\"%\");\n-        assert_eq!(decode(\"%26\"), ~\"%26\");\n-        assert_eq!(decode(\"%27\"), ~\"'\");\n-        assert_eq!(decode(\"%28\"), ~\"%28\");\n-        assert_eq!(decode(\"%29\"), ~\"%29\");\n-        assert_eq!(decode(\"%2A\"), ~\"%2A\");\n-        assert_eq!(decode(\"%2B\"), ~\"%2B\");\n-        assert_eq!(decode(\"%2C\"), ~\"%2C\");\n-        assert_eq!(decode(\"%2F\"), ~\"%2F\");\n-        assert_eq!(decode(\"%3A\"), ~\"%3A\");\n-        assert_eq!(decode(\"%3B\"), ~\"%3B\");\n-        assert_eq!(decode(\"%3D\"), ~\"%3D\");\n-        assert_eq!(decode(\"%3F\"), ~\"%3F\");\n-        assert_eq!(decode(\"%40\"), ~\"%40\");\n-        assert_eq!(decode(\"%5B\"), ~\"%5B\");\n-        assert_eq!(decode(\"%5D\"), ~\"%5D\");\n+        assert_eq!(decode(\"\"), \"\".to_owned());\n+        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_owned());\n+        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_owned());\n+        assert_eq!(decode(\"%20\"), \" \".to_owned());\n+        assert_eq!(decode(\"%21\"), \"%21\".to_owned());\n+        assert_eq!(decode(\"%22\"), \"%22\".to_owned());\n+        assert_eq!(decode(\"%23\"), \"%23\".to_owned());\n+        assert_eq!(decode(\"%24\"), \"%24\".to_owned());\n+        assert_eq!(decode(\"%25\"), \"%\".to_owned());\n+        assert_eq!(decode(\"%26\"), \"%26\".to_owned());\n+        assert_eq!(decode(\"%27\"), \"'\".to_owned());\n+        assert_eq!(decode(\"%28\"), \"%28\".to_owned());\n+        assert_eq!(decode(\"%29\"), \"%29\".to_owned());\n+        assert_eq!(decode(\"%2A\"), \"%2A\".to_owned());\n+        assert_eq!(decode(\"%2B\"), \"%2B\".to_owned());\n+        assert_eq!(decode(\"%2C\"), \"%2C\".to_owned());\n+        assert_eq!(decode(\"%2F\"), \"%2F\".to_owned());\n+        assert_eq!(decode(\"%3A\"), \"%3A\".to_owned());\n+        assert_eq!(decode(\"%3B\"), \"%3B\".to_owned());\n+        assert_eq!(decode(\"%3D\"), \"%3D\".to_owned());\n+        assert_eq!(decode(\"%3F\"), \"%3F\".to_owned());\n+        assert_eq!(decode(\"%40\"), \"%40\".to_owned());\n+        assert_eq!(decode(\"%5B\"), \"%5B\".to_owned());\n+        assert_eq!(decode(\"%5D\"), \"%5D\".to_owned());\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert_eq!(decode_component(\"\"), ~\"\");\n-        assert_eq!(decode_component(\"abc/def 123\"), ~\"abc/def 123\");\n-        assert_eq!(decode_component(\"abc%2Fdef%20123\"), ~\"abc/def 123\");\n-        assert_eq!(decode_component(\"%20\"), ~\" \");\n-        assert_eq!(decode_component(\"%21\"), ~\"!\");\n-        assert_eq!(decode_component(\"%22\"), ~\"\\\"\");\n-        assert_eq!(decode_component(\"%23\"), ~\"#\");\n-        assert_eq!(decode_component(\"%24\"), ~\"$\");\n-        assert_eq!(decode_component(\"%25\"), ~\"%\");\n-        assert_eq!(decode_component(\"%26\"), ~\"&\");\n-        assert_eq!(decode_component(\"%27\"), ~\"'\");\n-        assert_eq!(decode_component(\"%28\"), ~\"(\");\n-        assert_eq!(decode_component(\"%29\"), ~\")\");\n-        assert_eq!(decode_component(\"%2A\"), ~\"*\");\n-        assert_eq!(decode_component(\"%2B\"), ~\"+\");\n-        assert_eq!(decode_component(\"%2C\"), ~\",\");\n-        assert_eq!(decode_component(\"%2F\"), ~\"/\");\n-        assert_eq!(decode_component(\"%3A\"), ~\":\");\n-        assert_eq!(decode_component(\"%3B\"), ~\";\");\n-        assert_eq!(decode_component(\"%3D\"), ~\"=\");\n-        assert_eq!(decode_component(\"%3F\"), ~\"?\");\n-        assert_eq!(decode_component(\"%40\"), ~\"@\");\n-        assert_eq!(decode_component(\"%5B\"), ~\"[\");\n-        assert_eq!(decode_component(\"%5D\"), ~\"]\");\n+        assert_eq!(decode_component(\"\"), \"\".to_owned());\n+        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_owned());\n+        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_owned());\n+        assert_eq!(decode_component(\"%20\"), \" \".to_owned());\n+        assert_eq!(decode_component(\"%21\"), \"!\".to_owned());\n+        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_owned());\n+        assert_eq!(decode_component(\"%23\"), \"#\".to_owned());\n+        assert_eq!(decode_component(\"%24\"), \"$\".to_owned());\n+        assert_eq!(decode_component(\"%25\"), \"%\".to_owned());\n+        assert_eq!(decode_component(\"%26\"), \"&\".to_owned());\n+        assert_eq!(decode_component(\"%27\"), \"'\".to_owned());\n+        assert_eq!(decode_component(\"%28\"), \"(\".to_owned());\n+        assert_eq!(decode_component(\"%29\"), \")\".to_owned());\n+        assert_eq!(decode_component(\"%2A\"), \"*\".to_owned());\n+        assert_eq!(decode_component(\"%2B\"), \"+\".to_owned());\n+        assert_eq!(decode_component(\"%2C\"), \",\".to_owned());\n+        assert_eq!(decode_component(\"%2F\"), \"/\".to_owned());\n+        assert_eq!(decode_component(\"%3A\"), \":\".to_owned());\n+        assert_eq!(decode_component(\"%3B\"), \";\".to_owned());\n+        assert_eq!(decode_component(\"%3D\"), \"=\".to_owned());\n+        assert_eq!(decode_component(\"%3F\"), \"?\".to_owned());\n+        assert_eq!(decode_component(\"%40\"), \"@\".to_owned());\n+        assert_eq!(decode_component(\"%5B\"), \"[\".to_owned());\n+        assert_eq!(decode_component(\"%5D\"), \"]\".to_owned());\n     }\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n-        assert_eq!(encode_form_urlencoded(&m), ~\"\");\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_owned());\n \n-        m.insert(~\"\", vec!());\n-        m.insert(~\"foo\", vec!());\n-        assert_eq!(encode_form_urlencoded(&m), ~\"\");\n+        m.insert(\"\".to_owned(), vec!());\n+        m.insert(\"foo\".to_owned(), vec!());\n+        assert_eq!(encode_form_urlencoded(&m), \"\".to_owned());\n \n         let mut m = HashMap::new();\n-        m.insert(~\"foo\", vec!(~\"bar\", ~\"123\"));\n-        assert_eq!(encode_form_urlencoded(&m), ~\"foo=bar&foo=123\");\n+        m.insert(\"foo\".to_owned(), vec!(\"bar\".to_owned(), \"123\".to_owned()));\n+        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_owned());\n \n         let mut m = HashMap::new();\n-        m.insert(~\"foo bar\", vec!(~\"abc\", ~\"12 = 34\"));\n+        m.insert(\"foo bar\".to_owned(), vec!(\"abc\".to_owned(), \"12 = 34\".to_owned()));\n         assert!(encode_form_urlencoded(&m) ==\n-            ~\"foo+bar=abc&foo+bar=12+%3D+34\");\n+            \"foo+bar=abc&foo+bar=12+%3D+34\".to_owned());\n     }\n \n     #[test]\n@@ -1280,7 +1282,7 @@ mod tests {\n         let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n         let form = decode_form_urlencoded(s);\n         assert_eq!(form.len(), 2);\n-        assert_eq!(form.get(&~\"a\"), &vec!(~\"1\"));\n-        assert_eq!(form.get(&~\"foo bar\"), &vec!(~\"abc\", ~\"12 = 34\"));\n+        assert_eq!(form.get(&\"a\".to_owned()), &vec!(\"1\".to_owned()));\n+        assert_eq!(form.get(&\"foo bar\".to_owned()), &vec!(\"abc\".to_owned(), \"12 = 34\".to_owned()));\n     }\n }"}, {"sha": "2ee096dad4256cf9337a69cc51a3ba965003a0b6", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -727,7 +727,7 @@ mod test {\n \n         let u = Uuid::from_fields(d1, d2, d3, d4.as_slice());\n \n-        let expected = ~\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\";\n+        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_owned();\n         let result = u.to_simple_str();\n         assert!(result == expected);\n     }\n@@ -738,7 +738,7 @@ mod test {\n                    0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 );\n \n         let u = Uuid::from_bytes(b.as_slice()).unwrap();\n-        let expected = ~\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\";\n+        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_owned();\n \n         assert!(u.to_simple_str() == expected);\n     }"}, {"sha": "f662977ae0f9c2a0d51a1ec770eb2fe568e37f90", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -492,10 +492,10 @@ fn test() {\n         return pth;\n     }\n \n-    let pth = make_path(~\"foo.c\");\n+    let pth = make_path(\"foo.c\".to_owned());\n     File::create(&pth).write(bytes!(\"int main() { return 0; }\")).unwrap();\n \n-    let db_path = make_path(~\"db.json\");\n+    let db_path = make_path(\"db.json\".to_owned());\n \n     let cx = Context::new(Arc::new(RWLock::new(Database::new(db_path))),\n                           Arc::new(TreeMap::new()));\n@@ -511,11 +511,11 @@ fn test() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n         prep.exec(proc(_exe) {\n-            let out = make_path(~\"foo.o\");\n+            let out = make_path(\"foo.o\".to_owned());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             Process::status(compiler, [pth.as_str().unwrap().to_owned(),\n-                                    ~\"-o\",\n+                                    \"-o\".to_owned(),\n                                     out.as_str().unwrap().to_owned()]).unwrap();\n \n             let _proof_of_concept = subcx.prep(\"subfn\");"}, {"sha": "bf1ac1e585ab0f28bda07344db4271d14a1f4838", "filename": "src/rt/sundown/CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Frt%2Fsundown%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Frt%2Fsundown%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FCONTRIBUTING.md?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -7,4 +7,4 @@ Unfortunately, Sundown is currently frozen as we're working with the Reddit, Sta\n \n The new parser will be smaller, faster, safer and most importantly, more consistent.\n \n-Please stay tuned.\n\\ No newline at end of file\n+Please stay tuned."}, {"sha": "8c9ce5dda66f221e6298c3218b9af01f29c7e4b8", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,7 +15,7 @@\n pub struct NameVal { pub name: ~str, pub val: int }\n \n pub fn struct_nameval() -> NameVal {\n-    NameVal { name: ~\"crateresolve5\", val: 10 }\n+    NameVal { name: \"crateresolve5\".to_owned(), val: 10 }\n }\n \n pub enum e {"}, {"sha": "52296e2c054a4550e39ec8ef0d642c6a02a9364c", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,7 +14,7 @@\n \n pub struct NameVal { pub name: ~str, pub val: int }\n pub fn struct_nameval() -> NameVal {\n-    NameVal { name: ~\"crateresolve5\", val: 10 }\n+    NameVal { name: \"crateresolve5\".to_owned(), val: 10 }\n }\n \n pub enum e {"}, {"sha": "5da5653f26e644ad19a2979d9b34043460feab3c", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -21,5 +21,5 @@ pub type header_map = HashMap<~str, @RefCell<Vec<@~str>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&~\"METHOD\")).clone()).borrow().clone().get(0)).clone();\n+  let _x = (**((**req.get(&\"METHOD\".to_owned())).clone()).borrow().clone().get(0)).clone();\n }"}, {"sha": "ad8c823b99179e609ff07296b1222abcd19b998a", "filename": "src/test/auxiliary/issue13213aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -24,4 +24,4 @@ mod private {\n     pub static THREE: P = P { p: 3 };\n }\n \n-pub static A: S = S { p: private::THREE };\n\\ No newline at end of file\n+pub static A: S = S { p: private::THREE };"}, {"sha": "6d94bfcf613b9fa5d6729f8935c3995a4fb90a68", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -47,7 +47,7 @@ pub mod sub_foo {\n \n     impl Bort {\n         pub fn bort() -> ~str {\n-            ~\"bort()\"\n+            \"bort()\".to_owned()\n         }\n     }\n }"}, {"sha": "902f2c72409ef8b8ceda31ecb8d6eb764ef491ae", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -46,7 +46,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: ||) {\n     if os::getenv(\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n-        run_test = argv.iter().any(|x| x == &~\"all\") || argv.iter().any(|x| x == &name)\n+        run_test = argv.iter().any(|x| x == &\"all\".to_owned()) || argv.iter().any(|x| x == &name)\n     }\n \n     if !run_test {"}, {"sha": "d954b0c12e3c8513dfe89786de8259a7836856cb", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,9 +14,9 @@ use std::uint;\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"10000000\")\n+        vec!(\"\".to_owned(), \"10000000\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"100000\")\n+        vec!(\"\".to_owned(), \"100000\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "b99d778c39925500d5017eb585caab3e16de5c91", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -96,9 +96,9 @@ fn run(args: &[~str]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"1000000\", ~\"10000\")\n+        vec!(\"\".to_owned(), \"1000000\".to_owned(), \"10000\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10000\", ~\"4\")\n+        vec!(\"\".to_owned(), \"10000\".to_owned(), \"4\".to_owned())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "af8a89cc5978ed367608d30645f2b9033380e38f", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -106,9 +106,9 @@ fn run(args: &[~str]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"1000000\", ~\"8\")\n+        vec!(\"\".to_owned(), \"1000000\".to_owned(), \"8\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10000\", ~\"4\")\n+        vec!(\"\".to_owned(), \"10000\".to_owned(), \"4\".to_owned())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "2779ec06e9ff0bc5a7ab3fb0cb88cc7bf15e0721", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -63,9 +63,9 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"100\", ~\"10000\")\n+        vec!(\"\".to_owned(), \"100\".to_owned(), \"10000\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10\", ~\"100\")\n+        vec!(\"\".to_owned(), \"10\".to_owned(), \"100\".to_owned())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "70b31017223e68f13461eda8de593f9e49220408", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -64,9 +64,9 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"100\", ~\"10000\")\n+        vec!(\"\".to_owned(), \"100\".to_owned(), \"10000\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10\", ~\"100\")\n+        vec!(\"\".to_owned(), \"10\".to_owned(), \"100\".to_owned())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "46ea188a271a46798e06cd4d30d3c57c2afb7da8", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -25,9 +25,9 @@ fn ack(m: int, n: int) -> int {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"12\")\n+        vec!(\"\".to_owned(), \"12\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"8\")\n+        vec!(\"\".to_owned(), \"8\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "096279316d89705bb4eb578643c08af1e15c427d", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -209,9 +209,9 @@ fn rendezvous(nn: uint, set: Vec<color>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"200000\")\n+        vec!(\"\".to_owned(), \"200000\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"600\")\n+        vec!(\"\".to_owned(), \"600\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "a453ddccde51057a6b03444145199aff75782c38", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -21,9 +21,9 @@ fn fib(n: int) -> int {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"40\")\n+        vec!(\"\".to_owned(), \"40\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"30\")\n+        vec!(\"\".to_owned(), \"30\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "dd6e504f1dec978e564a3dbc2efc8250bb944101", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -129,12 +129,13 @@ fn make_sequence_processor(sz: uint,\n    let buffer = match sz {\n        1u => { sort_and_fmt(&freqs, total) }\n        2u => { sort_and_fmt(&freqs, total) }\n-       3u => { format!(\"{}\\t{}\", find(&freqs, ~\"GGT\"), \"GGT\") }\n-       4u => { format!(\"{}\\t{}\", find(&freqs, ~\"GGTA\"), \"GGTA\") }\n-       6u => { format!(\"{}\\t{}\", find(&freqs, ~\"GGTATT\"), \"GGTATT\") }\n-      12u => { format!(\"{}\\t{}\", find(&freqs, ~\"GGTATTTTAATT\"), \"GGTATTTTAATT\") }\n-      18u => { format!(\"{}\\t{}\", find(&freqs, ~\"GGTATTTTAATTTATAGT\"), \"GGTATTTTAATTTATAGT\") }\n-        _ => { ~\"\" }\n+       3u => { format!(\"{}\\t{}\", find(&freqs, \"GGT\".to_owned()), \"GGT\") }\n+       4u => { format!(\"{}\\t{}\", find(&freqs, \"GGTA\".to_owned()), \"GGTA\") }\n+       6u => { format!(\"{}\\t{}\", find(&freqs, \"GGTATT\".to_owned()), \"GGTATT\") }\n+      12u => { format!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATT\".to_owned()), \"GGTATTTTAATT\") }\n+      18u => { format!(\"{}\\t{}\", find(&freqs, \"GGTATTTTAATTTATAGT\".to_owned()),\n+                       \"GGTATTTTAATTTATAGT\") }\n+        _ => { \"\".to_owned() }\n    };\n \n     to_parent.send(buffer);"}, {"sha": "6e86f5205f017a84ad06d44b0609032763214737", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -277,7 +277,7 @@ fn main () {\n     };\n     let masks = make_masks();\n     let masks = filter_masks(masks.as_slice());\n-    let mut data = Data {stop_after: stop_after, nb: 0, min: ~\"\", max: ~\"\"};\n+    let mut data = Data {stop_after: stop_after, nb: 0, min: \"\".to_owned(), max: \"\".to_owned()};\n     search(masks.as_slice(), 0, 0, Nil, &mut data);\n     println!(\"{} solutions found\", data.nb);\n     print_sol(data.min);"}, {"sha": "d96019f3673aaf7d663ed900f2b636c4ded29b1f", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -148,9 +148,9 @@ fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"1000\")\n+        vec!(\"\".to_owned(), \"1000\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"1000\")\n+        vec!(\"\".to_owned(), \"1000\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "39384ce275a5f6ef91ed8412305eff2a5deadc13", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -91,9 +91,9 @@ fn stress(num_tasks: int) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"20\")\n+        vec!(\"\".to_owned(), \"20\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"8\")\n+        vec!(\"\".to_owned(), \"8\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "54881a63694ee2b62a5e95bd096ef85754a57492", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -55,7 +55,7 @@ fn main() {\n     use std::from_str::FromStr;\n \n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"2000000\", ~\"503\")\n+        vec!(\"\".to_owned(), \"2000000\".to_owned(), \"503\".to_owned())\n     } else {\n         os::args().move_iter().collect()\n     };"}, {"sha": "ae1d9db8982bb29ad9908a7707d8018b39a07d81", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -32,9 +32,9 @@ fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"100000\", ~\"100\")\n+        vec!(\"\".to_owned(), \"100000\".to_owned(), \"100\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10000\", ~\"50\")\n+        vec!(\"\".to_owned(), \"10000\".to_owned(), \"50\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "3398cd84acdc8708d100e0ce36f1b20bf8bcc588", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -66,7 +66,8 @@ impl Sudoku {\n     }\n \n     pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n-        assert!(reader.read_line().unwrap() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n+        /* assert first line is exactly \"9,9\" */\n+        assert!(reader.read_line().unwrap() == \"9,9\".to_owned());\n \n         let mut g = Vec::from_fn(10u, { |_i| vec!(0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8) });\n         for line in reader.lines() {"}, {"sha": "35c314dac93cc007af49989e89790132fa778845", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -41,9 +41,9 @@ fn child_generation(gens_left: uint, tx: comm::Sender<()>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"100000\")\n+        vec!(\"\".to_owned(), \"100000\".to_owned())\n     } else if args.len() <= 1 {\n-        vec!(~\"\", ~\"100\")\n+        vec!(\"\".to_owned(), \"100\".to_owned())\n     } else {\n         args.clone().move_iter().collect()\n     };"}, {"sha": "0b712923d881b5a6e057ff568fea0f39a003cc82", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -49,9 +49,9 @@ fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"30\")\n+        vec!(\"\".to_owned(), \"30\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10\")\n+        vec!(\"\".to_owned(), \"10\".to_owned())\n     } else {\n         args\n     };"}, {"sha": "e64b807ca3acc436696c8e38ab8b6b812a26760f", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -25,9 +25,9 @@ fn g() { }\n fn main() {\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(~\"\", ~\"400\")\n+        vec!(\"\".to_owned(), \"400\".to_owned())\n     } else if args.len() <= 1u {\n-        vec!(~\"\", ~\"10\")\n+        vec!(\"\".to_owned(), \"10\".to_owned())\n     } else {\n         args.move_iter().collect()\n     };"}, {"sha": "d97628bad7a797168696fe2ea40f00265229b10b", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:`^` cannot be applied to type `~str`\n \n-fn main() { let x = ~\"a\" ^ ~\"b\"; }\n+fn main() { let x = \"a\".to_owned() ^ \"b\".to_owned(); }"}, {"sha": "2be5d5701352ab98e376cf62e75b90afcc8eabb7", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -19,7 +19,7 @@ fn arg_closure() {\n }\n \n fn let_pat() {\n-    let &_x = &~\"hi\";\n+    let &_x = &\"hi\".to_owned();\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n }\n "}, {"sha": "cb1ac467c766849c14e50df123e3ca09b3c1ad23", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,6 +11,6 @@\n use std::rc::Rc;\n \n pub fn main() {\n-    let _x = *Rc::new(~\"hi\");\n+    let _x = *Rc::new(\"hi\".to_owned());\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n }"}, {"sha": "e40fc4e4b236f33c5c997c9fa0829b7151540ba6", "filename": "src/test/compile-fail/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,14 +14,14 @@ impl Drop for S {\n }\n \n fn move_in_match() {\n-    match S {f:~\"foo\"} {\n+    match S {f:\"foo\".to_owned()} {\n         S {f:_s} => {}\n         //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n     }\n }\n \n fn move_in_let() {\n-    let S {f:_s} = S {f:~\"foo\"};\n+    let S {f:_s} = S {f:\"foo\".to_owned()};\n     //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n }\n "}, {"sha": "9701283469b1fe9cfbb8ea66b629aade6ab4e27b", "filename": "src/test/compile-fail/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,14 +14,14 @@ impl Drop for S {\n }\n \n fn move_in_match() {\n-    match S(~\"foo\") {\n+    match S(\"foo\".to_owned()) {\n         S(_s) => {}\n         //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n     }\n }\n \n fn move_in_let() {\n-    let S(_s) = S(~\"foo\");\n+    let S(_s) = S(\"foo\".to_owned());\n     //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n }\n "}, {"sha": "317c30c6e19b4459f0a463fb0b5127e62ae72ebb", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,9 +17,9 @@ struct Foo {\n \n pub fn main() {\n     let x = vec!(\n-        Foo { string: ~\"foo\" },\n-        Foo { string: ~\"bar\" },\n-        Foo { string: ~\"baz\" }\n+        Foo { string: \"foo\".to_owned() },\n+        Foo { string: \"bar\".to_owned() },\n+        Foo { string: \"baz\".to_owned() }\n     );\n     let x: &[Foo] = x.as_slice();\n     match x {"}, {"sha": "1b83e61cc35dd45c6ad95612ac321319881377e0", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let msg;\n-    match Some(~\"Hello\") {\n+    match Some(\"Hello\".to_owned()) {\n         Some(ref m) => { //~ ERROR borrowed value does not live long enough\n             msg = m;\n         },"}, {"sha": "986db86a6c1e14e6a6cfcee2a40d2bb958ba15f3", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -20,7 +20,7 @@ struct S {\n fn f(x: ~str) {}\n \n fn main() {\n-    let s = S { x: Bar(~\"hello\") };\n+    let s = S { x: Bar(\"hello\".to_owned()) };\n     match &s.x {\n         &Foo => {}\n         &Bar(identifier) => f(identifier.clone())  //~ ERROR cannot move"}, {"sha": "a8581534848a83fa8d4288881e0e66c5335382b6", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -92,7 +92,9 @@ impl Drop for UnsafeStruct {\n static STATIC10: UnsafeStruct = UnsafeStruct;\n //~^ ERROR static items are not allowed to have destructor\n \n-static STATIC11: ~str = ~\"Owned pointers are not allowed either\";\n+struct MyOwned;\n+\n+static STATIC11: ~MyOwned = ~MyOwned;\n //~^ ERROR static items are not allowed to have owned pointers\n \n // The following examples test that mutable structs are just forbidden\n@@ -104,14 +106,14 @@ static mut STATIC12: UnsafeStruct = UnsafeStruct;\n static mut STATIC13: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(WithDtor)};\n //~^ ERROR mutable static items are not allowed to have destructors\n \n-static mut STATIC14: SafeStruct = SafeStruct{field1: Variant1, field2: Variant4(~\"str\")};\n+static mut STATIC14: SafeStruct = SafeStruct{field1: Variant1, field2: Variant4(\"str\".to_owned())};\n //~^ ERROR mutable static items are not allowed to have destructors\n \n-static STATIC15: &'static [~str] = &'static [~\"str\", ~\"str\"];\n+static STATIC15: &'static [~MyOwned] = &'static [~MyOwned, ~MyOwned];\n //~^ ERROR static items are not allowed to have owned pointers\n //~^^ ERROR static items are not allowed to have owned pointers\n \n-static STATIC16: (~str, ~str) = (~\"str\", ~\"str\");\n+static STATIC16: (&'static ~MyOwned, &'static ~MyOwned) = (&'static ~MyOwned, &'static ~MyOwned);\n //~^ ERROR static items are not allowed to have owned pointers\n //~^^ ERROR static items are not allowed to have owned pointers\n "}, {"sha": "a1739849807ccad5eb44c0639d1c6c3af8af6dfd", "filename": "src/test/compile-fail/circular_modules_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -12,7 +12,7 @@\n mod circular_modules_hello; //~ERROR: circular modules\n \n pub fn hi_str() -> ~str {\n-  ~\"Hi!\"\n+  \"Hi!\".to_owned()\n }\n \n fn main() {"}, {"sha": "506e1cba9fded5aabc0015542a1fd69ad97e0b7f", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -57,6 +57,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n fn main() {\n-  let nyan: ~noisy = ~cat(0, 2, ~\"nyan\") as ~noisy;\n+  let nyan: ~noisy = ~cat(0, 2, \"nyan\".to_owned()) as ~noisy;\n   nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n }"}, {"sha": "40bb63907c9f16f20a1acbe7bce5a069e45a9389", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -24,7 +24,7 @@ fn unwrap(x: X) -> ~str {\n }\n \n fn main() {\n-    let x = X { x: ~\"hello\" };\n+    let x = X { x: \"hello\".to_owned() };\n     let y = unwrap(x);\n     println!(\"contents: {}\", y);\n }"}, {"sha": "eec665b62f9d1f245242cb894504846b2dadaca7", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -19,7 +19,7 @@ impl Drop for X {\n }\n \n fn main() {\n-    let x = X { x: ~\"hello\" };\n+    let x = X { x: \"hello\".to_owned() };\n \n     match x {\n         X { x: y } => println!(\"contents: {}\", y)"}, {"sha": "ee839893e8ebe585e01d4b75b023b262b677acbe", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n-    let s: ~str = ~\"abcdef\";\n+    let s: ~str = \"abcdef\".to_owned();\n     assert_eq!(v.as_slice()[3u], 3);\n     assert_eq!(v.as_slice()[3u8], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3i8], 3); //~ ERROR: mismatched types"}, {"sha": "9f16ba53d827b3d6a76b6a4acf5b93773eb7e1a8", "filename": "src/test/compile-fail/issue-10412.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -25,7 +25,7 @@ impl<'self> Serializable<str> for &'self str {\n \n fn main() {\n     println!(\"hello\");\n-    let x = ~\"foo\";\n+    let x = \"foo\".to_owned();\n     let y = x;\n     println!(\"{}\", y);\n }"}, {"sha": "b6425dac3c117f4c9f4e3d8f40c0d378b698d9f2", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -21,7 +21,7 @@ trait to_str_2 {\n // the compiler to attempt autoderef and then\n // try to resolve the method.\n impl to_str_2 for t {\n-    fn my_to_str() -> ~str { ~\"t\" }\n+    fn my_to_str() -> ~str { \"t\".to_owned() }\n }\n \n fn new_t(x: t) {"}, {"sha": "1d792dba0d87494f1dc391c27d053d74b829a347", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n fn foo(b: bool) -> Result<bool,~str> {\n-    Err(~\"bar\"); //~ ERROR: cannot determine a type for this expression: unconstrained type\n+    Err(\"bar\".to_owned());\n+    //~^ ERROR: cannot determine a type for this expression: unconstrained type\n }\n \n fn main() {"}, {"sha": "e39b2d9309bec9b16ef4e79b3cae00b12c248308", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,7 +18,7 @@ impl CrateId {\n     fn new(s: &str) -> CrateId {\n         CrateId {\n             local_path: s.to_owned(),\n-            junk: ~\"wutevs\"\n+            junk: \"wutevs\".to_owned()\n         }\n     }\n }"}, {"sha": "5f2987c6cfbd4e41489a2d5369edd2be2843ae0d", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -26,7 +26,6 @@ fn main() {\n \n     ~2; //~ ERROR type uses owned\n     fn g(_: ~Clone) {} //~ ERROR type uses owned\n-    ~\"\"; //~ ERROR type uses owned\n-    //~^ ERROR type uses owned\n+    \"\".to_owned(); //~ ERROR type uses owned\n     proc() {}; //~ ERROR type uses owned\n }"}, {"sha": "17c93f596e9c5cc8ac4cf77f8e0974ee07874cc6", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    match ~\"foo\" {\n+    match \"foo\".to_owned() {\n         ['f', 'o', ..] => { } //~ ERROR mismatched types: expected `~str` but found a vector pattern\n         _ => { }\n     }"}, {"sha": "2e3b5e399f195b72968e6d7f6adffd45a70ba1ad", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,7 +18,7 @@ fn main() {\n         _ => ()\n     }\n \n-    let x: Vec<~str> = vec!(~\"foo\", ~\"bar\", ~\"baz\");\n+    let x: Vec<~str> = vec!(\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned());\n     let x: &[~str] = x.as_slice();\n     match x {\n         [a, _, _, ..] => { println!(\"{}\", a); }"}, {"sha": "636debc77e01bcbd466f17d985a840dda84746e5", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:cannot apply unary operator `-` to type `~str`\n \n-fn main() { -~\"foo\"; }\n+fn main() { -\"foo\".to_owned(); }"}, {"sha": "dc2cd22e632e05c6a25b771527f56efb3e65e20c", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,13 +16,13 @@ fn consume(_s: ~str) {}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = Foo { f: ~\"hi\", y: 3 };\n+    let x = Foo { f: \"hi\".to_owned(), y: 3 };\n     consume(x.f);\n     touch(&x.y); //~ ERROR use of partially moved value: `x`\n }\n \n fn f20() {\n-    let x = vec!(~\"hi\");\n+    let x = vec!(\"hi\".to_owned());\n     consume(x.move_iter().next().unwrap());\n     touch(x.get(0)); //~ ERROR use of moved value: `x`\n }"}, {"sha": "b68d3f6d8e40d1c184c63e055cca84ec32bb13c4", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n fn main() {\n-    let x = ~\"Hello world!\";\n+    let x = \"Hello world!\".to_owned();\n     task::spawn(proc() {\n         println!(\"{}\", x);\n     });"}, {"sha": "07fa6b27cc4979f206e90004b2a93aa4c7b83f0a", "filename": "src/test/compile-fail/moves-based-on-type-distribute-copy-over-paren.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,37 +15,37 @@ struct Foo<A> { f: A }\n fn touch<A>(_a: &A) {}\n \n fn f00() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:x }; //~ NOTE `x` moved here\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f05() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:(((x))) }; //~ NOTE `x` moved here\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f10() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:x.clone() };\n     touch(&x);\n }\n \n fn f20() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:(x).clone() };\n     touch(&x);\n }\n \n fn f30() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:((x)).clone() };\n     touch(&x);\n }\n \n fn f40() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:(((((((x)).clone()))))) };\n     touch(&x);\n }"}, {"sha": "ea96d87855e7420e9defbc301f41fc0d01b4de51", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,13 +18,13 @@ fn guard(_s: ~str) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = Foo { f:x };\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f20() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = (x, 3);\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n@@ -36,8 +36,8 @@ fn f21() {\n }\n \n fn f30(cond: bool) {\n-    let x = ~\"hi\";\n-    let y = ~\"ho\";\n+    let x = \"hi\".to_owned();\n+    let y = \"ho\".to_owned();\n     let _y = if cond {\n         x\n     } else {\n@@ -48,8 +48,8 @@ fn f30(cond: bool) {\n }\n \n fn f40(cond: bool) {\n-    let x = ~\"hi\";\n-    let y = ~\"ho\";\n+    let x = \"hi\".to_owned();\n+    let y = \"ho\".to_owned();\n     let _y = match cond {\n         true => x,\n         false => y\n@@ -59,8 +59,8 @@ fn f40(cond: bool) {\n }\n \n fn f50(cond: bool) {\n-    let x = ~\"hi\";\n-    let y = ~\"ho\";\n+    let x = \"hi\".to_owned();\n+    let y = \"ho\".to_owned();\n     let _y = match cond {\n         _ if guard(x) => 10,\n         true => 10,\n@@ -71,31 +71,31 @@ fn f50(cond: bool) {\n }\n \n fn f70() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = [x];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f80() {\n-    let x = ~\"hi\";\n+    let x = \"hi\".to_owned();\n     let _y = vec!(x);\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f100() {\n-    let x = vec!(~\"hi\");\n+    let x = vec!(\"hi\".to_owned());\n     let _y = x.move_iter().next().unwrap();\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f110() {\n-    let x = vec!(~\"hi\");\n+    let x = vec!(\"hi\".to_owned());\n     let _y = [x.move_iter().next().unwrap(), ..1];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f120() {\n-    let mut x = vec!(~\"hi\", ~\"ho\");\n+    let mut x = vec!(\"hi\".to_owned(), \"ho\".to_owned());\n     x.as_mut_slice().swap(0, 1);\n     touch(x.get(0));\n     touch(x.get(1));"}, {"sha": "59918b51e4c9083a09f52e64d8a901b5604dcf4e", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,7 +17,7 @@ fn guard(_s: ~str) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {\n-    let x = Foo {f: ~\"hi\"};\n+    let x = Foo {f: \"hi\".to_owned()};\n \n     let y = match x {\n         Foo {f} => {} //~ NOTE moved here"}, {"sha": "e5fe1891cb87825279bdd34f79b7322891b4aad5", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -20,7 +20,7 @@ struct R<'a> {\n }\n \n fn innocent_looking_victim() {\n-    let mut x = Some(~\"hello\");\n+    let mut x = Some(\"hello\".to_owned());\n     conspirator(|f, writer| {\n         if writer {\n             x = None;"}, {"sha": "a57e7ebe6a04f3264f2889d7c97e61605eecfaa5", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,5 +14,5 @@ struct S {\n \n impl Cmp, ToStr for S { //~ ERROR: expected `{` but found `,`\n   fn eq(&&other: S) { false }\n-  fn to_str(&self) -> ~str { ~\"hi\" }\n+  fn to_str(&self) -> ~str { \"hi\".to_owned() }\n }"}, {"sha": "d8a6391826b48f6356e16fcc65ee3b689377e1eb", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -33,7 +33,7 @@ mod argparse {\n }\n \n fn main () {\n-    let f : argparse::Flag = argparse::flag(~\"flag\", ~\"My flag\");\n-    let updated_flag = f.set_desc(~\"My new flag\");\n+    let f : argparse::Flag = argparse::flag(\"flag\".to_owned(), \"My flag\".to_owned());\n+    let updated_flag = f.set_desc(\"My new flag\".to_owned());\n     assert_eq!(updated_flag.desc, \"My new flag\");\n }"}, {"sha": "38a09143e3cd0b5923f702c61a5a2ae595956412", "filename": "src/test/compile-fail/syntax-extension-minor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,8 +13,8 @@\n #![feature(concat_idents)]\n \n pub fn main() {\n-    let asdf_fdsa = ~\"<.<\";\n-    assert_eq!(concat_idents!(asd, f_f, dsa), ~\"<.<\");\n+    let asdf_fdsa = \"<.<\".to_owned();\n+    assert_eq!(concat_idents!(asd, f_f, dsa), \"<.<\".to_owned());\n     //~^ ERROR: unresolved name `asdf_fdsa`\n \n     assert!(stringify!(use_mention_distinction) =="}, {"sha": "6ffee2ef22b2105f7e691e23d17966072d4b8171", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -23,7 +23,7 @@ impl Trait<&'static str> for Struct {\n }\n \n fn main() {\n-    let person = ~\"Fred\";\n+    let person = \"Fred\".to_owned();\n     let person: &str = person;  //~ ERROR `person[..]` does not live long enough\n     let s: ~Trait<&'static str> = ~Struct { person: person };\n }"}, {"sha": "1adf88c80be90a131cc625d057616939efa85b02", "filename": "src/test/compile-fail/unsafe-modifying-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut s = ~\"test\";\n+    let mut s = \"test\".to_owned();\n     s[0] = 3; //~ ERROR: not allowed\n     s[0] += 3; //~ ERROR: not allowed\n     {"}, {"sha": "a30337aba68c3dd6132d74d1d6e2f668175ab981", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -26,7 +26,7 @@ fn foo(i:int, j: @~str) -> foo {\n }\n \n fn main() {\n-  let cat = ~\"kitty\";\n+  let cat = \"kitty\".to_owned();\n   let (tx, _) = channel(); //~ ERROR does not fulfill `Send`\n   tx.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "28eb4a12739fbaf45301152c01d434f59e27ec9f", "filename": "src/test/compile-fail/use-after-move-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-based-on-type.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = ~\"Hello!\";\n+    let x = \"Hello!\".to_owned();\n     let _y = x;\n     println!(\"{}\", x); //~ ERROR use of moved value\n }"}, {"sha": "a03b263a692b8389ecd8eed34220cc4cc2872f58", "filename": "src/test/debug-info/issue13213.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fdebug-info%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fdebug-info%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fissue13213.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -23,4 +23,4 @@ fn main() {\n     zzz();\n }\n \n-fn zzz() {()}\n\\ No newline at end of file\n+fn zzz() {()}"}, {"sha": "994a81dc4866203091a160c5b21fa923a06e2bef", "filename": "src/test/pretty/match-naked-expr-long.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fpretty%2Fmatch-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fpretty%2Fmatch-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-long.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,8 +18,8 @@ fn main() {\n     let _y =\n         match x {\n             Some(_) =>\n-            ~\"some\" + \"very\" + \"very\" + \"very\" + \"very\" + \"very\" + \"very\" +\n-                \"very\" + \"very\" + \"long\" + \"string\",\n-            None => ~\"none\"\n+            \"some\".to_owned() + \"very\" + \"very\" + \"very\" + \"very\" + \"very\" +\n+                \"very\" + \"very\" + \"very\" + \"long\" + \"string\",\n+            None => \"none\".to_owned()\n         };\n }"}, {"sha": "c05c3d7fe8fc9b6b44a6278db39afcc8a834dca8", "filename": "src/test/pretty/match-naked-expr-medium.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,7 +14,11 @@ fn main() {\n     let x = Some(3);\n     let _y =\n         match x {\n-            Some(_) => [~\"some(_)\", ~\"not\", ~\"SO\", ~\"long\", ~\"string\"],\n-            None => [~\"none\", ~\"a\", ~\"a\", ~\"a\", ~\"a\"]\n+            Some(_) =>\n+            [\"some(_)\".to_owned(), \"not\".to_owned(), \"SO\".to_owned(),\n+             \"long\".to_owned(), \"string\".to_owned()],\n+            None =>\n+            [\"none\".to_owned(), \"a\".to_owned(), \"a\".to_owned(),\n+             \"a\".to_owned(), \"a\".to_owned()]\n         };\n }"}, {"sha": "dd44f7de3539fecf8fda0b31fce37bc2009a9b32", "filename": "src/test/pretty/match-naked-expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -12,5 +12,9 @@\n \n fn main() {\n     let x = Some(3);\n-    let _y = match x { Some(_) => ~\"some(_)\", None => ~\"none\" };\n+    let _y =\n+        match x {\n+            Some(_) => \"some(_)\".to_owned(),\n+            None => \"none\".to_owned()\n+        };\n }"}, {"sha": "9dec60e488dbff93fbb9073968612a83fde8e151", "filename": "src/test/run-fail/assert-macro-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:failed at 'test-assert-owned'\n \n fn main() {\n-    assert!(false, ~\"test-assert-owned\");\n+    assert!(false, \"test-assert-owned\".to_owned());\n }"}, {"sha": "1186c5008f73e0b3809f0875c54ead866e235835", "filename": "src/test/run-fail/binop-fail-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:quux\n fn my_err(s: ~str) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { 3u == my_err(~\"bye\"); }\n+fn main() { 3u == my_err(\"bye\".to_owned()); }"}, {"sha": "1186c5008f73e0b3809f0875c54ead866e235835", "filename": "src/test/run-fail/binop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:quux\n fn my_err(s: ~str) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { 3u == my_err(~\"bye\"); }\n+fn main() { 3u == my_err(\"bye\".to_owned()); }"}, {"sha": "7b5d263071b76d3bebf8f60c4e0a5a7dc2536f70", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,5 +15,5 @@\n fn main() {\n     let mut a = 1;\n     if 1 == 1 { a = 2; }\n-    fail!(~\"woooo\" + \"o\");\n+    fail!(\"woooo\".to_owned() + \"o\");\n }"}, {"sha": "23ceead0cb01e2f7f3280cc60468bc3c1fb915fe", "filename": "src/test/run-fail/fail-task-name-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,7 +13,7 @@\n use std::task;\n \n fn main() {\n-    task::task().named(~\"owned name\").try(proc() {\n+    task::task().named(\"owned name\".to_owned()).try(proc() {\n         fail!(\"test\");\n         1\n     }).unwrap()"}, {"sha": "9c7979efb6c02293fb4066b4327d93669d0f31e5", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:meh\n \n-fn main() { let str_var: ~str = ~\"meh\"; fail!(\"{}\", str_var); }\n+fn main() { let str_var: ~str = \"meh\".to_owned(); fail!(\"{}\", str_var); }"}, {"sha": "f300a1fa7158e2d2266e2534109111bfff0056ef", "filename": "src/test/run-fail/if-cond-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:quux\n fn my_err(s: ~str) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n-fn main() { if my_err(~\"bye\") { } }\n+fn main() { if my_err(\"bye\".to_owned()) { } }"}, {"sha": "b3b1fd2082b8c7006bda013489f8f20d2ec8b551", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     let y = vec!(3);\n     fail!(\"so long\");\n     x.push_all_move(y);\n-    ~\"good\" + ~\"bye\";\n+    \"good\".to_owned() + \"bye\".to_owned();\n }"}, {"sha": "0a3746e44651e2319f4313a361f02be69c10bfa3", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,5 +13,5 @@\n use std::result;\n \n fn main() {\n-    println!(\"{:?}\", result::Err::<int,~str>(~\"kitty\").unwrap());\n+    println!(\"{:?}\", result::Err::<int,~str>(\"kitty\".to_owned()).unwrap());\n }"}, {"sha": "9f7b03ac2ea3dafc4887b909888592a255bf4643", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,7 +11,7 @@\n \n // error-pattern:index out of bounds: the len is 5 but the index is 5\n fn main() {\n-    let s: ~str = ~\"hello\";\n+    let s: ~str = \"hello\".to_owned();\n \n     // Bounds-check failure.\n     assert_eq!(s[5], 0x0 as u8);"}, {"sha": "2e76c8150d871b8abcc3007342e9a2f58b2c7126", "filename": "src/test/run-fail/unwind-box-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-box-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-box-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-str.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,7 +17,7 @@ fn failfn() {\n }\n \n fn main() {\n-    let x = @~\"hi\";\n+    let x = @\"hi\".to_owned();\n     failfn();\n     println!(\"{:?}\", x);\n }"}, {"sha": "ddaddcec390002d4eee608b20ed0f9c010458998", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,8 +13,8 @@\n // error-pattern:fail\n \n fn main() {\n-    let cheese = ~\"roquefort\";\n-    let carrots = @~\"crunchy\";\n+    let cheese = \"roquefort\".to_owned();\n+    let carrots = @\"crunchy\".to_owned();\n \n     let result: |@~str, |~str||: 'static = (|tasties, macerate| {\n         macerate((*tasties).clone());"}, {"sha": "be22b368c0c78da3b135c123629038aaaf7a5c05", "filename": "src/test/run-fail/unwind-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-match.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,9 +16,9 @@ fn test_box() {\n     @0;\n }\n fn test_str() {\n-  let res = match false { true => { ~\"happy\" },\n+  let res = match false { true => { \"happy\".to_owned() },\n      _ => fail!(\"non-exhaustive match failure\") };\n-  assert_eq!(res, ~\"happy\");\n+  assert_eq!(res, \"happy\".to_owned());\n }\n fn main() {\n     test_box();"}, {"sha": "fae1a8a17738cd169007f86e6ebd03ac9d302526", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -22,9 +22,9 @@ fn main() {\n     let mut map = collections::HashMap::new();\n     let mut arr = Vec::new();\n     for _i in range(0u, 10u) {\n-        arr.push(@~\"key stuff\");\n+        arr.push(@\"key stuff\".to_owned());\n         map.insert(arr.clone(),\n-                   arr.clone().append([@~\"value stuff\"]));\n+                   arr.clone().append([@\"value stuff\".to_owned()]));\n         if arr.len() == 5 {\n             fail!();\n         }"}, {"sha": "d54c04b77b0d8fbc9a5d1848de53ca6ac74998c0", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -57,7 +57,7 @@ fn main() {\n \n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n-        let result = Process::output(\"sh\", [~\"-c\", rustc + \" \" + main_file_str]).unwrap();\n+        let result = Process::output(\"sh\", [\"-c\".to_owned(), rustc + \" \" + main_file_str]).unwrap();\n         let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // positive test so that this test will be updated when the"}, {"sha": "5f4af50753ec7c04afc4251f7964bd8ec8191ddf", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -53,7 +53,7 @@ fn main() {\n \n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n-        let result = Process::output(\"sh\", [~\"-c\", rustc + \" \" + main_file_str]).unwrap();\n+        let result = Process::output(\"sh\", [\"-c\".to_owned(), rustc + \" \" + main_file_str]).unwrap();\n \n         let err = str::from_utf8_lossy(result.error.as_slice());\n "}, {"sha": "3b3e4066e0ccd48cda9565faec154d0a977b6a88", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -57,20 +57,20 @@ fn main() {\n     let cx = mk_ctxt();\n \n     let abc = quote_expr!(cx, 23);\n-    check_pp(ext_cx, abc,  pprust::print_expr, ~\"23\");\n+    check_pp(ext_cx, abc,  pprust::print_expr, \"23\".to_owned());\n \n \n     let ty = quote_ty!(cx, int);\n-    check_pp(ext_cx, ty, pprust::print_type, ~\"int\");\n+    check_pp(ext_cx, ty, pprust::print_type, \"int\".to_owned());\n \n     let item = quote_item!(cx, static x : int = 10;).get();\n-    check_pp(ext_cx, item, pprust::print_item, ~\"static x: int = 10;\");\n+    check_pp(ext_cx, item, pprust::print_item, \"static x: int = 10;\".to_owned());\n \n     let stmt = quote_stmt!(cx, let x = 20;);\n-    check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n+    check_pp(ext_cx, *stmt, pprust::print_stmt, \"let x = 20;\".to_owned());\n \n     let pat = quote_pat!(cx, Some(_));\n-    check_pp(ext_cx, pat, pprust::print_pat, ~\"Some(_)\");\n+    check_pp(ext_cx, pat, pprust::print_pat, \"Some(_)\".to_owned());\n \n }\n \n@@ -82,7 +82,7 @@ fn check_pp<T>(cx: fake_ext_ctxt,\n         pp::eof(pp.s);\n     });\n     stdout().write_line(s);\n-    if expect != ~\"\" {\n+    if expect != \"\".to_owned() {\n         println!(\"expect: '%s', got: '%s'\", expect, s);\n         assert_eq!(s, expect);\n     }"}, {"sha": "1e0418d880600aad6924fa88137b73f96c5067f3", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,7 +13,7 @@ struct Point { x : int }\n \n pub fn main() {\n     assert_eq!(14,14);\n-    assert_eq!(~\"abc\",~\"abc\");\n+    assert_eq!(\"abc\".to_owned(),\"abc\".to_owned());\n     assert_eq!(~Point{x:34},~Point{x:34});\n     assert_eq!(&Point{x:34},&Point{x:34});\n     assert_eq!(@Point{x:34},@Point{x:34});"}, {"sha": "8e0bdfdc74076620176e365d0f818a2553f7817c", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     (vec!(1)).as_slice().test_imm();\n     (&[1]).test_imm();\n     (\"test\").test_imm();\n-    (~\"test\").test_imm();\n+    (\"test\".to_owned()).test_imm();\n     (&\"test\").test_imm();\n \n     // FIXME: Other types of mutable vecs don't currently exist"}, {"sha": "5dad14c7d99bea3f14c1e6c036272795d381d3d3", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,5 +16,5 @@ fn g(act: |Vec<int> | -> int) -> int { return act(vec!(1, 2, 3)); }\n pub fn main() {\n     assert_eq!(g(f), 1);\n     let f1: |Vec<~str> | -> ~str = f;\n-    assert_eq!(f1(vec!(~\"x\", ~\"y\", ~\"z\")), ~\"x\");\n+    assert_eq!(f1(vec!(\"x\".to_owned(), \"y\".to_owned(), \"z\".to_owned())), \"x\".to_owned());\n }"}, {"sha": "ca11fb355c0007e7aefbb2639c934a58b9772c10", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -28,5 +28,5 @@ impl Foo for uint {\n \n pub fn main() {\n     let x = @3u;\n-    assert_eq!(x.foo(), ~\"@3\");\n+    assert_eq!(x.foo(), \"@3\".to_owned());\n }"}, {"sha": "0277cb35f528635b64f1ae0aa2c3c489c1339096", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -41,12 +41,12 @@ fn runtest(me: &str) {\n         Some(i) => { env.remove(i); }\n         None => {}\n     }\n-    env.push((~\"RUST_BACKTRACE\", ~\"1\"));\n+    env.push((\"RUST_BACKTRACE\".to_owned(), \"1\".to_owned()));\n \n     // Make sure that the stack trace is printed\n     let mut p = Process::configure(ProcessConfig {\n         program: me,\n-        args: [~\"fail\"],\n+        args: [\"fail\".to_owned()],\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     }).unwrap();\n@@ -59,7 +59,7 @@ fn runtest(me: &str) {\n     // Make sure the stack trace is *not* printed\n     let mut p = Process::configure(ProcessConfig {\n         program: me,\n-        args: [~\"fail\"],\n+        args: [\"fail\".to_owned()],\n         .. ProcessConfig::new()\n     }).unwrap();\n     let out = p.wait_with_output();\n@@ -71,7 +71,7 @@ fn runtest(me: &str) {\n     // Make sure a stack trace is printed\n     let mut p = Process::configure(ProcessConfig {\n         program: me,\n-        args: [~\"double-fail\"],\n+        args: [\"double-fail\".to_owned()],\n         .. ProcessConfig::new()\n     }).unwrap();\n     let out = p.wait_with_output();\n@@ -83,7 +83,7 @@ fn runtest(me: &str) {\n     // Make sure a stack trace isn't printed too many times\n     let mut p = Process::configure(ProcessConfig {\n         program: me,\n-        args: [~\"double-fail\"],\n+        args: [\"double-fail\".to_owned()],\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     }).unwrap();"}, {"sha": "8df2679aa53d505c2d1df1b7a484862c4aa7a129", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -10,5 +10,5 @@\n \n pub fn main() {\n     fn as_buf<T>(s: ~str, f: |~str| -> T) -> T { f(s) }\n-    as_buf(~\"foo\", |foo: ~str| -> () println!(\"{}\", foo) );\n+    as_buf(\"foo\".to_owned(), |foo: ~str| -> () println!(\"{}\", foo) );\n }"}, {"sha": "c961f59f98148f1c2567b18ea164a3f7fd0618e9", "filename": "src/test/run-pass/borrowed-ptr-pattern-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,6 +16,6 @@ fn foo(s: &~str) -> bool {\n }\n \n pub fn main() {\n-    assert!(foo(&~\"kitty\"));\n-    assert!(!foo(&~\"gata\"));\n+    assert!(foo(&\"kitty\".to_owned()));\n+    assert!(!foo(&\"gata\".to_owned()));\n }"}, {"sha": "2e90fba122e0905bfa8f224c144d99b7c6909a49", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -12,6 +12,6 @@\n \n pub fn main() {\n     assert!((@1 < @3));\n-    assert!((@@~\"hello \" > @@~\"hello\"));\n-    assert!((@@@~\"hello\" != @@@~\"there\"));\n+    assert!((@@\"hello \".to_owned() > @@\"hello\".to_owned()));\n+    assert!((@@@\"hello\".to_owned() != @@@\"there\".to_owned()));\n }"}, {"sha": "86fde76fb75fd7c14b36946d2651084c9b32db50", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -27,17 +27,17 @@ impl<T: Speak> Speak for Option<T> {\n     fn say(&self, s:&str) -> ~str {\n         match *self {\n             None => format!(\"{} - none\", s),\n-            Some(ref x) => { ~\"something!\" + x.say(s) }\n+            Some(ref x) => { \"something!\".to_owned() + x.say(s) }\n         }\n     }\n }\n \n \n pub fn main() {\n-    assert_eq!(3.hi(), ~\"hello: 3\");\n-    assert_eq!(Some(Some(3)).hi(), ~\"something!something!hello: 3\");\n-    assert_eq!(None::<int>.hi(), ~\"hello - none\");\n+    assert_eq!(3.hi(), \"hello: 3\".to_owned());\n+    assert_eq!(Some(Some(3)).hi(), \"something!something!hello: 3\".to_owned());\n+    assert_eq!(None::<int>.hi(), \"hello - none\".to_owned());\n \n-    assert_eq!(Some(None::<int>).hi(), ~\"something!hello - none\");\n-    assert_eq!(Some(3).hi(), ~\"something!hello: 3\");\n+    assert_eq!(Some(None::<int>).hi(), \"something!hello - none\".to_owned());\n+    assert_eq!(Some(3).hi(), \"something!hello: 3\".to_owned());\n }"}, {"sha": "0b38c7fa1ddfe9e5da60f5f3f73c89e2cf28d8e0", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -30,6 +30,6 @@ fn atoll(s: ~str) -> i64 {\n }\n \n pub fn main() {\n-    assert_eq!(atol(~\"1024\") * 10, atol(~\"10240\"));\n-    assert!((atoll(~\"11111111111111111\") * 10) == atoll(~\"111111111111111110\"));\n+    assert_eq!(atol(\"1024\".to_owned()) * 10, atol(\"10240\".to_owned()));\n+    assert!((atoll(\"11111111111111111\".to_owned()) * 10) == atoll(\"111111111111111110\".to_owned()));\n }"}, {"sha": "a6443dc5a1a9adeae75133266c0545df4e308bd0", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -45,5 +45,5 @@ fn main() {\n         debug!(\"debug\");\n         info!(\"info\");\n     });\n-    assert_eq!(r.read_to_str().unwrap(), ~\"info\\n\");\n+    assert_eq!(r.read_to_str().unwrap(), \"info\\n\".to_owned());\n }"}, {"sha": "7042f875111ad3a0c39a8b2431e40bff16020602", "filename": "src/test/run-pass/cci_nested_exe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,14 +17,14 @@ use cci_nested_lib::*;\n \n pub fn main() {\n     let lst = new_int_alist();\n-    alist_add(&lst, 22, ~\"hi\");\n-    alist_add(&lst, 44, ~\"ho\");\n-    assert_eq!(alist_get(&lst, 22), ~\"hi\");\n-    assert_eq!(alist_get(&lst, 44), ~\"ho\");\n+    alist_add(&lst, 22, \"hi\".to_owned());\n+    alist_add(&lst, 44, \"ho\".to_owned());\n+    assert_eq!(alist_get(&lst, 22), \"hi\".to_owned());\n+    assert_eq!(alist_get(&lst, 44), \"ho\".to_owned());\n \n     let lst = new_int_alist_2();\n-    alist_add(&lst, 22, ~\"hi\");\n-    alist_add(&lst, 44, ~\"ho\");\n-    assert_eq!(alist_get(&lst, 22), ~\"hi\");\n-    assert_eq!(alist_get(&lst, 44), ~\"ho\");\n+    alist_add(&lst, 22, \"hi\".to_owned());\n+    alist_add(&lst, 44, \"ho\".to_owned());\n+    assert_eq!(alist_get(&lst, 22), \"hi\".to_owned());\n+    assert_eq!(alist_get(&lst, 44), \"ho\".to_owned());\n }"}, {"sha": "d32eb03e10105a8e1d02918a01c8c01e114db712", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,5 +15,5 @@ use std::task;\n fn child2(_s: ~str) { }\n \n pub fn main() {\n-    let _x = task::spawn(proc() child2(~\"hi\"));\n+    let _x = task::spawn(proc() child2(\"hi\".to_owned()));\n }"}, {"sha": "75c3f1a06e2233824856e60b12b166a27e047535", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -23,4 +23,4 @@ impl Drop for cat {\n #[cat_maker]\n fn cat(name: ~str) -> cat { cat{name: name,} }\n \n-pub fn main() { let _kitty = cat(~\"Spotty\"); }\n+pub fn main() { let _kitty = cat(\"Spotty\".to_owned()); }"}, {"sha": "d506fa6eb331647922d958a5509b5ae5ebfc8304", "filename": "src/test/run-pass/class-attributes-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -33,5 +33,5 @@ fn cat(name: ~str) -> cat {\n }\n \n pub fn main() {\n-  let _kitty = cat(~\"Spotty\");\n+  let _kitty = cat(\"Spotty\".to_owned());\n }"}, {"sha": "85c3c5d518ed1915c8ad1801bb2b27163507cd7e", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -20,6 +20,6 @@ fn print_out(thing: ~ToStr, expected: ~str) {\n }\n \n pub fn main() {\n-  let nyan: ~ToStr = ~cat(0u, 2, ~\"nyan\") as ~ToStr;\n-  print_out(nyan, ~\"nyan\");\n+  let nyan: ~ToStr = ~cat(0u, 2, \"nyan\".to_owned()) as ~ToStr;\n+  print_out(nyan, \"nyan\".to_owned());\n }"}, {"sha": "701a6d44bf5fdb2738f742e7a4c01e994fce04be", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -93,7 +93,7 @@ fn annoy_neighbors(critter: &mut noisy) {\n }\n \n pub fn main() {\n-  let mut nyan: cat = cat(0u, 2, ~\"nyan\");\n+  let mut nyan: cat = cat(0u, 2, \"nyan\".to_owned());\n   let mut whitefang: dog = dog();\n   annoy_neighbors(&mut nyan);\n   annoy_neighbors(&mut whitefang);"}, {"sha": "fb479b5937ae2a25bc047d348fdcfba6e3388fbf", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -60,7 +60,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, ~\"nyan\");\n+    let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n     let mut nyan: &mut noisy = &mut nyan;\n     nyan.speak();\n }"}, {"sha": "96270577ce2b9389881d44270e8bbe32d5e9f1af", "filename": "src/test/run-pass/class-exports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-exports.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -33,5 +33,5 @@ mod kitty {\n }\n \n pub fn main() {\n-  assert_eq!(cat(~\"Spreckles\").get_name(), ~\"Spreckles\");\n+  assert_eq!(cat(\"Spreckles\".to_owned()).get_name(), \"Spreckles\".to_owned());\n }"}, {"sha": "360e82cf8fdacf00671e18bf758f0b9c26724cab", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -114,9 +114,9 @@ impl<T> cat<T> {\n }\n \n pub fn main() {\n-    let mut nyan: cat<~str> = cat::new(0, 2, ~\"nyan\");\n+    let mut nyan: cat<~str> = cat::new(0, 2, \"nyan\".to_owned());\n     for _ in range(1u, 5) { nyan.speak(); }\n-    assert!(*nyan.find(&1).unwrap() == ~\"nyan\");\n+    assert!(*nyan.find(&1).unwrap() == \"nyan\".to_owned());\n     assert_eq!(nyan.find(&10), None);\n     let mut spotty: cat<cat_type> = cat::new(2, 57, tuxedo);\n     for _ in range(0u, 6) { spotty.speak(); }"}, {"sha": "c068c226f4d384a61dac7a55e31b278409842502", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -57,7 +57,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let mut nyan = cat(0u, 2, ~\"nyan\");\n+  let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "3739e350d798cf000c885254534cbdcda3b8afd0", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -62,7 +62,7 @@ fn make_speak<C:noisy>(mut c: C) {\n }\n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, ~\"nyan\");\n+    let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n     nyan.eat();\n     assert!((!nyan.eat()));\n     for _ in range(1u, 10u) {"}, {"sha": "b6fdaf91dc8062400deedb40dbc4352489ff895d", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,11 +14,11 @@ use cci_class_6::kitties::cat;\n \n pub fn main() {\n   let mut nyan : cat<char> = cat::<char>(52u, 99, vec!('p'));\n-  let mut kitty = cat(1000u, 2, vec!(~\"tabby\"));\n+  let mut kitty = cat(1000u, 2, vec!(\"tabby\".to_owned()));\n   assert_eq!(nyan.how_hungry, 99);\n   assert_eq!(kitty.how_hungry, 2);\n   nyan.speak(vec!(1u,2u,3u));\n   assert_eq!(nyan.meow_count(), 55u);\n-  kitty.speak(vec!(~\"meow\", ~\"mew\", ~\"purr\", ~\"chirp\"));\n+  kitty.speak(vec!(\"meow\".to_owned(), \"mew\".to_owned(), \"purr\".to_owned(), \"chirp\".to_owned()));\n   assert_eq!(kitty.meow_count(), 1004u);\n }"}, {"sha": "515613675cb264707ae088cb8ef00f664888a39a", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -33,11 +33,11 @@ fn cat<U>(in_x : uint, in_y : int, in_info: Vec<U> ) -> cat<U> {\n \n pub fn main() {\n   let mut nyan : cat<int> = cat::<int>(52u, 99, vec!(9));\n-  let mut kitty = cat(1000u, 2, vec!(~\"tabby\"));\n+  let mut kitty = cat(1000u, 2, vec!(\"tabby\".to_owned()));\n   assert_eq!(nyan.how_hungry, 99);\n   assert_eq!(kitty.how_hungry, 2);\n   nyan.speak(vec!(1,2,3));\n   assert_eq!(nyan.meow_count(), 55u);\n-  kitty.speak(vec!(~\"meow\", ~\"mew\", ~\"purr\", ~\"chirp\"));\n+  kitty.speak(vec!(\"meow\".to_owned(), \"mew\".to_owned(), \"purr\".to_owned(), \"chirp\".to_owned()));\n   assert_eq!(kitty.meow_count(), 1004u);\n }"}, {"sha": "0f1e8aa2724b8cdd80acd782302e7ff81ef723d6", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -64,6 +64,6 @@ fn print_out(thing: ~ToStr, expected: ~str) {\n }\n \n pub fn main() {\n-  let nyan: ~ToStr = ~cat(0u, 2, ~\"nyan\") as ~ToStr;\n-  print_out(nyan, ~\"nyan\");\n+  let nyan: ~ToStr = ~cat(0u, 2, \"nyan\".to_owned()) as ~ToStr;\n+  print_out(nyan, \"nyan\".to_owned());\n }"}, {"sha": "c1ecbd9b1d2b5c486c2a52b84c4775748610e7de", "filename": "src/test/run-pass/class-str-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-str-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclass-str-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-str-field.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -21,5 +21,5 @@ fn cat(in_name: ~str) -> cat {\n }\n \n pub fn main() {\n-  let _nyan = cat(~\"nyan\");\n+  let _nyan = cat(\"nyan\".to_owned());\n }"}, {"sha": "d1b47e45ccfedbfb49a9eeb22de94298cfaf44cd", "filename": "src/test/run-pass/classes-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,7 +13,7 @@ extern crate cci_class_4;\n use cci_class_4::kitties::cat;\n \n pub fn main() {\n-    let mut nyan = cat(0u, 2, ~\"nyan\");\n+    let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n     nyan.eat();\n     assert!((!nyan.eat()));\n     for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "d54a29cde064ec1866a390f2f41f944c10eebbaa", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -49,7 +49,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n pub fn main() {\n-  let mut nyan = cat(0u, 2, ~\"nyan\");\n+  let mut nyan = cat(0u, 2, \"nyan\".to_owned());\n   nyan.eat();\n   assert!((!nyan.eat()));\n   for _ in range(1u, 10u) { nyan.speak(); };"}, {"sha": "76d73fd5b8705874a88652906215a51ab064c8e0", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -25,13 +25,13 @@ use std::os;\n pub fn main() {\n     let args = os::args();\n \n-    // Here, the rvalue `~\"signal\"` requires cleanup. Older versions\n+    // Here, the rvalue `\"signal\".to_owned()` requires cleanup. Older versions\n     // of the code had a problem that the cleanup scope for this\n-    // expression was the end of the `if`, and as the `~\"signal\"`\n+    // expression was the end of the `if`, and as the `\"signal\".to_owned()`\n     // expression was never evaluated, we wound up trying to clean\n     // uninitialized memory.\n \n-    if args.len() >= 2 && args[1] == ~\"signal\" {\n+    if args.len() >= 2 && args[1] == \"signal\".to_owned() {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     }"}, {"sha": "de7bdd15fa25e7ac606ddf84df975451b8038399", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -15,7 +15,7 @@ use std::cast;\n use std::io::stdio::println;\n \n fn call_it(f: proc(~str) -> ~str) {\n-    println!(\"{}\", f(~\"Fred\"))\n+    println!(\"{}\", f(\"Fred\".to_owned()))\n }\n \n fn call_a_thunk(f: ||) {\n@@ -48,15 +48,15 @@ fn call_bare_again(f: extern \"Rust\" fn(&str)) {\n pub fn main() {\n     // Procs\n \n-    let greeting = ~\"Hello \";\n+    let greeting = \"Hello \".to_owned();\n     call_it(proc(s) {\n         greeting + s\n     });\n \n-    let greeting = ~\"Goodbye \";\n+    let greeting = \"Goodbye \".to_owned();\n     call_it(proc(s) greeting + s);\n \n-    let greeting = ~\"How's life, \";\n+    let greeting = \"How's life, \".to_owned();\n     call_it(proc(s: ~str) -> ~str {\n         greeting + s\n     });"}, {"sha": "3ade33b43750d473970e0fd48fc4becd18c9ea67", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -19,14 +19,14 @@ fn putstr(_s: ~str) { }\n \n fn putint(_i: int) {\n     let mut i: int = 33;\n-    while i < 36 { putstr(~\"hi\"); i = i + 1; }\n+    while i < 36 { putstr(\"hi\".to_owned()); i = i + 1; }\n }\n \n fn zerg(i: int) -> int { return i; }\n \n fn foo(x: int) -> int {\n     let mut y: t = x + 2;\n-    putstr(~\"hello\");\n+    putstr(\"hello\".to_owned());\n     while y < 10 { putint(y); if y * 3 == 4 { y = y + 2; nothing(); } }\n     let mut z: t;\n     z = 0x55;"}, {"sha": "99f97a41907dfb314e4952b64fcc3c5d089e387c", "filename": "src/test/run-pass/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconcat.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!(format!(concat!(\"foo\", \"bar\", \"{}\"), \"baz\"), ~\"foobarbaz\");\n-    assert_eq!(format!(concat!()), ~\"\");\n+    assert_eq!(format!(concat!(\"foo\", \"bar\", \"{}\"), \"baz\"), \"foobarbaz\".to_owned());\n+    assert_eq!(format!(concat!()), \"\".to_owned());\n \n     assert_eq!(\n         concat!(1, 2i, 3u, 4f32, 4.0, 'a', true, ()),"}, {"sha": "ff47f078da300e45e6050d4bd80973177174c9b0", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,7 +18,7 @@ struct F { field: int }\n \n pub fn main() {\n     /*foo(1);\n-    foo(~\"hi\");\n+    foo(\"hi\".to_owned());\n     foo(~[1, 2, 3]);\n     foo(F{field: 42});\n     foo((1, 2u));"}, {"sha": "8569bc40d2e1c36a69e3e56b9ce20a07d6f54ac3", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,12 +18,12 @@ pub fn main() {\n     unsafe {\n         let foo = &A as *u8;\n         assert_eq!(str::raw::from_utf8(A), \"hi\");\n-        assert_eq!(str::raw::from_buf_len(foo, A.len()), ~\"hi\");\n-        assert_eq!(str::raw::from_buf_len(C, B.len()), ~\"hi\");\n+        assert_eq!(str::raw::from_buf_len(foo, A.len()), \"hi\".to_owned());\n+        assert_eq!(str::raw::from_buf_len(C, B.len()), \"hi\".to_owned());\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *u8) == A[0]);\n \n         let bar = str::raw::from_utf8(A).to_c_str();\n-        assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), ~\"hi\");\n+        assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), \"hi\".to_owned());\n     }\n }"}, {"sha": "83d3b51f74a4fb29ddf365128f8e8399be6f1fa0", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -68,14 +68,14 @@ iotest!(fn test_destroy_once() {\n \n #[cfg(unix)]\n pub fn sleeper() -> Process {\n-    Process::new(\"sleep\", [~\"1000\"]).unwrap()\n+    Process::new(\"sleep\", [\"1000\".to_owned()]).unwrap()\n }\n #[cfg(windows)]\n pub fn sleeper() -> Process {\n     // There's a `timeout` command on windows, but it doesn't like having\n     // its output piped, so instead just ping ourselves a few times with\n     // gaps inbetweeen so we're sure this process is alive for awhile\n-    Process::new(\"ping\", [~\"127.0.0.1\", ~\"-n\", ~\"1000\"]).unwrap()\n+    Process::new(\"ping\", [\"127.0.0.1\".to_owned(), \"-n\".to_owned(), \"1000\".to_owned()]).unwrap()\n }\n \n iotest!(fn test_destroy_twice() {"}, {"sha": "82b33d02214aec6b537a134426fd73b3ee73ff59", "filename": "src/test/run-pass/crate-method-reexport-grrrrrrr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-method-reexport-grrrrrrr.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -24,5 +24,5 @@ pub fn main() {\n     let x = @();\n     x.cx();\n     let y = ();\n-    y.add(~\"hi\");\n+    y.add(\"hi\".to_owned());\n }"}, {"sha": "ce24fa71607043d99c345bba515d42a22a985c47", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -20,8 +20,8 @@ struct Person {\n }\n \n fn main() {\n-    let person1 = Person { id: 5, name: ~\"Janet\", phone: 555_666_7777 };\n-    let person2 = Person { id: 5, name: ~\"Bob\", phone: 555_666_7777 };\n+    let person1 = Person { id: 5, name: \"Janet\".to_owned(), phone: 555_666_7777 };\n+    let person2 = Person { id: 5, name: \"Bob\".to_owned(), phone: 555_666_7777 };\n     assert!(hash::hash(&person1) == hash::hash(&person1));\n     assert!(hash::hash(&person1) != hash::hash(&person2));\n }"}, {"sha": "9811caacda00c8b79d602720e5409250f3f454e0", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -41,15 +41,15 @@ impl fmt::Show for Custom {\n }\n \n pub fn main() {\n-    assert_eq!(B1.to_str(), ~\"B1\");\n-    assert_eq!(B2.to_str(), ~\"B2\");\n-    assert_eq!(C1(3).to_str(), ~\"C1(3)\");\n-    assert_eq!(C2(B2).to_str(), ~\"C2(B2)\");\n-    assert_eq!(D1{ a: 2 }.to_str(), ~\"D1 { a: 2 }\");\n-    assert_eq!(E.to_str(), ~\"E\");\n-    assert_eq!(F(3).to_str(), ~\"F(3)\");\n-    assert_eq!(G(3, 4).to_str(), ~\"G(3, 4)\");\n-    assert_eq!(G(3, 4).to_str(), ~\"G(3, 4)\");\n-    assert_eq!(I{ a: 2, b: 4 }.to_str(), ~\"I { a: 2, b: 4 }\");\n-    assert_eq!(J(Custom).to_str(), ~\"J(yay)\");\n+    assert_eq!(B1.to_str(), \"B1\".to_owned());\n+    assert_eq!(B2.to_str(), \"B2\".to_owned());\n+    assert_eq!(C1(3).to_str(), \"C1(3)\".to_owned());\n+    assert_eq!(C2(B2).to_str(), \"C2(B2)\".to_owned());\n+    assert_eq!(D1{ a: 2 }.to_str(), \"D1 { a: 2 }\".to_owned());\n+    assert_eq!(E.to_str(), \"E\".to_owned());\n+    assert_eq!(F(3).to_str(), \"F(3)\".to_owned());\n+    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_owned());\n+    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_owned());\n+    assert_eq!(I{ a: 2, b: 4 }.to_str(), \"I { a: 2, b: 4 }\".to_owned());\n+    assert_eq!(J(Custom).to_str(), \"J(yay)\".to_owned());\n }"}, {"sha": "fc425dd707622c673247913a094ba88c9737186b", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -12,9 +12,9 @@\n struct Foo(int, int, ~str);\n \n pub fn main() {\n-  let a1 = Foo(5, 6, ~\"abc\");\n-  let a2 = Foo(5, 6, ~\"abc\");\n-  let b = Foo(5, 7, ~\"def\");\n+  let a1 = Foo(5, 6, \"abc\".to_owned());\n+  let a2 = Foo(5, 6, \"abc\".to_owned());\n+  let b = Foo(5, 7, \"def\".to_owned());\n \n   assert!(a1 == a1);\n   assert!(a2 == a1);"}, {"sha": "0ab0788fcf716afe4a08dfd2e19eb792d71f1ac5", "filename": "src/test/run-pass/drop-on-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,7 +13,7 @@\n \n fn f() -> int {\n     if true {\n-        let _s: ~str = ~\"should not leak\";\n+        let _s: ~str = \"should not leak\".to_owned();\n         return 1;\n     }\n     return 0;"}, {"sha": "12ed4830c82d00aacc02ceed4f9d05536c9a6b09", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -23,8 +23,8 @@ macro_rules! check {\n                 assert_eq!(size_of::<E>(), size_of::<$t>());\n                 assert_eq!(V as $t, $v);\n                 assert_eq!(C as $t, $v);\n-                assert_eq!(format!(\"{:?}\", V), ~\"V\");\n-                assert_eq!(format!(\"{:?}\", C), ~\"V\");\n+                assert_eq!(format!(\"{:?}\", V), \"V\".to_owned());\n+                assert_eq!(format!(\"{:?}\", C), \"V\".to_owned());\n             }\n         }\n         $m::check();"}, {"sha": "5397d5e65e4df52c642fc1d15b5f7aaa3d61b1c0", "filename": "src/test/run-pass/enum-disr-val-pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-disr-val-pretty.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,10 +13,10 @@\n enum color { red = 1, green, blue, imaginary = -1, }\n \n pub fn main() {\n-    test_color(red, 1, ~\"red\");\n-    test_color(green, 2, ~\"green\");\n-    test_color(blue, 3, ~\"blue\");\n-    test_color(imaginary, -1, ~\"imaginary\");\n+    test_color(red, 1, \"red\".to_owned());\n+    test_color(green, 2, \"green\".to_owned());\n+    test_color(blue, 3, \"blue\".to_owned());\n+    test_color(imaginary, -1, \"imaginary\".to_owned());\n }\n \n fn test_color(color: color, val: int, _name: ~str) {"}, {"sha": "363b44384af05d2dce4f1dce10bcd16e7169f08f", "filename": "src/test/run-pass/enum-variants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variants.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -18,8 +18,8 @@ enum Animal {\n }\n \n pub fn main() {\n-    let mut a: Animal = Dog(~\"Cocoa\", 37.2);\n-    a = Cat{ name: ~\"Spotty\", weight: 2.7 };\n+    let mut a: Animal = Dog(\"Cocoa\".to_owned(), 37.2);\n+    a = Cat{ name: \"Spotty\".to_owned(), weight: 2.7 };\n     // permuting the fields should work too\n-    let _c = Cat { weight: 3.1, name: ~\"Spreckles\" };\n+    let _c = Cat { weight: 3.1, name: \"Spreckles\".to_owned() };\n }"}, {"sha": "e879453f7c981e7869bab403fa76cf028a62f7bf", "filename": "src/test/run-pass/estr-uniq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Festr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-uniq.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,9 +11,9 @@\n #![allow(dead_assignment)]\n \n pub fn main() {\n-    let x : ~str = ~\"hello\";\n-    let _y : ~str = ~\"there\";\n-    let mut z = ~\"thing\";\n+    let x : ~str = \"hello\".to_owned();\n+    let _y : ~str = \"there\".to_owned();\n+    let mut z = \"thing\".to_owned();\n     z = x;\n     assert_eq!(z[0], ('h' as u8));\n     assert_eq!(z[4], ('o' as u8));"}, {"sha": "5c71d90c159be850e368186f9416c790425fdefc", "filename": "src/test/run-pass/exec-env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexec-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexec-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexec-env.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -13,5 +13,5 @@\n use std::os;\n \n pub fn main() {\n-    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(~\"22\"));\n+    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(\"22\".to_owned()));\n }"}, {"sha": "f536b055c6c5d285f4e1f0b815b4cbc92d1a93f4", "filename": "src/test/run-pass/explicit_self_xcrate_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit_self_xcrate_exe.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,6 +14,6 @@ extern crate explicit_self_xcrate;\n use explicit_self_xcrate::{Foo, Bar};\n \n pub fn main() {\n-    let x = Bar { x: ~\"hello\" };\n+    let x = Bar { x: \"hello\".to_owned() };\n     x.f();\n }"}, {"sha": "78e2d3caea9b990471fa9fa1cb5261577b951206", "filename": "src/test/run-pass/expr-if-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,8 +17,8 @@ fn test_box() {\n }\n \n fn test_str() {\n-    let rs = if true { ~\"happy\" } else { ~\"sad\" };\n-    assert_eq!(rs, ~\"happy\");\n+    let rs = if true { \"happy\".to_owned() } else { \"sad\".to_owned() };\n+    assert_eq!(rs, \"happy\".to_owned());\n }\n \n pub fn main() { test_box(); test_str(); }"}, {"sha": "de08c537abb853bc3f450575b7839b6e3816de98", "filename": "src/test/run-pass/expr-match-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-box.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,9 +17,9 @@ fn test_box() {\n }\n \n fn test_str() {\n-    let res = match true { true => { ~\"happy\" },\n+    let res = match true { true => { \"happy\".to_owned() },\n                          _ => fail!(\"not happy at all\") };\n-    assert_eq!(res, ~\"happy\");\n+    assert_eq!(res, \"happy\".to_owned());\n }\n \n pub fn main() { test_box(); test_str(); }"}, {"sha": "330ba896062e210b16198be3fb19a85519884e5d", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,5 +17,5 @@ pub fn main() {\n     let arr = [1,2,3];\n     let struc = Struc {a: 13u8, b: arr, c: 42};\n     let s = repr::repr_to_str(&struc);\n-    assert_eq!(s, ~\"Struc{a: 13u8, b: [1, 2, 3], c: 42}\");\n+    assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_owned());\n }"}, {"sha": "76902470c06e2b38b56b4d5ed1d7337603bcad8b", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -32,6 +32,6 @@ fn strlen(str: ~str) -> uint {\n }\n \n pub fn main() {\n-    let len = strlen(~\"Rust\");\n+    let len = strlen(\"Rust\".to_owned());\n     assert_eq!(len, 4u);\n }"}, {"sha": "c43c22d592cdc453fefe2ff88e94cff427321f69", "filename": "src/test/run-pass/format-ref-cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n     let name = RefCell::new(\"rust\");\n     let what = RefCell::new(\"rocks\");\n     let msg = format!(\"{name:?} {:?}\", &*what.borrow(), name=&*name.borrow());\n-    assert_eq!(msg, ~\"&\\\"rust\\\" &\\\"rocks\\\"\");\n+    assert_eq!(msg, \"&\\\"rust\\\" &\\\"rocks\\\"\".to_owned());\n }"}, {"sha": "26fefabdf9dd20e7890e9d121c97592d4d36b199", "filename": "src/test/run-pass/generic-tag-corruption.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-corruption.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -14,4 +14,4 @@\n // This used to cause memory corruption in stage 0.\n enum thing<K> { some(K), }\n \n-pub fn main() { let _x = some(~\"hi\"); }\n+pub fn main() { let _x = some(\"hi\".to_owned()); }"}, {"sha": "32ce8e6f5422592097a6b70f5ce46c9dfc0e4a7f", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -20,7 +20,7 @@ extern crate collections;\n    This originally came from the word-count benchmark.\n */\n \n-pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n+pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, \"1\".to_owned()); }\n \n mod map_reduce {\n     use collections::HashMap;\n@@ -96,5 +96,5 @@ mod map_reduce {\n }\n \n pub fn main() {\n-    map_reduce::map_reduce(vec!(~\"../src/test/run-pass/hashmap-memory.rs\"));\n+    map_reduce::map_reduce(vec!(\"../src/test/run-pass/hashmap-memory.rs\".to_owned()));\n }"}, {"sha": "ebecfb2c78ac21c61cf385fe2761d32ad1485a41", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -66,7 +66,7 @@ macro_rules! parse_node (\n     ) => (\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n-            [$(:$nodes,)* :text(~\".\")];\n+            [$(:$nodes,)* :text(\".\".to_owned())];\n             $($rest)*\n         )\n     );"}, {"sha": "d20c4ec83731ce104db6ad0a093f88e786f3f7e9", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -51,7 +51,7 @@ pub fn main() {\n     t!(format!(\"{}\", 1.0f32), \"1\");\n     t!(format!(\"{}\", 1.0f64), \"1\");\n     t!(format!(\"{}\", \"a\"), \"a\");\n-    t!(format!(\"{}\", ~\"a\"), \"a\");\n+    t!(format!(\"{}\", \"a\".to_owned()), \"a\");\n     t!(format!(\"{}\", false), \"false\");\n     t!(format!(\"{}\", 'a'), \"a\");\n \n@@ -65,7 +65,7 @@ pub fn main() {\n     t!(format!(\"{:x}\", 10u), \"a\");\n     t!(format!(\"{:X}\", 10u), \"A\");\n     t!(format!(\"{:s}\", \"foo\"), \"foo\");\n-    t!(format!(\"{:s}\", ~\"foo\"), \"foo\");\n+    t!(format!(\"{:s}\", \"foo\".to_owned()), \"foo\");\n     t!(format!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n     t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n     t!(format!(\"{:d}\", A), \"aloha\");\n@@ -216,5 +216,5 @@ fn test_order() {\n     }\n     assert_eq!(format!(\"{} {} {a} {b} {} {c}\",\n                        foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n-               ~\"1 2 4 5 3 6\");\n+               \"1 2 4 5 3 6\".to_owned());\n }"}, {"sha": "97f9c6bef7fa2cdb8fa1fa3fd9990c9b11a64b08", "filename": "src/test/run-pass/inferred-suffix-in-pattern-range.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,22 +11,22 @@\n pub fn main() {\n     let x = 2;\n     let x_message = match x {\n-      0 .. 1     => { ~\"not many\" }\n-      _          => { ~\"lots\" }\n+      0 .. 1     => { \"not many\".to_owned() }\n+      _          => { \"lots\".to_owned() }\n     };\n-    assert_eq!(x_message, ~\"lots\");\n+    assert_eq!(x_message, \"lots\".to_owned());\n \n     let y = 2i;\n     let y_message = match y {\n-      0 .. 1     => { ~\"not many\" }\n-      _          => { ~\"lots\" }\n+      0 .. 1     => { \"not many\".to_owned() }\n+      _          => { \"lots\".to_owned() }\n     };\n-    assert_eq!(y_message, ~\"lots\");\n+    assert_eq!(y_message, \"lots\".to_owned());\n \n     let z = 1u64;\n     let z_message = match z {\n-      0 .. 1     => { ~\"not many\" }\n-      _          => { ~\"lots\" }\n+      0 .. 1     => { \"not many\".to_owned() }\n+      _          => { \"lots\".to_owned() }\n     };\n-    assert_eq!(z_message, ~\"not many\");\n+    assert_eq!(z_message, \"not many\".to_owned());\n }"}, {"sha": "a430e1c8de91668c485ec0d974f3601f71015bd8", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,7 +17,7 @@ use std::io::process;\n \n pub fn main () {\n     let args = os::args();\n-    if args.len() > 1 && args[1] == ~\"child\" {\n+    if args.len() > 1 && args[1] == \"child\".to_owned() {\n         for _ in range(0, 1000) {\n             println!(\"hello?\");\n         }\n@@ -29,7 +29,7 @@ pub fn main () {\n \n     let config = process::ProcessConfig {\n         program : args[0].as_slice(),\n-        args : &[~\"child\"],\n+        args : &[\"child\".to_owned()],\n         stdout: process::Ignored,\n         stderr: process::Ignored,\n         .. process::ProcessConfig::new()"}, {"sha": "3cb71cb75e0fd3c8e51f519b80249aa03b2fccf4", "filename": "src/test/run-pass/issue-1257.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-1257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-1257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1257.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n pub fn main () {\n-  let mut line = ~\"\";\n+  let mut line = \"\".to_owned();\n   let mut i = 0;\n-  while line != ~\"exit\" {\n-    line = if i == 9 { ~\"exit\" } else { ~\"notexit\" };\n+  while line != \"exit\".to_owned() {\n+    line = if i == 9 { \"exit\".to_owned() } else { \"notexit\".to_owned() };\n     i += 1;\n   }\n }"}, {"sha": "aa4deeb73c9317c33f7de375169fab42278b91bc", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -34,12 +34,12 @@ fn main() {\n             rx.recv();\n         }\n     } else {\n-        parent(~\"green\");\n-        parent(~\"native\");\n+        parent(\"green\".to_owned());\n+        parent(\"native\".to_owned());\n         let (tx, rx) = channel();\n         native::task::spawn(proc() {\n-            parent(~\"green\");\n-            parent(~\"native\");\n+            parent(\"green\".to_owned());\n+            parent(\"native\".to_owned());\n             tx.send(());\n         });\n         rx.recv();\n@@ -48,7 +48,7 @@ fn main() {\n \n fn parent(flavor: ~str) {\n     let args = os::args();\n-    let mut p = io::Process::new(args[0].as_slice(), [~\"child\", flavor]).unwrap();\n+    let mut p = io::Process::new(args[0].as_slice(), [\"child\".to_owned(), flavor]).unwrap();\n     p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output();\n     assert!(out.status.success());"}, {"sha": "965b875a9e61caa7c3a9dfc85cc59456de5e97c6", "filename": "src/test/run-pass/issue-1701.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1701.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -16,16 +16,16 @@ enum animal { cat(pattern), dog(breed), rabbit(name, ear_kind), tiger }\n \n fn noise(a: animal) -> Option<~str> {\n     match a {\n-      cat(..)    => { Some(~\"meow\") }\n-      dog(..)    => { Some(~\"woof\") }\n+      cat(..)    => { Some(\"meow\".to_owned()) }\n+      dog(..)    => { Some(\"woof\".to_owned()) }\n       rabbit(..) => { None }\n-      tiger(..)  => { Some(~\"roar\") }\n+      tiger(..)  => { Some(\"roar\".to_owned()) }\n     }\n }\n \n pub fn main() {\n-    assert_eq!(noise(cat(tabby)), Some(~\"meow\"));\n-    assert_eq!(noise(dog(pug)), Some(~\"woof\"));\n-    assert_eq!(noise(rabbit(~\"Hilbert\", upright)), None);\n-    assert_eq!(noise(tiger), Some(~\"roar\"));\n+    assert_eq!(noise(cat(tabby)), Some(\"meow\".to_owned()));\n+    assert_eq!(noise(dog(pug)), Some(\"woof\".to_owned()));\n+    assert_eq!(noise(rabbit(\"Hilbert\".to_owned(), upright)), None);\n+    assert_eq!(noise(tiger), Some(\"roar\".to_owned()));\n }"}, {"sha": "81d3466751987507a3547b02c220d2b43cbbb53f", "filename": "src/test/run-pass/issue-1974.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-1974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-1974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1974.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -11,8 +11,8 @@\n // Issue 1974\n // Don't double free the condition allocation\n pub fn main() {\n-    let s = ~\"hej\";\n-    while s != ~\"\" {\n+    let s = \"hej\".to_owned();\n+    while s != \"\".to_owned() {\n         return;\n     }\n }"}, {"sha": "ce67b4c3fda7e5054360f9f1e5e69492a46df8e8", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -20,8 +20,8 @@ use std::cell::RefCell;\n use collections::HashMap;\n \n pub fn main() {\n-  let v = vec!(@~\"hi\");\n+  let v = vec!(@\"hi\".to_owned());\n   let mut m: req::header_map = HashMap::new();\n-  m.insert(~\"METHOD\", @RefCell::new(v));\n+  m.insert(\"METHOD\".to_owned(), @RefCell::new(v));\n   request::<int>(&m);\n }"}, {"sha": "597a709201f1fec26412225fd5c80605d627cbdb", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -17,7 +17,7 @@ extern crate collections;\n use collections::HashMap;\n \n fn add_interfaces(managed_ip: ~str, device: HashMap<~str, int>)  {\n-     println!(\"{}, {:?}\", managed_ip, device.get(&~\"interfaces\"));\n+     println!(\"{}, {:?}\", managed_ip, device.get(&\"interfaces\".to_owned()));\n }\n \n pub fn main() {}"}, {"sha": "91e21dedd49727cc74837fbc5f09a58412087426", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -41,21 +41,21 @@ fn add_interface(_store: int, managed_ip: ~str, data: json::Json) -> (~str, obje\n {\n     match &data {\n         &json::Object(ref interface) => {\n-            let name = lookup((*interface).clone(), ~\"ifDescr\", ~\"\");\n+            let name = lookup((*interface).clone(), \"ifDescr\".to_owned(), \"\".to_owned());\n             let label = format!(\"{}-{}\", managed_ip, name);\n \n             (label, bool_value(false))\n         }\n         _ => {\n             println!(\"Expected dict for {} interfaces but found {:?}\", managed_ip, data);\n-            (~\"gnos:missing-interface\", bool_value(true))\n+            (\"gnos:missing-interface\".to_owned(), bool_value(true))\n         }\n     }\n }\n \n fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, json::Json>)\n -> Vec<(~str, object)> {\n-    match device.get(&~\"interfaces\")\n+    match device.get(&\"interfaces\".to_owned())\n     {\n         &json::List(ref interfaces) =>\n         {\n@@ -66,7 +66,7 @@ fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, json::Json\n         _ =>\n         {\n             println!(\"Expected list for {} interfaces but found {:?}\", managed_ip,\n-                   device.get(&~\"interfaces\"));\n+                   device.get(&\"interfaces\".to_owned()));\n             Vec::new()\n         }\n     }"}, {"sha": "4626c0f0c787686424f4daed349740606ed10ff7", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -30,14 +30,14 @@ enum square {\n impl fmt::Show for square {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"{}\", match *self {\n-          bot => { ~\"R\" }\n-          wall => { ~\"#\" }\n-          rock => { ~\"*\" }\n-          lambda => { ~\"\\\\\" }\n-          closed_lift => { ~\"L\" }\n-          open_lift => { ~\"O\" }\n-          earth => { ~\".\" }\n-          empty => { ~\" \" }\n+          bot => { \"R\".to_owned() }\n+          wall => { \"#\".to_owned() }\n+          rock => { \"*\".to_owned() }\n+          lambda => { \"\\\\\".to_owned() }\n+          closed_lift => { \"L\".to_owned() }\n+          open_lift => { \"O\".to_owned() }\n+          earth => { \".\".to_owned() }\n+          empty => { \" \".to_owned() }\n         })\n     }\n }"}, {"sha": "404b066ac10beda846d325e6195e4e0e91a964f3", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af24045ff0e17764524a9eaf243479a3260c2d8b/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=af24045ff0e17764524a9eaf243479a3260c2d8b", "patch": "@@ -25,8 +25,8 @@ pub fn main() {\n         content: Vec::new(),\n         children: Vec::new()\n     };\n-    let v = vec!(~\"123\", ~\"abc\");\n-    node.content = vec!(~\"123\", ~\"abc\");\n+    let v = vec!(\"123\".to_owned(), \"abc\".to_owned());\n+    node.content = vec!(\"123\".to_owned(), \"abc\".to_owned());\n     print_str_vector(v);\n     print_str_vector(node.content.clone());\n "}]}