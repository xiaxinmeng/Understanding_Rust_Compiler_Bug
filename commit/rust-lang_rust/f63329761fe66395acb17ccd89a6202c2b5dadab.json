{"sha": "f63329761fe66395acb17ccd89a6202c2b5dadab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MzMyOTc2MWZlNjYzOTVhY2IxN2NjZDg5YTYyMDJjMmI1ZGFkYWI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-12T22:17:54Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-13T16:27:49Z"}, "message": "Cleanup utils, mostly doc", "tree": {"sha": "88387d252bb479cdd3baabd255e9141b9e265100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88387d252bb479cdd3baabd255e9141b9e265100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f63329761fe66395acb17ccd89a6202c2b5dadab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f63329761fe66395acb17ccd89a6202c2b5dadab", "html_url": "https://github.com/rust-lang/rust/commit/f63329761fe66395acb17ccd89a6202c2b5dadab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f63329761fe66395acb17ccd89a6202c2b5dadab/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09129c1b416cf0101b75e72e6a3ffdfbbef78542", "url": "https://api.github.com/repos/rust-lang/rust/commits/09129c1b416cf0101b75e72e6a3ffdfbbef78542", "html_url": "https://github.com/rust-lang/rust/commit/09129c1b416cf0101b75e72e6a3ffdfbbef78542"}], "stats": {"total": 110, "additions": 58, "deletions": 52}, "files": [{"sha": "db5944ab9b4c00cb4533c5a02c4bd06238fb1bf9", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f63329761fe66395acb17ccd89a6202c2b5dadab/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f63329761fe66395acb17ccd89a6202c2b5dadab/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f63329761fe66395acb17ccd89a6202c2b5dadab", "patch": "@@ -29,5 +29,4 @@ rustc-serialize = \"0.3\"\n \n [features]\n \n-structured_logging = []\n debugging = []"}, {"sha": "53f83d6921acd224c04eb6e695ef9c10c287d8b0", "filename": "src/utils.rs", "status": "modified", "additions": 58, "deletions": 51, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f63329761fe66395acb17ccd89a6202c2b5dadab/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f63329761fe66395acb17ccd89a6202c2b5dadab/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f63329761fe66395acb17ccd89a6202c2b5dadab", "patch": "@@ -78,20 +78,21 @@ macro_rules! if_let_chain {\n     };\n }\n \n-/// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one isn't)\n+/// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n+/// isn't).\n pub fn differing_macro_contexts(sp1: Span, sp2: Span) -> bool {\n     sp1.expn_id != sp2.expn_id\n }\n-/// returns true if this expn_info was expanded by any macro\n+/// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| info.is_some())\n }\n \n-/// returns true if the macro that expanded the crate was outside of\n-/// the current crate or was a compiler plugin\n+/// Returns true if the macro that expanded the crate was outside of the current crate or was a\n+/// compiler plugin.\n pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    /// invokes in_macro with the expansion info of the given span\n-    /// slightly heavy, try to use this after other checks have already happened\n+    /// Invokes in_macro with the expansion info of the given span slightly heavy, try to use this\n+    /// after other checks have already happened.\n     fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n@@ -110,25 +111,28 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| in_macro_ext(cx, info))\n }\n \n-/// check if a DefId's path matches the given absolute type path\n-/// usage e.g. with\n-/// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n+/// Check if a `DefId`'s path matches the given absolute type path usage.\n+///\n+/// # Examples\n+/// ```\n+/// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n+/// ```\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n     cx.tcx.with_path(def_id, |iter| {\n         iter.zip(path)\n             .all(|(nm, p)| nm.name().as_str() == *p)\n     })\n }\n \n-/// check if type is struct or enum type with given def path\n+/// Check if type is struct or enum type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n-/// check if method call given in \"expr\" belongs to given trait\n+/// Check if the method call given in `expr` belongs to given trait.\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n@@ -145,9 +149,10 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     }\n }\n \n-/// check if method call given in \"expr\" belongs to given trait\n+/// Check if the method call given in `expr` belongs to given trait.\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n+\n     let trt_id = cx.tcx\n                    .tables\n                    .borrow()\n@@ -161,21 +166,31 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     }\n }\n \n-/// match a Path against a slice of segment string literals, e.g.\n-/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+/// Match a `Path` against a slice of segment string literals.\n+///\n+/// # Examples\n+/// ```\n+/// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n-/// match a Path against a slice of segment string literals, e.g.\n-/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+/// Match a `Path` against a slice of segment string literals, e.g.\n+///\n+/// # Examples\n+/// ```\n+/// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n-/// match an Expr against a chain of methods, and return the matched Exprs. For example, if `expr`\n-/// represents the `.baz()` in `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])`\n-/// will return a Vec containing the Exprs for `.bar()` and `.baz()`\n+/// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n+///\n+/// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n+/// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec` containing the `Expr`s for\n+/// `.bar()` and `.baz()`\n pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n@@ -197,7 +212,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n }\n \n \n-/// get the name of the item the expression is in, if available\n+/// Get the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n@@ -208,7 +223,7 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n-/// checks if a `let` decl is from a for loop desugaring\n+/// Checks if a `let` decl is from a `for` loop desugaring.\n pub fn is_from_for_desugar(decl: &Decl) -> bool {\n     if_let_chain! {\n         [\n@@ -222,31 +237,39 @@ pub fn is_from_for_desugar(decl: &Decl) -> bool {\n }\n \n \n-/// convert a span to a code snippet if available, otherwise use default, e.g.\n-/// `snippet(cx, expr.span, \"..\")`\n+/// Convert a span to a code snippet if available, otherwise use default.\n+///\n+/// # Example\n+/// ```\n+/// snippet(cx, expr.span, \"..\")\n+/// ```\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n }\n \n-/// Converts a span to a code snippet. Returns None if not available.\n+/// Convert a span to a code snippet. Returns `None` if not available.\n pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().codemap().span_to_snippet(span).ok()\n }\n \n-/// convert a span (from a block) to a code snippet if available, otherwise use default, e.g.\n-/// `snippet(cx, expr.span, \"..\")`\n-/// This trims the code of indentation, except for the first line\n-/// Use it for blocks or block-like things which need to be printed as such\n+/// Convert a span (from a block) to a code snippet if available, otherwise use default.\n+/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n+/// things which need to be printed as such.\n+///\n+/// # Example\n+/// ```\n+/// snippet(cx, expr.span, \"..\")\n+/// ```\n pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     trim_multiline(snip, true)\n }\n \n-/// Like snippet_block, but add braces if the expr is not an ExprBlock\n-/// Also takes an Option<String> which can be put inside the braces\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n+/// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n-    let string = option.map_or(\"\".to_owned(), |s| s);\n+    let string = option.unwrap_or_default();\n     if let ExprBlock(_) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n@@ -256,8 +279,7 @@ pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String\n     }\n }\n \n-/// Trim indentation from a multiline string\n-/// with possibility of ignoring the first line\n+/// Trim indentation from a multiline string with possibility of ignoring the first line.\n pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n     let s_space = trim_multiline_inner(s, ignore_first, ' ');\n     let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n@@ -297,7 +319,7 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n     }\n }\n \n-/// get a parent expr if any \u2013 this is useful to constrain a lint\n+/// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.map;\n     let node_id: NodeId = e.id;\n@@ -350,22 +372,7 @@ impl<'a> Deref for DiagnosticWrapper<'a> {\n     }\n }\n \n-#[cfg(not(feature=\"structured_logging\"))]\n-pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n-    let mut db = cx.struct_span_lint(lint, sp, msg);\n-    if cx.current_level(lint) != Level::Allow {\n-        db.fileline_help(sp,\n-                         &format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-                                  lint.name_lower()));\n-    }\n-    DiagnosticWrapper(db)\n-}\n-\n-#[cfg(feature=\"structured_logging\")]\n pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n-    // lint.name / lint.desc is can give details of the lint\n-    // cx.sess().codemap() has all these nice functions for line/column/snippet details\n-    // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n     let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n         db.fileline_help(sp,\n@@ -419,15 +426,15 @@ pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint,\n     db\n }\n \n-/// return the base type for references and raw pointers\n+/// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n \n-/// return the base type for references and raw pointers, and count reference depth\n+/// Return the base type for references and raw pointers, and count reference depth.\n pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n         match ty.sty {"}]}