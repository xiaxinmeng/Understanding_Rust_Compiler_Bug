{"sha": "56ae9a1746f266097eb51cd958f31c406b6eb233", "node_id": "C_kwDOAAsO6NoAKDU2YWU5YTE3NDZmMjY2MDk3ZWI1MWNkOTU4ZjMxYzQwNmI2ZWIyMzM", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-29T08:08:26Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-29T08:10:59Z"}, "message": "`rustc_ast_pretty`: remove `ref` patterns", "tree": {"sha": "6fe823e99ba2f36e945677a484f0f49b8e272fae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fe823e99ba2f36e945677a484f0f49b8e272fae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ae9a1746f266097eb51cd958f31c406b6eb233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ae9a1746f266097eb51cd958f31c406b6eb233", "html_url": "https://github.com/rust-lang/rust/commit/56ae9a1746f266097eb51cd958f31c406b6eb233", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ae9a1746f266097eb51cd958f31c406b6eb233/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07b86a94c77483127a7b7371cb046e67d8e59279", "url": "https://api.github.com/repos/rust-lang/rust/commits/07b86a94c77483127a7b7371cb046e67d8e59279", "html_url": "https://github.com/rust-lang/rust/commit/07b86a94c77483127a7b7371cb046e67d8e59279"}], "stats": {"total": 430, "additions": 214, "deletions": 216}, "files": [{"sha": "0fe1045c244cb0c8279dffdfca65f740a60f33bf", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 88, "deletions": 87, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/56ae9a1746f266097eb51cd958f31c406b6eb233/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ae9a1746f266097eb51cd958f31c406b6eb233/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=56ae9a1746f266097eb51cd958f31c406b6eb233", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, Mutability, PatKind};\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, PatKind};\n use rustc_ast::{attr, BindingAnnotation, ByRef, DelimArgs, RangeEnd, RangeSyntax, Term};\n use rustc_ast::{GenericArg, GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n@@ -64,6 +64,7 @@ impl<'a> Comments<'a> {\n         Comments { sm, comments, current: 0 }\n     }\n \n+    // This shouldn't probably clone lmao\n     pub fn next(&self) -> Option<Comment> {\n         self.comments.get(self.current).cloned()\n     }\n@@ -268,10 +269,10 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn maybe_print_comment(&mut self, pos: BytePos) -> bool {\n         let mut has_comment = false;\n-        while let Some(ref cmnt) = self.next_comment() {\n+        while let Some(cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n                 has_comment = true;\n-                self.print_comment(cmnt);\n+                self.print_comment(&cmnt);\n             } else {\n                 break;\n             }\n@@ -366,8 +367,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         if self.next_comment().is_none() {\n             self.hardbreak();\n         }\n-        while let Some(ref cmnt) = self.next_comment() {\n-            self.print_comment(cmnt)\n+        while let Some(cmnt) = self.next_comment() {\n+            self.print_comment(&cmnt)\n         }\n     }\n \n@@ -446,8 +447,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.hardbreak_if_not_bol();\n         }\n         self.maybe_print_comment(attr.span.lo());\n-        match attr.kind {\n-            ast::AttrKind::Normal(ref normal) => {\n+        match &attr.kind {\n+            ast::AttrKind::Normal(normal) => {\n                 match attr.style {\n                     ast::AttrStyle::Inner => self.word(\"#![\"),\n                     ast::AttrStyle::Outer => self.word(\"#[\"),\n@@ -456,7 +457,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.word(\"]\");\n             }\n             ast::AttrKind::DocComment(comment_kind, data) => {\n-                self.word(doc_comment_to_string(comment_kind, attr.style, data));\n+                self.word(doc_comment_to_string(*comment_kind, attr.style, *data));\n                 self.hardbreak()\n             }\n         }\n@@ -497,22 +498,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) {\n         match item {\n-            ast::NestedMetaItem::MetaItem(ref mi) => self.print_meta_item(mi),\n-            ast::NestedMetaItem::Lit(ref lit) => self.print_meta_item_lit(lit),\n+            ast::NestedMetaItem::MetaItem(mi) => self.print_meta_item(mi),\n+            ast::NestedMetaItem::Lit(lit) => self.print_meta_item_lit(lit),\n         }\n     }\n \n     fn print_meta_item(&mut self, item: &ast::MetaItem) {\n         self.ibox(INDENT_UNIT);\n-        match item.kind {\n+        match &item.kind {\n             ast::MetaItemKind::Word => self.print_path(&item.path, false, 0),\n-            ast::MetaItemKind::NameValue(ref value) => {\n+            ast::MetaItemKind::NameValue(value) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_meta_item_lit(value);\n             }\n-            ast::MetaItemKind::List(ref items) => {\n+            ast::MetaItemKind::List(items) => {\n                 self.print_path(&item.path, false, 0);\n                 self.popen();\n                 self.commasep(Consistent, &items, |s, i| s.print_meta_list_item(i));\n@@ -657,7 +658,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_path_segment(&mut self, segment: &ast::PathSegment, colons_before_params: bool) {\n         if segment.ident.name != kw::PathRoot {\n             self.print_ident(segment.ident);\n-            if let Some(ref args) = segment.args {\n+            if let Some(args) = &segment.args {\n                 self.print_generic_args(args, colons_before_params);\n             }\n         }\n@@ -712,19 +713,19 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn nonterminal_to_string(&self, nt: &Nonterminal) -> String {\n-        match *nt {\n-            token::NtExpr(ref e) => self.expr_to_string(e),\n-            token::NtMeta(ref e) => self.attr_item_to_string(e),\n-            token::NtTy(ref e) => self.ty_to_string(e),\n-            token::NtPath(ref e) => self.path_to_string(e),\n-            token::NtItem(ref e) => self.item_to_string(e),\n-            token::NtBlock(ref e) => self.block_to_string(e),\n-            token::NtStmt(ref e) => self.stmt_to_string(e),\n-            token::NtPat(ref e) => self.pat_to_string(e),\n-            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n+        match nt {\n+            token::NtExpr(e) => self.expr_to_string(e),\n+            token::NtMeta(e) => self.attr_item_to_string(e),\n+            token::NtTy(e) => self.ty_to_string(e),\n+            token::NtPath(e) => self.path_to_string(e),\n+            token::NtItem(e) => self.item_to_string(e),\n+            token::NtBlock(e) => self.block_to_string(e),\n+            token::NtStmt(e) => self.stmt_to_string(e),\n+            token::NtPat(e) => self.pat_to_string(e),\n+            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(*e, *is_raw).to_string(),\n             token::NtLifetime(e) => e.to_string(),\n-            token::NtLiteral(ref e) => self.expr_to_string(e),\n-            token::NtVis(ref e) => self.vis_to_string(e),\n+            token::NtLiteral(e) => self.expr_to_string(e),\n+            token::NtVis(e) => self.vis_to_string(e),\n         }\n     }\n \n@@ -917,8 +918,8 @@ impl<'a> PrintState<'a> for State<'a> {\n             self.word(\"::\")\n         }\n \n-        match *args {\n-            ast::GenericArgs::AngleBracketed(ref data) => {\n+        match args {\n+            ast::GenericArgs::AngleBracketed(data) => {\n                 self.word(\"<\");\n                 self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n                     ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n@@ -927,7 +928,7 @@ impl<'a> PrintState<'a> for State<'a> {\n                 self.word(\">\")\n             }\n \n-            ast::GenericArgs::Parenthesized(ref data) => {\n+            ast::GenericArgs::Parenthesized(data) => {\n                 self.word(\"(\");\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(ty));\n                 self.word(\")\");\n@@ -1011,62 +1012,62 @@ impl<'a> State<'a> {\n     pub fn print_type(&mut self, ty: &ast::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.kind {\n-            ast::TyKind::Slice(ref ty) => {\n+        match &ty.kind {\n+            ast::TyKind::Slice(ty) => {\n                 self.word(\"[\");\n                 self.print_type(ty);\n                 self.word(\"]\");\n             }\n-            ast::TyKind::Ptr(ref mt) => {\n+            ast::TyKind::Ptr(mt) => {\n                 self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n-            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Rptr(lifetime, mt) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n                 self.word(\"!\");\n             }\n-            ast::TyKind::Tup(ref elts) => {\n+            ast::TyKind::Tup(elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            ast::TyKind::Paren(ref typ) => {\n+            ast::TyKind::Paren(typ) => {\n                 self.popen();\n                 self.print_type(typ);\n                 self.pclose();\n             }\n-            ast::TyKind::BareFn(ref f) => {\n+            ast::TyKind::BareFn(f) => {\n                 self.print_ty_fn(f.ext, f.unsafety, &f.decl, None, &f.generic_params);\n             }\n-            ast::TyKind::Path(None, ref path) => {\n+            ast::TyKind::Path(None, path) => {\n                 self.print_path(path, false, 0);\n             }\n-            ast::TyKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, false),\n-            ast::TyKind::TraitObject(ref bounds, syntax) => {\n-                if syntax == ast::TraitObjectSyntax::Dyn {\n+            ast::TyKind::Path(Some(qself), path) => self.print_qpath(path, qself, false),\n+            ast::TyKind::TraitObject(bounds, syntax) => {\n+                if *syntax == ast::TraitObjectSyntax::Dyn {\n                     self.word_nbsp(\"dyn\");\n                 }\n                 self.print_type_bounds(bounds);\n             }\n-            ast::TyKind::ImplTrait(_, ref bounds) => {\n+            ast::TyKind::ImplTrait(_, bounds) => {\n                 self.word_nbsp(\"impl\");\n                 self.print_type_bounds(bounds);\n             }\n-            ast::TyKind::Array(ref ty, ref length) => {\n+            ast::TyKind::Array(ty, length) => {\n                 self.word(\"[\");\n                 self.print_type(ty);\n                 self.word(\"; \");\n                 self.print_expr(&length.value);\n                 self.word(\"]\");\n             }\n-            ast::TyKind::Typeof(ref e) => {\n+            ast::TyKind::Typeof(e) => {\n                 self.word(\"typeof(\");\n                 self.print_expr(&e.value);\n                 self.word(\")\");\n@@ -1082,7 +1083,7 @@ impl<'a> State<'a> {\n             ast::TyKind::ImplicitSelf => {\n                 self.word(\"Self\");\n             }\n-            ast::TyKind::MacCall(ref m) => {\n+            ast::TyKind::MacCall(m) => {\n                 self.print_mac(m);\n             }\n             ast::TyKind::CVarArgs => {\n@@ -1111,8 +1112,8 @@ impl<'a> State<'a> {\n \n     pub(crate) fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n-        match st.kind {\n-            ast::StmtKind::Local(ref loc) => {\n+        match &st.kind {\n+            ast::StmtKind::Local(loc) => {\n                 self.print_outer_attributes(&loc.attrs);\n                 self.space_if_not_bol();\n                 self.ibox(INDENT_UNIT);\n@@ -1135,15 +1136,15 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // `let` ibox\n             }\n-            ast::StmtKind::Item(ref item) => self.print_item(item),\n-            ast::StmtKind::Expr(ref expr) => {\n+            ast::StmtKind::Item(item) => self.print_item(item),\n+            ast::StmtKind::Expr(expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 if classify::expr_requires_semi_to_be_stmt(expr) {\n                     self.word(\";\");\n                 }\n             }\n-            ast::StmtKind::Semi(ref expr) => {\n+            ast::StmtKind::Semi(expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 self.word(\";\");\n@@ -1152,7 +1153,7 @@ impl<'a> State<'a> {\n                 self.space_if_not_bol();\n                 self.word(\";\");\n             }\n-            ast::StmtKind::MacCall(ref mac) => {\n+            ast::StmtKind::MacCall(mac) => {\n                 self.space_if_not_bol();\n                 self.print_outer_attributes(&mac.attrs);\n                 self.print_mac(&mac.mac);\n@@ -1193,8 +1194,8 @@ impl<'a> State<'a> {\n         let has_attrs = self.print_inner_attributes(attrs);\n \n         for (i, st) in blk.stmts.iter().enumerate() {\n-            match st.kind {\n-                ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n+            match &st.kind {\n+                ast::StmtKind::Expr(expr) if i == blk.stmts.len() - 1 => {\n                     self.maybe_print_comment(st.span.lo());\n                     self.space_if_not_bol();\n                     self.print_expr_outer_attr_style(expr, false);\n@@ -1362,7 +1363,7 @@ impl<'a> State<'a> {\n \n     pub(crate) fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n-        if let Some(ref ty) = loc.ty {\n+        if let Some(ty) = &loc.ty {\n             self.word_space(\":\");\n             self.print_type(ty);\n         }\n@@ -1386,7 +1387,7 @@ impl<'a> State<'a> {\n         for item_segment in &path.segments[qself.position..] {\n             self.word(\"::\");\n             self.print_ident(item_segment.ident);\n-            if let Some(ref args) = item_segment.args {\n+            if let Some(args) = &item_segment.args {\n                 self.print_generic_args(args, colons_before_params)\n             }\n         }\n@@ -1397,23 +1398,23 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n         is that it doesn't matter */\n-        match pat.kind {\n+        match &pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, ref sub) => {\n-                if by_ref == ByRef::Yes {\n+            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, sub) => {\n+                if *by_ref == ByRef::Yes {\n                     self.word_nbsp(\"ref\");\n                 }\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word_nbsp(\"mut\");\n                 }\n-                self.print_ident(ident);\n-                if let Some(ref p) = *sub {\n+                self.print_ident(*ident);\n+                if let Some(p) = sub {\n                     self.space();\n                     self.word_space(\"@\");\n                     self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref qself, ref path, ref elts) => {\n+            PatKind::TupleStruct(qself, path, elts) => {\n                 if let Some(qself) = qself {\n                     self.print_qpath(path, qself, true);\n                 } else {\n@@ -1423,16 +1424,16 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n-            PatKind::Or(ref pats) => {\n+            PatKind::Or(pats) => {\n                 self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(p));\n             }\n-            PatKind::Path(None, ref path) => {\n+            PatKind::Path(None, path) => {\n                 self.print_path(path, true, 0);\n             }\n-            PatKind::Path(Some(ref qself), ref path) => {\n+            PatKind::Path(Some(qself), path) => {\n                 self.print_qpath(path, qself, false);\n             }\n-            PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+            PatKind::Struct(qself, path, fields, etc) => {\n                 if let Some(qself) = qself {\n                     self.print_qpath(path, qself, true);\n                 } else {\n@@ -1458,7 +1459,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.pat.span,\n                 );\n-                if etc {\n+                if *etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n@@ -1469,21 +1470,21 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"}\");\n             }\n-            PatKind::Tuple(ref elts) => {\n+            PatKind::Tuple(elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            PatKind::Box(ref inner) => {\n+            PatKind::Box(inner) => {\n                 self.word(\"box \");\n                 self.print_pat(inner);\n             }\n-            PatKind::Ref(ref inner, mutbl) => {\n+            PatKind::Ref(inner, mutbl) => {\n                 self.word(\"&\");\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word(\"mut \");\n                 }\n                 if let PatKind::Ident(ast::BindingAnnotation::MUT, ..) = inner.kind {\n@@ -1494,12 +1495,12 @@ impl<'a> State<'a> {\n                     self.print_pat(inner);\n                 }\n             }\n-            PatKind::Lit(ref e) => self.print_expr(&**e),\n-            PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n+            PatKind::Lit(e) => self.print_expr(&**e),\n+            PatKind::Range(begin, end, Spanned { node: end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n                 }\n-                match *end_kind {\n+                match end_kind {\n                     RangeEnd::Included(RangeSyntax::DotDotDot) => self.word(\"...\"),\n                     RangeEnd::Included(RangeSyntax::DotDotEq) => self.word(\"..=\"),\n                     RangeEnd::Excluded => self.word(\"..\"),\n@@ -1508,36 +1509,36 @@ impl<'a> State<'a> {\n                     self.print_expr(e);\n                 }\n             }\n-            PatKind::Slice(ref elts) => {\n+            PatKind::Slice(elts) => {\n                 self.word(\"[\");\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n             PatKind::Rest => self.word(\"..\"),\n-            PatKind::Paren(ref inner) => {\n+            PatKind::Paren(inner) => {\n                 self.popen();\n                 self.print_pat(inner);\n                 self.pclose();\n             }\n-            PatKind::MacCall(ref m) => self.print_mac(m),\n+            PatKind::MacCall(m) => self.print_mac(m),\n         }\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n-        match explicit_self.node {\n+        match &explicit_self.node {\n             SelfKind::Value(m) => {\n-                self.print_mutability(m, false);\n+                self.print_mutability(*m, false);\n                 self.word(\"self\")\n             }\n-            SelfKind::Region(ref lt, m) => {\n+            SelfKind::Region(lt, m) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lt);\n-                self.print_mutability(m, false);\n+                self.print_mutability(*m, false);\n                 self.word(\"self\")\n             }\n-            SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m, false);\n+            SelfKind::Explicit(typ, m) => {\n+                self.print_mutability(*m, false);\n                 self.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n@@ -1599,7 +1600,7 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n \n-            match param.kind {\n+            match &param.kind {\n                 ast::GenericParamKind::Lifetime => {\n                     let lt = ast::Lifetime { id: param.id, ident: param.ident };\n                     s.print_lifetime(lt);\n@@ -1608,19 +1609,19 @@ impl<'a> State<'a> {\n                         s.print_lifetime_bounds(&param.bounds)\n                     }\n                 }\n-                ast::GenericParamKind::Type { ref default } => {\n+                ast::GenericParamKind::Type { default } => {\n                     s.print_ident(param.ident);\n                     if !param.bounds.is_empty() {\n                         s.word_nbsp(\":\");\n                         s.print_type_bounds(&param.bounds);\n                     }\n-                    if let Some(ref default) = default {\n+                    if let Some(default) = default {\n                         s.space();\n                         s.word_space(\"=\");\n                         s.print_type(default)\n                     }\n                 }\n-                ast::GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+                ast::GenericParamKind::Const { ty, default, .. } => {\n                     s.word_space(\"const\");\n                     s.print_ident(param.ident);\n                     s.space();\n@@ -1630,7 +1631,7 @@ impl<'a> State<'a> {\n                         s.word_nbsp(\":\");\n                         s.print_type_bounds(&param.bounds);\n                     }\n-                    if let Some(ref default) = default {\n+                    if let Some(default) = default {\n                         s.space();\n                         s.word_space(\"=\");\n                         s.print_expr(&default.value);"}, {"sha": "81483ac30d1de21bc5c1355832aa394fb58629bc", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 68, "deletions": 76, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/56ae9a1746f266097eb51cd958f31c406b6eb233/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ae9a1746f266097eb51cd958f31c406b6eb233/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=56ae9a1746f266097eb51cd958f31c406b6eb233", "patch": "@@ -8,9 +8,9 @@ use rustc_ast::{self as ast, BlockCheckMode};\n impl<'a> State<'a> {\n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n         if let Some(_else) = els {\n-            match _else.kind {\n+            match &_else.kind {\n                 // Another `else if` block.\n-                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                ast::ExprKind::If(i, then, e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else if \");\n@@ -20,7 +20,7 @@ impl<'a> State<'a> {\n                     self.print_else(e.as_deref())\n                 }\n                 // Final `else` block.\n-                ast::ExprKind::Block(ref b, _) => {\n+                ast::ExprKind::Block(b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else \");\n@@ -202,7 +202,7 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(receiver, parser::PREC_POSTFIX);\n         self.word(\".\");\n         self.print_ident(segment.ident);\n-        if let Some(ref args) = segment.args {\n+        if let Some(args) = &segment.args {\n             self.print_generic_args(args, true);\n         }\n         self.print_call_post(base_args)\n@@ -284,73 +284,66 @@ impl<'a> State<'a> {\n \n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.kind {\n-            ast::ExprKind::Box(ref expr) => {\n+        match &expr.kind {\n+            ast::ExprKind::Box(expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n             }\n-            ast::ExprKind::Array(ref exprs) => {\n+            ast::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }\n-            ast::ExprKind::ConstBlock(ref anon_const) => {\n+            ast::ExprKind::ConstBlock(anon_const) => {\n                 self.print_expr_anon_const(anon_const, attrs);\n             }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n+            ast::ExprKind::Repeat(element, count) => {\n                 self.print_expr_repeat(element, count);\n             }\n-            ast::ExprKind::Struct(ref se) => {\n+            ast::ExprKind::Struct(se) => {\n                 self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n             }\n-            ast::ExprKind::Tup(ref exprs) => {\n+            ast::ExprKind::Tup(exprs) => {\n                 self.print_expr_tup(exprs);\n             }\n-            ast::ExprKind::Call(ref func, ref args) => {\n+            ast::ExprKind::Call(func, args) => {\n                 self.print_expr_call(func, &args);\n             }\n-            ast::ExprKind::MethodCall(box ast::MethodCall {\n-                ref seg,\n-                ref receiver,\n-                ref args,\n-                ..\n-            }) => {\n+            ast::ExprKind::MethodCall(box ast::MethodCall { seg, receiver, args, .. }) => {\n                 self.print_expr_method_call(seg, &receiver, &args);\n             }\n-            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, lhs, rhs);\n+            ast::ExprKind::Binary(op, lhs, rhs) => {\n+                self.print_expr_binary(*op, lhs, rhs);\n             }\n-            ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, expr);\n+            ast::ExprKind::Unary(op, expr) => {\n+                self.print_expr_unary(*op, expr);\n             }\n-            ast::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, expr);\n+            ast::ExprKind::AddrOf(k, m, expr) => {\n+                self.print_expr_addr_of(*k, *m, expr);\n             }\n             ast::ExprKind::Lit(token_lit) => {\n-                self.print_token_literal(token_lit, expr.span);\n+                self.print_token_literal(*token_lit, expr.span);\n             }\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n+            ast::ExprKind::IncludedBytes(bytes) => {\n                 let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n                 self.print_token_literal(lit, expr.span)\n             }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n+            ast::ExprKind::Cast(expr, ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n                 self.space();\n                 self.word_space(\"as\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n+            ast::ExprKind::Type(expr, ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n                 self.word_space(\":\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+            ast::ExprKind::Let(pat, scrutinee, _) => {\n                 self.print_let(pat, scrutinee);\n             }\n-            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(test, blk, elseopt.as_deref())\n-            }\n-            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+            ast::ExprKind::If(test, blk, elseopt) => self.print_if(test, blk, elseopt.as_deref()),\n+            ast::ExprKind::While(test, blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -362,7 +355,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+            ast::ExprKind::ForLoop(pat, iter, blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -377,7 +370,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Loop(ref blk, opt_label, _) => {\n+            ast::ExprKind::Loop(blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -387,7 +380,7 @@ impl<'a> State<'a> {\n                 self.word_nbsp(\"loop\");\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Match(ref expr, ref arms) => {\n+            ast::ExprKind::Match(expr, arms) => {\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.word_nbsp(\"match\");\n@@ -402,18 +395,18 @@ impl<'a> State<'a> {\n                 self.bclose(expr.span, empty);\n             }\n             ast::ExprKind::Closure(box ast::Closure {\n-                ref binder,\n+                binder,\n                 capture_clause,\n                 asyncness,\n                 movability,\n-                ref fn_decl,\n-                ref body,\n+                fn_decl,\n+                body,\n                 fn_decl_span: _,\n             }) => {\n                 self.print_closure_binder(binder);\n-                self.print_movability(movability);\n-                self.print_asyncness(asyncness);\n-                self.print_capture_clause(capture_clause);\n+                self.print_movability(*movability);\n+                self.print_asyncness(*asyncness);\n+                self.print_capture_clause(*capture_clause);\n \n                 self.print_fn_params_and_ret(fn_decl, true);\n                 self.space();\n@@ -425,7 +418,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n             }\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n+            ast::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -436,72 +429,71 @@ impl<'a> State<'a> {\n                 self.ibox(0);\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+            ast::ExprKind::Async(capture_clause, _, blk) => {\n                 self.word_nbsp(\"async\");\n-                self.print_capture_clause(capture_clause);\n+                self.print_capture_clause(*capture_clause);\n                 // cbox/ibox in analogy to the `ExprKind::Block` arm above\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Await(ref expr) => {\n+            ast::ExprKind::Await(expr) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".await\");\n             }\n-            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            ast::ExprKind::Assign(lhs, rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n-            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(op, lhs, rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word(op.node.to_string());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n-            ast::ExprKind::Field(ref expr, ident) => {\n+            ast::ExprKind::Field(expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".\");\n-                self.print_ident(ident);\n+                self.print_ident(*ident);\n             }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n+            ast::ExprKind::Index(expr, index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\"[\");\n                 self.print_expr(index);\n                 self.word(\"]\");\n             }\n-            ast::ExprKind::Range(ref start, ref end, limits) => {\n+            ast::ExprKind::Range(start, end, limits) => {\n                 // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n                 // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n                 // Here we use a fake precedence value so that any child with lower precedence than\n                 // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n                 let fake_prec = AssocOp::LOr.precedence() as i8;\n-                if let Some(ref e) = *start {\n+                if let Some(e) = start {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n-                if limits == ast::RangeLimits::HalfOpen {\n-                    self.word(\"..\");\n-                } else {\n-                    self.word(\"..=\");\n+                match limits {\n+                    ast::RangeLimits::HalfOpen => self.word(\"..\"),\n+                    ast::RangeLimits::Closed => self.word(\"..=\"),\n                 }\n-                if let Some(ref e) = *end {\n+                if let Some(e) = end {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n             }\n             ast::ExprKind::Underscore => self.word(\"_\"),\n-            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n-            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n-            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n+            ast::ExprKind::Path(None, path) => self.print_path(path, true, 0),\n+            ast::ExprKind::Path(Some(qself), path) => self.print_qpath(path, qself, true),\n+            ast::ExprKind::Break(opt_label, opt_expr) => {\n                 self.word(\"break\");\n                 if let Some(label) = opt_label {\n                     self.space();\n                     self.print_ident(label.ident);\n                 }\n-                if let Some(ref expr) = *opt_expr {\n+                if let Some(expr) = opt_expr {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n@@ -513,45 +505,45 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                 }\n             }\n-            ast::ExprKind::Ret(ref result) => {\n+            ast::ExprKind::Ret(result) => {\n                 self.word(\"return\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::Yeet(ref result) => {\n+            ast::ExprKind::Yeet(result) => {\n                 self.word(\"do\");\n                 self.word(\" \");\n                 self.word(\"yeet\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::InlineAsm(ref a) => {\n+            ast::ExprKind::InlineAsm(a) => {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n-            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n-            ast::ExprKind::Paren(ref e) => {\n+            ast::ExprKind::MacCall(m) => self.print_mac(m),\n+            ast::ExprKind::Paren(e) => {\n                 self.popen();\n                 self.print_expr(e);\n                 self.pclose();\n             }\n-            ast::ExprKind::Yield(ref e) => {\n+            ast::ExprKind::Yield(e) => {\n                 self.word(\"yield\");\n \n-                if let Some(ref expr) = *e {\n+                if let Some(expr) = e {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::Try(ref e) => {\n+            ast::ExprKind::Try(e) => {\n                 self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n                 self.word(\"?\")\n             }\n-            ast::ExprKind::TryBlock(ref blk) => {\n+            ast::ExprKind::TryBlock(blk) => {\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.word_nbsp(\"try\");\n@@ -578,15 +570,15 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&arm.attrs);\n         self.print_pat(&arm.pat);\n         self.space();\n-        if let Some(ref e) = arm.guard {\n+        if let Some(e) = &arm.guard {\n             self.word_space(\"if\");\n             self.print_expr(e);\n             self.space();\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.kind {\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n+        match &arm.body.kind {\n+            ast::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "c52f15401abe3094b9e351344ae5e570bc5c0d6e", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/56ae9a1746f266097eb51cd958f31c406b6eb233/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ae9a1746f266097eb51cd958f31c406b6eb233/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=56ae9a1746f266097eb51cd958f31c406b6eb233", "patch": "@@ -136,10 +136,10 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.kind {\n+        match &item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n-                if let Some(orig_name) = orig_name {\n+                if let &Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n                     self.space();\n                     self.word(\"as\");\n@@ -150,35 +150,41 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::Use(ref tree) => {\n+            ast::ItemKind::Use(tree) => {\n                 self.print_visibility(&item.vis);\n                 self.word_nbsp(\"use\");\n                 self.print_use_tree(tree);\n                 self.word(\";\");\n             }\n-            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+            ast::ItemKind::Static(ty, mutbl, body) => {\n                 let def = ast::Defaultness::Final;\n-                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n+                self.print_item_const(\n+                    item.ident,\n+                    Some(*mutbl),\n+                    ty,\n+                    body.as_deref(),\n+                    &item.vis,\n+                    def,\n+                );\n             }\n-            ast::ItemKind::Const(def, ref ty, ref body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n+            ast::ItemKind::Const(def, ty, body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, *def);\n             }\n-            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                let body = body.as_deref();\n+            ast::ItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n                 self.print_fn_full(\n                     sig,\n                     item.ident,\n                     generics,\n                     &item.vis,\n-                    defaultness,\n-                    body,\n+                    *defaultness,\n+                    body.as_deref(),\n                     &item.attrs,\n                 );\n             }\n-            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n+            ast::ItemKind::Mod(unsafety, mod_kind) => {\n                 self.head(Self::to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(unsafety);\n+                    s.print_unsafety(*unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n@@ -201,7 +207,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n-            ast::ItemKind::ForeignMod(ref nmod) => {\n+            ast::ItemKind::ForeignMod(nmod) => {\n                 self.head(Self::to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n@@ -215,7 +221,7 @@ impl<'a> State<'a> {\n                 let empty = item.attrs.is_empty() && nmod.items.is_empty();\n                 self.bclose(item.span, empty);\n             }\n-            ast::ItemKind::GlobalAsm(ref asm) => {\n+            ast::ItemKind::GlobalAsm(asm) => {\n                 self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n                 self.print_inline_asm(asm);\n                 self.word(\";\");\n@@ -224,32 +230,31 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::TyAlias(box ast::TyAlias {\n                 defaultness,\n-                ref generics,\n+                generics,\n                 where_clauses,\n                 where_predicates_split,\n-                ref bounds,\n-                ref ty,\n+                bounds,\n+                ty,\n             }) => {\n-                let ty = ty.as_deref();\n                 self.print_associated_type(\n                     item.ident,\n                     generics,\n-                    where_clauses,\n-                    where_predicates_split,\n+                    *where_clauses,\n+                    *where_predicates_split,\n                     bounds,\n-                    ty,\n+                    ty.as_deref(),\n                     &item.vis,\n-                    defaultness,\n+                    *defaultness,\n                 );\n             }\n-            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n+            ast::ItemKind::Enum(enum_definition, params) => {\n                 self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n             }\n-            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n+            ast::ItemKind::Struct(struct_def, generics) => {\n                 self.head(visibility_qualified(&item.vis, \"struct\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n-            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+            ast::ItemKind::Union(struct_def, generics) => {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n@@ -258,15 +263,15 @@ impl<'a> State<'a> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                ref items,\n+                generics,\n+                of_trait,\n+                self_ty,\n+                items,\n             }) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n+                self.print_defaultness(*defaultness);\n+                self.print_unsafety(*unsafety);\n                 self.word(\"impl\");\n \n                 if generics.params.is_empty() {\n@@ -276,13 +281,13 @@ impl<'a> State<'a> {\n                     self.space();\n                 }\n \n-                self.print_constness(constness);\n+                self.print_constness(*constness);\n \n                 if let ast::ImplPolarity::Negative(_) = polarity {\n                     self.word(\"!\");\n                 }\n \n-                if let Some(ref t) = *of_trait {\n+                if let Some(t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.space();\n                     self.word_space(\"for\");\n@@ -303,21 +308,21 @@ impl<'a> State<'a> {\n             ast::ItemKind::Trait(box ast::Trait {\n                 is_auto,\n                 unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n+                generics,\n+                bounds,\n+                items,\n                 ..\n             }) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n-                self.print_unsafety(unsafety);\n-                self.print_is_auto(is_auto);\n+                self.print_unsafety(*unsafety);\n+                self.print_is_auto(*is_auto);\n                 self.word_nbsp(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -339,14 +344,14 @@ impl<'a> State<'a> {\n                 let empty = item.attrs.is_empty() && items.is_empty();\n                 self.bclose(item.span, empty);\n             }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ast::ItemKind::TraitAlias(generics, bounds) => {\n                 self.head(visibility_qualified(&item.vis, \"trait\"));\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -364,13 +369,13 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::MacCall(ref mac) => {\n+            ast::ItemKind::MacCall(mac) => {\n                 self.print_mac(mac);\n                 if mac.args.need_semicolon() {\n                     self.word(\";\");\n                 }\n             }\n-            ast::ItemKind::MacroDef(ref macro_def) => {\n+            ast::ItemKind::MacroDef(macro_def) => {\n                 self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n                     state.print_visibility(&item.vis)\n                 });\n@@ -412,11 +417,11 @@ impl<'a> State<'a> {\n     }\n \n     pub(crate) fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.kind {\n+        match &vis.kind {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            ast::VisibilityKind::Restricted { ref path, id: _, shorthand } => {\n+            ast::VisibilityKind::Restricted { path, shorthand, .. } => {\n                 let path = Self::to_string(|s| s.print_path(path, false, 0));\n-                if shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n+                if *shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n                     self.word_nbsp(format!(\"pub(in {})\", path))\n@@ -465,7 +470,7 @@ impl<'a> State<'a> {\n     ) {\n         self.print_ident(ident);\n         self.print_generic_params(&generics.params);\n-        match struct_def {\n+        match &struct_def {\n             ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n                 if let ast::VariantData::Tuple(..) = struct_def {\n                     self.popen();\n@@ -484,7 +489,7 @@ impl<'a> State<'a> {\n                 self.end();\n                 self.end(); // Close the outer-box.\n             }\n-            ast::VariantData::Struct(ref fields, ..) => {\n+            ast::VariantData::Struct(fields, ..) => {\n                 self.print_where_clause(&generics.where_clause);\n                 self.print_record_struct_body(fields, span);\n             }\n@@ -496,7 +501,7 @@ impl<'a> State<'a> {\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        if let Some(ref d) = v.disr_expr {\n+        if let Some(d) = &v.disr_expr {\n             self.space();\n             self.word_space(\"=\");\n             self.print_expr(&d.value)\n@@ -657,10 +662,10 @@ impl<'a> State<'a> {\n     }\n \n     fn print_use_tree(&mut self, tree: &ast::UseTree) {\n-        match tree.kind {\n+        match &tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 self.print_path(&tree.prefix, false, 0);\n-                if let Some(rename) = rename {\n+                if let &Some(rename) = rename {\n                     self.nbsp();\n                     self.word_nbsp(\"as\");\n                     self.print_ident(rename);\n@@ -673,7 +678,7 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"*\");\n             }\n-            ast::UseTreeKind::Nested(ref items) => {\n+            ast::UseTreeKind::Nested(items) => {\n                 if !tree.prefix.segments.is_empty() {\n                     self.print_path(&tree.prefix, false, 0);\n                     self.word(\"::\");"}]}