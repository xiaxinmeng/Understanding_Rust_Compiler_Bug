{"sha": "9e250109f9d40deefbca1a42f602d3f0b59ca1e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMjUwMTA5ZjlkNDBkZWVmYmNhMWE0MmY2MDJkM2YwYjU5Y2ExZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-29T02:41:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-29T02:41:41Z"}, "message": "auto merge of #16032 : treeman/rust/doc-treecollection, r=alexcrichton", "tree": {"sha": "01638a36963e12e21c49c5dcce289c4b41911227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01638a36963e12e21c49c5dcce289c4b41911227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e250109f9d40deefbca1a42f602d3f0b59ca1e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e250109f9d40deefbca1a42f602d3f0b59ca1e6", "html_url": "https://github.com/rust-lang/rust/commit/9e250109f9d40deefbca1a42f602d3f0b59ca1e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e250109f9d40deefbca1a42f602d3f0b59ca1e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2bd9986072a010cd68a7f0a814ad99038050983", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bd9986072a010cd68a7f0a814ad99038050983", "html_url": "https://github.com/rust-lang/rust/commit/b2bd9986072a010cd68a7f0a814ad99038050983"}, {"sha": "58d3f109f87eb95998d2b5293a5981c1c5cfa4ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d3f109f87eb95998d2b5293a5981c1c5cfa4ce", "html_url": "https://github.com/rust-lang/rust/commit/58d3f109f87eb95998d2b5293a5981c1c5cfa4ce"}], "stats": {"total": 559, "additions": 528, "deletions": 31}, "files": [{"sha": "5de23b42f5c7d77c4f35e4f9497a18ce9cfe8bda", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 528, "deletions": 31, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/9e250109f9d40deefbca1a42f602d3f0b59ca1e6/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e250109f9d40deefbca1a42f602d3f0b59ca1e6/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=9e250109f9d40deefbca1a42f602d3f0b59ca1e6", "patch": "@@ -43,10 +43,111 @@ use std::hash::{Writer, Hash};\n use {Collection, Mutable, Set, MutableSet, MutableMap, Map, MutableSeq};\n use vec::Vec;\n \n-// This is implemented as an AA tree, which is a simplified variation of\n-// a red-black tree where red (horizontal) nodes can only be added\n-// as a right child. The time complexity is the same, and re-balancing\n-// operations are more frequent but also cheaper.\n+/// This is implemented as an AA tree, which is a simplified variation of\n+/// a red-black tree where red (horizontal) nodes can only be added\n+/// as a right child. The time complexity is the same, and re-balancing\n+/// operations are more frequent but also cheaper.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::TreeMap;\n+///\n+/// let mut map = TreeMap::new();\n+///\n+/// map.insert(2i, \"bar\");\n+/// map.insert(1i, \"foo\");\n+/// map.insert(3i, \"quux\");\n+///\n+/// // In ascending order by keys\n+/// for (key, value) in map.iter() {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// // Prints 1, 2, 3\n+/// for key in map.keys() {\n+///     println!(\"{}\", key);\n+/// }\n+///\n+/// // Prints `foo`, `bar`, `quux`\n+/// for key in map.values() {\n+///     println!(\"{}\", key);\n+/// }\n+///\n+/// map.remove(&1);\n+/// assert_eq!(map.len(), 2);\n+///\n+/// if !map.contains_key(&1) {\n+///     println!(\"1 is no more\");\n+/// }\n+///\n+/// for key in range(0, 4) {\n+///     match map.find(&key) {\n+///         Some(val) => println!(\"{} has a value: {}\", key, val),\n+///         None => println!(\"{} not in map\", key),\n+///     }\n+/// }\n+///\n+/// map.clear();\n+/// assert!(map.is_empty());\n+/// ```\n+///\n+/// The easiest way to use `TreeMap` with a custom type as keys is to implement `Ord`.\n+/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n+///\n+/// ```\n+/// use std::collections::TreeMap;\n+///\n+/// // We need `Eq` and `PartialEq`, these can be derived.\n+/// #[deriving(Eq, PartialEq)]\n+/// struct Troll<'a> {\n+///     name: &'a str,\n+///     level: uint,\n+/// }\n+///\n+/// // Implement `Ord` and sort trolls by level.\n+/// impl<'a> Ord for Troll<'a> {\n+///     fn cmp(&self, other: &Troll) -> Ordering {\n+///         // If we swap `self` and `other`, we get descending ordering.\n+///         self.level.cmp(&other.level)\n+///     }\n+/// }\n+///\n+/// // `PartialOrd` needs to be implemented as well.\n+/// impl<'a> PartialOrd for Troll<'a> {\n+///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// // Use a map to store trolls, sorted by level, and track a list of\n+/// // heroes slain.\n+/// let mut trolls = TreeMap::new();\n+///\n+/// trolls.insert(Troll { name: \"Orgarr\", level: 2 },\n+///               vec![\"King Karl\"]);\n+/// trolls.insert(Troll { name: \"Blargarr\", level: 3 },\n+///               vec![\"Odd\"]);\n+/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 },\n+///               vec![\"Omar the Brave\", \"Peter: Slayer of Trolls\"]);\n+/// trolls.insert(Troll { name: \"Wartilda\", level: 1 },\n+///               vec![]);\n+///\n+/// println!(\"You are facing {} trolls!\", trolls.len());\n+///\n+/// // Print the trolls, ordered by level with smallest level first\n+/// for (troll, heroes) in trolls.iter() {\n+///     let what = if heroes.len() == 1u { \"hero\" }\n+///                else { \"heroes\" };\n+///\n+///     println!(\"level {}: '{}' has slain {} {}\",\n+///              troll.level, troll.name, heroes.len(), what);\n+/// }\n+///\n+/// // Kill all trolls\n+/// trolls.clear();\n+/// assert_eq!(trolls.len(), 0);\n+/// ```\n \n // Future improvements:\n \n@@ -59,7 +160,6 @@ use vec::Vec;\n //   * union: |\n // These would be convenient since the methods work like `each`\n \n-#[allow(missing_doc)]\n #[deriving(Clone)]\n pub struct TreeMap<K, V> {\n     root: Option<Box<TreeNode<K, V>>>,\n@@ -138,21 +238,73 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n }\n \n impl<K: Ord, V> TreeMap<K, V> {\n-    /// Create an empty TreeMap\n+    /// Create an empty `TreeMap`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map: TreeMap<&str, int> = TreeMap::new();\n+    /// ```\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Get a lazy iterator over the keys in the map.\n+    /// Get a lazy iterator over the keys in the map, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print \"a\", \"b\", \"c\" in order.\n+    /// for x in map.keys() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n-    /// Get a lazy iterator over the values in the map.\n+    /// Get a lazy iterator over the values in the map, in ascending order\n+    /// with respect to the corresponding keys.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print 1, 2, 3 ordered by keys.\n+    /// for x in map.values() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n-    /// Get a lazy iterator over the key-value pairs in the map.\n-    /// Requires that it be frozen (immutable).\n+    /// Get a lazy iterator over the key-value pairs in the map, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print contents in ascending order\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n             stack: vec!(),\n@@ -162,14 +314,48 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Get a lazy reverse iterator over the key-value pairs in the map.\n-    /// Requires that it be frozen (immutable).\n+    /// Get a lazy reverse iterator over the key-value pairs in the map, in descending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print contents in descending order\n+    /// for (key, value) in map.rev_iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn rev_iter<'a>(&'a self) -> RevEntries<'a, K, V> {\n         RevEntries{iter: self.iter()}\n     }\n \n     /// Get a lazy forward iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Add 10 until we find \"b\"\n+    /// for (key, value) in map.mut_iter() {\n+    ///     *value += 10;\n+    ///     if key == &\"b\" { break }\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&\"a\"), Some(&11));\n+    /// assert_eq!(map.find(&\"b\"), Some(&12));\n+    /// assert_eq!(map.find(&\"c\"), Some(&3));\n+    /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n             stack: vec!(),\n@@ -180,12 +366,47 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n     /// Get a lazy reverse iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Add 10 until we find \"b\"\n+    /// for (key, value) in map.mut_rev_iter() {\n+    ///     *value += 10;\n+    ///     if key == &\"b\" { break }\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&\"a\"), Some(&1));\n+    /// assert_eq!(map.find(&\"b\"), Some(&12));\n+    /// assert_eq!(map.find(&\"c\"), Some(&13));\n+    /// ```\n     pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n         RevMutEntries{iter: self.mut_iter()}\n     }\n \n \n-    /// Get a lazy iterator that consumes the treemap.\n+    /// Get a lazy iterator that consumes the treemap, it is not usable\n+    /// after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Not possible with a regular `.iter()`\n+    /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n+    /// assert_eq!(vec, vec![(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n+    /// ```\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n         let TreeMap { root: root, length: length } = self;\n         let stk = match root {\n@@ -232,6 +453,7 @@ impl<K, V> TreeMap<K, V> {\n     /// Return the value for which `f(key)` returns `Equal`. `f` is invoked\n     /// with current key and guides tree navigation. That means `f` should\n     /// be aware of natural ordering of the tree.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -301,12 +523,44 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.lower_bound(&4).next(), Some((&4, &\"b\")));\n+    /// assert_eq!(map.lower_bound(&5).next(), Some((&6, &\"c\")));\n+    /// assert_eq!(map.lower_bound(&10).next(), None);\n+    /// ```\n     pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n         bound_setup!(self.iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n-    /// If all keys in map are not greater than `k` an empty iterator is returned.\n+    /// If all keys in map are less than or equal to `k` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.upper_bound(&4).next(), Some((&6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(&5).next(), Some((&6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(&10).next(), None);\n+    /// ```\n     pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n         bound_setup!(self.iter_for_traversal(), k, false)\n     }\n@@ -327,15 +581,65 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// If all keys in map are less than `k` an empty iterator is\n     /// returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.mut_lower_bound(&4).next(), Some((&4, &mut \"b\")));\n+    /// assert_eq!(map.mut_lower_bound(&5).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.mut_lower_bound(&10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_lower_bound(&4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair (with the\n     /// value being mutable) whose key is greater than `k`.\n     ///\n-    /// If all keys in map are not greater than `k` an empty iterator\n+    /// If all keys in map are less than or equal to `k` an empty iterator\n     /// is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.mut_upper_bound(&4).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(&5).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(&10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_upper_bound(&4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"b\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), k, false)\n     }\n@@ -633,15 +937,68 @@ impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n /// ```{rust}\n /// use std::collections::TreeSet;\n ///\n-/// let mut tree_set = TreeSet::new();\n+/// let mut set = TreeSet::new();\n ///\n-/// tree_set.insert(2i);\n-/// tree_set.insert(1i);\n-/// tree_set.insert(3i);\n+/// set.insert(2i);\n+/// set.insert(1i);\n+/// set.insert(3i);\n ///\n-/// for i in tree_set.iter() {\n+/// for i in set.iter() {\n ///    println!(\"{}\", i) // prints 1, then 2, then 3\n /// }\n+///\n+/// set.remove(&3);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"set does not contain a 3 anymore\");\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n+/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n+///\n+/// ```\n+/// use std::collections::TreeSet;\n+///\n+/// // We need `Eq` and `PartialEq`, these can be derived.\n+/// #[deriving(Eq, PartialEq)]\n+/// struct Troll<'a> {\n+///     name: &'a str,\n+///     level: uint,\n+/// }\n+///\n+/// // Implement `Ord` and sort trolls by level.\n+/// impl<'a> Ord for Troll<'a> {\n+///     fn cmp(&self, other: &Troll) -> Ordering {\n+///         // If we swap `self` and `other`, we get descending ordering.\n+///         self.level.cmp(&other.level)\n+///     }\n+/// }\n+///\n+/// // `PartialOrd` needs to be implemented as well.\n+/// impl<'a> PartialOrd for Troll<'a> {\n+///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// let mut trolls = TreeSet::new();\n+///\n+/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n+/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n+/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n+/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n+///\n+/// println!(\"You are facing {} trolls!\", trolls.len());\n+///\n+/// // Print the trolls, ordered by level with smallest level first\n+/// for x in trolls.iter() {\n+///     println!(\"level {}: {}!\", x.level, x.name);\n+/// }\n+///\n+/// // Kill all trolls\n+/// trolls.clear();\n+/// assert_eq!(trolls.len(), 0);\n /// ```\n #[deriving(Clone)]\n pub struct TreeSet<T> {\n@@ -732,62 +1089,202 @@ impl<T: Ord> Default for TreeSet<T> {\n }\n \n impl<T: Ord> TreeSet<T> {\n-    /// Create an empty TreeSet\n+    /// Create an empty `TreeSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n+    /// Get a lazy iterator over the values in the set, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in ascending order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         SetItems{iter: self.map.iter()}\n     }\n \n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n+    /// Get a lazy iterator over the values in the set, in descending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in descending order.\n+    /// for x in set.rev_iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n         RevSetItems{iter: self.map.rev_iter()}\n     }\n \n-    /// Get a lazy iterator that consumes the set.\n+    /// Creates a consuming iterator, that is, one that moves each value out of the\n+    /// set in ascending order. The set cannot be used after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Not possible with a regular `.iter()`\n+    /// let v: Vec<int> = set.move_iter().collect();\n+    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+    /// ```\n     #[inline]\n     pub fn move_iter(self) -> MoveSetItems<T> {\n         self.map.move_iter().map(|(value, _)| value)\n     }\n \n     /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n+    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.lower_bound(&10).next(), None);\n+    /// ```\n     #[inline]\n     pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n         SetItems{iter: self.map.lower_bound(v)}\n     }\n \n     /// Get a lazy iterator pointing to the first value greater than `v`.\n-    /// If all elements in the set are not greater than `v` empty iterator is returned.\n+    /// If all elements in the set are less than or equal to `v` an\n+    /// empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&10).next(), None);\n+    /// ```\n     #[inline]\n     pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n         SetItems{iter: self.map.upper_bound(v)}\n     }\n \n-    /// Visit the values (in-order) representing the difference\n+    /// Visit the values representing the difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1 then 2\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values (in-order) representing the symmetric difference\n+    /// Visit the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 4, 5 in ascending order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n         -> SymDifferenceItems<'a, T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values (in-order) representing the intersection\n+    /// Visit the values representing the intersection, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in ascending order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n         -> IntersectionItems<'a, T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values (in-order) representing the union\n+    /// Visit the values representing the union, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4, 5 in ascending order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }"}]}