{"sha": "79dc862d4a8c0690fbc50d7ebd129fab2e199a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZGM4NjJkNGE4YzA2OTBmYmM1MGQ3ZWJkMTI5ZmFiMmUxOTlhNDk=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-09-30T16:09:10Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-10-02T13:53:22Z"}, "message": "Use PlaceBuilder to avoid a lot of slice -> vec -> slice convertions", "tree": {"sha": "bb77f7893f1288488a0c7dfc2b6b2cff951bd458", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb77f7893f1288488a0c7dfc2b6b2cff951bd458"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79dc862d4a8c0690fbc50d7ebd129fab2e199a49", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAl2Uq9MACgkQiMlBzaHU\nZDJPEA/6Az+2wYF/F6YwDdaoG2mrqjr+5aBUITZjA5ibwkVUDfqblS2P6UPb4IY3\nPGd7y2q/6dP4SxgwoJaUCQTdPUs8KztbKF1qH/F0K7t3EXr5k3FifFAOE0EGQiAu\n7XK1dVP6zth/yyWXn/uF47XDTDfVQjThPoTHcbmoOyGV+HhkY0rPSkVIyXGaipqy\nzwZLw2UUjGGG3QjEvUjw4ygzC/C661a+B+qL7DiYiGtTb3H+XfVXMRIqs+NhpntL\nsr0tWtVr5cq6ppsVjXD9+tVR5T/9Tp2YlMpZNX8oYFxKzpCeXb+ADI4kckuOWUhk\na0hQgzjsI5UheLImMSLxun1wSuA2+jKwjuq6aOPE3bUreOpJfpGxukezfk80bQYS\neUQKnLB+VYOsbdT+T1PmrZ2O/p+VmSdmBhSWhR6Qu395M0aEBysevyvVLB4B9L6L\nhJu7PKXOQ2+DUgcj4nZTyubuQkt4P7gLn6fYKH/6gNK2Z8XCY2FK13iL9glDR0qP\nv0lBxBB18urLwxAmUVAw3HsTrmgtHK9BBm9Kg+stBSRacQNjz8m1iyGN42JZyu1V\nGPNMuyzZQ9X+hPPAmOfBY5pRRVHFXonBmfnUo/2TsU+355q1Wd5FcxpuFZNfdXE+\n7mBjy7eFsdmkrDZN3KlS9HO3njI04Dp7eGkxkdGT/PIBZA4B1fM=\n=jfv6\n-----END PGP SIGNATURE-----", "payload": "tree bb77f7893f1288488a0c7dfc2b6b2cff951bd458\nparent bf8491e72ef0d5ea0ef683e9d149408a717545e4\nauthor Santiago Pastorino <spastorino@gmail.com> 1569859750 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1570024402 -0300\n\nUse PlaceBuilder to avoid a lot of slice -> vec -> slice convertions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79dc862d4a8c0690fbc50d7ebd129fab2e199a49", "html_url": "https://github.com/rust-lang/rust/commit/79dc862d4a8c0690fbc50d7ebd129fab2e199a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79dc862d4a8c0690fbc50d7ebd129fab2e199a49/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf8491e72ef0d5ea0ef683e9d149408a717545e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8491e72ef0d5ea0ef683e9d149408a717545e4", "html_url": "https://github.com/rust-lang/rust/commit/bf8491e72ef0d5ea0ef683e9d149408a717545e4"}], "stats": {"total": 144, "additions": 114, "deletions": 30}, "files": [{"sha": "ecbf4699015824c58f4e20df783e0789dc5d4af1", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 114, "deletions": 30, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/79dc862d4a8c0690fbc50d7ebd129fab2e199a49/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79dc862d4a8c0690fbc50d7ebd129fab2e199a49/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=79dc862d4a8c0690fbc50d7ebd129fab2e199a49", "patch": "@@ -6,13 +6,79 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Variance};\n+use rustc::ty::{CanonicalUserTypeAnnotation, Ty, Variance};\n \n use rustc_data_structures::indexed_vec::Idx;\n \n+/// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n+/// place by pushing more and more projections onto the end, and then convert the final set into a\n+/// place using the `into_place` method.\n+///\n+/// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n+/// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n+#[derive(Clone)]\n+struct PlaceBuilder<'tcx> {\n+    base: PlaceBase<'tcx>,\n+    projection: Vec<PlaceElem<'tcx>>,\n+}\n+\n+impl PlaceBuilder<'tcx> {\n+    fn into_place(self) -> Place<'tcx> {\n+        Place {\n+            base: self.base,\n+            projection: self.projection.into_boxed_slice(),\n+        }\n+    }\n+\n+    fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n+        self.project(PlaceElem::Field(f, ty))\n+    }\n+\n+    fn deref(self) -> Self {\n+        self.project(PlaceElem::Deref)\n+    }\n+\n+    fn index(self, index: Local) -> Self {\n+        self.project(PlaceElem::Index(index))\n+    }\n+\n+    fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n+        self.projection.push(elem);\n+        self\n+    }\n+}\n+\n+impl From<Local> for PlaceBuilder<'tcx> {\n+    fn from(local: Local) -> Self {\n+        Self {\n+            base: local.into(),\n+            projection: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n+    fn from(base: PlaceBase<'tcx>) -> Self {\n+        Self {\n+            base,\n+            projection: Vec::new(),\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n-    pub fn as_place<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    pub fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    where\n+        M: Mirror<'tcx, Output = Expr<'tcx>>,\n+    {\n+        let place_builder = unpack!(block = self.as_place_builder(block, expr));\n+        block.and(place_builder.into_place())\n+    }\n+\n+    /// This is used when constructing a compound `Place`, so that we can avoid creating\n+    /// intermediate `Place` values until we know the full set of projections.\n+    fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -25,7 +91,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    pub fn as_read_only_place<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    pub fn as_read_only_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    where\n+        M: Mirror<'tcx, Output = Expr<'tcx>>,\n+    {\n+        let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n+        block.and(place_builder.into_place())\n+    }\n+\n+    /// This is used when constructing a compound `Place`, so that we can avoid creating\n+    /// intermediate `Place` values until we know the full set of projections.\n+    /// Mutability note: The caller of this method promises only to read from the resulting\n+    /// place. The place itself may or may not be mutable:\n+    /// * If this expr is a place expr like a.b, then we will return that place.\n+    /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n+    fn as_read_only_place_builder<M>(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: M,\n+    ) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -38,7 +122,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n         mutability: Mutability,\n-    ) -> BlockAnd<Place<'tcx>> {\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         debug!(\n             \"expr_as_place(block={:?}, expr={:?}, mutability={:?})\",\n             block, expr, mutability\n@@ -54,25 +138,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 value,\n             } => this.in_scope((region_scope, source_info), lint_level, |this| {\n                 if mutability == Mutability::Not {\n-                    this.as_read_only_place(block, value)\n+                    this.as_read_only_place_builder(block, value)\n                 } else {\n-                    this.as_place(block, value)\n+                    this.as_place_builder(block, value)\n                 }\n             }),\n             ExprKind::Field { lhs, name } => {\n-                let place = unpack!(block = this.as_place(block, lhs));\n-                let place = place.field(name, expr.ty);\n-                block.and(place)\n+                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n+                block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place = unpack!(block = this.as_place(block, arg));\n-                let place = place.deref();\n-                block.and(place)\n+                let place_builder = unpack!(block = this.as_place_builder(block, arg));\n+                block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => {\n                 let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n \n-                let slice = unpack!(block = this.as_place(block, lhs));\n+                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n                 // Making this a *fresh* temporary also means we do not have to worry about\n                 // the index changing later: Nothing will ever change this temporary.\n                 // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n@@ -83,6 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Mutability::Not,\n                 ));\n \n+                let slice = place_builder.clone().into_place();\n                 // bounds check:\n                 let (len, lt) = (\n                     this.temp(usize_ty.clone(), expr_span),\n@@ -92,7 +175,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     block,\n                     source_info, // len = len(slice)\n                     &len,\n-                    Rvalue::Len(slice.clone()),\n+                    Rvalue::Len(slice),\n                 );\n                 this.cfg.push_assign(\n                     block,\n@@ -110,30 +193,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     index: Operand::Copy(Place::from(idx)),\n                 };\n                 let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n-                success.and(slice.index(idx))\n+                success.and(place_builder.index(idx))\n             }\n-            ExprKind::SelfRef => block.and(Place::from(Local::new(1))),\n+            ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n-                let place = if this.is_bound_var_in_guard(id) {\n+                let place_builder = if this.is_bound_var_in_guard(id) {\n                     let index = this.var_local_id(id, RefWithinGuard);\n-                    Place::from(index).deref()\n+                    PlaceBuilder::from(index).deref()\n                 } else {\n                     let index = this.var_local_id(id, OutsideGuard);\n-                    Place::from(index)\n+                    PlaceBuilder::from(index)\n                 };\n-                block.and(place)\n+                block.and(place_builder)\n             }\n-            ExprKind::StaticRef { id } => block.and(Place {\n-                base: PlaceBase::Static(Box::new(Static {\n+            ExprKind::StaticRef { id } => block.and(PlaceBuilder::from(\n+                PlaceBase::Static(Box::new(Static {\n                     ty: expr.ty,\n                     kind: StaticKind::Static,\n                     def_id: id,\n-                })),\n-                projection: box [],\n-            }),\n+                }))\n+            )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let place = unpack!(block = this.as_place(block, source));\n+                let place_builder = unpack!(block = this.as_place_builder(block, source));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n                         CanonicalUserTypeAnnotation {\n@@ -142,21 +224,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         }\n                     );\n+\n+                    let place = place_builder.clone().into_place();\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 box(\n-                                    place.clone(),\n+                                    place,\n                                     UserTypeProjection { base: annotation_index, projs: vec![], }\n                                 ),\n                                 Variance::Invariant,\n                             ),\n                         },\n                     );\n                 }\n-                block.and(place)\n+                block.and(place_builder)\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n                 let source = this.hir.mirror(source);\n@@ -185,7 +269,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         },\n                     );\n                 }\n-                block.and(Place::from(temp))\n+                block.and(PlaceBuilder::from(temp))\n             }\n \n             ExprKind::Array { .. }\n@@ -221,7 +305,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n                 let temp =\n                     unpack!(block = this.as_temp(block, expr.temp_lifetime, expr, mutability));\n-                block.and(Place::from(temp))\n+                block.and(PlaceBuilder::from(temp))\n             }\n         }\n     }"}]}