{"sha": "2d1f0b105d7995088fdf7a90e5e594b5555699c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMWYwYjEwNWQ3OTk1MDg4ZmRmN2E5MGU1ZTU5NGI1NTU1Njk5YzY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T18:29:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "move test", "tree": {"sha": "2c70b7671381c0ec42190303bbf6865a638ed39c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c70b7671381c0ec42190303bbf6865a638ed39c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d1f0b105d7995088fdf7a90e5e594b5555699c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1f0b105d7995088fdf7a90e5e594b5555699c6", "html_url": "https://github.com/rust-lang/rust/commit/2d1f0b105d7995088fdf7a90e5e594b5555699c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d1f0b105d7995088fdf7a90e5e594b5555699c6/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40feacdeb90786b49ea9e0510ba22ff7af79e020", "url": "https://api.github.com/repos/rust-lang/rust/commits/40feacdeb90786b49ea9e0510ba22ff7af79e020", "html_url": "https://github.com/rust-lang/rust/commit/40feacdeb90786b49ea9e0510ba22ff7af79e020"}], "stats": {"total": 249, "additions": 129, "deletions": 120}, "files": [{"sha": "49a9da624b2df41a079fc1491e125b49e435e695", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -1023,9 +1023,9 @@ dependencies = [\n name = \"ra_mbe\"\n version = \"0.1.0\"\n dependencies = [\n+ \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smol_str 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1058,7 +1058,6 @@ dependencies = [\n name = \"ra_tt\"\n version = \"0.1.0\"\n dependencies = [\n- \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "7ca34d434511d670a5ae22bb38943ca3d6a4a842", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -11,7 +11,6 @@ use std::sync::Arc;\n \n use ra_syntax::{\n     TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreeArc, SyntaxNodePtr,\n-    SyntaxKind::*,\n     ast::{self, NameOwner},\n };\n \n@@ -196,116 +195,3 @@ pub(crate) fn expand_macro_invocation(\n     let (def, input) = MacroDef::from_call(macro_call)?;\n     def.expand(input).map(Arc::new)\n }\n-\n-fn macro_call_to_tt(call: &ast::MacroCall) -> Option<tt::Subtree> {\n-    let tt = call.token_tree()?;\n-    convert_tt(tt.syntax())\n-}\n-\n-fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n-    let first_child = tt.first_child()?;\n-    let last_child = tt.last_child()?;\n-    let delimiter = match (first_child.kind(), last_child.kind()) {\n-        (L_PAREN, R_PAREN) => tt::Delimiter::Parenthesis,\n-        (L_CURLY, R_CURLY) => tt::Delimiter::Brace,\n-        (L_BRACK, R_BRACK) => tt::Delimiter::Bracket,\n-        _ => return None,\n-    };\n-    let mut token_trees = Vec::new();\n-    for child in tt.children().skip(1) {\n-        if child == first_child || child == last_child || child.kind().is_trivia() {\n-            continue;\n-        }\n-        if child.kind().is_punct() {\n-            let mut prev = None;\n-            for char in child.leaf_text().unwrap().chars() {\n-                if let Some(char) = prev {\n-                    token_trees.push(\n-                        tt::Leaf::from(tt::Punct {\n-                            char,\n-                            spacing: tt::Spacing::Joint,\n-                        })\n-                        .into(),\n-                    );\n-                }\n-                prev = Some(char)\n-            }\n-            if let Some(char) = prev {\n-                token_trees.push(\n-                    tt::Leaf::from(tt::Punct {\n-                        char,\n-                        spacing: tt::Spacing::Alone,\n-                    })\n-                    .into(),\n-                );\n-            }\n-        } else {\n-            let child: tt::TokenTree = if child.kind() == TOKEN_TREE {\n-                convert_tt(child)?.into()\n-            } else if child.kind().is_keyword() || child.kind() == IDENT {\n-                let text = child.leaf_text().unwrap().clone();\n-                tt::Leaf::from(tt::Ident { text }).into()\n-            } else if child.kind().is_literal() {\n-                tt::Leaf::from(tt::Literal {\n-                    text: child.leaf_text().unwrap().clone(),\n-                })\n-                .into()\n-            } else {\n-                log::error!(\"unknown kind: {:?}\", child);\n-                return None;\n-            };\n-            token_trees.push(child)\n-        }\n-    }\n-\n-    let res = tt::Subtree {\n-        delimiter,\n-        token_trees,\n-    };\n-    Some(res)\n-}\n-\n-#[test]\n-fn test_convert_tt() {\n-    let macro_definition = r#\"\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\"#;\n-\n-    let macro_invocation = r#\"\n-impl_froms!(TokenTree: Leaf, Subtree);\n-\"#;\n-\n-    let source_file = ast::SourceFile::parse(macro_definition);\n-    let macro_definition = source_file\n-        .syntax()\n-        .descendants()\n-        .find_map(ast::MacroCall::cast)\n-        .unwrap();\n-\n-    let source_file = ast::SourceFile::parse(macro_invocation);\n-    let macro_invocation = source_file\n-        .syntax()\n-        .descendants()\n-        .find_map(ast::MacroCall::cast)\n-        .unwrap();\n-\n-    let definition_tt = macro_call_to_tt(macro_definition).unwrap();\n-    let invocation_tt = macro_call_to_tt(macro_invocation).unwrap();\n-    let mbe = mbe::parse(&definition_tt).unwrap();\n-    let expansion = mbe::exapnd(&mbe, &invocation_tt).unwrap();\n-    assert_eq!(\n-        expansion.to_string(),\n-        \"{(impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}}) \\\n-          (impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}})}\"\n-    )\n-}"}, {"sha": "68dc85eb97c023f0ab4ddeaf6dd6eadb1b7ba1ca", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -5,6 +5,7 @@ version = \"0.1.0\"\n authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n+ra_syntax = { path = \"../ra_syntax\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+\n rustc-hash = \"1.0.0\"\n-smol_str = \"0.1.9\""}, {"sha": "c7be33b19910a6404c763cea99fa0927702f24b5", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -1,3 +1,8 @@\n+/// `mbe` (short for Macro By Example) crate contains code for handling\n+/// `macro_rules` macros. It uses `TokenTree` (from `ra_tt` package) as the\n+/// interface, although it contains some code to bridge `SyntaxNode`s and\n+/// `TokenTree`s as well!\n+\n macro_rules! impl_froms {\n     ($e:ident: $($v:ident), *) => {\n         $(\n@@ -13,14 +18,16 @@ macro_rules! impl_froms {\n mod tt_cursor;\n mod mbe_parser;\n mod mbe_expander;\n+mod syntax_bridge;\n \n-use smol_str::SmolStr;\n+use ra_syntax::SmolStr;\n \n pub use tt::{Delimiter, Punct};\n \n pub use crate::{\n     mbe_parser::parse,\n     mbe_expander::exapnd,\n+    syntax_bridge::macro_call_to_tt,\n };\n \n #[derive(Debug)]"}, {"sha": "21c1552cebcd0d5da7ca2762c27ffd0c9d6ccc78", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -1,5 +1,5 @@\n use rustc_hash::FxHashMap;\n-use smol_str::SmolStr;\n+use ra_syntax::SmolStr;\n \n use crate::{self as mbe, tt_cursor::TtCursor};\n "}, {"sha": "aad5f24b7d051c19179f8f188a50bfaa5397aea4", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -0,0 +1,113 @@\n+use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxKind::*};\n+\n+pub fn macro_call_to_tt(call: &ast::MacroCall) -> Option<tt::Subtree> {\n+    let tt = call.token_tree()?;\n+    convert_tt(tt.syntax())\n+}\n+\n+fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n+    let first_child = tt.first_child()?;\n+    let last_child = tt.last_child()?;\n+    let delimiter = match (first_child.kind(), last_child.kind()) {\n+        (L_PAREN, R_PAREN) => tt::Delimiter::Parenthesis,\n+        (L_CURLY, R_CURLY) => tt::Delimiter::Brace,\n+        (L_BRACK, R_BRACK) => tt::Delimiter::Bracket,\n+        _ => return None,\n+    };\n+    let mut token_trees = Vec::new();\n+    for child in tt.children().skip(1) {\n+        if child == first_child || child == last_child || child.kind().is_trivia() {\n+            continue;\n+        }\n+        if child.kind().is_punct() {\n+            let mut prev = None;\n+            for char in child.leaf_text().unwrap().chars() {\n+                if let Some(char) = prev {\n+                    token_trees.push(\n+                        tt::Leaf::from(tt::Punct {\n+                            char,\n+                            spacing: tt::Spacing::Joint,\n+                        })\n+                        .into(),\n+                    );\n+                }\n+                prev = Some(char)\n+            }\n+            if let Some(char) = prev {\n+                token_trees.push(\n+                    tt::Leaf::from(tt::Punct {\n+                        char,\n+                        spacing: tt::Spacing::Alone,\n+                    })\n+                    .into(),\n+                );\n+            }\n+        } else {\n+            let child: tt::TokenTree = if child.kind() == TOKEN_TREE {\n+                convert_tt(child)?.into()\n+            } else if child.kind().is_keyword() || child.kind() == IDENT {\n+                let text = child.leaf_text().unwrap().clone();\n+                tt::Leaf::from(tt::Ident { text }).into()\n+            } else if child.kind().is_literal() {\n+                tt::Leaf::from(tt::Literal {\n+                    text: child.leaf_text().unwrap().clone(),\n+                })\n+                .into()\n+            } else {\n+                return None;\n+            };\n+            token_trees.push(child)\n+        }\n+    }\n+\n+    let res = tt::Subtree {\n+        delimiter,\n+        token_trees,\n+    };\n+    Some(res)\n+}\n+\n+#[test]\n+fn test_convert_tt() {\n+    let macro_definition = r#\"\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\"#;\n+\n+    let macro_invocation = r#\"\n+impl_froms!(TokenTree: Leaf, Subtree);\n+\"#;\n+\n+    let source_file = ast::SourceFile::parse(macro_definition);\n+    let macro_definition = source_file\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::MacroCall::cast)\n+        .unwrap();\n+\n+    let source_file = ast::SourceFile::parse(macro_invocation);\n+    let macro_invocation = source_file\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::MacroCall::cast)\n+        .unwrap();\n+\n+    let definition_tt = macro_call_to_tt(macro_definition).unwrap();\n+    let invocation_tt = macro_call_to_tt(macro_invocation).unwrap();\n+    let mbe = crate::parse(&definition_tt).unwrap();\n+    let expansion = crate::exapnd(&mbe, &invocation_tt).unwrap();\n+    assert_eq!(\n+        expansion.to_string(),\n+        \"{(impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}}) \\\n+          (impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}})}\"\n+    )\n+}"}, {"sha": "02accd4040b159e2e47c64043bd074b973bb4b89", "filename": "crates/ra_tt/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_tt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_tt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2FCargo.toml?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -5,5 +5,4 @@ version = \"0.1.0\"\n authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n-rustc-hash = \"1.0.0\"\n smol_str = \"0.1.9\""}, {"sha": "043417abcce20b549df8331bb7eaecf244a2f527", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1f0b105d7995088fdf7a90e5e594b5555699c6/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=2d1f0b105d7995088fdf7a90e5e594b5555699c6", "patch": "@@ -1,3 +1,7 @@\n+/// `tt` crate defines a `TokenTree` datastructure: this is the interface (both\n+/// input and output) of macros. It closely mirrors `proc_macro` crate's\n+/// `TokenTree`.\n+\n macro_rules! impl_froms {\n     ($e:ident: $($v:ident), *) => {\n         $("}]}