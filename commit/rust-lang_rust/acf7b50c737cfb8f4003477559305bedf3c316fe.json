{"sha": "acf7b50c737cfb8f4003477559305bedf3c316fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZjdiNTBjNzM3Y2ZiOGY0MDAzNDc3NTU5MzA1YmVkZjNjMzE2ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T09:54:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T09:54:50Z"}, "message": "Auto merge of #64663 - jakoschiko:report-time, r=alexcrichton\n\nlibtest: Add --report-time flag to print test execution time\n\nImplements the flag `--report-time` to print the execution time of each executed (successful or failed) test.\n\nCloses #46610\n\n# Example\n\n`cargo test -- --report-time` produces the following output to stdout:\n```\nrunning 6 tests\ntest tests::ignore ... ignored\ntest tests::noop ... ok 0.000s\ntest tests::should_panic ... ok 0.000s\ntest tests::panic_after_10millis ... FAILED 0.010s\ntest tests::sleep_100millis ... ok 0.100s\ntest tests::sleep_10secs ... ok 10.001s\n\nfailures:\n\n---- tests::panic_after_10millis stdout ----\nthread 'tests::panic_after_10millis' panicked at 'foo', src\\lib.rs:31:9\n\nfailures:\n    tests::panic_after_10millis\n\ntest result: FAILED. 4 passed; 1 failed; 1 ignored; 0 measured; 0 filtered out\n```\n`cargo test -- --report-time -Z unstable-options --format=json` produces the following output to stdout:\n```\n{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": 6 }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"tests::ignore\" }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"tests::noop\" }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"tests::panic_after_10millis\" }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"tests::should_panic\" }\n{ \"type\": \"test\", \"name\": \"tests::ignore\", \"event\": \"ignored\" }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"tests::sleep_100millis\" }\n{ \"type\": \"test\", \"name\": \"tests::noop\", \"event\": \"ok\", \"exec_time\": \"0.000s\" }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"tests::sleep_10secs\" }\n{ \"type\": \"test\", \"name\": \"tests::should_panic\", \"event\": \"ok\", \"exec_time\": \"0.000s\" }\n{ \"type\": \"test\", \"name\": \"tests::panic_after_10millis\", \"event\": \"failed\", \"exec_time\": \"0.010s\", \"stdout\": \"thread 'tests::panic_after_10millis' panicked at 'foo', src\\\\lib.rs:31:9\\n\" }\n{ \"type\": \"test\", \"name\": \"tests::sleep_100millis\", \"event\": \"ok\", \"exec_time\": \"0.101s\" }\n{ \"type\": \"test\", \"name\": \"tests::sleep_10secs\", \"event\": \"ok\", \"exec_time\": \"10.000s\" }\n{ \"type\": \"suite\", \"event\": \"failed\", \"passed\": 4, \"failed\": 1, \"allowed_fail\": 0, \"ignored\": 1, \"measured\": 0, \"filtered_out\": 0 }\n```\n`cargo test -- --report-time --logfile foo.log` produces the following logfile:\n```\nignored tests::ignore\nok tests::noop 0.000s\nok tests::should_panic 0.000s\nfailed tests::panic_after_10millis 0.010s\nok tests::sleep_100millis 0.100s\nok tests::sleep_10secs 10.001s\n```", "tree": {"sha": "e3d73c64944ed4f355820c727ff71f5f55b43aaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3d73c64944ed4f355820c727ff71f5f55b43aaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acf7b50c737cfb8f4003477559305bedf3c316fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acf7b50c737cfb8f4003477559305bedf3c316fe", "html_url": "https://github.com/rust-lang/rust/commit/acf7b50c737cfb8f4003477559305bedf3c316fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acf7b50c737cfb8f4003477559305bedf3c316fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "html_url": "https://github.com/rust-lang/rust/commit/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d"}, {"sha": "d91b965664c47cdf8dfa060f17f50d2fe972c2de", "url": "https://api.github.com/repos/rust-lang/rust/commits/d91b965664c47cdf8dfa060f17f50d2fe972c2de", "html_url": "https://github.com/rust-lang/rust/commit/d91b965664c47cdf8dfa060f17f50d2fe972c2de"}], "stats": {"total": 216, "additions": 168, "deletions": 48}, "files": [{"sha": "d9e4abf61c3dc2f7aa0c65db1d020fe609341395", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=acf7b50c737cfb8f4003477559305bedf3c316fe", "patch": "@@ -27,13 +27,20 @@ impl<T: Write> JsonFormatter<T> {\n         ty: &str,\n         name: &str,\n         evt: &str,\n+        exec_time: Option<&TestExecTime>,\n         stdout: Option<Cow<'_, str>>,\n         extra: Option<&str>,\n     ) -> io::Result<()> {\n         self.write_message(&*format!(\n             r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n             ty, name, evt\n         ))?;\n+        if let Some(exec_time) = exec_time {\n+            self.write_message(&*format!(\n+                r#\", \"exec_time\": \"{}\"\"#,\n+                exec_time\n+            ))?;\n+        }\n         if let Some(stdout) = stdout {\n             self.write_message(&*format!(\n                 r#\", \"stdout\": \"{}\"\"#,\n@@ -69,6 +76,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n+        exec_time: Option<&TestExecTime>,\n         stdout: &[u8],\n         state: &ConsoleTestState,\n     ) -> io::Result<()> {\n@@ -78,24 +86,36 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n             None\n         };\n         match *result {\n-            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", stdout, None),\n+            TrOk => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"ok\", exec_time, stdout, None)\n+            }\n \n-            TrFailed => self.write_event(\"test\", desc.name.as_slice(), \"failed\", stdout, None),\n+            TrFailed => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"failed\", exec_time, stdout, None)\n+            }\n \n             TrFailedMsg(ref m) => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"failed\",\n+                exec_time,\n                 stdout,\n                 Some(&*format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n             ),\n \n-            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", stdout, None),\n-\n-            TrAllowedFail => {\n-                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", stdout, None)\n+            TrIgnored => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"ignored\", exec_time, stdout, None)\n             }\n \n+            TrAllowedFail => self.write_event(\n+                \"test\",\n+                desc.name.as_slice(),\n+                \"allowed_failure\",\n+                exec_time,\n+                stdout,\n+                None,\n+            ),\n+\n             TrBench(ref bs) => {\n                 let median = bs.ns_iter_summ.median as usize;\n                 let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;"}, {"sha": "e97cda76d23180e33e5f35b5022a26231a787a49", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=acf7b50c737cfb8f4003477559305bedf3c316fe", "patch": "@@ -16,6 +16,7 @@ pub(crate) trait OutputFormatter {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n+        exec_time: Option<&TestExecTime>,\n         stdout: &[u8],\n         state: &ConsoleTestState,\n     ) -> io::Result<()>;"}, {"sha": "184726c67d3fb1a6bd87cbc96d9963413c856b53", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=acf7b50c737cfb8f4003477559305bedf3c316fe", "patch": "@@ -30,20 +30,20 @@ impl<T: Write> PrettyFormatter<T> {\n         &self.out\n     }\n \n-    pub fn write_ok(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ok\", term::color::GREEN)\n+    pub fn write_ok(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n+        self.write_short_result(\"ok\", term::color::GREEN, exec_time)\n     }\n \n-    pub fn write_failed(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED\", term::color::RED)\n+    pub fn write_failed(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n+        self.write_short_result(\"FAILED\", term::color::RED, exec_time)\n     }\n \n-    pub fn write_ignored(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ignored\", term::color::YELLOW)\n+    pub fn write_ignored(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n+        self.write_short_result(\"ignored\", term::color::YELLOW, exec_time)\n     }\n \n-    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n+    pub fn write_allowed_fail(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW, exec_time)\n     }\n \n     pub fn write_bench(&mut self) -> io::Result<()> {\n@@ -54,8 +54,12 @@ impl<T: Write> PrettyFormatter<T> {\n         &mut self,\n         result: &str,\n         color: term::color::Color,\n+        exec_time: Option<&TestExecTime>,\n     ) -> io::Result<()> {\n         self.write_pretty(result, color)?;\n+        if let Some(exec_time) = exec_time {\n+            self.write_plain(format!(\" {}\", exec_time))?;\n+        }\n         self.write_plain(\"\\n\")\n     }\n \n@@ -166,6 +170,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n+        exec_time: Option<&TestExecTime>,\n         _: &[u8],\n         _: &ConsoleTestState,\n     ) -> io::Result<()> {\n@@ -174,10 +179,10 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         }\n \n         match *result {\n-            TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) => self.write_failed(),\n-            TrIgnored => self.write_ignored(),\n-            TrAllowedFail => self.write_allowed_fail(),\n+            TrOk => self.write_ok(exec_time),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(exec_time),\n+            TrIgnored => self.write_ignored(exec_time),\n+            TrAllowedFail => self.write_allowed_fail(exec_time),\n             TrBench(ref bs) => {\n                 self.write_bench()?;\n                 self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))"}, {"sha": "1812c20904c87f591feb2d498b03c46b618fe89c", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=acf7b50c737cfb8f4003477559305bedf3c316fe", "patch": "@@ -174,6 +174,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         &mut self,\n         desc: &TestDesc,\n         result: &TestResult,\n+        _: Option<&TestExecTime>,\n         _: &[u8],\n         _: &ConsoleTestState,\n     ) -> io::Result<()> {"}, {"sha": "e441514e5973857a03b2d89ca918cac4a305a7a9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=acf7b50c737cfb8f4003477559305bedf3c316fe", "patch": "@@ -378,6 +378,7 @@ pub struct TestOpts {\n     pub format: OutputFormat,\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n+    pub report_time: bool,\n     pub options: Options,\n }\n \n@@ -460,6 +461,11 @@ fn optgroups() -> getopts::Options {\n             \"Enable nightly-only flags:\n             unstable-options = Allow use of experimental features\",\n             \"unstable-options\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"report-time\",\n+            \"Show execution time of each test. Not available for --format=terse\"\n         );\n     return opts;\n }\n@@ -560,6 +566,13 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         ));\n     }\n \n+    let report_time = matches.opt_present(\"report-time\");\n+    if !allow_unstable && report_time {\n+        return Some(Err(\n+            \"The \\\"report-time\\\" flag is only accepted on the nightly compiler\".into(),\n+        ));\n+    }\n+\n     let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n         (true, true) => {\n             return Some(Err(\n@@ -653,6 +666,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         format,\n         test_threads,\n         skip: matches.opt_strs(\"skip\"),\n+        report_time,\n         options: Options::new().display_output(matches.opt_present(\"show-output\")),\n     };\n \n@@ -677,6 +691,16 @@ pub enum TestResult {\n \n unsafe impl Send for TestResult {}\n \n+/// The meassured execution time of a unit test.\n+#[derive(Clone, PartialEq)]\n+pub struct TestExecTime(Duration);\n+\n+impl fmt::Display for TestExecTime {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:.3}s\", self.0.as_secs_f64())\n+    }\n+}\n+\n enum OutputLocation<T> {\n     Pretty(Box<term::StdoutTerminal>),\n     Raw(T),\n@@ -736,17 +760,30 @@ impl ConsoleTestState {\n         })\n     }\n \n-    pub fn write_log<S: AsRef<str>>(&mut self, msg: S) -> io::Result<()> {\n-        let msg = msg.as_ref();\n+    pub fn write_log<F, S>(\n+        &mut self,\n+        msg: F,\n+    ) -> io::Result<()>\n+    where\n+        S: AsRef<str>,\n+        F: FnOnce() -> S,\n+    {\n         match self.log_out {\n             None => Ok(()),\n-            Some(ref mut o) => o.write_all(msg.as_bytes()),\n+            Some(ref mut o) => {\n+                let msg = msg();\n+                let msg = msg.as_ref();\n+                o.write_all(msg.as_bytes())\n+            },\n         }\n     }\n \n-    pub fn write_log_result(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n-        self.write_log(format!(\n-            \"{} {}\\n\",\n+    pub fn write_log_result(&mut self,test: &TestDesc,\n+        result: &TestResult,\n+        exec_time: Option<&TestExecTime>,\n+    ) -> io::Result<()> {\n+        self.write_log(|| format!(\n+            \"{} {}\",\n             match *result {\n                 TrOk => \"ok\".to_owned(),\n                 TrFailed => \"failed\".to_owned(),\n@@ -755,8 +792,12 @@ impl ConsoleTestState {\n                 TrAllowedFail => \"failed (allowed)\".to_owned(),\n                 TrBench(ref bs) => fmt_bench_samples(bs),\n             },\n-            test.name\n-        ))\n+            test.name,\n+        ))?;\n+        if let Some(exec_time) = exec_time {\n+            self.write_log(|| format!(\" {}\", exec_time))?;\n+        }\n+        self.write_log(|| \"\\n\")\n     }\n \n     fn current_test_count(&self) -> usize {\n@@ -843,7 +884,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n         };\n \n         writeln!(output, \"{}: {}\", name, fntype)?;\n-        st.write_log(format!(\"{} {}\\n\", fntype, name))?;\n+        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n     }\n \n     fn plural(count: u32, s: &str) -> String {\n@@ -884,9 +925,9 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n             TeWait(ref test) => out.write_test_start(test),\n             TeTimeout(ref test) => out.write_timeout(test),\n-            TeResult(test, result, stdout) => {\n-                st.write_log_result(&test, &result)?;\n-                out.write_result(&test, &result, &*stdout, &st)?;\n+            TeResult(test, result, exec_time, stdout) => {\n+                st.write_log_result(&test, &result, exec_time.as_ref())?;\n+                out.write_result(&test, &result, exec_time.as_ref(), &*stdout, &st)?;\n                 match result {\n                     TrOk => {\n                         st.passed += 1;\n@@ -1004,12 +1045,12 @@ fn stdout_isatty() -> bool {\n pub enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n     TeWait(TestDesc),\n-    TeResult(TestDesc, TestResult, Vec<u8>),\n+    TeResult(TestDesc, TestResult, Option<TestExecTime>, Vec<u8>),\n     TeTimeout(TestDesc),\n     TeFilteredOut(usize),\n }\n \n-pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n+pub type MonitorMsg = (TestDesc, TestResult, Option<TestExecTime>, Vec<u8>);\n \n struct Sink(Arc<Mutex<Vec<u8>>>);\n impl Write for Sink {\n@@ -1105,8 +1146,8 @@ where\n             let test = remaining.pop().unwrap();\n             callback(TeWait(test.desc.clone()))?;\n             run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::No);\n-            let (test, result, stdout) = rx.recv().unwrap();\n-            callback(TeResult(test, result, stdout))?;\n+            let (test, result, exec_time, stdout) = rx.recv().unwrap();\n+            callback(TeResult(test, result, exec_time, stdout))?;\n         }\n     } else {\n         while pending > 0 || !remaining.is_empty() {\n@@ -1135,10 +1176,10 @@ where\n                 }\n             }\n \n-            let (desc, result, stdout) = res.unwrap();\n+            let (desc, result, exec_time, stdout) = res.unwrap();\n             running_tests.remove(&desc);\n \n-            callback(TeResult(desc, result, stdout))?;\n+            callback(TeResult(desc, result, exec_time, stdout))?;\n             pending -= 1;\n         }\n     }\n@@ -1148,8 +1189,8 @@ where\n         for b in filtered_benchs {\n             callback(TeWait(b.desc.clone()))?;\n             run_test(opts, false, b, tx.clone(), Concurrent::No);\n-            let (test, result, stdout) = rx.recv().unwrap();\n-            callback(TeResult(test, result, stdout))?;\n+            let (test, result, exec_time, stdout) = rx.recv().unwrap();\n+            callback(TeResult(test, result, exec_time, stdout))?;\n         }\n     }\n     Ok(())\n@@ -1384,14 +1425,15 @@ pub fn run_test(\n         && desc.should_panic != ShouldPanic::No;\n \n     if force_ignore || desc.ignore || ignore_because_panic_abort {\n-        monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n+        monitor_ch.send((desc, TrIgnored, None, Vec::new())).unwrap();\n         return;\n     }\n \n     fn run_test_inner(\n         desc: TestDesc,\n         monitor_ch: Sender<MonitorMsg>,\n         nocapture: bool,\n+        report_time: bool,\n         testfn: Box<dyn FnOnce() + Send>,\n         concurrency: Concurrent,\n     ) {\n@@ -1410,7 +1452,16 @@ pub fn run_test(\n                 None\n             };\n \n+            let start = if report_time {\n+                Some(Instant::now())\n+            } else {\n+                None\n+            };\n             let result = catch_unwind(AssertUnwindSafe(testfn));\n+            let exec_time = start.map(|start| {\n+                let duration = start.elapsed();\n+                TestExecTime(duration)\n+            });\n \n             if let Some((printio, panicio)) = oldio {\n                 io::set_print(printio);\n@@ -1420,7 +1471,7 @@ pub fn run_test(\n             let test_result = calc_result(&desc, result);\n             let stdout = data.lock().unwrap().to_vec();\n             monitor_ch\n-                .send((desc.clone(), test_result, stdout))\n+                .send((desc.clone(), test_result, exec_time, stdout))\n                 .unwrap();\n         };\n \n@@ -1449,12 +1500,20 @@ pub fn run_test(\n         }\n         DynTestFn(f) => {\n             let cb = move || __rust_begin_short_backtrace(f);\n-            run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb), concurrency)\n+            run_test_inner(\n+                desc,\n+                monitor_ch,\n+                opts.nocapture,\n+                opts.report_time,\n+                Box::new(cb),\n+                concurrency,\n+            )\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,\n             monitor_ch,\n             opts.nocapture,\n+            opts.report_time,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n             concurrency,\n         ),\n@@ -1702,7 +1761,7 @@ pub mod bench {\n         };\n \n         let stdout = data.lock().unwrap().to_vec();\n-        monitor_ch.send((desc, test_result, stdout)).unwrap();\n+        monitor_ch.send((desc, test_result, None, stdout)).unwrap();\n     }\n \n     pub fn run_once<F>(f: F)"}, {"sha": "13ac8eb91f411ccac43ada5d41bd01b3f6d9b0ac", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf7b50c737cfb8f4003477559305bedf3c316fe/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=acf7b50c737cfb8f4003477559305bedf3c316fe", "patch": "@@ -23,6 +23,7 @@ impl TestOpts {\n             format: OutputFormat::Pretty,\n             test_threads: None,\n             skip: vec![],\n+            report_time: false,\n             options: Options::new(),\n         }\n     }\n@@ -67,7 +68,7 @@ pub fn do_not_run_ignored_tests() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-    let (_, res, _) = rx.recv().unwrap();\n+    let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res != TrOk);\n }\n \n@@ -85,7 +86,7 @@ pub fn ignored_tests_result_in_ignored() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-    let (_, res, _) = rx.recv().unwrap();\n+    let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrIgnored);\n }\n \n@@ -105,7 +106,7 @@ fn test_should_panic() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-    let (_, res, _) = rx.recv().unwrap();\n+    let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrOk);\n }\n \n@@ -125,7 +126,7 @@ fn test_should_panic_good_message() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-    let (_, res, _) = rx.recv().unwrap();\n+    let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrOk);\n }\n \n@@ -147,7 +148,7 @@ fn test_should_panic_bad_message() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-    let (_, res, _) = rx.recv().unwrap();\n+    let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n }\n \n@@ -165,10 +166,43 @@ fn test_should_panic_but_succeeds() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-    let (_, res, _) = rx.recv().unwrap();\n+    let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrFailed);\n }\n \n+fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n+    fn f() {}\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let test_opts = TestOpts {\n+        report_time,\n+        ..TestOpts::new()\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&test_opts, false, desc, tx, Concurrent::No);\n+    let (_, _, exec_time, _) = rx.recv().unwrap();\n+    exec_time\n+}\n+\n+#[test]\n+fn test_should_not_report_time() {\n+    let exec_time = report_time_test_template(false);\n+    assert!(exec_time.is_none());\n+}\n+\n+#[test]\n+fn test_should_report_time() {\n+    let exec_time = report_time_test_template(true);\n+    assert!(exec_time.is_some());\n+}\n+\n #[test]\n fn parse_ignored_flag() {\n     let args = vec!["}]}