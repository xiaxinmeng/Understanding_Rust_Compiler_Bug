{"sha": "7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzZkMGFkNDRlMWVjMjAzZDIzNWYyMmViMzUxNDI0N2I4Y2JmZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T04:51:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T04:51:18Z"}, "message": "auto merge of #14323 : richo/rust/features/strbuf_to_string, r=huonw\n\nConverts `StrBuf` to `String` throughout rustc and the standard library.\r\n\r\nTests all pass locally, but usual caveats about platforms that aren't OSX apply since I don't have a test environment handy.\r\n\r\n@alexcritchon mentioned that @pcwalton may have a patch incoming that should block this?\r\n\r\ncloses #14312", "tree": {"sha": "01682cf8147183250713acf5e8a77265aab7153c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01682cf8147183250713acf5e8a77265aab7153c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "html_url": "https://github.com/rust-lang/rust/commit/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb70cdd9cd982922cf7390459d53bde409699ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb70cdd9cd982922cf7390459d53bde409699ae", "html_url": "https://github.com/rust-lang/rust/commit/bbb70cdd9cd982922cf7390459d53bde409699ae"}, {"sha": "553074506ecd139eb961fb91eb33ad9fd0183acb", "url": "https://api.github.com/repos/rust-lang/rust/commits/553074506ecd139eb961fb91eb33ad9fd0183acb", "html_url": "https://github.com/rust-lang/rust/commit/553074506ecd139eb961fb91eb33ad9fd0183acb"}], "stats": {"total": 3532, "additions": 1766, "deletions": 1766}, "files": [{"sha": "4788229ff79c5aeedb3c53fc93f13e790f241483", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -56,10 +56,10 @@ impl fmt::Show for Mode {\n #[deriving(Clone)]\n pub struct Config {\n     // The library paths required for running the compiler\n-    pub compile_lib_path: StrBuf,\n+    pub compile_lib_path: String,\n \n     // The library paths required for running compiled programs\n-    pub run_lib_path: StrBuf,\n+    pub run_lib_path: String,\n \n     // The rustc executable\n     pub rustc_path: Path,\n@@ -80,7 +80,7 @@ pub struct Config {\n     pub aux_base: Path,\n \n     // The name of the stage being built (stage1, etc)\n-    pub stage_id: StrBuf,\n+    pub stage_id: String,\n \n     // The test mode, compile-fail, run-fail, run-pass\n     pub mode: Mode,\n@@ -113,37 +113,37 @@ pub struct Config {\n \n     // A command line to prefix program execution with,\n     // for running under valgrind\n-    pub runtool: Option<StrBuf>,\n+    pub runtool: Option<String>,\n \n     // Flags to pass to the compiler when building for the host\n-    pub host_rustcflags: Option<StrBuf>,\n+    pub host_rustcflags: Option<String>,\n \n     // Flags to pass to the compiler when building for the target\n-    pub target_rustcflags: Option<StrBuf>,\n+    pub target_rustcflags: Option<String>,\n \n     // Run tests using the JIT\n     pub jit: bool,\n \n     // Target system to be tested\n-    pub target: StrBuf,\n+    pub target: String,\n \n     // Host triple for the compiler being invoked\n-    pub host: StrBuf,\n+    pub host: String,\n \n     // Path to the android tools\n     pub android_cross_path: Path,\n \n     // Extra parameter to run adb on arm-linux-androideabi\n-    pub adb_path: StrBuf,\n+    pub adb_path: String,\n \n     // Extra parameter to run test sute on arm-linux-androideabi\n-    pub adb_test_dir: StrBuf,\n+    pub adb_test_dir: String,\n \n     // status whether android device available or not\n     pub adb_device_status: bool,\n \n     // the path containing LLDB's Python module\n-    pub lldb_python_dir: Option<StrBuf>,\n+    pub lldb_python_dir: Option<String>,\n \n     // Explain what's going on\n     pub verbose: bool"}, {"sha": "8ea718c7f276374b055bf149cb23df9f355a4f44", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -56,7 +56,7 @@ pub fn main() {\n     run_tests(&config);\n }\n \n-pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n+pub fn parse_config(args: Vec<String> ) -> Config {\n \n     let groups : Vec<getopts::OptGroup> =\n         vec!(reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n@@ -225,14 +225,14 @@ pub fn log_config(config: &Config) {\n     logv(c, format_strbuf!(\"\\n\"));\n }\n \n-pub fn opt_str<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n         Some(ref s) => s.as_slice(),\n     }\n }\n \n-pub fn opt_str2(maybestr: Option<StrBuf>) -> StrBuf {\n+pub fn opt_str2(maybestr: Option<String>) -> String {\n     match maybestr {\n         None => \"(none)\".to_strbuf(),\n         Some(s) => s,\n@@ -352,7 +352,7 @@ pub fn make_test(config: &Config, testfile: &Path, f: || -> test::TestFn)\n pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n \n     // Try to elide redundant long paths\n-    fn shorten(path: &Path) -> StrBuf {\n+    fn shorten(path: &Path) -> String {\n         let filename = path.filename_str();\n         let p = path.dir_path();\n         let dir = p.filename_str();"}, {"sha": "f3ebe30b37dd9540dfd8f9e28b17eb8a80fce252", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,8 +13,8 @@ use regex::Regex;\n \n pub struct ExpectedError {\n     pub line: uint,\n-    pub kind: StrBuf,\n-    pub msg: StrBuf,\n+    pub kind: String,\n+    pub msg: String,\n }\n \n pub static EXPECTED_PATTERN : &'static str = r\"//~(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";"}, {"sha": "44fc8e8ce528e36c4f1d31e8da196b1e5f003e48", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,20 +14,20 @@ use util;\n \n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n-    pub error_patterns: Vec<StrBuf> ,\n+    pub error_patterns: Vec<String> ,\n     // Extra flags to pass to the compiler\n-    pub compile_flags: Option<StrBuf>,\n+    pub compile_flags: Option<String>,\n     // Extra flags to pass when the compiled code is run (such as --bench)\n-    pub run_flags: Option<StrBuf>,\n+    pub run_flags: Option<String>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n     pub pp_exact: Option<Path>,\n     // Modules from aux directory that should be compiled\n-    pub aux_builds: Vec<StrBuf> ,\n+    pub aux_builds: Vec<String> ,\n     // Environment settings to use during execution\n-    pub exec_env: Vec<(StrBuf,StrBuf)> ,\n+    pub exec_env: Vec<(String,String)> ,\n     // Lines to check if they appear in the expected debugger output\n-    pub check_lines: Vec<StrBuf> ,\n+    pub check_lines: Vec<String> ,\n     // Flag to force a crate to be built with the host architecture\n     pub force_host: bool,\n     // Check stdout for error-pattern output as well as stderr\n@@ -119,10 +119,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n }\n \n pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n-    fn ignore_target(config: &Config) -> StrBuf {\n+    fn ignore_target(config: &Config) -> String {\n         format_strbuf!(\"ignore-{}\", util::get_os(config.target.as_slice()))\n     }\n-    fn ignore_stage(config: &Config) -> StrBuf {\n+    fn ignore_stage(config: &Config) -> String {\n         format_strbuf!(\"ignore-{}\",\n                        config.stage_id.as_slice().split('-').next().unwrap())\n     }\n@@ -169,23 +169,23 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n     return true;\n }\n \n-fn parse_error_pattern(line: &str) -> Option<StrBuf> {\n+fn parse_error_pattern(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"error-pattern\".to_strbuf())\n }\n \n-fn parse_aux_build(line: &str) -> Option<StrBuf> {\n+fn parse_aux_build(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"aux-build\".to_strbuf())\n }\n \n-fn parse_compile_flags(line: &str) -> Option<StrBuf> {\n+fn parse_compile_flags(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"compile-flags\".to_strbuf())\n }\n \n-fn parse_run_flags(line: &str) -> Option<StrBuf> {\n+fn parse_run_flags(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"run-flags\".to_strbuf())\n }\n \n-fn parse_check_line(line: &str) -> Option<StrBuf> {\n+fn parse_check_line(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"check\".to_strbuf())\n }\n \n@@ -205,10 +205,10 @@ fn parse_no_pretty_expanded(line: &str) -> bool {\n     parse_name_directive(line, \"no-pretty-expanded\")\n }\n \n-fn parse_exec_env(line: &str) -> Option<(StrBuf, StrBuf)> {\n+fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, \"exec-env\".to_strbuf()).map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<StrBuf> = nv.as_slice()\n+        let mut strs: Vec<String> = nv.as_slice()\n                                       .splitn('=', 1)\n                                       .map(|s| s.to_strbuf())\n                                       .collect();\n@@ -241,8 +241,8 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n     line.contains(directive)\n }\n \n-pub fn parse_name_value_directive(line: &str, directive: StrBuf)\n-                                  -> Option<StrBuf> {\n+pub fn parse_name_value_directive(line: &str, directive: String)\n+                                  -> Option<String> {\n     let keycolon = format_strbuf!(\"{}:\", directive);\n     match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {"}, {"sha": "49430a8d45be58f5e993de95e00bb5ccd6ec690e", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@ use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n use std::unstable::dynamic_lib::DynamicLibrary;\n \n-fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(String, String)> {\n     let prog = if cfg!(windows) {prog.slice_to(prog.len() - 4)} else {prog};\n     let mut aux_path = prog.to_strbuf();\n     aux_path.push_str(\".libaux\");\n@@ -26,7 +26,7 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n \n     // Remove the previous dylib search path var\n     let var = DynamicLibrary::envvar();\n-    let mut env: Vec<(StrBuf,StrBuf)> =\n+    let mut env: Vec<(String,String)> =\n         os::env().move_iter().map(|(a,b)|(a.to_strbuf(), b.to_strbuf())).collect();\n     match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n         Some(i) => { env.remove(i); }\n@@ -40,13 +40,13 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n     return env;\n }\n \n-pub struct Result {pub status: ProcessExit, pub out: StrBuf, pub err: StrBuf}\n+pub struct Result {pub status: ProcessExit, pub out: String, pub err: String}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n-           args: &[StrBuf],\n-           env: Vec<(StrBuf, StrBuf)> ,\n-           input: Option<StrBuf>) -> Option<Result> {\n+           args: &[String],\n+           env: Vec<(String, String)> ,\n+           input: Option<String>) -> Option<Result> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n@@ -69,9 +69,9 @@ pub fn run(lib_path: &str,\n \n pub fn run_background(lib_path: &str,\n            prog: &str,\n-           args: &[StrBuf],\n-           env: Vec<(StrBuf, StrBuf)> ,\n-           input: Option<StrBuf>) -> Option<Process> {\n+           args: &[String],\n+           env: Vec<(String, String)> ,\n+           input: Option<String>) -> Option<Process> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {"}, {"sha": "7ddbb83155cf3c4cd08b74f1e60a459c84cc1aef", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -28,11 +28,11 @@ use std::io::timer;\n use std::io;\n use std::os;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::task;\n use test::MetricMap;\n \n-pub fn run(config: Config, testfile: StrBuf) {\n+pub fn run(config: Config, testfile: String) {\n \n     match config.target.as_slice() {\n \n@@ -49,7 +49,7 @@ pub fn run(config: Config, testfile: StrBuf) {\n     run_metrics(config, testfile, &mut _mm);\n }\n \n-pub fn run_metrics(config: Config, testfile: StrBuf, mm: &mut MetricMap) {\n+pub fn run_metrics(config: Config, testfile: String, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n@@ -231,7 +231,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     fn print_source(config: &Config,\n                     props: &TestProps,\n                     testfile: &Path,\n-                    src: StrBuf,\n+                    src: String,\n                     pretty_type: &str) -> ProcRes {\n         compose_and_run(config,\n                         testfile,\n@@ -247,7 +247,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     fn make_pp_args(config: &Config,\n                     props: &TestProps,\n                     testfile: &Path,\n-                    pretty_type: StrBuf) -> ProcArgs {\n+                    pretty_type: String) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_strbuf(),\n@@ -284,7 +284,7 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(config: &Config, props: &TestProps,\n-                        testfile: &Path, src: StrBuf) -> ProcRes {\n+                        testfile: &Path, src: String) -> ProcRes {\n         let args = make_typecheck_args(config, props, testfile);\n         compose_and_run_compiler(config, props, testfile, args, Some(src))\n     }\n@@ -469,11 +469,11 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             // run debugger script with gdb\n             #[cfg(windows)]\n-            fn debugger() -> StrBuf {\n+            fn debugger() -> String {\n                 \"gdb.exe\".to_strbuf()\n             }\n             #[cfg(unix)]\n-            fn debugger() -> StrBuf {\n+            fn debugger() -> String {\n                 \"gdb\".to_strbuf()\n             }\n \n@@ -540,7 +540,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n     // Write debugger script:\n     // We don't want to hang when calling `quit` while the process is still running\n-    let mut script_str = StrBuf::from_str(\"settings set auto-confirm true\\n\");\n+    let mut script_str = String::from_str(\"settings set auto-confirm true\\n\");\n \n     // Set breakpoints on every line that contains the string \"#break\"\n     for line in breakpoint_lines.iter() {\n@@ -610,8 +610,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n }\n \n struct DebuggerCommands {\n-    commands: Vec<StrBuf>,\n-    check_lines: Vec<StrBuf>,\n+    commands: Vec<String>,\n+    check_lines: Vec<String>,\n     breakpoint_lines: Vec<uint>,\n }\n \n@@ -662,7 +662,7 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n     }\n }\n \n-fn cleanup_debug_info_options(options: &Option<StrBuf>) -> Option<StrBuf> {\n+fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n     if options.is_none() {\n         return None;\n     }\n@@ -676,18 +676,18 @@ fn cleanup_debug_info_options(options: &Option<StrBuf>) -> Option<StrBuf> {\n     let new_options =\n         split_maybe_args(options).move_iter()\n                                  .filter(|x| !options_to_remove.contains(x))\n-                                 .collect::<Vec<StrBuf>>()\n+                                 .collect::<Vec<String>>()\n                                  .connect(\" \")\n                                  .to_strbuf();\n     Some(new_options)\n }\n \n-fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[StrBuf]) {\n+fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String]) {\n     let num_check_lines = check_lines.len();\n     if num_check_lines > 0 {\n         // Allow check lines to leave parts unspecified (e.g., uninitialized\n         // bits in the wrong case of an enum) with the notation \"[...]\".\n-        let check_fragments: Vec<Vec<StrBuf>> =\n+        let check_fragments: Vec<Vec<String>> =\n             check_lines.iter().map(|s| {\n                 s.as_slice()\n                  .trim()\n@@ -812,10 +812,10 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n \n     let prefixes = expected_errors.iter().map(|ee| {\n         format_strbuf!(\"{}:{}:\", testfile.display(), ee.line)\n-    }).collect::<Vec<StrBuf> >();\n+    }).collect::<Vec<String> >();\n \n     #[cfg(target_os = \"win32\")]\n-    fn to_lower( s : &str ) -> StrBuf {\n+    fn to_lower( s : &str ) -> String {\n         let i = s.chars();\n         let c : Vec<char> = i.map( |c| {\n             if c.is_ascii() {\n@@ -966,15 +966,15 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n }\n \n struct ProcArgs {\n-    prog: StrBuf,\n-    args: Vec<StrBuf>,\n+    prog: String,\n+    args: Vec<String>,\n }\n \n struct ProcRes {\n     status: ProcessExit,\n-    stdout: StrBuf,\n-    stderr: StrBuf,\n-    cmdline: StrBuf,\n+    stdout: String,\n+    stderr: String,\n+    cmdline: String,\n }\n \n fn compile_test(config: &Config, props: &TestProps,\n@@ -987,7 +987,7 @@ fn jit_test(config: &Config, props: &TestProps, testfile: &Path) -> ProcRes {\n }\n \n fn compile_test_(config: &Config, props: &TestProps,\n-                 testfile: &Path, extra_args: &[StrBuf]) -> ProcRes {\n+                 testfile: &Path, extra_args: &[String]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let link_args = vec!(\"-L\".to_strbuf(),\n@@ -1026,7 +1026,7 @@ fn compose_and_run_compiler(\n     props: &TestProps,\n     testfile: &Path,\n     args: ProcArgs,\n-    input: Option<StrBuf>) -> ProcRes {\n+    input: Option<String>) -> ProcRes {\n \n     if !props.aux_builds.is_empty() {\n         ensure_dir(&aux_output_dir_name(config, testfile));\n@@ -1093,9 +1093,9 @@ fn ensure_dir(path: &Path) {\n \n fn compose_and_run(config: &Config, testfile: &Path,\n                    ProcArgs{ args, prog }: ProcArgs,\n-                   procenv: Vec<(StrBuf, StrBuf)> ,\n+                   procenv: Vec<(String, String)> ,\n                    lib_path: &str,\n-                   input: Option<StrBuf>) -> ProcRes {\n+                   input: Option<String>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n                           prog, args, procenv, input);\n }\n@@ -1107,7 +1107,7 @@ enum TargetLocation {\n \n fn make_compile_args(config: &Config,\n                      props: &TestProps,\n-                     extras: Vec<StrBuf> ,\n+                     extras: Vec<String> ,\n                      xform: |&Config, &Path| -> TargetLocation,\n                      testfile: &Path)\n                      -> ProcArgs {\n@@ -1188,7 +1188,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     };\n }\n \n-fn split_maybe_args(argstr: &Option<StrBuf>) -> Vec<StrBuf> {\n+fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n     match *argstr {\n         Some(ref s) => {\n             s.as_slice()\n@@ -1205,9 +1205,9 @@ fn split_maybe_args(argstr: &Option<StrBuf>) -> Vec<StrBuf> {\n     }\n }\n \n-fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: StrBuf,\n-                  args: Vec<StrBuf> , env: Vec<(StrBuf, StrBuf)> ,\n-                  input: Option<StrBuf>) -> ProcRes {\n+fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String,\n+                  args: Vec<String> , env: Vec<(String, String)> ,\n+                  input: Option<String>) -> ProcRes {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path,\n@@ -1239,12 +1239,12 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: StrBuf\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n+fn make_cmdline(_libpath: &str, prog: &str, args: &[String]) -> String {\n     format_strbuf!(\"{} {}\", prog, args.connect(\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n-fn make_cmdline(libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n+fn make_cmdline(libpath: &str, prog: &str, args: &[String]) -> String {\n     format_strbuf!(\"{} {} {}\",\n                    lib_path_cmd_prefix(libpath),\n                    prog,\n@@ -1254,7 +1254,7 @@ fn make_cmdline(libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n #[cfg(target_os = \"win32\")]\n-fn lib_path_cmd_prefix(path: &str) -> StrBuf {\n+fn lib_path_cmd_prefix(path: &str) -> String {\n     format_strbuf!(\"{}=\\\"{}\\\"\",\n                    util::lib_path_env_var(),\n                    util::make_new_path(path))\n@@ -1305,11 +1305,11 @@ fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: StrBuf) { println!(\"\\nerror: {}\", err); }\n+fn error(err: String) { println!(\"\\nerror: {}\", err); }\n \n-fn fatal(err: StrBuf) -> ! { error(err); fail!(); }\n+fn fatal(err: String) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: StrBuf, proc_res: &ProcRes) -> ! {\n+fn fatal_ProcRes(err: String, proc_res: &ProcRes) -> ! {\n     print!(\"\\n\\\n error: {}\\n\\\n status: {}\\n\\\n@@ -1331,15 +1331,15 @@ stderr:\\n\\\n fn _arm_exec_compiled_test(config: &Config,\n                            props: &TestProps,\n                            testfile: &Path,\n-                           env: Vec<(StrBuf, StrBuf)>)\n+                           env: Vec<(String, String)>)\n                            -> ProcRes {\n     let args = make_run_args(config, props, testfile);\n     let cmdline = make_cmdline(\"\",\n                                args.prog.as_slice(),\n                                args.args.as_slice());\n \n     // get bare program string\n-    let mut tvec: Vec<StrBuf> = args.prog\n+    let mut tvec: Vec<String> = args.prog\n                                     .as_slice()\n                                     .split('/')\n                                     .map(|ts| ts.to_strbuf())"}, {"sha": "5e69f3805738067200ae1d0dabebb30c23a7117f", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -33,7 +33,7 @@ pub fn get_os(triple: &str) -> &'static str {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn make_new_path(path: &str) -> StrBuf {\n+pub fn make_new_path(path: &str) -> String {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n@@ -46,12 +46,12 @@ pub fn make_new_path(path: &str) -> StrBuf {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn lib_path_env_var() -> StrBuf { \"PATH\".to_strbuf() }\n+pub fn lib_path_env_var() -> String { \"PATH\".to_strbuf() }\n \n #[cfg(target_os = \"win32\")]\n-pub fn path_div() -> StrBuf { \";\".to_strbuf() }\n+pub fn path_div() -> String { \";\".to_strbuf() }\n \n-pub fn logv(config: &Config, s: StrBuf) {\n+pub fn logv(config: &Config, s: String) {\n     debug!(\"{}\", s);\n     if config.verbose { println!(\"{}\", s); }\n }"}, {"sha": "3c41bb1b9d965fa0fa315f5040ba71885643f2fc", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,7 +8,7 @@ Use [`ToStr`](../std/to_str/trait.ToStr.html).\n \n ~~~\n let x: int = 42;\n-let y: StrBuf = x.to_str().to_strbuf();\n+let y: String = x.to_str().to_strbuf();\n ~~~\n \n **String to int**\n@@ -27,10 +27,10 @@ Use the `format_strbuf!` syntax extension.\n \n ~~~\n let x: int = 42;\n-let y: StrBuf = format_strbuf!(\"{:t}\", x);   // binary\n-let y: StrBuf = format_strbuf!(\"{:o}\", x);   // octal\n-let y: StrBuf = format_strbuf!(\"{:x}\", x);   // lowercase hexadecimal\n-let y: StrBuf = format_strbuf!(\"{:X}\", x);   // uppercase hexadecimal\n+let y: String = format_strbuf!(\"{:t}\", x);   // binary\n+let y: String = format_strbuf!(\"{:o}\", x);   // octal\n+let y: String = format_strbuf!(\"{:x}\", x);   // lowercase hexadecimal\n+let y: String = format_strbuf!(\"{:X}\", x);   // uppercase hexadecimal\n ~~~\n \n **String to int, in non-base-10**\n@@ -58,15 +58,15 @@ let x: Option<&str> = str::from_utf8(bytes);\n let y: &str = x.unwrap();\n ~~~\n \n-To return an Owned String (StrBuf) use the str helper function\n+To return an Owned String use the str helper function\n [`from_utf8_owned`](../std/str/fn.from_utf8_owned.html).\n \n ~~~\n use std::str;\n \n-let x: Option<StrBuf> =\n+let x: Option<String> =\n     str::from_utf8([ 104u8, 105u8 ]).map(|x| x.to_strbuf());\n-let y: StrBuf = x.unwrap();\n+let y: String = x.unwrap();\n ~~~\n \n To return a [`MaybeOwned`](../std/str/enum.MaybeOwned.html) use the str helper\n@@ -198,7 +198,7 @@ enum Closed {}\n Phantom types are useful for enforcing state at compile time. For example:\n \n ~~~\n-struct Door<State>(StrBuf);\n+struct Door<State>(String);\n \n struct Open;\n struct Closed;"}, {"sha": "5de7957cdab285fbf7b21ee35663a27fd0b555bf", "filename": "src/doc/favicon.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Ffavicon.inc", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Ffavicon.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ffavicon.inc?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1,3 +1,3 @@\n <link rel=\"shortcut icon\" href=\"http://www.rust-lang.org/favicon.ico\">\n <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400'\n-        rel='stylesheet' type='text/css'>\n\\ No newline at end of file\n+        rel='stylesheet' type='text/css'>"}, {"sha": "12a0ee6931ce2b4703cd5071d66f0cf4fcbc74b4", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -85,7 +85,7 @@ To take as an argument a fragment of Rust code, write `$` followed by a name\n   `foo`.)\n * `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n   `f(42)`.)\n-* `ty` (a type. Examples: `int`, `~[(char, StrBuf)]`, `&T`.)\n+* `ty` (a type. Examples: `int`, `~[(char, String)]`, `&T`.)\n * `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n   a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n * `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)"}, {"sha": "b0a0f10327c673045d5aecc0327043dd1145fb37", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -463,7 +463,7 @@ Here is the function that implements the child task:\n ~~~\n extern crate sync;\n # fn main() {\n-fn stringifier(channel: &sync::DuplexStream<StrBuf, uint>) {\n+fn stringifier(channel: &sync::DuplexStream<String, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n@@ -488,7 +488,7 @@ Here is the code for the parent task:\n extern crate sync;\n # use std::task::spawn;\n # use sync::DuplexStream;\n-# fn stringifier(channel: &sync::DuplexStream<StrBuf, uint>) {\n+# fn stringifier(channel: &sync::DuplexStream<String, uint>) {\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();"}, {"sha": "3b7bb2e740d46a58ca7c0689acd859c7da0991ef", "filename": "src/doc/po/ja/complement-cheatsheet.md.po", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -34,7 +34,7 @@ msgstr \"\"\n #, fuzzy\n #| msgid \"\"\n #| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n-msgid \"~~~ let x: int = 42; let y: StrBuf = x.to_str(); ~~~\"\n+msgid \"~~~ let x: int = 42; let y: String = x.to_str(); ~~~\"\n msgstr \"\"\n \"~~~~\\n\"\n \"let x: f64 = 4.0;\\n\"\n@@ -96,7 +96,7 @@ msgstr \"\"\n #, fuzzy\n #| msgid \"\"\n #| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n-msgid \"let x: int = 42; let y: StrBuf = x.to_str_radix(16); ~~~\"\n+msgid \"let x: int = 42; let y: String = x.to_str_radix(16); ~~~\"\n msgstr \"\"\n \"~~~~\\n\"\n \"let x: f64 = 4.0;\\n\""}, {"sha": "f0aef7accb6e1a0484f68cca36cf05bb4d3475b1", "filename": "src/doc/po/ja/rust.md.po", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Frust.md.po?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1641,7 +1641,7 @@ msgstr \"## \u6700\u5c0f\u9650\u306e\u4f8b\"\n msgid \"\"\n \"~~~~\\n\"\n \"trait Printable {\\n\"\n-\"  fn to_string(&self) -> StrBuf;\\n\"\n+\"  fn to_string(&self) -> String;\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -1656,7 +1656,7 @@ msgstr \"\"\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"impl Printable for int {\\n\"\n-\"  fn to_string(&self) -> StrBuf { self.to_str() }\\n\"\n+\"  fn to_string(&self) -> String { self.to_str() }\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -1702,7 +1702,7 @@ msgstr \"# \u30af\u30ed\u30fc\u30b8\u30e3\"\n msgid \"\"\n \"~~~~\\n\"\n \"trait Printable {\\n\"\n-\"  fn make_string(&self) -> StrBuf;\\n\"\n+\"  fn make_string(&self) -> String;\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -1716,8 +1716,8 @@ msgstr \"\"\n #, fuzzy, no-wrap\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n-\"impl Printable for StrBuf {\\n\"\n-\"    fn make_string(&self) -> StrBuf {\\n\"\n+\"impl Printable for String {\\n\"\n+\"    fn make_string(&self) -> String {\\n\"\n \"        (*self).clone()\\n\"\n \"    }\\n\"\n \"}\\n\""}, {"sha": "966d39b29f7de43d4dbb6f3e31e1ae58c7b87bb4", "filename": "src/doc/po/ja/tutorial.md.po", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -3755,15 +3755,15 @@ msgstr \"\"\n #| msgid \"\"\n #| \"Traits may be implemented for specific types with [impls]. An impl that \"\n #| \"implements a trait includes the name of the trait at the start of the \"\n-#| \"definition, as in the following impls of `Printable` for `int` and `StrBuf`.\"\n+#| \"definition, as in the following impls of `Printable` for `int` and `String`.\"\n msgid \"\"\n \"Traits may be implemented for specific types with [impls]. An impl for a \"\n \"particular trait gives an implementation of the methods that trait \"\n \"provides.  For instance, the following impls of `Printable` for `int` and \"\n-\"`StrBuf` give implementations of the `print` method.\"\n+\"`String` give implementations of the `print` method.\"\n msgstr \"\"\n \"[impl][impls] \u306b\u3088\u308a\u7279\u5b9a\u306e\u578b\u306b\u30c8\u30ec\u30a4\u30c8\u3092\u5b9f\u88c5\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u30c8\u30ec\u30a4\u30c8\u3092\u5b9f\"\n-\"\u88c5\u3059\u308b impl \u306f\u3001\u4ee5\u4e0b\u306e `Printable` \u306e `int` \u3068 `StrBuf` \u306b\u5bfe\u3059\u308b\u5b9f\u88c5\u306e\u3088\u3046\u306b\u3001\"\n+\"\u88c5\u3059\u308b impl \u306f\u3001\u4ee5\u4e0b\u306e `Printable` \u306e `int` \u3068 `String` \u306b\u5bfe\u3059\u308b\u5b9f\u88c5\u306e\u3088\u3046\u306b\u3001\"\n \"\u5b9a\u7fa9\u306e\u5148\u982d\u306b\u30c8\u30ec\u30a4\u30c8\u306e\u540d\u524d\u3092\u542b\u307f\u307e\u3059\u3002\"\n \n #. type: Plain text\n@@ -3776,7 +3776,7 @@ msgstr \"[impls]: #\u30e1\u30bd\u30c3\u30c9\"\n #, fuzzy, no-wrap\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n-\"impl Printable for StrBuf {\\n\"\n+\"impl Printable for String {\\n\"\n \"    fn print(&self) { println!(\\\"{}\\\", *self) }\\n\"\n \"}\\n\"\n msgstr \"\""}, {"sha": "d860c50f0a2154aa7712212f628c0d76dc70136c", "filename": "src/doc/rust.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -473,7 +473,7 @@ Two examples of paths with type arguments:\n # struct HashMap<K, V>;\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n-type T = HashMap<int,StrBuf>;  // Type arguments used in a type expression\n+type T = HashMap<int,String>;  // Type arguments used in a type expression\n let x = id::<int>(10);       // Type arguments used in a call expression\n # }\n ~~~~\n@@ -1260,8 +1260,8 @@ Enumeration constructors can have either named or unnamed fields:\n \n ~~~~\n enum Animal {\n-    Dog (StrBuf, f64),\n-    Cat { name: StrBuf, weight: f64 }\n+    Dog (String, f64),\n+    Cat { name: String, weight: f64 }\n }\n \n let mut a: Animal = Dog(\"Cocoa\".to_strbuf(), 37.2);\n@@ -2082,7 +2082,7 @@ These are functions:\n * `str_eq`\n   : Compare two strings (`&str`) for equality.\n * `uniq_str_eq`\n-  : Compare two owned strings (`StrBuf`) for equality.\n+  : Compare two owned strings (`String`) for equality.\n * `strdup_uniq`\n   : Return a new unique string\n     containing a copy of the contents of a unique string.\n@@ -3310,7 +3310,7 @@ A value of type `str` is a Unicode string,\n represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n Since `str` is of unknown size, it is not a _first class_ type,\n but can only be instantiated through a pointer type,\n-such as `&str` or `StrBuf`.\n+such as `&str` or `String`.\n \n ### Tuple types\n \n@@ -3574,11 +3574,11 @@ An example of an object type:\n \n ~~~~\n trait Printable {\n-  fn to_string(&self) -> StrBuf;\n+  fn to_string(&self) -> String;\n }\n \n impl Printable for int {\n-  fn to_string(&self) -> StrBuf { self.to_str().to_strbuf() }\n+  fn to_string(&self) -> String { self.to_str().to_strbuf() }\n }\n \n fn print(a: Box<Printable>) {\n@@ -3619,17 +3619,17 @@ example, in:\n \n ~~~~\n trait Printable {\n-  fn make_string(&self) -> StrBuf;\n+  fn make_string(&self) -> String;\n }\n \n-impl Printable for StrBuf {\n-    fn make_string(&self) -> StrBuf {\n+impl Printable for String {\n+    fn make_string(&self) -> String {\n         (*self).clone()\n     }\n }\n ~~~~\n \n-`self` refers to the value of type `StrBuf` that is the receiver for a\n+`self` refers to the value of type `String` that is the receiver for a\n call to the method `make_string`.\n \n ## Type kinds"}, {"sha": "3880503c8e56126d4263d5d728de46917a73e1ff", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -27,7 +27,7 @@ comments\":\n pub struct Widget {\n \t/// All widgets have a purpose (this is a doc comment, and will show up\n \t/// the field's documentation).\n-\tpurpose: StrBuf,\n+\tpurpose: String,\n \t/// Humans are not allowed to understand some widgets\n \tunderstandable: bool\n }"}, {"sha": "981c8a37085770b13ac4fb5da078c439d23975f6", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1581,7 +1581,7 @@ allocated memory on the heap. A unique vector owns the elements it contains, so\n the elements are mutable if the vector is mutable.\n \n ~~~\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n // A dynamically sized vector (unique vector)\n let mut numbers = vec![1, 2, 3];\n@@ -1593,7 +1593,7 @@ let more_numbers: Vec<int> = numbers.move_iter().map(|i| i+1).collect();\n \n // The original `numbers` value can no longer be used, due to move semantics.\n \n-let mut string = StrBuf::from_str(\"fo\");\n+let mut string = String::from_str(\"fo\");\n string.push_char('o');\n ~~~\n \n@@ -2213,7 +2213,7 @@ don't provide any methods.\n Traits may be implemented for specific types with [impls]. An impl for\n a particular trait gives an implementation of the methods that\n trait provides.  For instance, the following impls of\n-`Printable` for `int` and `StrBuf` give implementations of the `print`\n+`Printable` for `int` and `String` give implementations of the `print`\n method.\n \n [impls]: #methods\n@@ -2224,7 +2224,7 @@ impl Printable for int {\n     fn print(&self) { println!(\"{:?}\", *self) }\n }\n \n-impl Printable for StrBuf {\n+impl Printable for String {\n     fn print(&self) { println!(\"{}\", *self) }\n }\n \n@@ -2270,7 +2270,7 @@ trait Printable {\n \n impl Printable for int {}\n \n-impl Printable for StrBuf {\n+impl Printable for String {\n     fn print(&self) { println!(\"{}\", *self) }\n }\n \n@@ -2291,7 +2291,7 @@ provided in the trait definition.  Depending on the trait, default\n methods can save a great deal of boilerplate code from having to be\n written in impls.  Of course, individual impls can still override the\n default method for `print`, as is being done above in the impl for\n-`StrBuf`.\n+`String`.\n \n ## Type-parameterized traits\n "}, {"sha": "29da7c333bb72b3c1cc1d6d463b8acc792c16363", "filename": "src/etc/pkg/upgrade.iss", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fetc%2Fpkg%2Fupgrade.iss", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fetc%2Fpkg%2Fupgrade.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Fupgrade.iss?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -58,4 +58,4 @@ begin\n       UnInstallOldVersion();\n     end;\n   end;\n-end;\n\\ No newline at end of file\n+end;"}, {"sha": "77348335eb3464094ff1e49af9ccdb496f58e307", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -106,7 +106,7 @@ syn keyword rustTrait CloneableVector ImmutableCloneableVector MutableCloneableV\n syn keyword rustTrait ImmutableVector MutableVector\n syn keyword rustTrait ImmutableEqVector ImmutableTotalOrdVector MutableTotalOrdVector\n syn keyword rustTrait Vector VectorVector OwnedVector MutableVectorAllocating\n-syn keyword rustTrait StrBuf\n+syn keyword rustTrait String\n syn keyword rustTrait Vec\n \n \"syn keyword rustFunction sync_channel channel"}, {"sha": "42e426b5399747d16cadf03780e3bff3104c7968", "filename": "src/etc/x86.supp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -513,4 +513,4 @@\n    fun:uv__loop_init\n    fun:uv_loop_new\n    ...\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ce3fc46cf4ebfe73c9dae84a9e3a03a22e276077", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -538,7 +538,7 @@ mod tests {\n     }\n \n     struct Noncopy {\n-        string: StrBuf,\n+        string: String,\n         array: Vec<int> ,\n     }\n "}, {"sha": "f2059792500a2f7c13637a7dc71b14db68e7e6ad", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,7 +16,7 @@ use std::iter::RandomAccessIterator;\n use std::iter::{Enumerate, Repeat, Map, Zip};\n use std::ops;\n use std::slice;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n \n #[deriving(Clone)]\n@@ -532,8 +532,8 @@ impl Bitv {\n      * The resulting string has the same length as `self`, and each\n      * character is either '0' or '1'.\n      */\n-     pub fn to_str(&self) -> StrBuf {\n-        let mut rs = StrBuf::new();\n+     pub fn to_str(&self) -> String {\n+        let mut rs = String::new();\n         for i in self.iter() {\n             if i {\n                 rs.push_char('1');"}, {"sha": "91b725178f347f8682f54ea01beabdb81f29bd75", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -270,7 +270,7 @@ mod tests {\n \n     #[test]\n     fn test_put_update() {\n-        let mut cache: LruCache<StrBuf, Vec<u8>> = LruCache::new(1);\n+        let mut cache: LruCache<String, Vec<u8>> = LruCache::new(1);\n         cache.put(\"1\".to_strbuf(), vec![10, 10]);\n         cache.put(\"1\".to_strbuf(), vec![10, 19]);\n         assert_opt_eq(cache.get(&\"1\".to_strbuf()), vec![10, 19]);\n@@ -279,7 +279,7 @@ mod tests {\n \n     #[test]\n     fn test_expire_lru() {\n-        let mut cache: LruCache<StrBuf, StrBuf> = LruCache::new(2);\n+        let mut cache: LruCache<String, String> = LruCache::new(2);\n         cache.put(\"foo1\".to_strbuf(), \"bar1\".to_strbuf());\n         cache.put(\"foo2\".to_strbuf(), \"bar2\".to_strbuf());\n         cache.put(\"foo3\".to_strbuf(), \"bar3\".to_strbuf());"}, {"sha": "224f4ce1994621d3b47e2422f6c08e8418048fd4", "filename": "src/libcore/char.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -636,7 +636,7 @@ mod test {\n     use char::Char;\n     use slice::ImmutableVector;\n     use option::{Some, None};\n-    use realstd::strbuf::StrBuf;\n+    use realstd::string::String;\n     use realstd::str::{Str, StrAllocating};\n \n     #[test]\n@@ -742,8 +742,8 @@ mod test {\n \n     #[test]\n     fn test_escape_default() {\n-        fn string(c: char) -> StrBuf {\n-            let mut result = StrBuf::new();\n+        fn string(c: char) -> String {\n+            let mut result = String::new();\n             escape_default(c, |c| { result.push_char(c); });\n             return result;\n         }\n@@ -777,8 +777,8 @@ mod test {\n \n     #[test]\n     fn test_escape_unicode() {\n-        fn string(c: char) -> StrBuf {\n-            let mut result = StrBuf::new();\n+        fn string(c: char) -> String {\n+            let mut result = String::new();\n             escape_unicode(c, |c| { result.push_char(c); });\n             return result;\n         }"}, {"sha": "269dfa496eb0a8fc0d692b8189201632f3692442", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -171,7 +171,7 @@ pub trait Ord: Eq {\n /// The equivalence relation. Two values may be equivalent even if they are\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n-/// values to look up entries in a container with `StrBuf` keys.\n+/// values to look up entries in a container with `String` keys.\n pub trait Equiv<T> {\n     /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;"}, {"sha": "13236a1f654d0333eedce9337567c4f07428d7f0", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -594,7 +594,7 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n }\n \n #[cfg(test)]\n-pub fn format(args: &Arguments) -> ::realstd::strbuf::StrBuf {\n+pub fn format(args: &Arguments) -> ::realstd::string::String {\n     use str;\n     use realstd::str::StrAllocating;\n     use realstd::io::MemWriter;\n@@ -614,7 +614,7 @@ pub fn format(args: &Arguments) -> ::realstd::strbuf::StrBuf {\n     let mut i = MemWriter::new();\n     let _ = write(&mut i, args);\n \n-    let mut result = ::realstd::strbuf::StrBuf::new();\n+    let mut result = ::realstd::string::String::new();\n     result.push_str(str::from_utf8(i.get_ref()).unwrap());\n     result\n }"}, {"sha": "eac1f76d9f42373eff5af456af9f2e197e2993fa", "filename": "src/libcore/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -188,14 +188,14 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<StrBuf>` into an `Option<int>`, preserving the original.\n+    /// Convert an `Option<String>` into an `Option<int>`, preserving the original.\n     /// The `map` method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n     /// ```\n-    /// let num_as_str: Option<StrBuf> = Some(\"10\".to_strbuf());\n-    /// // First, cast `Option<StrBuf>` to `Option<&StrBuf>` with `as_ref`,\n+    /// let num_as_str: Option<String> = Some(\"10\".to_strbuf());\n+    /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n     /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n     /// println!(\"still can print num_as_str: {}\", num_as_str);\n@@ -278,10 +278,10 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<StrBuf>` into an `Option<uint>`, consuming the original:\n+    /// Convert an `Option<String>` into an `Option<uint>`, consuming the original:\n     ///\n     /// ```\n-    /// let num_as_str: Option<StrBuf> = Some(\"10\".to_strbuf());\n+    /// let num_as_str: Option<String> = Some(\"10\".to_strbuf());\n     /// // `Option::map` takes self *by value*, consuming `num_as_str`\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n@@ -596,7 +596,7 @@ pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) ->\n #[cfg(test)]\n mod tests {\n     use realstd::vec::Vec;\n-    use realstd::strbuf::StrBuf;\n+    use realstd::string::String;\n     use option::collect;\n     use prelude::*;\n     use realstd::str::{Str, StrAllocating};\n@@ -760,7 +760,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_unwrap_fail2() {\n-        let x: Option<StrBuf> = None;\n+        let x: Option<String> = None;\n         x.unwrap();\n     }\n "}, {"sha": "926605dddb3e6713606f4f7b8c717cdde4adccd4", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -170,7 +170,7 @@\n //! use std::io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n-//!     name: StrBuf,\n+//!     name: String,\n //!     age: int,\n //!     rating: int\n //! }\n@@ -196,7 +196,7 @@\n //! use std::io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n-//!     name: StrBuf,\n+//!     name: String,\n //!     age: int,\n //!     rating: int\n //! }\n@@ -429,7 +429,7 @@ impl<T, E> Result<T, E> {\n     /// let mut sum = 0;\n     ///\n     /// while !reader.eof() {\n-    ///     let line: IoResult<StrBuf> = reader.read_line();\n+    ///     let line: IoResult<String> = reader.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n     ///     let val: IoResult<int> = line.map(|line| {\n     ///         from_str::<int>(line.as_slice()).unwrap_or(0)\n@@ -637,7 +637,7 @@ pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n #[cfg(test)]\n mod tests {\n     use realstd::vec::Vec;\n-    use realstd::strbuf::StrBuf;\n+    use realstd::string::String;\n \n     use result::{collect, fold, fold_};\n     use prelude::*;"}, {"sha": "f575767b0bb54ba60733ad12dccaba5e4933b857", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -203,7 +203,7 @@ pub struct Parser<'a> {\n     cur: str::CharOffsets<'a>,\n     depth: uint,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<StrBuf>,\n+    pub errors: Vec<String>,\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n@@ -246,7 +246,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Notifies of an error. The message doesn't actually need to be of type\n-    /// StrBuf, but I think it does when this eventually uses conditions so it\n+    /// String, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n     fn err(&mut self, msg: &str) {\n         self.errors.push(msg.to_strbuf());"}, {"sha": "2039dcc7d14c51cc374c76249be337eb25c61ca1", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -34,7 +34,7 @@\n //! use getopts::{optopt,optflag,getopts,OptGroup};\n //! use std::os;\n //!\n-//! fn do_work(inp: &str, out: Option<StrBuf>) {\n+//! fn do_work(inp: &str, out: Option<String>) {\n //!     println!(\"{}\", inp);\n //!     match out {\n //!         Some(x) => println!(\"{}\", x),\n@@ -49,7 +49,7 @@\n //! }\n //!\n //! fn main() {\n-//!     let args: Vec<StrBuf> = os::args().iter()\n+//!     let args: Vec<String> = os::args().iter()\n //!                                       .map(|x| x.to_strbuf())\n //!                                       .collect();\n //!\n@@ -94,14 +94,14 @@\n use std::cmp::Eq;\n use std::result::{Err, Ok};\n use std::result;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n /// Name of an option. Either a string or a single char.\n #[deriving(Clone, Eq)]\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n-    Long(StrBuf),\n+    Long(String),\n     /// A char representing the short name of an option.\n     /// For example: 'h'\n     Short(char),\n@@ -147,13 +147,13 @@ pub struct Opt {\n #[deriving(Clone, Eq)]\n pub struct OptGroup {\n     /// Short Name of the `OptGroup`\n-    pub short_name: StrBuf,\n+    pub short_name: String,\n     /// Long Name of the `OptGroup`\n-    pub long_name: StrBuf,\n+    pub long_name: String,\n     /// Hint\n-    pub hint: StrBuf,\n+    pub hint: String,\n     /// Description\n-    pub desc: StrBuf,\n+    pub desc: String,\n     /// Whether it has an argument\n     pub hasarg: HasArg,\n     /// How often it can occur\n@@ -163,7 +163,7 @@ pub struct OptGroup {\n /// Describes wether an option is given at all or has a value.\n #[deriving(Clone, Eq)]\n enum Optval {\n-    Val(StrBuf),\n+    Val(String),\n     Given,\n }\n \n@@ -176,7 +176,7 @@ pub struct Matches {\n     /// Values of the Options that matched\n     vals: Vec<Vec<Optval> > ,\n     /// Free string fragments\n-    pub free: Vec<StrBuf>,\n+    pub free: Vec<String>,\n }\n \n /// The type returned when the command line does not conform to the\n@@ -185,15 +185,15 @@ pub struct Matches {\n #[deriving(Clone, Eq, Show)]\n pub enum Fail_ {\n     /// The option requires an argument but none was passed.\n-    ArgumentMissing(StrBuf),\n+    ArgumentMissing(String),\n     /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(StrBuf),\n+    UnrecognizedOption(String),\n     /// A required option is not present.\n-    OptionMissing(StrBuf),\n+    OptionMissing(String),\n     /// A single occurrence option is being used multiple times.\n-    OptionDuplicated(StrBuf),\n+    OptionDuplicated(String),\n     /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(StrBuf),\n+    UnexpectedArgument(String),\n }\n \n /// The type of failure that occurred.\n@@ -219,7 +219,7 @@ impl Name {\n         }\n     }\n \n-    fn to_str(&self) -> StrBuf {\n+    fn to_str(&self) -> String {\n         match *self {\n             Short(ch) => ch.to_str().to_strbuf(),\n             Long(ref s) => s.to_strbuf()\n@@ -299,7 +299,7 @@ impl Matches {\n     }\n \n     /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[StrBuf]) -> bool {\n+    pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n             match find_opt(self.opts.as_slice(),\n                            Name::from_str(nm.as_slice())) {\n@@ -311,7 +311,7 @@ impl Matches {\n     }\n \n     /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[StrBuf]) -> Option<StrBuf> {\n+    pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n             match self.opt_val(nm.as_slice()) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n@@ -325,8 +325,8 @@ impl Matches {\n     /// option.\n     ///\n     /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<StrBuf> {\n-        let mut acc: Vec<StrBuf> = Vec::new();\n+    pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n+        let mut acc: Vec<String> = Vec::new();\n         let r = self.opt_vals(nm);\n         for v in r.iter() {\n             match *v {\n@@ -338,10 +338,10 @@ impl Matches {\n     }\n \n     /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<StrBuf> {\n+    pub fn opt_str(&self, nm: &str) -> Option<String> {\n         let vals = self.opt_vals(nm);\n         if vals.is_empty() {\n-            return None::<StrBuf>;\n+            return None::<String>;\n         }\n         match vals.get(0) {\n             &Val(ref s) => Some((*s).clone()),\n@@ -355,7 +355,7 @@ impl Matches {\n     /// Returns none if the option was not present, `def` if the option was\n     /// present but no argument was provided, and the argument if the option was\n     /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<StrBuf> {\n+    pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n         let vals = self.opt_vals(nm);\n         if vals.is_empty() {\n             return None;\n@@ -496,7 +496,7 @@ pub fn opt(short_name: &str,\n \n impl Fail_ {\n     /// Convert a `Fail_` enum into an error string.\n-    pub fn to_err_msg(self) -> StrBuf {\n+    pub fn to_err_msg(self) -> String {\n         match self {\n             ArgumentMissing(ref nm) => {\n                 format_strbuf!(\"Argument to option '{}' missing.\", *nm)\n@@ -522,14 +522,14 @@ impl Fail_ {\n /// On success returns `Ok(Opt)`. Use methods such as `opt_present`\n /// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on failure.\n /// Use `to_err_msg` to get an error message.\n-pub fn getopts(args: &[StrBuf], optgrps: &[OptGroup]) -> Result {\n+pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n     let mut vals = Vec::from_fn(n_opts, f);\n-    let mut free: Vec<StrBuf> = Vec::new();\n+    let mut free: Vec<String> = Vec::new();\n     let l = args.len();\n     let mut i = 0;\n     while i < l {\n@@ -659,7 +659,7 @@ pub fn getopts(args: &[StrBuf], optgrps: &[OptGroup]) -> Result {\n }\n \n /// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n+pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n     let desc_sep = format!(\"\\n{}\", \" \".repeat(24));\n \n@@ -671,7 +671,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n                      hasarg: hasarg,\n                      ..} = (*optref).clone();\n \n-        let mut row = StrBuf::from_owned_str(\" \".repeat(4));\n+        let mut row = String::from_owned_str(\" \".repeat(4));\n \n         // short option\n         match short_name.len() {\n@@ -717,7 +717,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n         }\n \n         // Normalize desc to contain words separated by one space character\n-        let mut desc_normalized_whitespace = StrBuf::new();\n+        let mut desc_normalized_whitespace = String::new();\n         for word in desc.as_slice().words() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push_char(' ');\n@@ -741,11 +741,11 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n \n     format_strbuf!(\"{}\\n\\nOptions:\\n{}\\n\",\n                    brief,\n-                   rows.collect::<Vec<StrBuf>>().connect(\"\\n\"))\n+                   rows.collect::<Vec<String>>().connect(\"\\n\"))\n }\n \n-fn format_option(opt: &OptGroup) -> StrBuf {\n-    let mut line = StrBuf::new();\n+fn format_option(opt: &OptGroup) -> String {\n+    let mut line = String::new();\n \n     if opt.occur != Req {\n         line.push_char('[');\n@@ -782,11 +782,11 @@ fn format_option(opt: &OptGroup) -> StrBuf {\n }\n \n /// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> StrBuf {\n+pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     let mut line = format_strbuf!(\"Usage: {} \", program_name);\n     line.push_str(opts.iter()\n                       .map(format_option)\n-                      .collect::<Vec<StrBuf>>()\n+                      .collect::<Vec<String>>()\n                       .connect(\" \")\n                       .as_slice());\n     line\n@@ -898,7 +898,7 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n \n #[test]\n fn test_split_within() {\n-    fn t(s: &str, i: uint, u: &[StrBuf]) {\n+    fn t(s: &str, i: uint, u: &[String]) {\n         let mut v = Vec::new();\n         each_split_within(s, i, |s| { v.push(s.to_strbuf()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));"}, {"sha": "d2587746e0de6453d76ce9d3d8a4267a93784ee4", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -37,7 +37,7 @@ use std::cell::Cell;\n use std::{cmp, os, path};\n use std::io::fs;\n use std::path::is_sep;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n /**\n  * An iterator that yields Paths from the filesystem that match a particular\n@@ -310,8 +310,8 @@ impl Pattern {\n      * brackets. The resulting string will, when compiled into a `Pattern`,\n      * match the input string and nothing else.\n      */\n-    pub fn escape(s: &str) -> StrBuf {\n-        let mut escaped = StrBuf::new();\n+    pub fn escape(s: &str) -> String {\n+        let mut escaped = String::new();\n         for c in s.chars() {\n             match c {\n                 // note that ! does not need escaping because it is only special inside brackets\n@@ -464,8 +464,8 @@ impl Pattern {\n fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path: &Path,\n              options: MatchOptions) {\n     // convert a pattern that's just many Char(_) to a string\n-    fn pattern_as_str(pattern: &Pattern) -> Option<StrBuf> {\n-        let mut s = StrBuf::new();\n+    fn pattern_as_str(pattern: &Pattern) -> Option<String> {\n+        let mut s = String::new();\n         for token in pattern.tokens.iter() {\n             match *token {\n                 Char(c) => s.push_char(c),"}, {"sha": "15030da75d7147993eaf3519e7a85ede861c739f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -424,16 +424,16 @@ impl<'a> LabelText<'a> {\n             _ => c.escape_default(f)\n         }\n     }\n-    fn escape_str(s: &str) -> StrBuf {\n-        let mut out = StrBuf::with_capacity(s.len());\n+    fn escape_str(s: &str) -> String {\n+        let mut out = String::with_capacity(s.len());\n         for c in s.chars() {\n             LabelText::escape_char(c, |c| out.push_char(c));\n         }\n         out\n     }\n \n     /// Renders text as string suitable for a label in a .dot file.\n-    pub fn escape(&self) -> StrBuf {\n+    pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.as_slice().escape_default().to_strbuf(),\n             &EscStr(ref s) => LabelText::escape_str(s.as_slice()).to_strbuf(),\n@@ -661,7 +661,7 @@ mod tests {\n         }\n     }\n \n-    fn test_input(g: LabelledGraph) -> IoResult<StrBuf> {\n+    fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = MemWriter::new();\n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());"}, {"sha": "8f0630bbb86ea03ff4fcc488f170796885675ac8", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -70,7 +70,7 @@ pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n \n //Check if the literal is valid (as LLVM expects),\n //and return a descriptive error if not.\n-fn hex_float_lit_err(s: &str) -> Option<(uint, StrBuf)> {\n+fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n     let mut chars = s.chars().peekable();\n     let mut i = 0;\n     if chars.peek() == Some(&'-') { chars.next(); i+= 1 }"}, {"sha": "3569f8f54206902c8c2035564a587fb0632a834c", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@ use std::cmp;\n \n #[deriving(Show, Clone)]\n pub struct LogDirective {\n-    pub name: Option<StrBuf>,\n+    pub name: Option<String>,\n     pub level: u32,\n }\n "}, {"sha": "d1711c1b890bd522b96220277bdefa1c2cb84404", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -23,7 +23,7 @@ use super::IoResult;\n use super::file;\n use super::util;\n \n-#[cfg(windows)] use std::strbuf::StrBuf;\n+#[cfg(windows)] use std::string::String;\n #[cfg(unix)] use super::c;\n #[cfg(unix)] use super::retry;\n #[cfg(unix)] use io::helper_thread::Helper;\n@@ -396,8 +396,8 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n }\n \n #[cfg(windows)]\n-fn make_command_line(prog: &CString, args: &[CString]) -> StrBuf {\n-    let mut cmd = StrBuf::new();\n+fn make_command_line(prog: &CString, args: &[CString]) -> String {\n+    let mut cmd = String::new();\n     append_arg(&mut cmd, prog.as_str()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n     for arg in args.iter() {\n@@ -407,7 +407,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> StrBuf {\n     }\n     return cmd;\n \n-    fn append_arg(cmd: &mut StrBuf, arg: &str) {\n+    fn append_arg(cmd: &mut String, arg: &str) {\n         let quote = arg.chars().any(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n@@ -421,7 +421,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> StrBuf {\n         }\n     }\n \n-    fn append_char_at(cmd: &mut StrBuf, arg: &Vec<char>, i: uint) {\n+    fn append_char_at(cmd: &mut String, arg: &Vec<char>, i: uint) {\n         match *arg.get(i) {\n             '\"' => {\n                 // Escape quotes.\n@@ -1093,7 +1093,7 @@ mod tests {\n         use std::c_str::CString;\n         use super::make_command_line;\n \n-        fn test_wrapper(prog: &str, args: &[&str]) -> StrBuf {\n+        fn test_wrapper(prog: &str, args: &[&str]) -> String {\n             make_command_line(&prog.to_c_str(),\n                               args.iter()\n                                   .map(|a| a.to_c_str())"}, {"sha": "88a4807184c85c4438d487547a7cf085476341ac", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -26,7 +26,7 @@ use std::num::CheckedDiv;\n use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use rand::Rng;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n use std::{i64, u64};\n \n@@ -604,7 +604,7 @@ impl_to_biguint!(u32,  FromPrimitive::from_u32)\n impl_to_biguint!(u64,  FromPrimitive::from_u64)\n \n impl ToStrRadix for BigUint {\n-    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+    fn to_str_radix(&self, radix: uint) -> String {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n@@ -627,11 +627,11 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n-        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> StrBuf {\n+        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> String {\n             if v.is_empty() {\n                 return \"0\".to_strbuf()\n             }\n-            let mut s = StrBuf::with_capacity(v.len() * l);\n+            let mut s = String::with_capacity(v.len() * l);\n             for n in v.iter().rev() {\n                 let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()).as_slice());\n@@ -1211,7 +1211,7 @@ impl_to_bigint!(u64,  FromPrimitive::from_u64)\n \n impl ToStrRadix for BigInt {\n     #[inline]\n-    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+    fn to_str_radix(&self, radix: uint) -> String {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n             Zero  => \"0\".to_strbuf(),\n@@ -2029,7 +2029,7 @@ mod biguint_tests {\n         assert!(((one << 64) + one).is_odd());\n     }\n \n-    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, StrBuf)>)> {\n+    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, String)>)> {\n         let bits = BigDigit::bits;\n         vec!(( Zero::zero(), vec!(\n             (2, \"0\".to_strbuf()), (3, \"0\".to_strbuf())"}, {"sha": "5ba67f3fccf567b697f4e15236951199a5451bdb", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -175,7 +175,7 @@ impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n }\n \n impl<T: ToStrRadix + Num + Ord> ToStrRadix for Complex<T> {\n-    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+    fn to_str_radix(&self, radix: uint) -> String {\n         if self.im < Zero::zero() {\n             format_strbuf!(\"{}-{}i\",\n                            self.re.to_str_radix(radix),\n@@ -348,7 +348,7 @@ mod test {\n \n     #[test]\n     fn test_to_str() {\n-        fn test(c : Complex64, s: StrBuf) {\n+        fn test(c : Complex64, s: String) {\n             assert_eq!(c.to_str().to_strbuf(), s);\n         }\n         test(_0_0i, \"0+0i\".to_strbuf());"}, {"sha": "a51d1d1690587ef92a02c1fd3e0371ee1d4cab6f", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -281,7 +281,7 @@ impl<T: fmt::Show> fmt::Show for Ratio<T> {\n }\n impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     /// Renders as `numer/denom` where the numbers are in base `radix`.\n-    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+    fn to_str_radix(&self, radix: uint) -> String {\n         format_strbuf!(\"{}/{}\",\n                        self.numer.to_str_radix(radix),\n                        self.denom.to_str_radix(radix))\n@@ -557,7 +557,7 @@ mod test {\n \n     #[test]\n     fn test_to_from_str() {\n-        fn test(r: Rational, s: StrBuf) {\n+        fn test(r: Rational, s: String) {\n             assert_eq!(FromStr::from_str(s.as_slice()), Some(r));\n             assert_eq!(r.to_str().to_strbuf(), s);\n         }\n@@ -583,13 +583,13 @@ mod test {\n \n     #[test]\n     fn test_to_from_str_radix() {\n-        fn test(r: Rational, s: StrBuf, n: uint) {\n+        fn test(r: Rational, s: String, n: uint) {\n             assert_eq!(FromStrRadix::from_str_radix(s.as_slice(), n),\n                        Some(r));\n             assert_eq!(r.to_str_radix(n).to_strbuf(), s);\n         }\n-        fn test3(r: Rational, s: StrBuf) { test(r, s, 3) }\n-        fn test16(r: Rational, s: StrBuf) { test(r, s, 16) }\n+        fn test3(r: Rational, s: String) { test(r, s, 3) }\n+        fn test16(r: Rational, s: String) { test(r, s, 16) }\n \n         test3(_1, \"1/1\".to_strbuf());\n         test3(_0, \"0/1\".to_strbuf());"}, {"sha": "95c56152df66da230a8ffeb5347210cac37bc676", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -86,7 +86,7 @@ println!(\"{:?}\", tuple_ptr)\n use std::io::IoResult;\n use std::kinds::marker;\n use std::mem;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use os::OSRng;\n@@ -260,11 +260,11 @@ pub trait Rng {\n     ///\n     /// println!(\"{}\", task_rng().gen_ascii_str(10));\n     /// ```\n-    fn gen_ascii_str(&mut self, len: uint) -> StrBuf {\n+    fn gen_ascii_str(&mut self, len: uint) -> String {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                                              abcdefghijklmnopqrstuvwxyz\\\n                                                              0123456789\");\n-        let mut s = StrBuf::with_capacity(len);\n+        let mut s = String::with_capacity(len);\n         for _ in range(0, len) {\n             s.push_char(*self.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n         }"}, {"sha": "91bbb23c337d0065764460f05231555d987ed620", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -83,12 +83,12 @@ pub struct Program {\n     /// If the regular expression requires a literal prefix in order to have a\n     /// match, that prefix is stored here. (It's used in the VM to implement\n     /// an optimization.)\n-    pub prefix: StrBuf,\n+    pub prefix: String,\n }\n \n impl Program {\n     /// Compiles a Regex given its AST.\n-    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<StrBuf>>) {\n+    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<String>>) {\n         let mut c = Compiler {\n             insts: Vec::with_capacity(100),\n             names: Vec::with_capacity(10),\n@@ -102,7 +102,7 @@ impl Program {\n         // Try to discover a literal string prefix.\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n-        let mut pre = StrBuf::with_capacity(5);\n+        let mut pre = String::with_capacity(5);\n         for inst in c.insts.slice_from(1).iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push_char(c),\n@@ -135,7 +135,7 @@ impl Program {\n \n struct Compiler<'r> {\n     insts: Vec<Inst>,\n-    names: Vec<Option<StrBuf>>,\n+    names: Vec<Option<String>>,\n }\n \n // The compiler implemented here is extremely simple. Most of the complexity"}, {"sha": "bc365582ca444469c74d59e96c981ee75837cb9f", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -32,7 +32,7 @@ pub struct Error {\n     /// The *approximate* character index of where the error occurred.\n     pub pos: uint,\n     /// A message describing the error.\n-    pub msg: StrBuf,\n+    pub msg: String,\n }\n \n impl fmt::Show for Error {\n@@ -59,7 +59,7 @@ pub enum Ast {\n     Begin(Flags),\n     End(Flags),\n     WordBoundary(Flags),\n-    Capture(uint, Option<StrBuf>, Box<Ast>),\n+    Capture(uint, Option<String>, Box<Ast>),\n     // Represent concatenation as a flat vector to avoid blowing the\n     // stack in the compiler.\n     Cat(Vec<Ast>),\n@@ -104,7 +104,7 @@ impl Greed {\n #[deriving(Show)]\n enum BuildAst {\n     Ast(Ast),\n-    Paren(Flags, uint, StrBuf), // '('\n+    Paren(Flags, uint, String), // '('\n     Bar, // '|'\n }\n \n@@ -131,7 +131,7 @@ impl BuildAst {\n         }\n     }\n \n-    fn capture_name(&self) -> Option<StrBuf> {\n+    fn capture_name(&self) -> Option<String> {\n         match *self {\n             Paren(_, 0, _) => None,\n             Paren(_, _, ref name) => {\n@@ -185,7 +185,7 @@ struct Parser<'a> {\n     // opening a capture group).\n     caps: uint,\n     // A set of all capture group names used only to detect duplicates.\n-    names: Vec<StrBuf>,\n+    names: Vec<String>,\n }\n \n pub fn parse(s: &str) -> Result<Ast, Error> {\n@@ -625,7 +625,7 @@ impl<'a> Parser<'a> {\n     // character).\n     fn parse_unicode_name(&mut self) -> Result<Ast, Error> {\n         let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n-        let mut name: StrBuf;\n+        let mut name: String;\n         if self.peek_is(1, '{') {\n             try!(self.expect('{'))\n             let closer =\n@@ -941,7 +941,7 @@ impl<'a> Parser<'a> {\n         *self.chars.get(self.chari)\n     }\n \n-    fn slice(&self, start: uint, end: uint) -> StrBuf {\n+    fn slice(&self, start: uint, end: uint) -> String {\n         str::from_chars(self.chars.as_slice().slice(start, end)).to_strbuf()\n     }\n }"}, {"sha": "f80327c5ec78908d84f6a67447c56db4a29cb89e", "filename": "src/libregex/re.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -20,8 +20,8 @@ use vm::{CaptureLocs, MatchKind, Exists, Location, Submatches};\n \n /// Escapes all regular expression meta characters in `text` so that it may be\n /// safely used in a regular expression as a literal string.\n-pub fn quote(text: &str) -> StrBuf {\n-    let mut quoted = StrBuf::with_capacity(text.len());\n+pub fn quote(text: &str) -> String {\n+    let mut quoted = String::with_capacity(text.len());\n     for c in text.chars() {\n         if parse::is_punct(c) {\n             quoted.push_char('\\\\')\n@@ -107,9 +107,9 @@ pub struct Regex {\n     /// See the comments for the `program` module in `lib.rs` for a more\n     /// detailed explanation for what `regex!` requires.\n     #[doc(hidden)]\n-    pub original: StrBuf,\n+    pub original: String,\n     #[doc(hidden)]\n-    pub names: Vec<Option<StrBuf>>,\n+    pub names: Vec<Option<String>>,\n     #[doc(hidden)]\n     pub p: MaybeNative,\n }\n@@ -407,7 +407,7 @@ impl Regex {\n     /// ```\n     ///\n     /// But anything satisfying the `Replacer` trait will work. For example,\n-    /// a closure of type `|&Captures| -> StrBuf` provides direct access to the\n+    /// a closure of type `|&Captures| -> String` provides direct access to the\n     /// captures corresponding to a match. This allows one to access\n     /// submatches easily:\n     ///\n@@ -456,7 +456,7 @@ impl Regex {\n     /// assert_eq!(result.as_slice(), \"$2 $last\");\n     /// # }\n     /// ```\n-    pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> StrBuf {\n+    pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> String {\n         self.replacen(text, 1, rep)\n     }\n \n@@ -466,7 +466,7 @@ impl Regex {\n     ///\n     /// See the documentation for `replace` for details on how to access\n     /// submatches in the replacement string.\n-    pub fn replace_all<R: Replacer>(&self, text: &str, rep: R) -> StrBuf {\n+    pub fn replace_all<R: Replacer>(&self, text: &str, rep: R) -> String {\n         self.replacen(text, 0, rep)\n     }\n \n@@ -477,8 +477,8 @@ impl Regex {\n     /// See the documentation for `replace` for details on how to access\n     /// submatches in the replacement string.\n     pub fn replacen<R: Replacer>\n-                   (&self, text: &str, limit: uint, mut rep: R) -> StrBuf {\n-        let mut new = StrBuf::with_capacity(text.len());\n+                   (&self, text: &str, limit: uint, mut rep: R) -> String {\n+        let mut new = String::with_capacity(text.len());\n         let mut last_match = 0u;\n \n         for (i, cap) in self.captures_iter(text).enumerate() {\n@@ -529,7 +529,7 @@ impl<'t> Replacer for &'t str {\n     }\n }\n \n-impl<'a> Replacer for |&Captures|: 'a -> StrBuf {\n+impl<'a> Replacer for |&Captures|: 'a -> String {\n     fn reg_replace<'r>(&'r mut self, caps: &Captures) -> MaybeOwned<'r> {\n         Owned((*self)(caps).into_owned())\n     }\n@@ -608,7 +608,7 @@ impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n pub struct Captures<'t> {\n     text: &'t str,\n     locs: CaptureLocs,\n-    named: Option<HashMap<StrBuf, uint>>,\n+    named: Option<HashMap<String, uint>>,\n }\n \n impl<'t> Captures<'t> {\n@@ -706,11 +706,11 @@ impl<'t> Captures<'t> {\n     /// isn't a valid index), then it is replaced with the empty string.\n     ///\n     /// To write a literal `$` use `$$`.\n-    pub fn expand(&self, text: &str) -> StrBuf {\n+    pub fn expand(&self, text: &str) -> String {\n         // How evil can you get?\n         // FIXME: Don't use regexes for this. It's completely unnecessary.\n         let re = Regex::new(r\"(^|[^$]|\\b)\\$(\\w+)\").unwrap();\n-        let text = re.replace_all(text, |refs: &Captures| -> StrBuf {\n+        let text = re.replace_all(text, |refs: &Captures| -> String {\n             let (pre, name) = (refs.at(1), refs.at(2));\n             format_strbuf!(\"{}{}\",\n                            pre,"}, {"sha": "5bbb37c2490ff58e2ed6496f708d0868fbe7ef12", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -153,7 +153,7 @@ fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n #[allow(deprecated_owned_vector)]\n-fn gen_text(n: uint) -> StrBuf {\n+fn gen_text(n: uint) -> String {\n     let mut rng = task_rng();\n     let mut bytes = rng.gen_ascii_str(n).into_bytes();\n     for (i, b) in bytes.mut_iter().enumerate() {"}, {"sha": "68d43156ae63194734b2886564ff2c74c366fbf0", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -34,7 +34,7 @@ macro_rules! replace(\n         #[test]\n         fn $name() {\n             let re = regex!($re);\n-            assert_eq!(re.$which($search, $replace), StrBuf::from_str($result));\n+            assert_eq!(re.$which($search, $replace), String::from_str($result));\n         }\n     );\n )"}, {"sha": "f27cba415111bfff22a1c1b0bd93a2a16a13a895", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -105,8 +105,8 @@ struct NfaGen<'a> {\n     cx: &'a ExtCtxt<'a>,\n     sp: codemap::Span,\n     prog: Program,\n-    names: Vec<Option<StrBuf>>,\n-    original: StrBuf,\n+    names: Vec<Option<String>>,\n+    original: String,\n }\n \n impl<'a> NfaGen<'a> {\n@@ -601,7 +601,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n /// Looks for a single string literal and returns it.\n /// Otherwise, logs an error with cx.span_err and returns None.\n-fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<StrBuf> {\n+fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(),\n                                                 Vec::from_slice(tts));\n     let entry = cx.expand_expr(parser.parse_expr());"}, {"sha": "d7875d47c6ac4c1c8e4753e8977fd7ad8a0bafe3", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -134,7 +134,7 @@ impl<'a> Archive<'a> {\n     }\n \n     /// Lists all files in an archive\n-    pub fn files(&self) -> Vec<StrBuf> {\n+    pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n         let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of"}, {"sha": "fcce2fe25035a92c293bd470ada32a5c85c2f981", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     let cc_args = if target_triple.as_slice().contains(\"thumb\") {\n         vec!(\"-mthumb\".to_strbuf())\n     } else {"}, {"sha": "89a79dbb80d896c185e3072d6b47f92f3fa8ca35", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -33,7 +33,7 @@ use std::io::{fs, TempDir, Command};\n use std::io;\n use std::ptr;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use flate;\n use serialize::hex::ToHex;\n use syntax::abi;\n@@ -54,7 +54,7 @@ pub enum OutputType {\n     OutputTypeExe,\n }\n \n-pub fn llvm_err(sess: &Session, msg: StrBuf) -> ! {\n+pub fn llvm_err(sess: &Session, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -541,14 +541,14 @@ pub fn find_crate_id(attrs: &[ast::Attribute], out_filestem: &str) -> CrateId {\n     match attr::find_crateid(attrs) {\n         None => from_str(out_filestem).unwrap_or_else(|| {\n             let mut s = out_filestem.chars().filter(|c| c.is_XID_continue());\n-            from_str(s.collect::<StrBuf>().as_slice())\n+            from_str(s.collect::<String>().as_slice())\n                 .or(from_str(\"rust-out\")).unwrap()\n         }),\n         Some(s) => s,\n     }\n }\n \n-pub fn crate_id_hash(crate_id: &CrateId) -> StrBuf {\n+pub fn crate_id_hash(crate_id: &CrateId) -> String {\n     // This calculates CMH as defined above. Note that we don't use the path of\n     // the crate id in the hash because lookups are only done by (name/vers),\n     // not by path.\n@@ -567,7 +567,7 @@ pub fn build_link_meta(krate: &ast::Crate, out_filestem: &str) -> LinkMeta {\n     return r;\n }\n \n-fn truncated_hash_result(symbol_hasher: &mut Sha256) -> StrBuf {\n+fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n     let output = symbol_hasher.result_bytes();\n     // 64 bits should be enough to avoid collisions.\n     output.slice_to(8).to_hex().to_strbuf()\n@@ -579,7 +579,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n                symbol_hasher: &mut Sha256,\n                t: ty::t,\n                link_meta: &LinkMeta)\n-               -> StrBuf {\n+               -> String {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -590,12 +590,12 @@ fn symbol_hash(tcx: &ty::ctxt,\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(encoder::encoded_ty(tcx, t).as_slice());\n     // Prefix with 'h' so that it never blends into adjacent digits\n-    let mut hash = StrBuf::from_str(\"h\");\n+    let mut hash = String::from_str(\"h\");\n     hash.push_str(truncated_hash_result(symbol_hasher).as_slice());\n     hash\n }\n \n-fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> StrBuf {\n+fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n     match ccx.type_hashcodes.borrow().find(&t) {\n         Some(h) => return h.to_strbuf(),\n         None => {}\n@@ -611,8 +611,8 @@ fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> StrBuf {\n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> StrBuf {\n-    let mut result = StrBuf::new();\n+pub fn sanitize(s: &str) -> String {\n+    let mut result = String::new();\n     for c in s.chars() {\n         match c {\n             // Escape these with $ sequences\n@@ -637,7 +637,7 @@ pub fn sanitize(s: &str) -> StrBuf {\n             | '_' | '.' | '$' => result.push_char(c),\n \n             _ => {\n-                let mut tstr = StrBuf::new();\n+                let mut tstr = String::new();\n                 char::escape_unicode(c, |c| tstr.push_char(c));\n                 result.push_char('$');\n                 result.push_str(tstr.as_slice().slice_from(1));\n@@ -657,7 +657,7 @@ pub fn sanitize(s: &str) -> StrBuf {\n \n pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n                                       hash: Option<&str>,\n-                                      vers: Option<&str>) -> StrBuf {\n+                                      vers: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -672,9 +672,9 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n     // To be able to work on all platforms and get *some* reasonable output, we\n     // use C++ name-mangling.\n \n-    let mut n = StrBuf::from_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+    let mut n = String::from_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n \n-    fn push(n: &mut StrBuf, s: &str) {\n+    fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n         n.push_str(format!(\"{}{}\", sani.len(), sani).as_slice());\n     }\n@@ -697,7 +697,7 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n     n\n }\n \n-pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> StrBuf {\n+pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> String {\n     // The version will get mangled to have a leading '_', but it makes more\n     // sense to lead with a 'v' b/c this is a version...\n     let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n@@ -710,7 +710,7 @@ pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> StrBuf {\n }\n \n pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n-                            t: ty::t, id: ast::NodeId) -> StrBuf {\n+                            t: ty::t, id: ast::NodeId) -> String {\n     let mut hash = get_symbol_hash(ccx, t);\n \n     // Paths can be completely identical for different nodes,\n@@ -738,26 +738,26 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n-                                            name: &str) -> StrBuf {\n+                                            name: &str) -> String {\n     let s = ppaux::ty_to_str(ccx.tcx(), t);\n     let path = [PathName(token::intern(s.as_slice())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(ast_map::Values(path.iter()), Some(hash.as_slice()), None)\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> StrBuf {\n+pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n     mangle(path.chain(Some(gensym_name(flav)).move_iter()), None, None)\n }\n \n-pub fn output_lib_filename(id: &CrateId) -> StrBuf {\n+pub fn output_lib_filename(id: &CrateId) -> String {\n     format_strbuf!(\"{}-{}-{}\",\n                    id.name,\n                    crate_id_hash(id),\n                    id.version_or_default())\n }\n \n-pub fn get_cc_prog(sess: &Session) -> StrBuf {\n+pub fn get_cc_prog(sess: &Session) -> String {\n     match sess.opts.cg.linker {\n         Some(ref linker) => return linker.to_strbuf(),\n         None => {}\n@@ -773,7 +773,7 @@ pub fn get_cc_prog(sess: &Session) -> StrBuf {\n     }.to_strbuf()\n }\n \n-pub fn get_ar_prog(sess: &Session) -> StrBuf {\n+pub fn get_ar_prog(sess: &Session) -> String {\n     match sess.opts.cg.ar {\n         Some(ref ar) => (*ar).clone(),\n         None => \"ar\".to_strbuf()"}, {"sha": "372d66003f2dab8d347fb20b3d0d34ce9c182967", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -20,7 +20,7 @@ use libc;\n use flate;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n-           tm: TargetMachineRef, reachable: &[StrBuf]) {\n+           tm: TargetMachineRef, reachable: &[String]) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.err(\"cannot prefer dynamic linking when performing LTO\");\n         sess.note(\"only 'staticlib' and 'bin' outputs are supported with LTO\");"}, {"sha": "3b9ec546a10a1458b6072c5943bba5b242a8362c", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_strbuf(),\n "}, {"sha": "f99515603b2321f278ab7c8620828570e455ae57", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -22,7 +22,7 @@ fn not_win32(os: abi::Os) -> bool {\n   os != abi::OsWin32\n }\n \n-pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<StrBuf> {\n+pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<String> {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -56,7 +56,7 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<StrBuf> {\n     flags\n }\n \n-pub fn rpaths_to_flags(rpaths: &[StrBuf]) -> Vec<StrBuf> {\n+pub fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n         ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).as_slice()));\n@@ -68,7 +68,7 @@ fn get_rpaths(os: abi::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n-              target_triple: &str) -> Vec<StrBuf> {\n+              target_triple: &str) -> Vec<String> {\n     debug!(\"sysroot: {}\", sysroot.display());\n     debug!(\"output: {}\", output.display());\n     debug!(\"libs:\");\n@@ -85,7 +85,7 @@ fn get_rpaths(os: abi::Os,\n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = vec!(get_install_prefix_rpath(sysroot, target_triple));\n \n-    fn log_rpaths(desc: &str, rpaths: &[StrBuf]) {\n+    fn log_rpaths(desc: &str, rpaths: &[String]) {\n         debug!(\"{} rpaths:\", desc);\n         for rpath in rpaths.iter() {\n             debug!(\"    {}\", *rpath);\n@@ -105,14 +105,14 @@ fn get_rpaths(os: abi::Os,\n \n fn get_rpaths_relative_to_output(os: abi::Os,\n                                  output: &Path,\n-                                 libs: &[Path]) -> Vec<StrBuf> {\n+                                 libs: &[Path]) -> Vec<String> {\n     libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: abi::Os,\n                                     output: &Path,\n                                     lib: &Path)\n-                                 -> StrBuf {\n+                                 -> String {\n     use std::os;\n \n     assert!(not_win32(os));\n@@ -137,7 +137,7 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n             relative.as_str().expect(\"non-utf8 component in path\"))\n }\n \n-pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> StrBuf {\n+pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> String {\n     let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n \n     let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -148,7 +148,7 @@ pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> StrBuf {\n     path.as_str().expect(\"non-utf8 component in rpath\").to_strbuf()\n }\n \n-pub fn minimize_rpaths(rpaths: &[StrBuf]) -> Vec<StrBuf> {\n+pub fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {"}, {"sha": "00dbb3da39a904ef5baf0bc95485d6c3010526d7", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -55,7 +55,7 @@ use syntax::visit;\n \n #[deriving(Clone, Eq)]\n pub struct Svh {\n-    hash: StrBuf,\n+    hash: String,\n }\n \n impl Svh {"}, {"sha": "ed5976ad508baa8619aae4bebb688dc7945b4e1b", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,9 +11,9 @@\n #![allow(non_camel_case_types)]\n \n pub struct t {\n-    pub module_asm: StrBuf,\n-    pub meta_sect_name: StrBuf,\n-    pub data_layout: StrBuf,\n-    pub target_triple: StrBuf,\n-    pub cc_args: Vec<StrBuf> ,\n+    pub module_asm: String,\n+    pub meta_sect_name: String,\n+    pub data_layout: String,\n+    pub target_triple: String,\n+    pub cc_args: Vec<String> ,\n }"}, {"sha": "c9c007185b8b2a54e786007524445beb6fd8b9f0", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os)\n+pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n                        -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_strbuf(),"}, {"sha": "bd8d7f13e4efbcd1c815d19b2e67a6cdd6b85cdd", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: \"\".to_strbuf(),\n "}, {"sha": "df79e71436c7f11f3af4b8006a5743429d4b019f", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -77,7 +77,7 @@ pub struct Options {\n     // this.\n     pub addl_lib_search_paths: RefCell<HashSet<Path>>,\n     pub maybe_sysroot: Option<Path>,\n-    pub target_triple: StrBuf,\n+    pub target_triple: String,\n     // User-specified cfg meta items. The compiler itself will add additional\n     // items to the crate config, and during parsing the entire crate config\n     // will be added to the crate AST node.  This should not be used for\n@@ -250,21 +250,21 @@ macro_rules! cgoptions(\n             }\n         }\n \n-        fn parse_opt_string(slot: &mut Option<StrBuf>, v: Option<&str>) -> bool {\n+        fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = Some(s.to_strbuf()); true },\n                 None => false,\n             }\n         }\n \n-        fn parse_string(slot: &mut StrBuf, v: Option<&str>) -> bool {\n+        fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.to_strbuf(); true },\n                 None => false,\n             }\n         }\n \n-        fn parse_list(slot: &mut Vec<StrBuf>, v: Option<&str>)\n+        fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n                       -> bool {\n             match v {\n                 Some(s) => {\n@@ -281,19 +281,19 @@ macro_rules! cgoptions(\n ) )\n \n cgoptions!(\n-    ar: Option<StrBuf> = (None, parse_opt_string,\n+    ar: Option<String> = (None, parse_opt_string,\n         \"tool to assemble archives with\"),\n-    linker: Option<StrBuf> = (None, parse_opt_string,\n+    linker: Option<String> = (None, parse_opt_string,\n         \"system linker to link outputs with\"),\n-    link_args: Vec<StrBuf> = (Vec::new(), parse_list,\n+    link_args: Vec<String> = (Vec::new(), parse_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n-    target_cpu: StrBuf = (\"generic\".to_strbuf(), parse_string,\n+    target_cpu: String = (\"generic\".to_strbuf(), parse_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n-    target_feature: StrBuf = (\"\".to_strbuf(), parse_string,\n+    target_feature: String = (\"\".to_strbuf(), parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n-    passes: Vec<StrBuf> = (Vec::new(), parse_list,\n+    passes: Vec<String> = (Vec::new(), parse_list,\n         \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<StrBuf> = (Vec::new(), parse_list,\n+    llvm_args: Vec<String> = (Vec::new(), parse_list,\n         \"a list of arguments to pass to llvm (space separated)\"),\n     save_temps: bool = (false, parse_bool,\n         \"save all temporary output files during compilation\"),\n@@ -311,7 +311,7 @@ cgoptions!(\n         \"prefer dynamic linking to static linking\"),\n     no_integrated_as: bool = (false, parse_bool,\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    relocation_model: StrBuf = (\"pic\".to_strbuf(), parse_string,\n+    relocation_model: String = (\"pic\".to_strbuf(), parse_string,\n          \"choose the relocation model to use (llc -relocation-model for details)\"),\n )\n \n@@ -555,7 +555,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n \n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: Vec<StrBuf> ) -> ast::CrateConfig {\n+fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         parse::parse_meta_from_source_str(\"cfgspec\".to_strbuf(),\n                                           s.to_strbuf(),"}, {"sha": "5f5b30c9c708a2c0cd841a603f3c1d1f03ce42a6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -105,11 +105,11 @@ pub fn compile_input(sess: Session,\n  * The name used for source code that doesn't originate in a file\n  * (e.g. source from stdin or a string)\n  */\n-pub fn anon_src() -> StrBuf {\n+pub fn anon_src() -> String {\n     \"<anon>\".to_strbuf()\n }\n \n-pub fn source_name(input: &Input) -> StrBuf {\n+pub fn source_name(input: &Input) -> String {\n     match *input {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         FileInput(ref ifile) => ifile.as_str().unwrap().to_strbuf(),\n@@ -121,11 +121,11 @@ pub enum Input {\n     /// Load source from file\n     FileInput(Path),\n     /// The string is the source\n-    StrInput(StrBuf)\n+    StrInput(String)\n }\n \n impl Input {\n-    fn filestem(&self) -> StrBuf {\n+    fn filestem(&self) -> String {\n         match *self {\n             FileInput(ref ifile) => ifile.filestem_str().unwrap().to_strbuf(),\n             StrInput(_) => \"rust_out\".to_strbuf(),\n@@ -360,7 +360,7 @@ pub struct CrateTranslation {\n     pub metadata_module: ModuleRef,\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,\n-    pub reachable: Vec<StrBuf>,\n+    pub reachable: Vec<String>,\n     pub crate_formats: dependency_format::Dependencies,\n     pub no_builtins: bool,\n }\n@@ -495,7 +495,7 @@ fn write_out_deps(sess: &Session,\n     let result = (|| {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n-        let files: Vec<StrBuf> = sess.codemap().files.borrow()\n+        let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n                                    .map(|fmap| fmap.name.to_strbuf())\n                                    .collect();\n@@ -780,7 +780,7 @@ pub fn collect_crate_types(session: &Session,\n \n pub struct OutputFilenames {\n     pub out_directory: Path,\n-    pub out_filestem: StrBuf,\n+    pub out_filestem: String,\n     pub single_output_file: Option<Path>,\n }\n "}, {"sha": "e764b07a828b00003c77c8439877b8c9fab2c2e0", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -35,7 +35,7 @@ pub mod session;\n pub mod config;\n \n \n-pub fn main_args(args: &[StrBuf]) -> int {\n+pub fn main_args(args: &[String]) -> int {\n     let owned_args = args.to_owned();\n     monitor(proc() run_compiler(owned_args));\n     0\n@@ -44,7 +44,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n static BUG_REPORT_URL: &'static str =\n     \"http://doc.rust-lang.org/complement-bugreport.html\";\n \n-fn run_compiler(args: &[StrBuf]) {\n+fn run_compiler(args: &[String]) {\n     let matches = match handle_options(Vec::from_slice(args)) {\n         Some(matches) => matches,\n         None => return\n@@ -143,7 +143,7 @@ Available lint options:\n     for &(_, name) in lint_dict.iter() {\n         max_key = cmp::max(name.len(), max_key);\n     }\n-    fn padded(max: uint, s: &str) -> StrBuf {\n+    fn padded(max: uint, s: &str) -> String {\n         format!(\"{}{}\", \" \".repeat(max - s.len()), s)\n     }\n     println!(\"\\nAvailable lint checks:\\n\");\n@@ -192,7 +192,7 @@ fn describe_codegen_flags() {\n /// Process command line options. Emits messages as appropirate.If compilation\n /// should continue, returns a getopts::Matches object parsed from args, otherwise\n /// returns None.\n-pub fn handle_options(mut args: Vec<StrBuf>) -> Option<getopts::Matches> {\n+pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n     let _binary = args.shift().unwrap();\n "}, {"sha": "109622b66277a3c86077059b28cc3092cf3dfc03", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -42,7 +42,7 @@ pub struct Session {\n     // expected to be absolute. `None` means that there is no source file.\n     pub local_crate_source_file: Option<Path>,\n     pub working_dir: Path,\n-    pub lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, StrBuf)>>>,\n+    pub lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, String)>>>,\n     pub node_id: Cell<ast::NodeId>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub features: front::feature_gate::Features,\n@@ -108,7 +108,7 @@ impl Session {\n                     lint: lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n-                    msg: StrBuf) {\n+                    msg: String) {\n         let mut lints = self.lints.borrow_mut();\n         match lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n@@ -245,7 +245,7 @@ pub fn build_session_(sopts: config::Options,\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> StrBuf)\n+pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> String)\n               -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }"}, {"sha": "bc403d5a76c1da1789f1fbec8157634e30027655", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1862,7 +1862,7 @@ pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    named_types: RefCell<HashMap<StrBuf, TypeRef>>,\n+    named_types: RefCell<HashMap<String, TypeRef>>,\n }\n \n impl TypeNames {\n@@ -1881,7 +1881,7 @@ impl TypeNames {\n         self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n-    pub fn type_to_str(&self, ty: Type) -> StrBuf {\n+    pub fn type_to_str(&self, ty: Type) -> String {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n@@ -1890,12 +1890,12 @@ impl TypeNames {\n         }\n     }\n \n-    pub fn types_to_str(&self, tys: &[Type]) -> StrBuf {\n-        let strs: Vec<StrBuf> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n+    pub fn types_to_str(&self, tys: &[Type]) -> String {\n+        let strs: Vec<String> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n         format_strbuf!(\"[{}]\", strs.connect(\",\").to_strbuf())\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> StrBuf {\n+    pub fn val_to_str(&self, val: ValueRef) -> String {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);"}, {"sha": "1b4e52f542c421f2bf1cda017def244cc79d4d3f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -139,7 +139,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n }\n \n struct CrateInfo {\n-    ident: StrBuf,\n+    ident: String,\n     crate_id: CrateId,\n     id: ast::NodeId,\n     should_link: bool,"}, {"sha": "efe3633195e7c364cb7194ec0c0aec94b9b96090", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -33,7 +33,7 @@ pub struct StaticMethodInfo {\n     pub vis: ast::Visibility,\n }\n \n-pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> StrBuf {\n+pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_symbol(cdata.data(), def.node)\n }\n@@ -247,7 +247,7 @@ pub fn get_impl_vtables(tcx: &ty::ctxt,\n \n pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n-                                -> Vec<(cstore::NativeLibaryKind, StrBuf)> {\n+                                -> Vec<(cstore::NativeLibaryKind, String)> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(&*cdata)\n }"}, {"sha": "467bafeb2ecc678fb02109d420f3b74e6df78453", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -38,7 +38,7 @@ pub enum MetadataBlob {\n }\n \n pub struct crate_metadata {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub data: MetadataBlob,\n     pub cnum_map: cnum_map,\n     pub cnum: ast::CrateNum,\n@@ -71,8 +71,8 @@ pub struct CStore {\n     metas: RefCell<HashMap<ast::CrateNum, Rc<crate_metadata>>>,\n     extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n-    used_libraries: RefCell<Vec<(StrBuf, NativeLibaryKind)>>,\n-    used_link_args: RefCell<Vec<StrBuf>>,\n+    used_libraries: RefCell<Vec<(String, NativeLibaryKind)>>,\n+    used_link_args: RefCell<Vec<String>>,\n     pub intr: Rc<IdentInterner>,\n }\n \n@@ -189,13 +189,13 @@ impl CStore {\n         libs\n     }\n \n-    pub fn add_used_library(&self, lib: StrBuf, kind: NativeLibaryKind) {\n+    pub fn add_used_library(&self, lib: String, kind: NativeLibaryKind) {\n         assert!(!lib.is_empty());\n         self.used_libraries.borrow_mut().push((lib, kind));\n     }\n \n     pub fn get_used_libraries<'a>(&'a self)\n-                              -> &'a RefCell<Vec<(StrBuf, NativeLibaryKind)> > {\n+                              -> &'a RefCell<Vec<(String, NativeLibaryKind)> > {\n         &self.used_libraries\n     }\n \n@@ -205,7 +205,7 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<StrBuf> > {\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String> > {\n         &self.used_link_args\n     }\n "}, {"sha": "83b24d882e5b5e3055555d158db752e2c448918c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -185,7 +185,7 @@ fn item_method_sort(item: ebml::Doc) -> char {\n     ret\n }\n \n-fn item_symbol(item: ebml::Doc) -> StrBuf {\n+fn item_symbol(item: ebml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_strbuf()\n }\n \n@@ -452,7 +452,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n }\n \n \n-pub fn get_symbol(data: &[u8], id: ast::NodeId) -> StrBuf {\n+pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -1093,7 +1093,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> StrBuf {\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> String {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_strbuf()\n     }\n@@ -1142,7 +1142,7 @@ pub fn maybe_get_crate_id(data: &[u8]) -> Option<CrateId> {\n     })\n }\n \n-pub fn get_crate_triple(data: &[u8]) -> StrBuf {\n+pub fn get_crate_triple(data: &[u8]) -> String {\n     let cratedoc = reader::Doc(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n     triple_doc.expect(\"No triple in crate\").as_str().to_strbuf()\n@@ -1238,7 +1238,7 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n \n \n pub fn get_native_libraries(cdata: Cmd)\n-                            -> Vec<(cstore::NativeLibaryKind, StrBuf)> {\n+                            -> Vec<(cstore::NativeLibaryKind, String)> {\n     let libraries = reader::get_doc(reader::Doc(cdata.data()),\n                                     tag_native_libraries);\n     let mut result = Vec::new();\n@@ -1259,7 +1259,7 @@ pub fn get_macro_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n-pub fn get_exported_macros(data: &[u8]) -> Vec<StrBuf> {\n+pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n     let macros = reader::get_doc(reader::Doc(data),\n                                  tag_exported_macros);\n     let mut result = Vec::new();"}, {"sha": "bd333a5afe087bbe6c9e185e76880c981efb2a4e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -70,7 +70,7 @@ pub struct EncodeParams<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n-    pub item_symbols: &'a RefCell<NodeMap<StrBuf>>,\n+    pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n@@ -81,7 +81,7 @@ pub struct EncodeContext<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n-    pub item_symbols: &'a RefCell<NodeMap<StrBuf>>,\n+    pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n@@ -139,7 +139,7 @@ fn encode_family(ebml_w: &mut Encoder, c: char) {\n     ebml_w.end_tag();\n }\n \n-pub fn def_to_str(did: DefId) -> StrBuf {\n+pub fn def_to_str(did: DefId) -> String {\n     format_strbuf!(\"{}:{}\", did.krate, did.node)\n }\n \n@@ -1715,7 +1715,7 @@ fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireDynamic => \"d\",\n                     cstore::RequireStatic => \"s\",\n                 })).to_strbuf())\n-            }).collect::<Vec<StrBuf>>();\n+            }).collect::<Vec<String>>();\n             ebml_w.writer.write(s.connect(\",\").as_bytes());\n         }\n         None => {}\n@@ -1877,7 +1877,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> StrBuf {\n+pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n     let mut wr = MemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),"}, {"sha": "70d3c6c359a3cf557d2ba48d2d15e018330d6acc", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -186,7 +186,7 @@ static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns RUST_PATH as a string, without default paths added\n-pub fn get_rust_path() -> Option<StrBuf> {\n+pub fn get_rust_path() -> Option<String> {\n     os::getenv(\"RUST_PATH\").map(|x| x.to_strbuf())\n }\n \n@@ -236,7 +236,7 @@ pub fn rust_path() -> Vec<Path> {\n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n #[cfg(unix)]\n-fn find_libdir(sysroot: &Path) -> StrBuf {\n+fn find_libdir(sysroot: &Path) -> String {\n     // FIXME: This is a quick hack to make the rustc binary able to locate\n     // Rust libraries in Linux environments where libraries might be installed\n     // to lib64/lib32. This would be more foolproof by basing the sysroot off\n@@ -250,27 +250,27 @@ fn find_libdir(sysroot: &Path) -> StrBuf {\n     }\n \n     #[cfg(target_word_size = \"64\")]\n-    fn primary_libdir_name() -> StrBuf {\n+    fn primary_libdir_name() -> String {\n         \"lib64\".to_strbuf()\n     }\n \n     #[cfg(target_word_size = \"32\")]\n-    fn primary_libdir_name() -> StrBuf {\n+    fn primary_libdir_name() -> String {\n         \"lib32\".to_strbuf()\n     }\n \n-    fn secondary_libdir_name() -> StrBuf {\n+    fn secondary_libdir_name() -> String {\n         \"lib\".to_strbuf()\n     }\n }\n \n #[cfg(windows)]\n-fn find_libdir(_sysroot: &Path) -> StrBuf {\n+fn find_libdir(_sysroot: &Path) -> String {\n     \"bin\".to_strbuf()\n }\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n-pub fn rustlibdir() -> StrBuf {\n+pub fn rustlibdir() -> String {\n     \"rustlib\".to_strbuf()\n }"}, {"sha": "18c1c48e58f704771883fbc1b1d183e62345532f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -61,7 +61,7 @@ pub enum Os {\n \n pub struct CrateMismatch {\n     path: Path,\n-    got: StrBuf,\n+    got: String,\n }\n \n pub struct Context<'a> {\n@@ -92,7 +92,7 @@ pub struct ArchiveMetadata {\n }\n \n pub struct CratePaths {\n-    pub ident: StrBuf,\n+    pub ident: String,\n     pub dylib: Option<Path>,\n     pub rlib: Option<Path>\n }\n@@ -313,7 +313,7 @@ impl<'a> Context<'a> {\n     //\n     // If everything checks out, then `Some(hash)` is returned where `hash` is\n     // the listed hash in the filename itself.\n-    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<StrBuf>{\n+    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<String>{\n         let middle = file.slice(prefix.len(), file.len() - suffix.len());\n         debug!(\"matching -- {}, middle: {}\", file, middle);\n         let mut parts = middle.splitn('-', 1);\n@@ -496,15 +496,15 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, StrBuf> {\n+fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, String> {\n     let start = time::precise_time_ns();\n     let ret = get_metadata_section_imp(os, filename);\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n            (time::precise_time_ns() - start) / 1000000);\n     return ret;\n }\n \n-fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, StrBuf> {\n+fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format_strbuf!(\"no such file: '{}'\", filename.display()));\n     }"}, {"sha": "6c9247040433f11d2a4bcb57e451091f812661e2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -20,7 +20,7 @@ use middle::ty;\n \n use std::rc::Rc;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n use syntax::abi;\n use syntax::ast;\n@@ -267,8 +267,8 @@ fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n     }\n }\n \n-fn parse_str(st: &mut PState, term: char) -> StrBuf {\n-    let mut result = StrBuf::new();\n+fn parse_str(st: &mut PState, term: char) -> String {\n+    let mut result = String::new();\n     while peek(st) != term {\n         unsafe {\n             result.push_bytes([next_byte(st)])"}, {"sha": "1b0e2469b055f0fd659b194c9dae0e43e890e201", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -31,7 +31,7 @@ macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n pub struct ctxt<'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    pub ds: fn(DefId) -> StrBuf,\n+    pub ds: fn(DefId) -> String,\n     // The type context.\n     pub tcx: &'a ty::ctxt,\n     pub abbrevs: &'a abbrev_map\n@@ -43,7 +43,7 @@ pub struct ctxt<'a> {\n pub struct ty_abbrev {\n     pos: uint,\n     len: uint,\n-    s: StrBuf\n+    s: String\n }\n \n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;"}, {"sha": "dbc23348e2bd4fd1fdfa613529ba4d8ab3f3bab5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -38,7 +38,7 @@ use std::io::Seek;\n use std::io::MemWriter;\n use std::mem;\n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -1152,8 +1152,8 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             Ok(ty)\n         }).unwrap();\n \n-        fn type_string(doc: ebml::Doc) -> StrBuf {\n-            let mut str = StrBuf::new();\n+        fn type_string(doc: ebml::Doc) -> String {\n+            let mut str = String::new();\n             for i in range(doc.start, doc.end) {\n                 str.push_char(doc.data[i] as char);\n             }"}, {"sha": "909434559a61525d369ca2e7614cc96d9a9d27e8", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -22,7 +22,7 @@ use util::ppaux::{note_and_explain_region, Repr, UserString};\n use std::cell::{Cell};\n use std::ops::{BitOr, BitAnd};\n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -91,7 +91,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n                  make_stat(&bccx, bccx.stats.stable_paths.get()));\n     }\n \n-    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> StrBuf {\n+    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> String {\n         let stat_f = stat as f64;\n         let total = bccx.stats.guaranteed_paths.get() as f64;\n         format_strbuf!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n@@ -296,7 +296,7 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n }\n \n impl Repr for RestrictionSet {\n-    fn repr(&self, _tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ty::ctxt) -> String {\n         format_strbuf!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n     }\n }\n@@ -574,7 +574,7 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn bckerr_to_str(&self, err: &BckError) -> StrBuf {\n+    pub fn bckerr_to_str(&self, err: &BckError) -> String {\n         match err.code {\n             err_mutbl => {\n                 let descr = match opt_loan_path(&err.cmt) {\n@@ -734,7 +734,7 @@ impl<'a> BorrowckCtxt<'a> {\n \n     pub fn append_loan_path_to_str(&self,\n                                    loan_path: &LoanPath,\n-                                   out: &mut StrBuf) {\n+                                   out: &mut String) {\n         match *loan_path {\n             LpVar(id) => {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n@@ -768,7 +768,7 @@ impl<'a> BorrowckCtxt<'a> {\n \n     pub fn append_autoderefd_loan_path_to_str(&self,\n                                               loan_path: &LoanPath,\n-                                              out: &mut StrBuf) {\n+                                              out: &mut String) {\n         match *loan_path {\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n@@ -783,13 +783,13 @@ impl<'a> BorrowckCtxt<'a> {\n         }\n     }\n \n-    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> StrBuf {\n-        let mut result = StrBuf::new();\n+    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> String {\n+        let mut result = String::new();\n         self.append_loan_path_to_str(loan_path, &mut result);\n         result\n     }\n \n-    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> StrBuf {\n+    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> String {\n         self.mc().cmt_to_str(cmt)\n     }\n }\n@@ -819,7 +819,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n }\n \n impl Repr for Loan {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         (format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n@@ -831,15 +831,15 @@ impl Repr for Loan {\n }\n \n impl Repr for Restriction {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         (format!(\"Restriction({}, {:x})\",\n                  self.loan_path.repr(tcx),\n                  self.set.bits as uint)).to_strbuf()\n     }\n }\n \n impl Repr for LoanPath {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match self {\n             &LpVar(id) => {\n                 (format!(\"$({})\", tcx.map.node_to_str(id))).to_strbuf()"}, {"sha": "87a7ce8b7a4af79c89202329fc600fca15ada387", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -25,10 +25,10 @@ pub type Edge<'a> = &'a cfg::CFGEdge;\n pub struct LabelledCFG<'a>{\n     pub ast_map: &'a ast_map::Map,\n     pub cfg: &'a cfg::CFG,\n-    pub name: StrBuf,\n+    pub name: String,\n }\n \n-fn replace_newline_with_backslash_l(s: StrBuf) -> StrBuf {\n+fn replace_newline_with_backslash_l(s: String) -> String {\n     // Replacing newlines with \\\\l causes each line to be left-aligned,\n     // improving presentation of (long) pretty-printed expressions.\n     if s.as_slice().contains(\"\\n\") {\n@@ -72,7 +72,7 @@ impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a> {\n     }\n \n     fn edge_label(&self, e: &Edge<'a>) -> dot::LabelText<'a> {\n-        let mut label = StrBuf::new();\n+        let mut label = String::new();\n         let mut put_one = false;\n         for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {"}, {"sha": "abf80fe5104c6c95dee9f8254a8b0472cdafa681", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -33,7 +33,7 @@ use syntax::visit;\n use syntax::print::pprust;\n \n \n-fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<StrBuf> {\n+fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<String> {\n     let node_ty = ty::node_id_to_type(cx, e.id);\n     let tcontents = ty::type_contents(cx, node_ty);\n     debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n@@ -62,7 +62,7 @@ pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n }\n \n impl<'a> CheckStaticVisitor<'a> {\n-    fn report_error(&self, span: Span, result: Option<StrBuf>) -> bool {\n+    fn report_error(&self, span: Span, result: Option<String>) -> bool {\n         match result {\n             None => { false }\n             Some(msg) => {"}, {"sha": "d2a28692f7bd3e7fe6e1c328e566f9ece7d256d3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -306,8 +306,8 @@ pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n }\n \n pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n-                            -> Result<const_val, StrBuf> {\n-    fn fromb(b: bool) -> Result<const_val, StrBuf> { Ok(const_int(b as i64)) }\n+                            -> Result<const_val, String> {\n+    fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n       ExprUnary(UnNeg, inner) => {\n         match eval_const_expr_partial(tcx, inner) {"}, {"sha": "5d1237da1def4e2cc7911bde357b52bca41c900c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -18,7 +18,7 @@\n \n \n use std::io;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n@@ -832,12 +832,12 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n }\n \n-fn mut_bits_to_str(words: &mut [uint]) -> StrBuf {\n+fn mut_bits_to_str(words: &mut [uint]) -> String {\n     bits_to_str(words)\n }\n \n-fn bits_to_str(words: &[uint]) -> StrBuf {\n-    let mut result = StrBuf::new();\n+fn bits_to_str(words: &[uint]) -> String {\n+    let mut result = String::new();\n     let mut sep = '[';\n \n     // Note: this is a little endian printout of bytes.\n@@ -892,7 +892,7 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     oldv != newv\n }\n \n-fn bit_str(bit: uint) -> StrBuf {\n+fn bit_str(bit: uint) -> String {\n     let byte = bit >> 8;\n     let lobits = 1 << (bit & 0xFF);\n     format_strbuf!(\"[{}:{}-{:02x}]\", bit, byte, lobits)"}, {"sha": "7114eb10c4058a9de1d36d2deeb4c51387992f5d", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -574,7 +574,7 @@ pub fn check_cast_for_escaping_regions(\n }\n \n // Ensure that `ty` has a statically known size (i.e., it has the `Sized` bound).\n-fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: StrBuf, sp: Span) {\n+fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n     if !ty::type_is_sized(tcx, ty) {\n         tcx.sess.span_err(sp,\n                           format!(\"variable `{}` has dynamically sized type \\"}, {"sha": "3f00950f4cdd3ff03f9c6bc2446a18645011f295", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -74,7 +74,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn require(&self, it: LangItem) -> Result<ast::DefId, StrBuf> {\n+    pub fn require(&self, it: LangItem) -> Result<ast::DefId, String> {\n         match self.items.get(it as uint) {\n             &Some(id) => Ok(id),\n             &None => {"}, {"sha": "192e7e9be9c2400eeeee2d61effc8fc0db4d9960", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -150,7 +150,7 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> StrBuf {\n+fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n     let cm = cx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => {\n@@ -322,7 +322,7 @@ impl<'a> IrMaps<'a> {\n         }\n     }\n \n-    fn variable_name(&self, var: Variable) -> StrBuf {\n+    fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds.get(var.get()) {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n                 token::get_ident(nm).get().to_str().to_strbuf()\n@@ -750,7 +750,7 @@ impl<'a> Liveness<'a> {\n     }\n \n     #[allow(unused_must_use)]\n-    fn ln_str(&self, ln: LiveNode) -> StrBuf {\n+    fn ln_str(&self, ln: LiveNode) -> String {\n         let mut wr = io::MemWriter::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n@@ -1541,7 +1541,7 @@ impl<'a> Liveness<'a> {\n        }\n     }\n \n-    fn should_warn(&self, var: Variable) -> Option<StrBuf> {\n+    fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n         if name.len() == 0 || name.as_slice()[0] == ('_' as u8) {\n             None"}, {"sha": "2d878965d5c96236a758feea527f984deb0cc5e5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1093,7 +1093,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_str(&self, cmt: &cmt_) -> StrBuf {\n+    pub fn cmt_to_str(&self, cmt: &cmt_) -> String {\n         match cmt.cat {\n           cat_static_item => {\n               \"static item\".to_strbuf()\n@@ -1249,7 +1249,7 @@ impl cmt_ {\n }\n \n impl Repr for cmt_ {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         format_strbuf!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n                        self.cat.repr(tcx),\n                        self.id,\n@@ -1259,7 +1259,7 @@ impl Repr for cmt_ {\n }\n \n impl Repr for categorization {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n@@ -1300,7 +1300,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n }\n \n impl Repr for InteriorKind {\n-    fn repr(&self, _tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ty::ctxt) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).get().to_str().to_strbuf()"}, {"sha": "2d13079ae7d8fbfff61018d9ce595aa27e76da1b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -45,7 +45,7 @@ pub type PublicItems = NodeSet;\n /// Result of a checking operation - None => no errors were found. Some => an\n /// error and contains the span and message for reporting that error and\n /// optionally the same for a note about the error.\n-type CheckResult = Option<(Span, StrBuf, Option<(Span, StrBuf)>)>;\n+type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// The parent visitor, used to determine what's the parent of what (node-wise)\n@@ -356,7 +356,7 @@ enum FieldName {\n \n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n-    fn nodestr(&self, id: ast::NodeId) -> StrBuf {\n+    fn nodestr(&self, id: ast::NodeId) -> String {\n         self.tcx.map.node_to_str(id).to_strbuf()\n     }\n "}, {"sha": "d3437e60658d7655581bb7fa78585e9c0d49f811", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -35,7 +35,7 @@ use collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n \n // Definition mapping\n@@ -57,7 +57,7 @@ pub type TraitMap = NodeMap<Vec<DefId> >;\n pub type ExportMap2 = RefCell<NodeMap<Vec<Export2> >>;\n \n pub struct Export2 {\n-    pub name: StrBuf,        // The name of the target.\n+    pub name: String,        // The name of the target.\n     pub def_id: DefId,     // The definition of the target.\n }\n \n@@ -221,8 +221,8 @@ enum FallbackSuggestion {\n     Field,\n     Method,\n     TraitMethod,\n-    StaticMethod(StrBuf),\n-    StaticTraitMethod(StrBuf),\n+    StaticMethod(String),\n+    StaticTraitMethod(String),\n }\n \n enum TypeParameters<'a> {\n@@ -2070,9 +2070,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn idents_to_str(&self, idents: &[Ident]) -> StrBuf {\n+    fn idents_to_str(&self, idents: &[Ident]) -> String {\n         let mut first = true;\n-        let mut result = StrBuf::new();\n+        let mut result = String::new();\n         for ident in idents.iter() {\n             if first {\n                 first = false\n@@ -2084,7 +2084,7 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn path_idents_to_str(&self, path: &Path) -> StrBuf {\n+    fn path_idents_to_str(&self, path: &Path) -> String {\n         let identifiers: Vec<ast::Ident> = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n@@ -2094,7 +2094,7 @@ impl<'a> Resolver<'a> {\n \n     fn import_directive_subclass_to_str(&mut self,\n                                         subclass: ImportDirectiveSubclass)\n-                                        -> StrBuf {\n+                                        -> String {\n         match subclass {\n             SingleImport(_, source) => {\n                 token::get_ident(source).get().to_strbuf()\n@@ -2106,7 +2106,7 @@ impl<'a> Resolver<'a> {\n     fn import_path_to_str(&mut self,\n                           idents: &[Ident],\n                           subclass: ImportDirectiveSubclass)\n-                          -> StrBuf {\n+                          -> String {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n@@ -5019,7 +5019,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n-                                -> Option<StrBuf> {\n+                                -> Option<String> {\n         let this = &mut *self;\n \n         let mut maybes: Vec<token::InternedString> = Vec::new();\n@@ -5499,7 +5499,7 @@ impl<'a> Resolver<'a> {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(&mut self, module: &Module) -> StrBuf {\n+    fn module_to_str(&mut self, module: &Module) -> String {\n         let mut idents = Vec::new();\n \n         fn collect_mod(idents: &mut Vec<ast::Ident>, module: &Module) {"}, {"sha": "a10b31e923b196c4652fb827d95cdfaf3b46270b", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -400,7 +400,7 @@ struct Match<'a, 'b> {\n }\n \n impl<'a, 'b> Repr for Match<'a, 'b> {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n             self.pats.repr(tcx)"}, {"sha": "1ead93ca3665610ec14a47412ba73b47c9d66c3f", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -23,7 +23,7 @@ use middle::trans::type_of;\n use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n@@ -64,9 +64,9 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n     let mut constraints =\n-        StrBuf::from_str(constraints.iter()\n+        String::from_str(constraints.iter()\n                                     .map(|s| s.get().to_strbuf())\n-                                    .collect::<Vec<StrBuf>>()\n+                                    .collect::<Vec<String>>()\n                                     .connect(\",\")\n                                     .as_slice());\n \n@@ -135,12 +135,12 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"mips\")]\n-fn getClobbers() -> StrBuf {\n+fn getClobbers() -> String {\n     \"\".to_strbuf()\n }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]\n-fn getClobbers() -> StrBuf {\n+fn getClobbers() -> String {\n     \"~{dirflag},~{fpsr},~{flags}\".to_strbuf()\n }"}, {"sha": "0be4396f7132ba501fea7fd2f0eee933f979764c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -125,13 +125,13 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n \n pub struct StatRecorder<'a> {\n     ccx: &'a CrateContext,\n-    name: Option<StrBuf>,\n+    name: Option<String>,\n     start: u64,\n     istart: uint,\n }\n \n impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: &'a CrateContext, name: StrBuf) -> StatRecorder<'a> {\n+    pub fn new(ccx: &'a CrateContext, name: String) -> StatRecorder<'a> {\n         let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -429,7 +429,7 @@ pub fn unset_split_stack(f: ValueRef) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: StrBuf) {\n+pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols.borrow().contains(&sym) {\n         ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).as_slice());\n     }\n@@ -1626,7 +1626,7 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     }\n }\n \n-fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: StrBuf, node_id: ast::NodeId,\n+fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n     ccx.item_symbols.borrow_mut().insert(node_id, sym);\n \n@@ -1654,7 +1654,7 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: StrBuf, node_id: ast::N\n \n fn register_fn(ccx: &CrateContext,\n                sp: Span,\n-               sym: StrBuf,\n+               sym: String,\n                node_id: ast::NodeId,\n                node_type: ty::t)\n                -> ValueRef {\n@@ -1777,7 +1777,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n-                          sym: StrBuf,\n+                          sym: String,\n                           node_id: ast::NodeId,\n                           cc: lib::llvm::CallConv,\n                           llfty: Type) -> ValueRef {\n@@ -1872,7 +1872,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n }\n \n fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n-                 ty: ty::t, attrs: &[ast::Attribute]) -> StrBuf {\n+                 ty: ty::t, attrs: &[ast::Attribute]) -> String {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.get().to_strbuf(),\n@@ -2279,7 +2279,7 @@ pub fn trans_crate(krate: ast::Crate,\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n \n-    let mut reachable: Vec<StrBuf> = ccx.reachable.iter().filter_map(|id| {\n+    let mut reachable: Vec<String> = ccx.reachable.iter().filter_map(|id| {\n         ccx.item_symbols.borrow().find(id).map(|s| s.to_strbuf())\n     }).collect();\n "}, {"sha": "352ebc3834bbd0272497178fa637580e2e8a2da5", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -122,7 +122,7 @@ pub fn Invoke(cx: &Block,\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_str(fn_),\n-           args.iter().map(|a| cx.val_to_str(*a)).collect::<Vec<StrBuf>>().connect(\", \"));\n+           args.iter().map(|a| cx.val_to_str(*a)).collect::<Vec<String>>().connect(\", \"));\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n "}, {"sha": "f7cf2284a24348b60af896ccc4580c406db05f48", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -21,7 +21,7 @@ use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n use collections::HashMap;\n use libc::{c_uint, c_ulonglong, c_char};\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n@@ -69,7 +69,7 @@ impl<'a> Builder<'a> {\n                 // Pass 2: concat strings for each elt, skipping\n                 // forwards over any cycles by advancing to rightmost\n                 // occurrence of each element in path.\n-                let mut s = StrBuf::from_str(\".\");\n+                let mut s = String::from_str(\".\");\n                 i = 0u;\n                 while i < len {\n                     i = *mm.get(&v[i]);\n@@ -806,7 +806,7 @@ impl<'a> Builder<'a> {\n                self.ccx.tn.val_to_str(llfn),\n                args.iter()\n                    .map(|&v| self.ccx.tn.val_to_str(v))\n-                   .collect::<Vec<StrBuf>>()\n+                   .collect::<Vec<String>>()\n                    .connect(\", \"));\n \n         unsafe {"}, {"sha": "6aecbd2a17e79974e6e10454e0ffd8af8b057297", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -756,7 +756,7 @@ impl<'a> CleanupScope<'a> {\n             self.cleanups.iter().any(|c| c.clean_on_unwind())\n     }\n \n-    fn block_name(&self, prefix: &str) -> StrBuf {\n+    fn block_name(&self, prefix: &str) -> String {\n         /*!\n          * Returns a suitable name to use for the basic block that\n          * handles this cleanup scope"}, {"sha": "29ea9157126d8e641e8f5438488d020a1e90ca2a", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -104,7 +104,7 @@ pub struct EnvValue {\n }\n \n impl EnvValue {\n-    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+    pub fn to_str(&self, ccx: &CrateContext) -> String {\n         format_strbuf!(\"{}({})\", self.action, self.datum.to_str(ccx))\n     }\n }"}, {"sha": "55638b9f80a6ea75d7918b69f41e3fc7404be8ce", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -173,7 +173,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = HashMap<StrBuf, ValueRef>;\n+pub type ExternMap = HashMap<String, ValueRef>;\n \n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n@@ -194,12 +194,12 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> StrBuf {\n+fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> String {\n     format_strbuf!(\"param_substs({})\", this.substs.repr(tcx))\n }\n \n impl Repr for param_substs {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         param_substs_to_str(self, tcx)\n     }\n }\n@@ -442,15 +442,15 @@ impl<'a> Block<'a> {\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n-    pub fn ident(&self, ident: Ident) -> StrBuf {\n+    pub fn ident(&self, ident: Ident) -> String {\n         token::get_ident(ident).get().to_strbuf()\n     }\n \n-    pub fn node_id_to_str(&self, id: ast::NodeId) -> StrBuf {\n+    pub fn node_id_to_str(&self, id: ast::NodeId) -> String {\n         self.tcx().map.node_to_str(id).to_strbuf()\n     }\n \n-    pub fn expr_to_str(&self, e: &ast::Expr) -> StrBuf {\n+    pub fn expr_to_str(&self, e: &ast::Expr) -> String {\n         e.repr(self.tcx())\n     }\n \n@@ -464,19 +464,19 @@ impl<'a> Block<'a> {\n         }\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> StrBuf {\n+    pub fn val_to_str(&self, val: ValueRef) -> String {\n         self.ccx().tn.val_to_str(val)\n     }\n \n-    pub fn llty_str(&self, ty: Type) -> StrBuf {\n+    pub fn llty_str(&self, ty: Type) -> String {\n         self.ccx().tn.type_to_str(ty)\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> StrBuf {\n+    pub fn ty_to_str(&self, t: ty::t) -> String {\n         t.repr(self.tcx())\n     }\n \n-    pub fn to_str(&self) -> StrBuf {\n+    pub fn to_str(&self) -> String {\n         let blk: *Block = self;\n         format_strbuf!(\"[block {}]\", blk)\n     }"}, {"sha": "a34a6b613ab64886e37ab30357f50bb653612f0b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -45,9 +45,9 @@ pub struct Stats {\n     pub n_inlines: Cell<uint>,\n     pub n_closures: Cell<uint>,\n     pub n_llvm_insns: Cell<uint>,\n-    pub llvm_insns: RefCell<HashMap<StrBuf, uint>>,\n+    pub llvm_insns: RefCell<HashMap<String, uint>>,\n     // (ident, time-in-ms, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(StrBuf, uint, uint)> >,\n+    pub fn_stats: RefCell<Vec<(String, uint, uint)> >,\n }\n \n pub struct CrateContext {\n@@ -60,7 +60,7 @@ pub struct CrateContext {\n     pub item_vals: RefCell<NodeMap<ValueRef>>,\n     pub exp_map2: resolve::ExportMap2,\n     pub reachable: NodeSet,\n-    pub item_symbols: RefCell<NodeMap<StrBuf>>,\n+    pub item_symbols: RefCell<NodeMap<String>>,\n     pub link_meta: LinkMeta,\n     pub drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n     pub tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n@@ -109,8 +109,8 @@ pub struct CrateContext {\n     pub llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n     pub adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n     pub symbol_hasher: RefCell<Sha256>,\n-    pub type_hashcodes: RefCell<HashMap<ty::t, StrBuf>>,\n-    pub all_llvm_symbols: RefCell<HashSet<StrBuf>>,\n+    pub type_hashcodes: RefCell<HashMap<ty::t, String>>,\n+    pub all_llvm_symbols: RefCell<HashSet<String>>,\n     pub tcx: ty::ctxt,\n     pub stats: Stats,\n     pub int_type: Type,"}, {"sha": "860c82cc9de6975b1cb67f3a66d45b1e20b8d909", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -624,7 +624,7 @@ impl<K:KindOps> Datum<K> {\n     }\n \n     #[allow(dead_code)] // useful for debugging\n-    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+    pub fn to_str(&self, ccx: &CrateContext) -> String {\n         format_strbuf!(\"Datum({}, {}, {:?})\",\n                        ccx.tn.val_to_str(self.val),\n                        ty_to_str(ccx.tcx(), self.ty),"}, {"sha": "3e3576e6f80587b6299c9148600833fba7984512", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -149,7 +149,7 @@ use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::sync::atomics;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n@@ -178,7 +178,7 @@ pub struct CrateDebugContext {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<DebugLocation>,\n-    created_files: RefCell<HashMap<StrBuf, DIFile>>,\n+    created_files: RefCell<HashMap<String, DIFile>>,\n     created_types: RefCell<HashMap<uint, DIType>>,\n     created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n     namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n@@ -719,7 +719,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n-    let mut function_name = StrBuf::from_str(token::get_ident(ident).get());\n+    let mut function_name = String::from_str(token::get_ident(ident).get());\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -824,7 +824,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                generics: &ast::Generics,\n                                param_substs: Option<&param_substs>,\n                                file_metadata: DIFile,\n-                               name_to_append_suffix_to: &mut StrBuf)\n+                               name_to_append_suffix_to: &mut String)\n                                -> DIArray {\n         let self_type = match param_substs {\n             Some(param_substs) => param_substs.substs.self_ty,\n@@ -1454,7 +1454,7 @@ impl GeneralMemberDescriptionFactory {\n }\n \n struct EnumVariantMemberDescriptionFactory {\n-    args: Vec<(StrBuf, ty::t)> ,\n+    args: Vec<(String, ty::t)> ,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n@@ -1525,7 +1525,7 @@ fn describe_enum_variant(cx: &CrateContext,\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(StrBuf, ty::t)> = arg_names.iter()\n+    let args: Vec<(String, ty::t)> = arg_names.iter()\n         .zip(struct_def.fields.iter())\n         .map(|(s, &t)| (s.to_strbuf(), t))\n         .collect();\n@@ -1732,7 +1732,7 @@ enum MemberOffset {\n }\n \n struct MemberDescription {\n-    name: StrBuf,\n+    name: String,\n     llvm_type: Type,\n     type_metadata: DIType,\n     offset: MemberOffset,\n@@ -2339,7 +2339,7 @@ fn cache_id_for_type(t: ty::t) -> uint {\n \n // Used to avoid LLVM metadata uniquing problems. See `create_struct_stub()` and\n // `prepare_enum_metadata()`.\n-fn generate_unique_type_id(prefix: &'static str) -> StrBuf {\n+fn generate_unique_type_id(prefix: &'static str) -> String {\n     unsafe {\n         static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n         format_strbuf!(\"{}{}\",\n@@ -2841,7 +2841,7 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprInlineAsm(ast::InlineAsm { inputs: ref inputs,\n                                                 outputs: ref outputs,\n                                                 .. }) => {\n-                // inputs, outputs: ~[(StrBuf, @expr)]\n+                // inputs, outputs: ~[(String, @expr)]\n                 for &(_, exp) in inputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n@@ -2866,8 +2866,8 @@ struct NamespaceTreeNode {\n }\n \n impl NamespaceTreeNode {\n-    fn mangled_name_of_contained_item(&self, item_name: &str) -> StrBuf {\n-        fn fill_nested(node: &NamespaceTreeNode, output: &mut StrBuf) {\n+    fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n+        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n             match node.parent {\n                 Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n                 None => {}\n@@ -2877,7 +2877,7 @@ impl NamespaceTreeNode {\n             output.push_str(string.get());\n         }\n \n-        let mut name = StrBuf::from_str(\"_ZN\");\n+        let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n         name.push_str(format!(\"{}\", item_name.len()).as_slice());\n         name.push_str(item_name);"}, {"sha": "8b5685ec4a43bf1ab3fa0f7655a3f7b661c68c4d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -86,7 +86,7 @@ pub enum Dest {\n }\n \n impl Dest {\n-    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+    pub fn to_str(&self, ccx: &CrateContext) -> String {\n         match *self {\n             SaveIn(v) => format_strbuf!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n             Ignore => \"Ignore\".to_strbuf()"}, {"sha": "0f14a3a097caee98ab865e5e77c7aa9da6adbc6b", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -496,7 +496,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n \n pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                                          sp: Span,\n-                                         sym: StrBuf,\n+                                         sym: String,\n                                          node_id: ast::NodeId)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");"}, {"sha": "487749f9ecba8aef4c4dc7d3bef06e5d470d5183", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,24 +13,24 @@ use middle::trans::type_::Type;\n use lib::llvm::ValueRef;\n \n pub trait LlvmRepr {\n-    fn llrepr(&self, ccx: &CrateContext) -> StrBuf;\n+    fn llrepr(&self, ccx: &CrateContext) -> String;\n }\n \n impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n-    fn llrepr(&self, ccx: &CrateContext) -> StrBuf {\n-        let reprs: Vec<StrBuf> = self.iter().map(|t| t.llrepr(ccx)).collect();\n+    fn llrepr(&self, ccx: &CrateContext) -> String {\n+        let reprs: Vec<String> = self.iter().map(|t| t.llrepr(ccx)).collect();\n         format_strbuf!(\"[{}]\", reprs.connect(\",\"))\n     }\n }\n \n impl LlvmRepr for Type {\n-    fn llrepr(&self, ccx: &CrateContext) -> StrBuf {\n+    fn llrepr(&self, ccx: &CrateContext) -> String {\n         ccx.tn.type_to_str(*self)\n     }\n }\n \n impl LlvmRepr for ValueRef {\n-    fn llrepr(&self, ccx: &CrateContext) -> StrBuf {\n+    fn llrepr(&self, ccx: &CrateContext) -> String {\n         ccx.tn.val_to_str(*self)\n     }\n }"}, {"sha": "36500cc27f8f69c37802d2775f7a355722d42c95", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -73,7 +73,7 @@ pub struct VecTypes {\n }\n \n impl VecTypes {\n-    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+    pub fn to_str(&self, ccx: &CrateContext) -> String {\n         format_strbuf!(\"VecTypes \\\\{unit_ty={}, llunit_ty={}, \\\n                         llunit_size={}, llunit_alloc_size={}\\\\}\",\n                        ty_to_str(ccx.tcx(), self.unit_ty),"}, {"sha": "f4fa5002fe909aedd7699bc5f9d0ab92f25c9ad3", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -302,7 +302,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n                       did: ast::DefId,\n                       tps: &[ty::t])\n-                      -> StrBuf {\n+                      -> String {\n     let name = match what {\n         a_struct => { \"struct\" }\n         an_enum => { \"enum\" }"}, {"sha": "6c5006e6d0739d5173e6e551cf2fb2736b809dca", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -278,7 +278,7 @@ pub struct ctxt {\n     pub freevars: RefCell<freevars::freevar_map>,\n     pub tcache: type_cache,\n     pub rcache: creader_cache,\n-    pub short_names_cache: RefCell<HashMap<t, StrBuf>>,\n+    pub short_names_cache: RefCell<HashMap<t, String>>,\n     pub needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     pub tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n@@ -1540,7 +1540,7 @@ pub fn substs_is_noop(substs: &substs) -> bool {\n         substs.self_ty.is_none()\n }\n \n-pub fn substs_to_str(cx: &ctxt, substs: &substs) -> StrBuf {\n+pub fn substs_to_str(cx: &ctxt, substs: &substs) -> String {\n     substs.repr(cx)\n }\n \n@@ -3201,7 +3201,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_ident(f.ident).get().to_strbuf())\n-              .collect::<Vec<StrBuf>>()).as_slice());\n+              .collect::<Vec<String>>()).as_slice());\n }\n \n pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n@@ -3224,7 +3224,7 @@ pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n     rslt\n }\n \n-pub fn ty_sort_str(cx: &ctxt, t: t) -> StrBuf {\n+pub fn ty_sort_str(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n@@ -3255,7 +3255,7 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> StrBuf {\n     }\n }\n \n-pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> StrBuf {\n+pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n     /*!\n      *\n      * Explains the source of a type err in a short,\n@@ -3265,7 +3265,7 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> StrBuf {\n      * to present additional details, particularly when\n      * it comes to lifetime-related errors. */\n \n-    fn tstore_to_closure(s: &TraitStore) -> StrBuf {\n+    fn tstore_to_closure(s: &TraitStore) -> String {\n         match s {\n             &UniqTraitStore => \"proc\".to_strbuf(),\n             &RegionTraitStore(..) => \"closure\".to_strbuf()\n@@ -3708,7 +3708,7 @@ pub fn substd_enum_variants(cx: &ctxt,\n     }).collect()\n }\n \n-pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> StrBuf {\n+pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> String {\n     with_path(cx, id, |path| ast_map::path_to_str(path)).to_strbuf()\n }\n \n@@ -4276,22 +4276,22 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n     return true;\n }\n \n-pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, StrBuf> {\n+pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n \n-pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, StrBuf> {\n+pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, String> {\n     tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     })\n }\n \n pub fn visitor_object_ty(tcx: &ctxt,\n-                         region: ty::Region) -> Result<(Rc<TraitRef>, t), StrBuf> {\n+                         region: ty::Region) -> Result<(Rc<TraitRef>, t), String> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n         Err(s) => { return Err(s); }"}, {"sha": "6b3d026e0e515bd79fb6cc35b8a8a53dc4488711", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1495,11 +1495,11 @@ impl<'a> LookupContext<'a> {\n         self.fcx.tcx()\n     }\n \n-    fn ty_to_str(&self, t: ty::t) -> StrBuf {\n+    fn ty_to_str(&self, t: ty::t) -> String {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    fn did_to_str(&self, did: DefId) -> StrBuf {\n+    fn did_to_str(&self, did: DefId) -> String {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n@@ -1509,7 +1509,7 @@ impl<'a> LookupContext<'a> {\n }\n \n impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         format_strbuf!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, \\\n                         origin={:?})\",\n                        self.rcvr_match_condition.repr(tcx),\n@@ -1520,7 +1520,7 @@ impl Repr for Candidate {\n }\n \n impl Repr for RcvrMatchCondition {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             RcvrMatchesIfObject(d) => {\n                 format_strbuf!(\"RcvrMatchesIfObject({})\", d.repr(tcx))"}, {"sha": "bb6b0c51a2734ffa14e03fe98adc1a984137af35", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -468,7 +468,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={:?}, ret_ty={:?})\",\n-           arg_tys.iter().map(|&a| ppaux::ty_to_str(tcx, a)).collect::<Vec<StrBuf>>(),\n+           arg_tys.iter().map(|&a| ppaux::ty_to_str(tcx, a)).collect::<Vec<String>>(),\n            ppaux::ty_to_str(tcx, ret_ty));\n \n     // Create the function context.  This is either derived from scratch or,\n@@ -1100,7 +1100,7 @@ impl<'a> RegionScope for infer::InferCtxt<'a> {\n }\n \n impl<'a> FnCtxt<'a> {\n-    pub fn tag(&self) -> StrBuf {\n+    pub fn tag(&self) -> String {\n         format_strbuf!(\"{}\", self as *FnCtxt)\n     }\n \n@@ -1176,7 +1176,7 @@ impl<'a> FnCtxt<'a> {\n         ast_ty_to_ty(self, self.infcx(), ast_t)\n     }\n \n-    pub fn pat_to_str(&self, pat: &ast::Pat) -> StrBuf {\n+    pub fn pat_to_str(&self, pat: &ast::Pat) -> String {\n         pat.repr(self.tcx())\n     }\n \n@@ -1283,7 +1283,7 @@ impl<'a> FnCtxt<'a> {\n \n     pub fn type_error_message(&self,\n                               sp: Span,\n-                              mk_msg: |StrBuf| -> StrBuf,\n+                              mk_msg: |String| -> String,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1800,7 +1800,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         debug!(\"check_argument_types: formal_tys={:?}\",\n-               formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<StrBuf>>());\n+               formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<String>>());\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments"}, {"sha": "8ac6b19f657aa7dda62058feeeb554cb7d0a200f", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -71,7 +71,7 @@ use syntax::abi;\n \n pub trait Combine {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n-    fn tag(&self) -> StrBuf;\n+    fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n "}, {"sha": "6b4da020506c7d1f3bc82263a7f720c9b84a46af", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -77,7 +77,7 @@ use middle::typeck::infer::region_inference::SameRegions;\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -103,12 +103,12 @@ pub trait ErrorReporting {\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err);\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<StrBuf>;\n+    fn values_str(&self, values: &ValuePairs) -> Option<String>;\n \n     fn expected_found_str<T:UserString+Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n-        -> Option<StrBuf>;\n+        -> Option<String>;\n \n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin,\n@@ -365,7 +365,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<StrBuf> {\n+    fn values_str(&self, values: &ValuePairs) -> Option<String> {\n         /*!\n          * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n@@ -383,7 +383,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n     fn expected_found_str<T:UserString+Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n-        -> Option<StrBuf>\n+        -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n         if expected.contains_error() {\n@@ -1466,7 +1466,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n \n // LifeGiver is responsible for generating fresh lifetime names\n struct LifeGiver {\n-    taken: HashSet<StrBuf>,\n+    taken: HashSet<String>,\n     counter: Cell<uint>,\n     generated: RefCell<Vec<ast::Lifetime>>,\n }\n@@ -1506,8 +1506,8 @@ impl LifeGiver {\n         return lifetime;\n \n         // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_str(counter: uint) -> StrBuf {\n-            let mut s = StrBuf::new();\n+        fn num_to_str(counter: uint) -> String {\n+            let mut s = String::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();\n             for _ in range(0, n) {"}, {"sha": "7c1866cf81ddf2b2a0acc5752c220b500b76b0ac", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -36,7 +36,7 @@ impl<'f> Glb<'f> {\n \n impl<'f> Combine for Glb<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> StrBuf { \"glb\".to_strbuf() }\n+    fn tag(&self) -> String { \"glb\".to_strbuf() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "22caad79c198f42d9f7ea6b1dda8fe9a600d4e71", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -35,7 +35,7 @@ impl<'f> Lub<'f> {\n \n impl<'f> Combine for Lub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> StrBuf { \"lub\".to_strbuf() }\n+    fn tag(&self) -> String { \"lub\".to_strbuf() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "7a0a9610629e5a10dddc1271f869af642ad5fd9d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -245,7 +245,7 @@ pub enum fixup_err {\n     region_var_bound_by_region_var(RegionVid, RegionVid)\n }\n \n-pub fn fixup_err_to_str(f: fixup_err) -> StrBuf {\n+pub fn fixup_err_to_str(f: fixup_err) -> String {\n     match f {\n       unresolved_int_ty(_) => \"unconstrained integral type\".to_strbuf(),\n       unresolved_ty(_) => \"unconstrained type\".to_strbuf(),\n@@ -650,17 +650,17 @@ impl<'a> InferCtxt<'a> {\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> StrBuf {\n+    pub fn ty_to_str(&self, t: ty::t) -> String {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_str(&self, ts: &[ty::t]) -> StrBuf {\n-        let tstrs: Vec<StrBuf> = ts.iter().map(|t| self.ty_to_str(*t)).collect();\n+    pub fn tys_to_str(&self, ts: &[ty::t]) -> String {\n+        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_str(*t)).collect();\n         format_strbuf!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_str(&self, t: &ty::TraitRef) -> StrBuf {\n+    pub fn trait_ref_to_str(&self, t: &ty::TraitRef) -> String {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)\n     }\n@@ -713,19 +713,19 @@ impl<'a> InferCtxt<'a> {\n     // errors.\n     pub fn type_error_message_str(&self,\n                                   sp: Span,\n-                                  mk_msg: |Option<StrBuf>, StrBuf| -> StrBuf,\n-                                  actual_ty: StrBuf,\n+                                  mk_msg: |Option<String>, String| -> String,\n+                                  actual_ty: String,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n     pub fn type_error_message_str_with_expected(&self,\n                                                 sp: Span,\n-                                                mk_msg: |Option<StrBuf>,\n-                                                         StrBuf|\n-                                                         -> StrBuf,\n+                                                mk_msg: |Option<String>,\n+                                                         String|\n+                                                         -> String,\n                                                 expected_ty: Option<ty::t>,\n-                                                actual_ty: StrBuf,\n+                                                actual_ty: String,\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n@@ -760,7 +760,7 @@ impl<'a> InferCtxt<'a> {\n \n     pub fn type_error_message(&self,\n                               sp: Span,\n-                              mk_msg: |StrBuf| -> StrBuf,\n+                              mk_msg: |String| -> String,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n@@ -784,8 +784,8 @@ impl<'a> InferCtxt<'a> {\n             // Don't report an error if expected is ty_err\n             ty::ty_err => return,\n             _ => {\n-                // if I leave out : StrBuf, it infers &str and complains\n-                |actual: StrBuf| {\n+                // if I leave out : String, it infers &str and complains\n+                |actual: String| {\n                     format_strbuf!(\"mismatched types: expected `{}` but \\\n                                     found `{}`\",\n                                    self.ty_to_str(resolved_expected),\n@@ -829,7 +829,7 @@ impl TypeTrace {\n }\n \n impl Repr for TypeTrace {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         format_strbuf!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n }\n@@ -849,7 +849,7 @@ impl TypeOrigin {\n }\n \n impl Repr for TypeOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             MethodCompatCheck(a) => {\n                 format_strbuf!(\"MethodCompatCheck({})\", a.repr(tcx))\n@@ -898,7 +898,7 @@ impl SubregionOrigin {\n }\n \n impl Repr for SubregionOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             Subtype(ref a) => {\n                 format_strbuf!(\"Subtype({})\", a.repr(tcx))\n@@ -959,7 +959,7 @@ impl RegionVariableOrigin {\n }\n \n impl Repr for RegionVariableOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             MiscVariable(a) => {\n                 format_strbuf!(\"MiscVariable({})\", a.repr(tcx))"}, {"sha": "396dd476e8950e5c2c969337c9caa8db7b4644f9", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1339,7 +1339,7 @@ impl<'a> RegionVarBindings<'a> {\n }\n \n impl Repr for Constraint {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             ConstrainVarSubVar(a, b) => {\n                 format_strbuf!(\"ConstrainVarSubVar({}, {})\","}, {"sha": "a99e06d460cff838da92528d13ad5c7bbd80662b", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -35,7 +35,7 @@ impl<'f> Sub<'f> {\n \n impl<'f> Combine for Sub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> StrBuf { \"sub\".to_strbuf() }\n+    fn tag(&self) -> String { \"sub\".to_strbuf() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "231d84f37c5b2990bf35ff37c223e559336b1e87", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -34,7 +34,7 @@ struct Env {\n     krate: @ast::Crate,\n     tcx: ty::ctxt,\n     infcx: infer::infer_ctxt,\n-    err_messages: @DVec<StrBuf>\n+    err_messages: @DVec<String>\n }\n \n struct RH {\n@@ -93,7 +93,7 @@ impl Env {\n                             sub: &[]}]});\n     }\n \n-    pub fn lookup_item(&self, names: &[StrBuf]) -> ast::node_id {\n+    pub fn lookup_item(&self, names: &[String]) -> ast::node_id {\n         return match search_mod(self, &self.krate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n@@ -104,7 +104,7 @@ impl Env {\n         fn search_mod(self: &Env,\n                       m: &ast::Mod,\n                       idx: uint,\n-                      names: &[StrBuf]) -> Option<ast::node_id> {\n+                      names: &[String]) -> Option<ast::node_id> {\n             assert!(idx < names.len());\n             for item in m.items.iter() {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n@@ -117,7 +117,7 @@ impl Env {\n         fn search(self: &Env,\n                   it: @ast::Item,\n                   idx: uint,\n-                  names: &[StrBuf]) -> Option<ast::node_id> {\n+                  names: &[String]) -> Option<ast::node_id> {\n             if idx == names.len() {\n                 return Some(it.id);\n             }\n@@ -174,7 +174,7 @@ impl Env {\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_str(&self, a: ty::t) -> StrBuf {\n+    pub fn ty_to_str(&self, a: ty::t) -> String {\n         ty_to_str(self.tcx, a)\n     }\n "}, {"sha": "ab65db8e394b69d1462f3b25258a2924c00fa240", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -20,40 +20,40 @@ use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n use syntax::ast;\n \n pub trait InferStr {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf;\n+    fn inf_str(&self, cx: &InferCtxt) -> String;\n }\n \n impl InferStr for ty::t {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         ty_to_str(cx.tcx, *self)\n     }\n }\n \n impl InferStr for FnSig {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         format_strbuf!(\"({}) -> {}\",\n                        self.inputs\n                            .iter()\n                            .map(|a| a.inf_str(cx))\n-                           .collect::<Vec<StrBuf>>().connect(\", \"),\n+                           .collect::<Vec<String>>().connect(\", \"),\n                        self.output.inf_str(cx))\n     }\n }\n \n impl InferStr for ty::mt {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         mt_to_str(cx.tcx, self)\n     }\n }\n \n impl InferStr for ty::Region {\n-    fn inf_str(&self, _cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, _cx: &InferCtxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl<V:InferStr> InferStr for Bound<V> {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         match *self {\n             Some(ref v) => v.inf_str(cx),\n             None => \"none\".to_strbuf()\n@@ -62,15 +62,15 @@ impl<V:InferStr> InferStr for Bound<V> {\n }\n \n impl<T:InferStr> InferStr for Bounds<T> {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         format_strbuf!(\"\\\\{{} <: {}\\\\}\",\n                        self.lb.inf_str(cx),\n                        self.ub.inf_str(cx))\n     }\n }\n \n impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         match *self {\n           Redirect(ref vid) => format_strbuf!(\"Redirect({})\", vid.to_str()),\n           Root(ref pt, rk) => {\n@@ -81,19 +81,19 @@ impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n }\n \n impl InferStr for IntVarValue {\n-    fn inf_str(&self, _cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, _cx: &InferCtxt) -> String {\n         self.to_str().to_strbuf()\n     }\n }\n \n impl InferStr for ast::FloatTy {\n-    fn inf_str(&self, _cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, _cx: &InferCtxt) -> String {\n         self.to_str().to_strbuf()\n     }\n }\n \n impl InferStr for ty::TraitRef {\n-    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n         trait_ref_to_str(cx.tcx, self)\n     }\n }"}, {"sha": "995ce56078dba09f8ad41c4ba706bcd4ab740b41", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -198,7 +198,7 @@ pub enum vtable_origin {\n }\n \n impl Repr for vtable_origin {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n                 format_strbuf!(\"vtable_static({:?}:{}, {}, {})\",\n@@ -230,7 +230,7 @@ pub struct impl_res {\n }\n \n impl Repr for impl_res {\n-    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n         format_strbuf!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n                        self.trait_vtables.repr(tcx),\n                        self.self_vtables.repr(tcx))\n@@ -293,7 +293,7 @@ pub fn require_same_types(tcx: &ty::ctxt,\n                           span: Span,\n                           t1: ty::t,\n                           t2: ty::t,\n-                          msg: || -> StrBuf)\n+                          msg: || -> String)\n                           -> bool {\n     let result = match maybe_infcx {\n         None => {"}, {"sha": "649608e82752c62ca76b11f614ac1bff402feaf7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -23,7 +23,7 @@ use middle::ty;\n use middle::typeck;\n \n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n@@ -34,12 +34,12 @@ use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n pub trait Repr {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf;\n+    fn repr(&self, tcx: &ctxt) -> String;\n }\n \n /// Produces a string suitable for showing to the user.\n pub trait UserString {\n-    fn user_string(&self, tcx: &ctxt) -> StrBuf;\n+    fn user_string(&self, tcx: &ctxt) -> String;\n }\n \n pub fn note_and_explain_region(cx: &ctxt,\n@@ -60,7 +60,7 @@ pub fn note_and_explain_region(cx: &ctxt,\n }\n \n pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n-                            -> (StrBuf, Option<Span>) {\n+                            -> (String, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n         match cx.map.find(node_id) {\n@@ -135,7 +135,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     };\n \n     fn explain_span(cx: &ctxt, heading: &str, span: Span)\n-        -> (StrBuf, Option<Span>) {\n+        -> (String, Option<Span>) {\n         let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n         (format_strbuf!(\"the {} at {}:{}\",\n                         heading,\n@@ -144,13 +144,13 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> StrBuf {\n+pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> String {\n     bound_region_to_str(cx, \"\", false, br)\n }\n \n pub fn bound_region_to_str(cx: &ctxt,\n                            prefix: &str, space: bool,\n-                           br: BoundRegion) -> StrBuf {\n+                           br: BoundRegion) -> String {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n@@ -172,11 +172,11 @@ pub fn bound_region_to_str(cx: &ctxt,\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> StrBuf {\n+pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> String {\n     region_to_str(cx, \"&\", true, region)\n }\n \n-pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> StrBuf {\n+pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> String {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n@@ -203,18 +203,18 @@ pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> St\n     }\n }\n \n-pub fn mutability_to_str(m: ast::Mutability) -> StrBuf {\n+pub fn mutability_to_str(m: ast::Mutability) -> String {\n     match m {\n         ast::MutMutable => \"mut \".to_strbuf(),\n         ast::MutImmutable => \"\".to_strbuf(),\n     }\n }\n \n-pub fn mt_to_str(cx: &ctxt, m: &mt) -> StrBuf {\n+pub fn mt_to_str(cx: &ctxt, m: &mt) -> String {\n     format_strbuf!(\"{}{}\", mutability_to_str(m.mutbl), ty_to_str(cx, m.ty))\n }\n \n-pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> StrBuf {\n+pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> String {\n     match s {\n         ty::UniqTraitStore => \"Box \".to_strbuf(),\n         ty::RegionTraitStore(r, m) => {\n@@ -225,33 +225,33 @@ pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> StrBuf {\n     }\n }\n \n-pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> StrBuf) -> StrBuf {\n-    let tstrs = ts.iter().map(f).collect::<Vec<StrBuf>>();\n+pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> String) -> String {\n+    let tstrs = ts.iter().map(f).collect::<Vec<String>>();\n     format_strbuf!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> StrBuf {\n+pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> String {\n     format_strbuf!(\"fn{}{} -> {}\",\n                    typ.binder_id,\n                    typ.inputs.repr(cx),\n                    typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> StrBuf {\n+pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n     trait_ref.user_string(cx).to_strbuf()\n }\n \n-pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n-    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> StrBuf {\n+pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n+    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> String {\n         ty_to_str(cx, input).to_strbuf()\n     }\n     fn bare_fn_to_str(cx: &ctxt,\n                       fn_style: ast::FnStyle,\n                       abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n-                      -> StrBuf {\n-        let mut s = StrBuf::new();\n+                      -> String {\n+        let mut s = String::new();\n         match fn_style {\n             ast::NormalFn => {}\n             _ => {\n@@ -279,8 +279,8 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n         s\n     }\n \n-    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> StrBuf {\n-        let mut s = StrBuf::new();\n+    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n+        let mut s = String::new();\n \n         match cty.store {\n             ty::UniqTraitStore => {}\n@@ -321,12 +321,12 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n     }\n \n     fn push_sig_to_str(cx: &ctxt,\n-                       s: &mut StrBuf,\n+                       s: &mut String,\n                        bra: char,\n                        ket: char,\n                        sig: &ty::FnSig) {\n         s.push_char(bra);\n-        let strs: Vec<StrBuf> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n+        let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n         s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n             s.push_str(\", ...\");\n@@ -369,7 +369,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n           buf\n       }\n       ty_tup(ref elems) => {\n-        let strs: Vec<StrBuf> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n+        let strs: Vec<String> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n         format_strbuf!(\"({})\", strs.connect(\",\"))\n       }\n       ty_closure(ref f) => {\n@@ -435,7 +435,7 @@ pub fn parameterized(cx: &ctxt,\n                      tps: &[ty::t],\n                      did: ast::DefId,\n                      is_trait: bool)\n-                     -> StrBuf {\n+                     -> String {\n     let mut strs = Vec::new();\n     match *regions {\n         ty::ErasedRegions => { }\n@@ -482,7 +482,7 @@ pub fn parameterized(cx: &ctxt,\n     }\n }\n \n-pub fn ty_to_short_str(cx: &ctxt, typ: t) -> StrBuf {\n+pub fn ty_to_short_str(cx: &ctxt, typ: t) -> String {\n     let mut s = typ.repr(cx).to_strbuf();\n     if s.len() >= 32u {\n         s = s.as_slice().slice(0u, 32u).to_strbuf();\n@@ -491,7 +491,7 @@ pub fn ty_to_short_str(cx: &ctxt, typ: t) -> StrBuf {\n }\n \n impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         match self {\n             &None => \"None\".to_strbuf(),\n             &Some(ref t) => t.repr(tcx),\n@@ -500,7 +500,7 @@ impl<T:Repr> Repr for Option<T> {\n }\n \n impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         match self {\n             &Ok(ref t) => t.repr(tcx),\n             &Err(ref u) => format_strbuf!(\"Err({})\", u.repr(tcx))\n@@ -509,77 +509,77 @@ impl<T:Repr,U:Repr> Repr for Result<T,U> {\n }\n \n impl Repr for () {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         \"()\".to_strbuf()\n     }\n }\n \n impl<T:Repr> Repr for Rc<T> {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n impl<T:Repr> Repr for @T {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n impl<T:Repr> Repr for Box<T> {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n-fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> StrBuf {\n+fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> String {\n     vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n impl<'a, T:Repr> Repr for &'a [T] {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         repr_vec(tcx, *self)\n     }\n }\n \n impl<T:Repr> Repr for OwnedSlice<T> {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n impl Repr for ty::TypeParameterDef {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"TypeParameterDef({:?}, {})\",\n                        self.def_id,\n                        self.bounds.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionParameterDef {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"RegionParameterDef({}, {:?})\",\n                        token::get_name(self.name),\n                        self.def_id)\n     }\n }\n \n impl Repr for ty::t {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::substs {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"substs(regions={}, self_ty={}, tps={})\",\n                        self.regions.repr(tcx),\n                        self.self_ty.repr(tcx),\n@@ -588,13 +588,13 @@ impl Repr for ty::substs {\n }\n \n impl Repr for ty::ItemSubsts {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"ItemSubsts({})\", self.substs.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionSubsts {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::ErasedRegions => \"erased\".to_strbuf(),\n             ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n@@ -603,7 +603,7 @@ impl Repr for ty::RegionSubsts {\n }\n \n impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n@@ -622,39 +622,39 @@ impl Repr for ty::ParamBounds {\n }\n \n impl Repr for ty::TraitRef {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         trait_ref_to_str(tcx, self)\n     }\n }\n \n impl Repr for ast::Expr {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n     }\n }\n \n impl Repr for ast::Item {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"item({})\", tcx.map.node_to_str(self.id))\n     }\n }\n \n impl Repr for ast::Stmt {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"stmt({}: {})\",\n                        ast_util::stmt_id(self),\n                        pprust::stmt_to_str(self))\n     }\n }\n \n impl Repr for ast::Pat {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"pat({}: {})\", self.id, pprust::pat_to_str(self))\n     }\n }\n \n impl Repr for ty::BoundRegion {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::BrAnon(id) => format_strbuf!(\"BrAnon({})\", id),\n             ty::BrNamed(id, name) => {\n@@ -668,7 +668,7 @@ impl Repr for ty::BoundRegion {\n }\n \n impl Repr for ty::Region {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::ReEarlyBound(id, index, name) => {\n                 format_strbuf!(\"ReEarlyBound({}, {}, {})\",\n@@ -715,7 +715,7 @@ impl Repr for ty::Region {\n }\n \n impl Repr for ast::DefId {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n@@ -742,15 +742,15 @@ impl Repr for ast::DefId {\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n                        self.generics.repr(tcx),\n                        self.ty.repr(tcx))\n     }\n }\n \n impl Repr for ty::Generics {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"Generics(type_param_defs: {}, \\\n                            region_param_defs: {})\",\n                  self.type_param_defs().repr(tcx),\n@@ -759,7 +759,7 @@ impl Repr for ty::Generics {\n }\n \n impl Repr for ty::ItemVariances {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"IterVariances(self_param={}, \\\n                                 type_params={}, \\\n                                 region_params={})\",\n@@ -770,13 +770,13 @@ impl Repr for ty::ItemVariances {\n }\n \n impl Repr for ty::Variance {\n-    fn repr(&self, _: &ctxt) -> StrBuf {\n+    fn repr(&self, _: &ctxt) -> String {\n         self.to_str().to_strbuf()\n     }\n }\n \n impl Repr for ty::Method {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"method(ident: {}, generics: {}, fty: {}, \\\n                         explicit_self: {}, vis: {}, def_id: {})\",\n                        self.ident.repr(tcx),\n@@ -789,31 +789,31 @@ impl Repr for ty::Method {\n }\n \n impl Repr for ast::Name {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_name(*self).get().to_strbuf()\n     }\n }\n \n impl Repr for ast::Ident {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_ident(*self).get().to_strbuf()\n     }\n }\n \n impl Repr for ast::ExplicitSelf_ {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ast::Visibility {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"BareFnTy \\\\{fn_style: {:?}, abi: {}, sig: {}\\\\}\",\n                        self.fn_style,\n                        self.abi.to_str(),\n@@ -822,13 +822,13 @@ impl Repr for ty::BareFnTy {\n }\n \n impl Repr for ty::FnSig {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         fn_sig_to_str(tcx, self)\n     }\n }\n \n impl Repr for typeck::MethodCallee {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n                        self.origin.repr(tcx),\n                        self.ty.repr(tcx),\n@@ -837,7 +837,7 @@ impl Repr for typeck::MethodCallee {\n }\n \n impl Repr for typeck::MethodOrigin {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         match self {\n             &typeck::MethodStatic(def_id) => {\n                 format_strbuf!(\"MethodStatic({})\", def_id.repr(tcx))\n@@ -853,7 +853,7 @@ impl Repr for typeck::MethodOrigin {\n }\n \n impl Repr for typeck::MethodParam {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"MethodParam({},{:?},{:?},{:?})\",\n                        self.trait_id.repr(tcx),\n                        self.method_num,\n@@ -863,7 +863,7 @@ impl Repr for typeck::MethodParam {\n }\n \n impl Repr for typeck::MethodObject {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"MethodObject({},{:?},{:?})\",\n                        self.trait_id.repr(tcx),\n                        self.method_num,\n@@ -873,25 +873,25 @@ impl Repr for typeck::MethodObject {\n \n \n impl Repr for ty::RegionVid {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::TraitStore {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         trait_store_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::BuiltinBound {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl UserString for ty::BuiltinBound {\n-    fn user_string(&self, _tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n             ty::BoundStatic => \"'static\".to_strbuf(),\n             ty::BoundSend => \"Send\".to_strbuf(),\n@@ -903,36 +903,36 @@ impl UserString for ty::BuiltinBound {\n }\n \n impl Repr for ty::BuiltinBounds {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         self.user_string(tcx)\n     }\n }\n \n impl Repr for Span {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         tcx.sess.codemap().span_to_str(*self).to_strbuf()\n     }\n }\n \n impl<A:UserString> UserString for Rc<A> {\n-    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n         let this: &A = &**self;\n         this.user_string(tcx)\n     }\n }\n \n impl UserString for ty::BuiltinBounds {\n-    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n         self.iter()\n             .map(|bb| bb.user_string(tcx))\n-            .collect::<Vec<StrBuf>>()\n+            .collect::<Vec<String>>()\n             .connect(\"+\")\n             .to_strbuf()\n     }\n }\n \n impl UserString for ty::TraitRef {\n-    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n@@ -955,31 +955,31 @@ impl UserString for ty::TraitRef {\n }\n \n impl UserString for ty::t {\n-    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, tcx: &ctxt) -> String {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl UserString for ast::Ident {\n-    fn user_string(&self, _tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, _tcx: &ctxt) -> String {\n         token::get_name(self.name).get().to_strbuf()\n     }\n }\n \n impl Repr for abi::Abi {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         self.to_str().to_strbuf()\n     }\n }\n \n impl UserString for abi::Abi {\n-    fn user_string(&self, _tcx: &ctxt) -> StrBuf {\n+    fn user_string(&self, _tcx: &ctxt) -> String {\n         self.to_str().to_strbuf()\n     }\n }\n \n impl Repr for ty::UpvarId {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"UpvarId({};`{}`;{})\",\n                        self.var_id,\n                        ty::local_var_name_str(tcx, self.var_id),\n@@ -988,19 +988,19 @@ impl Repr for ty::UpvarId {\n }\n \n impl Repr for ast::Mutability {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BorrowKind {\n-    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n         format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::UpvarBorrow {\n-    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+    fn repr(&self, tcx: &ctxt) -> String {\n         format_strbuf!(\"UpvarBorrow({}, {})\",\n                        self.kind.repr(tcx),\n                        self.region.repr(tcx))"}, {"sha": "187e37faf3ae32e8a4325739fdca59abc9fa0f2f", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -257,8 +257,8 @@ pub trait Digest {\n     }\n \n     /// Convenience function that retrieves the result of a digest as a\n-    /// StrBuf in hexadecimal format.\n-    fn result_str(&mut self) -> StrBuf {\n+    /// String in hexadecimal format.\n+    fn result_str(&mut self) -> String {\n         self.result_bytes().as_slice().to_hex().to_strbuf()\n     }\n }\n@@ -543,8 +543,8 @@ mod tests {\n     }\n \n     struct Test {\n-        input: StrBuf,\n-        output_str: StrBuf,\n+        input: String,\n+        output_str: String,\n     }\n \n     fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {"}, {"sha": "68af35acdbe3382eeb25dee0ca72367983cecbf6", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -27,7 +27,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::ty;\n \n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n use core;\n use doctree;\n@@ -70,7 +70,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Crate {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n }\n@@ -102,7 +102,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct ExternalCrate {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub attrs: Vec<Attribute>,\n }\n \n@@ -125,7 +125,7 @@ pub struct Item {\n     /// Stringified span\n     pub source: Span,\n     /// Not everything has a name. E.g., impls\n-    pub name: Option<StrBuf>,\n+    pub name: Option<String>,\n     pub attrs: Vec<Attribute> ,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n@@ -288,9 +288,9 @@ impl Clean<Item> for doctree::Module {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum Attribute {\n-    Word(StrBuf),\n-    List(StrBuf, Vec<Attribute> ),\n-    NameValue(StrBuf, StrBuf)\n+    Word(String),\n+    List(String, Vec<Attribute> ),\n+    NameValue(String, String)\n }\n \n impl Clean<Attribute> for ast::MetaItem {\n@@ -339,7 +339,7 @@ impl attr::AttrMetaMethods for Attribute {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyParam {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub did: ast::DefId,\n     pub bounds: Vec<TyParamBound>,\n }\n@@ -433,7 +433,7 @@ impl Clean<TyParamBound> for ty::TraitRef {\n         };\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n         let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf())\n-                     .collect::<Vec<StrBuf>>();\n+                     .collect::<Vec<String>>();\n         let path = external_path(fqn.last().unwrap().as_slice());\n         cx.external_paths.borrow_mut().get_mut_ref().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n@@ -474,7 +474,7 @@ impl Clean<Option<Vec<TyParamBound>>> for ty::substs {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub struct Lifetime(StrBuf);\n+pub struct Lifetime(String);\n \n impl Lifetime {\n     pub fn get_ref<'a>(&'a self) -> &'a str {\n@@ -729,7 +729,7 @@ impl Clean<FnDecl> for ty::FnSig {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Argument {\n     pub type_: Type,\n-    pub name: StrBuf,\n+    pub name: String,\n     pub id: ast::NodeId,\n }\n \n@@ -902,7 +902,7 @@ pub enum Type {\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Vector(Box<Type>),\n-    FixedVector(Box<Type>, StrBuf),\n+    FixedVector(Box<Type>, String),\n     String,\n     Bool,\n     /// aka TyNil\n@@ -1012,7 +1012,7 @@ impl Clean<Type> for ty::t {\n                     core::NotTyped(_) => fail!(),\n                 };\n                 let fqn = csearch::get_item_path(tcx, did);\n-                let fqn: Vec<StrBuf> = fqn.move_iter().map(|i| {\n+                let fqn: Vec<String> = fqn.move_iter().map(|i| {\n                     i.to_str().to_strbuf()\n                 }).collect();\n                 let mut path = external_path(fqn.last()\n@@ -1195,7 +1195,7 @@ impl Clean<VariantKind> for ast::VariantKind {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Span {\n-    pub filename: StrBuf,\n+    pub filename: String,\n     pub loline: uint,\n     pub locol: uint,\n     pub hiline: uint,\n@@ -1236,7 +1236,7 @@ impl Clean<Path> for ast::Path {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct PathSegment {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub lifetimes: Vec<Lifetime>,\n     pub types: Vec<Type>,\n }\n@@ -1251,10 +1251,10 @@ impl Clean<PathSegment> for ast::PathSegment {\n     }\n }\n \n-fn path_to_str(p: &ast::Path) -> StrBuf {\n+fn path_to_str(p: &ast::Path) -> String {\n     use syntax::parse::token;\n \n-    let mut s = StrBuf::new();\n+    let mut s = String::new();\n     let mut first = true;\n     for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n         if !first || p.global {\n@@ -1267,8 +1267,8 @@ fn path_to_str(p: &ast::Path) -> StrBuf {\n     s\n }\n \n-impl Clean<StrBuf> for ast::Ident {\n-    fn clean(&self) -> StrBuf {\n+impl Clean<String> for ast::Ident {\n+    fn clean(&self) -> String {\n         token::get_ident(*self).get().to_strbuf()\n     }\n }\n@@ -1300,7 +1300,7 @@ pub struct BareFunctionDecl {\n     pub fn_style: ast::FnStyle,\n     pub generics: Generics,\n     pub decl: FnDecl,\n-    pub abi: StrBuf,\n+    pub abi: String,\n }\n \n impl Clean<BareFunctionDecl> for ast::BareFnTy {\n@@ -1324,7 +1324,7 @@ pub struct Static {\n     /// It's useful to have the value of a static documented, but I have no\n     /// desire to represent expressions (that'd basically be all of the AST,\n     /// which is huge!). So, have a string.\n-    pub expr: StrBuf,\n+    pub expr: String,\n }\n \n impl Clean<Item> for doctree::Static {\n@@ -1421,7 +1421,7 @@ impl Clean<Item> for ast::ViewItem {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewItemInner {\n-    ExternCrate(StrBuf, Option<StrBuf>, ast::NodeId),\n+    ExternCrate(String, Option<String>, ast::NodeId),\n     Import(ViewPath)\n }\n \n@@ -1445,7 +1445,7 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewPath {\n     // use str = source;\n-    SimpleImport(StrBuf, ImportSource),\n+    SimpleImport(String, ImportSource),\n     // use source::*;\n     GlobImport(ImportSource),\n     // use source::{a, b, c};\n@@ -1475,7 +1475,7 @@ impl Clean<ViewPath> for ast::ViewPath {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct ViewListIdent {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub source: Option<ast::DefId>,\n }\n \n@@ -1526,11 +1526,11 @@ impl Clean<Item> for ast::ForeignItem {\n // Utilities\n \n trait ToSource {\n-    fn to_src(&self) -> StrBuf;\n+    fn to_src(&self) -> String;\n }\n \n impl ToSource for syntax::codemap::Span {\n-    fn to_src(&self) -> StrBuf {\n+    fn to_src(&self) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n         let ctxt = super::ctxtkey.get().unwrap();\n         let cm = ctxt.sess().codemap().clone();\n@@ -1543,7 +1543,7 @@ impl ToSource for syntax::codemap::Span {\n     }\n }\n \n-fn lit_to_str(lit: &ast::Lit) -> StrBuf {\n+fn lit_to_str(lit: &ast::Lit) -> String {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_strbuf(),\n         ast::LitBinary(ref data) => format_strbuf!(\"{:?}\", data.as_slice()),\n@@ -1558,7 +1558,7 @@ fn lit_to_str(lit: &ast::Lit) -> StrBuf {\n     }\n }\n \n-fn name_from_pat(p: &ast::Pat) -> StrBuf {\n+fn name_from_pat(p: &ast::Pat) -> String {\n     use syntax::ast::*;\n     debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n@@ -1673,7 +1673,7 @@ fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Macro {\n-    pub source: StrBuf,\n+    pub source: String,\n }\n \n impl Clean<Item> for doctree::Macro {"}, {"sha": "7bc4693215a8cbeb03459645a058eba6d5c1ac59", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -32,15 +32,15 @@ pub enum MaybeTyped {\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n-                                                (Vec<StrBuf>, clean::TypeKind)>>>;\n+                                                (Vec<String>, clean::TypeKind)>>>;\n \n pub struct DocContext {\n     pub krate: ast::Crate,\n     pub maybe_typed: MaybeTyped,\n     pub src: Path,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n-    pub external_typarams: RefCell<Option<HashMap<ast::DefId, StrBuf>>>,\n+    pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n }\n \n impl DocContext {\n@@ -57,11 +57,11 @@ pub struct CrateAnalysis {\n     pub public_items: privacy::PublicItems,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n-    pub external_typarams: RefCell<Option<HashMap<ast::DefId, StrBuf>>>,\n+    pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n }\n \n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<StrBuf>)\n+fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n                        -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n@@ -120,7 +120,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<StrBuf>)\n     })\n }\n \n-pub fn run_core(libs: HashSet<Path>, cfgs: Vec<StrBuf>, path: &Path)\n+pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;"}, {"sha": "e14be8ac6fda2465df0cd489d0aed5d09ba54cc3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,7 +16,7 @@\n //! them in the future to instead emit any format desired.\n \n use std::fmt;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n use syntax::ast;\n use syntax::ast_util;\n@@ -171,12 +171,12 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n }\n \n fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n-        root: |&render::Cache, &[StrBuf]| -> Option<StrBuf>,\n-        info: |&render::Cache| -> Option<(Vec<StrBuf> , ItemType)>)\n+        root: |&render::Cache, &[String]| -> Option<String>,\n+        info: |&render::Cache| -> Option<(Vec<String> , ItemType)>)\n     -> fmt::Result\n {\n     // The generics will get written to both the title and link\n-    let mut generics = StrBuf::new();\n+    let mut generics = String::new();\n     let last = path.segments.last().unwrap();\n     if last.lifetimes.len() > 0 || last.types.len() > 0 {\n         let mut counter = 0;\n@@ -206,7 +206,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         let amt = path.segments.len() - 1;\n         match rel_root {\n             Some(root) => {\n-                let mut root = StrBuf::from_str(root.as_slice());\n+                let mut root = String::from_str(root.as_slice());\n                 for seg in path.segments.slice_to(amt).iter() {\n                     if \"super\" == seg.name.as_slice() ||\n                             \"self\" == seg.name.as_slice() {\n@@ -232,7 +232,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n     match info(&**cache) {\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n-            let mut url = StrBuf::from_str(abs_root.unwrap().as_slice());\n+            let mut url = String::from_str(abs_root.unwrap().as_slice());\n             let to_link = fqp.slice_to(fqp.len() - 1);\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n@@ -334,7 +334,7 @@ impl fmt::Show for clean::Type {\n                        },\n                        ret = decl.decl.output,\n                        bounds = {\n-                           let mut ret = StrBuf::new();\n+                           let mut ret = String::new();\n                            match *region {\n                                Some(ref lt) => {\n                                    ret.push_str(format!(\": {}\",\n@@ -377,7 +377,7 @@ impl fmt::Show for clean::Type {\n                                            .map(|s| s.to_str().to_strbuf());\n                            format_strbuf!(\n                                \": {}\",\n-                               m.collect::<Vec<StrBuf>>().connect(\" + \"))\n+                               m.collect::<Vec<String>>().connect(\" + \"))\n                        },\n                        arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n                        ret = decl.decl.output)\n@@ -462,7 +462,7 @@ impl fmt::Show for clean::FnDecl {\n impl<'a> fmt::Show for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *self;\n-        let mut args = StrBuf::new();\n+        let mut args = String::new();\n         match *selfty {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),"}, {"sha": "65ef404473f184a49235fd13256196fb22a4bd1d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -25,7 +25,7 @@ use html::escape::Escape;\n use t = syntax::parse::token;\n \n /// Highlights some source code, returning the HTML output.\n-pub fn highlight(src: &str, class: Option<&str>) -> StrBuf {\n+pub fn highlight(src: &str, class: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::new_parse_sess();\n     let fm = parse::string_to_filemap(&sess,"}, {"sha": "f4a8541c6d22b6af404552af21e138c2c193bf4c", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,9 +13,9 @@ use std::io;\n \n #[deriving(Clone)]\n pub struct Layout {\n-    pub logo: StrBuf,\n-    pub favicon: StrBuf,\n-    pub krate: StrBuf,\n+    pub logo: String,\n+    pub favicon: String,\n+    pub krate: String,\n }\n \n pub struct Page<'a> {"}, {"sha": "7b8514ab38f621c14d8ba503ab6de7fd5fe3cd27", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -138,7 +138,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-local_data_key!(used_header_map: RefCell<HashMap<StrBuf, uint>>)\n+local_data_key!(used_header_map: RefCell<HashMap<String, uint>>)\n \n pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n@@ -208,7 +208,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 Some(s) => s.to_lower().into_str().to_strbuf(),\n                 None => s.to_strbuf()\n             }\n-        }).collect::<Vec<StrBuf>>().connect(\"-\")).to_strbuf();\n+        }).collect::<Vec<String>>().connect(\"-\")).to_strbuf();\n \n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text."}, {"sha": "53e271dafa28da5db2226aea86b442b91a133708", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -38,7 +38,7 @@ use std::fmt;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::io;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n use sync::Arc;\n use serialize::json::ToJson;\n@@ -70,10 +70,10 @@ use html::markdown;\n pub struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub current: Vec<StrBuf> ,\n+    pub current: Vec<String> ,\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n-    pub root_path: StrBuf,\n+    pub root_path: String,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: Path,\n@@ -85,7 +85,7 @@ pub struct Context {\n     /// functions), and the value is the list of containers belonging to this\n     /// header. This map will change depending on the surrounding context of the\n     /// page.\n-    pub sidebar: HashMap<StrBuf, Vec<StrBuf>>,\n+    pub sidebar: HashMap<String, Vec<String>>,\n     /// This flag indicates whether [src] links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n@@ -95,7 +95,7 @@ pub struct Context {\n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n     /// Remote URL root of the external crate\n-    Remote(StrBuf),\n+    Remote(String),\n     /// This external crate can be found in the local doc/ folder\n     Local,\n     /// The external crate could not be found.\n@@ -124,22 +124,22 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: HashMap<ast::DefId, StrBuf>,\n+    pub typarams: HashMap<ast::DefId, String>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<StrBuf>)>>,\n+    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<String>)>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: HashMap<ast::DefId, (Vec<StrBuf>, ItemType)>,\n+    pub paths: HashMap<ast::DefId, (Vec<String>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -157,7 +157,7 @@ pub struct Cache {\n \n     // Private fields only used when initially crawling a crate to build a cache\n \n-    stack: Vec<StrBuf> ,\n+    stack: Vec<String> ,\n     parent_stack: Vec<ast::NodeId> ,\n     search_index: Vec<IndexItem> ,\n     privmod: bool,\n@@ -176,7 +176,7 @@ struct SourceCollector<'a> {\n     cx: &'a mut Context,\n \n     /// Processed source-file paths\n-    seen: HashSet<StrBuf>,\n+    seen: HashSet<String>,\n     /// Root destination to place all HTML output into\n     dst: Path,\n }\n@@ -195,23 +195,23 @@ struct Sidebar<'a> { cx: &'a Context, item: &'a clean::Item, }\n /// by hand to a large JS file at the end of cache-creation.\n struct IndexItem {\n     ty: ItemType,\n-    name: StrBuf,\n-    path: StrBuf,\n-    desc: StrBuf,\n+    name: String,\n+    path: String,\n+    desc: String,\n     parent: Option<ast::NodeId>,\n }\n \n // TLS keys used to carry information around during rendering.\n \n local_data_key!(pub cache_key: Arc<Cache>)\n-local_data_key!(pub current_location_key: Vec<StrBuf> )\n+local_data_key!(pub current_location_key: Vec<String> )\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         current: Vec::new(),\n-        root_path: StrBuf::new(),\n+        root_path: String::new(),\n         sidebar: HashMap::new(),\n         layout: layout::Layout {\n             logo: \"\".to_strbuf(),\n@@ -402,7 +402,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                    include_bin!(\"static/Heuristica-Bold.woff\")));\n \n         fn collect(path: &Path, krate: &str,\n-                   key: &str) -> io::IoResult<Vec<StrBuf>> {\n+                   key: &str) -> io::IoResult<Vec<String>> {\n             let mut ret = Vec::new();\n             if path.exists() {\n                 for line in BufferedReader::new(File::open(path)).lines() {\n@@ -636,7 +636,7 @@ impl<'a> SourceCollector<'a> {\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n-        let mut root_path = StrBuf::from_str(\"../../\");\n+        let mut root_path = String::from_str(\"../../\");\n         clean_srcpath(p.dirname(), |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n@@ -906,7 +906,7 @@ impl<'a> Cache {\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n-    fn recurse<T>(&mut self, s: StrBuf, f: |&mut Context| -> T) -> T {\n+    fn recurse<T>(&mut self, s: String, f: |&mut Context| -> T) -> T {\n         if s.len() == 0 {\n             fail!(\"what {:?}\", self);\n         }\n@@ -1041,7 +1041,7 @@ impl<'a> Item<'a> {\n         }\n     }\n \n-    fn link(&self) -> StrBuf {\n+    fn link(&self) -> String {\n         let mut path = Vec::new();\n         clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n             path.push(component.to_owned());\n@@ -1080,7 +1080,7 @@ impl<'a> fmt::Show for Item<'a> {\n         let cur = self.cx.current.as_slice();\n         let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n         for (i, component) in cur.iter().enumerate().take(amt) {\n-            let mut trail = StrBuf::new();\n+            let mut trail = String::new();\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n@@ -1127,7 +1127,7 @@ impl<'a> fmt::Show for Item<'a> {\n     }\n }\n \n-fn item_path(item: &clean::Item) -> StrBuf {\n+fn item_path(item: &clean::Item) -> String {\n     match item.inner {\n         clean::ModuleItem(..) => {\n             format_strbuf!(\"{}/index.html\", item.name.get_ref())\n@@ -1140,7 +1140,7 @@ fn item_path(item: &clean::Item) -> StrBuf {\n     }\n }\n \n-fn full_path(cx: &Context, item: &clean::Item) -> StrBuf {\n+fn full_path(cx: &Context, item: &clean::Item) -> String {\n     let mut s = cx.current.connect(\"::\");\n     s.push_str(\"::\");\n     s.push_str(item.name.get_ref().as_slice());\n@@ -1342,7 +1342,7 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n-    let mut parents = StrBuf::new();\n+    let mut parents = String::new();\n     if t.parents.len() > 0 {\n         parents.push_str(\": \");\n         for (i, p) in t.parents.iter().enumerate() {\n@@ -1677,11 +1677,11 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             let mut non_trait = v.iter().filter(|p| {\n                 p.ref0().trait_.is_none()\n             });\n-            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<StrBuf>)>>();\n+            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<String>)>>();\n             let mut traits = v.iter().filter(|p| {\n                 p.ref0().trait_.is_some()\n             });\n-            let traits = traits.collect::<Vec<&(clean::Impl, Option<StrBuf>)>>();\n+            let traits = traits.collect::<Vec<&(clean::Impl, Option<String>)>>();\n \n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n@@ -1717,7 +1717,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n }\n \n fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n-               dox: &Option<StrBuf>) -> fmt::Result {\n+               dox: &Option<String>) -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     match i.trait_ {\n         Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n@@ -1851,7 +1851,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n-fn build_sidebar(m: &clean::Module) -> HashMap<StrBuf, Vec<StrBuf>> {\n+fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n         let short = shortty(item).to_static_str();"}, {"sha": "7831f10ab9195645b96a8b84056f5339d1647e1c", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -421,4 +421,4 @@ pre.rust .lifetime { color: #B76514; }\n     nav.sub {\n         margin: 0 auto;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2804c26a29662a3e32d668a072a778fa5efbbbee", "filename": "src/librustdoc/html/static/normalize.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1 +1 @@\n-/*! normalize.css v3.0.0 | MIT License | git.io/normalize */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=\"button\"],input[type=\"reset\"],input[type=\"submit\"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=\"checkbox\"],input[type=\"radio\"]{box-sizing:border-box;padding:0}input[type=\"number\"]::-webkit-inner-spin-button,input[type=\"number\"]::-webkit-outer-spin-button{height:auto}input[type=\"search\"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=\"search\"]::-webkit-search-cancel-button,input[type=\"search\"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}\n\\ No newline at end of file\n+/*! normalize.css v3.0.0 | MIT License | git.io/normalize */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=\"button\"],input[type=\"reset\"],input[type=\"submit\"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=\"checkbox\"],input[type=\"radio\"]{box-sizing:border-box;padding:0}input[type=\"number\"]::-webkit-inner-spin-button,input[type=\"number\"]::-webkit-outer-spin-button{height:auto}input[type=\"search\"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=\"search\"]::-webkit-search-cancel-button,input[type=\"search\"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}"}, {"sha": "d499ab580ec41e9359156ebfc02be6006c86f877", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,7 +11,7 @@\n //! Table-of-contents creation.\n \n use std::fmt;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n /// A (recursive) table of contents\n #[deriving(Eq)]\n@@ -39,9 +39,9 @@ impl Toc {\n #[deriving(Eq)]\n pub struct TocEntry {\n     level: u32,\n-    sec_number: StrBuf,\n-    name: StrBuf,\n-    id: StrBuf,\n+    sec_number: String,\n+    name: String,\n+    id: String,\n     children: Toc,\n }\n \n@@ -125,7 +125,7 @@ impl TocBuilder {\n     /// Push a level `level` heading into the appropriate place in the\n     /// heirarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n-    pub fn push<'a>(&'a mut self, level: u32, name: StrBuf, id: StrBuf) -> &'a str {\n+    pub fn push<'a>(&'a mut self, level: u32, name: String, id: String) -> &'a str {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we\n@@ -137,11 +137,11 @@ impl TocBuilder {\n         {\n             let (toc_level, toc) = match self.chain.last() {\n                 None => {\n-                    sec_number = StrBuf::new();\n+                    sec_number = String::new();\n                     (0, &self.top_level)\n                 }\n                 Some(entry) => {\n-                    sec_number = StrBuf::from_str(entry.sec_number\n+                    sec_number = String::from_str(entry.sec_number\n                                                        .as_slice());\n                     sec_number.push_str(\".\");\n                     (entry.level, &entry.children)"}, {"sha": "abc6d526cd91def5c2040058f0adeb3be0585bc4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -136,7 +136,7 @@ pub fn usage(argv0: &str) {\n                             opts().as_slice()));\n }\n \n-pub fn main_args(args: &[StrBuf]) -> int {\n+pub fn main_args(args: &[String]) -> int {\n     let matches = match getopts::getopts(args.tail(), opts().as_slice()) {\n         Ok(m) => m,\n         Err(err) => {\n@@ -164,7 +164,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n     let libs = matches.opt_strs(\"L\").iter().map(|s| Path::new(s.as_slice())).collect();\n \n     let test_args = matches.opt_strs(\"test-args\");\n-    let test_args: Vec<StrBuf> = test_args.iter()\n+    let test_args: Vec<String> = test_args.iter()\n                                           .flat_map(|s| s.as_slice().words())\n                                           .map(|s| s.to_strbuf())\n                                           .collect();\n@@ -243,7 +243,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input(input: &str,\n-                 matches: &getopts::Matches) -> Result<Output, StrBuf> {\n+                 matches: &getopts::Matches) -> Result<Output, String> {\n     match matches.opt_str(\"r\").as_ref().map(|s| s.as_slice()) {\n         Some(\"rust\") => Ok(rust_input(input, matches)),\n         Some(\"json\") => json_input(input),\n@@ -351,7 +351,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n-fn json_input(input: &str) -> Result<Output, StrBuf> {\n+fn json_input(input: &str) -> Result<Output, String> {\n     let mut input = match File::open(&Path::new(input)) {\n         Ok(f) => f,\n         Err(e) => {"}, {"sha": "80e4214f15906d844e91950f9ef89b6c3f781ce1", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -10,7 +10,7 @@\n \n use collections::HashSet;\n use std::{str, io};\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n use getopts;\n use testing;\n@@ -19,7 +19,7 @@ use html::escape::Escape;\n use html::markdown::{MarkdownWithToc, find_testable_code, reset_headers};\n use test::Collector;\n \n-fn load_string(input: &Path) -> io::IoResult<Option<StrBuf>> {\n+fn load_string(input: &Path) -> io::IoResult<Option<String>> {\n     let mut f = try!(io::File::open(input));\n     let d = try!(f.read_to_end());\n     Ok(str::from_utf8(d.as_slice()).map(|s| s.to_strbuf()))\n@@ -61,8 +61,8 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     (metadata, \"\")\n }\n \n-fn load_external_files(names: &[StrBuf]) -> Option<StrBuf> {\n-    let mut out = StrBuf::new();\n+fn load_external_files(names: &[String]) -> Option<String> {\n+    let mut out = String::new();\n     for name in names.iter() {\n         out.push_str(load_or_return!(name.as_slice(), None, None).as_slice());\n         out.push_char('\\n');\n@@ -77,7 +77,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n     output.push(input_p.filestem().unwrap());\n     output.set_extension(\"html\");\n \n-    let mut css = StrBuf::new();\n+    let mut css = String::new();\n     for name in matches.opt_strs(\"markdown-css\").iter() {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n         css.push_str(s.as_slice())\n@@ -170,7 +170,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<StrBuf>) -> int {\n+pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<String>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut collector = Collector::new(input.to_strbuf(), libs, true, true);"}, {"sha": "16c319d6363bb1702f409ff095c93274f48ced28", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,7 +11,7 @@\n use collections::HashSet;\n use rustc::util::nodemap::NodeSet;\n use std::cmp;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n@@ -251,7 +251,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     struct Collapser;\n     impl fold::DocFolder for Collapser {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            let mut docstr = StrBuf::new();\n+            let mut docstr = String::new();\n             let mut i = i;\n             for attr in i.attrs.iter() {\n                 match *attr {\n@@ -279,7 +279,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     (krate, None)\n }\n \n-pub fn unindent(s: &str) -> StrBuf {\n+pub fn unindent(s: &str) -> String {\n     let lines = s.lines_any().collect::<Vec<&str> >();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;"}, {"sha": "7a796e97f412f2ee98bf4158a7c05a8a167779a5", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,9 +12,9 @@ use clean;\n \n use dl = std::unstable::dynamic_lib;\n use serialize::json;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n-pub type PluginJson = Option<(StrBuf, json::Json)>;\n+pub type PluginJson = Option<(String, json::Json)>;\n pub type PluginResult = (clean::Crate, PluginJson);\n pub type PluginCallback = fn (clean::Crate) -> PluginResult;\n \n@@ -41,7 +41,7 @@ impl PluginManager {\n     /// Turns `name` into the proper dynamic library filename for the given\n     /// platform. On windows, it turns into name.dll, on OS X, name.dylib, and\n     /// elsewhere, libname.so.\n-    pub fn load_plugin(&mut self, name: StrBuf) {\n+    pub fn load_plugin(&mut self, name: String) {\n         let x = self.prefix.join(libname(name));\n         let lib_result = dl::DynamicLibrary::open(Some(&x));\n         let lib = lib_result.unwrap();\n@@ -71,20 +71,20 @@ impl PluginManager {\n }\n \n #[cfg(target_os=\"win32\")]\n-fn libname(mut n: StrBuf) -> StrBuf {\n+fn libname(mut n: String) -> String {\n     n.push_str(\".dll\");\n     n\n }\n \n #[cfg(target_os=\"macos\")]\n-fn libname(mut n: StrBuf) -> StrBuf {\n+fn libname(mut n: String) -> String {\n     n.push_str(\".dylib\");\n     n\n }\n \n #[cfg(not(target_os=\"win32\"), not(target_os=\"macos\"))]\n-fn libname(n: StrBuf) -> StrBuf {\n-    let mut i = StrBuf::from_str(\"lib\");\n+fn libname(n: String) -> String {\n+    let mut i = String::from_str(\"lib\");\n     i.push_str(n.as_slice());\n     i.push_str(\".so\");\n     i"}, {"sha": "40244a67a4a71993b5572eb2d1da153135341688", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@ use std::io;\n use std::io::{Command, TempDir};\n use std::os;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::unstable::dynamic_lib::DynamicLibrary;\n \n use collections::{HashSet, HashMap};\n@@ -38,9 +38,9 @@ use passes;\n use visit_ast::RustdocVisitor;\n \n pub fn run(input: &str,\n-           cfgs: Vec<StrBuf>,\n+           cfgs: Vec<String>,\n            libs: HashSet<Path>,\n-           mut test_args: Vec<StrBuf>)\n+           mut test_args: Vec<String>)\n            -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n@@ -171,7 +171,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n         // Remove the previous dylib search path var\n         let var = DynamicLibrary::envvar();\n-        let mut env: Vec<(StrBuf,StrBuf)> = os::env().move_iter().collect();\n+        let mut env: Vec<(String,String)> = os::env().move_iter().collect();\n         match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n             Some(i) => { env.remove(i); }\n             None => {}\n@@ -199,8 +199,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     }\n }\n \n-fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> StrBuf {\n-    let mut prog = StrBuf::from_str(r\"\n+fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> String {\n+    let mut prog = String::from_str(r\"\n #![deny(warnings)]\n #![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n \");\n@@ -230,18 +230,18 @@ fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> StrBuf {\n \n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n-    names: Vec<StrBuf>,\n+    names: Vec<String>,\n     libs: HashSet<Path>,\n     cnt: uint,\n     use_headers: bool,\n-    current_header: Option<StrBuf>,\n-    cratename: StrBuf,\n+    current_header: Option<String>,\n+    cratename: String,\n \n     loose_feature_gating: bool\n }\n \n impl Collector {\n-    pub fn new(cratename: StrBuf, libs: HashSet<Path>,\n+    pub fn new(cratename: String, libs: HashSet<Path>,\n                use_headers: bool, loose_feature_gating: bool) -> Collector {\n         Collector {\n             tests: Vec::new(),\n@@ -256,7 +256,7 @@ impl Collector {\n         }\n     }\n \n-    pub fn add_test(&mut self, test: StrBuf, should_fail: bool, no_run: bool, should_ignore: bool) {\n+    pub fn add_test(&mut self, test: String, should_fail: bool, no_run: bool, should_ignore: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n             format_strbuf!(\"{}_{}\", s, self.cnt)\n@@ -296,7 +296,7 @@ impl Collector {\n                     } else {\n                         '_'\n                     }\n-                }).collect::<StrBuf>();\n+                }).collect::<String>();\n \n             // new header => reset count.\n             self.cnt = 0;"}, {"sha": "122b8785507d68e2b30161c7686148030ee63e71", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -354,7 +354,7 @@ impl Loop {\n pub struct UvError(c_int);\n \n impl UvError {\n-    pub fn name(&self) -> StrBuf {\n+    pub fn name(&self) -> String {\n         unsafe {\n             let inner = match self { &UvError(a) => a };\n             let name_str = uvll::uv_err_name(inner);\n@@ -363,7 +363,7 @@ impl UvError {\n         }\n     }\n \n-    pub fn desc(&self) -> StrBuf {\n+    pub fn desc(&self) -> String {\n         unsafe {\n             let inner = match self { &UvError(a) => a };\n             let desc_str = uvll::uv_strerror(inner);"}, {"sha": "342a79057af1a4e6cad6c8c541f4aa1c53b61f24", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -42,15 +42,15 @@ use std::cmp;\n use std::fmt;\n use std::fmt::Show;\n use std::option::{Option, Some, None};\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n /// An identifier in the pre-release or build metadata. If the identifier can\n /// be parsed as a decimal value, it will be represented with `Numeric`.\n #[deriving(Clone, Eq)]\n #[allow(missing_doc)]\n pub enum Identifier {\n     Numeric(uint),\n-    AlphaNumeric(StrBuf)\n+    AlphaNumeric(String)\n }\n \n impl cmp::Ord for Identifier {\n@@ -158,8 +158,8 @@ impl cmp::Ord for Version {\n }\n \n fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n-                        -> (StrBuf, Option<char>) {\n-    let mut buf = StrBuf::new();\n+                        -> (String, Option<char>) {\n+    let mut buf = String::new();\n     let mut ch = rdr.next();\n     loop {\n         match ch {"}, {"sha": "61ba36eeb1f347b690d628a75b829030f7435a80", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -54,7 +54,7 @@ static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n pub trait ToBase64 {\n     /// Converts the value of `self` to a base64 value following the specified\n     /// format configuration, returning the owned string.\n-    fn to_base64(&self, config: Config) -> StrBuf;\n+    fn to_base64(&self, config: Config) -> String;\n }\n \n impl<'a> ToBase64 for &'a [u8] {\n@@ -73,7 +73,7 @@ impl<'a> ToBase64 for &'a [u8] {\n      * }\n      * ```\n      */\n-    fn to_base64(&self, config: Config) -> StrBuf {\n+    fn to_base64(&self, config: Config) -> String {\n         let bytes = match config.char_set {\n             Standard => STANDARD_CHARS,\n             UrlSafe => URLSAFE_CHARS\n@@ -181,7 +181,7 @@ impl<'a> FromBase64 for &'a str {\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `StrBuf::from_utf8` function in `std::strbuf` to turn a\n+     * You can use the `String::from_utf8` function in `std::string` to turn a\n      * `Vec<u8>` into a string with characters corresponding to those values.\n      *\n      * # Example\n@@ -197,7 +197,7 @@ impl<'a> FromBase64 for &'a str {\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.as_slice().from_base64();\n      *     if res.is_ok() {\n-     *       let opt_bytes = StrBuf::from_utf8(res.unwrap());\n+     *       let opt_bytes = String::from_utf8(res.unwrap());\n      *       if opt_bytes.is_ok() {\n      *         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n      *       }"}, {"sha": "403705017d5ea29b716a9169674c25977387ae3f", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -34,7 +34,7 @@ impl<'doc> Doc<'doc> {\n         str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n     }\n \n-    pub fn as_str(&self) -> StrBuf {\n+    pub fn as_str(&self) -> String {\n         self.as_str_slice().to_strbuf()\n     }\n }\n@@ -80,7 +80,7 @@ pub enum EbmlEncoderTag {\n #[deriving(Show)]\n pub enum Error {\n     IntTooBig(uint),\n-    Expected(StrBuf),\n+    Expected(String),\n     IoError(io::IoError)\n }\n // --------------------------------------\n@@ -443,7 +443,7 @@ pub mod reader {\n         fn read_char(&mut self) -> DecodeResult<char> {\n             Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n         }\n-        fn read_str(&mut self) -> DecodeResult<StrBuf> {\n+        fn read_str(&mut self) -> DecodeResult<String> {\n             Ok(try!(self.next_doc(EsStr)).as_str())\n         }\n "}, {"sha": "e1cc8f5f2dcb199fad0d268e09488e4b444007b6", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,7 +16,7 @@ use std::fmt;\n pub trait ToHex {\n     /// Converts the value of `self` to a hex value, returning the owned\n     /// string.\n-    fn to_hex(&self) -> StrBuf;\n+    fn to_hex(&self) -> String;\n }\n \n static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n@@ -37,7 +37,7 @@ impl<'a> ToHex for &'a [u8] {\n      * }\n      * ```\n      */\n-    fn to_hex(&self) -> StrBuf {\n+    fn to_hex(&self) -> String {\n         let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n             v.push(CHARS[(byte >> 4) as uint]);\n@@ -80,7 +80,7 @@ impl<'a> FromHex for &'a str {\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `StrBuf::from_utf8` function in `std::strbuf` to turn a\n+     * You can use the `String::from_utf8` function in `std::string` to turn a\n      * `Vec<u8>` into a string with characters corresponding to those values.\n      *\n      * # Example\n@@ -96,7 +96,7 @@ impl<'a> FromHex for &'a str {\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.as_slice().from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n-     *     let result_str = StrBuf::from_utf8(bytes).unwrap();\n+     *     let result_str = String::from_utf8(bytes).unwrap();\n      *     println!(\"{}\", result_str);\n      * }\n      * ```"}, {"sha": "cf05bf5b641486b0cbfe6a21b34cab532a538001", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -64,7 +64,7 @@ use serialize::{json, Encodable};\n \n  #[deriving(Encodable)]\n  pub struct TestStruct   {\n-    data_str: StrBuf,\n+    data_str: String,\n  }\n \n fn main() {\n@@ -81,12 +81,12 @@ fn main() {\n ```\n \n Two wrapper functions are provided to encode a Encodable object\n-into a string (StrBuf) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+into a string (String) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n \n ```rust\n use serialize::json;\n let to_encode_object = \"example of string to encode\".to_strbuf();\n-let encoded_str: StrBuf = json::Encoder::str_encode(&to_encode_object);\n+let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n ```\n \n JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n@@ -108,7 +108,7 @@ use collections::TreeMap;\n \n pub struct MyStruct  {\n     attr1: u8,\n-    attr2: StrBuf,\n+    attr2: String,\n }\n \n impl ToJson for MyStruct {\n@@ -123,7 +123,7 @@ impl ToJson for MyStruct {\n fn main() {\n     let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_strbuf()};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: StrBuf = tjson.to_str().into_strbuf();\n+    let json_str: String = tjson.to_str().into_strbuf();\n }\n ```\n \n@@ -136,11 +136,11 @@ use serialize::{json, Decodable};\n #[deriving(Decodable)]\n pub struct MyStruct  {\n      attr1: u8,\n-     attr2: StrBuf,\n+     attr2: String,\n }\n \n fn main() {\n-    let json_str_to_decode: StrBuf =\n+    let json_str_to_decode: String =\n             \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_strbuf();\n     let json_object = json::from_str(json_str_to_decode.as_slice());\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n@@ -165,7 +165,7 @@ use serialize::{json, Encodable, Decodable};\n  #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n  pub struct TestStruct1  {\n     data_int: u8,\n-    data_str: StrBuf,\n+    data_str: String,\n     data_vector: Vec<u8>,\n  }\n \n@@ -174,7 +174,7 @@ use serialize::{json, Encodable, Decodable};\n fn main() {\n     let to_encode_object = TestStruct1\n          {data_int: 1, data_str:\"toto\".to_strbuf(), data_vector:vec![2,3,4,5]};\n-    let encoded_str: StrBuf = json::Encoder::str_encode(&to_encode_object);\n+    let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n \n@@ -200,7 +200,7 @@ use collections::TreeMap;\n #[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n pub struct TestStruct1  {\n     data_int: u8,\n-    data_str: StrBuf,\n+    data_str: String,\n     data_vector: Vec<u8>,\n }\n \n@@ -220,7 +220,7 @@ fn main() {\n     let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_strbuf(),\n                                           data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: StrBuf = tjson.to_str().into_strbuf();\n+    let json_str: String = tjson.to_str().into_strbuf();\n \n     // Deserialize like before.\n \n@@ -242,7 +242,7 @@ use std::mem::swap;\n use std::num;\n use std::str::ScalarValue;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::vec::Vec;\n \n use Encodable;\n@@ -252,15 +252,15 @@ use collections::{HashMap, TreeMap};\n #[deriving(Clone, Eq)]\n pub enum Json {\n     Number(f64),\n-    String(StrBuf),\n+    String(String),\n     Boolean(bool),\n     List(List),\n     Object(Box<Object>),\n     Null,\n }\n \n pub type List = Vec<Json>;\n-pub type Object = TreeMap<StrBuf, Json>;\n+pub type Object = TreeMap<String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, Eq)]\n@@ -296,9 +296,9 @@ pub type BuilderError = ParserError;\n #[deriving(Clone, Eq, Show)]\n pub enum DecoderError {\n     ParseError(ParserError),\n-    ExpectedError(StrBuf, StrBuf),\n-    MissingFieldError(StrBuf),\n-    UnknownVariantError(StrBuf),\n+    ExpectedError(String, String),\n+    MissingFieldError(String),\n+    UnknownVariantError(String),\n }\n \n /// Returns a readable error string for a given error code.\n@@ -337,8 +337,8 @@ fn io_error_to_error(io: io::IoError) -> ParserError {\n pub type EncodeResult = io::IoResult<()>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-fn escape_str(s: &str) -> StrBuf {\n-    let mut escaped = StrBuf::from_str(\"\\\"\");\n+fn escape_str(s: &str) -> String {\n+    let mut escaped = String::from_str(\"\\\"\");\n     for c in s.chars() {\n         match c {\n             '\"' => escaped.push_str(\"\\\\\\\"\"),\n@@ -355,8 +355,8 @@ fn escape_str(s: &str) -> StrBuf {\n     escaped\n }\n \n-fn spaces(n: uint) -> StrBuf {\n-    let mut ss = StrBuf::new();\n+fn spaces(n: uint) -> String {\n+    let mut ss = String::new();\n     for _ in range(0, n) {\n         ss.push_str(\" \");\n     }\n@@ -391,7 +391,7 @@ impl<'a> Encoder<'a> {\n     pub fn str_encode<T:Encodable<Encoder<'a>,\n                         io::IoError>>(\n                       to_encode_object: &T)\n-                      -> StrBuf {\n+                      -> String {\n         let buff = Encoder::buffer_encode(to_encode_object);\n         str::from_utf8(buff.as_slice()).unwrap().to_strbuf()\n     }\n@@ -836,15 +836,15 @@ impl Json {\n     }\n \n     /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> StrBuf {\n+    pub fn to_pretty_str(&self) -> String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8(s.unwrap().as_slice()).unwrap().to_strbuf()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &StrBuf) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &String) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find(key),\n             _ => None\n@@ -854,7 +854,7 @@ impl Json {\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&StrBuf]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&String]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -868,7 +868,7 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &StrBuf) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &String) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n                 match map.find(key) {\n@@ -983,7 +983,7 @@ pub enum JsonEvent {\n     ListEnd,\n     BooleanValue(bool),\n     NumberValue(f64),\n-    StringValue(StrBuf),\n+    StringValue(String),\n     NullValue,\n     Error(ParserError),\n }\n@@ -1101,7 +1101,7 @@ impl Stack {\n     }\n \n     // Used by Parser to insert Key elements at the top of the stack.\n-    fn push_key(&mut self, key: StrBuf) {\n+    fn push_key(&mut self, key: String) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n         for c in key.as_bytes().iter() {\n             self.str_buffer.push(*c);\n@@ -1388,9 +1388,9 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(n)\n     }\n \n-    fn parse_str(&mut self) -> Result<StrBuf, ParserError> {\n+    fn parse_str(&mut self) -> Result<String, ParserError> {\n         let mut escape = false;\n-        let mut res = StrBuf::new();\n+        let mut res = String::new();\n \n         loop {\n             self.bump();\n@@ -1748,7 +1748,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(NumberValue(n)) => { Ok(Number(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n-                let mut temp = StrBuf::new();\n+                let mut temp = String::new();\n                 swap(s, &mut temp);\n                 Ok(String(temp))\n             }\n@@ -1920,7 +1920,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                           format_strbuf!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<StrBuf> {\n+    fn read_str(&mut self) -> DecodeResult<String> {\n         debug!(\"read_str\");\n         Ok(try!(expect!(self.pop(), String)))\n     }\n@@ -2233,7 +2233,7 @@ impl ToJson for bool {\n     fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n-impl ToJson for StrBuf {\n+impl ToJson for String {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n@@ -2265,7 +2265,7 @@ impl<A:ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for TreeMap<StrBuf, A> {\n+impl<A:ToJson> ToJson for TreeMap<String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2275,7 +2275,7 @@ impl<A:ToJson> ToJson for TreeMap<StrBuf, A> {\n     }\n }\n \n-impl<A:ToJson> ToJson for HashMap<StrBuf, A> {\n+impl<A:ToJson> ToJson for HashMap<String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2321,22 +2321,22 @@ mod tests {\n     #[deriving(Eq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n-        Frog(StrBuf, int)\n+        Frog(String, int)\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: Vec<StrBuf>,\n+        c: Vec<String>,\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }\n \n-    fn mk_object(items: &[(StrBuf, Json)]) -> Json {\n+    fn mk_object(items: &[(String, Json)]) -> Json {\n         let mut d = box TreeMap::new();\n \n         for item in items.iter() {\n@@ -2488,7 +2488,7 @@ mod tests {\n                    from_str(a.to_pretty_str().as_slice()).unwrap());\n     }\n \n-    fn with_str_writer(f: |&mut io::Writer|) -> StrBuf {\n+    fn with_str_writer(f: |&mut io::Writer|) -> String {\n         use std::io::MemWriter;\n         use std::str;\n \n@@ -2556,7 +2556,7 @@ mod tests {\n \n     #[test]\n     fn test_write_none() {\n-        let value: Option<StrBuf> = None;\n+        let value: Option<String> = None;\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n@@ -2694,11 +2694,11 @@ mod tests {\n \n         for &(i, o) in s.iter() {\n             let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: StrBuf = Decodable::decode(&mut decoder).unwrap();\n+            let v: String = Decodable::decode(&mut decoder).unwrap();\n             assert_eq!(v.as_slice(), o);\n \n             let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: StrBuf = Decodable::decode(&mut decoder).unwrap();\n+            let v: String = Decodable::decode(&mut decoder).unwrap();\n             assert_eq!(v, o.to_strbuf());\n         }\n     }\n@@ -2828,11 +2828,11 @@ mod tests {\n     #[test]\n     fn test_decode_option() {\n         let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<StrBuf> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, None);\n \n         let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<StrBuf> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, Some(\"jodhpurs\".to_strbuf()));\n     }\n \n@@ -2853,7 +2853,7 @@ mod tests {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<StrBuf, Animal> = Decodable::decode(&mut decoder).unwrap();\n+        let mut map: TreeMap<String, Animal> = Decodable::decode(&mut decoder).unwrap();\n \n         assert_eq!(map.pop(&\"a\".to_strbuf()), Some(Dog));\n         assert_eq!(map.pop(&\"b\".to_strbuf()), Some(Frog(\"Henry\".to_strbuf(), 349)));\n@@ -2869,13 +2869,13 @@ mod tests {\n     struct DecodeStruct {\n         x: f64,\n         y: bool,\n-        z: StrBuf,\n+        z: String,\n         w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {\n         A(f64),\n-        B(StrBuf)\n+        B(String)\n     }\n     fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n                                                       expected: DecoderError) {\n@@ -3399,7 +3399,7 @@ mod tests {\n         });\n     }\n \n-    fn big_json() -> StrBuf {\n+    fn big_json() -> String {\n         let mut src = \"[\\n\".to_strbuf();\n         for _ in range(0, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\"}, {"sha": "9252ac55d24e59a630577f495309112b082115e4", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -108,7 +108,7 @@ pub trait Decoder<E> {\n     fn read_f64(&mut self) -> Result<f64, E>;\n     fn read_f32(&mut self) -> Result<f32, E>;\n     fn read_char(&mut self) -> Result<char, E>;\n-    fn read_str(&mut self) -> Result<StrBuf, E>;\n+    fn read_str(&mut self) -> Result<String, E>;\n \n     // Compound types:\n     fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n@@ -297,15 +297,15 @@ impl<'a, E, S:Encoder<E>> Encodable<S, E> for &'a str {\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for StrBuf {\n+impl<E, S:Encoder<E>> Encodable<S, E> for String {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(self.as_slice())\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for StrBuf {\n-    fn decode(d: &mut D) -> Result<StrBuf, E> {\n-        Ok(StrBuf::from_str(try!(d.read_str()).as_slice()))\n+impl<E, D:Decoder<E>> Decodable<D, E> for String {\n+    fn decode(d: &mut D) -> Result<String, E> {\n+        Ok(String::from_str(try!(d.read_str()).as_slice()))\n     }\n }\n "}, {"sha": "61e3f1a14bb28b1e3b3a4ef1d3b923a1953c88bd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -18,7 +18,7 @@ use option::{Option, Some, None};\n use slice::{ImmutableVector, MutableVector, Vector};\n use str::{OwnedStr, Str, StrAllocating, StrSlice};\n use str;\n-use strbuf::StrBuf;\n+use string::String;\n use to_str::{IntoStr};\n use vec::Vec;\n \n@@ -290,7 +290,7 @@ impl OwnedAsciiCast for ~[u8] {\n     }\n }\n \n-impl OwnedAsciiCast for StrBuf {\n+impl OwnedAsciiCast for String {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.as_slice().is_ascii()\n@@ -355,15 +355,15 @@ impl<'a> AsciiStr for &'a [Ascii] {\n \n impl IntoStr for ~[Ascii] {\n     #[inline]\n-    fn into_str(self) -> StrBuf {\n+    fn into_str(self) -> String {\n         let vector: Vec<Ascii> = self.as_slice().iter().map(|x| *x).collect();\n         vector.into_str()\n     }\n }\n \n impl IntoStr for Vec<Ascii> {\n     #[inline]\n-    fn into_str(self) -> StrBuf {\n+    fn into_str(self) -> String {\n         unsafe {\n             let s: &str = mem::transmute(self.as_slice());\n             s.to_strbuf()\n@@ -388,25 +388,25 @@ pub trait OwnedStrAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n-    fn into_ascii_upper(self) -> StrBuf;\n+    fn into_ascii_upper(self) -> String;\n \n     /// Convert the string to ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n-    fn into_ascii_lower(self) -> StrBuf;\n+    fn into_ascii_lower(self) -> String;\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n pub trait StrAsciiExt {\n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_upper(&self) -> StrBuf;\n+    fn to_ascii_upper(&self) -> String;\n \n     /// Makes a copy of the string in ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_lower(&self) -> StrBuf;\n+    fn to_ascii_lower(&self) -> String;\n \n     /// Check that two strings are an ASCII case-insensitive match.\n     /// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n@@ -416,12 +416,12 @@ pub trait StrAsciiExt {\n \n impl<'a> StrAsciiExt for &'a str {\n     #[inline]\n-    fn to_ascii_upper(&self) -> StrBuf {\n+    fn to_ascii_upper(&self) -> String {\n         unsafe { str_copy_map_bytes(*self, ASCII_UPPER_MAP) }\n     }\n \n     #[inline]\n-    fn to_ascii_lower(&self) -> StrBuf {\n+    fn to_ascii_lower(&self) -> String {\n         unsafe { str_copy_map_bytes(*self, ASCII_LOWER_MAP) }\n     }\n \n@@ -436,20 +436,20 @@ impl<'a> StrAsciiExt for &'a str {\n     }\n }\n \n-impl OwnedStrAsciiExt for StrBuf {\n+impl OwnedStrAsciiExt for String {\n     #[inline]\n-    fn into_ascii_upper(self) -> StrBuf {\n+    fn into_ascii_upper(self) -> String {\n         unsafe { str_map_bytes(self, ASCII_UPPER_MAP) }\n     }\n \n     #[inline]\n-    fn into_ascii_lower(self) -> StrBuf {\n+    fn into_ascii_lower(self) -> String {\n         unsafe { str_map_bytes(self, ASCII_LOWER_MAP) }\n     }\n }\n \n #[inline]\n-unsafe fn str_map_bytes(string: StrBuf, map: &'static [u8]) -> StrBuf {\n+unsafe fn str_map_bytes(string: String, map: &'static [u8]) -> String {\n     let mut bytes = string.into_bytes();\n \n     for b in bytes.mut_iter() {\n@@ -460,7 +460,7 @@ unsafe fn str_map_bytes(string: StrBuf, map: &'static [u8]) -> StrBuf {\n }\n \n #[inline]\n-unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> StrBuf {\n+unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> String {\n     let mut s = string.to_strbuf();\n     for b in s.as_mut_bytes().mut_iter() {\n         *b = map[*b as uint];"}, {"sha": "029f7162b42dfbc268267032a1322db7e680c7d5", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -82,7 +82,7 @@ use slice::{ImmutableVector, MutableVector};\n use slice;\n use str::StrSlice;\n use str;\n-use strbuf::StrBuf;\n+use string::String;\n \n /// The representation of a C String.\n ///\n@@ -296,7 +296,7 @@ pub trait ToCStr {\n // FIXME (#12938): Until DST lands, we cannot decompose &str into &\n // and str, so we cannot usefully take ToCStr arguments by reference\n // (without forcing an additional & around &str). So we are instead\n-// temporarily adding an instance for ~str and StrBuf, so that we can\n+// temporarily adding an instance for ~str and String, so that we can\n // take ToCStr as owned. When DST lands, the string instances should\n // be revisted, and arguments bound by ToCStr should be passed by\n // reference.\n@@ -323,7 +323,7 @@ impl<'a> ToCStr for &'a str {\n     }\n }\n \n-impl ToCStr for StrBuf {\n+impl ToCStr for String {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n         self.as_bytes().to_c_str()"}, {"sha": "0952652498a3d69e1e557270e8a1daf89ac086da", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -27,7 +27,7 @@ general case.\n \n The `format!` macro is intended to be familiar to those coming from C's\n printf/fprintf functions or Python's `str.format` function. In its current\n-revision, the `format!` macro returns a `StrBuf` type which is the result of\n+revision, the `format!` macro returns a `String` type which is the result of\n the formatting. In the future it will also be able to pass in a stream to\n format arguments directly while performing minimal allocations.\n \n@@ -282,7 +282,7 @@ use std::io;\n \n # #[allow(unused_must_use)]\n # fn main() {\n-format_args!(fmt::format, \"this returns {}\", \"StrBuf\");\n+format_args!(fmt::format, \"this returns {}\", \"String\");\n \n let some_writer: &mut io::Writer = &mut io::stdout();\n format_args!(|args| { write!(some_writer, \"{}\", args) }, \"print with a {}\", \"closure\");\n@@ -490,7 +490,7 @@ use repr;\n use result::{Ok, Err};\n use str::{Str, StrAllocating};\n use str;\n-use strbuf::StrBuf;\n+use string;\n use slice::Vector;\n \n pub use core::fmt::{Formatter, Result, FormatWriter, Show, rt};\n@@ -545,14 +545,14 @@ pub trait Poly {\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n /// assert_eq!(s, \"Hello, world!\".to_owned());\n /// ```\n-pub fn format(args: &Arguments) -> StrBuf{\n+pub fn format(args: &Arguments) -> string::String{\n     let mut output = io::MemWriter::new();\n     let _ = write!(&mut output, \"{}\", args);\n     str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()\n }\n \n /// Temporary transition utility\n-pub fn format_strbuf(args: &Arguments) -> StrBuf {\n+pub fn format_strbuf(args: &Arguments) -> string::String {\n     let mut output = io::MemWriter::new();\n     let _ = write!(&mut output, \"{}\", args);\n     str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()"}, {"sha": "6ab65809a3ca835acca8630bffea9f3f31fee02a", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -23,7 +23,7 @@\n  * #[deriving(Hash)]\n  * struct Person {\n  *     id: uint,\n- *     name: StrBuf,\n+ *     name: String,\n  *     phone: u64,\n  * }\n  *\n@@ -43,7 +43,7 @@\n  *\n  * struct Person {\n  *     id: uint,\n- *     name: StrBuf,\n+ *     name: String,\n  *     phone: u64,\n  * }\n  *"}, {"sha": "9076790861221b26984216f42fa7ea4dfd49b847", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -363,7 +363,7 @@ mod tests {\n     use num::ToStrRadix;\n     use option::{Some, None};\n     use str::Str;\n-    use strbuf::StrBuf;\n+    use string::String;\n     use slice::{Vector, ImmutableVector};\n     use self::test::Bencher;\n \n@@ -458,8 +458,8 @@ mod tests {\n         let mut state_inc = SipState::new_with_keys(k0, k1);\n         let mut state_full = SipState::new_with_keys(k0, k1);\n \n-        fn to_hex_str(r: &[u8, ..8]) -> StrBuf {\n-            let mut s = StrBuf::new();\n+        fn to_hex_str(r: &[u8, ..8]) -> String {\n+            let mut s = String::new();\n             for b in r.iter() {\n                 s.push_str((*b as uint).to_str_radix(16u).as_slice());\n             }\n@@ -478,9 +478,9 @@ mod tests {\n             ]\n         }\n \n-        fn result_str(h: u64) -> StrBuf {\n+        fn result_str(h: u64) -> String {\n             let r = result_bytes(h);\n-            let mut s = StrBuf::new();\n+            let mut s = String::new();\n             for b in r.iter() {\n                 s.push_str((*b as uint).to_str_radix(16u).as_slice());\n             }"}, {"sha": "c22bc92fb65b59a9b6fa8607af6c3867b525cd37", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -76,7 +76,7 @@ Some examples of obvious things you might want to do\n \n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n-    let lines: Vec<StrBuf> = file.lines().map(|x| x.unwrap()).collect();\n+    let lines: Vec<String> = file.lines().map(|x| x.unwrap()).collect();\n     ```\n \n * Make a simple TCP client connection and request\n@@ -228,7 +228,7 @@ use result::{Ok, Err, Result};\n use slice::{Vector, MutableVector, ImmutableVector};\n use str::{StrSlice, StrAllocating};\n use str;\n-use strbuf::StrBuf;\n+use string::String;\n use uint;\n use vec::Vec;\n \n@@ -293,7 +293,7 @@ pub struct IoError {\n     /// A human-readable description about the error\n     pub desc: &'static str,\n     /// Detailed information about this error, not always available\n-    pub detail: Option<StrBuf>\n+    pub detail: Option<String>\n }\n \n impl IoError {\n@@ -632,7 +632,7 @@ pub trait Reader {\n     /// This function returns all of the same errors as `read_to_end` with an\n     /// additional error if the reader's contents are not a valid sequence of\n     /// UTF-8 bytes.\n-    fn read_to_str(&mut self) -> IoResult<StrBuf> {\n+    fn read_to_str(&mut self) -> IoResult<String> {\n         self.read_to_end().and_then(|s| {\n             match str::from_utf8(s.as_slice()) {\n                 Some(s) => Ok(s.to_strbuf()),\n@@ -1244,8 +1244,8 @@ pub struct Lines<'r, T> {\n     buffer: &'r mut T,\n }\n \n-impl<'r, T: Buffer> Iterator<IoResult<StrBuf>> for Lines<'r, T> {\n-    fn next(&mut self) -> Option<IoResult<StrBuf>> {\n+impl<'r, T: Buffer> Iterator<IoResult<String>> for Lines<'r, T> {\n+    fn next(&mut self) -> Option<IoResult<String>> {\n         match self.buffer.read_line() {\n             Ok(x) => Some(Ok(x)),\n             Err(IoError { kind: EndOfFile, ..}) => None,\n@@ -1330,7 +1330,7 @@ pub trait Buffer: Reader {\n     ///\n     /// Additionally, this function can fail if the line of input read is not a\n     /// valid UTF-8 sequence of bytes.\n-    fn read_line(&mut self) -> IoResult<StrBuf> {\n+    fn read_line(&mut self) -> IoResult<String> {\n         self.read_until('\\n' as u8).and_then(|line|\n             match str::from_utf8(line.as_slice()) {\n                 Some(s) => Ok(s.to_strbuf()),"}, {"sha": "468bf5551b3342ca10d90db35308c77372dd1e3e", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -583,11 +583,11 @@ mod tests {\n         }\n     })\n \n-    pub fn read_all(input: &mut Reader) -> StrBuf {\n+    pub fn read_all(input: &mut Reader) -> String {\n         input.read_to_str().unwrap()\n     }\n \n-    pub fn run_output(cmd: Command) -> StrBuf {\n+    pub fn run_output(cmd: Command) -> String {\n         let p = cmd.spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();"}, {"sha": "0d42e1743f561f0a098ae3b4da3a93c621ac5d55", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -49,7 +49,7 @@\n //! `&str`, a UTF-8 string, is a built-in type, and the standard library\n //! defines methods for it on a variety of traits in the\n //! [`str`](str/index.html) module. Rust strings are immutable;\n-//! use the `StrBuf` type defined in [`strbuf`](strbuf/index.html)\n+//! use the `String` type defined in [`strbuf`](strbuf/index.html)\n //! for a mutable string builder.\n //!\n //! For converting to strings use the [`format!`](fmt/index.html)\n@@ -206,7 +206,7 @@ pub mod prelude;\n pub mod slice;\n pub mod vec;\n pub mod str;\n-pub mod strbuf;\n+pub mod string;\n \n pub mod ascii;\n \n@@ -285,5 +285,5 @@ mod std {\n \n     // The test runner requires std::slice::Vector, so re-export std::slice just for it.\n     #[cfg(test)] pub use slice;\n-    #[cfg(test)] pub use strbuf;\n+    #[cfg(test)] pub use string;\n }"}, {"sha": "2412e18bf621a42f27d3530705dc699d88d88b72", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -276,7 +276,7 @@ mod tests {\n \n     #[test]\n     fn test_tls_multitask() {\n-        static my_key: Key<StrBuf> = &Key;\n+        static my_key: Key<String> = &Key;\n         my_key.replace(Some(\"parent data\".to_strbuf()));\n         task::spawn(proc() {\n             // TLS shouldn't carry over.\n@@ -294,15 +294,15 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite() {\n-        static my_key: Key<StrBuf> = &Key;\n+        static my_key: Key<String> = &Key;\n         my_key.replace(Some(\"first data\".to_strbuf()));\n         my_key.replace(Some(\"next data\".to_strbuf())); // Shouldn't leak.\n         assert!(my_key.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n-        static my_key: Key<StrBuf> = &Key;\n+        static my_key: Key<String> = &Key;\n         my_key.replace(Some(\"weasel\".to_strbuf()));\n         assert!(my_key.replace(None).unwrap() == \"weasel\".to_strbuf());\n         // Pop must remove the data from the map.\n@@ -317,15 +317,15 @@ mod tests {\n         // to get recorded as something within a rust stack segment. Then a\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n-        static my_key: Key<StrBuf> = &Key;\n+        static my_key: Key<String> = &Key;\n         task::spawn(proc() {\n             my_key.replace(Some(\"hax\".to_strbuf()));\n         });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n-        static str_key: Key<StrBuf> = &Key;\n+        static str_key: Key<String> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n@@ -337,7 +337,7 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite_multiple_types() {\n-        static str_key: Key<StrBuf> = &Key;\n+        static str_key: Key<String> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n@@ -356,7 +356,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_tls_cleanup_on_failure() {\n-        static str_key: Key<StrBuf> = &Key;\n+        static str_key: Key<String> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         str_key.replace(Some(\"parent data\".to_strbuf()));"}, {"sha": "b7bd3705bf20b0a8f4d33d64c0e043d2bf98c5ec", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -20,7 +20,7 @@ use intrinsics;\n use libc::c_int;\n use num::strconv;\n use num;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -243,7 +243,7 @@ impl FloatMath for f32 {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str(num: f32) -> StrBuf {\n+pub fn to_str(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -255,7 +255,7 @@ pub fn to_str(num: f32) -> StrBuf {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str_hex(num: f32) -> StrBuf {\n+pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -269,7 +269,7 @@ pub fn to_str_hex(num: f32) -> StrBuf {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-pub fn to_str_radix_special(num: f32, rdx: uint) -> (StrBuf, bool) {\n+pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n@@ -282,7 +282,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (StrBuf, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_exact(num: f32, dig: uint) -> StrBuf {\n+pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n@@ -296,7 +296,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> StrBuf {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_digits(num: f32, dig: uint) -> StrBuf {\n+pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n@@ -311,7 +311,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> StrBuf {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> StrBuf {\n+pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n     r\n@@ -326,7 +326,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> StrBuf {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> StrBuf {\n+pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n     r\n@@ -346,7 +346,7 @@ impl num::ToStrRadix for f32 {\n     /// possible misinterpretation of the result at higher bases. If those values\n     /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> StrBuf {\n+    fn to_str_radix(&self, rdx: uint) -> String {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\"}, {"sha": "e7b29c733ec0fc9798510aa82eb4ea6f31283fe9", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -19,7 +19,7 @@ use intrinsics;\n use libc::c_int;\n use num::strconv;\n use num;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -251,7 +251,7 @@ impl FloatMath for f64 {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str(num: f64) -> StrBuf {\n+pub fn to_str(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -263,7 +263,7 @@ pub fn to_str(num: f64) -> StrBuf {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str_hex(num: f64) -> StrBuf {\n+pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -277,7 +277,7 @@ pub fn to_str_hex(num: f64) -> StrBuf {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-pub fn to_str_radix_special(num: f64, rdx: uint) -> (StrBuf, bool) {\n+pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n@@ -290,7 +290,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (StrBuf, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_exact(num: f64, dig: uint) -> StrBuf {\n+pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n@@ -304,7 +304,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> StrBuf {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_digits(num: f64, dig: uint) -> StrBuf {\n+pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n@@ -319,7 +319,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> StrBuf {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> StrBuf {\n+pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n     r\n@@ -334,7 +334,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> StrBuf {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> StrBuf {\n+pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n     r\n@@ -354,7 +354,7 @@ impl num::ToStrRadix for f64 {\n     /// possible misinterpretation of the result at higher bases. If those values\n     /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> StrBuf {\n+    fn to_str_radix(&self, rdx: uint) -> String {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\"}, {"sha": "e0c5d93f28abc8a48da38c1181226dbab18b2d5c", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "6938689f47d70020136472723d9a53560801a8c3", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "4be43876105cb279b013a69f608efa754a6f54a1", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "b0459ca46f1affc1079617fd4764ad4ed57cc5d2", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "774b0d7d8cf64d871f5c09301714ebd26e55ac28", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "4456c8124ba01e49e1302db1de75aabd4747a77b", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -77,7 +77,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n-    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+    fn to_str_radix(&self, radix: uint) -> String {\n         format_strbuf!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }"}, {"sha": "9700f8c9970c410258dc9a5a9ee6c25bc416b153", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,7 +16,7 @@\n #![allow(missing_doc)]\n \n use option::Option;\n-use strbuf::StrBuf;\n+use string::String;\n \n #[cfg(test)] use fmt::Show;\n \n@@ -112,7 +112,7 @@ pub trait FloatMath: Float {\n \n /// A generic trait for converting a value to a string with a radix (base)\n pub trait ToStrRadix {\n-    fn to_str_radix(&self, radix: uint) -> StrBuf;\n+    fn to_str_radix(&self, radix: uint) -> String;\n }\n \n /// A generic trait for converting a string with a radix (base) to a value"}, {"sha": "1efe83217f48d3b4042f98aa364f47e5be733057", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -22,7 +22,7 @@ use option::{None, Option, Some};\n use slice::{ImmutableVector, MutableVector};\n use std::cmp::{Ord, Eq};\n use str::StrSlice;\n-use strbuf::StrBuf;\n+use string::String;\n use vec::Vec;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n@@ -496,10 +496,10 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+\n                              Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n-        ) -> (StrBuf, bool) {\n+        ) -> (String, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits, exp_format, exp_capital);\n-    (StrBuf::from_utf8(bytes).unwrap(), special)\n+    (String::from_utf8(bytes).unwrap(), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}, {"sha": "5200fbd7a3b4bb6352b4012693862760d1e74bc2", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "18cdb9e7e87d2cd1cb2082a0e2b28b0a82c7ce7a", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "7c17d2cd0bdb3978ef90c3a34b1e889a1d5631b5", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "05d86fba40e8039a6c0b12dd36f3d25820ee0c49", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ac38f740931800216ae56fe8f824d6317824f7a5", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n-use strbuf::StrBuf;\n+use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "e59e638faa9f562ef14aa02f4c180dd068019469", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -78,7 +78,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n-    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+    fn to_str_radix(&self, radix: uint) -> String {\n         format_strbuf!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }"}, {"sha": "00e5574c86dd3cd1da4268311a24de35f90e66c0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -44,7 +44,7 @@ use result::{Err, Ok, Result};\n use slice::{Vector, ImmutableVector, MutableVector, OwnedVector};\n use str::{Str, StrSlice, StrAllocating};\n use str;\n-use strbuf::StrBuf;\n+use string::String;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n \n@@ -104,13 +104,13 @@ pub mod win32 {\n     use option;\n     use os::TMPBUF_SZ;\n     use slice::{MutableVector, ImmutableVector};\n-    use strbuf::StrBuf;\n+    use string::String;\n     use str::{StrSlice, StrAllocating};\n     use str;\n     use vec::Vec;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n-        -> Option<StrBuf> {\n+        -> Option<String> {\n \n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n@@ -176,7 +176,7 @@ fn with_env_lock<T>(f: || -> T) -> T {\n ///\n /// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n /// for details.\n-pub fn env() -> Vec<(StrBuf,StrBuf)> {\n+pub fn env() -> Vec<(String,String)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n         let k = str::from_utf8_lossy(k.as_slice()).to_strbuf();\n         let v = str::from_utf8_lossy(v.as_slice()).to_strbuf();\n@@ -276,7 +276,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// # Failure\n ///\n /// Fails if `n` has any interior NULs.\n-pub fn getenv(n: &str) -> Option<StrBuf> {\n+pub fn getenv(n: &str) -> Option<String> {\n     getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v.as_slice()).to_strbuf())\n }\n \n@@ -306,7 +306,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n #[cfg(windows)]\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n-pub fn getenv(n: &str) -> Option<StrBuf> {\n+pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n@@ -436,7 +436,7 @@ pub fn pipe() -> Pipe {\n }\n \n /// Returns the proper dll filename for the given basename of a file.\n-pub fn dll_filename(base: &str) -> StrBuf {\n+pub fn dll_filename(base: &str) -> String {\n     format_strbuf!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n \n@@ -692,11 +692,11 @@ pub fn errno() -> uint {\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n-pub fn error_string(errnum: uint) -> StrBuf {\n+pub fn error_string(errnum: uint) -> String {\n     return strerror(errnum);\n \n     #[cfg(unix)]\n-    fn strerror(errnum: uint) -> StrBuf {\n+    fn strerror(errnum: uint) -> String {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n@@ -741,7 +741,7 @@ pub fn error_string(errnum: uint) -> StrBuf {\n     }\n \n     #[cfg(windows)]\n-    fn strerror(errnum: uint) -> StrBuf {\n+    fn strerror(errnum: uint) -> String {\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPWSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -793,7 +793,7 @@ pub fn error_string(errnum: uint) -> StrBuf {\n }\n \n /// Get a string representing the platform-dependent last error\n-pub fn last_os_error() -> StrBuf {\n+pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n@@ -856,15 +856,15 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n }\n \n #[cfg(not(windows))]\n-fn real_args() -> Vec<StrBuf> {\n+fn real_args() -> Vec<String> {\n     real_args_as_bytes().move_iter()\n                         .map(|v| {\n                             str::from_utf8_lossy(v.as_slice()).into_strbuf()\n                         }).collect()\n }\n \n #[cfg(windows)]\n-fn real_args() -> Vec<StrBuf> {\n+fn real_args() -> Vec<String> {\n     use slice;\n     use option::Expect;\n \n@@ -919,13 +919,13 @@ extern \"system\" {\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n /// See `str::from_utf8_lossy` for details.\n #[cfg(not(test))]\n-pub fn args() -> Vec<StrBuf> {\n+pub fn args() -> Vec<String> {\n     real_args()\n }\n \n #[cfg(test)]\n #[allow(missing_doc)]\n-pub fn args() -> ::realstd::vec::Vec<::realstd::strbuf::StrBuf> {\n+pub fn args() -> ::realstd::vec::Vec<::realstd::string::String> {\n     ::realstd::os::args()\n }\n \n@@ -1524,7 +1524,7 @@ mod tests {\n         assert!(a.len() >= 1);\n     }\n \n-    fn make_rand_name() -> StrBuf {\n+    fn make_rand_name() -> String {\n         let mut rng = rand::task_rng();\n         let n = format_strbuf!(\"TEST{}\", rng.gen_ascii_str(10u).as_slice());\n         assert!(getenv(n.as_slice()).is_none());"}, {"sha": "681b19a2d1ab5eb3c3a06eb4bfefdcab89e198da", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -73,7 +73,7 @@ use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n-use strbuf::StrBuf;\n+use string::String;\n use slice::Vector;\n use slice::{ImmutableEqVector, ImmutableVector};\n use vec::Vec;\n@@ -507,7 +507,7 @@ impl<'a> BytesContainer for &'a str {\n     fn is_str(_: Option<&'a str>) -> bool { true }\n }\n \n-impl BytesContainer for StrBuf {\n+impl BytesContainer for String {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_bytes()\n@@ -517,7 +517,7 @@ impl BytesContainer for StrBuf {\n         Some(self.as_slice())\n     }\n     #[inline]\n-    fn is_str(_: Option<StrBuf>) -> bool { true }\n+    fn is_str(_: Option<String>) -> bool { true }\n }\n \n impl<'a> BytesContainer for &'a [u8] {"}, {"sha": "763883a159fd7fbb65cf70060cb06afc8e9cbdcd", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -22,7 +22,7 @@ use mem;\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n-use strbuf::StrBuf;\n+use string::String;\n use vec::Vec;\n \n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -74,7 +74,7 @@ pub type Components<'a> = Map<'a, Option<&'a str>, &'a [u8],\n // preserved by the data structure; let the Windows API error out on them.\n #[deriving(Clone)]\n pub struct Path {\n-    repr: StrBuf, // assumed to never be empty\n+    repr: String, // assumed to never be empty\n     prefix: Option<PathPrefix>,\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n@@ -194,7 +194,7 @@ impl GenericPathUnsafe for Path {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n             None if \"..\" == self.repr.as_slice() => {\n-                let mut s = StrBuf::with_capacity(3 + filename.len());\n+                let mut s = String::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n                 s.push_char(SEP);\n                 s.push_str(filename);\n@@ -204,20 +204,20 @@ impl GenericPathUnsafe for Path {\n                 self.update_normalized(filename);\n             }\n             Some((_,idxa,end)) if self.repr.as_slice().slice(idxa,end) == \"..\" => {\n-                let mut s = StrBuf::with_capacity(end + 1 + filename.len());\n+                let mut s = String::with_capacity(end + 1 + filename.len());\n                 s.push_str(self.repr.as_slice().slice_to(end));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n-                let mut s = StrBuf::with_capacity(idxb + filename.len());\n+                let mut s = String::with_capacity(idxb + filename.len());\n                 s.push_str(self.repr.as_slice().slice_to(idxb));\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,_,_)) => {\n-                let mut s = StrBuf::with_capacity(idxb + 1 + filename.len());\n+                let mut s = String::with_capacity(idxb + 1 + filename.len());\n                 s.push_str(self.repr.as_slice().slice_to(idxb));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n@@ -261,7 +261,7 @@ impl GenericPathUnsafe for Path {\n             let newpath = Path::normalize__(path, prefix);\n             me.repr = match newpath {\n                 Some(p) => p,\n-                None => StrBuf::from_str(path)\n+                None => String::from_str(path)\n             };\n             me.prefix = prefix;\n             me.update_sepidx();\n@@ -272,7 +272,7 @@ impl GenericPathUnsafe for Path {\n             let path_ = if is_verbatim(me) { Path::normalize__(path, None) }\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n-            let mut s = StrBuf::with_capacity(me.repr.len() + 1 + pathlen);\n+            let mut s = String::with_capacity(me.repr.len() + 1 + pathlen);\n             s.push_str(me.repr.as_slice());\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n@@ -424,7 +424,7 @@ impl GenericPath for Path {\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == self.repr.as_slice() => false,\n             None => {\n-                self.repr = StrBuf::from_str(\".\");\n+                self.repr = String::from_str(\".\");\n                 self.sepidx = None;\n                 true\n             }\n@@ -687,7 +687,7 @@ impl Path {\n         }\n     }\n \n-    fn normalize_<S: StrAllocating>(s: S) -> (Option<PathPrefix>, StrBuf) {\n+    fn normalize_<S: StrAllocating>(s: S) -> (Option<PathPrefix>, String) {\n         // make borrowck happy\n         let (prefix, val) = {\n             let prefix = parse_prefix(s.as_slice());\n@@ -700,13 +700,13 @@ impl Path {\n         })\n     }\n \n-    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<StrBuf> {\n+    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<String> {\n         if prefix_is_verbatim(prefix) {\n             // don't do any normalization\n             match prefix {\n                 Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n                     // the server component has no trailing '\\'\n-                    let mut s = StrBuf::from_str(s);\n+                    let mut s = String::from_str(s);\n                     s.push_char(SEP);\n                     Some(s)\n                 }\n@@ -735,7 +735,7 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = StrBuf::from_str(s.slice_to(len));\n+                                let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     *v.get_mut(0) = v.get(0)\n@@ -753,7 +753,7 @@ impl Path {\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = StrBuf::from_str(s.slice_to(len));\n+                                let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     *v.get_mut(4) = v.get(4).to_ascii().to_upper().to_byte();\n@@ -763,18 +763,18 @@ impl Path {\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(StrBuf::from_str(s.slice_to(plen)))\n+                                    Some(String::from_str(s.slice_to(plen)))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n-                        Some(StrBuf::from_char(1, SEP))\n+                        Some(String::from_char(1, SEP))\n                     } else {\n                         let prefix_ = s.slice_to(prefix_len(prefix));\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n-                        let mut s = StrBuf::with_capacity(n);\n+                        let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n                                 s.push_char(prefix_[0].to_ascii().to_upper().to_char());"}, {"sha": "8d028a7a96a7e83e35e93f9ba01a38f05ea57f80", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -80,7 +80,7 @@ pub use slice::{CloneableVector, ImmutableCloneableVector, MutableCloneableVecto\n pub use slice::{ImmutableVector, MutableVector};\n pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, MutableTotalOrdVector};\n pub use slice::{Vector, VectorVector, OwnedVector, MutableVectorAllocating};\n-pub use strbuf::StrBuf;\n+pub use string::String;\n pub use vec::Vec;\n \n // Reexported runtime types"}, {"sha": "d800232d3b873a2631737f98fb5d7c7acd873ef4", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -30,7 +30,7 @@ use reflect;\n use result::{Ok, Err};\n use slice::Vector;\n use str::{Str, StrSlice};\n-use strbuf::StrBuf;\n+use string::String;\n use to_str::ToStr;\n use vec::Vec;\n \n@@ -602,7 +602,7 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     }\n }\n \n-pub fn repr_to_str<T>(t: &T) -> StrBuf {\n+pub fn repr_to_str<T>(t: &T) -> String {\n     use str;\n     use str::StrAllocating;\n     use io;"}, {"sha": "cd59de8899a10bdd7c37adfc6dd39966b0939d69", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -420,10 +420,10 @@ mod test {\n \n     #[test]\n     fn tls() {\n-        local_data_key!(key: @StrBuf)\n+        local_data_key!(key: @String)\n         key.replace(Some(@\"data\".to_strbuf()));\n         assert_eq!(key.get().unwrap().as_slice(), \"data\");\n-        local_data_key!(key2: @StrBuf)\n+        local_data_key!(key2: @String)\n         key2.replace(Some(@\"data\".to_strbuf()));\n         assert_eq!(key2.get().unwrap().as_slice(), \"data\");\n     }"}, {"sha": "be05bfceaac3e1da8024b8db55b0330d101712c3", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -71,7 +71,7 @@ use rt::backtrace;\n use rt::local::Local;\n use rt::task::Task;\n use str::Str;\n-use strbuf::StrBuf;\n+use string::String;\n use task::TaskResult;\n \n use uw = rt::libunwind;\n@@ -389,7 +389,7 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n     {\n         let msg_s = match msg.as_ref::<&'static str>() {\n             Some(s) => *s,\n-            None => match msg.as_ref::<StrBuf>() {\n+            None => match msg.as_ref::<String>() {\n                 Some(s) => s.as_slice(),\n                 None => \"Box<Any>\",\n             }"}, {"sha": "d68ed099a4a4e81f14a32b3dda0ff17126ba59f7", "filename": "src/libstd/str.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -79,7 +79,7 @@ use option::{None, Option, Some};\n use result::Result;\n use slice::Vector;\n use slice::{ImmutableVector, MutableVector, CloneableVector};\n-use strbuf::StrBuf;\n+use string::String;\n use vec::Vec;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharOffsets};\n@@ -98,51 +98,51 @@ Section: Creating a string\n ///\n /// Returns `Err` with the original vector if the vector contains invalid\n /// UTF-8.\n-pub fn from_utf8_owned(vv: Vec<u8>) -> Result<StrBuf, Vec<u8>> {\n-    StrBuf::from_utf8(vv)\n+pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n+    String::from_utf8(vv)\n }\n \n /// Convert a byte to a UTF-8 string\n ///\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n-pub fn from_byte(b: u8) -> StrBuf {\n+pub fn from_byte(b: u8) -> String {\n     assert!(b < 128u8);\n-    StrBuf::from_char(1, b as char)\n+    String::from_char(1, b as char)\n }\n \n /// Convert a char to a string\n-pub fn from_char(ch: char) -> StrBuf {\n-    let mut buf = StrBuf::new();\n+pub fn from_char(ch: char) -> String {\n+    let mut buf = String::new();\n     buf.push_char(ch);\n     buf\n }\n \n /// Convert a vector of chars to a string\n-pub fn from_chars(chs: &[char]) -> StrBuf {\n+pub fn from_chars(chs: &[char]) -> String {\n     chs.iter().map(|c| *c).collect()\n }\n \n /// Methods for vectors of strings\n pub trait StrVector {\n     /// Concatenate a vector of strings.\n-    fn concat(&self) -> StrBuf;\n+    fn concat(&self) -> String;\n \n     /// Concatenate a vector of strings, placing a given separator between each.\n-    fn connect(&self, sep: &str) -> StrBuf;\n+    fn connect(&self, sep: &str) -> String;\n }\n \n impl<'a, S: Str> StrVector for &'a [S] {\n-    fn concat(&self) -> StrBuf {\n+    fn concat(&self) -> String {\n         if self.is_empty() {\n-            return StrBuf::new();\n+            return String::new();\n         }\n \n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n-        let mut result = StrBuf::with_capacity(len);\n+        let mut result = String::with_capacity(len);\n \n         for s in self.iter() {\n             result.push_str(s.as_slice())\n@@ -151,9 +151,9 @@ impl<'a, S: Str> StrVector for &'a [S] {\n         result\n     }\n \n-    fn connect(&self, sep: &str) -> StrBuf {\n+    fn connect(&self, sep: &str) -> String {\n         if self.is_empty() {\n-            return StrBuf::new();\n+            return String::new();\n         }\n \n         // concat is faster\n@@ -165,7 +165,7 @@ impl<'a, S: Str> StrVector for &'a [S] {\n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = sep.len() * (self.len() - 1)\n             + self.iter().map(|s| s.as_slice().len()).sum();\n-        let mut result = StrBuf::with_capacity(len);\n+        let mut result = String::with_capacity(len);\n         let mut first = true;\n \n         for s in self.iter() {\n@@ -182,12 +182,12 @@ impl<'a, S: Str> StrVector for &'a [S] {\n \n impl<'a, S: Str> StrVector for Vec<S> {\n     #[inline]\n-    fn concat(&self) -> StrBuf {\n+    fn concat(&self) -> String {\n         self.as_slice().concat()\n     }\n \n     #[inline]\n-    fn connect(&self, sep: &str) -> StrBuf {\n+    fn connect(&self, sep: &str) -> String {\n         self.as_slice().connect(sep)\n     }\n }\n@@ -303,8 +303,8 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n /// # Return value\n ///\n /// The original string with all occurrences of `from` replaced with `to`\n-pub fn replace(s: &str, from: &str, to: &str) -> StrBuf {\n-    let mut result = StrBuf::new();\n+pub fn replace(s: &str, from: &str, to: &str) -> String {\n+    let mut result = String::new();\n     let mut last_end = 0;\n     for (start, end) in s.match_indices(from) {\n         result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n@@ -336,8 +336,8 @@ Section: Misc\n /// v[4] = 0xD800;\n /// assert_eq!(str::from_utf16(v), None);\n /// ```\n-pub fn from_utf16(v: &[u16]) -> Option<StrBuf> {\n-    let mut s = StrBuf::with_capacity(v.len() / 2);\n+pub fn from_utf16(v: &[u16]) -> Option<String> {\n+    let mut s = String::with_capacity(v.len() / 2);\n     for c in utf16_items(v) {\n         match c {\n             ScalarValue(c) => s.push_char(c),\n@@ -362,7 +362,7 @@ pub fn from_utf16(v: &[u16]) -> Option<StrBuf> {\n /// assert_eq!(str::from_utf16_lossy(v),\n ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_owned());\n /// ```\n-pub fn from_utf16_lossy(v: &[u16]) -> StrBuf {\n+pub fn from_utf16_lossy(v: &[u16]) -> String {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n@@ -409,7 +409,7 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         }\n     }\n \n-    let mut res = StrBuf::with_capacity(total);\n+    let mut res = String::with_capacity(total);\n \n     if i > 0 {\n         unsafe {\n@@ -509,14 +509,14 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n Section: MaybeOwned\n */\n \n-/// A MaybeOwned is a string that can hold either a StrBuf or a &str.\n+/// A MaybeOwned is a string that can hold either a String or a &str.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n pub enum MaybeOwned<'a> {\n     /// A borrowed string\n     Slice(&'a str),\n     /// An owned string\n-    Owned(StrBuf)\n+    Owned(String)\n }\n \n /// SendStr is a specialization of `MaybeOwned` to be sendable\n@@ -548,7 +548,7 @@ pub trait IntoMaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a>;\n }\n \n-impl<'a> IntoMaybeOwned<'a> for StrBuf {\n+impl<'a> IntoMaybeOwned<'a> for String {\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> {\n         Owned(self)\n@@ -607,7 +607,7 @@ impl<'a> Str for MaybeOwned<'a> {\n \n impl<'a> StrAllocating for MaybeOwned<'a> {\n     #[inline]\n-    fn into_owned(self) -> StrBuf {\n+    fn into_owned(self) -> String {\n         match self {\n             Slice(s) => s.to_owned(),\n             Owned(s) => s\n@@ -661,15 +661,15 @@ pub mod raw {\n     use libc;\n     use mem;\n     use raw::Slice;\n-    use strbuf::StrBuf;\n+    use string::String;\n     use vec::Vec;\n \n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> StrBuf {\n-        let mut result = StrBuf::new();\n+    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> String {\n+        let mut result = String::new();\n         result.push_bytes(mem::transmute(Slice {\n             data: buf,\n             len: len,\n@@ -678,21 +678,21 @@ pub mod raw {\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    pub unsafe fn from_c_str(c_string: *libc::c_char) -> StrBuf {\n-        let mut buf = StrBuf::new();\n+    pub unsafe fn from_c_str(c_string: *libc::c_char) -> String {\n+        let mut buf = String::new();\n         buf.push_bytes(CString::new(c_string, false).as_bytes_no_nul());\n         buf\n     }\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n     #[inline]\n-    pub unsafe fn from_utf8_owned(v: Vec<u8>) -> StrBuf {\n+    pub unsafe fn from_utf8_owned(v: Vec<u8>) -> String {\n         mem::transmute(v)\n     }\n \n     /// Converts a byte to a string.\n-    pub unsafe fn from_byte(u: u8) -> StrBuf {\n+    pub unsafe fn from_byte(u: u8) -> String {\n         from_utf8_owned(vec![u])\n     }\n \n@@ -721,35 +721,35 @@ Section: Trait implementations\n \n /// Any string that can be represented as a slice\n pub trait StrAllocating: Str {\n-    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n-    fn into_owned(self) -> StrBuf;\n+    /// Convert `self` into a `String`, not making a copy if possible.\n+    fn into_owned(self) -> String;\n \n-    /// Convert `self` into a `StrBuf`.\n+    /// Convert `self` into a `String`.\n     #[inline]\n-    fn to_strbuf(&self) -> StrBuf {\n-        StrBuf::from_str(self.as_slice())\n+    fn to_strbuf(&self) -> String {\n+        String::from_str(self.as_slice())\n     }\n \n-    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n+    /// Convert `self` into a `String`, not making a copy if possible.\n     #[inline]\n-    fn into_strbuf(self) -> StrBuf {\n+    fn into_strbuf(self) -> String {\n         self.into_owned()\n     }\n \n     /// Escape each char in `s` with `char::escape_default`.\n-    fn escape_default(&self) -> StrBuf {\n+    fn escape_default(&self) -> String {\n         let me = self.as_slice();\n-        let mut out = StrBuf::with_capacity(me.len());\n+        let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n         out\n     }\n \n     /// Escape each char in `s` with `char::escape_unicode`.\n-    fn escape_unicode(&self) -> StrBuf {\n+    fn escape_unicode(&self) -> String {\n         let me = self.as_slice();\n-        let mut out = StrBuf::with_capacity(me.len());\n+        let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n@@ -780,9 +780,9 @@ pub trait StrAllocating: Str {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    fn replace(&self, from: &str, to: &str) -> StrBuf {\n+    fn replace(&self, from: &str, to: &str) -> String {\n         let me = self.as_slice();\n-        let mut result = StrBuf::new();\n+        let mut result = String::new();\n         let mut last_end = 0;\n         for (start, end) in me.match_indices(from) {\n             result.push_str(unsafe{raw::slice_bytes(me, last_end, start)});\n@@ -793,9 +793,9 @@ pub trait StrAllocating: Str {\n         result\n     }\n \n-    /// Copy a slice into a new `StrBuf`.\n+    /// Copy a slice into a new `String`.\n     #[inline]\n-    fn to_owned(&self) -> StrBuf {\n+    fn to_owned(&self) -> String {\n         use slice::Vector;\n \n         unsafe {\n@@ -816,9 +816,9 @@ pub trait StrAllocating: Str {\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n-    fn repeat(&self, nn: uint) -> StrBuf {\n+    fn repeat(&self, nn: uint) -> String {\n         let me = self.as_slice();\n-        let mut ret = StrBuf::with_capacity(nn * me.len());\n+        let mut ret = String::with_capacity(nn * me.len());\n         for _ in range(0, nn) {\n             ret.push_str(me);\n         }\n@@ -887,7 +887,7 @@ pub trait StrAllocating: Str {\n \n impl<'a> StrAllocating for &'a str {\n     #[inline]\n-    fn into_owned(self) -> StrBuf {\n+    fn into_owned(self) -> String {\n         self.to_owned()\n     }\n }\n@@ -900,18 +900,18 @@ pub trait OwnedStr {\n     fn into_bytes(self) -> Vec<u8>;\n \n     /// Pushes the given string onto this string, returning the concatenation of the two strings.\n-    fn append(self, rhs: &str) -> StrBuf;\n+    fn append(self, rhs: &str) -> String;\n }\n \n-impl OwnedStr for StrBuf {\n+impl OwnedStr for String {\n     #[inline]\n     fn into_bytes(self) -> Vec<u8> {\n         unsafe { mem::transmute(self) }\n     }\n \n     #[inline]\n-    fn append(self, rhs: &str) -> StrBuf {\n-        let mut new_str = StrBuf::from_owned_str(self);\n+    fn append(self, rhs: &str) -> String {\n+        let mut new_str = String::from_owned_str(self);\n         new_str.push_str(rhs);\n         new_str\n     }\n@@ -923,7 +923,7 @@ mod tests {\n     use default::Default;\n     use prelude::*;\n     use str::*;\n-    use strbuf::StrBuf;\n+    use string::String;\n \n     #[test]\n     fn test_eq_slice() {\n@@ -983,10 +983,10 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let empty = \"\".to_owned();\n-        let s: StrBuf = empty.as_slice().chars().collect();\n+        let s: String = empty.as_slice().chars().collect();\n         assert_eq!(empty, s);\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_owned();\n-        let s: StrBuf = data.as_slice().chars().collect();\n+        let s: String = data.as_slice().chars().collect();\n         assert_eq!(data, s);\n     }\n \n@@ -1043,25 +1043,25 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        fn t(v: &[StrBuf], s: &str) {\n+        fn t(v: &[String], s: &str) {\n             assert_eq!(v.concat(), s.to_str().into_owned());\n         }\n         t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n           \"no\".to_owned(), \"good\".to_owned()], \"youknowI'mnogood\");\n-        let v: &[StrBuf] = [];\n+        let v: &[String] = [];\n         t(v, \"\");\n         t([\"hi\".to_owned()], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n-        fn t(v: &[StrBuf], sep: &str, s: &str) {\n+        fn t(v: &[String], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep), s.to_str().into_owned());\n         }\n         t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n            \"no\".to_owned(), \"good\".to_owned()],\n           \" \", \"you know I'm no good\");\n-        let v: &[StrBuf] = [];\n+        let v: &[String] = [];\n         t(v, \" \", \"\");\n         t([\"hi\".to_owned()], \" \", \"hi\");\n     }\n@@ -1102,18 +1102,18 @@ mod tests {\n         assert_eq!(\"ab\", unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n         assert_eq!(\"bc\", unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n         assert_eq!(\"\", unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n-        fn a_million_letter_a() -> StrBuf {\n+        fn a_million_letter_a() -> String {\n             let mut i = 0;\n-            let mut rs = StrBuf::new();\n+            let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaaaaaaa\");\n                 i += 1;\n             }\n             rs\n         }\n-        fn half_a_million_letter_a() -> StrBuf {\n+        fn half_a_million_letter_a() -> String {\n             let mut i = 0;\n-            let mut rs = StrBuf::new();\n+            let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaa\");\n                 i += 1;\n@@ -1219,18 +1219,18 @@ mod tests {\n         assert_eq!(\"\", data.slice(3, 3));\n         assert_eq!(\"\u534e\", data.slice(30, 33));\n \n-        fn a_million_letter_X() -> StrBuf {\n+        fn a_million_letter_X() -> String {\n             let mut i = 0;\n-            let mut rs = StrBuf::new();\n+            let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n             rs\n         }\n-        fn half_a_million_letter_X() -> StrBuf {\n+        fn half_a_million_letter_X() -> String {\n             let mut i = 0;\n-            let mut rs = StrBuf::new();\n+            let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n@@ -1532,10 +1532,10 @@ mod tests {\n \n     #[test]\n     fn vec_str_conversions() {\n-        let s1: StrBuf = \"All mimsy were the borogoves\".to_strbuf();\n+        let s1: String = \"All mimsy were the borogoves\".to_strbuf();\n \n         let v: Vec<u8> = Vec::from_slice(s1.as_bytes());\n-        let s2: StrBuf = from_utf8(v.as_slice()).unwrap().to_strbuf();\n+        let s2: String = from_utf8(v.as_slice()).unwrap().to_strbuf();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -1967,30 +1967,30 @@ mod tests {\n \n     #[test]\n     fn test_nfd_chars() {\n-        assert_eq!(\"abc\".nfd_chars().collect::<StrBuf>(), \"abc\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<StrBuf>(), \"d\\u0307\\u01c4\".to_strbuf());\n-        assert_eq!(\"\\u2026\".nfd_chars().collect::<StrBuf>(), \"\\u2026\".to_strbuf());\n-        assert_eq!(\"\\u2126\".nfd_chars().collect::<StrBuf>(), \"\\u03a9\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"a\\u0301\".nfd_chars().collect::<StrBuf>(), \"a\\u0301\".to_strbuf());\n-        assert_eq!(\"\\u0301a\".nfd_chars().collect::<StrBuf>(), \"\\u0301a\".to_strbuf());\n-        assert_eq!(\"\\ud4db\".nfd_chars().collect::<StrBuf>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n-        assert_eq!(\"\\uac1c\".nfd_chars().collect::<StrBuf>(), \"\\u1100\\u1162\".to_strbuf());\n+        assert_eq!(\"abc\".nfd_chars().collect::<String>(), \"abc\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<String>(), \"d\\u0307\\u01c4\".to_strbuf());\n+        assert_eq!(\"\\u2026\".nfd_chars().collect::<String>(), \"\\u2026\".to_strbuf());\n+        assert_eq!(\"\\u2126\".nfd_chars().collect::<String>(), \"\\u03a9\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"a\\u0301\".nfd_chars().collect::<String>(), \"a\\u0301\".to_strbuf());\n+        assert_eq!(\"\\u0301a\".nfd_chars().collect::<String>(), \"\\u0301a\".to_strbuf());\n+        assert_eq!(\"\\ud4db\".nfd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n+        assert_eq!(\"\\uac1c\".nfd_chars().collect::<String>(), \"\\u1100\\u1162\".to_strbuf());\n     }\n \n     #[test]\n     fn test_nfkd_chars() {\n-        assert_eq!(\"abc\".nfkd_chars().collect::<StrBuf>(), \"abc\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<StrBuf>(), \"d\\u0307DZ\\u030c\".to_strbuf());\n-        assert_eq!(\"\\u2026\".nfkd_chars().collect::<StrBuf>(), \"...\".to_strbuf());\n-        assert_eq!(\"\\u2126\".nfkd_chars().collect::<StrBuf>(), \"\\u03a9\".to_strbuf());\n-        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<StrBuf>(), \"d\\u0323\\u0307\".to_strbuf());\n-        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<StrBuf>(), \"a\\u0301\".to_strbuf());\n-        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<StrBuf>(), \"\\u0301a\".to_strbuf());\n-        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<StrBuf>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n-        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<StrBuf>(), \"\\u1100\\u1162\".to_strbuf());\n+        assert_eq!(\"abc\".nfkd_chars().collect::<String>(), \"abc\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<String>(), \"d\\u0307DZ\\u030c\".to_strbuf());\n+        assert_eq!(\"\\u2026\".nfkd_chars().collect::<String>(), \"...\".to_strbuf());\n+        assert_eq!(\"\\u2126\".nfkd_chars().collect::<String>(), \"\\u03a9\".to_strbuf());\n+        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<String>(), \"d\\u0323\\u0307\".to_strbuf());\n+        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<String>(), \"a\\u0301\".to_strbuf());\n+        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<String>(), \"\\u0301a\".to_strbuf());\n+        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<String>(), \"\\u1111\\u1171\\u11b6\".to_strbuf());\n+        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<String>(), \"\\u1100\\u1162\".to_strbuf());\n     }\n \n     #[test]\n@@ -2035,7 +2035,7 @@ mod tests {\n         }\n \n         t::<&str>();\n-        t::<StrBuf>();\n+        t::<String>();\n     }\n \n     #[test]\n@@ -2110,7 +2110,7 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-      let owned: Option<StrBuf> = from_str(\"string\");\n+      let owned: Option<String> = from_str(\"string\");\n       assert_eq!(owned, Some(\"string\".to_strbuf()));\n     }\n "}, {"sha": "f4d1e2a18588ca5c8e920bd4c2ca46cd430f28ae", "filename": "src/libstd/string.rs", "status": "renamed", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstring.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -31,46 +31,46 @@ use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n-pub struct StrBuf {\n+pub struct String {\n     vec: Vec<u8>,\n }\n \n-impl StrBuf {\n+impl String {\n     /// Creates a new string buffer initialized with the empty string.\n     #[inline]\n-    pub fn new() -> StrBuf {\n-        StrBuf {\n+    pub fn new() -> String {\n+        String {\n             vec: Vec::new(),\n         }\n     }\n \n     /// Creates a new string buffer with the given capacity.\n     #[inline]\n-    pub fn with_capacity(capacity: uint) -> StrBuf {\n-        StrBuf {\n+    pub fn with_capacity(capacity: uint) -> String {\n+        String {\n             vec: Vec::with_capacity(capacity),\n         }\n     }\n \n     /// Creates a new string buffer from length, capacity, and a pointer.\n     #[inline]\n-    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> StrBuf {\n-        StrBuf {\n+    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> String {\n+        String {\n             vec: Vec::from_raw_parts(length, capacity, ptr),\n         }\n     }\n \n     /// Creates a new string buffer from the given string.\n     #[inline]\n-    pub fn from_str(string: &str) -> StrBuf {\n-        StrBuf {\n+    pub fn from_str(string: &str) -> String {\n+        String {\n             vec: Vec::from_slice(string.as_bytes())\n         }\n     }\n \n     /// Creates a new string buffer from the given owned string, taking care not to copy it.\n     #[inline]\n-    pub fn from_owned_str(string: StrBuf) -> StrBuf {\n+    pub fn from_owned_str(string: String) -> String {\n         string\n     }\n \n@@ -80,9 +80,9 @@ impl StrBuf {\n     /// Returns `Err` with the original vector if the vector contains invalid\n     /// UTF-8.\n     #[inline]\n-    pub fn from_utf8(vec: Vec<u8>) -> Result<StrBuf, Vec<u8>> {\n+    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n         if str::is_utf8(vec.as_slice()) {\n-            Ok(StrBuf { vec: vec })\n+            Ok(String { vec: vec })\n         } else {\n             Err(vec)\n         }\n@@ -97,19 +97,19 @@ impl StrBuf {\n     /// Pushes the given string onto this buffer; then, returns `self` so that it can be used\n     /// again.\n     #[inline]\n-    pub fn append(mut self, second: &str) -> StrBuf {\n+    pub fn append(mut self, second: &str) -> String {\n         self.push_str(second);\n         self\n     }\n \n     /// Creates a string buffer by repeating a character `length` times.\n     #[inline]\n-    pub fn from_char(length: uint, ch: char) -> StrBuf {\n+    pub fn from_char(length: uint, ch: char) -> String {\n         if length == 0 {\n-            return StrBuf::new()\n+            return String::new()\n         }\n \n-        let mut buf = StrBuf::new();\n+        let mut buf = String::new();\n         buf.push_char(ch);\n         let size = buf.len() * length;\n         buf.reserve(size);\n@@ -281,37 +281,37 @@ impl StrBuf {\n     }\n }\n \n-impl Container for StrBuf {\n+impl Container for String {\n     #[inline]\n     fn len(&self) -> uint {\n         self.vec.len()\n     }\n }\n \n-impl Mutable for StrBuf {\n+impl Mutable for String {\n     #[inline]\n     fn clear(&mut self) {\n         self.vec.clear()\n     }\n }\n \n-impl FromIterator<char> for StrBuf {\n-    fn from_iter<I:Iterator<char>>(iterator: I) -> StrBuf {\n-        let mut buf = StrBuf::new();\n+impl FromIterator<char> for String {\n+    fn from_iter<I:Iterator<char>>(iterator: I) -> String {\n+        let mut buf = String::new();\n         buf.extend(iterator);\n         buf\n     }\n }\n \n-impl Extendable<char> for StrBuf {\n+impl Extendable<char> for String {\n     fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n         for ch in iterator {\n             self.push_char(ch)\n         }\n     }\n }\n \n-impl Str for StrBuf {\n+impl Str for String {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe {\n@@ -320,47 +320,47 @@ impl Str for StrBuf {\n     }\n }\n \n-impl StrAllocating for StrBuf {\n+impl StrAllocating for String {\n     #[inline]\n-    fn into_owned(self) -> StrBuf {\n+    fn into_owned(self) -> String {\n         self\n     }\n \n     #[inline]\n-    fn into_strbuf(self) -> StrBuf {\n+    fn into_strbuf(self) -> String {\n         self\n     }\n }\n \n-impl Default for StrBuf {\n-    fn default() -> StrBuf {\n-        StrBuf::new()\n+impl Default for String {\n+    fn default() -> String {\n+        String::new()\n     }\n }\n \n-impl fmt::Show for StrBuf {\n+impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }\n }\n \n-impl<H:Writer> ::hash::Hash<H> for StrBuf {\n+impl<H:Writer> ::hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n     }\n }\n \n-impl<'a, S: Str> Equiv<S> for StrBuf {\n+impl<'a, S: Str> Equiv<S> for String {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n-impl FromStr for StrBuf {\n+impl FromStr for String {\n     #[inline]\n-    fn from_str(s: &str) -> Option<StrBuf> {\n+    fn from_str(s: &str) -> Option<String> {\n         Some(s.to_strbuf())\n     }\n }\n@@ -371,27 +371,27 @@ mod tests {\n     use container::{Container, Mutable};\n     use self::test::Bencher;\n     use str::{Str, StrSlice};\n-    use super::StrBuf;\n+    use super::String;\n \n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {\n-            StrBuf::with_capacity(100)\n+            String::with_capacity(100)\n         });\n     }\n \n     #[bench]\n     fn bench_push_str(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         b.iter(|| {\n-            let mut r = StrBuf::new();\n+            let mut r = String::new();\n             r.push_str(s);\n         });\n     }\n \n     #[test]\n     fn test_push_bytes() {\n-        let mut s = StrBuf::from_str(\"ABC\");\n+        let mut s = String::from_str(\"ABC\");\n         unsafe {\n             s.push_bytes([ 'D' as u8 ]);\n         }\n@@ -400,7 +400,7 @@ mod tests {\n \n     #[test]\n     fn test_push_str() {\n-        let mut s = StrBuf::new();\n+        let mut s = String::new();\n         s.push_str(\"\");\n         assert_eq!(s.as_slice().slice_from(0), \"\");\n         s.push_str(\"abc\");\n@@ -411,7 +411,7 @@ mod tests {\n \n     #[test]\n     fn test_push_char() {\n-        let mut data = StrBuf::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+        let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n         data.push_char('\u534e');\n         data.push_char('b'); // 1 byte\n         data.push_char('\u00a2'); // 2 byte\n@@ -422,7 +422,7 @@ mod tests {\n \n     #[test]\n     fn test_pop_char() {\n-        let mut data = StrBuf::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+        let mut data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n         assert_eq!(data.pop_char().unwrap(), '\ud852\udf62'); // 4 bytes\n         assert_eq!(data.pop_char().unwrap(), '\u20ac'); // 3 bytes\n         assert_eq!(data.pop_char().unwrap(), '\u00a2'); // 2 bytes\n@@ -433,7 +433,7 @@ mod tests {\n \n     #[test]\n     fn test_shift_char() {\n-        let mut data = StrBuf::from_str(\"\ud852\udf62\u20ac\u00a2b\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+        let mut data = String::from_str(\"\ud852\udf62\u20ac\u00a2b\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n         assert_eq!(data.shift_char().unwrap(), '\ud852\udf62'); // 4 bytes\n         assert_eq!(data.shift_char().unwrap(), '\u20ac'); // 3 bytes\n         assert_eq!(data.shift_char().unwrap(), '\u00a2'); // 2 bytes\n@@ -444,15 +444,15 @@ mod tests {\n \n     #[test]\n     fn test_str_truncate() {\n-        let mut s = StrBuf::from_str(\"12345\");\n+        let mut s = String::from_str(\"12345\");\n         s.truncate(5);\n         assert_eq!(s.as_slice(), \"12345\");\n         s.truncate(3);\n         assert_eq!(s.as_slice(), \"123\");\n         s.truncate(0);\n         assert_eq!(s.as_slice(), \"\");\n \n-        let mut s = StrBuf::from_str(\"12345\");\n+        let mut s = String::from_str(\"12345\");\n         let p = s.as_slice().as_ptr();\n         s.truncate(3);\n         s.push_str(\"6\");\n@@ -463,20 +463,20 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_str_truncate_invalid_len() {\n-        let mut s = StrBuf::from_str(\"12345\");\n+        let mut s = String::from_str(\"12345\");\n         s.truncate(6);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_str_truncate_split_codepoint() {\n-        let mut s = StrBuf::from_str(\"\\u00FC\"); // \u00fc\n+        let mut s = String::from_str(\"\\u00FC\"); // \u00fc\n         s.truncate(1);\n     }\n \n     #[test]\n     fn test_str_clear() {\n-        let mut s = StrBuf::from_str(\"12345\");\n+        let mut s = String::from_str(\"12345\");\n         s.clear();\n         assert_eq!(s.len(), 0);\n         assert_eq!(s.as_slice(), \"\");", "previous_filename": "src/libstd/strbuf.rs"}, {"sha": "078883aac13ed579d4403bbd1b57c1ba43080e4d", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -51,7 +51,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n #[cfg(test)] use owned::AnyOwnExt;\n #[cfg(test)] use result;\n #[cfg(test)] use str::StrAllocating;\n-#[cfg(test)] use strbuf::StrBuf;\n+#[cfg(test)] use string::String;\n \n /// Indicates the manner in which a task exited.\n ///\n@@ -500,7 +500,7 @@ fn test_try_fail_message_owned_str() {\n         fail!(\"owned string\".to_strbuf());\n     }) {\n         Err(e) => {\n-            type T = StrBuf;\n+            type T = String;\n             assert!(e.is::<T>());\n             assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_strbuf());\n         }"}, {"sha": "afc71ab88d928bac177af5ce81adfa90abf5ba1a", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,22 +15,22 @@ The `ToStr` trait for converting to strings\n */\n \n use fmt;\n-use strbuf::StrBuf;\n+use string::String;\n \n /// A generic trait for converting a value to a string\n pub trait ToStr {\n     /// Converts the value of `self` to an owned string\n-    fn to_str(&self) -> StrBuf;\n+    fn to_str(&self) -> String;\n }\n \n /// Trait for converting a type to a string, consuming it in the process.\n pub trait IntoStr {\n     /// Consume and convert to a string.\n-    fn into_str(self) -> StrBuf;\n+    fn into_str(self) -> String;\n }\n \n impl<T: fmt::Show> ToStr for T {\n-    fn to_str(&self) -> StrBuf {\n+    fn to_str(&self) -> String {\n         format_strbuf!(\"{}\", *self)\n     }\n }"}, {"sha": "6302ab39dd87cd08bc4ba0e3a30cb420a3d61b1b", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -27,7 +27,7 @@ use path::{Path,GenericPath};\n use result::*;\n use slice::{Vector,ImmutableVector};\n use str;\n-use strbuf::StrBuf;\n+use string::String;\n use vec::Vec;\n \n pub struct DynamicLibrary { handle: *u8}\n@@ -57,7 +57,7 @@ impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open<T: ToCStr>(filename: Option<T>)\n-                        -> Result<DynamicLibrary, StrBuf> {\n+                        -> Result<DynamicLibrary, String> {\n         unsafe {\n             let mut filename = filename;\n             let maybe_library = dl::check_for_errors_in(|| {\n@@ -131,7 +131,7 @@ impl DynamicLibrary {\n     }\n \n     /// Access the value at the symbol of the dynamic library\n-    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, StrBuf> {\n+    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, String> {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n@@ -211,7 +211,7 @@ pub mod dl {\n     use ptr;\n     use result::*;\n     use str::StrAllocating;\n-    use strbuf::StrBuf;\n+    use string::String;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         filename.with_c_str(|raw_name| {\n@@ -223,7 +223,7 @@ pub mod dl {\n         dlopen(ptr::null(), Lazy as libc::c_int) as *u8\n     }\n \n-    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, StrBuf> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n         use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n@@ -276,7 +276,7 @@ pub mod dl {\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n-    use strbuf::StrBuf;\n+    use string::String;\n     use str;\n     use c_str::ToCStr;\n \n@@ -295,7 +295,7 @@ pub mod dl {\n         handle as *u8\n     }\n \n-    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, StrBuf> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n         unsafe {\n             SetLastError(0);\n "}, {"sha": "3c1e83e1b544f39d50bc33bdce3ecdbb40631453", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -671,7 +671,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let v = vec!(\"a\".to_owned(), \"b\".to_owned());\n     /// for s in v.move_iter() {\n-    ///     // s has type StrBuf, not &StrBuf\n+    ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n     /// }\n     /// ```\n@@ -1850,7 +1850,7 @@ mod tests {\n         assert_eq!(b.as_slice(), &[]);\n \n         let a = vec![\"one\".to_strbuf(), \"two\".to_strbuf()];\n-        let b: ~[StrBuf] = FromVec::from_vec(a);\n+        let b: ~[String] = FromVec::from_vec(a);\n         assert_eq!(b.as_slice(), &[\"one\".to_strbuf(), \"two\".to_strbuf()]);\n \n         struct Foo {"}, {"sha": "a854d44aab0f6683e9e7bbafb83ee832bfe85c94", "filename": "src/libsync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -189,7 +189,7 @@ mod test {\n     #[should_fail]\n     fn test_futurefail() {\n         let mut f = Future::spawn(proc() fail!());\n-        let _x: StrBuf = f.get();\n+        let _x: String = f.get();\n     }\n \n     #[test]"}, {"sha": "a6cc12fef7c52a4ac1bd3e15f114cdeb6db6954e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -22,7 +22,7 @@ use std::cell::RefCell;\n use std::fmt;\n use std::iter;\n use std::slice;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n #[deriving(Clone, Eq)]\n pub enum PathElem {\n@@ -79,10 +79,10 @@ impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n /// The type of the iterator used by with_path.\n pub type PathElems<'a, 'b> = iter::Chain<Values<'a, PathElem>, LinkedPath<'b>>;\n \n-pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> StrBuf {\n+pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> String {\n     let itr = token::get_ident_interner();\n \n-    path.fold(StrBuf::new(), |mut s, e| {\n+    path.fold(String::new(), |mut s, e| {\n         let e = itr.get(e.name());\n         if !s.is_empty() {\n             s.push_str(\"::\");\n@@ -326,11 +326,11 @@ impl Map {\n         self.with_path_next(id, None, f)\n     }\n \n-    pub fn path_to_str(&self, id: NodeId) -> StrBuf {\n+    pub fn path_to_str(&self, id: NodeId) -> String {\n         self.with_path(id, |path| path_to_str(path))\n     }\n \n-    fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> StrBuf {\n+    fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> String {\n         self.with_path(id, |path| {\n             path_to_str(path.chain(Some(PathName(i.name)).move_iter()))\n         })\n@@ -416,7 +416,7 @@ impl Map {\n             .unwrap_or_else(|| fail!(\"AstMap.span: could not find span for id {}\", id))\n     }\n \n-    pub fn node_to_str(&self, id: NodeId) -> StrBuf {\n+    pub fn node_to_str(&self, id: NodeId) -> String {\n         node_id_to_str(self, id)\n     }\n }\n@@ -663,7 +663,7 @@ pub fn map_decoded_item<F: FoldOps>(map: &Map,\n     ii\n }\n \n-fn node_id_to_str(map: &Map, id: NodeId) -> StrBuf {\n+fn node_id_to_str(map: &Map, id: NodeId) -> String {\n     match map.find(id) {\n         Some(NodeItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);"}, {"sha": "876e537fc8c660b754a43a6c33a1e959abe94c28", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -21,14 +21,14 @@ use visit;\n \n use std::cell::Cell;\n use std::cmp;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::u32;\n \n-pub fn path_name_i(idents: &[Ident]) -> StrBuf {\n+pub fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| {\n         token::get_ident(*i).get().to_strbuf()\n-    }).collect::<Vec<StrBuf>>().connect(\"::\").to_strbuf()\n+    }).collect::<Vec<String>>().connect(\"::\").to_strbuf()\n }\n \n // totally scary function: ignores all but the last element, should have\n@@ -139,7 +139,7 @@ pub enum SuffixMode {\n \n // Get a string representation of a signed int type, with its value.\n // We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n-pub fn int_ty_to_str(t: IntTy, val: Option<i64>, mode: SuffixMode) -> StrBuf {\n+pub fn int_ty_to_str(t: IntTy, val: Option<i64>, mode: SuffixMode) -> String {\n     let s = match t {\n         TyI if val.is_some() => match mode {\n             AutoSuffix => \"\",\n@@ -172,7 +172,7 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n \n // Get a string representation of an unsigned int type, with its value.\n // We want to avoid \"42uint\" in favor of \"42u\"\n-pub fn uint_ty_to_str(t: UintTy, val: Option<u64>, mode: SuffixMode) -> StrBuf {\n+pub fn uint_ty_to_str(t: UintTy, val: Option<u64>, mode: SuffixMode) -> String {\n     let s = match t {\n         TyU if val.is_some() => match mode {\n             AutoSuffix => \"\",\n@@ -200,7 +200,7 @@ pub fn uint_ty_max(t: UintTy) -> u64 {\n     }\n }\n \n-pub fn float_ty_to_str(t: FloatTy) -> StrBuf {\n+pub fn float_ty_to_str(t: FloatTy) -> String {\n     match t {\n         TyF32 => \"f32\".to_strbuf(),\n         TyF64 => \"f64\".to_strbuf(),"}, {"sha": "563bf15486d67daf8c775414781e6a39b76eaadf", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -24,7 +24,7 @@ source code snippets, etc.\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n pub trait Pos {\n     fn from_uint(n: uint) -> Self;\n@@ -189,7 +189,7 @@ pub enum MacroFormat {\n pub struct NameAndSpan {\n     /// The name of the macro that was invoked to create the thing\n     /// with this Span.\n-    pub name: StrBuf,\n+    pub name: String,\n     /// The format with which the macro was invoked.\n     pub format: MacroFormat,\n     /// The span of the macro definition itself. The macro may not\n@@ -220,7 +220,7 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n-pub type FileName = StrBuf;\n+pub type FileName = String;\n \n pub struct FileLines {\n     pub file: Rc<FileMap>,\n@@ -242,7 +242,7 @@ pub struct FileMap {\n     /// e.g. `<anon>`\n     pub name: FileName,\n     /// The complete source code\n-    pub src: StrBuf,\n+    pub src: String,\n     /// The start position of this source in the CodeMap\n     pub start_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n@@ -270,7 +270,7 @@ impl FileMap {\n     }\n \n     // get a line from the list of pre-computed line-beginnings\n-    pub fn get_line(&self, line: int) -> StrBuf {\n+    pub fn get_line(&self, line: int) -> String {\n         let mut lines = self.lines.borrow_mut();\n         let begin: BytePos = *lines.get(line as uint) - self.start_pos;\n         let begin = begin.to_uint();\n@@ -307,7 +307,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, src: StrBuf) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, src: String) -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.last() {\n             None => 0,\n@@ -318,9 +318,9 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.as_slice().starts_with(\"\\ufeff\") {\n-            StrBuf::from_str(src.as_slice().slice_from(3))\n+            String::from_str(src.as_slice().slice_from(3))\n         } else {\n-            StrBuf::from_str(src.as_slice())\n+            String::from_str(src.as_slice())\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -344,7 +344,7 @@ impl CodeMap {\n         filemap\n     }\n \n-    pub fn mk_substr_filename(&self, sp: Span) -> StrBuf {\n+    pub fn mk_substr_filename(&self, sp: Span) -> String {\n         let pos = self.lookup_char_pos(sp.lo);\n         (format!(\"<{}:{}:{}>\",\n                  pos.file.name,\n@@ -367,7 +367,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn span_to_str(&self, sp: Span) -> StrBuf {\n+    pub fn span_to_str(&self, sp: Span) -> String {\n         if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n             return \"no-location\".to_strbuf();\n         }\n@@ -396,7 +396,7 @@ impl CodeMap {\n         FileLines {file: lo.file, lines: lines}\n     }\n \n-    pub fn span_to_snippet(&self, sp: Span) -> Option<StrBuf> {\n+    pub fn span_to_snippet(&self, sp: Span) -> Option<String> {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n "}, {"sha": "06b3ed91a5a18e04208ef0da069745f81b78639a", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -24,11 +24,11 @@ use std::from_str::FromStr;\n pub struct CrateId {\n     /// A path which represents the codes origin. By convention this is the\n     /// URL, without `http://` or `https://` prefix, to the crate's repository\n-    pub path: StrBuf,\n+    pub path: String,\n     /// The name of the crate.\n-    pub name: StrBuf,\n+    pub name: String,\n     /// The version of the crate.\n-    pub version: Option<StrBuf>,\n+    pub version: Option<String>,\n }\n \n impl fmt::Show for CrateId {\n@@ -111,7 +111,7 @@ impl CrateId {\n         }\n     }\n \n-    pub fn short_name_with_version(&self) -> StrBuf {\n+    pub fn short_name_with_version(&self) -> String {\n         (format!(\"{}-{}\", self.name, self.version_or_default())).to_strbuf()\n     }\n "}, {"sha": "c6a25bc6129b3f57b228f6e1b0a6d4647635944c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -17,7 +17,7 @@ use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::io;\n use std::iter::range;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use term;\n \n // maximum number of lines we will print for each error; arbitrary.\n@@ -405,7 +405,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n \n         // indent past |name:## | and the 0-offset column location\n         let left = fm.name.len() + digits + lo.col.to_uint() + 3u;\n-        let mut s = StrBuf::new();\n+        let mut s = String::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n@@ -425,7 +425,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             };\n         }\n         try!(write!(&mut err.dst, \"{}\", s));\n-        let mut s = StrBuf::from_str(\"^\");\n+        let mut s = String::from_str(\"^\");\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n@@ -473,7 +473,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     let hi = cm.lookup_char_pos(sp.hi);\n     // Span seems to use half-opened interval, so subtract 1\n     let skip = last_line_start.len() + hi.col.to_uint() - 1;\n-    let mut s = StrBuf::new();\n+    let mut s = String::new();\n     for _ in range(0, skip) {\n         s.push_char(' ');\n     }\n@@ -508,7 +508,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     Ok(())\n }\n \n-pub fn expect<T:Clone>(diag: &SpanHandler, opt: Option<T>, msg: || -> StrBuf)\n+pub fn expect<T:Clone>(diag: &SpanHandler, opt: Option<T>, msg: || -> String)\n               -> T {\n     match opt {\n        Some(ref t) => (*t).clone(),"}, {"sha": "0808533cb4395f88778d9928cca3d774b40f06dd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -30,7 +30,7 @@ use collections::HashMap;\n // ast::MacInvocTT.\n \n pub struct MacroDef {\n-    pub name: StrBuf,\n+    pub name: String,\n     pub ext: SyntaxExtension\n }\n \n@@ -364,8 +364,8 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n \n pub struct MacroCrate {\n     pub lib: Option<Path>,\n-    pub macros: Vec<StrBuf>,\n-    pub registrar_symbol: Option<StrBuf>,\n+    pub macros: Vec<String>,\n+    pub registrar_symbol: Option<String>,\n }\n \n pub trait CrateLoader {\n@@ -543,7 +543,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n                                sp: Span,\n                                tts: &[ast::TokenTree],\n                                name: &str)\n-                               -> Option<StrBuf> {\n+                               -> Option<String> {\n     if tts.len() != 1 {\n         cx.span_err(sp, format!(\"{} takes 1 argument.\", name).as_slice());\n     } else {"}, {"sha": "83f45ca9f169b5635a8b34405ffb0e4245fb3502", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token;\n \n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n@@ -24,7 +24,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n         Some(e) => e,\n         None => return base::DummyResult::expr(sp)\n     };\n-    let mut accumulator = StrBuf::new();\n+    let mut accumulator = String::new();\n     for e in es.move_iter() {\n         match e.node {\n             ast::ExprLit(lit) => {"}, {"sha": "dad7f3e6979f77ed087373489c16f051c01f141c", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,11 +16,11 @@ use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n \n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                          -> Box<base::MacResult> {\n-    let mut res_str = StrBuf::new();\n+    let mut res_str = String::new();\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {"}, {"sha": "fb6a85e4e7ca1724fdc2e2aeec2076bc3193ed0a", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -18,7 +18,7 @@ use ext::deriving::generic::*;\n use parse::token;\n \n use collections::HashMap;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n@@ -70,7 +70,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = StrBuf::from_str(token::get_ident(name).get());\n+    let mut format_string = String::from_str(token::get_ident(name).get());\n     // the internal fields we're actually formatting\n     let mut exprs = Vec::new();\n "}, {"sha": "6c6bf5201040655645cc003ed3a7bece247e0d04", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1118,7 +1118,7 @@ mod test {\n         }\n     }\n \n-    fn expand_crate_str(crate_str: StrBuf) -> ast::Crate {\n+    fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::new_parse_sess();\n         let crate_ast = string_to_parser(&ps, crate_str).parse_crate_mod();\n         // the cfg argument actually does matter, here...\n@@ -1136,7 +1136,7 @@ mod test {\n         // println!(\"expanded: {:?}\\n\",expanded_ast);\n         //mtwt_resolve_crate(expanded_ast)\n     //}\n-    //fn expand_and_resolve_and_pretty_print (crate_str: @str) -> StrBuf {\n+    //fn expand_and_resolve_and_pretty_print (crate_str: @str) -> String {\n         //let resolved_ast = expand_and_resolve(crate_str);\n         //pprust::to_str(&resolved_ast,fake_print_crate,get_ident_interner())\n     //}"}, {"sha": "9a0b91be146890054b35fab3765c53ad47cf044d", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -23,14 +23,14 @@ use collections::{HashMap, HashSet};\n \n #[deriving(Eq)]\n enum ArgumentType {\n-    Known(StrBuf),\n+    Known(String),\n     Unsigned,\n     String,\n }\n \n enum Position {\n     Exact(uint),\n-    Named(StrBuf),\n+    Named(String),\n }\n \n struct Context<'a, 'b> {\n@@ -45,13 +45,13 @@ struct Context<'a, 'b> {\n     // Note that we keep a side-array of the ordering of the named arguments\n     // found to be sure that we can translate them in the same order that they\n     // were declared in.\n-    names: HashMap<StrBuf, @ast::Expr>,\n-    name_types: HashMap<StrBuf, ArgumentType>,\n-    name_ordering: Vec<StrBuf>,\n+    names: HashMap<String, @ast::Expr>,\n+    name_types: HashMap<String, ArgumentType>,\n+    name_ordering: Vec<String>,\n \n     // Collection of the compiled `rt::Piece` structures\n     pieces: Vec<@ast::Expr> ,\n-    name_positions: HashMap<StrBuf, uint>,\n+    name_positions: HashMap<String, uint>,\n     method_statics: Vec<@ast::Item> ,\n \n     // Updated as arguments are consumed or methods are entered\n@@ -74,10 +74,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<StrBuf>,\n-                            HashMap<StrBuf, @ast::Expr>)>) {\n+    -> (Invocation, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<String>,\n+                            HashMap<String, @ast::Expr>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<StrBuf, @ast::Expr>::new();\n+    let mut names = HashMap::<String, @ast::Expr>::new();\n     let mut order = Vec::new();\n \n     let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n@@ -855,8 +855,8 @@ pub fn expand_format_args_method(ecx: &mut ExtCtxt, sp: Span,\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n                                     efmt: @ast::Expr, args: Vec<@ast::Expr>,\n-                                    name_ordering: Vec<StrBuf>,\n-                                    names: HashMap<StrBuf, @ast::Expr>) -> @ast::Expr {\n+                                    name_ordering: Vec<String>,\n+                                    names: HashMap<String, @ast::Expr>) -> @ast::Expr {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,"}, {"sha": "5f3306318191f5e0f54a4915949bcc80bcb76bf1", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -55,7 +55,7 @@ pub mod rt {\n \n     trait ToSource : ToTokens {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source() -> StrBuf;\n+        pub fn to_source() -> String;\n \n         // If you can make source, you can definitely make tokens.\n         pub fn to_tokens(cx: &ExtCtxt) -> ~[TokenTree] {\n@@ -67,159 +67,159 @@ pub mod rt {\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        fn to_source(&self) -> StrBuf;\n+        fn to_source(&self) -> String;\n     }\n \n     impl ToSource for ast::Ident {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             get_ident(*self).get().to_strbuf()\n         }\n     }\n \n     impl ToSource for @ast::Item {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             pprust::item_to_str(*self)\n         }\n     }\n \n     impl<'a> ToSource for &'a [@ast::Item] {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             self.iter()\n                 .map(|i| i.to_source())\n-                .collect::<Vec<StrBuf>>()\n+                .collect::<Vec<String>>()\n                 .connect(\"\\n\\n\")\n                 .to_strbuf()\n         }\n     }\n \n     impl ToSource for ast::Ty {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             pprust::ty_to_str(self)\n         }\n     }\n \n     impl<'a> ToSource for &'a [ast::Ty] {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             self.iter()\n                 .map(|i| i.to_source())\n-                .collect::<Vec<StrBuf>>()\n+                .collect::<Vec<String>>()\n                 .connect(\", \")\n                 .to_strbuf()\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             pprust::generics_to_str(self)\n         }\n     }\n \n     impl ToSource for @ast::Expr {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             pprust::expr_to_str(*self)\n         }\n     }\n \n     impl ToSource for ast::Block {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             pprust::block_to_str(self)\n         }\n     }\n \n     impl<'a> ToSource for &'a str {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitStr(\n                     token::intern_and_get_ident(*self), ast::CookedStr));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for () {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             \"()\".to_strbuf()\n         }\n     }\n \n     impl ToSource for bool {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitBool(*self));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for char {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitChar(*self));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI8));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI16));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI32));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI64));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU8));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU16));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU32));\n             pprust::lit_to_str(&lit)\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self) -> StrBuf {\n+        fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU64));\n             pprust::lit_to_str(&lit)\n         }\n@@ -271,15 +271,15 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: StrBuf) -> @ast::Item;\n-        fn parse_expr(&self, s: StrBuf) -> @ast::Expr;\n-        fn parse_stmt(&self, s: StrBuf) -> @ast::Stmt;\n-        fn parse_tts(&self, s: StrBuf) -> Vec<ast::TokenTree> ;\n+        fn parse_item(&self, s: String) -> @ast::Item;\n+        fn parse_expr(&self, s: String) -> @ast::Expr;\n+        fn parse_stmt(&self, s: String) -> @ast::Stmt;\n+        fn parse_tts(&self, s: String) -> Vec<ast::TokenTree> ;\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n-        fn parse_item(&self, s: StrBuf) -> @ast::Item {\n+        fn parse_item(&self, s: String) -> @ast::Item {\n             let res = parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_strbuf(),\n                 s,\n@@ -294,22 +294,22 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: StrBuf) -> @ast::Stmt {\n+        fn parse_stmt(&self, s: String) -> @ast::Stmt {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_strbuf(),\n                                               s,\n                                               self.cfg(),\n                                               Vec::new(),\n                                               self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: StrBuf) -> @ast::Expr {\n+        fn parse_expr(&self, s: String) -> @ast::Expr {\n             parse::parse_expr_from_source_str(\"<quote expansion>\".to_strbuf(),\n                                               s,\n                                               self.cfg(),\n                                               self.parse_sess())\n         }\n \n-        fn parse_tts(&self, s: StrBuf) -> Vec<ast::TokenTree> {\n+        fn parse_tts(&self, s: String) -> Vec<ast::TokenTree> {\n             parse::parse_tts_from_source_str(\"<quote expansion>\".to_strbuf(),\n                                              s,\n                                              self.cfg(),\n@@ -375,7 +375,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n     base::MacExpr::new(expanded)\n }\n \n-fn ids_ext(strs: Vec<StrBuf> ) -> Vec<ast::Ident> {\n+fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n     strs.iter().map(|str| str_to_ident((*str).as_slice())).collect()\n }\n "}, {"sha": "04ce607e9f5c1b4e4aee1b3639d48ab2ec36a421", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -74,7 +74,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let string = cx.mod_path()\n                    .iter()\n                    .map(|x| token::get_ident(*x).get().to_strbuf())\n-                   .collect::<Vec<StrBuf>>()\n+                   .collect::<Vec<String>>()\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str(\n             sp,"}, {"sha": "8780620ced54c9bd98919db35c4b9028a6075790", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -203,8 +203,8 @@ pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[Rc<NamedMatch>])\n \n pub enum ParseResult {\n     Success(HashMap<Ident, Rc<NamedMatch>>),\n-    Failure(codemap::Span, StrBuf),\n-    Error(codemap::Span, StrBuf)\n+    Failure(codemap::Span, String),\n+    Error(codemap::Span, String)\n }\n \n pub fn parse_or_else(sess: &ParseSess,\n@@ -387,7 +387,7 @@ pub fn parse(sess: &ParseSess,\n                                 token::get_ident(bind))).to_strbuf()\n                       }\n                       _ => fail!()\n-                    } }).collect::<Vec<StrBuf>>().connect(\" or \");\n+                    } }).collect::<Vec<String>>().connect(\" or \");\n                 return Error(sp, format!(\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\","}, {"sha": "055821c40fe5566697c25de6946aaa1079a63ca8", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -101,7 +101,7 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> Rc<NamedMatch> {\n enum LockstepIterSize {\n     LisUnconstrained,\n     LisConstraint(uint, Ident),\n-    LisContradiction(StrBuf),\n+    LisContradiction(String),\n }\n \n fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {"}, {"sha": "907e89622d08b5d00d4196c52baa6d73a432f5f5", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -19,7 +19,7 @@ use parse::token;\n \n use std::io;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n \n #[deriving(Clone, Eq)]\n@@ -33,7 +33,7 @@ pub enum CommentStyle {\n #[deriving(Clone)]\n pub struct Comment {\n     pub style: CommentStyle,\n-    pub lines: Vec<StrBuf>,\n+    pub lines: Vec<String>,\n     pub pos: BytePos,\n }\n \n@@ -53,9 +53,9 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n     }\n }\n \n-pub fn strip_doc_comment_decoration(comment: &str) -> StrBuf {\n+pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     /// remove whitespace-only lines from the start/end of lines\n-    fn vertical_trim(lines: Vec<StrBuf> ) -> Vec<StrBuf> {\n+    fn vertical_trim(lines: Vec<String> ) -> Vec<String> {\n         let mut i = 0u;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n@@ -81,7 +81,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> StrBuf {\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n-    fn horizontal_trim(lines: Vec<StrBuf> ) -> Vec<StrBuf> {\n+    fn horizontal_trim(lines: Vec<String> ) -> Vec<String> {\n         let mut i = uint::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n@@ -130,7 +130,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> StrBuf {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .lines_any()\n             .map(|s| s.to_strbuf())\n-            .collect::<Vec<StrBuf> >();\n+            .collect::<Vec<String> >();\n \n         let lines = vertical_trim(lines);\n         let lines = horizontal_trim(lines);\n@@ -141,8 +141,8 @@ pub fn strip_doc_comment_decoration(comment: &str) -> StrBuf {\n     fail!(\"not a doc-comment: {}\", comment);\n }\n \n-fn read_to_eol(rdr: &mut StringReader) -> StrBuf {\n-    let mut val = StrBuf::new();\n+fn read_to_eol(rdr: &mut StringReader) -> String {\n+    let mut val = String::new();\n     while !rdr.curr_is('\\n') && !is_eof(rdr) {\n         val.push_char(rdr.curr.unwrap());\n         bump(rdr);\n@@ -151,7 +151,7 @@ fn read_to_eol(rdr: &mut StringReader) -> StrBuf {\n     return val\n }\n \n-fn read_one_line_comment(rdr: &mut StringReader) -> StrBuf {\n+fn read_one_line_comment(rdr: &mut StringReader) -> String {\n     let val = read_to_eol(rdr);\n     assert!((val.as_slice()[0] == '/' as u8 &&\n                 val.as_slice()[1] == '/' as u8) ||\n@@ -202,7 +202,7 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n                       comments: &mut Vec<Comment>) {\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos;\n-    let mut lines: Vec<StrBuf> = Vec::new();\n+    let mut lines: Vec<String> = Vec::new();\n     while rdr.curr_is('/') && nextch_is(rdr, '/') {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n@@ -241,8 +241,8 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n     return Some(cursor);\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<StrBuf> ,\n-                                        s: StrBuf, col: CharPos) {\n+fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n+                                        s: String, col: CharPos) {\n     let len = s.len();\n     let s1 = match all_whitespace(s.as_slice(), col) {\n         Some(col) => {\n@@ -263,12 +263,12 @@ fn read_block_comment(rdr: &mut StringReader,\n                       comments: &mut Vec<Comment> ) {\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos;\n-    let mut lines: Vec<StrBuf> = Vec::new();\n+    let mut lines: Vec<String> = Vec::new();\n     let col = rdr.col;\n     bump(rdr);\n     bump(rdr);\n \n-    let mut curr_line = StrBuf::from_str(\"/*\");\n+    let mut curr_line = String::from_str(\"/*\");\n \n     // doc-comments are not really comments, they are attributes\n     if (rdr.curr_is('*') && !nextch_is(rdr, '*')) || rdr.curr_is('!') {\n@@ -297,7 +297,7 @@ fn read_block_comment(rdr: &mut StringReader,\n                 trim_whitespace_prefix_and_push_line(&mut lines,\n                                                      curr_line,\n                                                      col);\n-                curr_line = StrBuf::new();\n+                curr_line = String::new();\n                 bump(rdr);\n             } else {\n                 curr_line.push_char(rdr.curr.unwrap());\n@@ -356,15 +356,15 @@ fn consume_comment(rdr: &mut StringReader,\n \n #[deriving(Clone)]\n pub struct Literal {\n-    pub lit: StrBuf,\n+    pub lit: String,\n     pub pos: BytePos,\n }\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n                                         &diagnostic::SpanHandler,\n-                                    path: StrBuf,\n+                                    path: String,\n                                     srdr: &mut io::Reader)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();"}, {"sha": "e045116c9e2e61d22e6757ff32ac48e41100198a", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -424,10 +424,10 @@ fn consume_block_comment(rdr: &mut StringReader) -> Option<TokenAndSpan> {\n     if res.is_some() { res } else { consume_whitespace_and_comments(rdr) }\n }\n \n-fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<StrBuf> {\n+fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<String> {\n     // \\x00 hits the `return None` case immediately, so this is fine.\n     let mut c = rdr.curr.unwrap_or('\\x00');\n-    let mut rslt = StrBuf::new();\n+    let mut rslt = String::new();\n     if c == 'e' || c == 'E' {\n         rslt.push_char(c);\n         bump(rdr);\n@@ -449,8 +449,8 @@ fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<StrBuf>\n     }\n }\n \n-fn scan_digits(rdr: &mut StringReader, radix: uint) -> StrBuf {\n-    let mut rslt = StrBuf::new();\n+fn scan_digits(rdr: &mut StringReader, radix: uint) -> String {\n+    let mut rslt = String::new();\n     loop {\n         let c = rdr.curr;\n         if c == Some('_') { bump(rdr); continue; }\n@@ -858,7 +858,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n         return token::LIT_CHAR(c2);\n       }\n       '\"' => {\n-        let mut accum_str = StrBuf::new();\n+        let mut accum_str = String::new();\n         let start_bpos = rdr.last_pos;\n         bump(rdr);\n         while !rdr.curr_is('\"') {\n@@ -1002,7 +1002,7 @@ mod test {\n \n     // open a string reader for the given string\n     fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n-                 teststr: StrBuf) -> StringReader<'a> {\n+                 teststr: String) -> StringReader<'a> {\n         let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_strbuf(), teststr);\n         new_string_reader(span_handler, fm)\n     }"}, {"sha": "c4947b528f12e4ed8c85820ba63f396b7953ed73", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -77,8 +77,8 @@ pub fn parse_crate_attrs_from_file(\n     inner\n }\n \n-pub fn parse_crate_from_source_str(name: StrBuf,\n-                                   source: StrBuf,\n+pub fn parse_crate_from_source_str(name: String,\n+                                   source: String,\n                                    cfg: ast::CrateConfig,\n                                    sess: &ParseSess)\n                                    -> ast::Crate {\n@@ -89,8 +89,8 @@ pub fn parse_crate_from_source_str(name: StrBuf,\n     maybe_aborted(p.parse_crate_mod(),p)\n }\n \n-pub fn parse_crate_attrs_from_source_str(name: StrBuf,\n-                                         source: StrBuf,\n+pub fn parse_crate_attrs_from_source_str(name: String,\n+                                         source: String,\n                                          cfg: ast::CrateConfig,\n                                          sess: &ParseSess)\n                                          -> Vec<ast::Attribute> {\n@@ -102,17 +102,17 @@ pub fn parse_crate_attrs_from_source_str(name: StrBuf,\n     inner\n }\n \n-pub fn parse_expr_from_source_str(name: StrBuf,\n-                                  source: StrBuf,\n+pub fn parse_expr_from_source_str(name: String,\n+                                  source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n                                   -> @ast::Expr {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n \n-pub fn parse_item_from_source_str(name: StrBuf,\n-                                  source: StrBuf,\n+pub fn parse_item_from_source_str(name: String,\n+                                  source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n                                   -> Option<@ast::Item> {\n@@ -121,17 +121,17 @@ pub fn parse_item_from_source_str(name: StrBuf,\n     maybe_aborted(p.parse_item(attrs),p)\n }\n \n-pub fn parse_meta_from_source_str(name: StrBuf,\n-                                  source: StrBuf,\n+pub fn parse_meta_from_source_str(name: String,\n+                                  source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n                                   -> @ast::MetaItem {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n \n-pub fn parse_stmt_from_source_str(name: StrBuf,\n-                                  source: StrBuf,\n+pub fn parse_stmt_from_source_str(name: String,\n+                                  source: String,\n                                   cfg: ast::CrateConfig,\n                                   attrs: Vec<ast::Attribute> ,\n                                   sess: &ParseSess)\n@@ -145,8 +145,8 @@ pub fn parse_stmt_from_source_str(name: StrBuf,\n     maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n-pub fn parse_tts_from_source_str(name: StrBuf,\n-                                 source: StrBuf,\n+pub fn parse_tts_from_source_str(name: String,\n+                                 source: String,\n                                  cfg: ast::CrateConfig,\n                                  sess: &ParseSess)\n                                  -> Vec<ast::TokenTree> {\n@@ -164,8 +164,8 @@ pub fn parse_tts_from_source_str(name: StrBuf,\n // Create a new parser from a source string\n pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n                                       cfg: ast::CrateConfig,\n-                                      name: StrBuf,\n-                                      source: StrBuf)\n+                                      name: String,\n+                                      source: String)\n                                       -> Parser<'a> {\n     filemap_to_parser(sess, string_to_filemap(sess, source, name), cfg)\n }\n@@ -185,7 +185,7 @@ pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n                                     cfg: ast::CrateConfig,\n                                     path: &Path,\n                                     owns_directory: bool,\n-                                    module_name: Option<StrBuf>,\n+                                    module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n     let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)), cfg);\n     p.owns_directory = owns_directory;\n@@ -244,7 +244,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n \n // given a session and a string, add the string to\n // the session's codemap and return the new filemap\n-pub fn string_to_filemap(sess: &ParseSess, source: StrBuf, path: StrBuf)\n+pub fn string_to_filemap(sess: &ParseSess, source: String, path: String)\n                          -> Rc<FileMap> {\n     sess.span_diagnostic.cm.new_filemap(path, source)\n }\n@@ -293,7 +293,7 @@ mod test {\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::string_to_stmt;\n \n-    fn to_json_str<'a, E: Encodable<json::Encoder<'a>, io::IoError>>(val: &E) -> StrBuf {\n+    fn to_json_str<'a, E: Encodable<json::Encoder<'a>, io::IoError>>(val: &E) -> String {\n         let mut writer = MemWriter::new();\n         let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n         let _ = val.encode(&mut encoder);\n@@ -709,7 +709,7 @@ mod test {\n \n     #[test] fn attrs_fix_bug () {\n         string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<@Writer, StrBuf> {\n+                   -> Result<@Writer, String> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int"}, {"sha": "bfdf0361f053c6d8fa16a49de3aa091753d652b8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -79,7 +79,7 @@ use owned_slice::OwnedSlice;\n use collections::HashSet;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n #[allow(non_camel_case_types)]\n #[deriving(Eq)]\n@@ -350,7 +350,7 @@ pub struct Parser<'a> {\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n-    pub root_module_name: Option<StrBuf>,\n+    pub root_module_name: Option<String>,\n }\n \n fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n@@ -359,12 +359,12 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n \n impl<'a> Parser<'a> {\n     // convert a token to a string using self's reader\n-    pub fn token_to_str(token: &token::Token) -> StrBuf {\n+    pub fn token_to_str(token: &token::Token) -> String {\n         token::to_str(token)\n     }\n \n     // convert the current token to a string using self's reader\n-    pub fn this_token_to_str(&mut self) -> StrBuf {\n+    pub fn this_token_to_str(&mut self) -> String {\n         Parser::token_to_str(&self.token)\n     }\n \n@@ -399,7 +399,7 @@ impl<'a> Parser<'a> {\n     pub fn expect_one_of(&mut self,\n                          edible: &[token::Token],\n                          inedible: &[token::Token]) {\n-        fn tokens_to_str(tokens: &[token::Token]) -> StrBuf {\n+        fn tokens_to_str(tokens: &[token::Token]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n@@ -3883,15 +3883,15 @@ impl<'a> Parser<'a> {\n         (ident, ItemImpl(generics, opt_trait, ty, meths), Some(inner_attrs))\n     }\n \n-    // parse a::B<StrBuf,int>\n+    // parse a::B<String,int>\n     fn parse_trait_ref(&mut self) -> TraitRef {\n         ast::TraitRef {\n             path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n             ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n-    // parse B + C<StrBuf,int> + D\n+    // parse B + C<String,int> + D\n     fn parse_trait_ref_list(&mut self, ket: &token::Token) -> Vec<TraitRef> {\n         self.parse_seq_to_before_end(\n             ket,\n@@ -4214,12 +4214,12 @@ impl<'a> Parser<'a> {\n     fn eval_src_mod_from_path(&mut self,\n                               path: Path,\n                               owns_directory: bool,\n-                              name: StrBuf,\n+                              name: String,\n                               id_sp: Span) -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n-                let mut err = StrBuf::from_str(\"circular modules: \");\n+                let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in included_mod_stack.slice(i, len).iter() {\n                     err.push_str(p.display().as_maybe_owned().as_slice());\n@@ -4808,7 +4808,7 @@ impl<'a> Parser<'a> {\n \n         // FAILURE TO PARSE ITEM\n         if visibility != Inherited {\n-            let mut s = StrBuf::from_str(\"unmatched visibility `\");\n+            let mut s = String::from_str(\"unmatched visibility `\");\n             if visibility == Public {\n                 s.push_str(\"pub\")\n             } else {"}, {"sha": "e3788801293f37870b4df7788b81ab1030e62cda", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -21,7 +21,7 @@ use std::fmt;\n use std::path::BytesContainer;\n use std::mem;\n use std::rc::Rc;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n@@ -136,7 +136,7 @@ impl fmt::Show for Nonterminal {\n     }\n }\n \n-pub fn binop_to_str(o: BinOp) -> StrBuf {\n+pub fn binop_to_str(o: BinOp) -> String {\n     match o {\n       PLUS => \"+\".to_strbuf(),\n       MINUS => \"-\".to_strbuf(),\n@@ -151,7 +151,7 @@ pub fn binop_to_str(o: BinOp) -> StrBuf {\n     }\n }\n \n-pub fn to_str(t: &Token) -> StrBuf {\n+pub fn to_str(t: &Token) -> String {\n     match *t {\n       EQ => \"=\".to_strbuf(),\n       LT => \"<\".to_strbuf(),\n@@ -194,7 +194,7 @@ pub fn to_str(t: &Token) -> StrBuf {\n \n       /* Literals */\n       LIT_CHAR(c) => {\n-          let mut res = StrBuf::from_str(\"'\");\n+          let mut res = String::from_str(\"'\");\n           c.escape_default(|c| {\n               res.push_char(c);\n           });\n@@ -207,15 +207,15 @@ pub fn to_str(t: &Token) -> StrBuf {\n                                                  ast_util::ForceSuffix),\n       LIT_INT_UNSUFFIXED(i) => { (i as u64).to_str().to_strbuf() }\n       LIT_FLOAT(s, t) => {\n-        let mut body = StrBuf::from_str(get_ident(s).get());\n+        let mut body = String::from_str(get_ident(s).get());\n         if body.as_slice().ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n         body.push_str(ast_util::float_ty_to_str(t).as_slice());\n         body\n       }\n       LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = StrBuf::from_str(get_ident(s).get());\n+        let mut body = String::from_str(get_ident(s).get());\n         if body.as_slice().ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }"}, {"sha": "f45462da423713ecd55ebdbbc75eb97f2f38e460", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -62,7 +62,7 @@\n  */\n \n use std::io;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n #[deriving(Clone, Eq)]\n pub enum Breaks {\n@@ -84,7 +84,7 @@ pub struct BeginToken {\n \n #[deriving(Clone)]\n pub enum Token {\n-    String(StrBuf, int),\n+    String(String, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -109,7 +109,7 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(t: Token) -> StrBuf {\n+pub fn tok_str(t: Token) -> String {\n     match t {\n         String(s, len) => return format!(\"STR({},{})\", s, len).to_strbuf(),\n         Break(_) => return \"BREAK\".to_strbuf(),\n@@ -124,12 +124,12 @@ pub fn buf_str(toks: Vec<Token>,\n                left: uint,\n                right: uint,\n                lim: uint)\n-               -> StrBuf {\n+               -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = StrBuf::from_str(\"[\");\n+    let mut s = String::from_str(\"[\");\n     while i != right && l != 0u {\n         l -= 1u;\n         if i != left {"}, {"sha": "c5fa6351630f2938e47e3bfe59c70b5082103cd9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -31,7 +31,7 @@ use std::io;\n use std::mem;\n use std::rc::Rc;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n pub enum AnnNode<'a> {\n     NodeBlock(&'a ast::Block),\n@@ -97,7 +97,7 @@ pub static default_columns: uint = 78u;\n pub fn print_crate<'a>(cm: &'a CodeMap,\n                        span_diagnostic: &diagnostic::SpanHandler,\n                        krate: &ast::Crate,\n-                       filename: StrBuf,\n+                       filename: String,\n                        input: &mut io::Reader,\n                        out: Box<io::Writer>,\n                        ann: &'a PpAnn,\n@@ -132,7 +132,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n     eof(&mut s.s)\n }\n \n-pub fn to_str(f: |&mut State| -> IoResult<()>) -> StrBuf {\n+pub fn to_str(f: |&mut State| -> IoResult<()>) -> String {\n     let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n@@ -148,61 +148,61 @@ pub fn to_str(f: |&mut State| -> IoResult<()>) -> StrBuf {\n     }\n }\n \n-pub fn ty_to_str(ty: &ast::Ty) -> StrBuf {\n+pub fn ty_to_str(ty: &ast::Ty) -> String {\n     to_str(|s| s.print_type(ty))\n }\n \n-pub fn pat_to_str(pat: &ast::Pat) -> StrBuf {\n+pub fn pat_to_str(pat: &ast::Pat) -> String {\n     to_str(|s| s.print_pat(pat))\n }\n \n-pub fn expr_to_str(e: &ast::Expr) -> StrBuf {\n+pub fn expr_to_str(e: &ast::Expr) -> String {\n     to_str(|s| s.print_expr(e))\n }\n \n-pub fn lifetime_to_str(e: &ast::Lifetime) -> StrBuf {\n+pub fn lifetime_to_str(e: &ast::Lifetime) -> String {\n     to_str(|s| s.print_lifetime(e))\n }\n \n-pub fn tt_to_str(tt: &ast::TokenTree) -> StrBuf {\n+pub fn tt_to_str(tt: &ast::TokenTree) -> String {\n     to_str(|s| s.print_tt(tt))\n }\n \n-pub fn tts_to_str(tts: &[ast::TokenTree]) -> StrBuf {\n+pub fn tts_to_str(tts: &[ast::TokenTree]) -> String {\n     to_str(|s| s.print_tts(tts))\n }\n \n-pub fn stmt_to_str(stmt: &ast::Stmt) -> StrBuf {\n+pub fn stmt_to_str(stmt: &ast::Stmt) -> String {\n     to_str(|s| s.print_stmt(stmt))\n }\n \n-pub fn item_to_str(i: &ast::Item) -> StrBuf {\n+pub fn item_to_str(i: &ast::Item) -> String {\n     to_str(|s| s.print_item(i))\n }\n \n-pub fn generics_to_str(generics: &ast::Generics) -> StrBuf {\n+pub fn generics_to_str(generics: &ast::Generics) -> String {\n     to_str(|s| s.print_generics(generics))\n }\n \n-pub fn ty_method_to_str(p: &ast::TypeMethod) -> StrBuf {\n+pub fn ty_method_to_str(p: &ast::TypeMethod) -> String {\n     to_str(|s| s.print_ty_method(p))\n }\n \n-pub fn method_to_str(p: &ast::Method) -> StrBuf {\n+pub fn method_to_str(p: &ast::Method) -> String {\n     to_str(|s| s.print_method(p))\n }\n \n-pub fn fn_block_to_str(p: &ast::FnDecl) -> StrBuf {\n+pub fn fn_block_to_str(p: &ast::FnDecl) -> String {\n     to_str(|s| s.print_fn_block_args(p))\n }\n \n-pub fn path_to_str(p: &ast::Path) -> StrBuf {\n+pub fn path_to_str(p: &ast::Path) -> String {\n     to_str(|s| s.print_path(p, false))\n }\n \n pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n-                  generics: &ast::Generics) -> StrBuf {\n+                  generics: &ast::Generics) -> String {\n     to_str(|s| {\n         try!(s.print_fn(decl, Some(fn_style), abi::Rust,\n                         name, generics, opt_explicit_self, ast::Inherited));\n@@ -211,7 +211,7 @@ pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n     })\n }\n \n-pub fn block_to_str(blk: &ast::Block) -> StrBuf {\n+pub fn block_to_str(blk: &ast::Block) -> String {\n     to_str(|s| {\n         // containing cbox, will be closed by print-block at }\n         try!(s.cbox(indent_unit));\n@@ -221,27 +221,27 @@ pub fn block_to_str(blk: &ast::Block) -> StrBuf {\n     })\n }\n \n-pub fn meta_item_to_str(mi: &ast::MetaItem) -> StrBuf {\n+pub fn meta_item_to_str(mi: &ast::MetaItem) -> String {\n     to_str(|s| s.print_meta_item(mi))\n }\n \n-pub fn attribute_to_str(attr: &ast::Attribute) -> StrBuf {\n+pub fn attribute_to_str(attr: &ast::Attribute) -> String {\n     to_str(|s| s.print_attribute(attr))\n }\n \n-pub fn lit_to_str(l: &ast::Lit) -> StrBuf {\n+pub fn lit_to_str(l: &ast::Lit) -> String {\n     to_str(|s| s.print_literal(l))\n }\n \n-pub fn explicit_self_to_str(explicit_self: ast::ExplicitSelf_) -> StrBuf {\n+pub fn explicit_self_to_str(explicit_self: ast::ExplicitSelf_) -> String {\n     to_str(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n }\n \n-pub fn variant_to_str(var: &ast::Variant) -> StrBuf {\n+pub fn variant_to_str(var: &ast::Variant) -> String {\n     to_str(|s| s.print_variant(var))\n }\n \n-pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> StrBuf {\n+pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n     match vis {\n         ast::Public => format!(\"pub {}\", s).to_strbuf(),\n         ast::Inherited => s.to_strbuf()\n@@ -376,7 +376,7 @@ impl<'a> State<'a> {\n \n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n-    pub fn synth_comment(&mut self, text: StrBuf) -> IoResult<()> {\n+    pub fn synth_comment(&mut self, text: String) -> IoResult<()> {\n         try!(word(&mut self.s, \"/*\"));\n         try!(space(&mut self.s));\n         try!(word(&mut self.s, text.as_slice()));\n@@ -2232,7 +2232,7 @@ impl<'a> State<'a> {\n         match lit.node {\n             ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n             ast::LitChar(ch) => {\n-                let mut res = StrBuf::from_str(\"'\");\n+                let mut res = String::from_str(\"'\");\n                 ch.escape_default(|c| res.push_char(c));\n                 res.push_char('\\'');\n                 word(&mut self.s, res.as_slice())"}, {"sha": "9c88ab14143f5a79ebe55564e31d2ab94499e596", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -92,7 +92,7 @@ impl<T: TotalEq + Hash + Clone + 'static> Interner<T> {\n \n #[deriving(Clone, Eq, Hash, Ord)]\n pub struct RcStr {\n-    string: Rc<StrBuf>,\n+    string: Rc<String>,\n }\n \n impl TotalEq for RcStr {}"}, {"sha": "33a038a1dcacd59388794b398ecb3f9bafb6c0a5", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,21 +16,21 @@ use parse::parser::Parser;\n use parse::token;\n \n // map a string to tts, using a made-up filename:\n-pub fn string_to_tts(source_str: StrBuf) -> Vec<ast::TokenTree> {\n+pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n     let ps = new_parse_sess();\n     filemap_to_tts(&ps,\n                    string_to_filemap(&ps, source_str, \"bogofile\".to_strbuf()))\n }\n \n // map string to parser (via tts)\n-pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: StrBuf) -> Parser<'a> {\n+pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n     new_parser_from_source_str(ps,\n                                Vec::new(),\n                                \"bogofile\".to_strbuf(),\n                                source_str)\n }\n \n-fn with_error_checking_parse<T>(s: StrBuf, f: |&mut Parser| -> T) -> T {\n+fn with_error_checking_parse<T>(s: String, f: |&mut Parser| -> T) -> T {\n     let ps = new_parse_sess();\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);\n@@ -39,36 +39,36 @@ fn with_error_checking_parse<T>(s: StrBuf, f: |&mut Parser| -> T) -> T {\n }\n \n // parse a string, return a crate.\n-pub fn string_to_crate (source_str : StrBuf) -> ast::Crate {\n+pub fn string_to_crate (source_str : String) -> ast::Crate {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_crate_mod()\n     })\n }\n \n // parse a string, return an expr\n-pub fn string_to_expr (source_str : StrBuf) -> @ast::Expr {\n+pub fn string_to_expr (source_str : String) -> @ast::Expr {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_expr()\n     })\n }\n \n // parse a string, return an item\n-pub fn string_to_item (source_str : StrBuf) -> Option<@ast::Item> {\n+pub fn string_to_item (source_str : String) -> Option<@ast::Item> {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_item(Vec::new())\n     })\n }\n \n // parse a string, return a stmt\n-pub fn string_to_stmt(source_str : StrBuf) -> @ast::Stmt {\n+pub fn string_to_stmt(source_str : String) -> @ast::Stmt {\n     with_error_checking_parse(source_str, |p| {\n         p.parse_stmt(Vec::new())\n     })\n }\n \n // parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n // (currently) affect parsing.\n-pub fn string_to_pat(source_str: StrBuf) -> @ast::Pat {\n+pub fn string_to_pat(source_str: String) -> @ast::Pat {\n     string_to_parser(&new_parse_sess(), source_str).parse_pat()\n }\n "}, {"sha": "716f96b187208086cc4d856e5c092c0a1c7edb47", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -26,13 +26,13 @@ use self::parm::{expand, Number, Variables};\n #[deriving(Show)]\n pub struct TermInfo {\n     /// Names for the terminal\n-    pub names: Vec<StrBuf> ,\n+    pub names: Vec<String> ,\n     /// Map of capability name to boolean value\n-    pub bools: HashMap<StrBuf, bool>,\n+    pub bools: HashMap<String, bool>,\n     /// Map of capability name to numeric value\n-    pub numbers: HashMap<StrBuf, u16>,\n+    pub numbers: HashMap<String, u16>,\n     /// Map of capability name to raw (unexpanded) string\n-    pub strings: HashMap<StrBuf, Vec<u8> >\n+    pub strings: HashMap<String, Vec<u8> >\n }\n \n pub mod searcher;"}, {"sha": "6b96a78b24df060b086e86857d79c0dc9ae86f2e", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -41,7 +41,7 @@ enum FormatState {\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub enum Param {\n-    String(StrBuf),\n+    String(String),\n     Number(int)\n }\n \n@@ -89,7 +89,7 @@ impl Variables {\n   multiple capabilities for the same terminal.\n   */\n pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n-    -> Result<Vec<u8> , StrBuf> {\n+    -> Result<Vec<u8> , String> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n@@ -483,7 +483,7 @@ impl FormatOp {\n     }\n }\n \n-fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,StrBuf> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     let mut s = match val {\n         Number(d) => {\n             let s = match (op, flags.sign) {"}, {"sha": "5625a14a4f25527585032e900468bfa1d3e1d853", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -160,7 +160,7 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader, longnames: bool)\n-             -> Result<Box<TermInfo>, StrBuf> {\n+             -> Result<Box<TermInfo>, String> {\n     macro_rules! try( ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n@@ -221,7 +221,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         None => return Err(\"input not utf-8\".to_strbuf()),\n     };\n \n-    let term_names: Vec<StrBuf> = names_str.as_slice()\n+    let term_names: Vec<String> = names_str.as_slice()\n                                            .split('|')\n                                            .map(|s| s.to_strbuf())\n                                            .collect();"}, {"sha": "5c800c75432e4ebc8a88b48fd7240607f92bc707", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -76,7 +76,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n }\n \n /// Return open file for `term`\n-pub fn open(term: &str) -> Result<File, StrBuf> {\n+pub fn open(term: &str) -> Result<File, String> {\n     match get_dbpath_for_term(term) {\n         Some(x) => {\n             match File::open(x) {\n@@ -97,7 +97,7 @@ fn test_get_dbpath_for_term() {\n     // note: current tests won't work with non-standard terminfo hierarchies (e.g. OS X's)\n     use std::os::{setenv, unsetenv};\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    fn x(t: &str) -> StrBuf {\n+    fn x(t: &str) -> String {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n         p.as_str().unwrap().to_strbuf()\n     };"}, {"sha": "89f8d22771735587e1732624e620f1333eaffb0d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -62,7 +62,7 @@ use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::os;\n use std::str;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::task::TaskBuilder;\n \n // to be used by rustc to compile tests in libtest\n@@ -86,7 +86,7 @@ pub mod stats;\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum TestName {\n     StaticTestName(&'static str),\n-    DynTestName(StrBuf)\n+    DynTestName(String)\n }\n impl TestName {\n     fn as_slice<'a>(&'a self) -> &'a str {\n@@ -106,11 +106,11 @@ impl Show for TestName {\n enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n \n impl TestDesc {\n-    fn padded_name(&self, column_count: uint, align: NamePadding) -> StrBuf {\n+    fn padded_name(&self, column_count: uint, align: NamePadding) -> String {\n         use std::num::Saturating;\n-        let mut name = StrBuf::from_str(self.name.as_slice());\n+        let mut name = String::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n-        let mut pad = StrBuf::from_owned_str(\" \".repeat(fill));\n+        let mut pad = String::from_owned_str(\" \".repeat(fill));\n         match align {\n             PadNone => name,\n             PadOnLeft => {\n@@ -209,7 +209,7 @@ impl Metric {\n }\n \n #[deriving(Eq)]\n-pub struct MetricMap(TreeMap<StrBuf,Metric>);\n+pub struct MetricMap(TreeMap<String,Metric>);\n \n impl Clone for MetricMap {\n     fn clone(&self) -> MetricMap {\n@@ -228,11 +228,11 @@ pub enum MetricChange {\n     Regression(f64)\n }\n \n-pub type MetricDiff = TreeMap<StrBuf,MetricChange>;\n+pub type MetricDiff = TreeMap<String,MetricChange>;\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[StrBuf], tests: Vec<TestDescAndFn> ) {\n+pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n@@ -253,7 +253,7 @@ pub fn test_main(args: &[StrBuf], tests: Vec<TestDescAndFn> ) {\n // a ~[TestDescAndFn] is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n-pub fn test_main_static(args: &[StrBuf], tests: &[TestDescAndFn]) {\n+pub fn test_main_static(args: &[String], tests: &[TestDescAndFn]) {\n     let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n             StaticTestFn(f) => TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n@@ -304,7 +304,7 @@ impl TestOpts {\n }\n \n /// Result of parsing the options.\n-pub type OptRes = Result<TestOpts, StrBuf>;\n+pub type OptRes = Result<TestOpts, String>;\n \n fn optgroups() -> Vec<getopts::OptGroup> {\n     vec!(getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n@@ -360,7 +360,7 @@ Test Attributes:\n }\n \n // Parses command line arguments into test options\n-pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n+pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n         match getopts::getopts(args_.as_slice(), optgroups().as_slice()) {\n@@ -423,7 +423,7 @@ pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     Some(Ok(test_opts))\n }\n \n-pub fn opt_shard(maybestr: Option<StrBuf>) -> Option<(uint,uint)> {\n+pub fn opt_shard(maybestr: Option<String>) -> Option<(uint,uint)> {\n     match maybestr {\n         None => None,\n         Some(s) => {\n@@ -616,7 +616,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn write_failures(&mut self) -> io::IoResult<()> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = Vec::new();\n-        let mut fail_out = StrBuf::new();\n+        let mut fail_out = String::new();\n         for &(ref f, ref stdout) in self.failures.iter() {\n             failures.push(f.name.to_str());\n             if stdout.len() > 0 {\n@@ -736,9 +736,9 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n }\n \n-pub fn fmt_metrics(mm: &MetricMap) -> StrBuf {\n+pub fn fmt_metrics(mm: &MetricMap) -> String {\n     let MetricMap(ref mm) = *mm;\n-    let v : Vec<StrBuf> = mm.iter()\n+    let v : Vec<String> = mm.iter()\n         .map(|(k,v)| format_strbuf!(\"{}: {} (+/- {})\",\n                           *k,\n                           v.value as f64,\n@@ -747,7 +747,7 @@ pub fn fmt_metrics(mm: &MetricMap) -> StrBuf {\n     v.connect(\", \").to_strbuf()\n }\n \n-pub fn fmt_bench_samples(bs: &BenchSamples) -> StrBuf {\n+pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n     if bs.mb_s != 0 {\n         format_strbuf!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,"}, {"sha": "3ce87971099b6bae96c88bdfe619dfb87a65c038", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1028,7 +1028,7 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         #[allow(deprecated_owned_vector)]\n-        fn t(s: &Summary<f64>, expected: StrBuf) {\n+        fn t(s: &Summary<f64>, expected: String) {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();"}, {"sha": "4823eff2a7c975e12059daa0c036e69834732c50", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -29,7 +29,7 @@ extern crate sync;\n \n use std::io::BufReader;\n use std::num;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::str;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n@@ -315,10 +315,10 @@ impl Tm {\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    pub fn ctime(&self) -> StrBuf { self.strftime(\"%c\") }\n+    pub fn ctime(&self) -> String { self.strftime(\"%c\") }\n \n     /// Formats the time according to the format string.\n-    pub fn strftime(&self, format: &str) -> StrBuf {\n+    pub fn strftime(&self, format: &str) -> String {\n         strftime(format, self)\n     }\n \n@@ -328,7 +328,7 @@ impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    pub fn rfc822(&self) -> StrBuf {\n+    pub fn rfc822(&self) -> String {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -342,7 +342,7 @@ impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    pub fn rfc822z(&self) -> StrBuf {\n+    pub fn rfc822z(&self) -> String {\n         self.strftime(\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -352,7 +352,7 @@ impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    pub fn rfc3339(&self) -> StrBuf {\n+    pub fn rfc3339(&self) -> String {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {\n@@ -367,7 +367,7 @@ impl Tm {\n }\n \n /// Parses the time from the string according to the format string.\n-pub fn strptime(s: &str, format: &str) -> Result<Tm, StrBuf> {\n+pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n         for ch in needle.bytes() {\n@@ -379,7 +379,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, StrBuf> {\n         return true;\n     }\n \n-    fn match_strs(ss: &str, pos: uint, strs: &[(StrBuf, i32)])\n+    fn match_strs(ss: &str, pos: uint, strs: &[(String, i32)])\n       -> Option<(i32, uint)> {\n         let mut i = 0u;\n         let len = strs.len();\n@@ -461,7 +461,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, StrBuf> {\n         }\n     }\n \n-    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, StrBuf> {\n+    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, String> {\n         let range = s.char_range_at(pos);\n \n         if c == range.ch {\n@@ -474,7 +474,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, StrBuf> {\n     }\n \n     fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n-      -> Result<uint, StrBuf> {\n+      -> Result<uint, String> {\n         match ch {\n           'A' => match match_strs(s, pos, [\n               (\"Sunday\".to_strbuf(), 0_i32),\n@@ -840,7 +840,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, StrBuf> {\n }\n \n /// Formats the time according to the format string.\n-pub fn strftime(format: &str, tm: &Tm) -> StrBuf {\n+pub fn strftime(format: &str, tm: &Tm) -> String {\n     fn days_in_year(year: int) -> i32 {\n         if (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) {\n             366    /* Days in a leap year */\n@@ -868,7 +868,7 @@ pub fn strftime(format: &str, tm: &Tm) -> StrBuf {\n             + iso_week1_wday - iso_week_start_wday\n     }\n \n-    fn iso_week(ch:char, tm: &Tm) -> StrBuf {\n+    fn iso_week(ch:char, tm: &Tm) -> String {\n         let mut year: int = tm.tm_year as int + 1900;\n         let mut days: int = iso_week_days (tm.tm_yday, tm.tm_wday);\n \n@@ -894,7 +894,7 @@ pub fn strftime(format: &str, tm: &Tm) -> StrBuf {\n         }\n     }\n \n-    fn parse_type(ch: char, tm: &Tm) -> StrBuf {\n+    fn parse_type(ch: char, tm: &Tm) -> String {\n       let die = || {\n           format_strbuf!(\"strftime: can't understand this format {} \", ch)\n       };"}, {"sha": "e02993fc1c528bf02fd0d4f33aa42547473b9324", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -27,7 +27,7 @@ use std::fmt;\n use std::from_str::FromStr;\n use std::hash::Hash;\n use std::io::BufReader;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::uint;\n \n /// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n@@ -51,55 +51,55 @@ use std::uint;\n #[deriving(Clone, Eq, TotalEq)]\n pub struct Url {\n     /// The scheme part of a URL, such as `https` in the above example.\n-    pub scheme: StrBuf,\n+    pub scheme: String,\n     /// A URL subcomponent for user authentication.  `username` in the above example.\n     pub user: Option<UserInfo>,\n     /// A domain name or IP address.  For example, `example.com`.\n-    pub host: StrBuf,\n+    pub host: String,\n     /// A TCP port number, for example `8080`.\n-    pub port: Option<StrBuf>,\n+    pub port: Option<String>,\n     /// The path component of a URL, for example `/foo/bar`.\n-    pub path: StrBuf,\n+    pub path: String,\n     /// The query component of a URL.\n     /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<StrBuf>\n+    pub fragment: Option<String>\n }\n \n #[deriving(Clone, Eq)]\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n-    pub path: StrBuf,\n+    pub path: String,\n     /// The query component of a URL.\n     /// `vec!((\"baz\".to_strbuf(), \"qux\".to_strbuf()))` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n     /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n-    pub fragment: Option<StrBuf>\n+    pub fragment: Option<String>\n }\n \n /// An optional subcomponent of a URI authority component.\n #[deriving(Clone, Eq, TotalEq)]\n pub struct UserInfo {\n     /// The user name.\n-    pub user: StrBuf,\n+    pub user: String,\n     /// Password or other scheme-specific authentication information.\n-    pub pass: Option<StrBuf>\n+    pub pass: Option<String>\n }\n \n /// Represents the query component of a URI.\n-pub type Query = Vec<(StrBuf, StrBuf)>;\n+pub type Query = Vec<(String, String)>;\n \n impl Url {\n-    pub fn new(scheme: StrBuf,\n+    pub fn new(scheme: String,\n                user: Option<UserInfo>,\n-               host: StrBuf,\n-               port: Option<StrBuf>,\n-               path: StrBuf,\n+               host: String,\n+               port: Option<String>,\n+               path: String,\n                query: Query,\n-               fragment: Option<StrBuf>)\n+               fragment: Option<String>)\n                -> Url {\n         Url {\n             scheme: scheme,\n@@ -114,9 +114,9 @@ impl Url {\n }\n \n impl Path {\n-    pub fn new(path: StrBuf,\n+    pub fn new(path: String,\n                query: Query,\n-               fragment: Option<StrBuf>)\n+               fragment: Option<String>)\n                -> Path {\n         Path {\n             path: path,\n@@ -128,14 +128,14 @@ impl Path {\n \n impl UserInfo {\n     #[inline]\n-    pub fn new(user: StrBuf, pass: Option<StrBuf>) -> UserInfo {\n+    pub fn new(user: String, pass: Option<String>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }\n \n-fn encode_inner(s: &str, full_url: bool) -> StrBuf {\n+fn encode_inner(s: &str, full_url: bool) -> String {\n     let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = StrBuf::new();\n+    let mut out = String::new();\n \n     loop {\n         let mut buf = [0];\n@@ -191,7 +191,7 @@ fn encode_inner(s: &str, full_url: bool) -> StrBuf {\n  * println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n  * ```\n  */\n-pub fn encode(s: &str) -> StrBuf {\n+pub fn encode(s: &str) -> String {\n     encode_inner(s, true)\n }\n \n@@ -202,13 +202,13 @@ pub fn encode(s: &str) -> StrBuf {\n  * This function is compliant with RFC 3986.\n  */\n \n-pub fn encode_component(s: &str) -> StrBuf {\n+pub fn encode_component(s: &str) -> String {\n     encode_inner(s, false)\n }\n \n-fn decode_inner(s: &str, full_url: bool) -> StrBuf {\n+fn decode_inner(s: &str, full_url: bool) -> String {\n     let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = StrBuf::new();\n+    let mut out = String::new();\n \n     loop {\n         let mut buf = [0];\n@@ -266,20 +266,20 @@ fn decode_inner(s: &str, full_url: bool) -> StrBuf {\n  * println!(\"{}\", url); // https://example.com/Rust (programming language)\n  * ```\n  */\n-pub fn decode(s: &str) -> StrBuf {\n+pub fn decode(s: &str) -> String {\n     decode_inner(s, true)\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-pub fn decode_component(s: &str) -> StrBuf {\n+pub fn decode_component(s: &str) -> String {\n     decode_inner(s, false)\n }\n \n-fn encode_plus(s: &str) -> StrBuf {\n+fn encode_plus(s: &str) -> String {\n     let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = StrBuf::new();\n+    let mut out = String::new();\n \n     loop {\n         let mut buf = [0];\n@@ -302,8 +302,8 @@ fn encode_plus(s: &str) -> StrBuf {\n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-pub fn encode_form_urlencoded(m: &HashMap<StrBuf, Vec<StrBuf>>) -> StrBuf {\n-    let mut out = StrBuf::new();\n+pub fn encode_form_urlencoded(m: &HashMap<String, Vec<String>>) -> String {\n+    let mut out = String::new();\n     let mut first = true;\n \n     for (key, values) in m.iter() {\n@@ -331,11 +331,11 @@ pub fn encode_form_urlencoded(m: &HashMap<StrBuf, Vec<StrBuf>>) -> StrBuf {\n  * type into a hashmap.\n  */\n #[allow(experimental)]\n-pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<StrBuf, Vec<StrBuf>> {\n+pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<String, Vec<String>> {\n     let mut rdr = BufReader::new(s);\n-    let mut m: HashMap<StrBuf,Vec<StrBuf>> = HashMap::new();\n-    let mut key = StrBuf::new();\n-    let mut value = StrBuf::new();\n+    let mut m: HashMap<String,Vec<String>> = HashMap::new();\n+    let mut key = String::new();\n+    let mut value = String::new();\n     let mut parsing_key = true;\n \n     loop {\n@@ -357,8 +357,8 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<StrBuf, Vec<StrBuf>> {\n                 }\n \n                 parsing_key = true;\n-                key = StrBuf::new();\n-                value = StrBuf::new();\n+                key = String::new();\n+                value = String::new();\n             }\n             '=' => parsing_key = false,\n             ch => {\n@@ -398,7 +398,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<StrBuf, Vec<StrBuf>> {\n }\n \n \n-fn split_char_first(s: &str, c: char) -> (StrBuf, StrBuf) {\n+fn split_char_first(s: &str, c: char) -> (String, String) {\n     let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n@@ -458,7 +458,7 @@ fn query_from_str(rawquery: &str) -> Query {\n  * ```\n  */\n #[allow(unused_must_use)]\n-pub fn query_to_str(query: &Query) -> StrBuf {\n+pub fn query_to_str(query: &Query) -> String {\n     use std::io::MemWriter;\n     use std::str;\n \n@@ -488,7 +488,7 @@ pub fn query_to_str(query: &Query) -> StrBuf {\n  * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n  * ```\n  */\n-pub fn get_scheme(rawurl: &str) -> Result<(StrBuf, StrBuf), StrBuf> {\n+pub fn get_scheme(rawurl: &str) -> Result<(String, String), String> {\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => continue,\n@@ -524,7 +524,7 @@ enum Input {\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n-    Result<(Option<UserInfo>, StrBuf, Option<StrBuf>, StrBuf), StrBuf> {\n+    Result<(Option<UserInfo>, String, Option<String>, String), String> {\n     if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n         return Ok((None, \"\".to_strbuf(), None, rawurl.to_str().to_strbuf()));\n@@ -684,7 +684,7 @@ fn get_authority(rawurl: &str) ->\n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: &str, authority: bool) ->\n-    Result<(StrBuf, StrBuf), StrBuf> {\n+    Result<(String, String), String> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {\n@@ -715,7 +715,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n-    Result<(Query, Option<StrBuf>), StrBuf> {\n+    Result<(Query, Option<String>), String> {\n     if !rawurl.starts_with(\"?\") {\n         if rawurl.starts_with(\"#\") {\n             let f = decode_component(rawurl.slice(\n@@ -746,7 +746,7 @@ fn get_query_fragment(rawurl: &str) ->\n  *\n  * A `Url` struct type representing the URL.\n  */\n-pub fn from_str(rawurl: &str) -> Result<Url, StrBuf> {\n+pub fn from_str(rawurl: &str) -> Result<Url, String> {\n     // scheme\n     let (scheme, rest) = match get_scheme(rawurl) {\n         Ok(val) => val,\n@@ -775,7 +775,7 @@ pub fn from_str(rawurl: &str) -> Result<Url, StrBuf> {\n     Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n }\n \n-pub fn path_from_str(rawpath: &str) -> Result<Path, StrBuf> {\n+pub fn path_from_str(rawpath: &str) -> Result<Path, String> {\n     let (path, rest) = match get_path(rawpath, false) {\n         Ok(val) => val,\n         Err(e) => return Err(e)"}, {"sha": "351cd590a633f15242fe0357f5141fd1844c218e", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -322,7 +322,7 @@ impl Uuid {\n     /// Returns the UUID as a string of 16 hexadecimal digits\n     ///\n     /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n-    pub fn to_simple_str(&self) -> StrBuf {\n+    pub fn to_simple_str(&self) -> String {\n         let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n             let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n@@ -335,7 +335,7 @@ impl Uuid {\n     /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n     ///\n     /// Example: `550e8400-e29b-41d4-a716-446655440000`\n-    pub fn to_hyphenated_str(&self) -> StrBuf {\n+    pub fn to_hyphenated_str(&self) -> String {\n         use std::mem::{to_be16, to_be32};\n         // Convert to field-based struct as it matches groups in output.\n         // Ensure fields are in network byte order, as per RFC.\n@@ -361,7 +361,7 @@ impl Uuid {\n     /// This is the same as the hyphenated format, but with the \"urn:uuid:\" prefix.\n     ///\n     /// Example: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n-    pub fn to_urn_str(&self) -> StrBuf {\n+    pub fn to_urn_str(&self) -> String {\n         format_strbuf!(\"urn:uuid:{}\", self.to_hyphenated_str())\n     }\n "}, {"sha": "2d0d57a8b2135219865cca55198b13ddd2265818", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -101,8 +101,8 @@ use std::io::{File, MemWriter};\n \n #[deriving(Clone, Eq, Encodable, Decodable, Ord, TotalOrd, TotalEq)]\n struct WorkKey {\n-    kind: StrBuf,\n-    name: StrBuf\n+    kind: String,\n+    name: String\n }\n \n impl WorkKey {\n@@ -114,18 +114,18 @@ impl WorkKey {\n     }\n }\n \n-// FIXME #8883: The key should be a WorkKey and not a StrBuf.\n+// FIXME #8883: The key should be a WorkKey and not a String.\n // This is working around some JSON weirdness.\n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct WorkMap(TreeMap<StrBuf, KindMap>);\n+struct WorkMap(TreeMap<String, KindMap>);\n \n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct KindMap(TreeMap<StrBuf, StrBuf>);\n+struct KindMap(TreeMap<String, String>);\n \n impl WorkMap {\n     fn new() -> WorkMap { WorkMap(TreeMap::new()) }\n \n-    fn insert_work_key(&mut self, k: WorkKey, val: StrBuf) {\n+    fn insert_work_key(&mut self, k: WorkKey, val: String) {\n         let WorkKey { kind, name } = k;\n         let WorkMap(ref mut map) = *self;\n         match map.find_mut(&name) {\n@@ -140,7 +140,7 @@ impl WorkMap {\n \n pub struct Database {\n     db_filename: Path,\n-    db_cache: TreeMap<StrBuf, StrBuf>,\n+    db_cache: TreeMap<String, String>,\n     pub db_dirty: bool,\n }\n \n@@ -161,7 +161,7 @@ impl Database {\n     pub fn prepare(&self,\n                    fn_name: &str,\n                    declared_inputs: &WorkMap)\n-                   -> Option<(WorkMap, WorkMap, StrBuf)> {\n+                   -> Option<(WorkMap, WorkMap, String)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n@@ -227,7 +227,7 @@ impl Drop for Database {\n     }\n }\n \n-pub type FreshnessMap = TreeMap<StrBuf,extern fn(&str,&str)->bool>;\n+pub type FreshnessMap = TreeMap<String,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n pub struct Context {\n@@ -258,7 +258,7 @@ enum Work<'a, T> {\n     WorkFromTask(&'a Prep<'a>, Receiver<(Exec, T)>),\n }\n \n-fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> StrBuf {\n+fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> String {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     let _ = t.encode(&mut encoder);\n@@ -325,7 +325,7 @@ impl Exec {\n     }\n \n     // returns pairs of (kind, name)\n-    pub fn lookup_discovered_inputs(&self) -> Vec<(StrBuf, StrBuf)> {\n+    pub fn lookup_discovered_inputs(&self) -> Vec<(String, String)> {\n         let mut rs = vec![];\n         let WorkMap(ref discovered_inputs) = self.discovered_inputs;\n         for (k, v) in discovered_inputs.iter() {\n@@ -347,7 +347,7 @@ impl<'a> Prep<'a> {\n         }\n     }\n \n-    pub fn lookup_declared_inputs(&self) -> Vec<StrBuf> {\n+    pub fn lookup_declared_inputs(&self) -> Vec<String> {\n         let mut rs = vec![];\n         let WorkMap(ref declared_inputs) = self.declared_inputs;\n         for (_, v) in declared_inputs.iter() {\n@@ -491,7 +491,7 @@ fn test() {\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n-    fn make_path(filename: StrBuf) -> Path {\n+    fn make_path(filename: String) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if pth.exists() {\n             fs::unlink(&pth).unwrap();"}, {"sha": "78d667fc5a51261bc63fc4af8ea9a8bb029b5da2", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@ pub mod kitties {\n         meows : uint,\n \n         pub how_hungry : int,\n-        pub name : StrBuf,\n+        pub name : String,\n     }\n \n     impl cat {\n@@ -41,7 +41,7 @@ pub mod kitties {\n         }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n+    pub fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "6799b5fa85c29ca301ebbee3ce007e65851c9153", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@ pub mod kitty {\n     pub struct cat {\n       meows : uint,\n       pub how_hungry : int,\n-      pub name : StrBuf,\n+      pub name : String,\n     }\n \n     impl fmt::Show for cat {\n@@ -50,7 +50,7 @@ pub mod kitty {\n         }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n+    pub fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "2057a629bb1af026d9ed232ed9c86f41464fa517", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -17,11 +17,11 @@ pub mod name_pool {\n     pub type name_pool = ();\n \n     pub trait add {\n-        fn add(&self, s: StrBuf);\n+        fn add(&self, s: String);\n     }\n \n     impl add for name_pool {\n-        fn add(&self, _s: StrBuf) {\n+        fn add(&self, _s: String) {\n         }\n     }\n }"}, {"sha": "39702d74ca8c34b78b05dcc3e1b1675006a6498f", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct NameVal { pub name: StrBuf, pub val: int }\n+pub struct NameVal { pub name: String, pub val: int }\n \n pub fn struct_nameval() -> NameVal {\n     NameVal { name: \"crateresolve5\".to_strbuf(), val: 10 }"}, {"sha": "a1b19fce343e1196f1188291b0b499d208141c4b", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct NameVal { pub name: StrBuf, pub val: int }\n+pub struct NameVal { pub name: String, pub val: int }\n pub fn struct_nameval() -> NameVal {\n     NameVal { name: \"crateresolve5\".to_strbuf(), val: 10 }\n }"}, {"sha": "dafa66d9286d2f5292c85dabea10bf9593e13c32", "filename": "src/test/auxiliary/explicit_self_xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fexplicit_self_xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fexplicit_self_xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fexplicit_self_xcrate.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@ pub trait Foo {\n }\n \n pub struct Bar {\n-    pub x: StrBuf\n+    pub x: String\n }\n \n impl Foo for Bar {"}, {"sha": "08eaec2ed35528f7eda5b42b6cb9cea71fb2b3ea", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -17,6 +17,6 @@ trait foo {\n     fn foo(&self);\n }\n \n-impl foo for StrBuf {\n+impl foo for String {\n     fn foo(&self) {}\n }"}, {"sha": "c8c9d07d90be1950667302a2807e670875777678", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -17,7 +17,7 @@ extern crate collections;\n use std::cell::RefCell;\n use collections::HashMap;\n \n-pub type header_map = HashMap<StrBuf, @RefCell<Vec<@StrBuf>>>;\n+pub type header_map = HashMap<String, @RefCell<Vec<@String>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {"}, {"sha": "918ba0a2dcedf608fe73b9e658fc30d50bbc8086", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -48,7 +48,7 @@ pub mod testtypes {\n     // Tests ty_float (does not test all variants of FloatTy)\n     pub type FooFloat = f64;\n \n-    // For ty_str, what kind of string should I use? &'static str? StrBuf? Raw str?\n+    // For ty_str, what kind of string should I use? &'static str? String? Raw str?\n \n     // Tests ty_enum\n     pub enum FooEnum {"}, {"sha": "4fae888c6ad635841cb577ff93e9a1713c902224", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,9 +12,9 @@\n #![crate_type = \"lib\"]\n \n trait to_strz {\n-    fn to_strz() -> StrBuf;\n+    fn to_strz() -> String;\n }\n \n-impl to_strz for StrBuf {\n-    fn to_strz() -> StrBuf { self.clone() }\n+impl to_strz for String {\n+    fn to_strz() -> String { self.clone() }\n }"}, {"sha": "97d2556873510bd22079f2c131fb0987a30c2e5f", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,5 +16,5 @@ extern crate a;\n use a::to_strz;\n \n impl to_strz for bool {\n-    fn to_strz() -> StrBuf { fmt!(\"%b\", self) }\n+    fn to_strz() -> String { fmt!(\"%b\", self) }\n }"}, {"sha": "9a81c10751abee3f4ebd8af795121c3871db807c", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -31,7 +31,7 @@ pub mod sub_foo {\n     }\n \n     pub struct Boz {\n-        unused_str: StrBuf\n+        unused_str: String\n     }\n \n     impl Boz {\n@@ -46,7 +46,7 @@ pub mod sub_foo {\n     }\n \n     impl Bort {\n-        pub fn bort() -> StrBuf {\n+        pub fn bort() -> String {\n             \"bort()\".to_strbuf()\n         }\n     }"}, {"sha": "afb35112fb84618d507c5e71ca378cd4fbdd0c03", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,17 +14,17 @@\n use std::int;\n \n pub trait read {\n-    fn readMaybe(s: StrBuf) -> Option<Self>;\n+    fn readMaybe(s: String) -> Option<Self>;\n }\n \n impl read for int {\n-    fn readMaybe(s: StrBuf) -> Option<int> {\n+    fn readMaybe(s: String) -> Option<int> {\n         from_str::<int>(s.as_slice())\n     }\n }\n \n impl read for bool {\n-    fn readMaybe(s: StrBuf) -> Option<bool> {\n+    fn readMaybe(s: String) -> Option<bool> {\n         match s.as_slice() {\n           \"true\" => Some(true),\n           \"false\" => Some(false),\n@@ -33,7 +33,7 @@ impl read for bool {\n     }\n }\n \n-pub fn read<T:read>(s: StrBuf) -> T {\n+pub fn read<T:read>(s: String) -> T {\n     match read::readMaybe(s) {\n       Some(x) => x,\n       _ => fail!(\"read failed!\")"}, {"sha": "9d8fb798d06c11bf7a596d62f27669b82bd90ff5", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -80,7 +80,7 @@ impl Results {\n         }\n     }\n \n-    pub fn bench_str<T:MutableSet<StrBuf>,\n+    pub fn bench_str<T:MutableSet<String>,\n                      R:rand::Rng>(\n                      &mut self,\n                      rng: &mut R,\n@@ -175,7 +175,7 @@ fn main() {\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {\n-            let s: HashSet<StrBuf> = HashSet::new();\n+            let s: HashSet<String> = HashSet::new();\n             s\n         });\n         write_results(\"collections::HashSet\", &results);\n@@ -189,7 +189,7 @@ fn main() {\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {\n-            let s: TreeSet<StrBuf> = TreeSet::new();\n+            let s: TreeSet<String> = TreeSet::new();\n             s\n         });\n         write_results(\"collections::TreeSet\", &results);"}, {"sha": "8cdd9695f0295afd0b37c03d776ba5dfde5a056f", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -30,7 +30,7 @@ macro_rules! bench (\n )\n \n fn main() {\n-    let argv = os::args().move_iter().map(|x| x.to_strbuf()).collect::<Vec<StrBuf>>();\n+    let argv = os::args().move_iter().map(|x| x.to_strbuf()).collect::<Vec<String>>();\n     let _tests = argv.slice(1, argv.len());\n \n     bench!(argv, shift_push);\n@@ -42,7 +42,7 @@ fn main() {\n     bench!(argv, is_utf8_multibyte);\n }\n \n-fn maybe_run_test(argv: &[StrBuf], name: StrBuf, test: ||) {\n+fn maybe_run_test(argv: &[String], name: String, test: ||) {\n     let mut run_test = false;\n \n     if os::getenv(\"RUST_BENCH\").is_some() {"}, {"sha": "18fe5da6ca83ae291cefee9772f8c064a6231540", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -52,7 +52,7 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     //println!(\"server exiting\");\n }\n \n-fn run(args: &[StrBuf]) {\n+fn run(args: &[String]) {\n     let (to_parent, from_child) = channel();\n     let (to_child, from_parent) = channel();\n "}, {"sha": "2ae574080613cb14fc2a0e8c77037a87a3d633e9", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -47,7 +47,7 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     //println!(\"server exiting\");\n }\n \n-fn run(args: &[StrBuf]) {\n+fn run(args: &[String]) {\n     let (to_parent, from_child) = channel();\n \n     let size = from_str::<uint>(args[1].as_slice()).unwrap();"}, {"sha": "db68edc73ba80beb4303f93fcb9d6450d7739b8a", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -77,7 +77,7 @@ fn main() {\n                 format_strbuf!(\"{}\\t trees of depth {}\\t check: {}\",\n                                iterations * 2, depth, chk)\n             })\n-        }).collect::<Vec<Future<StrBuf>>>();\n+        }).collect::<Vec<Future<String>>>();\n \n     for message in messages.mut_iter() {\n         println!(\"{}\", *message.get_ref());"}, {"sha": "2c8b23f2acdf1274049976cbcfbe1770c6a85436", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@\n #![feature(phase)]\n #[phase(syntax)] extern crate green;\n \n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::fmt;\n \n green_start!(main)\n@@ -44,8 +44,8 @@ struct CreatureInfo {\n     color: Color\n }\n \n-fn show_color_list(set: Vec<Color>) -> StrBuf {\n-    let mut out = StrBuf::new();\n+fn show_color_list(set: Vec<Color>) -> String {\n+    let mut out = String::new();\n     for col in set.iter() {\n         out.push_char(' ');\n         out.push_str(col.to_str().as_slice());\n@@ -109,7 +109,7 @@ fn creature(\n     mut color: Color,\n     from_rendezvous: Receiver<CreatureInfo>,\n     to_rendezvous: Sender<CreatureInfo>,\n-    to_rendezvous_log: Sender<StrBuf>\n+    to_rendezvous_log: Sender<String>\n ) {\n     let mut creatures_met = 0;\n     let mut evil_clones_met = 0;\n@@ -145,7 +145,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n     let (to_rendezvous, from_creatures) = channel::<CreatureInfo>();\n \n     // these channels will be passed to the creatures so they can talk to us\n-    let (to_rendezvous_log, from_creatures_log) = channel::<StrBuf>();\n+    let (to_rendezvous_log, from_creatures_log) = channel::<String>();\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let mut to_creature: Vec<Sender<CreatureInfo>> ="}, {"sha": "554e32433151137e38dc19a3dfa97ffc7325874f", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -19,7 +19,7 @@ use collections::HashMap;\n use std::mem::replace;\n use std::option;\n use std::os;\n-use std::strbuf::StrBuf;\n+use std::string::String;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -37,7 +37,7 @@ fn f64_cmp(x: f64, y: f64) -> Ordering {\n }\n \n // given a map, print a sorted version of it\n-fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> StrBuf {\n+fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n    fn pct(xx: uint, yy: uint) -> f64 {\n       return (xx as f64) * 100.0 / (yy as f64);\n    }\n@@ -58,7 +58,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> StrBuf {\n \n    let pairs_sorted = sortKV(pairs);\n \n-   let mut buffer = StrBuf::new();\n+   let mut buffer = String::new();\n    for &(ref k, v) in pairs_sorted.iter() {\n        buffer.push_str(format!(\"{} {:0.3f}\\n\",\n                                k.as_slice()\n@@ -71,7 +71,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> StrBuf {\n }\n \n // given a map, search for the frequency of a pattern\n-fn find(mm: &HashMap<Vec<u8> , uint>, key: StrBuf) -> uint {\n+fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n    let key = key.to_owned().into_ascii().as_slice().to_lower().into_str();\n    match mm.find_equiv(&key.as_bytes()) {\n       option::None      => { return 0u; }\n@@ -106,7 +106,7 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n \n fn make_sequence_processor(sz: uint,\n                            from_parent: &Receiver<Vec<u8>>,\n-                           to_parent: &Sender<StrBuf>) {\n+                           to_parent: &Sender<String>) {\n    let mut freqs: HashMap<Vec<u8>, uint> = HashMap::new();\n    let mut carry = Vec::new();\n    let mut total: uint = 0u;\n@@ -155,7 +155,7 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = vec!(1u,2,3,4,6,12,18);\n-    let mut streams = Vec::from_fn(sizes.len(), |_| Some(channel::<StrBuf>()));\n+    let mut streams = Vec::from_fn(sizes.len(), |_| Some(channel::<String>()));\n     let mut from_child = Vec::new();\n     let to_child  = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n         let sz = *sz;"}, {"sha": "4b561def720c1cffb7e2768d942077a7645d0041", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n \n extern crate sync;\n \n-use std::strbuf::StrBuf;\n+use std::string::String;\n use std::slice;\n use sync::Arc;\n use sync::Future;\n@@ -51,7 +51,7 @@ impl Code {\n         string.bytes().fold(Code(0u64), |a, b| a.push_char(b))\n     }\n \n-    fn unpack(&self, frame: uint) -> StrBuf {\n+    fn unpack(&self, frame: uint) -> String {\n         let mut key = self.hash();\n         let mut result = Vec::new();\n         for _ in range(0, frame) {\n@@ -60,7 +60,7 @@ impl Code {\n         }\n \n         result.reverse();\n-        StrBuf::from_utf8(result).unwrap()\n+        String::from_utf8(result).unwrap()\n     }\n }\n "}, {"sha": "ab3f6892bb8af51292990ab27ece9e93cfc555a2", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -184,7 +184,7 @@ fn get_id(m: u64) -> u8 {\n     fail!(\"{:016x} does not have a valid identifier\", m);\n }\n \n-// Converts a list of mask to a StrBuf.\n+// Converts a list of mask to a String.\n fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n     let mut sol = Vec::from_elem(50, '.' as u8);\n     for &m in raw_sol.iter() {\n@@ -198,7 +198,7 @@ fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n     sol\n }\n \n-// Prints a solution in StrBuf form.\n+// Prints a solution in String form.\n fn print_sol(sol: &Vec<u8>) {\n     for (i, c) in sol.iter().enumerate() {\n         if (i) % 5 == 0 { println!(\"\"); }"}, {"sha": "da61a7780391d9789db826804aa1987a32801243", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -52,7 +52,7 @@ struct Config {\n     stress: bool\n }\n \n-fn parse_opts(argv: Vec<StrBuf> ) -> Config {\n+fn parse_opts(argv: Vec<String> ) -> Config {\n     let opts = vec!(getopts::optflag(\"\", \"stress\", \"\"));\n \n     let argv = argv.iter().map(|x| x.to_strbuf()).collect::<Vec<_>>();"}, {"sha": "227c16aba68eb9e30244257a685c60b5343cc5b5", "filename": "src/test/compile-fail/bad-const-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected `std::strbuf::StrBuf` but found `int`\n+// error-pattern:expected `std::string::String` but found `int`\n \n-static i: StrBuf = 10i;\n+static i: String = 10i;\n fn main() { println!(\"{}\", i); }"}, {"sha": "38ba652f53bc3931678e33b31ec1b92b8bafbd11", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,4 +12,4 @@\n \n mod m1 {}\n \n-fn main(args: Vec<StrBuf>) { log(debug, m1::a); }\n+fn main(args: Vec<String>) { log(debug, m1::a); }"}, {"sha": "f397d0b387da5d4fa538d53983de57ab621aeba6", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,6 +14,6 @@ mod m1 {\n     pub mod a {}\n }\n \n-fn main(args: Vec<StrBuf>) {\n+fn main(args: Vec<String>) {\n     log(debug, m1::a);\n }"}, {"sha": "33110fc23a07bcf5657685570e9473c9492d4f90", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:`^` cannot be applied to type `std::strbuf::StrBuf`\n+// error-pattern:`^` cannot be applied to type `std::string::String`\n \n fn main() { let x = \"a\".to_strbuf() ^ \"b\".to_strbuf(); }"}, {"sha": "41c6ddfbe473380892516b1f1ef3afd092f18f55", "filename": "src/test/compile-fail/borrowck-move-error-with-note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-error-with-note.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -26,8 +26,8 @@ fn blah() {\n }\n \n struct S {\n-    f: StrBuf,\n-    g: StrBuf\n+    f: String,\n+    g: String\n }\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }"}, {"sha": "ce51c5acd19b35c5160739c5ef3c19b782b8eb3c", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with(f: |&StrBuf|) {}\n+fn with(f: |&String|) {}\n \n-fn arg_item(&_x: &StrBuf) {}\n+fn arg_item(&_x: &String) {}\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n \n fn arg_closure() {"}, {"sha": "47c0004840026495f67bcc386373dfb78eb348ff", "filename": "src/test/compile-fail/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S {f:StrBuf}\n+struct S {f:String}\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }\n }"}, {"sha": "51ec8e42a003edfd32bb253892220a2ee9a258cb", "filename": "src/test/compile-fail/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S(StrBuf);\n+struct S(String);\n impl Drop for S {\n     fn drop(&mut self) { }\n }"}, {"sha": "52a72d501a00e055ac71fd20a467b4564a9edd03", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n \n #[deriving(Clone)]\n struct Foo {\n-    string: StrBuf\n+    string: String\n }\n \n pub fn main() {"}, {"sha": "d72398a6ac5a71d2d80a2e0b8a12a5e44d1ebeab", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo {\n-    t: StrBuf\n+    t: String\n }\n \n fn cond() -> bool { true }"}, {"sha": "c0c5c50a786c1c5b1a400a56c7c8cdccbcf5d39c", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -10,14 +10,14 @@\n \n enum E {\n     Foo,\n-    Bar(StrBuf)\n+    Bar(String)\n }\n \n struct S {\n     x: E\n }\n \n-fn f(x: StrBuf) {}\n+fn f(x: String) {}\n \n fn main() {\n     let s = S { x: Bar(\"hello\".to_strbuf()) };"}, {"sha": "0bfb243264b8a724ce5eeccf288332314e21f63e", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -27,7 +27,7 @@ enum SafeEnum {\n     Variant1,\n     Variant2(int),\n     Variant3(WithDtor),\n-    Variant4(StrBuf)\n+    Variant4(String)\n }\n \n // These should be ok"}, {"sha": "ad1596d002e392c896d25ffc44f1c9f767845853", "filename": "src/test/compile-fail/circular_modules_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,7 +11,7 @@\n #[path = \"circular_modules_hello.rs\"]\n mod circular_modules_hello; //~ERROR: circular modules\n \n-pub fn hi_str() -> StrBuf {\n+pub fn hi_str() -> String {\n   \"Hi!\".to_owned()\n }\n "}, {"sha": "e6c74c0d8ea385330137c4ea34f618a7bb1147f1", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -17,7 +17,7 @@ struct cat {\n   meows : uint,\n \n   how_hungry : int,\n-  name : StrBuf,\n+  name : String,\n }\n \n impl cat {\n@@ -49,7 +49,7 @@ impl cat {\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n+fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,"}, {"sha": "c499fb26d685663cd9096ef49caee6a12ec013b3", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct X {\n-    x: StrBuf,\n+    x: String,\n }\n \n impl Drop for X {\n@@ -18,7 +18,7 @@ impl Drop for X {\n     }\n }\n \n-fn unwrap(x: X) -> StrBuf {\n+fn unwrap(x: X) -> String {\n     let X { x: y } = x; //~ ERROR cannot move out of type\n     y\n }"}, {"sha": "80a884c78692f5e404096d05fbc2cb6875202f51", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct X {\n-    x: StrBuf,\n+    x: String,\n }\n \n impl Drop for X {"}, {"sha": "5335fa1206dbbf4685c2712b95508cc9c1317405", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn wants_uniq(x: StrBuf) { }\n+fn wants_uniq(x: String) { }\n fn wants_slice(x: &str) { }\n \n-fn has_uniq(x: StrBuf) {\n+fn has_uniq(x: String) {\n    wants_uniq(x);\n    wants_slice(x.as_slice());\n }"}, {"sha": "56ccd40f75bdfacdccd19ed906f0f6ae9b1149d8", "filename": "src/test/compile-fail/generic-type-params-name-repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -28,10 +28,10 @@ fn main() {\n     //~^ ERROR mismatched types: expected `Foo<int>` but found `()`\n \n     // Including cases where the default is using previous type params.\n-    let _: HashMap<StrBuf, int> = ();\n-    //~^ ERROR mismatched types: expected `HashMap<std::strbuf::StrBuf,int>` but found `()`\n-    let _: HashMap<StrBuf, int, Hash<StrBuf>> = ();\n-    //~^ ERROR mismatched types: expected `HashMap<std::strbuf::StrBuf,int>` but found `()`\n+    let _: HashMap<String, int> = ();\n+    //~^ ERROR mismatched types: expected `HashMap<std::string::String,int>` but found `()`\n+    let _: HashMap<String, int, Hash<String>> = ();\n+    //~^ ERROR mismatched types: expected `HashMap<std::string::String,int>` but found `()`\n \n     // But not when there's a different type in between.\n     let _: Foo<A, int, C> = ();"}, {"sha": "1a6865c1ea722d529c079ce29eb735bb87350ffd", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,4 +16,4 @@ use zed::baz;\n mod zed {\n     pub fn bar() { println!(\"bar\"); }\n }\n-fn main(args: Vec<StrBuf>) { bar(); }\n+fn main(args: Vec<String>) { bar(); }"}, {"sha": "64b6b6c6f584948416eca76281285268f59b0f3d", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,4 +16,4 @@ mod baz {}\n mod zed {\n     pub fn bar() { println!(\"bar3\"); }\n }\n-fn main(args: Vec<StrBuf>) { bar(); }\n+fn main(args: Vec<String>) { bar(); }"}, {"sha": "a45d6181941fadddaee13a3bf5ee4c496ec0ae98", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n-    let s: StrBuf = \"abcdef\".to_strbuf();\n+    let s: String = \"abcdef\".to_strbuf();\n     assert_eq!(v.as_slice()[3u], 3);\n     assert_eq!(v.as_slice()[3u8], 3); //~ ERROR: mismatched types\n     assert_eq!(v.as_slice()[3i8], 3); //~ ERROR: mismatched types"}, {"sha": "333ff7118d45b4b2b7d33275341cdd6d95a6a33d", "filename": "src/test/compile-fail/issue-11493.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-11493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-11493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11493.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,4 +13,4 @@\n fn main() {\n     let x = Some(3);\n     let y = x.as_ref().unwrap_or(&5); //~ ERROR: borrowed value does not live long enough\n-}\n\\ No newline at end of file\n+}"}, {"sha": "1aac55ab0f64ea67b265b0bc1c538be65cb2b556", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -10,15 +10,15 @@\n \n // Regression test for #13428\n \n-fn foo() -> StrBuf {  //~ ERROR not all control paths return a value\n+fn foo() -> String {  //~ ERROR not all control paths return a value\n     format_strbuf!(\"Hello {}\",\n                    \"world\")\n     // Put the trailing semicolon on its own line to test that the\n     // note message gets the offending semicolon exactly\n     ;   //~ NOTE consider removing this semicolon\n }\n \n-fn bar() -> StrBuf {  //~ ERROR not all control paths return a value\n+fn bar() -> String {  //~ ERROR not all control paths return a value\n     \"foobar\".to_strbuf()\n     ;   //~ NOTE consider removing this semicolon\n }"}, {"sha": "9e22d5f22ec47ac5ee27dd8812dfccf0eefa2386", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,14 +16,14 @@\n struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n trait to_str_2 {\n-    fn my_to_str() -> StrBuf;\n+    fn my_to_str() -> String;\n }\n \n // I use an impl here because it will cause\n // the compiler to attempt autoderef and then\n // try to resolve the method.\n impl to_str_2 for t {\n-    fn my_to_str() -> StrBuf { \"t\".to_strbuf() }\n+    fn my_to_str() -> String { \"t\".to_strbuf() }\n }\n \n fn new_t(x: t) {"}, {"sha": "cdc377a09996f58f9558bbbe9411e959b26ea5fb", "filename": "src/test/compile-fail/issue-3099.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn a(x: StrBuf) -> StrBuf {\n+fn a(x: String) -> String {\n     format!(\"First function with {}\", x)\n }\n \n-fn a(x: StrBuf, y: StrBuf) -> StrBuf { //~ ERROR duplicate definition of value `a`\n+fn a(x: String, y: String) -> String { //~ ERROR duplicate definition of value `a`\n     format!(\"Second function with {} and {}\", x, y)\n }\n "}, {"sha": "dd27314e14fa3e03f7674c3c68f8ea7985d998c4", "filename": "src/test/compile-fail/issue-3601.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -10,7 +10,7 @@\n \n \n struct HTMLImageData {\n-    image: Option<StrBuf>\n+    image: Option<String>\n }\n \n struct ElementData {"}, {"sha": "7fe7778c1a59e981aeb2fa5a4c72697c9ce6082f", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -22,7 +22,7 @@ impl ToStr for Point { //~ ERROR implements a method not defined in the trait\n         Point { x: x, y: y }\n     }\n \n-    fn to_str(&self) -> StrBuf {\n+    fn to_str(&self) -> String {\n         format!(\"({}, {})\", self.x, self.y)\n     }\n }"}, {"sha": "0090dd544f6553c571983fda1271cd8aa583e54e", "filename": "src/test/compile-fail/issue-5543.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@\n use std::io::ReaderUtil;\n use std::io::Reader;\n \n-fn bar(r:@ReaderUtil) -> StrBuf { r.read_line() }\n+fn bar(r:@ReaderUtil) -> String { r.read_line() }\n \n fn main() {\n     let r : @Reader = io::stdin();"}, {"sha": "b0adc89cf3088213a4e459b43b9822fc78816cf8", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(b: bool) -> Result<bool,StrBuf> {\n+fn foo(b: bool) -> Result<bool,String> {\n     Err(\"bar\".to_owned());\n     //~^ ERROR: cannot determine a type for this expression: unconstrained type\n }"}, {"sha": "9b0a648e0d6aba6e1e79e04ef0df0823c3fb1fd3", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -10,8 +10,8 @@\n \n \n pub struct CrateId {\n-    local_path: StrBuf,\n-    junk: StrBuf\n+    local_path: String,\n+    junk: String\n }\n \n impl CrateId {"}, {"sha": "768177785cfbad32a10dc8bdbaf5f5e9d738df1b", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -51,7 +51,7 @@ trait ManyImplTrait {\n     }\n }\n \n-impl ManyImplTrait for StrBuf {\n+impl ManyImplTrait for String {\n     fn is_str() -> bool {\n         true\n     }\n@@ -77,4 +77,4 @@ fn param_bound<T: ManyImplTrait>(t: T) -> bool {\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "5404b32eb2421d43551d56468428ef18a72eccd9", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -39,7 +39,7 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n \n     // ~ pointers are not ok\n     assert_copy::<Box<int>>();   //~ ERROR does not fulfill\n-    assert_copy::<StrBuf>();   //~ ERROR does not fulfill\n+    assert_copy::<String>();   //~ ERROR does not fulfill\n     assert_copy::<Vec<int> >(); //~ ERROR does not fulfill\n     assert_copy::<Box<&'a mut int>>(); //~ ERROR does not fulfill\n "}, {"sha": "aa9d2dda22a960ae1e69c7f798a0fc4a7cc3dfe2", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -30,7 +30,7 @@ fn test<'a,T,U:Send>(_: &'a int) {\n \n     // boxes are ok\n     assert_send::<Box<int>>();\n-    assert_send::<StrBuf>();\n+    assert_send::<String>();\n     assert_send::<Vec<int> >();\n \n     // but not if they own a bad thing"}, {"sha": "7c459434bcabd1023d47f86e05654ecee8195f1d", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -51,7 +51,7 @@ fn good2() {\n        sure that when purity is inherited that the source of the unsafe-ness\n        is tracked correctly */\n     unsafe {\n-        unsafe fn what() -> Vec<StrBuf> { fail!() }\n+        unsafe fn what() -> Vec<String> { fail!() }\n \n         callback(|| {\n             what();"}, {"sha": "82938d63ce54cec959105284088caa27b9b96de3", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n // of the various arms, particularly in the case where regions are\n // involved.\n \n-pub fn opt_str0<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n+pub fn opt_str0<'a>(maybestr: &'a Option<String>) -> &'a str {\n     if maybestr.is_none() {\n         \"(none)\"\n     } else {\n@@ -21,7 +21,7 @@ pub fn opt_str0<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     }\n }\n \n-pub fn opt_str1<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n+pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n     if maybestr.is_some() {\n         let s: &'a str = maybestr.get_ref().as_slice();\n         s\n@@ -30,7 +30,7 @@ pub fn opt_str1<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     }\n }\n \n-pub fn opt_str2<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n+pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_none() { //~ ERROR mismatched types\n         \"(none)\"\n     } else {\n@@ -39,7 +39,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n     }\n }\n \n-pub fn opt_str3<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n+pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_some() {  //~ ERROR mismatched types\n         let s: &'a str = maybestr.get_ref().as_slice();\n         s"}, {"sha": "98bea422fb5b9d28c0677a5a6c65f8db968dffce", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n // of the various arms, particularly in the case where regions are\n // involved.\n \n-pub fn opt_str0<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n+pub fn opt_str0<'a>(maybestr: &'a Option<String>) -> &'a str {\n     match *maybestr {\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n@@ -22,7 +22,7 @@ pub fn opt_str0<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     }\n }\n \n-pub fn opt_str1<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n+pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n         Some(ref s) => {\n@@ -32,7 +32,7 @@ pub fn opt_str1<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     }\n }\n \n-pub fn opt_str2<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n+pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr { //~ ERROR mismatched types\n         None => \"(none)\",\n         Some(ref s) => {\n@@ -42,7 +42,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n     }\n }\n \n-pub fn opt_str3<'a>(maybestr: &'a Option<StrBuf>) -> &'static str {\n+pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr { //~ ERROR mismatched types\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();"}, {"sha": "b91cf8d8bf6e47d1a4358c9d9501aaf8281ee843", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -18,10 +18,10 @@ fn main() {\n         _ => ()\n     }\n \n-    let x: Vec<StrBuf> = vec![\"foo\".to_strbuf(),\n+    let x: Vec<String> = vec![\"foo\".to_strbuf(),\n                               \"bar\".to_strbuf(),\n                               \"baz\".to_strbuf()];\n-    let x: &[StrBuf] = x.as_slice();\n+    let x: &[String] = x.as_slice();\n     match x {\n         [a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern"}, {"sha": "eb46c13948ee12f4669080bb7c13597630b254a3", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:cannot apply unary operator `-` to type `std::strbuf::StrBuf`\n+// error-pattern:cannot apply unary operator `-` to type `std::string::String`\n \n fn main() { -\"foo\".to_strbuf(); }"}, {"sha": "6bee6528d7c286df3506d2445654fb6b87860ff3", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,8 +11,8 @@\n // Tests that if you move from `x.f` or `x[0]`, `x` is inaccessible.\n // Also tests that we give a more specific error message.\n \n-struct Foo { f: StrBuf, y: int }\n-fn consume(_s: StrBuf) {}\n+struct Foo { f: String, y: int }\n+fn consume(_s: String) {}\n fn touch<A>(_a: &A) {}\n \n fn f10() {"}, {"sha": "ce7d51f610b78bb0b7ecab7415df21c7879399fa", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,7 +14,7 @@\n #![feature(managed_boxes)]\n \n struct Foo<A> { f: A }\n-fn guard(_s: StrBuf) -> bool {fail!()}\n+fn guard(_s: String) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {"}, {"sha": "b0bdda6c850d969fb32b3656f8b3a971967926bc", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@\n // terms of the binding, not the discriminant.\n \n struct Foo<A> { f: A }\n-fn guard(_s: StrBuf) -> bool {fail!()}\n+fn guard(_s: String) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n \n fn f10() {"}, {"sha": "f16e70777ed14b44e5f83737fb800824a64403fa", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,5 +14,5 @@ struct S {\n \n impl Cmp, ToStr for S { //~ ERROR: expected `{` but found `,`\n   fn eq(&&other: S) { false }\n-  fn to_str(&self) -> StrBuf { \"hi\".to_owned() }\n+  fn to_str(&self) -> String { \"hi\".to_owned() }\n }"}, {"sha": "0a6d210e114dc5bc9647b97570e410284dd3704b", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,10 +15,10 @@\n \n struct foo {\n   i: int,\n-  j: @StrBuf,\n+  j: @String,\n }\n \n-fn foo(i:int, j: @StrBuf) -> foo {\n+fn foo(i:int, j: @String) -> foo {\n     foo {\n         i: i,\n         j: j"}, {"sha": "977e304a32ec235dc6c4b67b901b0931adfa6c1c", "filename": "src/test/debuginfo/include_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Finclude_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Finclude_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Finclude_string.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,11 +15,11 @@\n // gdb-command:run\n // gdb-command:finish\n // gdb-command:print string1.length\n-// gdb-check:$1 = 48\n+// gdb-check:$1 = 49\n // gdb-command:print string2.length\n-// gdb-check:$2 = 48\n+// gdb-check:$2 = 49\n // gdb-command:print string3.length\n-// gdb-check:$3 = 48\n+// gdb-check:$3 = 49\n // gdb-command:continue\n \n #![allow(unused_variable)]"}, {"sha": "6e1354fbc3af9e1d2b886f0bb352c40beef75517", "filename": "src/test/debuginfo/issue11600.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue11600.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@\n // ignore-test\n \n fn main() {\n-    let args : ~[StrBuf] = ::std::os::args();\n+    let args : ~[String] = ::std::os::args();\n     ::std::io::println(args[0]);\n }\n \n@@ -25,6 +25,6 @@ fn main() {\n // compile-flags:-g\n // gdb-command:list\n // gdb-check:1[...]fn main() {\n-// gdb-check:2[...]let args : ~[StrBuf] = ::std::os::args();\n+// gdb-check:2[...]let args : ~[String] = ::std::os::args();\n // gdb-check:3[...]::std::io::println(args[0]);\n // gdb-check:4[...]}"}, {"sha": "91e2445c4aa9d12d6d7ed9cd2aef088c97c8f498", "filename": "src/test/debuginfo/text-to-include-1.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Ftext-to-include-1.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Ftext-to-include-1.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftext-to-include-1.txt?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1 +1 @@\n-some text to include in another file as string 1\n\\ No newline at end of file\n+some text to include in another file as string 1"}, {"sha": "be6022776c52160438438cc980ce31b0792d814d", "filename": "src/test/debuginfo/text-to-include-2.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Ftext-to-include-2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Ftext-to-include-2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftext-to-include-2.txt?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1 +1 @@\n-some text to include in another file as string 2\n\\ No newline at end of file\n+some text to include in another file as string 2"}, {"sha": "0cff667b47ca029a82df1676ad167d8cc7b0b197", "filename": "src/test/debuginfo/text-to-include-3.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Ftext-to-include-3.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fdebuginfo%2Ftext-to-include-3.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftext-to-include-3.txt?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -1 +1 @@\n-some text to include in another file as string 3\n\\ No newline at end of file\n+some text to include in another file as string 3"}, {"sha": "92fa8124d6828cdd5e0ccbc11c0d5ccd2a38e489", "filename": "src/test/pretty/closure-reform-pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@\n \n // pp-exact\n \n-fn call_it(f: proc(StrBuf) -> StrBuf) { }\n+fn call_it(f: proc(String) -> String) { }\n \n fn call_this(f: |&str|: Send) { }\n "}, {"sha": "091461bd5a890dfb097627ebcb4bd1adf69a7f2d", "filename": "src/test/run-fail/binop-fail-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n // error-pattern:quux\n-fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n+fn my_err(s: String) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n fn main() { 3u == my_err(\"bye\".to_strbuf()); }"}, {"sha": "091461bd5a890dfb097627ebcb4bd1adf69a7f2d", "filename": "src/test/run-fail/binop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n // error-pattern:quux\n-fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n+fn my_err(s: String) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n fn main() { 3u == my_err(\"bye\".to_strbuf()); }"}, {"sha": "b7ad9fe98272fff320e3eb6a243494e6eec294e8", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,6 +11,6 @@\n // error-pattern:meh\n \n fn main() {\n-    let str_var: StrBuf = \"meh\".to_strbuf();\n+    let str_var: String = \"meh\".to_strbuf();\n     fail!(\"{}\", str_var);\n }"}, {"sha": "fc5b8ad2b3b3249b9c618f98af97d41e1824a2e4", "filename": "src/test/run-fail/if-cond-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n // error-pattern:quux\n-fn my_err(s: StrBuf) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n+fn my_err(s: String) -> ! { println!(\"{}\", s); fail!(\"quux\"); }\n fn main() { if my_err(\"bye\".to_strbuf()) { } }"}, {"sha": "9d80f07de0af9173049ee15a7d7896df9c7d3195", "filename": "src/test/run-fail/match-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmatch-bot-fail.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,7 +13,7 @@\n #![allow(unreachable_code)]\n #![allow(unused_variable)]\n \n-fn foo(s: StrBuf) { }\n+fn foo(s: String) { }\n \n fn main() {\n     let i ="}, {"sha": "fa9a2bdd98bb860930d67054456fbdf70c8466db", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -13,5 +13,5 @@\n use std::result;\n \n fn main() {\n-    println!(\"{:?}\", result::Err::<int,StrBuf>(\"kitty\".to_strbuf()).unwrap());\n+    println!(\"{:?}\", result::Err::<int,String>(\"kitty\".to_strbuf()).unwrap());\n }"}, {"sha": "d607ec76c351de4856bd3b41736042e38b361eff", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@\n #![allow(unreachable_code)]\n #![allow(unused_variable)]\n \n-struct T { t: StrBuf }\n+struct T { t: String }\n \n fn main() {\n     let pth = fail!(\"bye\");"}, {"sha": "ee3f74ad2f4a17b51c4ec5d896997916f39dd0ef", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,7 +11,7 @@\n \n // error-pattern:index out of bounds: the len is 5 but the index is 5\n fn main() {\n-    let s: StrBuf = \"hello\".to_strbuf();\n+    let s: String = \"hello\".to_strbuf();\n \n     // Bounds-check failure.\n     assert_eq!(s.as_slice()[5], 0x0 as u8);"}, {"sha": "229280e0b4bfd6c2579131c25e686953dc07f68a", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     let cheese = \"roquefort\".to_strbuf();\n     let carrots = @\"crunchy\".to_strbuf();\n \n-    let result: |@StrBuf, |StrBuf||: 'static = (|tasties, macerate| {\n+    let result: |@String, |String||: 'static = (|tasties, macerate| {\n         macerate((*tasties).clone());\n     });\n     result(carrots, |food| {"}, {"sha": "b875f676982dc0928e7e899855f0332847814127", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -46,7 +46,7 @@ fn main() {\n             let _ = write!(&mut File::create(&main_file).unwrap(),\n                            r\"\\#![feature(non_ascii_idents)] fn main() \\{ {} \\}\",\n                            // random string of length n\n-                           range(0, n).map(|_| random_char()).collect::<StrBuf>());\n+                           range(0, n).map(|_| random_char()).collect::<String>());\n         }\n \n         // rustc is passed to us with --out-dir and -L etc., so we"}, {"sha": "85fbda610cb9e6c7576f055a3777e13d5c104349", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -75,7 +75,7 @@ fn main() {\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,\n-               expr: T, f: |pprust::ps, T|, expect: StrBuf) {\n+               expr: T, f: |pprust::ps, T|, expect: String) {\n     let s = io::with_str_writer(|wr| {\n         let pp = pprust::rust_printer(wr, cx.parse_sess().interner);\n         f(pp, expr);"}, {"sha": "08522ee6b80c15c70cb38a95d0f3656b40f88e9c", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -14,10 +14,10 @@\n \n enum sty { ty_nil, }\n \n-struct RawT {struct_: sty, cname: Option<StrBuf>, hash: uint}\n+struct RawT {struct_: sty, cname: Option<String>, hash: uint}\n \n-fn mk_raw_ty(st: sty, cname: Option<StrBuf>) -> RawT {\n+fn mk_raw_ty(st: sty, cname: Option<String>) -> RawT {\n     return RawT {struct_: st, cname: cname, hash: 0u};\n }\n \n-pub fn main() { mk_raw_ty(ty_nil, None::<StrBuf>); }\n+pub fn main() { mk_raw_ty(ty_nil, None::<String>); }"}, {"sha": "e365f6318c86361dc686435abb2fb5030c6b2797", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -15,7 +15,7 @@ fn g(act: |Vec<int> | -> int) -> int { return act(vec!(1, 2, 3)); }\n \n pub fn main() {\n     assert_eq!(g(f), 1);\n-    let f1: |Vec<StrBuf>| -> StrBuf = f;\n+    let f1: |Vec<String>| -> String = f;\n     assert_eq!(f1(vec![\"x\".to_strbuf(), \"y\".to_strbuf(), \"z\".to_strbuf()]),\n                \"x\".to_strbuf());\n }"}, {"sha": "5494212ffbd14010fdb9273f906651ce8cb7ab80", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -11,17 +11,17 @@\n #![feature(managed_boxes)]\n \n trait Foo {\n-    fn foo(&self) -> StrBuf;\n+    fn foo(&self) -> String;\n }\n \n impl<T:Foo> Foo for @T {\n-    fn foo(&self) -> StrBuf {\n+    fn foo(&self) -> String {\n         format_strbuf!(\"@{}\", (**self).foo())\n     }\n }\n \n impl Foo for uint {\n-    fn foo(&self) -> StrBuf {\n+    fn foo(&self) -> String {\n         format_strbuf!(\"{}\", *self)\n     }\n }"}, {"sha": "a3881424bb15fdd5766b4df7cc827cca76ac7bc8", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -37,7 +37,7 @@ fn runtest(me: &str) {\n     let mut env = os::env().move_iter()\n                            .map(|(ref k, ref v)| {\n                                (k.to_strbuf(), v.to_strbuf())\n-                           }).collect::<Vec<(StrBuf,StrBuf)>>();\n+                           }).collect::<Vec<(String,String)>>();\n     match env.iter()\n              .position(|&(ref s, _)| \"RUST_BACKTRACE\" == s.as_slice()) {\n         Some(i) => { env.remove(i); }"}, {"sha": "bd74a0bd8080cb46b2edba38dad3e1dd828bad72", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    fn as_buf<T>(s: StrBuf, f: |StrBuf| -> T) -> T { f(s) }\n-    as_buf(\"foo\".to_strbuf(), |foo: StrBuf| -> () println!(\"{}\", foo) );\n+    fn as_buf<T>(s: String, f: |String| -> T) -> T { f(s) }\n+    as_buf(\"foo\".to_strbuf(), |foo: String| -> () println!(\"{}\", foo) );\n }"}, {"sha": "9d23068b9ade34ac91c4785052d8a65e562ff141", "filename": "src/test/run-pass/borrowed-ptr-pattern-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-2.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(s: &StrBuf) -> bool {\n+fn foo(s: &String) -> bool {\n     match s.as_slice() {\n         \"kitty\" => true,\n         _ => false"}, {"sha": "4cbb52a0b3d44f0cbc29c7563efece64e78d3356", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -9,22 +9,22 @@\n // except according to those terms.\n \n trait Speak {\n-    fn say(&self, s:&str) -> StrBuf;\n-    fn hi(&self) -> StrBuf { hello(self) }\n+    fn say(&self, s:&str) -> String;\n+    fn hi(&self) -> String { hello(self) }\n }\n \n-fn hello<S:Speak>(s:&S) -> StrBuf{\n+fn hello<S:Speak>(s:&S) -> String{\n     s.say(\"hello\")\n }\n \n impl Speak for int {\n-    fn say(&self, s:&str) -> StrBuf {\n+    fn say(&self, s:&str) -> String {\n         format_strbuf!(\"{}: {}\", s, *self)\n     }\n }\n \n impl<T: Speak> Speak for Option<T> {\n-    fn say(&self, s:&str) -> StrBuf {\n+    fn say(&self, s:&str) -> String {\n         match *self {\n             None => format_strbuf!(\"{} - none\", s),\n             Some(ref x) => { format_strbuf!(\"something!{}\", x.say(s)) }"}, {"sha": "59b60d43fb1e977a93568b0f01281532a2cfe4e9", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -21,11 +21,11 @@ mod mlibc {\n     }\n }\n \n-fn atol(s: StrBuf) -> int {\n+fn atol(s: String) -> int {\n     s.as_slice().with_c_str(|x| unsafe { mlibc::atol(x) as int })\n }\n \n-fn atoll(s: StrBuf) -> i64 {\n+fn atoll(s: String) -> i64 {\n     s.as_slice().with_c_str(|x| unsafe { mlibc::atoll(x) as i64 })\n }\n "}, {"sha": "4e521a112971f32fed3e87d6ede97b4205d6ae06", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n \n use std::task;\n \n-fn child2(_s: StrBuf) { }\n+fn child2(_s: String) { }\n \n pub fn main() {\n     let _x = task::spawn(proc() child2(\"hi\".to_strbuf()));"}, {"sha": "e1b4b26ef07a9a969999418bf2f89352366a7a54", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d76d0ad44e1ec203d235f22eb3514247b8cbfe5/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=7d76d0ad44e1ec203d235f22eb3514247b8cbfe5", "patch": "@@ -12,7 +12,7 @@\n #![allow(unused_attribute)]\n \n struct cat {\n-    name: StrBuf,\n+    name: String,\n }\n \n impl Drop for cat {\n@@ -22,6 +22,6 @@ impl Drop for cat {\n \n \n #[cat_maker]\n-fn cat(name: StrBuf) -> cat { cat{name: name,} }\n+fn cat(name: String) -> cat { cat{name: name,} }\n \n pub fn main() { let _kitty = cat(\"Spotty\".to_strbuf()); }"}]}