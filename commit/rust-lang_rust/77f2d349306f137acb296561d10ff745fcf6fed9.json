{"sha": "77f2d349306f137acb296561d10ff745fcf6fed9", "node_id": "C_kwDOAAsO6NoAKDc3ZjJkMzQ5MzA2ZjEzN2FjYjI5NjU2MWQxMGZmNzQ1ZmNmNmZlZDk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-07T21:57:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-07T21:57:59Z"}, "message": "Merge #10950\n\n10950: internal: completion: split out more PathKinds from ImmediateLocation r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "c3b617973886c95bfc9ff90c0b9dd8319812718b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3b617973886c95bfc9ff90c0b9dd8319812718b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77f2d349306f137acb296561d10ff745fcf6fed9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhr9jnCRBK7hj4Ov3rIwAAqR4IACBiiVLWCEDTr/wH3Mc+AKKS\n4xKGTPtDRnwsYgqaC4A/RAuKOF+qGG++p23Jqh2BUka97ELdEczZ7ccvnoVMBSOD\nvnWQoBpNM3qE23QEKGlkDPhbu4qOE1ZLZNCC0IFgJdA8VaF86QR3iRp/5D3hShYk\n1DQyQEdGeVzZFIOQbMGDJd7CGHwjyPn0h3rYX/FfOB5hD+Ok1pOVoRJgH/Pe1WKV\nMmfNAlenrRTaJP0ZOQBe6Jc4ow7h1ICAypuxC9JmCbxDu/ddgzTD4BY36oGT2AC1\n5wjO8obBiNhjnOvznxDR6eH7PFIsj+Fm56KCCSVvEyphCuDCMmk0gKhIvFSwPwk=\n=sdwL\n-----END PGP SIGNATURE-----\n", "payload": "tree c3b617973886c95bfc9ff90c0b9dd8319812718b\nparent 755b668ae4107bc426edb686dc9362a5b3ba7549\nparent ae0c7268f7c19d83c7be342bf7c3f3d68f2a0599\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1638914279 +0000\ncommitter GitHub <noreply@github.com> 1638914279 +0000\n\nMerge #10950\n\n10950: internal: completion: split out more PathKinds from ImmediateLocation r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77f2d349306f137acb296561d10ff745fcf6fed9", "html_url": "https://github.com/rust-lang/rust/commit/77f2d349306f137acb296561d10ff745fcf6fed9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77f2d349306f137acb296561d10ff745fcf6fed9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755b668ae4107bc426edb686dc9362a5b3ba7549", "url": "https://api.github.com/repos/rust-lang/rust/commits/755b668ae4107bc426edb686dc9362a5b3ba7549", "html_url": "https://github.com/rust-lang/rust/commit/755b668ae4107bc426edb686dc9362a5b3ba7549"}, {"sha": "ae0c7268f7c19d83c7be342bf7c3f3d68f2a0599", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae0c7268f7c19d83c7be342bf7c3f3d68f2a0599", "html_url": "https://github.com/rust-lang/rust/commit/ae0c7268f7c19d83c7be342bf7c3f3d68f2a0599"}], "stats": {"total": 366, "additions": 206, "deletions": 160}, "files": [{"sha": "3a9c1b3beb738f7446c29f657350012686350d95", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -110,14 +110,19 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    if ctx.in_use_tree()\n+    if matches!(ctx.path_kind(), Some(PathKind::Vis { .. } | PathKind::Use))\n         || ctx.is_path_disallowed()\n         || ctx.expects_item()\n         || ctx.expects_assoc_item()\n         || ctx.expects_variant()\n     {\n         return None;\n     }\n+    // FIXME: This should be encoded in a different way\n+    if ctx.pattern_ctx.is_none() && ctx.path_context.is_none() && !ctx.has_dot_receiver() {\n+        // completion inside `ast::Name` of a item declaration\n+        return None;\n+    }\n     let potential_import_name = {\n         let token_kind = ctx.token.kind();\n         if matches!(token_kind, T![.] | T![::]) {\n@@ -147,14 +152,25 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             }\n         };\n         match (kind, import.original_item) {\n+            // Aren't handled in flyimport\n+            (PathKind::Vis { .. } | PathKind::Use, _) => false,\n+            // modules are always fair game\n+            (_, ItemInNs::Types(hir::ModuleDef::Module(_))) => true,\n+            // and so are macros(except for attributes)\n+            (\n+                PathKind::Expr | PathKind::Type | PathKind::Mac | PathKind::Pat,\n+                ItemInNs::Macros(mac),\n+            ) => mac.is_fn_like(),\n+            (PathKind::Mac, _) => true,\n+\n             (PathKind::Expr, ItemInNs::Types(_) | ItemInNs::Values(_)) => true,\n \n+            (PathKind::Pat, ItemInNs::Types(_)) => true,\n+            (PathKind::Pat, ItemInNs::Values(def)) => matches!(def, hir::ModuleDef::Const(_)),\n+\n             (PathKind::Type, ItemInNs::Types(_)) => true,\n             (PathKind::Type, ItemInNs::Values(_)) => false,\n \n-            (PathKind::Expr | PathKind::Type, ItemInNs::Macros(mac)) => mac.is_fn_like(),\n-\n-            (PathKind::Attr, ItemInNs::Types(hir::ModuleDef::Module(_))) => true,\n             (PathKind::Attr, ItemInNs::Macros(mac)) => mac.is_attr(),\n             (PathKind::Attr, _) => false,\n         }"}, {"sha": "1c686dc0a63efb0d95da2dcf38e8d96356c40a8f", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -5,8 +5,9 @@\n use syntax::{SyntaxKind, T};\n \n use crate::{\n-    context::PathCompletionContext, patterns::ImmediateLocation, CompletionContext, CompletionItem,\n-    CompletionItemKind, Completions,\n+    context::{PathCompletionContext, PathKind},\n+    patterns::ImmediateLocation,\n+    CompletionContext, CompletionItem, CompletionItemKind, Completions,\n };\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -33,8 +34,8 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     let has_block_expr_parent = ctx.has_block_expr_parent();\n     let expects_item = ctx.expects_item();\n \n-    if let Some(ImmediateLocation::Visibility(vis)) = &ctx.completion_location {\n-        if vis.in_token().is_none() {\n+    if let Some(PathKind::Vis { has_in_token }) = ctx.path_kind() {\n+        if !has_in_token {\n             cov_mark::hit!(kw_completion_in);\n             add_keyword(\"in\", \"in\");\n         }"}, {"sha": "047659014286cfaff8a7ac2de37cc6ae0b365e70", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -1,15 +1,17 @@\n-//! Completes constants and paths in patterns.\n+//! Completes constants and paths in unqualified patterns.\n \n use crate::{\n     context::{PatternContext, PatternRefutability},\n     CompletionContext, Completions,\n };\n \n-/// Completes constants and paths in patterns.\n+/// Completes constants and paths in unqualified patterns.\n pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     let refutable = match ctx.pattern_ctx {\n-        Some(PatternContext { refutability, .. }) => refutability == PatternRefutability::Refutable,\n-        None => return,\n+        Some(PatternContext { refutability, .. }) if ctx.path_context.is_none() => {\n+            refutability == PatternRefutability::Refutable\n+        }\n+        _ => return,\n     };\n \n     if refutable {"}, {"sha": "b5c3d83c16849d2237a152b8a5a151e6bed7f015", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -7,17 +7,23 @@ use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::PathCompletionContext, patterns::ImmediateLocation, CompletionContext, Completions,\n+    context::{PathCompletionContext, PathKind},\n+    patterns::ImmediateLocation,\n+    CompletionContext, Completions,\n };\n \n pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n-    let (path, use_tree_parent) = match &ctx.path_context {\n-        Some(PathCompletionContext { qualifier: Some(qualifier), use_tree_parent, .. }) => {\n-            (qualifier, *use_tree_parent)\n-        }\n+    let (path, use_tree_parent, kind) = match ctx.path_context {\n+        // let ... else, syntax would come in really handy here right now\n+        Some(PathCompletionContext {\n+            qualifier: Some(ref qualifier),\n+            use_tree_parent,\n+            kind,\n+            ..\n+        }) => (qualifier, use_tree_parent, kind),\n         _ => return,\n     };\n \n@@ -44,7 +50,11 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n             return;\n         }\n-        Some(ImmediateLocation::Visibility(_)) => {\n+        _ => (),\n+    }\n+\n+    match kind {\n+        Some(PathKind::Vis { .. }) => {\n             if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n                 if let Some(current_module) = ctx.scope.module() {\n                     if let Some(next) = current_module\n@@ -61,7 +71,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n             return;\n         }\n-        Some(ImmediateLocation::Attribute(_)) => {\n+        Some(PathKind::Attr) => {\n             if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n                 for (name, def) in module.scope(ctx.db, context_module) {\n                     let add_resolution = match def {\n@@ -76,37 +86,38 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n             return;\n         }\n+        Some(PathKind::Use) => {\n+            if iter::successors(Some(path.clone()), |p| p.qualifier())\n+                .all(|p| p.segment().and_then(|s| s.super_token()).is_some())\n+            {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+            // only show `self` in a new use-tree when the qualifier doesn't end in self\n+            if use_tree_parent\n+                && !matches!(\n+                    path.segment().and_then(|it| it.kind()),\n+                    Some(ast::PathSegmentKind::SelfKw)\n+                )\n+            {\n+                acc.add_keyword(ctx, \"self\");\n+            }\n+        }\n         _ => (),\n     }\n \n-    if ctx.in_use_tree() {\n-        if iter::successors(Some(path.clone()), |p| p.qualifier())\n-            .all(|p| p.segment().and_then(|s| s.super_token()).is_some())\n-        {\n-            acc.add_keyword(ctx, \"super::\");\n-        }\n-        // only show `self` in a new use-tree when the qualifier doesn't end in self\n-        if use_tree_parent\n-            && !matches!(\n-                path.segment().and_then(|it| it.kind()),\n-                Some(ast::PathSegmentKind::SelfKw)\n-            )\n-        {\n-            acc.add_keyword(ctx, \"self\");\n-        }\n+    if !matches!(kind, Some(PathKind::Pat)) {\n+        // Add associated types on type parameters and `Self`.\n+        resolution.assoc_type_shorthand_candidates(ctx.db, |_, alias| {\n+            acc.add_type_alias(ctx, alias);\n+            None::<()>\n+        });\n     }\n \n-    // Add associated types on type parameters and `Self`.\n-    resolution.assoc_type_shorthand_candidates(ctx.db, |_, alias| {\n-        acc.add_type_alias(ctx, alias);\n-        None::<()>\n-    });\n-\n     match resolution {\n         hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n             let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n-                if ctx.in_use_tree() {\n+                if let Some(PathKind::Use) = kind {\n                     if let ScopeDef::Unknown = def {\n                         if let Some(ast::NameLike::NameRef(name_ref)) = ctx.name_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_smol_str().as_str() {"}, {"sha": "ac1ba2da7c4348ecf0c1e7f439bc3e096ae24c44", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -3,15 +3,23 @@\n use hir::ScopeDef;\n use syntax::{ast, AstNode};\n \n-use crate::{patterns::ImmediateLocation, CompletionContext, Completions};\n+use crate::{\n+    context::{PathCompletionContext, PathKind},\n+    patterns::ImmediateLocation,\n+    CompletionContext, Completions,\n+};\n \n pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_unqualified_path\");\n-    if ctx.is_path_disallowed() || !ctx.is_trivial_path() || ctx.has_impl_or_trait_prev_sibling() {\n+    if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n+    let kind = match ctx.path_context {\n+        Some(PathCompletionContext { is_trivial_path: true, kind, .. }) => kind,\n+        _ => return,\n+    };\n \n-    if ctx.in_use_tree() {\n+    if let Some(PathKind::Use) = kind {\n         // only show modules in a fresh UseTree\n         cov_mark::hit!(unqualified_path_only_modules_in_import);\n         ctx.process_all_names(&mut |name, res| {\n@@ -25,8 +33,25 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     }\n     [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n \n+    match kind {\n+        Some(PathKind::Vis { .. }) => return,\n+        Some(PathKind::Attr) => {\n+            ctx.process_all_names(&mut |name, res| {\n+                let add_resolution = match res {\n+                    ScopeDef::MacroDef(mac) => mac.is_attr(),\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n+                    _ => false,\n+                };\n+                if add_resolution {\n+                    acc.add_resolution(ctx, name, &res);\n+                }\n+            });\n+            return;\n+        }\n+        _ => (),\n+    }\n+\n     match &ctx.completion_location {\n-        Some(ImmediateLocation::Visibility(_)) => return,\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {\n             // only show macros in {Assoc}ItemList\n             ctx.process_all_names(&mut |name, res| {\n@@ -56,19 +81,6 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n             });\n             return;\n         }\n-        Some(ImmediateLocation::Attribute(_)) => {\n-            ctx.process_all_names(&mut |name, res| {\n-                let add_resolution = match res {\n-                    ScopeDef::MacroDef(mac) => mac.is_attr(),\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n-                    _ => false,\n-                };\n-                if add_resolution {\n-                    acc.add_resolution(ctx, name, &res);\n-                }\n-            });\n-            return;\n-        }\n         _ => (),\n     }\n "}, {"sha": "e8566b80b6f2564b8f8e098e6eb39b04272f22ab", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 86, "deletions": 74, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -35,16 +35,23 @@ pub(super) enum PathKind {\n     Expr,\n     Type,\n     Attr,\n+    Mac,\n+    Pat,\n+    Vis { has_in_token: bool },\n+    Use,\n }\n \n #[derive(Debug)]\n pub(crate) struct PathCompletionContext {\n     /// If this is a call with () already there\n-    call_kind: Option<CallKind>,\n+    has_call_parens: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n     pub(super) qualifier: Option<ast::Path>,\n+    #[allow(dead_code)]\n+    /// If not a trivial path, the suffix (parent).\n+    pub(super) parent: Option<ast::Path>,\n     /// Whether the qualifier comes from a use tree parent or not\n     pub(super) use_tree_parent: bool,\n     pub(super) kind: Option<PathKind>,\n@@ -70,13 +77,6 @@ pub(super) enum LifetimeContext {\n     LabelDef,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum CallKind {\n-    Pat,\n-    Mac,\n-    Expr,\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ParamKind {\n     Function,\n@@ -206,13 +206,6 @@ impl<'a> CompletionContext<'a> {\n         )\n     }\n \n-    pub(crate) fn in_use_tree(&self) -> bool {\n-        matches!(\n-            self.completion_location,\n-            Some(ImmediateLocation::Use | ImmediateLocation::UseTree)\n-        )\n-    }\n-\n     pub(crate) fn has_impl_or_trait_prev_sibling(&self) -> bool {\n         matches!(\n             self.prev_sibling,\n@@ -257,8 +250,8 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.path_context, Some(PathCompletionContext { kind: Some(PathKind::Type), .. }))\n     }\n \n-    pub(crate) fn path_call_kind(&self) -> Option<CallKind> {\n-        self.path_context.as_ref().and_then(|it| it.call_kind)\n+    pub(crate) fn path_is_call(&self) -> bool {\n+        self.path_context.as_ref().map_or(false, |it| it.has_call_parens)\n     }\n \n     pub(crate) fn is_trivial_path(&self) -> bool {\n@@ -673,7 +666,12 @@ impl<'a> CompletionContext<'a> {\n                     Self::classify_lifetime(&self.sema, original_file, lifetime, offset);\n             }\n             ast::NameLike::NameRef(name_ref) => {\n-                self.path_context = Self::classify_name_ref(&self.sema, original_file, name_ref);\n+                if let Some((path_ctx, pat_ctx)) =\n+                    Self::classify_name_ref(&self.sema, original_file, name_ref)\n+                {\n+                    self.path_context = Some(path_ctx);\n+                    self.pattern_ctx = pat_ctx;\n+                }\n             }\n             ast::NameLike::Name(name) => {\n                 self.pattern_ctx = Self::classify_name(&self.sema, name);\n@@ -716,83 +714,61 @@ impl<'a> CompletionContext<'a> {\n         if !bind_pat.is_simple_ident() {\n             return None;\n         }\n-        let mut is_param = None;\n-        let (refutability, has_type_ascription) = bind_pat\n-            .syntax()\n-            .ancestors()\n-            .skip_while(|it| ast::Pat::can_cast(it.kind()))\n-            .next()\n-            .map_or((PatternRefutability::Irrefutable, false), |node| {\n-                let refutability = match_ast! {\n-                    match node {\n-                        ast::LetStmt(let_) => return (PatternRefutability::Irrefutable, let_.ty().is_some()),\n-                        ast::Param(param) => {\n-                            let is_closure_param = param\n-                                .syntax()\n-                                .ancestors()\n-                                .nth(2)\n-                                .and_then(ast::ClosureExpr::cast)\n-                                .is_some();\n-                            is_param = Some(if is_closure_param {\n-                                ParamKind::Closure\n-                            } else {\n-                                ParamKind::Function\n-                            });\n-                            return (PatternRefutability::Irrefutable, param.ty().is_some())\n-                        },\n-                        ast::MatchArm(__) => PatternRefutability::Refutable,\n-                        ast::Condition(__) => PatternRefutability::Refutable,\n-                        ast::ForExpr(__) => PatternRefutability::Irrefutable,\n-                        _ => PatternRefutability::Irrefutable,\n-                    }\n-                };\n-                (refutability, false)\n-            });\n-        Some(PatternContext { refutability, is_param, has_type_ascription })\n+        Some(pattern_context_for(bind_pat.into()))\n     }\n \n     fn classify_name_ref(\n         _sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n-    ) -> Option<PathCompletionContext> {\n+    ) -> Option<(PathCompletionContext, Option<PatternContext>)> {\n         let parent = name_ref.syntax().parent()?;\n         let segment = ast::PathSegment::cast(parent)?;\n+        let path = segment.parent_path();\n \n         let mut path_ctx = PathCompletionContext {\n-            call_kind: None,\n+            has_call_parens: false,\n             is_trivial_path: false,\n             qualifier: None,\n+            parent: None,\n             has_type_args: false,\n             can_be_stmt: false,\n             in_loop_body: false,\n             use_tree_parent: false,\n             kind: None,\n         };\n+        let mut pat_ctx = None;\n         path_ctx.in_loop_body = is_in_loop_body(name_ref.syntax());\n-        let path = segment.parent_path();\n-\n-        if let Some(p) = path.syntax().parent() {\n-            path_ctx.call_kind = match_ast! {\n-                match p {\n-                    ast::PathExpr(it) => it.syntax().parent().and_then(ast::CallExpr::cast).map(|_| CallKind::Expr),\n-                    ast::MacroCall(it) => it.excl_token().and(Some(CallKind::Mac)),\n-                    ast::TupleStructPat(_it) => Some(CallKind::Pat),\n-                    _ => None\n-                }\n-            };\n-        }\n \n-        if let Some(parent) = path.syntax().parent() {\n-            path_ctx.kind = match_ast! {\n-                match parent {\n+        path_ctx.kind  = path.syntax().ancestors().find_map(|it| {\n+            match_ast! {\n+                match it {\n                     ast::PathType(_it) => Some(PathKind::Type),\n-                    ast::PathExpr(_it) => Some(PathKind::Expr),\n+                    ast::PathExpr(it) => {\n+                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+                        Some(PathKind::Expr)\n+                    },\n+                    ast::TupleStructPat(it) => {\n+                        path_ctx.has_call_parens = true;\n+                        pat_ctx = Some(pattern_context_for(it.into()));\n+                        Some(PathKind::Pat)\n+                    },\n+                    ast::RecordPat(it) => {\n+                        pat_ctx = Some(pattern_context_for(it.into()));\n+                        Some(PathKind::Pat)\n+                    },\n+                    ast::PathPat(it) => {\n+                        pat_ctx = Some(pattern_context_for(it.into()));\n+                        Some(PathKind::Pat)\n+                    },\n+                    ast::MacroCall(it) => it.excl_token().and(Some(PathKind::Mac)),\n                     ast::Meta(_it) => Some(PathKind::Attr),\n+                    ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n+                    ast::UseTree(_it) => Some(PathKind::Use),\n                     _ => None,\n                 }\n-            };\n-        }\n+            }\n+        });\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n@@ -806,12 +782,12 @@ impl<'a> CompletionContext<'a> {\n                     )\n                 })\n                 .map(|it| it.parent_path());\n-            return Some(path_ctx);\n+            return Some((path_ctx, pat_ctx));\n         }\n \n         if let Some(segment) = path.segment() {\n             if segment.coloncolon_token().is_some() {\n-                return Some(path_ctx);\n+                return Some((path_ctx, pat_ctx));\n             }\n         }\n \n@@ -835,10 +811,46 @@ impl<'a> CompletionContext<'a> {\n                 None\n             })\n             .unwrap_or(false);\n-        Some(path_ctx)\n+        Some((path_ctx, pat_ctx))\n     }\n }\n \n+fn pattern_context_for(pat: ast::Pat) -> PatternContext {\n+    let mut is_param = None;\n+    let (refutability, has_type_ascription) =\n+    pat\n+        .syntax()\n+        .ancestors()\n+        .skip_while(|it| ast::Pat::can_cast(it.kind()))\n+        .next()\n+        .map_or((PatternRefutability::Irrefutable, false), |node| {\n+            let refutability = match_ast! {\n+                match node {\n+                    ast::LetStmt(let_) => return (PatternRefutability::Irrefutable, let_.ty().is_some()),\n+                    ast::Param(param) => {\n+                        let is_closure_param = param\n+                            .syntax()\n+                            .ancestors()\n+                            .nth(2)\n+                            .and_then(ast::ClosureExpr::cast)\n+                            .is_some();\n+                        is_param = Some(if is_closure_param {\n+                            ParamKind::Closure\n+                        } else {\n+                            ParamKind::Function\n+                        });\n+                        return (PatternRefutability::Irrefutable, param.ty().is_some())\n+                    },\n+                    ast::MatchArm(__) => PatternRefutability::Refutable,\n+                    ast::Condition(__) => PatternRefutability::Refutable,\n+                    ast::ForExpr(__) => PatternRefutability::Irrefutable,\n+                    _ => PatternRefutability::Irrefutable,\n+                }\n+            };\n+            (refutability, false)\n+        });\n+    PatternContext { refutability, is_param, has_type_ascription }\n+}\n fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n     syntax.covering_element(range).ancestors().find_map(N::cast)\n }"}, {"sha": "b50f76b9116a737824a4c90f520cea9d8a7b70b8", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -33,8 +33,6 @@ pub(crate) enum ImmediatePrevSibling {\n /// from which file the nodes are.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediateLocation {\n-    Use,\n-    UseTree,\n     Rename,\n     Impl,\n     Trait,\n@@ -47,10 +45,7 @@ pub(crate) enum ImmediateLocation {\n     TypeBound,\n     Variant,\n     /// Fake file ast node\n-    Attribute(ast::Attr),\n-    /// Fake file ast node\n     ModDeclaration(ast::Module),\n-    Visibility(ast::Visibility),\n     /// Original file ast node\n     MethodCall {\n         receiver: Option<ast::Expr>,\n@@ -206,9 +201,6 @@ pub(crate) fn determine_location(\n     let res = match_ast! {\n         match parent {\n             ast::IdentPat(_it) => ImmediateLocation::IdentPat,\n-            ast::Use(_it) => ImmediateLocation::Use,\n-            ast::UseTree(_it) => ImmediateLocation::UseTree,\n-            ast::UseTreeList(_it) => ImmediateLocation::UseTree,\n             ast::Rename(_it) => ImmediateLocation::Rename,\n             ast::StmtList(_it) => ImmediateLocation::StmtList,\n             ast::SourceFile(_it) => ImmediateLocation::ItemList,\n@@ -242,7 +234,6 @@ pub(crate) fn determine_location(\n                     return None;\n                 }\n             },\n-            ast::Attr(it) => ImmediateLocation::Attribute(it),\n             ast::FieldExpr(it) => {\n                 let receiver = it\n                     .expr()\n@@ -268,8 +259,6 @@ pub(crate) fn determine_location(\n                     .and_then(|r| find_node_with_range(original_file, r)),\n                 has_parens: it.arg_list().map_or(false, |it| it.l_paren_token().is_some())\n             },\n-            ast::Visibility(it) => it.pub_token()\n-                .and_then(|t| (t.text_range().end() < offset).then(|| ImmediateLocation::Visibility(it)))?,\n             _ => return None,\n         }\n     };\n@@ -417,14 +406,6 @@ mod tests {\n         check_location(r\"impl A { fn f$0 }\", None);\n     }\n \n-    #[test]\n-    fn test_use_loc() {\n-        check_location(r\"use f$0\", ImmediateLocation::Use);\n-        check_location(r\"use f$0;\", ImmediateLocation::Use);\n-        check_location(r\"use f::{f$0}\", ImmediateLocation::UseTree);\n-        check_location(r\"use {f$0}\", ImmediateLocation::UseTree);\n-    }\n-\n     #[test]\n     fn test_record_field_loc() {\n         check_location(r\"struct Foo { f$0 }\", ImmediateLocation::RecordField);"}, {"sha": "4d0405444542141ab45594251c18f432ec1b4c78", "filename": "crates/ide_completion/src/render/builder_ext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -4,7 +4,7 @@ use either::Either;\n use itertools::Itertools;\n use syntax::ast::{self, HasName};\n \n-use crate::{context::CallKind, item::Builder, patterns::ImmediateLocation, CompletionContext};\n+use crate::{context::PathKind, item::Builder, patterns::ImmediateLocation, CompletionContext};\n \n #[derive(Debug)]\n pub(super) enum Params {\n@@ -30,11 +30,11 @@ impl Builder {\n         if !ctx.config.add_call_parenthesis {\n             return false;\n         }\n-        if ctx.in_use_tree() {\n+        if let Some(PathKind::Use) = ctx.path_kind() {\n             cov_mark::hit!(no_parens_in_use_item);\n             return false;\n         }\n-        if matches!(ctx.path_call_kind(), Some(CallKind::Expr | CallKind::Pat))\n+        if matches!(ctx.path_kind(), Some(PathKind::Expr | PathKind::Pat) if ctx.path_is_call())\n             | matches!(\n                 ctx.completion_location,\n                 Some(ImmediateLocation::MethodCall { has_parens: true, .. })"}, {"sha": "ac1f152aeac325fe6850bd1c281ee61a614d94d1", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -9,7 +9,7 @@ use syntax::{\n };\n \n use crate::{\n-    context::CallKind,\n+    context::PathKind,\n     item::{CompletionItem, ImportEdit},\n     render::RenderContext,\n };\n@@ -61,9 +61,8 @@ impl<'a> MacroRender<'a> {\n         }\n \n         let needs_bang = self.macro_.is_fn_like()\n-            && !(self.ctx.completion.in_use_tree()\n-                || matches!(self.ctx.completion.path_call_kind(), Some(CallKind::Mac)));\n-        let has_parens = self.ctx.completion.path_call_kind().is_some();\n+            && !matches!(self.ctx.completion.path_kind(), Some(PathKind::Mac | PathKind::Use));\n+        let has_parens = self.ctx.completion.path_is_call();\n \n         match self.ctx.snippet_cap() {\n             Some(cap) if needs_bang && !has_parens => {\n@@ -86,8 +85,7 @@ impl<'a> MacroRender<'a> {\n     }\n \n     fn needs_bang(&self) -> bool {\n-        !self.ctx.completion.in_use_tree()\n-            && !matches!(self.ctx.completion.path_call_kind(), Some(CallKind::Mac))\n+        !matches!(self.ctx.completion.path_kind(), Some(PathKind::Mac | PathKind::Use))\n     }\n \n     fn label(&self) -> SmolStr {"}, {"sha": "23e5da463c7a9eac4b4d4972ceee65674e2c9d44", "filename": "crates/ide_completion/src/tests/flyimport.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f2d349306f137acb296561d10ff745fcf6fed9/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=77f2d349306f137acb296561d10ff745fcf6fed9", "patch": "@@ -1000,6 +1000,19 @@ fn function() {\n     );\n }\n \n+#[test]\n+fn flyimport_item_name() {\n+    check(\n+        r#\"\n+mod module {\n+    pub struct Struct;\n+}\n+struct Str$0\n+    \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n #[test]\n fn flyimport_rename() {\n     check("}]}