{"sha": "154f81b0be502b401c2900ce1bd0db8afb474ff6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NGY4MWIwYmU1MDJiNDAxYzI5MDBjZTFiZDBkYjhhZmI0NzRmZjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T03:39:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T06:40:32Z"}, "message": "revert metrics", "tree": {"sha": "c51d09cc17bac974543f92255453e7abc73d9142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c51d09cc17bac974543f92255453e7abc73d9142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154f81b0be502b401c2900ce1bd0db8afb474ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154f81b0be502b401c2900ce1bd0db8afb474ff6", "html_url": "https://github.com/rust-lang/rust/commit/154f81b0be502b401c2900ce1bd0db8afb474ff6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154f81b0be502b401c2900ce1bd0db8afb474ff6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6237368cc2e640e50ee3616386be65e7f0fc98ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/6237368cc2e640e50ee3616386be65e7f0fc98ad", "html_url": "https://github.com/rust-lang/rust/commit/6237368cc2e640e50ee3616386be65e7f0fc98ad"}], "stats": {"total": 176, "additions": 94, "deletions": 82}, "files": [{"sha": "f6539e4f0f3e3bb7231681676f897dca008c00d7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 91, "deletions": 73, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/154f81b0be502b401c2900ce1bd0db8afb474ff6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154f81b0be502b401c2900ce1bd0db8afb474ff6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=154f81b0be502b401c2900ce1bd0db8afb474ff6", "patch": "@@ -414,32 +414,29 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n                                False);\n }\n \n-fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n-    let {bcx, sz, align: _} = metrics(bcx, t, none);\n-    rslt(bcx, sz)\n+fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n+    size_of_(cx, t, align_total)\n }\n \n-fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n-    let {bcx, sz: _, align} = metrics(bcx, t, none);\n-    rslt(bcx, align)\n+tag align_mode {\n+    align_total;\n+    align_next(ty::t);\n }\n \n-// Computes the size/alignment of the type `t`.  `opt_v`, if provided, should\n-// be a pointer to the instance of type `t` whose size/alignment are being\n-// computed.  For most types, `opt_v` is not needed, because all instances\n-// have the same size/alignment.  However, for opaque types like closures, the\n-// instance is required.\n-fn metrics(bcx: @block_ctxt, t: ty::t, opt_v: option<ValueRef>)\n-    -> metrics_result {\n-    let ccx = bcx_ccx(bcx);\n+fn size_of_(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n+    let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = bcx.sp;\n-        let sz = llsize_of(bcx_ccx(bcx), type_of(ccx, sp, t));\n-        let align = llalign_of(bcx_ccx(bcx), type_of(ccx, sp, t));\n-        ret {bcx: bcx, sz: sz, align: align};\n-    } else {\n-        ret dynamic_metrics(bcx, t, opt_v);\n-    }\n+        let sp = cx.sp;\n+        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n+    } else { dynamic_size_of(cx, t, mode) }\n+}\n+\n+fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n+    } else { dynamic_align_of(cx, t) }\n }\n \n fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n@@ -545,18 +542,9 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n     }\n }\n \n-type metrics_result = {\n-    bcx: @block_ctxt,\n-    sz: ValueRef,\n-    align: ValueRef\n-};\n-\n-fn dynamic_metrics(bcx: @block_ctxt,\n-                   t: ty::t,\n-                   opt_v: option<ValueRef>) -> metrics_result {\n-    fn c_struct_metrics(bcx: @block_ctxt,\n-                        elts: [ty::t],\n-                        opt_v: option<ValueRef>) -> metrics_result {\n+fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n+    fn align_elements(cx: @block_ctxt, elts: [ty::t],\n+                      mode: align_mode) -> result {\n         //\n         // C padding rules:\n         //\n@@ -565,45 +553,50 @@ fn dynamic_metrics(bcx: @block_ctxt,\n         //   - Pad after final structure member so that whole structure\n         //     is aligned to max alignment of interior.\n         //\n-        let bcx = bcx;\n-        let off = C_int(bcx_ccx(bcx), 0);\n-        let max_align = C_int(bcx_ccx(bcx), 1);\n+\n+        let off = C_int(bcx_ccx(cx), 0);\n+        let max_align = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n         for e: ty::t in elts {\n-            let opt_ev = option::map(opt_v) {|v| ptr_offs(bcx, v, off) };\n-            let elt_metrics = metrics(bcx, e, opt_ev);\n-            bcx = elt_metrics.bcx;\n-            let aligned_off = align_to(bcx, off, elt_metrics.align);\n-            off = Add(bcx, aligned_off, elt_metrics.sz);\n-            max_align = umax(bcx, max_align, elt_metrics.align);\n+            let elt_align = align_of(bcx, e);\n+            bcx = elt_align.bcx;\n+            let elt_size = size_of(bcx, e);\n+            bcx = elt_size.bcx;\n+            let aligned_off = align_to(bcx, off, elt_align.val);\n+            off = Add(bcx, aligned_off, elt_size.val);\n+            max_align = umax(bcx, max_align, elt_align.val);\n         }\n-        off = align_to(bcx, off, max_align);\n-        ret { bcx: bcx, sz: off, align: max_align };\n+        off = alt mode {\n+          align_total. {\n+            align_to(bcx, off, max_align)\n+          }\n+          align_next(t) {\n+            let {bcx, val: align} = align_of(bcx, t);\n+            align_to(bcx, off, align)\n+          }\n+        };\n+        ret rslt(bcx, off);\n     }\n-\n-    alt ty::struct(bcx_tcx(bcx), t) {\n+    alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n-        let ti = none::<@tydesc_info>;\n-        let {bcx, val: tydesc} =\n-            get_tydesc(bcx, t, false, tps_normal, ti).result;\n-        let sz = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_size]));\n-        let al = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_align]));\n-        ret { bcx: bcx, sz: sz, align: al };\n+        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n+        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n       }\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = [];\n         for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret c_struct_metrics(bcx, tys, opt_v);\n+        ret align_elements(cx, tys, mode);\n       }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for tp in elts { tys += [tp]; }\n-        ret c_struct_metrics(bcx, tys, opt_v);\n+        ret align_elements(cx, tys, mode);\n       }\n       ty::ty_tag(tid, tps) {\n-        let bcx = bcx;\n+        let bcx = cx;\n         let ccx = bcx_ccx(bcx);\n+        // Compute max(variant sizes).\n \n-        // Compute max(variant sizes) and max(variant alignments).\n         let max_size: ValueRef = alloca(bcx, ccx.int_type);\n         Store(bcx, C_int(ccx, 0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n@@ -613,19 +606,12 @@ fn dynamic_metrics(bcx: @block_ctxt,\n             let raw_tys: [ty::t] = variant.args;\n             let tys: [ty::t] = [];\n             for raw_ty: ty::t in raw_tys {\n-                let t = ty::substitute_type_params(bcx_tcx(bcx), tps, raw_ty);\n+                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n                 tys += [t];\n             }\n-\n-            // Note: we do not pass in opt_v here for the value but rather\n-            // none.  The reason is that what we would want to pass in is a\n-            // ptr to the blob data of the tag, but this is impossible until\n-            // we know the size/alignment of the blob data.  Therefore, it is\n-            // not legal to have a tag type that contains an interior opaque\n-            // type.  Fortunately this will never happen.\n-            let rslt = c_struct_metrics(bcx, tys, none);\n+            let rslt = align_elements(bcx, tys, mode);\n             bcx = rslt.bcx;\n-            let this_size = rslt.sz;\n+            let this_size = rslt.val;\n             let old_max_size = Load(bcx, max_size);\n             Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n         }\n@@ -634,8 +620,41 @@ fn dynamic_metrics(bcx: @block_ctxt,\n             if vec::len(*variants) != 1u {\n                 Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n             } else { max_size_val };\n-        let total_align = C_int(bcx_ccx(bcx), 1); // FIXME: stub\n-        ret {bcx: bcx, sz: total_size, align: total_align};\n+        ret rslt(bcx, total_size);\n+      }\n+    }\n+}\n+\n+fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n+// FIXME: Typestate constraint that shows this alt is\n+// exhaustive\n+    alt ty::struct(bcx_tcx(cx), t) {\n+      ty::ty_param(p, _) {\n+        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n+        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n+      }\n+      ty::ty_rec(flds) {\n+        let a = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for f: ty::field in flds {\n+            let align = align_of(bcx, f.mt.ty);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n+      }\n+      ty::ty_tag(_, _) {\n+        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n+      }\n+      ty::ty_tup(elts) {\n+        let a = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for e in elts {\n+            let align = align_of(bcx, e);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n       }\n     }\n }\n@@ -744,10 +763,9 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n     let args = [];\n     for typ: ty::t in s.prefix { args += [typ]; }\n     let prefix_ty = ty::mk_tup(bcx_tcx(bcx), args);\n-    let {bcx, sz: prefix_sz, align: _} = metrics(bcx, prefix_ty, some(base));\n-    let {bcx, val: align} = align_of(bcx, s.target);\n-    let sz = align_to(bcx, prefix_sz, align);\n-    ret rslt(bcx, bump_ptr(bcx, s.target, base, sz));\n+\n+    let sz = size_of_(bcx, prefix_ty, align_next(s.target));\n+    ret rslt(sz.bcx, bump_ptr(sz.bcx, s.target, base, sz.val));\n }\n \n \n@@ -1999,7 +2017,7 @@ fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n         ret bcx;\n     }\n \n-    let {bcx, sz: llsz, align: _} = metrics(bcx, t, some(src));\n+    let {bcx, val: llsz} = size_of(bcx, t);\n     ret call_memmove(bcx, dst, src, llsz).bcx;\n }\n "}, {"sha": "5c4905207c85495711bd248aa93297afa7cb25b8", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/154f81b0be502b401c2900ce1bd0db8afb474ff6/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154f81b0be502b401c2900ce1bd0db8afb474ff6/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=154f81b0be502b401c2900ce1bd0db8afb474ff6", "patch": "@@ -5,7 +5,6 @@ import trans_build::*;\n import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n-    metrics,\n     size_of,\n     node_id_type,\n     INIT,\n@@ -34,15 +33,10 @@ fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n     ret trans::store_in_dest(bcx, llptr, dest);\n }\n \n-fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n-    : type_is_unique_box(cx, uniq_ty) -> result {\n-    ret alloc_uniq_(cx, uniq_ty, none);\n-}\n-\n-fn alloc_uniq_(bcx: @block_ctxt, uniq_ty: ty::t, opt_v: option<ValueRef>)\n+fn alloc_uniq(bcx: @block_ctxt, uniq_ty: ty::t)\n     : type_is_unique_box(bcx, uniq_ty) -> result {\n     let contents_ty = content_ty(bcx, uniq_ty);\n-    let {bcx, sz: llsz, align: _} = metrics(bcx, contents_ty, opt_v);\n+    let {bcx, val: llsz} = size_of(bcx, contents_ty);\n     let ccx = bcx_ccx(bcx);\n     check non_ty_var(ccx, contents_ty);\n     let llptrty = T_ptr(type_of_inner(ccx, bcx.sp, contents_ty));\n@@ -84,7 +78,7 @@ fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n     : type_is_unique_box(bcx, t) -> result {\n \n     let content_ty = content_ty(bcx, t);\n-    let {bcx, val: llptr} = alloc_uniq_(bcx, t, some(v));\n+    let {bcx, val: llptr} = alloc_uniq(bcx, t);\n \n     let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;"}]}