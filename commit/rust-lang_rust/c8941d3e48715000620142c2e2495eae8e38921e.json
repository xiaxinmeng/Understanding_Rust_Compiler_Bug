{"sha": "c8941d3e48715000620142c2e2495eae8e38921e", "node_id": "C_kwDOAAsO6NoAKGM4OTQxZDNlNDg3MTUwMDA2MjAxNDJjMmUyNDk1ZWFlOGUzODkyMWU", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2022-01-13T02:15:51Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2022-01-19T22:13:21Z"}, "message": "Store a `Symbol` instead of an `Ident` in `AssocItem`\n\nThis is the same idea as #92533, but for `AssocItem` instead\nof `VariantDef`/`FieldDef`.\n\nWith this change, we no longer have any uses of\n`#[stable_hasher(project(...))]`", "tree": {"sha": "a68796e666ff597b9618f2018013cb5aed9b5e6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a68796e666ff597b9618f2018013cb5aed9b5e6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8941d3e48715000620142c2e2495eae8e38921e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmHojQIACgkQtAh+UQ6Y\nsWRkDBAAoiyHzvSejXDpgKgjvzveNPqSIPtYjmZHw/Hw5axufWdqMykGLJw3pGhN\nM+U7HqJGbY4zlZ1D840QbcmYUpT0smG8pg4yk2zMPF+kvMJML1DBbBznFfUSKPKy\nA2aLss10ABctpDgmUUJ5EokzbctYBjg3jVXK48fNmKg3R16jnr3nS6yO+T9dQL9g\nhPHSye8ucBksQQcSxmMOD4XwHka92o9iRecFPG6ULseSjKNuqAqJJUs00oNdFbBV\nqxoohjZOnleBe8K6oLy+aukCOJXiD/CF0Qz8rKIZVrm81RxVTdGeYdZ0Bb/Nx2JP\nyya5U9wbnhyaxGOewc11OeV3o+qRbMq553VKZvhy2Z0FbJJ8ARP3lIQFyB/lRX2P\nUU1DsE+358/5NM/TUvDLKzFFU5jUY/MjbYTQotO6qszCRR7KbFbbz0bnVOX0TJn0\n9KHhj6fMX8CnTbRAtE41VqMppRsqg9tpVoZ8XAEWrEt1N8vBtZyShmkBaYI6m/F/\nfuMKWVoHBarZrTsuik5LXCE24K2FE04zkvGpL+wOPaKXBIROAyrf7H2Jo8UEGOIg\nH9vRl1R9GAmAJfI2tx77YL86mayPyZU8115lVOS7gW7ZP0ZjQO4pQ7fcnDOwrKhp\n290eqbChtlL9lgqkMhubT0zz4oTZXxuiEAXk+3+phYi+v3jhk/U=\n=dKfN\n-----END PGP SIGNATURE-----", "payload": "tree a68796e666ff597b9618f2018013cb5aed9b5e6a\nparent 5e57faa78aa7661c6000204591558f6665f11abc\nauthor Aaron Hill <aa1ronham@gmail.com> 1642040151 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1642630401 -0500\n\nStore a `Symbol` instead of an `Ident` in `AssocItem`\n\nThis is the same idea as #92533, but for `AssocItem` instead\nof `VariantDef`/`FieldDef`.\n\nWith this change, we no longer have any uses of\n`#[stable_hasher(project(...))]`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8941d3e48715000620142c2e2495eae8e38921e", "html_url": "https://github.com/rust-lang/rust/commit/c8941d3e48715000620142c2e2495eae8e38921e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8941d3e48715000620142c2e2495eae8e38921e/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e57faa78aa7661c6000204591558f6665f11abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e57faa78aa7661c6000204591558f6665f11abc", "html_url": "https://github.com/rust-lang/rust/commit/5e57faa78aa7661c6000204591558f6665f11abc"}], "stats": {"total": 192, "additions": 100, "deletions": 92}, "files": [{"sha": "8ed50075ecbae192fa1983f3a7d5610aff4fc51d", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -798,7 +798,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .map(|assoc_items| {\n                         assoc_items\n                             .in_definition_order()\n-                            .map(|assoc_item_def| assoc_item_def.ident)\n+                            .map(|assoc_item_def| assoc_item_def.ident(self.infcx.tcx))\n                             .filter(|&ident| {\n                                 let original_method_ident = path_segment.ident;\n                                 original_method_ident != ident"}, {"sha": "cf0ac5bcba6e95dc64e87603a64ccac4516ebaa0", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -2643,7 +2643,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => format!(\n                 \" for lifetime parameter {}in trait containing associated type `{}`\",\n                 br_string(br),\n-                self.tcx.associated_item(def_id).ident\n+                self.tcx.associated_item(def_id).name\n             ),\n             infer::EarlyBoundRegion(_, name) => format!(\" for lifetime parameter `{}`\", name),\n             infer::UpvarRegion(ref upvar_id, _) => {"}, {"sha": "0a9f59fbc9783dc378000dbf3520de5752927eed", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             .map(|s| format!(\"`{}`\", s))\n                             .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n                         lifetime,\n-                        ctxt.assoc_item.ident,\n+                        ctxt.assoc_item.name,\n                     );\n                     err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n                     err.span_label(\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n                 // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n                 if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n-                    override_error_code = Some(ctxt.assoc_item.ident);\n+                    override_error_code = Some(ctxt.assoc_item.name);\n                 }\n             }\n         }\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     self.get_impl_ident_and_self_ty_from_trait(*item_def_id, &v.0)\n                 {\n                     if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty) {\n-                        override_error_code = Some(ident);\n+                        override_error_code = Some(ident.name);\n                     }\n                 }\n             }"}, {"sha": "1582359024d61e1165fbb4d8d68e3d86af4db835", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1286,7 +1286,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         ty::AssocItem {\n-            ident,\n+            name: ident.name,\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),"}, {"sha": "3615c1cdff9ae77b9afc7465269d5c902b120ad7", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1291,7 +1291,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n             }\n         }\n-        self.encode_ident_span(def_id, impl_item.ident);\n+        self.encode_ident_span(def_id, impl_item.ident(self.tcx));\n         self.encode_item_type(def_id);\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n             record!(self.tables.trait_item_def_id[def_id] <- trait_item_def_id);"}, {"sha": "c23d4eae1a400eac98a716bedca65c160bc6fcb7", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -44,8 +44,7 @@ impl AssocItemContainer {\n #[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n pub struct AssocItem {\n     pub def_id: DefId,\n-    #[stable_hasher(project(name))]\n-    pub ident: Ident,\n+    pub name: Symbol,\n     pub kind: AssocKind,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n@@ -61,6 +60,10 @@ pub struct AssocItem {\n }\n \n impl AssocItem {\n+    pub fn ident(&self, tcx: TyCtxt<'_>) -> Ident {\n+        Ident::new(self.name, tcx.def_ident_span(self.def_id).unwrap())\n+    }\n+\n     pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n         match self.kind {\n             ty::AssocKind::Fn => {\n@@ -70,9 +73,9 @@ impl AssocItem {\n                 // regions just fine, showing `fn(&MyType)`.\n                 tcx.fn_sig(self.def_id).skip_binder().to_string()\n             }\n-            ty::AssocKind::Type => format!(\"type {};\", self.ident),\n+            ty::AssocKind::Type => format!(\"type {};\", self.name),\n             ty::AssocKind::Const => {\n-                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n+                format!(\"const {}: {:?};\", self.name, tcx.type_of(self.def_id))\n             }\n         }\n     }\n@@ -115,7 +118,7 @@ pub struct AssocItems<'tcx> {\n impl<'tcx> AssocItems<'tcx> {\n     /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n     pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n-        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n+        let items = items_in_def_order.into_iter().map(|item| (item.name, item)).collect();\n         AssocItems { items }\n     }\n \n@@ -149,7 +152,7 @@ impl<'tcx> AssocItems<'tcx> {\n     ) -> Option<&ty::AssocItem> {\n         self.filter_by_name_unhygienic(ident.name)\n             .filter(|item| item.kind == kind)\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+            .find(|item| tcx.hygienic_eq(ident, item.ident(tcx), parent_def_id))\n     }\n \n     /// Returns the associated item with the given name and any of `AssocKind`, if one exists.\n@@ -162,7 +165,7 @@ impl<'tcx> AssocItems<'tcx> {\n     ) -> Option<&ty::AssocItem> {\n         self.filter_by_name_unhygienic(ident.name)\n             .filter(|item| kinds.contains(&item.kind))\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+            .find(|item| tcx.hygienic_eq(ident, item.ident(tcx), parent_def_id))\n     }\n \n     /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n@@ -175,6 +178,6 @@ impl<'tcx> AssocItems<'tcx> {\n     ) -> Option<&ty::AssocItem> {\n         self.filter_by_name_unhygienic(ident.name)\n             .filter(|item| item.kind.namespace() == ns)\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+            .find(|item| tcx.hygienic_eq(ident, item.ident(tcx), parent_def_id))\n     }\n }"}, {"sha": "5c4a4cdde25131fda76b141c83dfcc99cc3dcf2e", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -972,10 +972,10 @@ fn foo(&self) -> Self::T { String::new() }\n             let (span, sugg) = if has_params {\n                 let pos = span.hi() - BytePos(1);\n                 let span = Span::new(pos, pos, span.ctxt(), span.parent());\n-                (span, format!(\", {} = {}\", assoc.ident, ty))\n+                (span, format!(\", {} = {}\", assoc.ident(self), ty))\n             } else {\n                 let item_args = self.format_generic_args(assoc_substs);\n-                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident, item_args, ty))\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(self), item_args, ty))\n             };\n             db.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n             return true;"}, {"sha": "00a1256d684e3bc6e798032d0e1bae237349a45e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -908,7 +908,7 @@ pub trait PrettyPrinter<'tcx>:\n                     if !first {\n                         p!(\", \");\n                     }\n-                    p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).ident));\n+                    p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).name));\n \n                     match term.skip_binder() {\n                         Term::Ty(ty) => {\n@@ -2455,7 +2455,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ExistentialProjection<'tcx> {\n-        let name = cx.tcx().associated_item(self.item_def_id).ident;\n+        let name = cx.tcx().associated_item(self.item_def_id).name;\n         p!(write(\"{} = \", name), print(self.term))\n     }\n "}, {"sha": "abc3aa356f0301b80f39b7ebdecbbb6fefece3e1", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -556,7 +556,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                         cx = cx.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n                     }\n                     ty::ExistentialPredicate::Projection(projection) => {\n-                        let name = cx.tcx.associated_item(projection.item_def_id).ident;\n+                        let name = cx.tcx.associated_item(projection.item_def_id).name;\n                         cx.push(\"p\");\n                         cx.push_ident(name.as_str());\n                         cx = match projection.term {"}, {"sha": "8552aa78a825aab81013547d5729a2fb14d693ab", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1353,14 +1353,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                                 .map(|id| (trait_assoc_item, id))\n                         })\n                         .and_then(|(trait_assoc_item, id)| {\n+                            let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n                             self.tcx.find_map_relevant_impl(\n                                 id,\n                                 proj.projection_ty.self_ty(),\n                                 |did| {\n                                     self.tcx\n                                         .associated_items(did)\n                                         .in_definition_order()\n-                                        .filter(|assoc| assoc.ident == trait_assoc_item.ident)\n+                                        .filter(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n                                         .next()\n                                 },\n                             )"}, {"sha": "6cd4bf6f3575e0ae60204a6c9ef28b42e584b290", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err.span_suggestion(\n                     span,\n                     \"use the fully qualified path to an implementation\",\n-                    format!(\"<Type as {}>::{}\", self.tcx.def_path_str(trait_ref), assoc_item.ident),\n+                    format!(\"<Type as {}>::{}\", self.tcx.def_path_str(trait_ref), assoc_item.name),\n                     Applicability::HasPlaceholders,\n                 );\n             }"}, {"sha": "7818053218decef33c5f9a848dc26cd8c9d884c6", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -89,7 +89,7 @@ fn object_safety_violations_for_trait(\n         .filter(|item| item.kind == ty::AssocKind::Fn)\n         .filter_map(|item| {\n             object_safety_violation_for_method(tcx, trait_def_id, &item)\n-                .map(|(code, span)| ObjectSafetyViolation::Method(item.ident.name, code, span))\n+                .map(|(code, span)| ObjectSafetyViolation::Method(item.name, code, span))\n         })\n         .filter(|violation| {\n             if let ObjectSafetyViolation::Method(\n@@ -125,15 +125,21 @@ fn object_safety_violations_for_trait(\n         tcx.associated_items(trait_def_id)\n             .in_definition_order()\n             .filter(|item| item.kind == ty::AssocKind::Const)\n-            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n+            .map(|item| {\n+                let ident = item.ident(tcx);\n+                ObjectSafetyViolation::AssocConst(ident.name, ident.span)\n+            }),\n     );\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n             .in_definition_order()\n             .filter(|item| item.kind == ty::AssocKind::Type)\n             .filter(|item| !tcx.generics_of(item.def_id).params.is_empty())\n-            .map(|item| ObjectSafetyViolation::GAT(item.ident.name, item.ident.span)),\n+            .map(|item| {\n+                let ident = item.ident(tcx);\n+                ObjectSafetyViolation::GAT(ident.name, ident.span)\n+            }),\n     );\n \n     debug!(\n@@ -367,15 +373,15 @@ fn object_safety_violation_for_method(\n             (MethodViolationCode::ReferencesSelfInput(arg), Some(node)) => node\n                 .fn_decl()\n                 .and_then(|decl| decl.inputs.get(arg + 1))\n-                .map_or(method.ident.span, |arg| arg.span),\n+                .map_or(method.ident(tcx).span, |arg| arg.span),\n             (MethodViolationCode::UndispatchableReceiver, Some(node)) => node\n                 .fn_decl()\n                 .and_then(|decl| decl.inputs.get(0))\n-                .map_or(method.ident.span, |arg| arg.span),\n+                .map_or(method.ident(tcx).span, |arg| arg.span),\n             (MethodViolationCode::ReferencesSelfOutput, Some(node)) => {\n-                node.fn_decl().map_or(method.ident.span, |decl| decl.output.span())\n+                node.fn_decl().map_or(method.ident(tcx).span, |decl| decl.output.span())\n             }\n-            _ => method.ident.span,\n+            _ => method.ident(tcx).span,\n         };\n         (v, span)\n     })\n@@ -404,10 +410,10 @@ fn virtual_call_violation_for_method<'tcx>(\n             );\n         // Get the span pointing at where the `self` receiver should be.\n         let sm = tcx.sess.source_map();\n-        let self_span = method.ident.span.to(tcx\n+        let self_span = method.ident(tcx).span.to(tcx\n             .hir()\n             .span_if_local(method.def_id)\n-            .unwrap_or_else(|| sm.next_point(method.ident.span))\n+            .unwrap_or_else(|| sm.next_point(method.ident(tcx).span))\n             .shrink_to_hi());\n         let self_span = sm.span_through_char(self_span, '(').shrink_to_hi();\n         return Some(MethodViolationCode::StaticMethod("}, {"sha": "e8b46e88a42285656c2b65850c1ba5ef05fdd3d2", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1600,7 +1600,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         gen_sig,\n     )\n     .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-        let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n+        let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n         let ty = if name == sym::Return {\n             return_ty\n         } else if name == sym::Yield {\n@@ -1842,7 +1842,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n         // just return Error.\n         debug!(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-            assoc_ty.item.ident, obligation.predicate\n+            assoc_ty.item.name, obligation.predicate\n         );\n         return Progress { ty: tcx.ty_error(), obligations: nested };\n     }"}, {"sha": "4142c999ca749a94cbe870b519c03f033893a909", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -100,7 +100,7 @@ fn associated_item_from_trait_item_ref(\n     };\n \n     ty::AssocItem {\n-        ident: trait_item_ref.ident,\n+        name: trait_item_ref.ident.name,\n         kind,\n         vis: tcx.visibility(def_id),\n         defaultness: trait_item_ref.defaultness,\n@@ -124,7 +124,7 @@ fn associated_item_from_impl_item_ref(\n     };\n \n     ty::AssocItem {\n-        ident: impl_item_ref.ident,\n+        name: impl_item_ref.ident.name,\n         kind,\n         vis: tcx.visibility(def_id),\n         defaultness: impl_item_ref.defaultness,"}, {"sha": "a49d6e24f2621d2772e54222b3bfb6c33d2c0a79", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -214,7 +214,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n             .flatten()\n             .filter_map(\n-                |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n+                |item| if item.kind == ty::AssocKind::Type { Some(item.name) } else { None },\n             )\n             .collect();\n \n@@ -270,7 +270,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let trait_def_id = assoc_item.container.id();\n                 names.push(format!(\n                     \"`{}` (from trait `{}`)\",\n-                    assoc_item.ident,\n+                    assoc_item.name,\n                     tcx.def_path_str(trait_def_id),\n                 ));\n             }\n@@ -327,19 +327,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let mut names: FxHashMap<_, usize> = FxHashMap::default();\n             for item in assoc_items {\n                 types_count += 1;\n-                *names.entry(item.ident.name).or_insert(0) += 1;\n+                *names.entry(item.name).or_insert(0) += 1;\n             }\n             let mut dupes = false;\n             for item in assoc_items {\n-                let prefix = if names[&item.ident.name] > 1 {\n+                let prefix = if names[&item.name] > 1 {\n                     let trait_def_id = item.container.id();\n                     dupes = true;\n                     format!(\"{}::\", tcx.def_path_str(trait_def_id))\n                 } else {\n                     String::new()\n                 };\n                 if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n-                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n+                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.name));\n                 }\n             }\n             if potential_assoc_types.len() == assoc_items.len() {\n@@ -350,14 +350,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Iterator<Item = isize>`.\n                 for (potential, item) in iter::zip(&potential_assoc_types, assoc_items) {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n-                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n+                        suggestions.push((*potential, format!(\"{} = {}\", item.name, snippet)));\n                     }\n                 }\n             } else if let (Ok(snippet), false) =\n                 (tcx.sess.source_map().span_to_snippet(*span), dupes)\n             {\n                 let types: Vec<_> =\n-                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n+                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.name)).collect();\n                 let code = if snippet.ends_with('>') {\n                     // The user wrote `Trait<'a>` or similar and we don't have a type we can\n                     // suggest, but at least we can clue them to the correct syntax\n@@ -388,17 +388,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let mut names: FxHashMap<_, usize> = FxHashMap::default();\n                 for item in assoc_items {\n                     types_count += 1;\n-                    *names.entry(item.ident.name).or_insert(0) += 1;\n+                    *names.entry(item.name).or_insert(0) += 1;\n                 }\n                 let mut label = vec![];\n                 for item in assoc_items {\n-                    let postfix = if names[&item.ident.name] > 1 {\n+                    let postfix = if names[&item.name] > 1 {\n                         let trait_def_id = item.container.id();\n                         format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n                     } else {\n                         String::new()\n                     };\n-                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n+                    label.push(format!(\"`{}`{}\", item.name, postfix));\n                 }\n                 if !label.is_empty() {\n                     err.span_label("}, {"sha": "6d4b2b5ba0037067257d87a61f4a973c65b500db", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1137,7 +1137,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .filter_by_name_unhygienic(assoc_ident.name)\n             .find(|i| {\n                 (i.kind == ty::AssocKind::Type || i.kind == ty::AssocKind::Const)\n-                    && i.ident.normalize_to_macros_2_0() == assoc_ident\n+                    && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n             })\n             .expect(\"missing associated type\");\n         // FIXME(associated_const_equality): need to handle assoc_consts here as well.\n@@ -1176,7 +1176,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Include substitutions for generic parameters of associated types\n         let projection_ty = candidate.map_bound(|trait_ref| {\n-            let ident = Ident::new(assoc_ty.ident.name, binding.item_name.span);\n+            let ident = Ident::new(assoc_ty.name, binding.item_name.span);\n             let item_segment = hir::PathSegment {\n                 ident,\n                 hir_id: Some(binding.hir_id),\n@@ -1868,7 +1868,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .in_definition_order()\n             .find(|i| {\n                 i.kind.namespace() == Namespace::TypeNS\n-                    && i.ident.normalize_to_macros_2_0() == assoc_ident\n+                    && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n             })\n             .expect(\"missing associated type\");\n "}, {"sha": "18a0a8767d45bf786d6ace91f4db58fd06d12465", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -999,7 +999,7 @@ fn check_impl_items_against_trait<'tcx>(\n \n                 if is_implemented_here {\n                     let trait_item = tcx.associated_item(trait_item_id);\n-                    if required_items.contains(&trait_item.ident) {\n+                    if required_items.contains(&trait_item.ident(tcx)) {\n                         must_implement_one_of = None;\n                     }\n                 }"}, {"sha": "74910234b7edcbe1215fbe6973a636acad8f00bc", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -300,7 +300,7 @@ fn compare_predicate_entailment<'tcx>(\n                 cause.span(tcx),\n                 E0053,\n                 \"method `{}` has an incompatible type for trait\",\n-                trait_m.ident\n+                trait_m.name\n             );\n             match &terr {\n                 TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n@@ -452,7 +452,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n         tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {\n             span,\n             item_kind,\n-            ident: impl_m.ident,\n+            ident: impl_m.ident(tcx),\n             generics_span,\n         });\n         return Err(ErrorReported);\n@@ -540,14 +540,14 @@ fn compare_self_type<'tcx>(\n                 impl_m_span,\n                 E0185,\n                 \"method `{}` has a `{}` declaration in the impl, but not in the trait\",\n-                trait_m.ident,\n+                trait_m.name,\n                 self_descr\n             );\n             err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"trait method declared without `{}`\", self_descr));\n             } else {\n-                err.note_trait_signature(trait_m.ident.to_string(), trait_m.signature(tcx));\n+                err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n             }\n             err.emit();\n             return Err(ErrorReported);\n@@ -560,14 +560,14 @@ fn compare_self_type<'tcx>(\n                 impl_m_span,\n                 E0186,\n                 \"method `{}` has a `{}` declaration in the trait, but not in the impl\",\n-                trait_m.ident,\n+                trait_m.name,\n                 self_descr\n             );\n             err.span_label(impl_m_span, format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n             } else {\n-                err.note_trait_signature(trait_m.ident.to_string(), trait_m.signature(tcx));\n+                err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n             }\n             err.emit();\n             return Err(ErrorReported);\n@@ -640,7 +640,7 @@ fn compare_number_of_generics<'tcx>(\n                     \"{} `{}` has {} {kind} parameter{} but its trait \\\n                      declaration has {} {kind} parameter{}\",\n                     item_kind,\n-                    trait_.ident,\n+                    trait_.name,\n                     impl_count,\n                     pluralize!(impl_count),\n                     trait_count,\n@@ -747,7 +747,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             impl_span,\n             E0050,\n             \"method `{}` has {} but the declaration in trait `{}` has {}\",\n-            trait_m.ident,\n+            trait_m.name,\n             potentially_plural_count(impl_number_args, \"parameter\"),\n             tcx.def_path_str(trait_m.def_id),\n             trait_number_args\n@@ -761,7 +761,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                 ),\n             );\n         } else {\n-            err.note_trait_signature(trait_m.ident.to_string(), trait_m.signature(tcx));\n+            err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n         }\n         err.span_label(\n             impl_span,\n@@ -811,7 +811,7 @@ fn compare_synthetic_generics<'tcx>(\n                 impl_span,\n                 E0643,\n                 \"method `{}` has incompatible signature for trait\",\n-                trait_m.ident\n+                trait_m.name\n             );\n             err.span_label(trait_span, \"declaration in trait here\");\n             match (impl_synthetic, trait_synthetic) {\n@@ -965,7 +965,7 @@ fn compare_const_param_types<'tcx>(\n                 *impl_span,\n                 E0053,\n                 \"method `{}` has an incompatible const parameter type for trait\",\n-                trait_m.ident\n+                trait_m.name\n             );\n             err.span_note(\n                 trait_span.map_or_else(|| trait_item_span.unwrap_or(*impl_span), |span| *span),\n@@ -1053,7 +1053,7 @@ crate fn compare_const_impl<'tcx>(\n                 cause.span,\n                 E0326,\n                 \"implemented const `{}` has an incompatible type for trait\",\n-                trait_c.ident\n+                trait_c.name\n             );\n \n             let trait_c_span = trait_c.def_id.as_local().map(|trait_c_def_id| {"}, {"sha": "e73ab1a313606bd7f83c82f13796d11438777678", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                     let mut suggestions = iter::zip(iter::repeat(&expr_text), &methods)\n                         .filter_map(|(receiver, method)| {\n-                            let method_call = format!(\".{}()\", method.ident);\n+                            let method_call = format!(\".{}()\", method.name);\n                             if receiver.ends_with(&method_call) {\n                                 None // do not suggest code that is already there (#53348)\n                             } else {"}, {"sha": "9efaa37633e3e4652d9f4b3d8cbfcea8fcd54d7e", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1033,7 +1033,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     true\n                 }\n             })\n-            .map(|candidate| candidate.item.ident)\n+            .map(|candidate| candidate.item.ident(self.tcx))\n             .filter(|&name| set.insert(name))\n             .collect();\n \n@@ -1438,7 +1438,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                 \"<{} as {}>::{}\",\n                                 stable_pick.self_ty,\n                                 self.tcx.def_path_str(def_id),\n-                                stable_pick.item.ident\n+                                stable_pick.item.name\n                             ),\n                             Applicability::MachineApplicable,\n                         );\n@@ -1748,14 +1748,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let best_name = {\n                     let names = applicable_close_candidates\n                         .iter()\n-                        .map(|cand| cand.ident.name)\n+                        .map(|cand| cand.name)\n                         .collect::<Vec<Symbol>>();\n                     find_best_match_for_name(&names, self.method_name.unwrap().name, None)\n                 }\n                 .unwrap();\n-                Ok(applicable_close_candidates\n-                    .into_iter()\n-                    .find(|method| method.ident.name == best_name))\n+                Ok(applicable_close_candidates.into_iter().find(|method| method.name == best_name))\n             }\n         })\n     }\n@@ -1906,7 +1904,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .associated_items(def_id)\n                     .in_definition_order()\n                     .filter(|x| {\n-                        let dist = lev_distance(name.as_str(), x.ident.as_str());\n+                        let dist = lev_distance(name.as_str(), x.name.as_str());\n                         x.kind.namespace() == Namespace::ValueNS && dist > 0 && dist <= max_dist\n                     })\n                     .copied()"}, {"sha": "cb1f45ee1da717290f71e1bbcc029fe553a34655", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -1025,7 +1025,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 def_kind.article(),\n                                 def_kind.descr(lev_candidate.def_id),\n                             ),\n-                            lev_candidate.ident.to_string(),\n+                            lev_candidate.name.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n@@ -1480,7 +1480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let skip = skippable.contains(&did);\n                     if pick.autoderefs == 0 && !skip {\n                         err.span_label(\n-                            pick.item.ident.span,\n+                            pick.item.ident(self.tcx).span,\n                             &format!(\"the method is available for `{}` here\", rcvr_ty),\n                         );\n                     }\n@@ -1514,7 +1514,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // an autoderef to `&self`\n                             if pick.autoderefs == 0 && !skip {\n                                 err.span_label(\n-                                    pick.item.ident.span,\n+                                    pick.item.ident(self.tcx).span,\n                                     &format!(\"the method is available for `{}` here\", new_rcvr_t),\n                                 );\n                                 err.multipart_suggestion("}, {"sha": "6e0b902a00bda1014c19a4f0771d17fee2a9e0a2", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -599,7 +599,7 @@ fn missing_items_err(\n ) {\n     let missing_items_msg = missing_items\n         .iter()\n-        .map(|trait_item| trait_item.ident.to_string())\n+        .map(|trait_item| trait_item.name.to_string())\n         .collect::<Vec<_>>()\n         .join(\"`, `\");\n \n@@ -628,7 +628,7 @@ fn missing_items_err(\n         let msg = format!(\"implement the missing item: `{}`\", snippet);\n         let appl = Applicability::HasPlaceholders;\n         if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n-            err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n+            err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n             err.tool_only_span_suggestion(sugg_sp, &msg, code, appl);\n         } else {\n             err.span_suggestion_hidden(sugg_sp, &msg, code, appl);\n@@ -805,16 +805,16 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n             fn_sig_suggestion(\n                 tcx,\n                 tcx.fn_sig(assoc.def_id).skip_binder(),\n-                assoc.ident,\n+                assoc.ident(tcx),\n                 tcx.predicates_of(assoc.def_id),\n                 assoc,\n             )\n         }\n-        ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),\n+        ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.name),\n         ty::AssocKind::Const => {\n             let ty = tcx.type_of(assoc.def_id);\n             let val = expr::ty_kind_suggestion(ty).unwrap_or(\"value\");\n-            format!(\"const {}: {} = {};\", assoc.ident, ty, val)\n+            format!(\"const {}: {} = {};\", assoc.name, ty, val)\n         }\n     }\n }"}, {"sha": "95a928e007b8ce6ad413946e82d6b5085ba8d84b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -851,7 +851,7 @@ fn check_associated_item(\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n                     fcx,\n-                    item.ident.span,\n+                    item.ident(fcx.tcx).span,\n                     sig,\n                     hir_sig.decl,\n                     item.def_id,"}, {"sha": "a409201372b3573741c6ee46af091ef71c37f5e8", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n \n         for item1 in impl_items1.in_definition_order() {\n             let collision = impl_items2\n-                .filter_by_name_unhygienic(item1.ident.name)\n+                .filter_by_name_unhygienic(item1.name)\n                 .any(|item2| self.compare_hygienically(item1, item2));\n \n             if collision {\n@@ -50,7 +50,8 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n     fn compare_hygienically(&self, item1: &ty::AssocItem, item2: &ty::AssocItem) -> bool {\n         // Symbols and namespace match, compare hygienically.\n         item1.kind.namespace() == item2.kind.namespace()\n-            && item1.ident.normalize_to_macros_2_0() == item2.ident.normalize_to_macros_2_0()\n+            && item1.ident(self.tcx).normalize_to_macros_2_0()\n+                == item2.ident(self.tcx).normalize_to_macros_2_0()\n     }\n \n     fn check_for_common_items_in_impls(\n@@ -64,11 +65,11 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n \n         for item1 in impl_items1.in_definition_order() {\n             let collision = impl_items2\n-                .filter_by_name_unhygienic(item1.ident.name)\n+                .filter_by_name_unhygienic(item1.name)\n                 .find(|item2| self.compare_hygienically(item1, item2));\n \n             if let Some(item2) = collision {\n-                let name = item1.ident.normalize_to_macros_2_0();\n+                let name = item1.ident(self.tcx).normalize_to_macros_2_0();\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     self.tcx.span_of_impl(item1.def_id).unwrap(),\n@@ -181,11 +182,11 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentOverlapChecker<'tcx> {\n                         let mut ids = impl_items\n                             .in_definition_order()\n                             .filter_map(|item| {\n-                                let entry = connected_region_ids.entry(item.ident.name);\n+                                let entry = connected_region_ids.entry(item.name);\n                                 if let Entry::Occupied(e) = &entry {\n                                     Some(*e.get())\n                                 } else {\n-                                    idents_to_add.push(item.ident.name);\n+                                    idents_to_add.push(item.name);\n                                     None\n                                 }\n                             })"}, {"sha": "33612c80654776a2f515566795fb4c608de17495", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -387,7 +387,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n         let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n         let self_type = self.self_ty().clean(cx);\n         Type::QPath {\n-            name: cx.tcx.associated_item(self.item_def_id).ident.name,\n+            name: cx.tcx.associated_item(self.item_def_id).name,\n             self_def_id: self_type.def_id(&cx.cache),\n             self_type: box self_type,\n             trait_,\n@@ -1131,7 +1131,7 @@ impl Clean<Item> for ty::AssocItem {\n                 }\n             }\n             ty::AssocKind::Type => {\n-                let my_name = self.ident.name;\n+                let my_name = self.name;\n \n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = tcx.explicit_item_bounds(self.def_id);\n@@ -1197,7 +1197,7 @@ impl Clean<Item> for ty::AssocItem {\n             }\n         };\n \n-        Item::from_def_id_and_parts(self.def_id, Some(self.ident.name), kind, cx)\n+        Item::from_def_id_and_parts(self.def_id, Some(self.name), kind, cx)\n     }\n }\n \n@@ -1521,7 +1521,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut bindings = vec![];\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n-                        name: cx.tcx.associated_item(pb.item_def_id()).ident.name,\n+                        name: cx.tcx.associated_item(pb.item_def_id()).name,\n                         kind: TypeBindingKind::Equality {\n                             term: pb.skip_binder().term.clean(cx).into(),\n                         },\n@@ -1592,7 +1592,6 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                             name: cx\n                                                 .tcx\n                                                 .associated_item(proj.projection_ty.item_def_id)\n-                                                .ident\n                                                 .name,\n                                             kind: TypeBindingKind::Equality {\n                                                 term: proj.term.clean(cx),"}, {"sha": "b26edec34936980653d95b88b53f156061c91baa", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -2222,7 +2222,7 @@ impl Impl {\n         self.trait_\n             .as_ref()\n             .map(|t| t.def_id())\n-            .map(|did| tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n+            .map(|did| tcx.provided_trait_methods(did).map(|meth| meth.name).collect())\n             .unwrap_or_default()\n     }\n }"}, {"sha": "bf1da760db70d9237d1d0ebefdf07a1d69f1e14f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|imp| tcx.associated_items(*imp).in_definition_order())\n-                    .any(|item| item.ident.name == variant_name)\n+                    .any(|item| item.name == variant_name)\n                 {\n                     // This is just to let `fold_item` know that this shouldn't be considered;\n                     // it's a bug for the error to make it to the user"}, {"sha": "22b458969551272c8083bf6cf97559055947c65c", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8941d3e48715000620142c2e2495eae8e38921e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8941d3e48715000620142c2e2495eae8e38921e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=c8941d3e48715000620142c2e2495eae8e38921e", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n                                         .filter(|assoc_item| {\n                                             matches!(assoc_item.kind, AssocKind::Fn)\n                                         })\n-                                        .map(|assoc_item| assoc_item.ident.name)\n+                                        .map(|assoc_item| assoc_item.name)\n                                         .collect()\n                                 }else{\n                                     BTreeSet::new()"}]}