{"sha": "30403802068b920eb3b3f6ffbc1e89068de43292", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNDAzODAyMDY4YjkyMGViM2IzZjZmZmJjMWU4OTA2OGRlNDMyOTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T19:50:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T19:50:16Z"}, "message": "rewrite pin module intro", "tree": {"sha": "c8a4f0ff50489cd2063027670d7bff975f52f3dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8a4f0ff50489cd2063027670d7bff975f52f3dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30403802068b920eb3b3f6ffbc1e89068de43292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30403802068b920eb3b3f6ffbc1e89068de43292", "html_url": "https://github.com/rust-lang/rust/commit/30403802068b920eb3b3f6ffbc1e89068de43292", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30403802068b920eb3b3f6ffbc1e89068de43292/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba99f62d1f76a82d208a9e0dab1357b626fb2bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba99f62d1f76a82d208a9e0dab1357b626fb2bc", "html_url": "https://github.com/rust-lang/rust/commit/0ba99f62d1f76a82d208a9e0dab1357b626fb2bc"}], "stats": {"total": 51, "additions": 27, "deletions": 24}, "files": [{"sha": "455517c929473ad9bdb4c73ea2b767776f38bd2f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30403802068b920eb3b3f6ffbc1e89068de43292/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30403802068b920eb3b3f6ffbc1e89068de43292/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=30403802068b920eb3b3f6ffbc1e89068de43292", "patch": "@@ -610,7 +610,8 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// which then allows it to move out with functions such as [`mem::replace`].\n ///\n /// `Unpin` has no consequence at all for non-pinned data. In particular,\n-/// [`mem::replace`] happily moves `!Unpin` data. However, you cannot use\n+/// [`mem::replace`] happily moves `!Unpin` data (it works for any `&mut T`, not\n+/// just when `T: Unpin`). However, you cannot use\n /// [`mem::replace`] on data wrapped inside a [`Pin`] because you cannot get the\n /// `&mut T` you need for that, and *that* is what makes this system work.\n ///"}, {"sha": "2d674fe4f791ec8d80c405cc5d7ab80a6ac5b318", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30403802068b920eb3b3f6ffbc1e89068de43292/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30403802068b920eb3b3f6ffbc1e89068de43292/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=30403802068b920eb3b3f6ffbc1e89068de43292", "patch": "@@ -2,33 +2,35 @@\n //!\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon.\n-//!\n //! A prime example of such a scenario would be building self-referential structs,\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n+//! [`Pin`] ensures that the pointee of any pointer type has a stable location in memory,\n+//! meaning it cannot be moved elsewhere and its memory cannot be deallocated\n+//! until it gets dropped. We say that the pointee is \"pinned\".\n+//!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as `Box`, `Rc`, and `&mut` allow replacing and\n-//! moving the values they contain. In order to prevent objects from moving, they must\n-//! be pinned by wrapping a pointer to the data in the [`Pin`] type.\n-//! Doing this prohibits moving the value behind the pointer.\n-//! For example, `Pin<Box<T>>` functions much like a regular `Box<T>`,\n-//! but doesn't allow moving `T`. The pointer value itself (the `Box`) can still be moved,\n-//! but the value behind it cannot.\n-//!\n-//! Since data can be moved out of `&mut` and `Box` with functions such as [`mem::swap`],\n-//! changing the location of the underlying data, [`Pin`] prohibits accessing the\n-//! underlying pointer type (the `&mut` or `Box`) directly, and provides its own set of\n-//! APIs for accessing and using the value. [`Pin`] also guarantees that no other\n-//! functions will move the pointed-to value. This allows for the creation of\n-//! self-references and other special behaviors that are only possible for unmovable\n-//! values.\n+//! and common smart-pointer types such as `Box` and `&mut` allow replacing and\n+//! moving the values they contain: you can move out of a `Box`, or you can use [`mem::swap`].\n+//! [`Pin`] wraps a pointer type, so `Pin<Box<T>>` functions much like a regular `Box<T>`\n+//! (when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated).\n+//! Similarily, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin`] does not let clients actually\n+//! obtain a `Box` or reference to pinned data, which implies that you cannot use\n+//! operations such as [`mem::swap`]:\n+//! ```\n+//! fn swap_pins<T>(x: Pin<&mut T>, y: Pin<&mut T>) {\n+//!     // `mem::swap` needs `&mut T`, but we cannot get it.\n+//!     // We are stuck, we cannot swap the contents of these references.\n+//!     // We could use `Pin::get_unchecked_mut`, but that is unsafe for a reason:\n+//!     // we are not allowed to use it for moving things out of the `Pin`.\n+//! }\n+//! ```\n //!\n //! It is worth reiterating that [`Pin`] does *not* change the fact that a Rust compiler\n //! considers all types movable.  [`mem::swap`] remains callable for any `T`. Instead, `Pin`\n //! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n-//! moved by making it impossible to call methods like [`mem::swap`] on them. These\n-//! methods all need an `&mut T`, and you cannot obtain that from a `Pin`.\n+//! moved by making it impossible to call methods like [`mem::swap`] on them.\n //!\n //! # `Unpin`\n //!\n@@ -43,7 +45,7 @@\n //! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n //! pointed-to type).\n //!\n-//! # Example: Self-referential struct\n+//! # Example: self-referential struct\n //!\n //! ```rust\n //! use std::pin::Pin;\n@@ -119,7 +121,7 @@\n //! To make this work, not just moving the data is restricted; deallocating, repurposing or\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n-//! that *its memory will not get invalidated from the momentit gets pinned until\n+//! that *its memory will not get invalidated from the moment it gets pinned until\n //! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n //! replacing a `Some(v)` by `None`, or calling `Vec::set_len` to \"kill\" some elements\n //! off of a vector.\n@@ -318,13 +320,13 @@ impl<P: Deref> Pin<P> {\n     /// # Safety\n     ///\n     /// This constructor is unsafe because we cannot guarantee that the data\n-    /// pointed to by `pointer` is pinned forever. If the constructed `Pin<P>` does\n+    /// pointed to by `pointer` is pinned, meaning that the data will not be moved or\n+    /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does\n     /// not guarantee that the data `P` points to is pinned, constructing a\n     /// `Pin<P>` is unsafe. In particular, calling `Pin::new_unchecked`\n     /// on an `&'a mut T` is unsafe because while you are able to pin it for the given\n     /// lifetime `'a`, you have no control over whether it is kept pinned once `'a`\n-    /// ends. A value, once pinned, must remain pinned forever\n-    /// (unless its type implements `Unpin`).\n+    /// ends. A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n     ///\n     /// By using this method, you are making a promise about the `P::Deref` and\n     /// `P::DerefMut` implementations, if they exist. Most importantly, they"}]}