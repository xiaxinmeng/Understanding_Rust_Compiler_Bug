{"sha": "1e51196f3356ebcc854522a240921d33d95886b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNTExOTZmMzM1NmViY2M4NTQ1MjJhMjQwOTIxZDMzZDk1ODg2YjM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-19T22:42:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-19T22:52:50Z"}, "message": "Get fixed-size evecs working.", "tree": {"sha": "9a3dea8b8af12c146c381f9f66afff55b625a310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a3dea8b8af12c146c381f9f66afff55b625a310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e51196f3356ebcc854522a240921d33d95886b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e51196f3356ebcc854522a240921d33d95886b3", "html_url": "https://github.com/rust-lang/rust/commit/1e51196f3356ebcc854522a240921d33d95886b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e51196f3356ebcc854522a240921d33d95886b3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ba0dce013b8c61dce46ba7cdbce4648c3e51259", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ba0dce013b8c61dce46ba7cdbce4648c3e51259", "html_url": "https://github.com/rust-lang/rust/commit/7ba0dce013b8c61dce46ba7cdbce4648c3e51259"}], "stats": {"total": 183, "additions": 127, "deletions": 56}, "files": [{"sha": "116803b2fbf52e6177a5e24c1f054ed7e57f7ef1", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1e51196f3356ebcc854522a240921d33d95886b3/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e51196f3356ebcc854522a240921d33d95886b3/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1e51196f3356ebcc854522a240921d33d95886b3", "patch": "@@ -259,6 +259,12 @@ fn alloca(cx: block, t: TypeRef) -> ValueRef {\n     ret Alloca(raw_block(cx.fcx, cx.fcx.llstaticallocas), t);\n }\n \n+fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n+    let _icx = cx.insn_ctxt(\"arrayalloca\");\n+    if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n+    ret ArrayAlloca(raw_block(cx.fcx, cx.fcx.llstaticallocas), t, v);\n+}\n+\n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n@@ -584,7 +590,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       }\n       ty::ty_vec(_) | ty::ty_str |\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) {\n-        let {bcx, val} = tvec::duplicate(bcx, Load(bcx, v), t);\n+        let {bcx, val} = tvec::duplicate_uniq(bcx, Load(bcx, v), t);\n         Store(bcx, val, v);\n         bcx\n       }\n@@ -928,7 +934,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_estr(ty::vstore_fixed(n)) |\n       ty::ty_evec(_, ty::vstore_fixed(n)) {\n-        cx = tvec::iter_vec_raw(cx, av, t, C_uint(cx.ccx(), n), f);\n+        let (base, len) = tvec::get_base_and_len(cx, av, t);\n+        cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n       ty::ty_tup(args) {\n         for vec::eachi(args) {|i, arg|\n@@ -1170,7 +1177,7 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n       ty::ty_str | ty::ty_vec(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) {\n-        tvec::duplicate(bcx, v, t)\n+        tvec::duplicate_uniq(bcx, v, t)\n       }\n       _ { rslt(bcx, v) }\n     }\n@@ -3121,7 +3128,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n       ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n       ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n-      ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n+      ast::expr_vec(args, _) {\n+        ret tvec::trans_evec(bcx, args, ast::vstore_uniq, e.id, dest);\n+      }\n       ast::expr_binary(op, lhs, rhs) {\n         ret trans_binary(bcx, op, lhs, rhs, dest, e);\n       }"}, {"sha": "89d6886dd05f2a38363563a032d944b0997a87b0", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e51196f3356ebcc854522a240921d33d95886b3/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e51196f3356ebcc854522a240921d33d95886b3/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=1e51196f3356ebcc854522a240921d33d95886b3", "patch": "@@ -367,6 +367,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         while i < n {\n             sub += shape_of(ccx, u8_t, ty_param_map);\n+            i += 1u;\n         }\n         add_substr(s, sub);\n         s\n@@ -377,6 +378,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let mut i = 0u;\n         while i < n {\n             sub += shape_of(ccx, mt.ty, ty_param_map);\n+            i += 1u;\n         }\n         add_substr(s, sub);\n         s"}, {"sha": "0b3b005503c2a524cdacab8e7d87a9fc1017fca9", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 96, "deletions": 52, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/1e51196f3356ebcc854522a240921d33d95886b3/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e51196f3356ebcc854522a240921d33d95886b3/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=1e51196f3356ebcc854522a240921d33d95886b3", "patch": "@@ -35,8 +35,8 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_raw\");\n+fn alloc_uniq_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq_raw\");\n     let ccx = bcx.ccx();\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n@@ -46,34 +46,23 @@ fn alloc_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n     ret {bcx: bcx, val: vecptr};\n }\n \n-type alloc_result =\n-    {bcx: block,\n-     val: ValueRef,\n-     unit_ty: ty::t,\n-     llunitty: TypeRef};\n-\n-fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc\");\n+fn alloc_uniq(bcx: block, llunitty: TypeRef, elts: uint) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n     let llvecty = T_vec(ccx, llunitty);\n     let unit_sz = llsize_of(ccx, llunitty);\n \n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n-    let {bcx: bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n+    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, fill, alloc);\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n \n-    ret {bcx: bcx,\n-         val: vptr,\n-         unit_ty: unit_ty,\n-         llunitty: llunitty};\n+    ret {bcx: bcx, val: vptr};\n }\n \n-fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(\"tvec::duplicate\");\n+fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n     let ccx = bcx.ccx();\n     let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n@@ -98,9 +87,9 @@ fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n     }\n }\n \n-fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n-             dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::trans_vec\");\n+fn trans_evec(bcx: block, args: [@ast::expr],\n+              vst: ast::vstore, id: ast::node_id, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_evec\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if dest == base::ignore {\n@@ -109,25 +98,69 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n         }\n         ret bcx;\n     }\n+\n     let vec_ty = node_id_type(bcx, id);\n-    let mut {bcx: bcx,\n-             val: vptr,\n-             unit_ty: unit_ty,\n-             llunitty: llunitty} = alloc(bcx, vec_ty, args.len());\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+\n+    let mut {bcx, val, dataptr} =\n+        alt vst {\n+          ast::vstore_fixed(_) {\n+            // Destination should be pre-allocated for us.\n+            let v = alt dest {\n+              base::save_in(v) {\n+                PointerCast(bcx, v, T_ptr(llunitty))\n+              }\n+              _ {\n+                bcx.ccx().sess.bug(\"bad dest for vstore_fixed \\\n+                                    in tvec::trans_evec\");\n+              }\n+            };\n+            {bcx: bcx, val: v, dataptr: v}\n+          }\n+          ast::vstore_slice(_) {\n+            let n = vec::len(args);\n+            let n = C_uint(ccx, n);\n+            let vp = base::arrayalloca(bcx, llunitty, n);\n+            let v = C_struct([vp, n]);\n+            {bcx: bcx, val: v, dataptr: vp}\n+          }\n+          ast::vstore_uniq {\n+            let {bcx, val} = alloc_uniq(bcx, llunitty, args.len());\n+            add_clean_free(bcx, val, true);\n+            let dataptr = get_dataptr(bcx, val, llunitty);\n+            {bcx: bcx, val: val, dataptr: dataptr}\n+          }\n+          ast::vstore_box {\n+            bcx.ccx().sess.unimpl(\"unhandled tvec::trans_evec\");\n+          }\n+        };\n+\n \n-    add_clean_free(bcx, vptr, true);\n     // Store the individual elements.\n-    let dataptr = get_dataptr(bcx, vptr, llunitty);\n-    let mut i = 0u, temp_cleanups = [vptr];\n+    let mut i = 0u, temp_cleanups = [val];\n+    #debug(\"trans_evec: v: %s, dataptr: %s\",\n+           val_str(ccx.tn, val),\n+           val_str(ccx.tn, dataptr));\n     for vec::each(args) {|e|\n         let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n+\n     for vec::each(temp_cleanups) {|cln| revoke_clean(bcx, cln); }\n-    ret base::store_in_dest(bcx, vptr, dest);\n+\n+    alt vst {\n+      ast::vstore_fixed(_) {\n+        // We wrote into the destination in the fixed case.\n+        ret bcx;\n+      }\n+      _ {\n+        ret base::store_in_dest(bcx, val, dest);\n+      }\n+    }\n }\n \n fn trans_vstore(bcx: block, e: @ast::expr,\n@@ -137,7 +170,7 @@ fn trans_vstore(bcx: block, e: @ast::expr,\n         ret trans_estr(bcx, s, v, dest);\n       }\n       ast::expr_vec(es, mutbl) {\n-        bcx.ccx().sess.span_unimpl(e.span, \"unhandled tvec::trans_vstore\");\n+        ret trans_evec(bcx, es, v, e.id, dest);\n       }\n       _ {\n         bcx.sess().span_bug(e.span, \"vstore on non-sequence type\");\n@@ -148,9 +181,13 @@ fn trans_vstore(bcx: block, e: @ast::expr,\n fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n     -> (ValueRef, ValueRef) {\n \n-    let tcx = cx.ccx().tcx;\n+    let ccx = cx.ccx();\n+    let tcx = ccx.tcx;\n     let vec_ty = ty::type_autoderef(tcx, e_ty);\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let unit_sz = llsize_of(ccx, llunitty);\n+\n     let vstore = alt ty::get(vec_ty).struct {\n       ty::ty_estr(vst) | ty::ty_evec(_, vst) { vst }\n       _ { ty::vstore_uniq }\n@@ -159,7 +196,8 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n     alt vstore {\n       ty::vstore_fixed(n) {\n         let base = GEPi(cx, v, [0, 0]);\n-        let len = C_uint(cx.ccx(), n + 1u /* +1 for null */);\n+        let n = if ty::type_is_str(e_ty) { n + 1u } else { n };\n+        let len = Mul(cx, C_uint(ccx, n), unit_sz);\n         (base, len)\n       }\n       ty::vstore_slice(_) {\n@@ -168,8 +206,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq {\n-        let base = tvec::get_dataptr(cx, v,\n-                                     type_of::type_of(cx.ccx(), unit_ty));\n+        let base = tvec::get_dataptr(cx, v, llunitty);\n         let len = tvec::get_fill(cx, v);\n         (base, len)\n       }\n@@ -222,11 +259,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     // Cast to opaque interior vector types if necessary.\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(ccx.tcx, vec_ty);\n-    let strings = alt check ty::get(vec_ty).struct {\n-      ty::ty_str { true }\n-      ty::ty_vec(_) { false }\n-    };\n-\n+    let strings = ty::type_is_str(vec_ty);\n     let llunitty = type_of::type_of(ccx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n@@ -248,7 +281,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n-    iter_vec_raw(bcx, rhs, vec_ty, rfill, {|bcx, addr, _ty|\n+    iter_vec_uniq(bcx, rhs, vec_ty, rfill, {|bcx, addr, _ty|\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n@@ -304,7 +337,8 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n     let lhs_fill = get_fill(bcx, lhs);\n     let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n-    let mut {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n+    let mut {bcx: bcx, val: new_vec_ptr} =\n+        alloc_uniq_raw(bcx, new_fill, new_fill);\n     new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(ccx, llunitty)));\n \n     let write_ptr_ptr = do_spill_noroot\n@@ -320,23 +354,20 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n         ret bcx;\n     };\n \n-    let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n-    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n+    let bcx = iter_vec_uniq(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n+    let bcx = iter_vec_uniq(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n     ret base::store_in_dest(bcx, new_vec_ptr, dest);\n }\n \n type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> result;\n \n type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n-fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n+fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n-    let ccx = bcx.ccx();\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n+\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n-    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n     // FIXME: Optimize this when the size of the unit type is statically\n@@ -354,16 +385,29 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     let body_cx = f(body_cx, data_ptr, unit_ty);\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr,\n-                                           [C_int(ccx, 1)]), body_cx.llbb);\n+                                           [C_int(bcx.ccx(), 1)]),\n+                     body_cx.llbb);\n     Br(body_cx, header_cx.llbb);\n     ret next_cx;\n+\n+}\n+\n+fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n+                 fill: ValueRef, f: iter_vec_block) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n+    let ccx = bcx.ccx();\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n+    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n+    iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n     let vptr = PointerCast(bcx, vptr, T_ptr(bcx.ccx().opaque_vec_type));\n-    ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n+    ret iter_vec_uniq(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n \n //"}, {"sha": "ce0fe172cf806445517f653c8f2ee53b996f168e", "filename": "src/test/run-pass/evec-internal-boxes.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e51196f3356ebcc854522a240921d33d95886b3/src%2Ftest%2Frun-pass%2Fevec-internal-boxes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e51196f3356ebcc854522a240921d33d95886b3/src%2Ftest%2Frun-pass%2Fevec-internal-boxes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-internal-boxes.rs?ref=1e51196f3356ebcc854522a240921d33d95886b3", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let x : [@int]/5 = [@1,@2,@3,@4,@5]/5;\n+    let _y : [@int]/5 = [@1,@2,@3,@4,@5]/_;\n+    let mut z = [@1,@2,@3,@4,@5]/_;\n+    z = x;\n+    assert *z[0] == 1;\n+    assert *z[4] == 5;\n+}"}, {"sha": "d402a7b8bb8e524bea35d1f588aa05542b841c57", "filename": "src/test/run-pass/evec-internal.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e51196f3356ebcc854522a240921d33d95886b3/src%2Ftest%2Frun-pass%2Fevec-internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e51196f3356ebcc854522a240921d33d95886b3/src%2Ftest%2Frun-pass%2Fevec-internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-internal.rs?ref=1e51196f3356ebcc854522a240921d33d95886b3", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let x : [int]/5 = [1,2,3,4,5]/5;\n+    let _y : [int]/5 = [1,2,3,4,5]/_;\n+    let mut z = [1,2,3,4,5]/_;\n+    z = x;\n+    assert z[0] == 1;\n+    assert z[4] == 5;\n+}"}]}