{"sha": "f23559451b0dc5181d73ddd89657266d4e150b6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMzU1OTQ1MWIwZGM1MTgxZDczZGRkODk2NTcyNjZkNGUxNTBiNmE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-01T00:13:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-01T00:13:35Z"}, "message": "Rollup merge of #77303 - lcnr:const-evaluatable-TooGeneric, r=oli-obk,varkor\n\nconst evaluatable: improve `TooGeneric` handling\n\nInstead of emitting an error in `fulfill`, we now correctly stall on inference variables.\n\nAs `const_eval_resolve` returns `ErrorHandled::TooGeneric` when encountering generic parameters on which\nwe actually do want to error, we check for inference variables and eagerly emit an error if they don't exist, returning `ErrorHandled::Reported` instead.\n\nAlso contains a small bugfix for `ConstEquate` where we previously only stalled on type variables. This is probably a leftover from\nwhen we did not yet support stalling on const inference variables.\n\nr? @oli-obk cc @varkor @eddyb", "tree": {"sha": "ee99fc43a28f46596e37598db6eaf40f82099ed2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee99fc43a28f46596e37598db6eaf40f82099ed2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23559451b0dc5181d73ddd89657266d4e150b6a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdR8wCRBK7hj4Ov3rIwAAdHIIAKB1v2wzk2dNq+bHkecidTG5\njekiESRpcw/Y4eksj0qhRRsHNlPMkGfcZK8QoxBC0UO/A6xu94wng10EZzCoMKTG\nPVzR8eK9pHhfE1o0REvVVm1zwqHJj+X1Mu5F6cvDr9u1kyyPLy0qvgDwkp6NdC1N\nRTTJjmc1AncJEmYIGmsRjww6z3iydIQ81KS5UT6eRIUS/LKMVyp7J+9ifHOBNHoc\nEJW1RBZp7mE16bmYEcCZUKmXS0qwhud0vmDSyD6RijaAuYxIf2pu2g7u/nwCT9gb\nn+UUBxwiDUfhzPaE/OhPB3QImn1s21Uiyd3z0mXyy0eEqFQZOLxF0Bc6x2RpdcU=\n=c2fB\n-----END PGP SIGNATURE-----\n", "payload": "tree ee99fc43a28f46596e37598db6eaf40f82099ed2\nparent 37df40bd1c9374ca91112f2d1ea0e27127130c09\nparent a4783debe021c6d13ce3cf5167efe98c5baeaa26\nauthor Dylan DPC <dylan.dpc@gmail.com> 1601511215 +0200\ncommitter GitHub <noreply@github.com> 1601511215 +0200\n\nRollup merge of #77303 - lcnr:const-evaluatable-TooGeneric, r=oli-obk,varkor\n\nconst evaluatable: improve `TooGeneric` handling\n\nInstead of emitting an error in `fulfill`, we now correctly stall on inference variables.\n\nAs `const_eval_resolve` returns `ErrorHandled::TooGeneric` when encountering generic parameters on which\nwe actually do want to error, we check for inference variables and eagerly emit an error if they don't exist, returning `ErrorHandled::Reported` instead.\n\nAlso contains a small bugfix for `ConstEquate` where we previously only stalled on type variables. This is probably a leftover from\nwhen we did not yet support stalling on const inference variables.\n\nr? @oli-obk cc @varkor @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23559451b0dc5181d73ddd89657266d4e150b6a", "html_url": "https://github.com/rust-lang/rust/commit/f23559451b0dc5181d73ddd89657266d4e150b6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23559451b0dc5181d73ddd89657266d4e150b6a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37df40bd1c9374ca91112f2d1ea0e27127130c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/37df40bd1c9374ca91112f2d1ea0e27127130c09", "html_url": "https://github.com/rust-lang/rust/commit/37df40bd1c9374ca91112f2d1ea0e27127130c09"}, {"sha": "a4783debe021c6d13ce3cf5167efe98c5baeaa26", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4783debe021c6d13ce3cf5167efe98c5baeaa26", "html_url": "https://github.com/rust-lang/rust/commit/a4783debe021c6d13ce3cf5167efe98c5baeaa26"}], "stats": {"total": 274, "additions": 199, "deletions": 75}, "files": [{"sha": "3828cf4d30210b89e35a471883b0768a59ea937a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 138, "deletions": 15, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -23,6 +23,9 @@ use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n+use std::cmp;\n+\n+/// Check if a given constant can be evaluated.\n pub fn is_const_evaluatable<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def: ty::WithOptConstParam<DefId>,\n@@ -32,23 +35,87 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs)? {\n-            for pred in param_env.caller_bounds() {\n-                match pred.skip_binders() {\n-                    ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n-                        debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n-                        if b_def == def && b_substs == substs {\n-                            debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n-                            return Ok(());\n-                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)?\n-                            .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n-                        {\n-                            debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n-                            return Ok(());\n+        let tcx = infcx.tcx;\n+        match AbstractConst::new(tcx, def, substs)? {\n+            // We are looking at a generic abstract constant.\n+            Some(ct) => {\n+                for pred in param_env.caller_bounds() {\n+                    match pred.skip_binders() {\n+                        ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n+                            debug!(\n+                                \"is_const_evaluatable: caller_bound={:?}, {:?}\",\n+                                b_def, b_substs\n+                            );\n+                            if b_def == def && b_substs == substs {\n+                                debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n+                                return Ok(());\n+                            } else if AbstractConst::new(tcx, b_def, b_substs)?\n+                                .map_or(false, |b_ct| try_unify(tcx, ct, b_ct))\n+                            {\n+                                debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                                return Ok(());\n+                            }\n                         }\n+                        _ => {} // don't care\n                     }\n-                    _ => {} // don't care\n                 }\n+\n+                // We were unable to unify the abstract constant with\n+                // a constant found in the caller bounds, there are\n+                // now three possible cases here.\n+                //\n+                // - The substs are concrete enough that we can simply\n+                //   try and evaluate the given constant.\n+                // - The abstract const still references an inference\n+                //   variable, in this case we return `TooGeneric`.\n+                // - The abstract const references a generic parameter,\n+                //   this means that we emit an error here.\n+                #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+                enum FailureKind {\n+                    MentionsInfer,\n+                    MentionsParam,\n+                    Concrete,\n+                }\n+                let mut failure_kind = FailureKind::Concrete;\n+                walk_abstract_const(tcx, ct, |node| match node {\n+                    Node::Leaf(leaf) => {\n+                        let leaf = leaf.subst(tcx, ct.substs);\n+                        if leaf.has_infer_types_or_consts() {\n+                            failure_kind = FailureKind::MentionsInfer;\n+                        } else if leaf.has_param_types_or_consts() {\n+                            failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                        }\n+                    }\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => (),\n+                });\n+\n+                match failure_kind {\n+                    FailureKind::MentionsInfer => {\n+                        return Err(ErrorHandled::TooGeneric);\n+                    }\n+                    FailureKind::MentionsParam => {\n+                        // FIXME(const_evaluatable_checked): Better error message.\n+                        infcx\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(span, \"unconstrained generic constant\")\n+                            .span_help(\n+                                tcx.def_span(def.did),\n+                                \"consider adding a `where` bound for this expression\",\n+                            )\n+                            .emit();\n+                        return Err(ErrorHandled::Reported(ErrorReported));\n+                    }\n+                    FailureKind::Concrete => {\n+                        // Dealt with below by the same code which handles this\n+                        // without the feature gate.\n+                    }\n+                }\n+            }\n+            None => {\n+                // If we are dealing with a concrete constant, we can\n+                // reuse the old code path and try to evaluate\n+                // the constant.\n             }\n         }\n     }\n@@ -95,7 +162,36 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     }\n \n     debug!(?concrete, \"is_const_evaluatable\");\n-    concrete.map(drop)\n+    match concrete {\n+        Err(ErrorHandled::TooGeneric) if !substs.has_infer_types_or_consts() => {\n+            // FIXME(const_evaluatable_checked): We really should move\n+            // emitting this error message to fulfill instead. For\n+            // now this is easier.\n+            //\n+            // This is not a problem without `const_evaluatable_checked` as\n+            // all `ConstEvaluatable` predicates have to be fulfilled for compilation\n+            // to succeed.\n+            //\n+            // @lcnr: We already emit an error for things like\n+            // `fn test<const N: usize>() -> [0 - N]` eagerly here,\n+            // so until we fix this I don't really care.\n+\n+            let mut err = infcx\n+                .tcx\n+                .sess\n+                .struct_span_err(span, \"constant expression depends on a generic parameter\");\n+            // FIXME(const_generics): we should suggest to the user how they can resolve this\n+            // issue. However, this is currently not actually possible\n+            // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n+            //\n+            // Note that with `feature(const_evaluatable_checked)` this case should not\n+            // be reachable.\n+            err.note(\"this may fail depending on what value the parameter takes\");\n+            err.emit();\n+            Err(ErrorHandled::Reported(ErrorReported))\n+        }\n+        c => c.map(drop),\n+    }\n }\n \n /// A tree representing an anonymous constant.\n@@ -421,6 +517,33 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n+fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F)\n+where\n+    F: FnMut(Node<'tcx>),\n+{\n+    recurse(tcx, ct, &mut f);\n+    fn recurse<'tcx>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, f: &mut dyn FnMut(Node<'tcx>)) {\n+        let root = ct.root();\n+        f(root);\n+        match root {\n+            Node::Leaf(_) => (),\n+            Node::Binop(_, l, r) => {\n+                recurse(tcx, ct.subtree(l), f);\n+                recurse(tcx, ct.subtree(r), f);\n+            }\n+            Node::UnaryOp(_, v) => {\n+                recurse(tcx, ct.subtree(v), f);\n+            }\n+            Node::FunctionCall(func, args) => {\n+                recurse(tcx, ct.subtree(func), f);\n+                for &arg in args {\n+                    recurse(tcx, ct.subtree(arg), f);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Tries to unify two abstract constants using structural equality.\n pub(super) fn try_unify<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "cb3de57cfed079952f2489af638c58582b0b2206", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -745,25 +745,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let violations = self.tcx.object_safety_violations(did);\n                 report_object_safety_error(self.tcx, span, did, violations)\n             }\n-\n             ConstEvalFailure(ErrorHandled::TooGeneric) => {\n-                // In this instance, we have a const expression containing an unevaluated\n-                // generic parameter. We have no idea whether this expression is valid or\n-                // not (e.g. it might result in an error), but we don't want to just assume\n-                // that it's okay, because that might result in post-monomorphisation time\n-                // errors. The onus is really on the caller to provide values that it can\n-                // prove are well-formed.\n-                let mut err = self\n-                    .tcx\n-                    .sess\n-                    .struct_span_err(span, \"constant expression depends on a generic parameter\");\n-                // FIXME(const_generics): we should suggest to the user how they can resolve this\n-                // issue. However, this is currently not actually possible\n-                // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n-                err.note(\"this may fail depending on what value the parameter takes\");\n-                err\n+                bug!(\"too generic should have been handled in `is_const_evaluatable`\");\n             }\n-\n             // Already reported in the query.\n             ConstEvalFailure(ErrorHandled::Reported(ErrorReported)) => {\n                 // FIXME(eddyb) remove this once `ErrorReported` becomes a proof token."}, {"sha": "8586a550230f9ae03cbe03929fd5e1887d6f989f", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -496,6 +496,13 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         obligation.cause.span,\n                     ) {\n                         Ok(()) => ProcessResult::Changed(vec![]),\n+                        Err(ErrorHandled::TooGeneric) => {\n+                            pending_obligation.stalled_on = substs\n+                                .iter()\n+                                .filter_map(|ty| TyOrConstInferVar::maybe_from_generic_arg(ty))\n+                                .collect();\n+                            ProcessResult::Unchanged\n+                        }\n                         Err(e) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(e))),\n                     }\n                 }\n@@ -537,8 +544,10 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                                 Err(ErrorHandled::TooGeneric) => {\n                                     stalled_on.append(\n                                         &mut substs\n-                                            .types()\n-                                            .filter_map(|ty| TyOrConstInferVar::maybe_from_ty(ty))\n+                                            .iter()\n+                                            .filter_map(|arg| {\n+                                                TyOrConstInferVar::maybe_from_generic_arg(arg)\n+                                            })\n                                             .collect(),\n                                     );\n                                     Err(ErrorHandled::TooGeneric)"}, {"sha": "e3a4d9a96aa1e3efe49be314fa05c5a2cb1e1760", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -5,10 +5,10 @@ extern crate const_evaluatable_lib;\n \n fn user<T>() {\n     let _ = const_evaluatable_lib::test1::<T>();\n-    //~^ ERROR constant expression depends\n-    //~| ERROR constant expression depends\n-    //~| ERROR constant expression depends\n-    //~| ERROR constant expression depends\n+    //~^ ERROR unconstrained generic constant\n+    //~| ERROR unconstrained generic constant\n+    //~| ERROR unconstrained generic constant\n+    //~| ERROR unconstrained generic constant\n }\n \n fn main() {}"}, {"sha": "8a298b47fffa72a913431a3c017cae2d2af81bc3", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.stderr", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -1,54 +1,50 @@\n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |          ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n-   |                           ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |          ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant expression depends on a generic parameter\n+error: unconstrained generic constant\n   --> $DIR/cross_crate_predicate.rs:7:13\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n-   |                           ---------------------------- required by this bound in `test1`\n+help: consider adding a `where` bound for this expression\n+  --> $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-   = note: this may fail depending on what value the parameter takes\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "cad06ea4004aff7176e291622f6d2cc3e8b0df45", "filename": "src/test/ui/const-generics/const_evaluatable_checked/infer-too-generic.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Finfer-too-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Finfer-too-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Finfer-too-generic.rs?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+use std::{mem, ptr};\n+\n+fn split_first<T, const N: usize>(arr: [T; N]) -> (T, [T; N - 1])\n+where\n+    [T; N - 1]: Sized,\n+{\n+    let arr = mem::ManuallyDrop::new(arr);\n+    unsafe {\n+        let head = ptr::read(&arr[0]);\n+        let tail = ptr::read(&arr[1..] as *const [T] as *const [T; N - 1]);\n+        (head, tail)\n+    }\n+}\n+\n+fn main() {\n+    let arr = [0, 1, 2, 3, 4];\n+    let (head, tail) = split_first(arr);\n+    assert_eq!(head, 0);\n+    assert_eq!(tail, [1, 2, 3, 4]);\n+}"}, {"sha": "9fdbbff66e9e90440436dec66f49cbd715196db9", "filename": "src/test/ui/const-generics/issues/issue-76595.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -14,5 +14,4 @@ fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n fn main() {\n     test::<2>();\n     //~^ ERROR wrong number of type\n-    //~| ERROR constant expression depends\n }"}, {"sha": "f258d2977186f824cfeb3b2e5ed576d5c347b7fc", "filename": "src/test/ui/const-generics/issues/issue-76595.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f23559451b0dc5181d73ddd89657266d4e150b6a/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr?ref=f23559451b0dc5181d73ddd89657266d4e150b6a", "patch": "@@ -4,17 +4,6 @@ error[E0107]: wrong number of type arguments: expected 1, found 0\n LL |     test::<2>();\n    |     ^^^^^^^^^ expected 1 type argument\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/issue-76595.rs:15:5\n-   |\n-LL | fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n-   |                                         ------------------------------- required by this bound in `test`\n-...\n-LL |     test::<2>();\n-   |     ^^^^^^^^^\n-   |\n-   = note: this may fail depending on what value the parameter takes\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0107`."}]}