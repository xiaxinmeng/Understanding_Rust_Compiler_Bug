{"sha": "0b53744f2d7e0694cd7207cca632fd6de1dc5bff", "node_id": "C_kwDOAAsO6NoAKDBiNTM3NDRmMmQ3ZTA2OTRjZDcyMDdjY2E2MzJmZDZkZTFkYzViZmY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-22T18:46:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-22T18:46:12Z"}, "message": "Merge #11461\n\n11461: Extract struct from enum variant filters generics r=jo-goro a=jo-goro\n\nFixes #11452.\r\n\r\nThis PR updates extract_struct_from_enum_variant. Extracting a struct `A` form an enum like\r\n```rust\r\nenum X<'a, 'b> {\r\n    A { a: &'a () },\r\n    B { b: &'b () },\r\n}\r\n```\r\nwill now be correctly generated as\r\n```rust\r\nstruct A<'a> { a: &'a () }\r\n\r\nenum X<'a, 'b> {\r\n    A(A<'a>),\r\n    B { b: &'b () },\r\n}\r\n```\r\ninstead of the previous\r\n```rust\r\nstruct A<'a, 'b>{ a: &'a () } // <- should not have 'b\r\n\r\nenum X<'a, 'b> {\r\n    A(A<'a, 'b>),\r\n    B { b: &'b () },\r\n}\r\n```\r\n\r\nThis also works for generic type parameters and const generics.\r\n\r\nBounds are also copied, however I have not yet implemented a filter for unneeded bounds. Extracting `B` from the following enum\r\n```rust\r\nenum X<'a, 'b: 'a> {\r\n    A { a: &'a () },\r\n    B { b: &'b () },\r\n}\r\n```\r\nwill be generated as \r\n```rust\r\nstruct B<'b: 'a> { b: &'b () } // <- should be `struct B<'b> { b: &'b () }`\r\n\r\nenum X<'a, 'b: 'a> {\r\n    A { a: &'a () },\r\n    B(B<'b>),\r\n}\r\n```\r\n\r\nExtracting bounds with where clauses is also still not implemented.\n\nCo-authored-by: Jonas Goronczy <goronczy.jonas@gmail.com>", "tree": {"sha": "8a9d1f752fdebad3b3d97836a1f455d604372f15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a9d1f752fdebad3b3d97836a1f455d604372f15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b53744f2d7e0694cd7207cca632fd6de1dc5bff", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiFS90CRBK7hj4Ov3rIwAAlxwIADiXWlOiQ4hTecgy1O8tfzjQ\nIVP0UqTD00FVpPx7VfaJjVsf3aFssEtMjQ5k6u8ziszP8NhBYZUwrP+IUQZAk1D8\n1D8+fNfXJZDZtf2STGv5L4gAClkD24XIfhJQpVZD8Th8UZsSimACrsQMZT7QK9tf\nlE81b6JxxOfEsoVHIrXDVJyZvS/XQsO4Vh1jdiG0lmmWy/N21oWt8n2N6ic6wo8O\nId/3rwtwtrWYEqtAbN7QaO1rFaALRmbUB79hrlsZtc6jKwr95srTsaIdf9EgEJYo\nHInQMvWwL9KBNaCVfvwY8+hWQTZ4xMvPxQVJzaYIX9sNbqWZss5fLI5yWrBCMtY=\n=n9LE\n-----END PGP SIGNATURE-----\n", "payload": "tree 8a9d1f752fdebad3b3d97836a1f455d604372f15\nparent 033f91e75d515936cfc0cc529b121f1ca3792179\nparent 0db0dec9993b510efeb61cb1d8ff113270d4ca51\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645555572 +0000\ncommitter GitHub <noreply@github.com> 1645555572 +0000\n\nMerge #11461\n\n11461: Extract struct from enum variant filters generics r=jo-goro a=jo-goro\n\nFixes #11452.\r\n\r\nThis PR updates extract_struct_from_enum_variant. Extracting a struct `A` form an enum like\r\n```rust\r\nenum X<'a, 'b> {\r\n    A { a: &'a () },\r\n    B { b: &'b () },\r\n}\r\n```\r\nwill now be correctly generated as\r\n```rust\r\nstruct A<'a> { a: &'a () }\r\n\r\nenum X<'a, 'b> {\r\n    A(A<'a>),\r\n    B { b: &'b () },\r\n}\r\n```\r\ninstead of the previous\r\n```rust\r\nstruct A<'a, 'b>{ a: &'a () } // <- should not have 'b\r\n\r\nenum X<'a, 'b> {\r\n    A(A<'a, 'b>),\r\n    B { b: &'b () },\r\n}\r\n```\r\n\r\nThis also works for generic type parameters and const generics.\r\n\r\nBounds are also copied, however I have not yet implemented a filter for unneeded bounds. Extracting `B` from the following enum\r\n```rust\r\nenum X<'a, 'b: 'a> {\r\n    A { a: &'a () },\r\n    B { b: &'b () },\r\n}\r\n```\r\nwill be generated as \r\n```rust\r\nstruct B<'b: 'a> { b: &'b () } // <- should be `struct B<'b> { b: &'b () }`\r\n\r\nenum X<'a, 'b: 'a> {\r\n    A { a: &'a () },\r\n    B(B<'b>),\r\n}\r\n```\r\n\r\nExtracting bounds with where clauses is also still not implemented.\n\nCo-authored-by: Jonas Goronczy <goronczy.jonas@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b53744f2d7e0694cd7207cca632fd6de1dc5bff", "html_url": "https://github.com/rust-lang/rust/commit/0b53744f2d7e0694cd7207cca632fd6de1dc5bff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b53744f2d7e0694cd7207cca632fd6de1dc5bff/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "033f91e75d515936cfc0cc529b121f1ca3792179", "url": "https://api.github.com/repos/rust-lang/rust/commits/033f91e75d515936cfc0cc529b121f1ca3792179", "html_url": "https://github.com/rust-lang/rust/commit/033f91e75d515936cfc0cc529b121f1ca3792179"}, {"sha": "0db0dec9993b510efeb61cb1d8ff113270d4ca51", "url": "https://api.github.com/repos/rust-lang/rust/commits/0db0dec9993b510efeb61cb1d8ff113270d4ca51", "html_url": "https://github.com/rust-lang/rust/commit/0db0dec9993b510efeb61cb1d8ff113270d4ca51"}], "stats": {"total": 232, "additions": 203, "deletions": 29}, "files": [{"sha": "1cdd4187af4e6d48c0bb10a3f5f8a3fcc5f9e4e0", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 203, "deletions": 29, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/0b53744f2d7e0694cd7207cca632fd6de1dc5bff/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b53744f2d7e0694cd7207cca632fd6de1dc5bff/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=0b53744f2d7e0694cd7207cca632fd6de1dc5bff", "patch": "@@ -11,15 +11,14 @@ use ide_db::{\n     search::FileReference,\n     RootDatabase,\n };\n-use itertools::Itertools;\n+use itertools::{Itertools, Position};\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{\n         self, edit::IndentLevel, edit_in_place::Indent, make, AstNode, HasAttrs, HasGenericParams,\n-        HasName, HasTypeBounds, HasVisibility,\n+        HasName, HasVisibility,\n     },\n-    match_ast,\n-    ted::{self, Position},\n+    match_ast, ted, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxNode, T,\n };\n@@ -106,7 +105,12 @@ pub(crate) fn extract_struct_from_enum_variant(\n             }\n \n             let indent = enum_ast.indent_level();\n-            let def = create_struct_def(variant_name.clone(), &variant, &field_list, &enum_ast);\n+            let generic_params = enum_ast\n+                .generic_param_list()\n+                .and_then(|known_generics| extract_generic_params(&known_generics, &field_list));\n+            let generics = generic_params.as_ref().map(|generics| generics.clone_for_update());\n+            let def =\n+                create_struct_def(variant_name.clone(), &variant, &field_list, generics, &enum_ast);\n             def.reindent_to(indent);\n \n             let start_offset = &variant.parent_enum().syntax().clone();\n@@ -118,7 +122,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 ],\n             );\n \n-            update_variant(&variant, enum_ast.generic_param_list());\n+            update_variant(&variant, generic_params.map(|g| g.clone_for_update()));\n         },\n     )\n }\n@@ -159,10 +163,77 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n         .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n+fn extract_generic_params(\n+    known_generics: &ast::GenericParamList,\n+    field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n+) -> Option<ast::GenericParamList> {\n+    let mut generics = known_generics.generic_params().map(|param| (param, false)).collect_vec();\n+\n+    let tagged_one = match field_list {\n+        Either::Left(field_list) => field_list\n+            .fields()\n+            .filter_map(|f| f.ty())\n+            .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),\n+        Either::Right(field_list) => field_list\n+            .fields()\n+            .filter_map(|f| f.ty())\n+            .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),\n+    };\n+\n+    let generics = generics.into_iter().filter_map(|(param, tag)| tag.then(|| param));\n+    tagged_one.then(|| make::generic_param_list(generics))\n+}\n+\n+fn tag_generics_in_variant(ty: &ast::Type, generics: &mut [(ast::GenericParam, bool)]) -> bool {\n+    let mut tagged_one = false;\n+\n+    for token in ty.syntax().descendants_with_tokens().filter_map(SyntaxElement::into_token) {\n+        for (param, tag) in generics.iter_mut().filter(|(_, tag)| !tag) {\n+            match param {\n+                ast::GenericParam::LifetimeParam(lt)\n+                    if matches!(token.kind(), T![lifetime_ident]) =>\n+                {\n+                    if let Some(lt) = lt.lifetime() {\n+                        if lt.text().as_str() == token.text() {\n+                            *tag = true;\n+                            tagged_one = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                param if matches!(token.kind(), T![ident]) => {\n+                    if match param {\n+                        ast::GenericParam::ConstParam(konst) => konst\n+                            .name()\n+                            .map(|name| name.text().as_str() == token.text())\n+                            .unwrap_or_default(),\n+                        ast::GenericParam::TypeParam(ty) => ty\n+                            .name()\n+                            .map(|name| name.text().as_str() == token.text())\n+                            .unwrap_or_default(),\n+                        ast::GenericParam::LifetimeParam(lt) => lt\n+                            .lifetime()\n+                            .map(|lt| lt.text().as_str() == token.text())\n+                            .unwrap_or_default(),\n+                    } {\n+                        *tag = true;\n+                        tagged_one = true;\n+                        break;\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    tagged_one\n+}\n+\n fn create_struct_def(\n     variant_name: ast::Name,\n     variant: &ast::Variant,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n+    generics: Option<ast::GenericParamList>,\n     enum_: &ast::Enum,\n ) -> ast::Struct {\n     let enum_vis = enum_.visibility();\n@@ -204,9 +275,7 @@ fn create_struct_def(\n \n     field_list.reindent_to(IndentLevel::single());\n \n-    // FIXME: This uses all the generic params of the enum, but the variant might not use all of them.\n-    let strukt = make::struct_(enum_vis, variant_name, enum_.generic_param_list(), field_list)\n-        .clone_for_update();\n+    let strukt = make::struct_(enum_vis, variant_name, generics, field_list).clone_for_update();\n \n     // FIXME: Consider making this an actual function somewhere (like in `AttrsOwnerEdit`) after some deliberation\n     let attrs_and_docs = |node: &SyntaxNode| {\n@@ -233,36 +302,53 @@ fn create_struct_def(\n             _ => tok,\n         })\n         .collect();\n-    ted::insert_all(Position::first_child_of(strukt.syntax()), variant_attrs);\n+    ted::insert_all(ted::Position::first_child_of(strukt.syntax()), variant_attrs);\n \n     // copy attributes from enum\n     ted::insert_all(\n-        Position::first_child_of(strukt.syntax()),\n+        ted::Position::first_child_of(strukt.syntax()),\n         enum_.attrs().map(|it| it.syntax().clone_for_update().into()).collect(),\n     );\n     strukt\n }\n \n-fn update_variant(variant: &ast::Variant, generic: Option<ast::GenericParamList>) -> Option<()> {\n+fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList>) -> Option<()> {\n     let name = variant.name()?;\n-    let ty = match generic {\n-        // FIXME: This uses all the generic params of the enum, but the variant might not use all of them.\n-        Some(gpl) => {\n-            let gpl = gpl.clone_for_update();\n-            gpl.generic_params().for_each(|gp| {\n-                let tbl = match gp {\n-                    ast::GenericParam::LifetimeParam(it) => it.type_bound_list(),\n-                    ast::GenericParam::TypeParam(it) => it.type_bound_list(),\n-                    ast::GenericParam::ConstParam(_) => return,\n-                };\n-                if let Some(tbl) = tbl {\n-                    tbl.remove();\n+    let ty = generics\n+        .filter(|generics| generics.generic_params().count() > 0)\n+        .map(|generics| {\n+            let mut generic_str = String::with_capacity(8);\n+\n+            for (p, more) in generics.generic_params().with_position().map(|p| match p {\n+                Position::First(p) | Position::Middle(p) => (p, true),\n+                Position::Last(p) | Position::Only(p) => (p, false),\n+            }) {\n+                match p {\n+                    ast::GenericParam::ConstParam(konst) => {\n+                        if let Some(name) = konst.name() {\n+                            generic_str.push_str(name.text().as_str());\n+                        }\n+                    }\n+                    ast::GenericParam::LifetimeParam(lt) => {\n+                        if let Some(lt) = lt.lifetime() {\n+                            generic_str.push_str(lt.text().as_str());\n+                        }\n+                    }\n+                    ast::GenericParam::TypeParam(ty) => {\n+                        if let Some(name) = ty.name() {\n+                            generic_str.push_str(name.text().as_str());\n+                        }\n+                    }\n                 }\n-            });\n-            make::ty(&format!(\"{}<{}>\", name.text(), gpl.generic_params().join(\", \")))\n-        }\n-        None => make::ty(&name.text()),\n-    };\n+                if more {\n+                    generic_str.push_str(\", \");\n+                }\n+            }\n+\n+            make::ty(&format!(\"{}<{}>\", &name.text(), &generic_str))\n+        })\n+        .unwrap_or_else(|| make::ty(&name.text()));\n+\n     let tuple_field = make::tuple_field(None, ty);\n     let replacement = make::variant(\n         name,\n@@ -902,4 +988,92 @@ enum A { $0One(u8, u32) }\n     fn test_extract_not_applicable_no_field_named() {\n         check_assist_not_applicable(extract_struct_from_enum_variant, r\"enum A { $0None {} }\");\n     }\n+\n+    #[test]\n+    fn test_extract_struct_only_copies_needed_generics() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum X<'a, 'b, 'x> {\n+    $0A { a: &'a &'x mut () },\n+    B { b: &'b () },\n+    C { c: () },\n+}\n+\"#,\n+            r#\"\n+struct A<'a, 'x>{ a: &'a &'x mut () }\n+\n+enum X<'a, 'b, 'x> {\n+    A(A<'a, 'x>),\n+    B { b: &'b () },\n+    C { c: () },\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_with_liftime_type_const() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum X<'b, T, V, const C: usize> {\n+    $0A { a: T, b: X<'b>, c: [u8; C] },\n+    D { d: V },\n+}\n+\"#,\n+            r#\"\n+struct A<'b, T, const C: usize>{ a: T, b: X<'b>, c: [u8; C] }\n+\n+enum X<'b, T, V, const C: usize> {\n+    A(A<'b, T, C>),\n+    D { d: V },\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_without_generics() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum X<'a, 'b> {\n+    A { a: &'a () },\n+    B { b: &'b () },\n+    $0C { c: () },\n+}\n+\"#,\n+            r#\"\n+struct C{ c: () }\n+\n+enum X<'a, 'b> {\n+    A { a: &'a () },\n+    B { b: &'b () },\n+    C(C),\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_keeps_trait_bounds() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum En<T: TraitT, V: TraitV> {\n+    $0A { a: T },\n+    B { b: V },\n+}\n+\"#,\n+            r#\"\n+struct A<T: TraitT>{ a: T }\n+\n+enum En<T: TraitT, V: TraitV> {\n+    A(A<T>),\n+    B { b: V },\n+}\n+\"#,\n+        );\n+    }\n }"}]}