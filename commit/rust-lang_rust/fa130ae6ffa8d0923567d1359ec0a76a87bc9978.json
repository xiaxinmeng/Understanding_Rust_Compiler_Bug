{"sha": "fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMTMwYWU2ZmZhOGQwOTIzNTY3ZDEzNTllYzBhNzZhODdiYzk5Nzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:26:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:26:18Z"}, "message": "rollup merge of #20330: fhahn/issue-15877-model-lexer-range-2\n\nThis patch resolves the second problem mentioned in #15877: function calls to integers, e.g. `3.b()`.\n\n It does so, by checking whether the character following the first dot of a FLOAT_LIT is a character or an underscore (these should denote a valid identifier). This does not look like a particularly, but it seems like a lookahead of 1 is needed for this distinction.\n\nAnother interesting aspect are ranges that start with a integer constant, but end with a function call, e.g. `1..b()`. Rust treats this as a range from 1 to `b()`, but given that `1.` is a valid FLOAT_LIT, `1..b()` could be a function call to a float as well.\n\ncc @cmr", "tree": {"sha": "c8b9dfa3d10038c9e33b2f24db8036498a84c0b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8b9dfa3d10038c9e33b2f24db8036498a84c0b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "html_url": "https://github.com/rust-lang/rust/commit/fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecf48fb4694c84c3f07f9eb97d519de0d08a79ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf48fb4694c84c3f07f9eb97d519de0d08a79ba", "html_url": "https://github.com/rust-lang/rust/commit/ecf48fb4694c84c3f07f9eb97d519de0d08a79ba"}, {"sha": "1e278c1cd1307d06d57c556676e3035516334d2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e278c1cd1307d06d57c556676e3035516334d2d", "html_url": "https://github.com/rust-lang/rust/commit/1e278c1cd1307d06d57c556676e3035516334d2d"}], "stats": {"total": 81, "additions": 77, "deletions": 4}, "files": [{"sha": "1f7923e1caff2b81fa9e0fb9af3be99bc52249a9", "filename": "src/grammar/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/src%2Fgrammar%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/src%2Fgrammar%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FREADME.md?ref=fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "patch": "@@ -1,7 +1,7 @@\n Reference grammar.\n \n Uses [antlr4](http://www.antlr.org/) and a custom Rust tool to compare\n-ASTs/token streams generated. You can use the `check-syntax` make target to\n+ASTs/token streams generated. You can use the `check-lexer` make target to\n run all of the available tests.\n \n To use manually:\n@@ -12,7 +12,7 @@ javac *.java\n rustc -O verify.rs\n for file in ../*/**.rs; do\n     echo $file;\n-    grun RustLexer tokens -tokens < $file | ./verify $file || break\n+    grun RustLexer tokens -tokens < $file | ./verify $file RustLexer.tokens || break\n done\n ```\n "}, {"sha": "88de5db41fe7b555369e2ff6e595e8bda6e8c650", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "patch": "@@ -112,8 +112,64 @@ LIT_INTEGER\n   ;\n \n LIT_FLOAT\n-  : [0-9][0-9_]* ( '.' {_input.LA(1) != '.'}?\n-                 | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n+  : [0-9][0-9_]* ('.' {\n+        /* dot followed by another dot is a range, no float */\n+        _input.LA(1) != '.' &&\n+        /* dot followed by an identifier is an integer with a function call, no float */\n+        _input.LA(1) != '_' &&\n+        _input.LA(1) != 'a' &&\n+        _input.LA(1) != 'b' &&\n+        _input.LA(1) != 'c' &&\n+        _input.LA(1) != 'd' &&\n+        _input.LA(1) != 'e' &&\n+        _input.LA(1) != 'f' &&\n+        _input.LA(1) != 'g' &&\n+        _input.LA(1) != 'h' &&\n+        _input.LA(1) != 'i' &&\n+        _input.LA(1) != 'j' &&\n+        _input.LA(1) != 'k' &&\n+        _input.LA(1) != 'l' &&\n+        _input.LA(1) != 'm' &&\n+        _input.LA(1) != 'n' &&\n+        _input.LA(1) != 'o' &&\n+        _input.LA(1) != 'p' &&\n+        _input.LA(1) != 'q' &&\n+        _input.LA(1) != 'r' &&\n+        _input.LA(1) != 's' &&\n+        _input.LA(1) != 't' &&\n+        _input.LA(1) != 'u' &&\n+        _input.LA(1) != 'v' &&\n+        _input.LA(1) != 'w' &&\n+        _input.LA(1) != 'x' &&\n+        _input.LA(1) != 'y' &&\n+        _input.LA(1) != 'z' &&\n+        _input.LA(1) != 'A' &&\n+        _input.LA(1) != 'B' &&\n+        _input.LA(1) != 'C' &&\n+        _input.LA(1) != 'D' &&\n+        _input.LA(1) != 'E' &&\n+        _input.LA(1) != 'F' &&\n+        _input.LA(1) != 'G' &&\n+        _input.LA(1) != 'H' &&\n+        _input.LA(1) != 'I' &&\n+        _input.LA(1) != 'J' &&\n+        _input.LA(1) != 'K' &&\n+        _input.LA(1) != 'L' &&\n+        _input.LA(1) != 'M' &&\n+        _input.LA(1) != 'N' &&\n+        _input.LA(1) != 'O' &&\n+        _input.LA(1) != 'P' &&\n+        _input.LA(1) != 'Q' &&\n+        _input.LA(1) != 'R' &&\n+        _input.LA(1) != 'S' &&\n+        _input.LA(1) != 'T' &&\n+        _input.LA(1) != 'U' &&\n+        _input.LA(1) != 'V' &&\n+        _input.LA(1) != 'W' &&\n+        _input.LA(1) != 'X' &&\n+        _input.LA(1) != 'Y' &&\n+        _input.LA(1) != 'Z'\n+  }? | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n   ;\n \n LIT_STR"}, {"sha": "cb269bbdb0ade0dc343bc3513bc9ce82698a0119", "filename": "src/grammar/check.sh", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/src%2Fgrammar%2Fcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fa130ae6ffa8d0923567d1359ec0a76a87bc9978/src%2Fgrammar%2Fcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fcheck.sh?ref=fa130ae6ffa8d0923567d1359ec0a76a87bc9978", "patch": "@@ -11,6 +11,10 @@ if [ \"${VERBOSE}\" == \"1\" ]; then\n     set -x\n fi\n \n+passed=0\n+failed=0\n+skipped=0\n+\n check() {\n     grep --silent \"// ignore-lexer-test\" $1;\n \n@@ -21,14 +25,27 @@ check() {\n         # seem to have anny effect.\n         if $3 RustLexer tokens -tokens < $1 | $4 $1 $5; then\n             echo \"pass: $1\"\n+            passed=`expr $passed + 1`\n         else\n             echo \"fail: $1\"\n+            failed=`expr $failed + 1`\n         fi\n     else\n         echo \"skip: $1\"\n+        skipped=`expr $skipped + 1`\n     fi\n }\n \n for file in $(find $1 -iname '*.rs' ! -path '*/test/compile-fail*'); do\n     check $file $2 $3 $4 $5\n done\n+\n+printf \"\\ntest result: \"\n+\n+if [ $failed -eq 0 ]; then\n+    printf \"ok. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n+else\n+    printf \"failed. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n+    exit 1\n+fi\n+"}]}